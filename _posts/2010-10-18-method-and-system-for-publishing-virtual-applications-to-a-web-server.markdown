---

title: Method and system for publishing virtual applications to a web server
abstract: A method and system for publishing virtual applications on the Internet. The method includes obtaining a list of applications associated with a publisher from a server computing device and displaying the list to a user via a user interface. Next, a selection by the user of one of the applications is received from the user interface. A new virtualized version of the selected application is built. The virtualized version includes at least one application file that at least partially implements the new virtualized version of the selected application. Then, the application file is uploaded to the server computing device. An application address is received from the server computing device and a link to the application address is displayed to the user via the user interface. The virtualized version of the application is available at the application address for download and execution over a network (e.g., the Internet).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09021015&OS=09021015&RS=09021015
owner: Code Systems Corporation
number: 09021015
owner_city: Seattle
owner_country: US
publication_date: 20101018
---
The present invention is directed generally to methods and systems for publishing application files on a server to be distributed thereby and more particularly to systems and methods of publishing virtualized application files on a web server for distribution thereby over the Internet.

A virtual application is a virtual machine image pre configured with all of the files registry data settings components runtimes and other dependencies required for a specific application to execute immediately and without installation on a host computing device. The virtual application is partially isolated from other applications implemented on a host computing device and partially isolated from an underlying host operating system installed and executing on the host computing device. The virtual application is encapsulated from the host operating system by a virtual runtime environment which includes a virtual operating system that receives operations performed by the virtualized application and redirects them to one or more virtualized locations e.g. a virtual filesystem virtual registry and the like .

Thus the virtual application may be conceptualized as including two components a virtualization runtime and a virtual application configuration. The virtualization runtime implements the virtual runtime environment which implements various operating system application programming interfaces APIs in such a way that allows the executing virtual application to access and interact with items that may not be present on the host computer. The virtual application configuration includes data necessary to implement the virtual application within the virtualization runtime.

The virtual application is stored in and implemented by one or more data files and or executable files. Depending upon the implementation details the one or more data files and or executable files storing and implementing the virtual application may include blocks of data corresponding to each application file of a natively installed version of the application. Herein these blocks of data will be referred to as virtual application files. The one or more data files and or executable files storing and implementing the virtual application also include configuration information.

The data files and or executable files are configured to execute within a virtual runtime environment that is provided at least in part by the virtual operating system. When the virtual application is executed within the virtual runtime engine the configuration information is used to configure the virtual operating system to execute the virtual application. For example the configuration information may contain information related to the virtual application files virtual registry entries environment variables services and the like. The virtual operating system is configured to communicate with the host operating system as required to execute the virtual application on the host computing device.

To publish a virtual application to a server e.g. a web server to be downloaded and or executed by others a user e.g. an application publisher must store copies of the data files and or executable files implementing the virtual application within a virtual runtime environment to the server. Therefore a need exists for a method and system configured to assist the user with uploading one or more data files and or executable files to the server. The present application provides these and other advantages as will be apparent from the following detailed description and accompanying figures.

In the embodiment illustrated the server computing device functions as an upload server receiving the application to be published from the client computing device . The server computing device copies the application to the server computing device which functions as a website server. The server computing device generates a website see from which the application may be downloaded and or executed e.g. by the client computing device . Optionally execution of the downloaded application may be profiled to generate one or more transcripts that may be used to generate a streaming model.

The server computing devices and are each connected to an Account Database and an Application Library Database . While illustrated as separate databases as is apparent to those of ordinary skill in the art the Account and Application Library Databases and may be implemented in the same database. Further the Account and Application Library Databases and may be implemented on one or more computing devices not shown .

The Account Database stores information related to each user account. The Application Library Database stores information related to each application uploaded to the server computing device .

The system may be used to distribute application files e.g. virtualized application files . Further the system may be used to track application versions and make different versions of a particular application available to users.

A diagram of hardware and an operating environment in conjunction with which implementations of the server computing device the server computing device the client computing device the client computing device the Account Database the Application Library Database and the network may be practiced is provided in and described below.

A virtual application may be implemented as an executable virtualized application file or an xlayer file configured to execute within a virtualized environment provided by a virtual machine or a virtual runtime engine . The executable virtualized application file and the xlayer file may each be characterized as being a virtualized application file. illustrates a virtual application A implemented by the execution of the xlayer file by the virtual runtime engine . also illustrates a virtual application B implemented by the execution of the executable virtualized application file . The virtual runtime engine may execute within an operating system shell process.

U.S. patent application Ser. No. 12 697 029 filed on Mar. 31 2010 entitled Method and System for Improving Startup Performance and Interoperability of a Virtual Application which is incorporated herein by reference in its entirety describes a file format that may be used to configure the xlayer file . The virtualized application file and the xlayer file may each be implemented as a binary file.

Depending upon the implementation details the xlayer file may include publisher information application information and version information including revision information . The version information may have four components a major version a minor version a build version and a revision number. Patches to a particular application may be identified by the build version and the revision number components. The xlayer file may also include additional information such as domain information.

The system memory A may store one or more files implementing one or more virtual runtime engines. By way of a non limiting example the system memory A may include a plurality of virtual machine executable files that when executed each implements a different virtual machine. For example each of the virtual machine executable files may implement a different version of the same virtual machine. The virtual machine executable files may be executed individually. When executed a virtual machine executable file implements a virtualized environment.

A natively installed version of an application is configured to execute within a runtime environment provided at least in part by the host operating system A. Typically to execute within the runtime environment provided at least in part by the host operating system A the natively installed version of the application modifies the configuration and settings of the host operating system A. For example the natively installed version may install dynamic link libraries or change registry settings of the host operating system A. In contrast a virtual version of the same application may be executed on the host operating system A without installation on the host operating system A. On the other hand the virtual applications A and B do not modify the configuration or settings of the host operating system A. For example to execute the virtual applications A and B dynamic link libraries dlls data files registry settings environment variables and the like need not be modified on to the host operating system A.

The virtualized application file may include components necessary to implement a virtual runtime environment including a virtual operating system B configured to execute in the operating system A of the client computing device illustrated in . Similarly the virtual runtime engine includes components necessary to implement a virtual runtime environment including a virtual operating system A configured to execute in the operating system A of the client computing device illustrated in . The virtual operating systems A and B are configured to intercept calls to the host operating system A and route them to corresponding components of the virtual operating systems A and B respectively. The virtual operating systems A and B may also route some requests and actions to the host operating system A and B respectively for processing.

In the embodiment illustrated in the virtualized application file and the xlayer file each implement a virtualized version of the application . U.S. patent application Ser. No. 12 188 155 filed on Aug. 7 2008 U.S. patent application Ser. No. 12 188 161 filed on Aug. 7 2008 and U.S. patent application Ser. No. 12 685 576 filed on Jan. 11 2010 all of which are incorporated herein by reference in their entireties disclose systems that may be used to create and configure the virtualized application file and or the xlayer file . As described in greater detail in U.S. patent application Ser. Nos. 12 188 155 12 188 161 and 12 685 576 a virtual application constructor or authoring tool may use an application template that includes copies of files such as a configuration file application files A C and the like to configure the virtualized application file or the xlayer file . However the template is not a requirement. Instead the authoring tool needs only the configuration file and copies of any applications files A C necessary for a natively installed version of the application to execute to build the virtualized application file or the xlayer file . The applications files A C and the configuration file are referred to collectively as an application configuration . The authoring tool may combine the application configuration and the components of the virtual runtime engine e.g. the virtual operating system to construct or build the executable virtualized application file . Alternatively the authoring tool may use the application configuration to build the xlayer file . As described in U.S. patent application Ser. Nos. 12 188 155 and 12 188 161 the application configuration may be created using a snapshot technique or other process e.g. manually specifying the application configuration operable to capture the application configuration based on the application .

The authoring tool includes a wizard tool operable to communicate with the server computing device which functions as an upload server for the purposes of publishing a virtual application e.g. one of the publishing virtual applications A and B on the website see generated by the server computing device which functions as an website server .

Depending upon the implementation details the process of publishing a virtual application e.g. one of the publishing virtual applications A and B to the server computing device may include 1 creating a publisher account 2 adding information related to the virtual application e.g. configuration information to the Application Library Database see and 3 uploading the file referred to as a file to be published to the server computing device see . The wizard may walk the user through this process. The file to be published may be the virtualized application file and or the xlayer file . Thus the wizard tool is operable to transfer the virtualized application file and or the xlayer file to the server computing device . For ease of illustration after the file to be published has been transferred by the wizard tool to the server computing device the file to be published will be referred to as an uploaded file see . While the file to be published is described above as being either the virtualized application file or the xlayer file the file to be published may be any application file a user wishes to publish to the website see .

The wizard tool is also operable to receive input from a user and forward that information to the server computing device . The input received includes user account information e.g. user name password etc. and information related to or associated with the file to be published e.g. application name application version etc. .

As mentioned above the server computing device transfers or copies the uploaded file see to the server computing device . The server computing device which functions as an upload server is further operable to communicate with the Account Database for the purposes of obtaining and storing information related to the user account associated with the uploaded file see . The server computing device is also operable to communicate with the Application Library Database for the purposes of obtaining and storing information related to the uploaded file see and the virtual application s associated therewith.

The server computing device is operable to generate the website see including a link for each of the uploaded files e.g. the uploaded file illustrated in . Other computing devices e.g. the client computing device illustrated in may navigate to the website see and select the links to thereby download and or execute the uploaded files.

While illustrated as being outside the filesystem A those of ordinary skill in the art appreciate that the executable virtualized application file the xlayer file the application configuration the application the virtual machine files and the authoring tool may be conceptualized as being within the filesystem A.

The system memory B also stores application library web services components configured to communicate with the Account and Application Library Databases and e.g. using Structured Query Language SQL and perform other functions described below. The wizard communicates with the web server components A which access the application library web services components requested by the wizard . While illustrated as being outside the filesystem B those of ordinary skill in the art appreciate that the uploaded file the web server components A and the application library web services components may be conceptualized as being within the filesystem B.

Virtual machine files are also stored in the system memory D. The virtual machine files may be substantially identical to the virtual machine files stored in the system memory A see . Execution of a virtual machine file e.g. one of the virtual machine files may be initiated by the Sandbox Manager using a command including a parameter e.g. a file path identifying a virtualized application file to execute. The virtualized application file may include a downloaded copy of the xlayer file or a portion thereof sufficient to initiate execution. In response to receiving the parameter the virtual machine executable file executes the identified virtualized application file inside the virtualized environment implemented by the virtual machine executable file.

Together the Client Application and the Sandbox Manager may download and or execute a virtual application. In embodiments in which the Client Application includes the plug in a user may click on a link or otherwise select an application file displayed on the website see for download and or execution. The website or selection of the application file launches the plug in which established the communication link with the Sandbox Manager . The Sandbox Manager identifies which of the virtual machine files is configured to execute the virtual runtime engine that is configured to execute the application file selected by the user and launches the virtual machine file identified. The Sandbox Manager determines whether the application is to be executed in profile mode. The selection mechanism e.g. a link clicked by the user may include a parameter value e.g. a flag that indicates whether execution of the application file is to be profiled. If the application is to be executed in profile mode the Sandbox Manager instructs the virtual runtime engine to operate in profile mode. As the virtual runtime engine executes the application file in profile mode the Sandbox Manager collects profile information supplied by the virtual runtime engine and stores it in one or more transcripts that may be used to profile a virtual application s access to the underlying original application file e.g. the xlayer file .

A profiling process and process of generating a streaming model from one or more transcript files are described in greater detail in U.S. patent application Ser. No. 12 877 918 filed on Sep. 8 2010 titled METHOD AND SYSTEM FOR BUILDING AND DISTRIBUTING APPLICATION PROFILES VIA THE INTERNET which is incorporated herein by reference in its entirety.

The system see may be characterized as implementing an application library that includes the uploaded files e.g. the uploaded file illustrated in the copy of the uploaded file illustrated in and the like Application Library Web Services implemented by the application library web services components illustrated in and the Account and Application Library Databases and see . The authoring tool see and the application library perform a method illustrated in and described in detail below.

Referring to the Application Library Web Services implemented by the application library web services components provide an application programming interface API to publish a virtual application e.g. one of the virtual applications A and B illustrated in to the application library. By way of a non limiting example the Application Library Web Services may include the following seven services 

The above Application Library Web Services are described in detail in the description of the method illustrated in provided below.

Referring to the wizard may walk the user through the process of publishing a virtual application to the server computing device see and communicate with the application library via the Application Library Web Services implemented by the application library web services components illustrated in . By way of a non limiting example the Application Library Web Services may be implemented using Extensible Markup Language XML Web Services over Hypertext Transfer Protocol HTTP . By way of another non limiting example the wizard may call the Application Library Web Services over HTTP.

The AccountInfo table includes one or more fields. By way of non limiting examples the AccountInfo table may include the following fields AccountID Account or User Name Contact Name Email Address Company and Password. Each account may be assigned a unique AccountID value which is stored in the AccountID field and may be used as a key in the AccountInfo table . The AccountID value assigned to the account uniquely identifies that account.

The Publisher table includes one or more fields. By way of non limiting examples the Publisher table may include the following fields PublisherID and AccountID. Each user identified in the Publisher table may be assigned a unique PublisherID value which is stored in the PublisherID field and may be used as a key in the Publisher table . The Publisher table may include a record for each unique AccountID value in the AccountID field of the AccountInfo table . In other words the records Publisher table may have a one to one relationship with the records in the AccountInfo table and the Publisher table may be linked to the AccountInfo table by the values in the AccountID field. The PublisherID value assigned to the publisher uniquely identifies that publisher or user .

The Domain table includes one or more fields. By way of non limiting examples the Domain table may include the following fields Domain and PublisherID. The Domain field stores a web address associated with a particular publisher. The Domain table may include one or more records for each publisher identified by a unique PublisherID value in the PublisherID field of the Publisher table . In other words the records Publisher table may have a one to many relationship with the records in the Domain table and the Publisher table may be linked to the Domain table by the values in the PublisherID field.

The Application table includes one or more fields. By way of non limiting examples the Application table may include the following fields ApplicationID PublisherID Name InternalName Summary Description ProductWebsite and ScreenShotXFile. Each application identified in the Application table may be assigned a unique ApplicationID value which is stored in the ApplicationID field and may be used as a key in the Application table . The ApplicationID value assigned to the application uniquely identifies that application. The Application table may include one or more records for each publisher identified by a unique PublisherID value in the PublisherID field of the Publisher table . In other words the records Publisher table may have a one to many relationship with the records in the Application table and the Publisher table may be linked to the Application table by the values in the PublisherID field.

The Application Version table includes one or more fields. By way of non limiting examples the Application table may include the following fields ApplicationVersionID ApplicationID and Version. A unique ApplicationVersionID value is assigned to each version of a particular application. Thus the ApplicationVersionID value assigned to a particular version of a particular application uniquely identifies that version of the particular application. The Application Version table may include one or more records for each application identified by a unique ApplicationID value in the ApplicationID field of the Application table . In other words the records Application table may have a one to many relationship with the records in the Application Version table and the Application table may be linked to the Application Version table by the values in the ApplicationID field.

The Layer Version table includes one or more fields. By way of non limiting examples the Application table may include the following fields LayerVersionID ApplicationVersionID RevisionNumber TestLinkURL and InternalNotes. A unique LayerVersionID value is assigned to each layer of each version of a particular application. Thus the LayerVersionID value assigned to a particular layer of a particular version of a particular application uniquely identifies that layer of the particular version of the particular application. The Layer Version table may include one or more records for each record in the Application Version table . In other words the records Application Version table may have a one to many relationship with the records in the Layer Version table and the Layer Version table may be linked to the Application Version table by the values in the ApplicationVersionID field.

The XFile table includes one or more fields. By way of non limiting examples the XFile table may include an ID field that uniquely identifies each file to be published. U.S. patent application Ser. No. 12 877 918 describes the XFile table and other tables related thereto. As explained in U.S. patent application Ser. No. 12 877 918 the uploaded file see or the copy of the uploaded file see may be used to create transcripts that may be combined or merged to generate a streaming model. Records in the XFile table may be linked to records in other tables to indicate the existence of a new streaming model not shown for the uploaded file and to identify on which server s the streaming model is stored.

The Application table may include one record for each record identified by a unique value in the ID field of the XFile table . In other words the records Application table may have a one to one relationship with the records in the XFile table and the Application table may be linked to the XFile table by the values in the ScreenShotXFile field of the Application table and the values in the ID field of the XFile table .

The Account Database may include the AccountInfo table . The Application Library Database may include the Publisher table the Application table the Application Version table and the Layer Version table . Optionally the Application Library Database may also include the Domain table and the XFile table .

In first block the wizard launches and connects to the server computing device . Then in block the wizard displays an initial form see to a user e.g. an application publisher . Turning to the initial form displays login choices that may include an option to create a new account or log into an existing account. When the first time the user attempts to publish an application to the website see the user may select the create a new account option to create a new account. Returning users to the website see may select the log into an existing account option to log into their existing accounts using previously specified credentials e.g. an account name and password .

Returning to in decision block the wizard receives a selection from the user and determines whether the user has chosen to create a new account. The decision in decision block is YES when the user has chosen to create a new account. When the user has chosen to log into an existing account the decision in decision block is NO. 

When the decision in decision block is YES in block the wizard displays a new account form see configured to request information from the user. Turning to to create the new account the user inputs information into the new account form . The new account form may request basic account information such as Account or User Name Contact Name Email Address Company Password and the like.

Then the user submits the new account form . Returning to the wizard detects that the user has submitted the new account form see and in block forwards the information entered into the new account form to the server computing device . In the embodiment illustrated the information sent to the server computing device is received by the web server components A see . By way of a non limiting example the information provided by the user in the new account form see may be sent to the server computing device as query string parameters e.g. appended to a Uniform Resource Locator URL to an Active Server Page Extended page e.g. having the extension aspx over a Secure Sockets Layer SSL connection.

In block the Active Server Page Extended page which executes on the server computing device or other computer executable instructions executing on the server computing device creates a new account for the user by storing the information provided by the user in the AccountInfo table see in the Account Database see . As is apparent to those of ordinary skill in the art before a new record is created the AccountInfo table see may be queried for the account name provided by the user to ensure multiple records do not include the same value in the Account Name field. If the query returns a record the server computing device may inform the wizard that an account having the account name provided already exists. Then the wizard may instruct the user to enter a different Account Name. If the query does not return a record the server computing device stores the account name and password as well as other information provided by the user in the AccountInfo table see . Then the wizard advances to block .

When the decision in decision block is NO in block the wizard displays a login form see requesting the user s account name and password. The user inputs an account name and password into the login form see and submits the login form. The wizard receives the account name and password input by the user.

In block the wizard forwards the account name and password to the server computing device and calls the AccountLogin Web Service which executes on the server computing device .

In decision block the AccountLogin Web Service determines whether the user has provided a valid account name and password. The decision in decision block is YES when the user has provided a valid account name and password. Otherwise the decision in decision block is NO when the user has not provided a valid account name and password. In decision block the AccountLogin Web Service validates the account name and password provided by the user against the information stored in AccountInfo table see in the Account Database see . The following pseudo code provides a non limiting example of an implementation of the AccountLogin Web Service.

As is apparent to those of ordinary skill in the art the above pseudo code receives two input parameters namely AccountName and Password. The parameter AccountName stores the account name provided by the user and the parameter Password stores the password provided by the user. The pseudo code may be implemented at least in part as a SQL query that queries the AccountInfo table for the values stored by the input parameters AccountName and Password. If the query returns a result the AccountInfo table includes a record in which the value in the AccountName field is equal to the account name provided by the user and the value in the Password field is equal to password provided by the user. When the AccountInfo table includes such a record the login is successful and the decision in decision block is YES. The AccountLogin Web Service informs the wizard as to whether the user has provided a valid account name and password.

When the decision in decision block is YES the wizard advances to block . Otherwise if the query returns an empty set the AccountInfo table does not include a record storing the values stored by the parameters AccountName and Password and the decision in decision block is NO. When the decision in decision block is NO the wizard returns to block or alternatively to block .

In block the wizard generates and displays an application creation form illustrated in . To generate the application creation form see the wizard calls the GetApplications Web Service which executes on the server computing device to download information related to existing virtual applications associated with the user. This information includes application names and versions. Optionally the information may also include information related to layers i.e. revisions or modifications made to a particular version . The information is grouped by application name and application version and may be used to populate dropdown boxes B and B on the application creation form illustrated in . The dropdown box B may display a list of applications. After an application is selected the dropdown box B may display a list of versions associated with the application selected. The dropdown box B may include a New Application selection that may be selected to indicate the user wishes to upload a new application. Similarly the dropdown box B may include a New Version selection that may be selected to indicate the user wishes to upload a new version of the application selected or a new application.

The following pseudo code provides a non limiting example of an implementation of the GetApplications Web Service.

As is apparent to those of ordinary skill in the art the above pseudo code receives two input parameters namely AccountName and Password and returns an array of publisher application objects stored in or referenced by an output parameter named PublisherApplications. The pseudo code may be implemented at least in part as a SQL query that queries the AccountInfo table see for the values of the parameters AccountName and Password to obtain the AccountID value associated with the login information. The pseudo code then queries via a SQL query the Publisher table see using the AccountID value to obtain the PublisherID value associated with the AccountID value. Next the pseudo code queries via a SQL query the Application table see for any ApplicationID values associated with the PublisherID value. The pseudo code also queries via a SQL query the Application Version table see for information associated with each of the ApplicationID values located.

Thus the GetApplications Web Service obtains information for each version of each application associated with the login information provided by the user. The GetApplications Web Service uses this information to construct the array of application objects stored in or referenced by the output parameter PublisherApplications. In particular embodiments the GetApplications Web Service returns an application object for each version of each application. Each of the application objects has a Name member that stores the Name value obtained from the Name field in the Application table see and a Version member that stores the Version value obtained from the Version field in the Application Version table see .

The application creation form illustrated in may be characterized as presenting the following three choices to the user 

After selecting one of these choices the user enters information into the application creation form .

If the user selects create a new application the information entered is associated with the new application to be uploaded to the website illustrated in . Thus the user enters information required to populate a new record in the Application table see . Optionally the user may also enter information required to populate a new record in the Application Version table see and a new record in the Layer Version table see .

If the user selects create a new version of an existing application the information entered is associated with the version of an existing application to be uploaded to the website illustrated in . Thus the user selects an existing application e.g. from the pre populated dropdown box B on the application creation form illustrated in and enters information required to populate a new record in the Application Version table see . Optionally the user may also enter information required to populate a new record in the Layer Version table see .

By way of a non limiting example if the user selects either create a new application or create a new version of an existing application the user may input the following information a web address at which the application is to be published e.g. a value to be stored in the Domain field of the Domain table summary information related to the application e.g. a value to be stored in the Summary field of the Application table a description of the application e.g. a value to be stored in the Description field of the Application table comments regarding the revision a value to be stored in the InternalNotes field of the Layer Version table a product URL e.g. a value to be stored in the ProductWebsite field of the Application table a screenshot captured from the application or other image related to the application and the like.

The screenshot or other image file is uploaded to the server computing device . When the screenshot file is uploaded a record is created in the XFile table for the screenshot file. The record in the XFile table can be resolved to a physical file location so that the server computing device may locate and display the screenshot file. The record in the XFile table can be resolved to a physical file location by including a File field not shown in the XFile table that stores a path to the screenshot file generating a path to the screenshot file using the name of the application e.g. C web www images appname .png and the like.

On the other hand if the user selects update an existing version of an existing application the user selects an existing application and version of that application e.g. from pre populated dropdown boxes B and B on the application creation form illustrated in and enters information required to populate a new record in the Layer Version table see . Further the user may wish to enter comments e.g. a value to be stored in the InternalNotes field of the Layer Version table regarding the revision that are unique for each revision uploaded to the website illustrated in .

When the user has finished entering information into the application creation form see the user submits the form.

As explained above the file to be published may be a binary file that may be implemented as an xlayer file e.g. the xlayer file an executable virtualized application file e.g. the executable virtualized application file and the like. The file to be published may be created before the method is performed. Alternatively in optional block the user builds or rebuilds the file to be published using the authoring tool and the application configuration see . By way of another non limiting example the file to be published may be built or rebuilt at another point during the execution of the method occurring before the file to be published is uploaded to the server computing device . As explained above the file to be published may be a a new application version and layer or revision b a new version and layer of an existing application or c a new layer of an existing version of an existing application. Optionally all or a portion of the information submitted by the user in the application creation form may be incorporated into the newly built virtualized application file by the authoring tool .

If a new application is being added to the Application Library Database a new ApplicationID value must be created. Similarly if a new version of an existing application is being added to the Application Library Database a new ApplicationVersionID value must be created. In block the wizard forwards the information received in block to the server computing device and calls the CreateApplication Web Service which updates the Application Library Database with the information related to the file to be published. If a new application is being added to the Application Library Database the CreateApplication Web Service creates a record in the Application table see for the file to be published and returns a new ApplicationID value created for the new record to the wizard . In block the wizard receives the new ApplicationID value from the CreateApplication Web Service. The following pseudo code provides a non limiting example of an implementation of the CreateApplication Web Service.

As is apparent to those of ordinary skill in the art the above pseudo code receives three input parameters namely AccountName Password and PublisherApplication and returns an InternalName value stored in an output parameter named InternalName. If the user selected an existing application on the application creation form illustrated in the parameter PublisherApplication may store one of the application objects of the array of applications objects PublisherApplications returned by the GetApplications Web Service. On the other hand if the user selected create a new application on the application creation form see the CreateApplication Web Service creates a new application object using the information provided on the application creation form.

The pseudo code may be implemented at least in part as a SQL query that queries the AccountInfo table see for the values stored in the parameters AccountName and Password to obtain the AccountID value stored in the AccountID field of a record associated with the login information.

Then the pseudo code queries e.g. via SQL the Publisher table see using the AccountID value. If the query returns a result the Publisher table see includes a record having the AccountID value and the pseudo code obtains the PublisherID value associated with the AccountID value. Otherwise if the query returns an empty set the Publisher table see does not include a record having the AccountID value and a new record is created in the Publisher table thereby creating a new publisher account using the information in the AccountInfo table see . Thus at this point the pseudo code has the AccountID and PublisherID values associated with the account name and password provided by the user.

Next the pseudo code queries e.g. via SQL the Application table see for the value of the Name member of the application object PublisherApplication. If the query returns a result the Application table includes a record having a Name value in the Name field equal to the value of the Name member of the application object PublisherApplication and the query obtains the ApplicationID and InternalName values stored in the record. The ApplicationID and InternalName values obtained are associated with the value of the Name member of the application object PublisherApplication. Otherwise if the query returns an empty set the Application table see does not include a record having a Name value in the Name field equal to the value of the Name member of the application object PublisherApplication and a new record is created in the Application table thereby creating a new application using the information stored in the application object PublisherApplication. A new unique InternalName value is generated based on the publisher name application name and application version. Thus at this point the pseudo code has obtained the ApplicationID and InternalName values associated with the application object PublisherApplication. 

Next the pseudo code queries the Application Version table see for the ApplicationID value associated with the application object PublisherApplication and the value of the Version member of the application object PublisherApplication. If the query returns a result the Application Version table includes a record having an ApplicationID value stored in the ApplicationID field equal to the ApplicationID value associated with the application object PublisherApplication and a Version value stored in the Version field equal to the value of the Version member of the application object PublisherApplication. When the query returns a result the result includes the values of all the fields in the Application Version table of the record located. Otherwise if the query returns an empty set the Application Version table does not include a record having the having an ApplicationID value stored in the ApplicationID field equal to the ApplicationID value associated with the application object PublisherApplication and or a Version value stored in the Version field equal to the value of the Version member of the application object PublisherApplication. When this is the case a new record is created in the Application Version table thereby creating a new version of the application using the information in the application object PublisherApplication. 

The CreateApplication Web Service returns the InternalName value associated with the Name member of the application object PublisherApplication. 

In block the wizard calls the StartUploadData Web Service to initiate the upload. The following pseudo code provides a non limiting example of an implementation of the StartUploadData Web Service.

As is apparent to those of ordinary skill in the art the above pseudo code receives three input parameters namely AccountName Password and InternalName and returns a globally unique identifier stored in an output parameter named Guid. The pseudo code may be implemented at least in part as a SQL query that queries the AccountInfo table see for the values of the parameters AccountName and Password to obtain the values of the fields of the record in the AccountInfo table associated with the login information. While not included in the pseudo code above this query may be used to prevent unauthorized or non existent users from publishing applications and or adding or modifying data stored in the Account Database or the Application Library Database . For example if this query does not return a record the StartUploadData Web Service may terminate.

Then the pseudo code creates a new globally unique identifier Guid and an empty file. The empty file is stored in a predetermined upload file location e.g. a folder . The empty file may be an xlayer file named in accordance with a predetermined format using the globally unique identifier stored in the parameter Guid. By way of a non limiting example the predetermined format may be as follows Guid.xlayer. Then the parameter Guid is returned by the StartUploadData Web Service to the wizard .

In block the wizard calls the UploadData Web Service to upload the file to be published in chunks or blocks e.g. one megabyte blocks to the server computing device . The following pseudo code provides a non limiting example of an implementation of the UploadData Web Service. The UploadData Web Service may be called multiple times once for each block.

As is apparent to those of ordinary skill in the art the above pseudo code receives four input parameters namely AccountName Password BinaryData and Guid. The pseudo code may be implemented at least in part as a SQL query that queries the AccountInfo table for the values of the parameters AccountName and Password to obtain the values of the fields of the record in the AccountInfo table associated with the login information. While not included in the pseudo code above this query may be used to prevent unauthorized or non existent users from publishing applications and or adding or modifying data stored in the Account Database or the Application Library Database . For example if this query does not return a record the UploadData Web Service may terminate. As is apparent to those of ordinary skill in the art it may not be necessary to perform this query for each separate block of data. In alternate implementations this query may be executed once e.g. when the first block is uploaded .

Then the pseudo code inserts or appends binary data stored in the input parameter BinaryData to the file created by the StartUploadData Web Service. The name of this file may be determined based at least in part on the value of the parameter Guid. Thus in particular implementations the pseudo code appends binary data stored in the input parameter BinaryData to a file having a name with the format Guid.xlayer stored in the upload file location.

At this point the UploadData Web Service may indicate in the Application Library Database see that the file to be published has been fully uploaded. This may be indicated by entering a new record in the Layer Version table .

While the information entered by the user into the application creation form illustrated in has been described as being sent to the server computing device for entry into the Application Library Database . The information entered by the user into the application creation form need not be sent to the server computing device in addition to uploading the file to be published. Instead because the file to be published is built on the client computing device the information entered by the user may be incorporated into the file to be published before it is uploaded to the server computing device . Thus the server computing device may read or parse the uploaded file see for the data to be entered into the Application Library Database . For example the xlayer file may include publisher information application information and version information. Thus when the uploaded file is an xlayer file at least a portion of the information used to populate the Application table Application Version table and the Layer Version table may be obtained from the uploaded file . However as is apparent to those of ordinary skill in the art all of the information entered into the application creation form see may be incorporated into the file to be uploaded.

As explained above the version information may have four components a major version a minor version a build version and a revision number. Each record in the Layer Version table may correspond to a different build version and revision number. Thus each record in the Layer Version table may correspond to a different patch.

After the file to be published has been fully uploaded to the server computing device the uploaded file see is transferred or copied to the server computing device which functions as a website server . In block the wizard calls the CompleteUpload Web Service to begin copying the file to the server computing device . The following pseudo code provides a non limiting example of an implementation of the CompleteUpload Web Service.

As is apparent to those of ordinary skill in the art the above pseudo code receives six input parameters namely AccountName Password InternalName RevisionNotes FileHash and Guid and returns a LayerVersionID value stored in an output parameter named LayerVersionID. The pseudo code may be implemented at least in part as a SQL query that queries the AccountInfo table see for the values of the parameters AccountName and Password to obtain the values of the fields of the record in the AccountInfo table associated with the login information. While not included in the pseudo code above this query may be used to prevent unauthorized or non existent users from publishing applications and or adding or modifying data stored in the Account Database or the Application Library Database . For example if this query does not return a record the CompleteUpload Web Service may terminate.

Next the pseudo code queries the Application table see for a record having the value of the input parameter InternalName stored in the InternalName field to obtain the ApplicationID value of the record associated with the InternalName value stored in the input parameter InternalName. Then the pseudo code queries the Application Version table see using the ApplicationID value for the record created for the latest version of the application associated with the ApplicationID value to obtain the ApplicationVersionID value associated with the latest version of the application . Next the pseudo code queries the Layer Version table see using the ApplicationVersionID value for the record created for the latest layer of the latest version of the application associated with the ApplicationID value to obtain the RevisionNumber value if any associated with the latest layer of the latest version of the application .

The pseudo code then creates a new record in the Layer Version table see for the new layer version. The RevisionNumber value of the new record is determined by incrementing the RevisionNumber value obtained above or alternatively if no value was returned assigning an initial value e.g. one to the RevisionNumber value.

In the pseudo code above a separate thread is launched to copy the uploaded file see from the server computing device which functions as an upload server to the server computing device which functions as a website server . Referring to the separate thread opens a global mutex or a mutual exclusion for the new LayerVersionID value copies the uploaded file see across the network e.g. a LAN portion of the network from the upload file location on the server computing device to the server computing device and closes the global mutex for the new LayerVersionID value. Then the CompleteUpload Web Service returns the LayerVersionID value to the wizard .

Returning to in block the wizard calls the IsAppReadyForTesting Web Service to determine whether the copying of the uploaded file started in block to the server computing device has completed. If it has the wizard receives an application address from the IsAppReadyForTesting Web Service. The application address may be an address on the domain entered into the application creation form see and or stored in the Domain field of the Domain table see .

In decision block the wizard determines whether the copying of the uploaded file to the server computing device which functions as a website server has completed. The decision in decision block is YES when the copying of the uploaded file to the server computing device has completed. Otherwise the decision in decision block is NO when the copying of the uploaded file to the server computing device has not yet completed. When the decision in decision block is NO the wizard returns to block .

When the decision in decision block is YES in block the wizard obtained the application address e.g. an application URL on the server computing device from which the copy of the uploaded file see may be downloaded and executed for test or other purposes.

The wizard may occasionally e.g. periodically call the IsAppReadyForTesting Web Service to confirm that the copy of the uploaded file is available on the server computing device which may function as a test server. The following pseudo code provides a non limiting example of an implementation of the IsAppReadyForTesting Web Service.

As is apparent to those of ordinary skill in the art the above pseudo code receives three input parameters namely AccountName Password and LayerVersionID and returns two output parameters named Ready and TestURL. The pseudo code may be implemented at least in part as a SQL query that queries the AccountInfo table see for the values of the parameters AccountName and Password to obtain the values of the fields of the record in the AccountInfo table associated with the login information. While not included in the pseudo code above this query may be used to prevent unauthorized or non existent users from publishing applications and or adding or modifying data stored in the Account Database or the Application Library Database . For example if this query does not return a record the IsAppReadyForTesting Web Service may terminate.

Then the pseudo code determines whether the global mutex created for the LayerVersionID value in the example of the CompleteUpload Web Service described above still exists. If the global mutex created for the LayerVersionID value still exists the uploaded file see is still being copied to the server computing device and the value of the output parameter Ready is set to FALSE. Otherwise if the global mutex created for the LayerVersionID value no longer exists the copying of the uploaded file see to the server computing device has completed and the value of the output parameter Ready is set to TRUE. 

Next the pseudo code queries the Layer Version table for the LayerVersionID value to obtain the TestLinkUrl value from the record associated with the LayerVersionID value. The value of the output parameter TestURL is set to the TestLinkUrl value obtained and the output parameter TestURL is returned to the wizard .

In block the wizard displays a test form see with a link to the application address i.e. the value of the output parameter TestURL provided by the IsAppReadyForTesting Web Service. The user may select the application address to download and or execute the application for testing or other purposes. Then the method terminates.

Optionally the application address may be forwarded to other users who may download and or execute the copy of the uploaded file see for testing or other purposes.

The server computing device may generate an application web page on the website illustrated in . The application webpage may display a link to the application address e.g. as a hyperlink that the user may select to download and or execute the copy of the uploaded file. Referring to as explained above if the link includes a parameter value e.g. a flag indicating that the application is to be provided the Sandbox Manager see instructs the virtual runtime engine to operate in profile mode and collects profile information supplied by the virtual runtime engine and stores it in one or more transcripts that may be used to profile a virtual application s access to the underlying original application file e.g. the xlayer file .

The Application Library Database may be queried for application information that may be used to generate web pages on the website . For example the Application Library Database may be queried for a list of applications associated with a particular publisher. Links to each application published by the publisher may be displayed to a user for selection thereby.

By publishing each patch to an application as a new record in the Layer Version table see of the Application Library Database a revision to an application may be published without disturbing users currently downloading or executing applications using pre existing application addresses stored in preexisting records in the Layer Version table .

Moreover those skilled in the art will appreciate that implementations may be practiced with other computer system configurations including hand held devices multiprocessor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. Implementations may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

The exemplary hardware and operating environment of includes a general purpose computing device in the form of a computing device . Each of the virtual application file the xlayer file the Client Application the Sandbox Manager the authoring tool including the wizard the web server components A the web server components B the application library web services implemented by the application library web services components illustrated in and or the virtual runtime engine may be implemented using one or more computing devices like the computing device . By way of non limiting example the virtual application file the xlayer file the Client Application the Sandbox Manager the authoring tool including the wizard the web server components A the web server components B the application library web services implemented by the application library web services components illustrated in and or the virtual runtime engine may be implemented on the computing device . Further each of the server computing device the server computing device the client computing device the client computing device the Account Database and the Application Library Database may be implemented by computing devices substantially similar to the computing device .

The computing device includes the system memory a processing unit and a system bus that operatively couples various system components including the system memory to the processing unit . There may be only one or there may be more than one processing unit such that the processor of computing device comprises a single central processing unit CPU or a plurality of processing units commonly referred to as a parallel processing environment. The computing device may be a conventional computer a distributed computer or any other type of computer.

The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory may also be referred to as simply the memory and includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computing device such as during start up is stored in ROM . The computing device further includes a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM DVD or other optical media.

The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical disk drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of computer readable instructions data structures program modules and other data for the computing device . It should be appreciated by those skilled in the art that any type of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards USB drives digital video disks Bernoulli cartridges random access memories RAMs read only memories ROMs and the like may be used in the exemplary operating environment. As is apparent to those of ordinary skill in the art the hard disk drive and other forms of computer readable media e.g. the removable magnetic disk the removable optical disk flash memory cards USB drives and the like accessible by the processing unit may be considered components of the system memory .

A number of program modules may be stored on the hard disk drive magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computing device through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor computers typically include other peripheral output devices not shown such as speakers and printers.

The input devices described above are operable to receive user input and selections. Referring to the display device is operable to display the initial form the new account form the login form the application creation form and the test form . Further the display device is operable to display web pages e.g. web pages generated by the server computing device illustrated in . Together the input and display devices may be described as providing a user interface.

Returning to the computing device may operate in a networked environment using logical connections to one or more remote computers such as remote computer . These logical connections are achieved by a communication device coupled to or a part of the computing device as the local computer . Implementations are not limited to a particular type of communications device. The remote computer may be another computer a server a router a network PC a client a memory storage device a peer device or other common network node and typically includes many or all of the elements described above relative to the computing device . The remote computer may be connected to a memory storage device . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computing device is connected to the local area network through a network interface or adapter which is one type of communications device. When used in a WAN networking environment the computing device typically includes a modem a type of communications device or any other type of communications device for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the personal computing device or portions thereof may be stored in the remote computer and or the remote memory storage device . It is appreciated that the network connections shown are exemplary and other means of and communications devices for establishing a communications link between the computers may be used.

The computing device and related components have been presented herein by way of particular example and also by abstraction in order to facilitate a high level view of the concepts disclosed. The actual technical design and implementation may vary based on particular implementation while maintaining the overall nature of the concepts disclosed.

Returning to the system memory A the system memory B the system memory C and the system memory D may each be substantially similar to the system memory . Thus the host operating system A the host operating system B the host operating system C the host operating system D the virtual application file the xlayer file the Client Application the Sandbox Manager the authoring tool including the wizard the web server components A the web server components B the application library web services implemented by the application library web services components illustrated in and or the virtual runtime engine may be stored as computer executable components on the system memory A B C and or D. Each of the host operating system A the host operating system B the host operating system C the host operating system D the virtual application file the xlayer file the Client Application the Sandbox Manager the authoring tool including the wizard the web server components A the web server components B the application library web services implemented by the application library web services components illustrated in and or the virtual runtime engine may be implemented using software components that are executable by the processing unit and when executed perform the functions described above. Further the method may be implemented as computer executable instructions that are executable by the processing unit . Such instructions may be encoded on one or more non transitory computer readable mediums for execution by one or more processing units.

The foregoing described embodiments depict different components contained within or connected with different other components. It is to be understood that such depicted architectures are merely exemplary and that in fact many other architectures can be implemented which achieve the same functionality. In a conceptual sense any arrangement of components to achieve the same functionality is effectively associated such that the desired functionality is achieved. Hence any two components herein combined to achieve a particular functionality can be seen as associated with each other such that the desired functionality is achieved irrespective of architectures or intermedial components. Likewise any two components so associated can also be viewed as being operably connected or operably coupled to each other to achieve the desired functionality.

While particular embodiments of the present invention have been shown and described it will be obvious to those skilled in the art that based upon the teachings herein changes and modifications may be made without departing from this invention and its broader aspects and therefore the appended claims are to encompass within their scope all such changes and modifications as are within the true spirit and scope of this invention. Furthermore it is to be understood that the invention is solely defined by the appended claims. It will be understood by those within the art that in general terms used herein and especially in the appended claims e.g. bodies of the appended claims are generally intended as open terms e.g. the term including should be interpreted as including but not limited to the term having should be interpreted as having at least the term includes should be interpreted as includes but is not limited to etc. . It will be further understood by those within the art that if a specific number of an introduced claim recitation is intended such an intent will be explicitly recited in the claim and in the absence of such recitation no such intent is present. For example as an aid to understanding the following appended claims may contain usage of the introductory phrases at least one and one or more to introduce claim recitations. However the use of such phrases should not be construed to imply that the introduction of a claim recitation by the indefinite articles a or an limits any particular claim containing such introduced claim recitation to inventions containing only one such recitation even when the same claim includes the introductory phrases one or more or at least one and indefinite articles such as a or an e.g. a and or an should typically be interpreted to mean at least one or one or more the same holds true for the use of definite articles used to introduce claim recitations. In addition even if a specific number of an introduced claim recitation is explicitly recited those skilled in the art will recognize that such recitation should typically be interpreted to mean at least the recited number e.g. the bare recitation of two recitations without other modifiers typically means at least two recitations or two or more recitations .

