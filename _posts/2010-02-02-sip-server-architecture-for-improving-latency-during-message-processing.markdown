---

title: SIP server architecture for improving latency during message processing
abstract: Systems and methods are provided for improving latency during message processing in a network environment via the use of SIP server architecture. The SIP server can be comprised of an engine tier and a state tier distributed on a cluster network. The engine tier can send and receive messages and execute various processes. The state tier can maintain in-memory state data associated with various SIP sessions. The state tier can store various long lived data objects and the engine tier can contain short lived data objects. The state data can be maintained in partitions comprised of state replicas. When processing messages, the engine can pull state data objects from the state tier, use the objects and push them back to the state tier after processing is complete. If one state replica is unavailable, such as during garbage collection, the engine can retrieve the objects from another replica in the partition.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07954005&OS=07954005&RS=07954005
owner: Oracle International Corporation
number: 07954005
owner_city: Redwood Shores
owner_country: US
publication_date: 20100202
---
This application is a continuation of U.S. patent application Ser. No. 11 545 648 filed on Oct. 10 2006 entitled SIP SERVER ARCHITECTURE FAULT TOLERANCE AND FAILOVER by Anno R. Langen et al.

The following commonly owned co pending United States patents and patent applications including the present application are related to each other. Each of the other patents applications are incorporated by reference herein in their entirety 

U.S. patent application Ser. No. 11 378 188 entitled SYSTEM AND METHOD FOR MANAGING COMMUNICATIONS SESSIONS IN A NETWORK by Reto Kramer et al. filed on Mar. 17 2006 

U.S. patent application Ser. No. 11 384 056 entitled SYSTEM AND METHOD FOR A GATEKEEPER IN A COMMUNICATIONS NETWORK by Reto Kramer et al. filed on Mar. 17 2006 

U.S. Patent Application No. 60 801 091 entitled SIP AND HTTP CONVERGENCE IN NETWORK COMPUTING ENVIRONMENTS by Anno Langen et al. filed on May 16 2006 

U.S. Patent Application No. 60 800 943 entitled HITLESS APPLICATION UPGRADE FOR SIP SERVER ARCHITECTURE by Anno Langen et al. filed on May 16 2006 

U.S. Patent Application No. 60 801 083 ENGINE NEAR CACHE FOR REDUCING LATENCY IN A TELECOMMUNICATIONS ENVIRONMENT by Anno Langen et al. filed on May 16 2006 

U.S. patent application Ser. No. 11 434 022 entitled SYSTEM AND METHOD FOR CONTROLLING DATA FLOW BASED UPON A TEMPORAL POLICY by Narendra Vemula et al. filed on May 15 2006 

U.S. patent application Ser. No. 11 434 024 entitled SYSTEM AND METHOD FOR CONTROLLILNG ACCESS TO LEGACY PUSH PROTOCOLS BASED UPON A POLICY by Bengt Inge Jakobsson et al. filed on May 15 2006 

U.S. patent application Ser. No. 11 434 010 entitled SYSTEM AND METHOD FOR CONTROLLING ACCESS TO LEGACY MULTIMEDIA MESSAGE PROTOCOLS BASED UPON A POLICY by Andreas Jansson filed on May 15 2006 

U.S. patent application Ser. No. 11 434 025 entitled SYSTEM AND METHOD FOR CONTROLLING ACCESS TO LEGACY SHORT MESSAGE PEER TO PEER PROTOCOLS BASED UPON A POLICY by Andreas Jansson filed on May 15 2006 

U.S. patent application Ser. No. 11 432 934 entitled SYSTEM AND METHOD FOR SHAPING TRAFFIC by Jan Svensson filed on May 12 2006.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The current invention relates generally to managing telecommunications and more particularly to improving latency during message processing for a SIP server architecture.

Conventionally telecommunications and network infrastructure providers have relied on often decades old switching technology to providing routing for network traffic. Businesses and consumers however are driving industry transformation by demanding new converged voice data and video services. The ability to meet these demands often can be limited by existing IT and network infrastructures that are closed proprietary and too rigid to support these next generation services. As a result telecommunications companies are transitioning from traditional circuit switched Public Switched Telephone Networks PSTN the common wired telephone system used around the world to connect any one telephone to another telephone to Voice Over Internet Protocol VoIP networks. VoIP technologies enable voice communication over vanilla IP networks such as the public Internet. Additionally a steady decline in voice revenues has resulted in heightened competitive pressures as carriers vie to grow data service revenues and reduce churn through the delivery of these more sophisticated data services. Increased federal regulation security and privacy issues as well as newly emerging standards can further compound the pressure.

However delivering these more sophisticated data services has proved to be more difficult than first imagined. Existing IT and network infrastructures closed proprietary network based switching fabrics and the like have proved to be too complex and too rigid to allow the creation and deployment of new service offerings. Furthermore failover and fault tolerance have become important issues in telecommunications environments as more and more users expect continuous and uninterrupted service from their devices.

The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. References to embodiments in this disclosure are not necessarily to the same embodiment and such references mean at least one. While specific implementations are discussed it is understood that this is done for illustrative purposes only. A person skilled in the relevant art will recognize that other components and configurations may be used without departing from the scope and spirit of the invention.

In the following description numerous specific details are set forth to provide a thorough description of the invention. However it will be apparent to those skilled in the art that the invention may be practiced without these specific details. In other instances well known features have not been described in detail so as not to obscure the invention.

Although a diagram may depict components as logically separate such depiction is merely for illustrative purposes. It can be apparent to those skilled in the art that the components portrayed can be combined or divided into separate software firmware and or hardware components. For example one or more of the embodiments described herein can be implemented in a network accessible device appliance such as a router. Furthermore it can also be apparent to those skilled in the art that such components regardless of how they are combined or divided can execute on the same computing device or can be distributed among different computing devices connected by one or more networks or other suitable communication means.

In accordance with embodiments there are provided systems and methods for improving latency in message processing for a network environment via the use of SIP server architecture. In various embodiments the SIP server can be comprised of an engine tier and a state tier distributed on a cluster network environment. The engine tier can send and receive messages and execute various processes. The state tier can maintain in memory state data associated with various SIP sessions. For example the state tier can store various long lived data objects and the engine tier can contain short lived data objects. The state data can be maintained in partitions comprised of state replicas. A load balancer can receive incoming message traffic and distribute it to the engine tier for processing. When processing a message the engine can pull state data objects from the state tier use the objects and push them back to the state tier after processing is complete. If one state replica is unavailable such as during garbage collection the engine can retrieve the objects from another replica in the partition.

A Session Initiation Protocol SIP Server and a Network Gatekeeper can comprise a portfolio of products that collectively make up the Communications Platform . The SIP Server provides the Communications Platform with a subsystem in which application components that interact with SIP based networks may be deployed. The Network Gatekeeper provides a policy driven telecommunications Web services gateway that allows granular control over access to network resources from un trusted domains.

A variety of shared and re usable software and service infrastructure components comprise the Communications Platform . For example an Application Server such as the WebLogic Application Server by BEA Systems Inc. of San Jose Calif. This Application Server may be augmented and adapted for deployment in telecommunications networks while providing many features and functionality of the WebLogic Server counterpart widely deployed in enterprise computing environments. Application Server embodiments for use in the telecommunications applications can provide a variety of additional features and functionality such as without limitation 

Analogously communications platform embodiments can provide a variety of additional features and functionality such as without limitation 

Communications platform comprises a SIP Server WLSS and a Network Gatekeeper WLNG . Tools for interacting with Web Services such as a Web Service Universal Description Discovery Interface WS UDDI a Web Service Business Process Execution Language WS BPEL may be coupled to the SIP Server and the Network Gatekeeper in embodiments. A log trace and database can assist with troubleshooting. In some deployments the Communications Platform can interface with an OSS BSS system via resource adapters . Such interfaces can provide access to billing applications Operation Administration and Maintenance OAM applications and others. A policy engine can control the activities of the above described components which can be implemented in a scalable cluster environment SCE .

A Communications Platform embodiment can provide an open high performance software based fault tolerant platform that allows operators to maximize revenue potential by shortening time to market and significantly reducing per service implementation and integration cost and complexity. The Communications Platform is suitable for use by for Network Infrastructure Vendor Network Operators and Communications Service Providers in multiple deployment scenarios ranging from fully IMS oriented network architectures to hybrid and highly heterogeneous network architectures. It is not restricted to use only in carrier networks however and may be deployed in Enterprise communications networks without restriction or extensive customization. When deployed in conjunction with an IP Multimedia Subsystem the Communications Platform can serve in the role of an IMS SIP Application Server and offers Communications Service Providers an execution environment in which to host applications such as the WebLogic Network Gatekeeper components and standard service enablers.

As illustrated the SIP server can be used as a back to back user agent B2BUA in a typical telecommunications environment. A B2BUA can take the place of an intermediary between communications between user agents including various cellular phones wireless devices laptops computers applications and other components capable of communicating with one another electronically. The B2BUA can provide multiple advantages including controlling the flow of communication between user agents enabling different user agents to communicate with one another e.g. a web application can communicate with a cellular phone as well as various security advantages. As an illustration the user agents can transmit to the SIP server instead of communicating directly to each other and thus malicious users can be prevented from sending spam and viruses hacking into other user agent devices and otherwise compromising security.

The SIP server can be implemented as a Java Enterprise Edition application server that has been extended with support for the session initiation protocol SIP as well as other operational enhancements that allow it to meet the demanding requirements of the next generation protocol based communication networks. In one embodiment the SIP server can include an Enterprise Java Beans EJB container a Hyper Text Transfer Protocol HTTP servlet container an SIP servlet container various Java 2 Enterprise Edition J2EE services and SIP and HTTP components. The SIP stack of the server can be fully integrated into the SIP servlet container and can offer much greater ease of use than a traditional protocol stack. A SIP servlet Application Programming Interface API can be provided in order to expose the full capabilities of the SIP protocol in the Java programming language. The SIP servlet API can define a higher layer of abstraction than simple protocol stacks provide and can thereby can free up the developer from concern about the mechanics of the SIP protocol itself. For example the developer can be shielded from syntactic validation of received requests handling of transaction layer timers generation of non application related responses generation of fully formed SIP requests from request objects which can involve correct preparation of system headers and generation of syntactically correct SIP messages and handling of lower layer transport protocols such as TCP UDP or SCTP.

In one embodiment the container is a server software that hosts applications i.e. contains them . In the case of a SIP container it hosts SIP applications. The container can perform a number of SIP functions as specified by the protocol thereby taking the burden off the applications. At the same time the SIP container can expose the application to SIP protocol messages via the SIP Servlet API on which applications can perform various actions. Different applications can thus be coded and deployed to the container that provides various telecommunication and multimedia services.

As illustrated a message such as a phone call request or some other transfer of data associated with SIP can come into the cluster from the internet such as over VoIP phone or some other type of network . This message can be received and handled by a load balancer which can be responsible distributing message traffic across the engines such as engine node and engine node in the cluster. The load balancer can be a standard load balancing appliance hardware device and it is not necessary that it be SIP aware there is no requirement that the load balancer support affinity between the engines and SIP dialogs or transactions. Alternatively the load balancer can be implemented as software that distributes the messages to the various engines. In the various embodiments the primary goal of the load balancer can be to provide a single public address that distributes incoming SIP requests to available servers in the SIP server engine tier . Such distribution of requests can ensure that the SIP server engines are fully utilized. The load balancer can also be used for performing maintenance activities such as upgrading individual servers or applications without disrupting existing SIP clients.

In one embodiment the SIP server can provide a two tier cluster architecture model to handle the incoming messages. In this model a stateless engine tier can process all signaling traffic and can also replicate transaction and session state to the state tier and its partitions . Each partition can consist of any number of nodes replicas distributed across any number of hosts such as host and host which can be implemented as computers linked in a cluster type network environment. The state tier can be an n way peer replicated Random Access Memory RAM store that maintains various data objects which can be accessed by the engine nodes in the engine tier. In this manner engines can be provided a dual advantage of faster access to the data objects than retrieving data from a database while at the same time engines can be freed up from having to store the data onto the engine tier itself. This type of separation can offer various performance improvements. The state tier can also function as a lock manager where call state access follows a simple library book model i.e. a call state can be checked out by one SIP engine at a time .

The engine tier can be implemented as a cluster of SIP server instances that hosts the SIP servlets which provide various features to SIP clients. In one embodiment the engine tier is stateless meaning that most SIP session state information is not persisted in the engine tier but is obtained by querying the state tier which can in turn provide replication and failover services for SIP session data.

The primary goal of the engine tier can be to provide maximum throughput combined with low response time to SIP clients. As the number of calls or their duration increases more server instances can be added to the engine tier to manage the additional load. It should be noted however that although the engine tier may include many such server instances it can be managed as a single logical entity. For example the SIP servlets can be deployed uniformly to all server instances by targeting the cluster itself and the load balancer need not maintain affinity between SIP clients and individual servers in the engine tier.

In various embodiments the state tier can be implemented as a cluster of SIP server instances that provides a high performance highly available in memory store for maintaining and retrieving session state data for SIP servlets. This session data may be required by SIP applications in the SIP server engine tier in order to process incoming messages. Within the state tier session data can be managed in one or more partitions where each partition manages a fixed portion of the concurrent call state. For example in a system that uses two partitions the first partition could manage one half of the concurrent call state e.g. A M and the second partition can manage the other half e.g. N Z . With three partitions each can manage a third of the call state and so on. Additional partitions can be added as needed to manage large number of concurrent calls.

In one embodiment within each partition multiple servers can be added to provide redundancy and failover should the other servers in the partition fail. When multiple servers participate in the same partition those servers can be referred to as replicas because each server maintains a duplicate copy of the partition s call state. For example nodes and of the partition can be implemented as replicas. Furthermore to increase the capacity of the state tier the data can be split evenly across a set of partitions as previously discussed. The number of replicas in the partition can be called the replication factor since it determines the level of redundancy and strength of failover that it provides. For example if one node goes down or becomes disconnected from the network any available replica can automatically provide call state data to the engine tier.

Replicas can join and leave the partition and each replica can serve as exactly one partition at a time. Thus in one embodiment the total available call state storage capacity of the cluster is a summation of the capacities of each partition .

In one embodiment each partition can peer replicated meaning that clients perform all operations reads writes to all replicas in the partition wherein the current set of replicas in the partition is called the partition view. This partition view can have an increasing ID for example. The view of the partition can be represented in any number of ways e.g. table with replica ids and this disclosure is not limited to any particular implementation. Peer replication can provide improved latency advantages over more traditional synchronous primary secondary architecture wherein one store acts as a primary and the other nodes serve as secondaries. Latency is reduced because there is no wait for the second hop of primary secondary systems. The peer replicated scheme can provide better failover characteristics as well since there does not need to be change propagation delay.

In one embodiment the engine nodes can be responsible for executing the call processing. Each call can have a call state associated with it. This call state can contain various information associated with the call such as the ids of the caller callee where the caller is what application is running on the callee as well as any timer objects that may need to fire in order to process the call flow as discussed below. The state for each call can be contained in the state tier . The engine tier on the other hand could be stateless in order to achieve the maximum performance. In alternative embodiments the engine tier can have small amounts of state data stored thereon at various times.

In one embodiment a typical message processing flow can involve locking getting the call state processing the message and putting unlocking the call state. The operations supported by the replicas for normal operations can include but are not limited to 

In various embodiments the engine tier can maintain mainly short lived objects and any long lived objects which may be needed for message processing can be stored on the state tier. This can provide improvements in latency during garbage collection. As an illustration the Java Virtual Machine JVM garbage collector can safely and quickly remove the short lived objects from memory without interfering with the execution of various other threads which may be in the process of executing. The longer lived objects on the other hand are not as easily removed by the garbage collector since they may be referenced and depended on by various entities and thus in some cases the JVM garbage collector may need to stop processing all threads in order to safely perform its garbage collection. This is due in part to the scoping of the short lived and long lived objects. Short lived objects typically exist in a different more localized memory scope than the long lived objects which may be referenced by more entities. Thus it can be more difficult for garbage collectors to ensure that every executing entity has finished using the long lived objects and various threads are usually stopped in order to perform their regular garbage collection. This can introduce latency.

In order to deal with such issues the engine tier can maintain mainly short lived objects. In cases where longer lived objects are needed by the engine tier they can be retrieved from the state tier used as short lived objects in the engine tier and subsequently pushed back to the state tier. This can be advantageous in that garbage collection can cause lesser interference with thread execution in the engine tier.

In various embodiments the state tier can maintain call state in various data objects residing in the random access memory RAM of a computer. This can provide significant access speed advantages to the engine tier . Alternatively if latency is not an issue call state can be maintained in a database or some other form of persistent store which can be accessed albeit slower by the engine tier. State of various applications running on the SIP server can also be maintained on the state tier. Developers can be provided an API to allow their applications to access the state tier and to store various data thereon for later access by various applications. Alternatively application state may be stored in a database.

As previously described the engine tier servers can continually access the state tier replicas in order to retrieve and write call state data. During this process the engine tier nodes can detect when a state tier server has failed or become disconnected. For example when an engine cannot access or write call state data for some reason e.g. the state tier node has failed or become disconnected then the engine can connect to another replica in the partition and retrieve or write data to that replica. The engine can also report that failed replica as being offline. This can be achieved by updating the view of the partition and data tier such that other engines can also be notified about the offline state tier server as they access state data.

Additional failover can also be provided by use of an echo server running on the same machine as the state tier server. The engines can periodically send heartbeat messages to the echo server which can continually send responses to each heartbeat request. If the echo server fails to respond for a specified period of time the engines can assume that the state tier server has become disabled and report that state server as previously described. In this manner even quicker failover detection is provided since the engines can notice failed servers without waiting for the time that access is needed and without relying on the TCP protocol s retransmission timers to diagnose a disconnection.

Failover can also be provided for the engine tier nodes. For example the engine tier nodes can periodically poll the state tier nodes in order to determine which timer objects need to fire as will be discussed in further detail below. In turn the state tier nodes can notice whenever the engine tier node has failed to poll. If a specified period of time elapses and the engine tier has not polled the state tier the state replica that should have received the poll from the engine can then report that engine as unavailable e.g. having failed or disconnected from the network . The engine node can be reported by the replica to the other engine nodes in the cluster. These engine nodes once notified can take the failed engine node out of the view of the cluster such that calls will no longer be routed to it by the load balancer. In this manner failover can be implemented for both the state tier and the engine tier thereby providing a more reliable and secure cluster for message processing.

As illustrated during message processing various engine nodes in the engine tier such as engine node A communicate with each replica in the partition . Depending on the network and call handling requirements the SIP server can allow for multiple partitions not shown in the state tier . During the usual flow of processing these communications are successful but sometimes a failure or a view change can be detected. In one embodiment a view change can signal that a new replica has joined the partition or that an existing replica has left the partition.

In this figure a failure is shown as being detected by the engine node A . As an example this can occur by the engine node requesting state information from primary replica A and replica A failing to respond to the request. In various embodiments failures can also be detected in other ways and it is not intended that the invention be limited by any particular method to detect such failures. Upon detecting the failure the engine node A can send a replica died message to any replicas in the partition A such as replica B as well as retrieve any needed state from the notified replica . In the case where there are no more replicas in the partition the partition A could be declared dead and steps can be taken to restore the partition. In this fashion the engine node A can report a failed replica to other replicas.

Upon receiving a failed replica notification replica B can take appropriate steps to propose a new partition view that excludes the dead replica. The various engine nodes can then be informed of the updated partition view and subsequently cease requesting state from the failed replica. In one embodiment when faced with a new partition the engine nodes that are performing a lock get state operation can immediately back off and retry their operations with the new view. As an illustration the SIP server engine can schedule a ten millisecond retry for this operation after which time the lock get operation can be retried with the new view.

In case of a view change occurring during a put operation the new view can first be inspected for added replicas in order to determine whether the view has changed because of a new replica joining the partition or an existing replica having left the partition because of failure. If it is determined that a new replica has joined the partition that new replica can also get the put request in order to ensure consistency in the state within the partition.

In various embodiments failover can also be provided for the engine tier. The state replicas can be responsible for detecting engine failure. Engine failure can have undesirable effects beyond the mere loss of processing power. For example if the engine is in the process of a lock get or put unlock operation during the failure it may abandon the locked call state for the messages that it is currently processing. Furthermore if the engine node is in the middle of processing a set of timer objects they may be abandoned because of the failure. Measures can be taken against such dangers.

In one embodiment the engine tier nodes are set to process the timer objects by periodically polling the state tier and querying for the timer objects which have expired and need to be processed. For example the SIP server may need to re send a particular message to a SIP client upon the expiration of a period of time because it can be assumed that the client did not receive it the first time it was sent. Such re transmission can be controlled by various timer objects. The engines can periodically e.g. every 200 ms poll the state tier to be provided with a set of timer objects which need to be processed. At this point the state tier can provide a subset of all the expired timer objects to each engine for processing. In effect the engine can check out the timer objects in order to process them.

In the case of an engine node failing to poll for a longer than specified period of time the state replica can assume that the engine node has failed or has become disconnected from the network. At this point it can inform other entities in the network about its failure such that calls are no longer being forwarded to the dead engine. Additionally the state tier can take measures to prevent any undesirable effects on state and timer objects.

If the engine node is in the process of a lock get operation when it fails there is a risk of permanently locking the state for the message being processed. On the other hand if the engine node is performing a put unlock there may by data inconsistencies across the replicas in the partition. In order to deal with this the replica can break the locks for call states if they are requested by another engine and the current lock holder is deemed failed. This can allow progress with the call state. Furthermore to deal with possible data inconsistencies where locks have to be broken the call state can be marked as possibly stale by the replica. Subsequently when an engine evaluates the response of a get lock operation it can choose the best data available i.e. if any replica in the partition reports non stale data the engine uses that data . Alternatively if there exists no nonstale data the possibly stale data may also be used since the data should only actually be stale if the single replica that had the nonstale version died in the intervening period.

If the engine node is in the middle of processing timer objects when it fails there is a risk that those timer objects may be affected adversely e.g. the set of timer objects may remain checked out indefinitely . As previously discussed the engine nodes check out timer objects from the state tier in order to process them. When engine failure is detected by the replica the set of checked out timer objects can be forcefully checked back in and rescheduled so that another engine can check out the set of timers and process them. In this manner timer operations need not be affected by engine failure nor by replica failure.

As illustrated in step the engines can write and read state information to and from the replicas in the state tier. For example when handling a message request an engine node may need state associated with the request and can retrieve it from a replica in the state tier partition. In one embodiment the long lived objects are retrieved from the state tier used as short lived objects in the engine tier and subsequently thrown out.

In step during an attempt to read or write state information to the state tier an engine may notice that a replica has failed or that the view for the partition has been changed. For example the engine node may not be successful in retrieving the needed data. In one embodiment the engine tier server uses its remote method invocation RMI connection to the replica to determine if the replica has failed or become disconnected. The algorithms used to determine a failure of an RMI connection can use the TCP protocol s retransmission timers to diagnose a disconnection e.g. if the network cable to the replica is removed . At this point the engine node can assume that the replica has failed become disconnected from the network or is otherwise not functioning properly. In alternative embodiments other intermediate steps can be performed before making failure assumptions such as attempting the retrieval process twice or detecting failures in another manner.

In step the engine node can then connect to a second replica in the same partition if one is available with partitions that only implement one replica failover possibilities may be more limited . Since the replica in the same partition has duplicate state as the failed replica the engine node can retrieve the needed state from the second replica. Furthermore the engine can also report the failed replica to the second replica in the partition as illustrated in step . This can be implemented by sending a replica died message to all replicas in the same partition as the failed replica.

As illustrated in step the replicas that have received the failure message from the engine node can then propose a new view for the partition one that would exclude the failed replica. Additionally the status of the failed replica can be changed to be offline. Subsequently other engine nodes can be notified of the updated partition view as illustrated in step . This can have the effect that other engine node servers cease attempting to retrieve write data from to the failed replica as illustrated in step .

In various embodiments the state replicas can have various different statuses. For example an online status can indicate that the server is available for managing call state transactions. An offline status can indicate that the server is shut down or unavailable. An online lock authority only status can indicate that the server was rebooted and is currently being updated from other replicas with the current state information. In one embodiment a recovering server cannot yet process call state transactions because it may not maintain a full copy of the call state managed by the partition. These statuses can be used during administration of the SIP server. For example if a state tier instances needs to be taken offline for scheduled maintenance the system administrator can ensure that at least one other server in the partition is active. This can be performed in order to prevent inconsistencies and loss of state data.

As previously described the engines can periodically poll the state tier replicas for which timer objects have expired and need to be processed as illustrated in step . This poll can be a query sent to the replica after each specified period of time. However at certain times it is possible that an engine may fail to poll the replica due to engine failure disconnection or some other fault within the system. Such an example is illustrated in step . The state replica can wait a specified period of time after the anticipated poll and after this period of time the state replica can assume that the engine node has failed as illustrated in . The period of time can be configurable in order to allow greater flexibility and improved response time to failover. After noticing the failure the replica can report the engine failure to other engines in the cluster and possibly to the load balancer such that calls are ceased from being routed to the dead engine.

At this point the replicas can perform certain safety procedures in order to ensure the consistency of state and timer objects as previously discussed. For example the replica can unlock state that was previously locked by the failed engine. Similarly the replica can check back in any timer objects which may have been checked out by the failed engine for processing. This can ensure a more reliable system by reducing any possible failure effects on the various system components.

As illustrated in step the engine nodes can communicate with the state tier replicas via Transfer Control Protocol TCP . In certain embodiments each replica server can have an echo server running thereon. The echo server can be a separate process running on the same physical machine as the replica. The purpose of such an echo server can be to provide a simple user datagram protocol UDP echo service to engine tier nodes to be used for determining when the engine tier server goes offline.

In step an engine node can send periodic heartbeat messages e.g. pings to the echo server running on the replica. In step the echo server can respond to each heartbeat such that the connection between the engine node and the replica is verified. In the event that the responses are normal the system can continue to function as previously described. In some cases however the replica can fail to respond to the heartbeat because of some fault or failure. In that case an engine node can mark the replica as being offline without having to wait for the normal TCP connection timeout as illustrated in step . At this point the engine node can also contact some other replica within the partition in order to report the failure and have the partition view updated as previously discussed.

In various embodiments the SIP server can be responsible for processing messages and calls from SIP clients via the use of the engine and state tiers as described above. As an example an application running on the engine tier can be implemented to receive messages from various SIP clients and to respond to those messages via the session initiation protocol. The flow of such calls can remain undisrupted by the failure of various state replicas or engine tiers by implementing the failover techniques previously described. The following is an exemplary description of a possible call flow processed by the SIP server architecture.

As illustrated a back to back user agent B2BUA having a running SIP server thereon can take the place of being an intermediary between the communications sent between various users. This can be done for purposes of controlling the call and message flow between user agent and user agent and in order to prevent any unwanted behavior and messages e.g. spamming hacking viruses etc. from being sent to the user agent device. It should be noted that although user agent and user agent are illustrated as telephones in the SIP messages can come from various other sources as well. For example the user agent can also be a cell phone a wireless device a laptop an application or any other component that can initiate a SIP type of communication. Similarly while illustrates communications between two user agents there can be more such user agents taking part of a single communication session. For example during a conference call there may be 20 or 30 user agents for all attendees of the conference each of which could send SIP messages to the B2BUA and receive transmissions back therefrom.

Continuing with the illustration a telephone call can be set up between user agent and user agent via the use of the SIP server. The first message sent from user agent to the SIP server on the B2BUA can be an invite message requesting to set up a telephone call with user agent . The invite message can be received by the load balancer of the SIP server and it can be directed to an engine in the engine tier for processing.

In various embodiments the engine tier e.g. an application executing thereon can then perform logic for determining various factors associated with the call such as determining whether user agent is allowed to make the type of call attempted to be initiated determining whether the callee that will be contacted is properly identified as well as any other logic that the server may need to calculate before attempting to set up a telephone call. The engine can then generate state around the fact that a call is being set up including generating the proper long lived and short lived objects associated with the messages as previously discussed. The engine can also determine how to find the target of the call i.e. user agent and the right path to route the message to the callee. As illustrated herein user agent is an originator as well as the terminator of the call and user agent is referred to as the callee.

After receiving the invite message the SIP server can send a 100 trying message back to user agent indicating that it has received the invite message and that it is in the process of handling it. The 100 trying message is part of the SIP protocol definition and can be used by a server in order to stop the user agent from re transmitting the invite request. In cellular phone environments the user agent may have interference which might cause an interruption or loss of various messages. Therefore SIP protocol defines various re transmission schemes in order to handle such mobility and interruptions. Messages such as 100 trying 180 ringing and 200 OK are just some of the examples of messages defined in SIP for handling communication.

Continuing with the illustration the SIP server can then send an invite message to the user agent and can receive back a 180 ringing message indicating that user agent has received the invitation and is now waiting for a user to answer. The SIP server engine tier can then transmit the 180 ringing message back to user agent . When a person finally answers the phone user agent can then send a 200 ok message to the SIP server the server can transmit that message to user agent . The user agent can send an acknowledgement Ack message to the SIP server which can be transmitted along to user agent and at this point a sound transfer conversation can be set up between the two user agents. This sound transfer can be implemented via real transfer protocol RTP on a media server. At the end of the conversation either user agent can choose to terminate the call by sending a Bye message. In this illustration user agent terminates the call by sending a Bye message to the SIP server which sends it off to user agent . After receiving back a 200 ok message from user agent the SIP server can transmit that message to user agent and the conversation can be truly ended.

In various embodiments the vertical lines such as those extending downward from the user agents and the B2BUA can each illustrate and be referred to as a single call leg. The call flow for each call leg may be time sensitive as some messages should be received or sent before others can be initiated. For example as illustrated herein the user agent A may continue to re transmit the initial invite message until it receives a 100 trying message from the B2BUA . As such in some cases certain messages may need to be processed synchronously while others may be allowed to process in parallel.

It should also be noted that this illustration of a call may be overly simplified for purposes of clarity. For example there can be various other message transmissions not illustrated such as authentication messages for caller callee determining the type of user agent the SIP server is communicating with and various other handshaking messages that can be exchanged between the SIP server and the user agents. Furthermore message transmitting steps may be added changed interrupted or rearranged in case of interference or failure of various components.

As previously discussed in various embodiments there may be specific sequences of messages exchanged between the SIP server and the user agents for controlling the flow of the call. These sequences can be controlled by various timer objects residing on the SIP server. As a nonlimiting illustration after receiving the invite message from one user agent the SIP server will typically forward that invite to another user agent and wait for a response. If no response is received within a period of time e.g. a number of milliseconds then the invite message may need to be retransmitted to the second user agent because it may be assumed that the user agent did not receive the first message. This type of re transmission can be controlled by the protocol timer objects which may be residing in the state tier. In one embodiment an initial T timer value of 500 milliseconds can control the retransmission interval for the invite request and responses and can also set the value of various other timers.

In various embodiments there are also other timer objects which can be executing on the level of the entire call. For example if after a specified period of time nothing is heard back from either user agent the entire call may be purged from the system. This specified period of time can also be controlled by firing a timer object.

In one embodiment as engine tier servers add new call state data to the state tier state tier instances queue and maintain a complete list of SIP protocol timers and application timers associated with each call. Engine tier servers can periodically poll the partitions of the state tier to determine which timers have expired given the current time. In order to avoid contention on the timer tables multiple engine tier polls to the state tier can be staggered. The engine tier can then process the expired timers using threads in the sip.timer.Default execute queue. Thus the processing of the timer objects can be executed by the engine server as determined by the state tier server. For example the state tier can tell the engine A to execute the first half of all due timer objects e.g. 1 100 and tell engine B to execute the other half e.g. 101 200 . The state tier can also simultaneously push the state onto the engine since the state may need to be employed in executing the timer objects. The engines can then process the timer objects e.g. by sending appropriate messages ending appropriate calls and can later again query poll the state tier for which timers have become due.

In various embodiments it may be preferable to synchronize system server clocks to a common time source e.g. within a few milliseconds in order achieve maximum performance. For example an engine tier server with a system clock that is significantly faster than other servers may process more expired timers than the other engine tier servers. In some situations this may cause retransmits to begin before their allotted time and thus care may need to be taken to ensure against it.

In various embodiments the SIP Servlet API can provide a timer service to be used by applications. There can be TimerService interface which can be retrieved from as a ServletContext attribute. The TimerService can define a createTimer SipApplicationSession appSession long delay boolean is Persistent java.io.Serializable info method to start an application level timer. The SipApplicationSession can be implicitly associated with the timer. When a timer fires an application defined TimerListener is invoked and ServletTimer object passed up through which the SipApplicationSession can be retrieved which provides the right context of the timer expiry.

In other aspects the invention encompasses in some embodiments computer apparatus computing systems and machine readable media configured to carry out the foregoing methods. In addition to an embodiment consisting of specifically designed integrated circuits or other electronics the present invention may be conveniently implemented using a conventional general purpose or a specialized digital computer or microprocessor programmed according to the teachings of the present disclosure as will be apparent to those skilled in the computer art.

Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of application specific integrated circuits or by interconnecting an appropriate network of conventional component circuits as will be readily apparent to those skilled in the art.

The present invention includes a computer program product which is a storage medium media having instructions stored thereon in which can be used to program a computer to perform any of the processes of the present invention. The storage medium can include but is not limited to any type of rotating media including floppy disks optical discs DVD CD ROMs microdrive and magneto optical disks and magnetic or optical cards nanosystems including molecular memory ICs or any type of media or device suitable for storing instructions and or data.

Stored on any one of the machine readable medium media the present invention includes software for controlling both the hardware of the general purpose specialized computer or microprocessor and for enabling the computer or microprocessor to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include but is not limited to device drivers operating systems and user applications.

Included in the programming software of the general specialized computer or microprocessor are software modules for implementing the teachings of the present invention including but not limited to providing systems and methods for providing the SIP server architecture as discussed herein.

Various embodiments may be implemented using a conventional general purpose or specialized digital computer s and or processor s programmed according to the teachings of the present disclosure as can be apparent to those skilled in the computer art. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure as can be apparent to those skilled in the software art. The invention may also be implemented by the preparation of integrated circuits and or by interconnecting an appropriate network of conventional component circuits as can be readily apparent to those skilled in the art.

Basic features. These include standards services such as Voice mail Caller ID Call waiting and call forwarding the ability to forward a call to a different number .

Call logs The ability to view calls made over a given period of time online ability to associate names with phone numbers integrate call log information to other applications such as IM.

Do not disturb The ability to specify policies around receiving calls for example all calls during office hours to be automatically forwarded to a mobile terminal all calls during the night to be directed to voice mail etc.

Locate me This is advanced call forwarding. Rather than have all calls forwarded to a single location e.g. voice mail when the caller is busy Locate me can try multiple terminals in series or in parallel. For example a user may have two office locations a mobile and a pager and it may make sense to forward a call to both office locations first then the pager and then the mobile terminal. Locate me is another example of feature interaction.

Personal conferencing A user could use an existing application e.g. IM client to schedule a Web audio conference to start at a certain time. Since the IM client already has personal profile information the conferencing system sends out the Web conference link information either through IM and or email to the participants. The phone contact information in the profile is used to automatically ring the participants at the time of the conference.

Lifetime number This is the facility where a single virtual number can travel with a customer wherever they live. Even if they move the old number continues to work and reaches them at their new location. This is really the analog of static IP addresses in a phone network.

Speed dial This is the ability to dramatically expand the list of numbers that can be dialed through short key and accelerator combinations. This is another example of a converged application since it s very likely that when a user will set up this information when they work through the call logs on the operator user portal and the updated information needs to be propagated to the network side in real time.

Depending on the service level agreement users are willing to sign up to the quality of media delivered e.g. number of frames per second will vary. The policy engine enables segmenting the customer base by revenue potential and to maximize return on investment made in the network.

A typical example here is the need for applications that have a short lifetime extremely high usage peaks within their lifetime and immediacy. For example voting on American Idol during the show or immediately afterwards has proved to be an extremely popular application.

The final class of applications is one that combines wireline and wireless terminal usage scenarios. An example of an integrated application is the following a mobile terminal user is on a conference call on their way to work. When he reaches his office he enters a special key sequence to transfer the phone call to his office phone. The transfer happens automatically without the user having to dial in the dial in information again. It s important to note hear that this capability be available without the use of any specific support from the hand set a transfer button for example .

Various embodiments include a computer program product which is a storage medium media having instructions stored thereon in which can be used to program a general purpose or specialized computing processor s device s to perform any of the features presented herein. The storage medium can include but is not limited to one or more of the following any type of physical media including floppy disks optical discs DVDs CD ROMs micro drives magneto optical disks holographic storage ROMs RAMs PRAMS EPROMs EEPROMs DRAMs VRAMs flash memory devices magnetic or optical cards nanosystems including molecular memory ICs paper or paper based media and any type of media or device suitable for storing instructions and or information. Various embodiments include a computer program product that can be transmitted in whole or in parts and over one or more public and or private networks wherein the transmission includes instructions which can be used by one or more processors to perform any of the features presented herein. In various embodiments the transmission may include a plurality of separate transmissions.

Stored one or more of the computer readable medium media the present disclosure includes software for controlling both the hardware of general purpose specialized computer s and or processor s and for enabling the computer s and or processor s to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include but is not limited to device drivers operating systems execution environments containers user interfaces and applications.

The foregoing description of the preferred embodiments of the present invention has been provided for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations can be apparent to the practitioner skilled in the art. Embodiments were chosen and described in order to best explain the principles of the invention and its practical application thereby enabling others skilled in the relevant art to understand the invention. It is intended that the scope of the invention be defined by the following claims and their equivalents.

