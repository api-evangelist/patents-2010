---

title: Boot restore system for rapidly restoring virtual machine backups
abstract: A boot restore system and associated processes for rapidly restoring virtual machine images are described. The boot restore system can boot a virtual machine from a set of one or more backup files in a backup repository. The boot restore system can make the backup set available for use by the virtual machine immediately or otherwise rapidly. Thus, users may not have to wait for an actual virtual disk image to be copied to a separate file system before accessing the restored backup set. While a user is accessing the virtual machine, a live migration process can migrate the backup set to a target file system, without any disruption or substantial disruption in use of the running virtual machine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09547562&OS=09547562&RS=09547562
owner: Dell Software Inc.
number: 09547562
owner_city: Aliso Viejo
owner_country: US
publication_date: 20101012
---
This application claims the benefit of priority under 35 U.S.C. 119 e of U.S. Provisional Patent Application No. 61 372 832 filed on Aug. 11 2010 and entitled System for Rapid Restore of Virtual Machine Image Backups the disclosure of which is hereby incorporated by reference in its entirety.

Many companies take advantage of virtualization solutions to consolidate several specialized physical servers and workstations into fewer servers running virtual machines. Each virtual machine can be configured with its own set of virtual hardware e.g. processor memory ports and the like such that specialized services that each of the previous physical machines performed can be run in their native operating system. For example a virtualization layer or hypervisor can allocate the computing resources of one or more host servers into one or more virtual machines and can further provide for isolation between such virtual machines. In such a manner the virtual machine can be a representation of a physical machine by software.

In many virtual machine implementations each virtual machine is associated with at least one virtual machine disk or image located in one or more files in a data store. The virtual machine image can include files associated with a file system of a guest operating system. The virtual machine image can be copied moved backed up or the like similar to a general data file.

Certain embodiments of this disclosure describe a boot restore system and associated processes for rapidly restoring virtual machine images. The boot restore system can boot a virtual machine from a set of one or more backup files in a backup repository. The boot restore system can make the backup set available for use by the virtual machine immediately or otherwise rapidly. Thus users may not have to wait for an actual virtual disk image to be copied to a separate file system before accessing the restored backup set. While a user is accessing the virtual machine a live migration process can migrate the backup set to a target file system without any disruption or substantial disruption in use of the running virtual machine.

For purposes of summarizing the disclosure certain aspects advantages and novel features of the inventions have been described herein. It is to be understood that not necessarily all such advantages can be achieved in accordance with any particular embodiment of the inventions disclosed herein. Thus the inventions disclosed herein can be embodied or carried out in a manner that achieves or optimizes one advantage or group of advantages as taught herein without necessarily achieving other advantages as can be taught or suggested herein.

Image based recovery of an entire virtual machine image can take a significant amount of time because the entire image file is generally copied from the backup repository to target storage over a network. Depending on the size of the image file and network traffic the recovery process can take many minutes and even hours of time. Image based recovery can take even longer when restoring a full backup file and associated partial backup files e.g. incremental or differential together. Once the full backup file is restored the changes from each partial backup file are typically restored to the full backup file until the restore is complete resulting in potentially significant restore time.

This disclosure describes a boot restore system and associated processes for rapidly restoring virtual machine images. In certain embodiments the boot restore system boots a virtual machine from a set of one or more backup files in a backup repository. The boot restore system can make the backup set available for use by the virtual machine immediately or otherwise rapidly. Thus in certain embodiments users do not have to wait for an actual virtual disk image to be copied to a separate file system before accessing the restored backup set. While a user is accessing the virtual machine a live migration process can migrate the backup set to a target file system over a network without any disruption or substantial disruption in use of the running virtual machine.

Before describing these boot restore features in greater detail an overview of virtualization and virtual machine backups will be described so as to give context to the boot restore features. The example boot restore system shown includes a host server that can be implemented with one or more computing devices. The host server can host one or more virtual machines executing on top of a hypervisor . In certain embodiments the hypervisor decouples the physical hardware of the host server from the operating systems of the virtual machine . Such abstraction allows for example for multiple virtual machines with different operating systems and applications to run in isolation or substantially in isolation on the same physical machine. The hypervisor can also be referred to as a virtual machine monitor VMM .

The hypervisor includes a virtualization platform that allows for multiple operating systems to run on a host computer at the same time. For instance the hypervisor can include a thin piece of software that runs directly on top of the hardware platform of the host server and that virtualizes resources of the machine e.g. a native or bare metal hypervisor . In such embodiments the virtual machines can run with their respective operating systems on the hypervisor without the need for a host operating system. Examples of such bare metal hypervisors can include but are not limited to ESX SERVER by VMware Inc. Palo Alto Calif. XEN and XENSERVER by Citrix Systems Inc. Fort Lauderdale Fla. ORACLE VM by Oracle Corporation Redwood City Calif. HYPER V by Microsoft Corporation Redmond Wash. VIRTUOZZO by Parallels Inc. Switzerland and the like.

In yet other embodiments the host server can include a hosted architecture in which the hypervisor runs within a host operating system environment. In such embodiments the hypervisor can rely on the host operating system for device support and or physical resource management. Examples of such hosted hypervisors can include but are not limited to VMWARE WORKSTATION and VMWARE SERVER by VMware Inc. VIRTUAL SERVER by Microsoft Corporation PARALLELS WORKSTATION by Parallels Inc. Kernel Based Virtual Machine KVM open source and the like.

For ease of illustration the remainder of this specification will refer to virtualization primarily in the context of VMWARE systems. However it should be understood that the boot restore features described herein can be implemented by many other virtualization platforms other than VMWARE. Further the term virtualization in addition to having its ordinary meaning can mean full virtualization or paravirtualization in certain embodiments.

Some or all of the virtual machines can include a guest operating system and associated applications. In such embodiments the virtual machine accesses the resources e.g. privileged resources of the host server through the hypervisor . However in some implementations the virtual machines can access at least some of the resources of the host server directly. At least some of the virtual machines can also include a backup service not shown which can assist with backup operations as described below.

The host server communicates with one or more data stores to access virtual machine data. For instance the data store s can include a file system that maintains virtual disk files or virtual machine images for some or all of the virtual machines on the host server . The virtual machine images can store operating system files program files and other data of the virtual machines . An example format of a virtual disk used by VMWARE is the virtual machine disk .vmdk format.

In certain embodiments the file system is a VMWARE virtual machine file system VMFS provided by VMware Inc. In such embodiments the VMFS file system enables multiple host servers e.g. with installations of ESX server to have concurrent access to the same virtual machine storage and provides on disk distributed locking to ensure that the same virtual machine is not powered on by multiple servers at the same time. Other platforms may have different file systems such as an NTFS file system . In other embodiments the file system and associated virtual machine images are stored on the host server instead of in a separate data store.

The data store s can include any physical or logical storage for holding virtual machine files. For instance the data store s can be implemented as local storage for the host server accessible using a serial advanced technology attachment SATA protocol a small computer system interface SCSI protocol or the like. The data store s can also be implemented as part of a storage area network SAN or network attached storage NAS . Accordingly the data store s can be accessed over a network using a protocol such as a fibre channel protocol FCP an Internet SCSI iSCSI protocol a network file system NFS protocol a common Internet file system CIFS protocol a file transfer protocol FTP a secure FTP SFTP protocol combinations of the same or the like. The data store s can also include one or more redundant arrays of independent disks RAID or the like.

The boot restore system further includes a network for communication between the host server and a management server . The network can provide wired or wireless communication between the host server the management server a backup repository and or the data store s . The network can be a local area network LAN a wide area network WAN the Internet an intranet combinations of the same or the like.

The management server can be implemented as one or more computing devices. The management server includes a backup module that can coordinate backup operations of the virtual machine disk files through the host server . In one embodiment the backup module causes a backup service not shown of the virtual machines to perform certain backup operations.

For example the backup service can perform shadow copy or snapshot operations such as are described in U.S. application Ser. No. 12 182 364 filed Jul. 30 2008 titled Systems and Methods for Performing Backup Operations of a Virtual Machine the disclosure of which is hereby incorporated by reference in its entirety. In addition the boot restore system can include additional features described in U.S. application Ser. No. 12 502 052 filed Jul. 13 2009 titled Backup Systems and Methods for a Virtual Computing Environment the disclosure of which is hereby incorporated by reference in its entirety. Further the boot restore system can implement the backup and restore features described in U.S. application Ser. No. 12 762 162 filed Apr. 16 2010 entitled Block Status Mapping System for Reducing Virtual Machine Backup Storage the disclosure of which is hereby incorporated by reference in its entirety.

More generally the backup module can perform full backups or full and partial backups of the virtual machine images . Full backups can contain a complete or substantially complete set of data from an image and can be used to restore an image to the state it existed at the time of the backup. Partial backups include into two main variations differential backups and incremental backups. A differential backup can be a cumulative backup of all or substantially all changes made since the last full backup. An incremental backup can be a backup of all or substantially all changes made since the last backup of any type.

As shown in a backup repository is also coupled to the network and can directly communicate with the management server . The backup module of the management server can store backup sets for each virtual machine in the backup repository . The backup sets can each include a full backup file and its associated partial backup file or files. If full backups are used without partial backups the full backup file can constitute the backup set.

A boot restore module on the management server can perform boot restores of the backup sets . Advantageously in certain embodiments the boot restore module restores a backup set by booting a virtual machine from the backup repository prior to copying the backup set to the data store s . Users can therefore access the restored virtual machine substantially immediately or otherwise rapidly without waiting for the image to be copied over the network to the data store s . Users can therefore potentially save seconds minutes or even hours when restoring virtual machines.

The boot restore module coordinates boot restores in certain embodiments with a virtual appliance running on the host server . The boot restore module can inject the virtual appliance on the host server to provide certain restore functionality on the host server . The virtual appliance can be a virtual machine that includes one or more modules for interfacing with the backup sets or stored in the backup repository . Although not shown the virtual appliance can include a virtual machine image in the data store or in another data repository see e.g. . In one embodiment the boot restore module includes logic for controlling and or automating the workflow of a boot restore process while the virtual appliance manages data accesses to the backup sets in the backup repository .

Advantageously in certain embodiments running a virtual appliance on a host can promote horizontal scalability of boot restore functionality. To illustrate a second host server is depicted which includes a second virtual appliance one or more virtual machines and a hypervisor . As host servers such as the host server are added to a datacenter the boot restore module can instantiate additional virtual appliances to run on the new host servers. In doing so the boot restore module can enable boot restore functionality on those servers. Each virtual appliance can assist with boot restores on one host server or alternatively on more than one host server.

In alternative embodiments some or all of the functionality of the boot restore module and or the backup module is included in the virtual appliances . The management server can be eliminated in such embodiments. In other embodiments the boot restore module performs the functionality of the virtual appliance . Thus the virtual appliance can be eliminated in such embodiments. Other configurations are possible.

Although the backup system has been described with reference to particular arrangements other embodiments can comprise more or fewer components. For example in certain embodiments the backup system can function without the backup repository and the backup sets can be stored in the data store s . In yet other embodiments the host servers can include a plurality of servers in a clustered arrangement such that the computing and memory resources of the clustered servers are shared by one or more virtual machines . Moreover in certain embodiments the backup module or restore module maintained by the management server can instead reside on the host server s and or the backup repository .

At block a request is received to restore a backup set archived in a backup repository. The request can be made by a user in one embodiment. The restore module described above can output a user interface that enables a user to initiate a boot restore. A user can select a full backup file or a full and one or more partial backup files to restore. Alternatively the user can specify a recurring restore window in which to restore a backup set or portion thereof periodically. Thus the request to restore a backup set or portion thereof can be provided by a user or by an automated scheduling component or the like.

A virtual machine is created at block . Creation of the virtual machine can include configuring the virtual machine to send data access I O requests such as reads and writes to the backup repository . However the backup set being restored from the backup repository may not be in a typical virtual machine image format capable of readily servicing read and write requests. For instance the backup set may be compressed and or may contain multiple files e.g. full plus partial s that have not been formatted into a virtual machine image.

Advantageously in certain embodiments the virtual machine is configured to send data access requests to the backup repository through the virtual appliance . The virtual appliance can transform the data access requests to the proper format for accessing the backup set. The virtual appliance can therefore abstract the backup set to the virtual machine making the backup set appear as a virtual disk image. Thus in certain embodiments the virtual appliance and or the boot restore module exposes a pseudo disk image to the virtual machine.

In other embodiments the virtual machine is configured to send data access requests directly to the backup repository . A software layer not shown can be installed on the backup repository to intercept and handle these requests. This software layer can take the place of or be used in conjunction with the restore module .

The virtual machine is powered on at block . The pseudo disk image is migrated to a different storage location at block . Users can advantageously use the restored virtual machine during the migration process. The migration process can be a live migration process which in addition to having its ordinary meaning can mean a migration of a virtual machine while the virtual machine is running. Examples of live migration processes that can be used include the vMotion and Storage vMotion applications provided by VMWARE.

At block of a backup set is mounted to a virtual appliance as a pseudo disk image. Mounting the backup set can be implemented by the boot restore module attaching the backup set as a block level device to the virtual appliance . Performing this mount can enable the virtual appliance to access the backup set as if it were an actual disk image. Using a pseudo disk image for backup sets containing multiple files can effectively result in merging interleaving or streaming together changes from backup files.

Functionality for performing this mount can be explained in the context of the more detailed boot restore system of . In the boot restore system a management server having a backup module and boot restore module is shown. These components can have all the functionality described above. A virtual appliance is also shown executing on a host server or servers . The virtual appliance can be implemented as a virtual machine in communication with a disk image stored in a file system . In one embodiment the file system is created by the boot restore module when initially deploying the virtual appliance . Providing the file system which can be separate from a customer s production file system e.g. the file system can ease setup of the virtual appliance .

The virtual appliance can include all the functionality of the virtual appliance described above. In the depicted embodiment the virtual appliance also includes a storage interface and a disk image manager . The storage interface can provide an interface for a target newly restored virtual machine to communicate with a backup set in a backup repository . The disk image manager can include a driver or the like that transforms the backup set into a pseudo disk image . The interface provided by the storage interface can allow the target virtual machine to access the pseudo disk image over a network or locally.

The disk image manager can transform the backup set into the pseudo disk image using one or more block directories stored with the backup set . The block directory or directories can be generated by the backup module for some or all backups performed. A block directory can be metadata that contains the disk locations of blocks in a backup file or backup set e.g. the backup set . The block directory can be a data structure such as a table map bitmap byte map array matrix or the like.

A block directory for a single backup file for example might contain information regarding the locations in a disk of the backup repository for each block of the backup file. For a full backup file the block directory can contain disk location information for all or substantially all blocks in an archived disk image. For a partial backup file the block directory can contain disk location information for the blocks changed in the partial backup file.

In one embodiment the disk image manager consolidates block directories for multiple files into a single block directory for the backup set . Alternatively the backup module can update a single block directory each time a new partial backup is performed. If the backup set is compressed into an archive file the block directory can be stored as part of the metadata in the archive file. The unified or single block directory can indicate for each block in an image the location on disk of the current block. The block directory can therefore include the locations of the most recent data in the backup set potentially reducing disk seeks to find the most recent data from individual backup files. A process for creating such a unified block directory is described below with respect to .

Referring again to at block the pseudo disk image is exposed or shared over a network such as the network of . This block can include assigning the pseudo disk image a network address which can further include a storage identifier. One example storage protocol that can be used to address the pseudo disk image is the Internet small computer system interface iSCSI protocol. Thus for example the boot restore module of can transform the pseudo disk image into an iSCSI target or iSCSI LUN logical unit number having an iSCSI target identifier. Once shared over iSCSI or another protocol the pseudo disk image can be zoned by the boot restore module as a raw disk to the host server s . As a raw disk the pseudo disk image can be accessible at the block level.

The iSCSI protocol is a block level protocol enabling addressing of the pseudo disk image at the block level. Other protocols including file level protocols e.g. NFS may be used to address the pseudo disk image . However in certain embodiments providing block level access to the pseudo disk image can provide better throughput than may be available with file level protocols. This improved throughput can be achieved because in certain embodiments file level overhead is avoided with iSCSI and other block level protocols. Further NFS and other file level protocols are often implemented in MICROSOFT WINDOWS environments whereas iSCSI is often implemented in LINUX environments. Architectural features of the iSCSI protocol and LINUX operating system can provide better scalability in enterprise deployments of the boot restore system than is available with the NFS protocol and MICROSOFT WINDOWS systems.

Referring again to a cache file is created in storage of the virtual appliance at block . An example of such a cache file is shown in . The cache file can include scratch space on the virtual appliance s disk image and can be used for caching writes to the pseudo disk image . In other embodiments the cache file is created in storage that is external to the virtual appliance s disk image such as in a repository accessible by the virtual appliance over a network. The cache file can be created by the virtual appliance or by the boot restore module . Caching is described in greater detail below with respect to block and .

At block of a new virtual machine is created with a mapping file that can map data access requests from the new virtual machine to the pseudo disk image. Referring again to the target virtual machine represents an example new virtual machine that can be created at block . In particular the boot restore module can create this target virtual machine . In one embodiment the virtual machine creator creates the target virtual machine with an application programming interface API call to a VMWARE API not shown or the like. The boot restore module creates the target virtual machine on the same host as the virtual appliance in certain embodiments to improve restore performance. However the virtual appliance and the target virtual machine can run on separate hosts in other implementations.

When creating the target virtual machine the boot restore module can create one or more configuration files including a mapping file a log file and a .vmdk descriptor file among possibly others. In VMWARE systems the mapping file can be a raw device mapping RDM . The RDM file can be a physical RDM or a virtual RDM vRDM that supports VMWARE snapshot functionality. More generally the mapping file can map data access e.g. I O requests to a raw device for example the pseudo disk image .

The mapping file can provide metadata regarding the pseudo disk image such as layout information of the pseudo disk image including disk size a number of sectors a number of cylinders and the like. The mapping file can also include a network address and or storage address of the pseudo disk image . In one embodiment this network address includes an IP address of the virtual appliance e.g. the virtual appliance together with the iSCSI target identifier and or LUN of the pseudo disk image . The mapping file can therefore redirect data access requests from the target virtual machine to the pseudo disk image .

For example once the target virtual machine is powered on data access requests from the target virtual machine to the mapping file can be redirected to the storage interface arrow . The storage interface can implement storage server software such as iSCSI server software or the like that services iSCSI or other storage requests. The storage interface can communicate with the target virtual machine via the mapping file using a communications protocol or protocols such as the TCP IP protocol stack. The storage interface can extract storage commands e.g. SCSI commands from packets received from the target virtual machine . The storage interface can pass the extracted storage commands to the disk image manager which can perform reads writes or other storage commands. Likewise the storage interface can encapsulate any data received from the disk image manager into TCP IP packets or other communications messages and send these packets or messages to the target virtual machine .

Advantageously the mapping file can be located in the file system which can be a production data store of a customer or the like. Other disk images for other virtual machines of the customer can also be on the file system . In other embodiments the mapping file can be placed on the file system which can be an out of the box file system provided by a vendor of the virtual appliance .

The new virtual machine is powered on or otherwise started at block of . Powering on the new virtual machine can include loading some or all of the virtual machine into memory of a host server and executing instructions of the virtual machine s operating system. The virtual machine can be powered on by the virtual machine creator of .

With continued reference to once the virtual machine is powered on at block the virtual machine is allowed to access the pseudo disk image at block . Reads to the pseudo disk image are passed through to the backup set in certain embodiments whereas writes to the pseudo disk image are redirected to the cache file created above. This redirection and caching are performed in certain embodiments until a migration process completes block . Referring to the disk image manager can manage read and write accesses to the pseudo disk image . Management of data access requests is described in greater detail below with respect to .

Referring again to a live migration of the pseudo disk image to a virtual disk image is performed at block . Advantageously in certain embodiments this live migration can be performed without interrupting or substantially interrupting usage of the restored virtual machine. As part of this live migration process the mapping file can optionally be converted to an actual virtual machine image see . For example in VMWARE systems the mapping file can be converted from an RDM or vRDM file to a VMDK virtual machine disk file. Live migration can be performed by the boot restore module making an API call to a vMotion or Storage vMotion process in VMWARE systems.

During the live migration process data from the backup set and the cache can be interleaved together to form an actual virtual disk image. This interleaving can be abstracted from the live migration process by the disk image manager . For instance the disk image manager can supply the most recent changed blocks from the cache or backup set as identified by the block directory when requested by the live migration process e.g. via the storage interface . The disk image manager can supply unchanged blocks from a full backup file in the backup set . Of course if the backup set includes only a full backup file the disk image manager can provide changed blocks from the cache and unchanged blocks from the full backup file. By interleaving the changed and unchanged blocks in this manner the disk image manager can enable the live migration process to seamlessly integrate the changed and unchanged blocks into an actual virtual disk image.

The process and associated systems can provide several advantages. One possible advantage is that users can use the restored virtual machine on boot of the virtual machine which can provide much faster access to the restored virtual machine than in currently available systems. Another possible advantage is that the user is able to use the virtual machine both before and during the live migration process. Moreover when the virtual appliance and target virtual machine are on the same host fewer computing e.g. processor resources may be needed to perform the live migration.

In alternative embodiments at least some of the features of the process or system may be altered or omitted. For instance in one implementation live migration is not performed. Live migration may be omitted to permit quick maintenance on a virtual machine or for testing purposes among other reasons. Further the mapping file need not be changed to a virtual disk image in some cases depending on user preference. Many other configurations are possible.

At block a full backup is performed. The full backup can be performed using any of the backup tools described above with respect to . At block the resulting backup file from the full backup is stored in a backup repository. Storing the full backup file can optionally involve compressing the full backup file into an archive file using any suitable compression algorithm or algorithms. The archive file can include among other data blocks and associated block headers. The block header for each block can include information such as a hash of the data in the associated block a file identifier associated with the block which can distinguish the backup file containing a most recent copy of the block and an offset within the file from which the data block was read during backup and to which it may be written during restore.

A block directory is created at block for the full backup file. The block directory can map blocks in the full backup file to locations in a disk of the backup repository where the blocks are stored. The block directory can include the block headers for some or all of the blocks in the full backup file. Because the block header for each block can identify the backup file to which the block belongs the most current blocks may be referenced by the block directory. Thus far a full backup file has been used to create the block directory and therefore the block headers refer to the full backup file.

At decision block it is determined whether a partial backup has been performed. If so at block the resulting partial backup file is stored in the backup repository. At block each block that was changed in the partial backup file is updated in the block directory. For example new block headers can be inserted in the block directory which correspond to the new or changed blocks in the partial backup file. Block headers may also be removed from the block directory if blocks are deleted. New block headers can identify the backup file where the actual blocks are found and can overwrite previous block headers corresponding to older data. Thus in certain embodiments the block directory can include some or all the metadata useful to seek an arbitrary point in a backup set archive in a single place thereby reducing disk seeks when accessing the backup set archive as a pseudo disk image.

The process A loops back to decision block . If additional partial backups such as incremental backups are performed the process A can loop through blocks through for each additional partial backup. Otherwise if no further backups are to be performed the process A ends. Although described primarily in the context of blocks the directory can more generally reflect changes in disk locations of any portion of a backup set such as a partition file cluster sector chunk of blocks or the like.

The process A can be implemented so as to store the block directory in memory rather than in an archive or any backup files. In this manner an archive or backup file can be kept in an unchanged condition so as to minimize potential corruption of archived data. Thus the process BA can be performed as a post process after the backups in a backup set full and any partial backups have been performed. For instance the unified block directory for a backup set can be created by analyzing the block directory for each backup file according to the process A starting with the full backup and proceeding to the first partial backup followed by any subsequent partial backups. In other embodiments the block directory can be stored in the archive or in an individual backup file or in another place in disk storage. The block directory can also be stored in disk storage and in volatile memory.

At block a virtual machine sends a data access request to a mapping file. This virtual machine can be the restored or target virtual machine discussed above and the mapping file can be the mapping file referred to above. In response to receiving the request at block the mapping file redirects the request to a pseudo disk image shared over a network by the disk image manager .

It is determined at decision block for example by the disk image manager whether the data access request is a read request. If so it is further determined by the disk image manager at decision block whether the data sought to be read is in the cache file . If so the disk image manager accesses the cache file and returns the resulting data to the virtual machine at block .

If not the disk image manager consults a block directory at block to determine where in the pseudo disk image the requested data is stored. For example the disk image manager can access the block headers in the block directory to determine which backup file in a backup set includes the data to be read. This data can be in a partial backup file or a full backup file for instance. The disk image manager reads the data from the pseudo disk image from the appropriate backup file and returns the resulting data at block .

If the data access request is a write request instead of a read request the disk image manager writes to the cache file instead of to the backup set. By redirecting writes to the cache file the disk image manager can leave the backup set unchanged. The disk image manager can use a copy on write mechanism to write to the cache file . In alternative embodiments the disk image manager writes directly to the backup set instead of writing to a cache file . The disk image manager can write to the cache even during a live migration process see .

Further in other embodiments the disk image manager can service data access requests without the use of a block directory. Instead the disk image manager can directly access each backup file from latest to earliest to determine which file contains the most recent sought after data. Many other variations are possible.

In some embodiments data obtained from the pseudo disk image from read requests can also be cached in the cache file . Subsequent requests for this data can therefore first access the cache file to determine whether the requested data has been cached. If the requested data has not been cached the read request can be passed to the pseudo disk image.

Depending on the embodiment certain acts events or functions of any of the algorithms described herein can be performed in a different sequence can be added merged or left out all together e.g. not all described acts or events are necessary for the practice of the algorithm . Moreover in certain embodiments acts or events can be performed concurrently e.g. through multi threaded processing interrupt processing or multiple processors or processor cores or on other parallel architectures rather than sequentially.

The various illustrative logical blocks modules and algorithm steps described in connection with the embodiments disclosed herein can be implemented as electronic hardware computer software or combinations of both. To clearly illustrate this interchangeability of hardware and software various illustrative components blocks modules and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. The described functionality can be implemented in varying ways for each particular application but such implementation decisions should not be interpreted as causing a departure from the scope of the disclosure.

The various illustrative logical blocks and modules described in connection with the embodiments disclosed herein can be implemented or performed by a machine such as a general purpose processor a digital signal processor DSP an application specific integrated circuit ASIC a field programmable gate array FPGA or other programmable logic device discrete gate or transistor logic discrete hardware components or any combination thereof designed to perform the functions described herein. A general purpose processor can be a microprocessor but in the alternative the processor can be a controller microcontroller or state machine combinations of the same or the like. A processor can also be implemented as a combination of computing devices e.g. a combination of a DSP and a microprocessor a plurality of microprocessors one or more microprocessors in conjunction with a DSP core or any other such configuration.

The steps of a method process or algorithm described in connection with the embodiments disclosed herein can be embodied directly in hardware in a software module executed by a processor or in a combination of the two. A software module can reside in RAM memory flash memory ROM memory EPROM memory EEPROM memory registers hard disk a removable disk a CD ROM or any other form of computer readable storage medium known in the art. An exemplary storage medium can be coupled to the processor such that the processor can read information from and write information to the storage medium. In the alternative the storage medium can be integral to the processor. The processor and the storage medium can reside in an ASIC. The ASIC can reside in a user terminal. In the alternative the processor and the storage medium can reside as discrete components in a user terminal.

Conditional language used herein such as among others can might may e.g. and the like unless specifically stated otherwise or otherwise understood within the context as used is generally intended to convey that certain embodiments include while other embodiments do not include certain features elements and or states. Thus such conditional language is not generally intended to imply that features elements and or states are in any way required for one or more embodiments or that one or more embodiments necessarily include logic for deciding with or without author input or prompting whether these features elements and or states are included or are to be performed in any particular embodiment. The terms comprising including having and the like are synonymous and are used inclusively in an open ended fashion and do not exclude additional elements features acts operations and so forth. Also the term or is used in its inclusive sense and not in its exclusive sense so that when used for example to connect a list of elements the term or means one some or all of the elements in the list.

While the above detailed description has shown described and pointed out novel features as applied to various embodiments it will be understood that various omissions substitutions and changes in the form and details of the devices or algorithms illustrated can be made without departing from the spirit of the disclosure. As will be recognized certain embodiments of the inventions described herein can be embodied within a form that does not provide all of the features and benefits set forth herein as some features can be used or practiced separately from others. The scope of certain inventions disclosed herein is indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

