---

title: Atomic switching of images in desktop streaming over wide area networks
abstract: Techniques are provided for desktop streaming over wide area networks. In one embodiment, a computing device comprises pivot logic that is configured to be executed during a first boot of an operating system on a computing device as a pivot process that is the only process running when performing modifications to a file system on the computing device. During execution, the pivot process replaces a current set of files in the file system with a new desktop image that represents a complete view of the file system. The desktop image includes a prefetch set of files, but other files in the desktop image are represented by file metadata. The prefetch set of files includes a smallest subset of files that is needed to boot the computing device without requiring retrieval of additional files. During execution, the pivot process terminates the first boot and to invoke a second boot that is executed based on the prefetch set of files included in the new desktop image.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08301874&OS=08301874&RS=08301874
owner: Wanova Technologies, Ltd.
number: 08301874
owner_city: South Netanya
owner_country: IL
publication_date: 20100312
---
This application claims priority and benefit under 35 U.S.C. 119 e to U.S. Provisional Patent Application Ser. No. 61 253 419 filed by Israel Ben Shaul et al. on Oct. 20 2009 and titled DESKTOP STREAMING OVER WIDE AREA NETWORKS the entire content of which is hereby incorporated by reference as if fully set forth herein.

This application is related to U.S. patent application Ser. No. 12 723 572 filed by Israel Ben Shaul et al. on Mar. 12 2010 and titled Desktop Streaming Over Wide Area Networks the entire content of which is hereby incorporated by reference as if fully set forth herein.

This application is related to U.S. patent application Ser. No. 12 723 550 filed by Israel Ben Shaul et al. on Mar. 12 2010 and titled On Demand Block level File System Streaming to Remote Desktops the entire content of which is hereby incorporated by reference as if fully set forth herein.

This application is related to U.S. patent application Ser. No. 12 270 715 filed by Israel Ben Shaul et al. on Nov. 13 2008 and titled DESKTOP DELIVERY FOR A DISTRIBUTED ENTERPRISE the entire content of which is hereby incorporated by reference as if fully set forth herein.

This application is related to U.S. patent application Ser. No. 12 578 485 filed by Israel Ben Shaul et al. on Oct. 13 2009 and titled STORAGE NETWORK DE DUPLICATION the entire content of which is hereby incorporated by reference as if fully set forth herein.

The approaches described in this section are approaches that could be pursued but not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.

Enterprise desktop management generally refers to managing protecting and distributing the disk contents of a large number of computers in an enterprise such as for example a company an educational institution or a government or non government organization. Enterprise desktop management is one of the most challenging Information Technology IT tasks for several reasons.

One reason is the complexity of managing a large number of different desktop instances that may exist on enterprise computers. The sheer number of computers to manage the proliferation of operating system OS images and applications and the complex set of operations to apply including but not limited to deployment and provisioning patching upgrades application installations and management compliance testing troubleshooting and re imaging all make the managing of enterprise computers a very challenging task. This task is further complicated because typically the execution of end user workloads and applications is delegated to the endpoint enterprise computers for the purposes of cost effectiveness improving performance and the end user experience and providing the end users with the ability to work offline.

Another reason that makes enterprise desktop management a challenging task is that nowadays most enterprises are dispersed over multiple geographic locations. The use of Local Area Networks LANs that are connected over one or more Wide Area Networks WANs with variable bandwidths and latencies is a serious barrier to providing efficient desktop management without sacrificing the end user experience. For example various desktop management operations e.g. deployment and provisioning patching upgrades application installations etc. typically need to be performed on end user computers over low bandwidth and high latency networks while the end users justifiably expect to be able to start working on their computers without significant delays and without having to wait for long running management operations to complete.

Techniques are provided for desktop streaming over wide area networks. In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

The techniques described in the present disclosure provide for streaming desktop images from a centralized location e.g. such as a data center to a computing device over one or more networks.

As used herein desktop image or just image refers to data and executables that comprise substantially the entire content that is stored at a computing device including the operating system OS applications configuration and settings as well as all user data and files. For example in some embodiments a desktop image includes all files that are stored on one or more physical storage devices e.g. such as hard disks or solid state storage devices in a computing device. In other embodiments a desktop image includes all files that are stored on one or more physical storage devices in a computing device except files that are temporary or transient in nature and that do not need to be centrally managed. It is noted that the target computing device also referred to as endpoint or endpoint device can be a virtual or a physical machine and can have limited physical storage space that may be smaller than the size of the entire desktop image that is centrally maintained for that computing device.

According to the techniques described herein a desktop image includes a collection of files that store data in compressed or non compressed form and the data may be unformatted e.g. binary data raw disk blocks raw data partitions etc. or structured as various types of files e.g. data files DLL files executable files personal user files of various file types various types of configuration files etc. and or any other type of data structure format. The collection of files included in a desktop image is sometimes referred to hereinafter as a Centralized Virtual Desktop CVD . The set of one or more desktop images which are maintained centrally for a particular computing device is sometimes referred to hereinafter as a Personal Virtual Disk PVD .

As used herein streaming a desktop image refers to transferring or otherwise transmitting the desktop image files in a sequence over one or more networks. In accordance with the techniques described herein the sequence in which the files in a desktop image are streamed to a computing device is determined specifically for that particular computing device. This allows for streamlining the centralized management of desktop images for a large number of computing devices while at the same time enabling each individual computing device to start operating as quickly as possible by transferring over the network only the minimal amount of data that is necessary for that individual computing device to start operation.

In a distributed system that centralizes the management of desktop images in a data center but executes the desktop images in remote endpoint devices there is a need to provide a mechanism for fast downloading of a desktop image or any software updates to that image onto the remote endpoint device that is associated with that image. Use cases for downloading a desktop image onto a corresponding endpoint device include but are not limited to 

The desktop image on the endpoint device has been lost stolen or broken and the user of the device lost all data and customizations including applications that resided on the device. The user wants to resume as soon as possible her complete working environment on a new hardware or replace an old hard disk with a new one.

A user has software corruption and needs a copy of his last known working image to be downloaded to the endpoint device operated by the user.

The desktop image on the endpoint device is malfunctioning. The IT support person who is managing a data center that is remote from the endpoint device can stream the relevant parts of the desktop image onto a local workbench device and troubleshoot the desktop image locally in the data center while the end user might be offline and continue to work. When the IT person fixes the problem she streams the fixed desktop image back to the remote endpoint device operated by the user. Hence the desktop image in this use case may be transferred twice over the network.

A user does not have his computing device e.g. laptop with her but still wants to access her centralized desktop image using thin client mechanisms. In this use case the desktop image can be downloaded or reassigned onto a local endpoint possibly a virtual machine at the data center and the user can be granted access to the local endpoint using a remote desktop protocol.

A user wants to access his single logical desktop image from multiple physical endpoints e.g. a desktop computer and a laptop . On every transition the user needs the logical desktop image to get downloaded to the endpoint device that the user is currently using.

In an example operational context the techniques described herein provide for streaming desktop contents onto an endpoint device over a wide area network so as to enable the endpoint device to get a desktop image quickly in order to start its operation without having to wait for the entire image to get downloaded and by requiring minimal amount of data on the endpoint device before it can start its operation.

According to the techniques described herein in one embodiment a computer comprises one or more processors and logic that is stored in one or more storage media and is executable by the one or more processors. When executed the logic receives over a network a first request for a desktop image of a computing device where the desktop image includes a collection of files for the computing device. The logic segments the desktop image into a prefetch set a streaming set and a leave behind set. The prefetch set includes a smallest subset of files in the collection of files that is needed to boot up the computing device without requiring retrieval of additional files over the network. The streaming set includes those files in the collection of files that are to be downloaded to the computing device after the computing device has booted up. The leave behind set includes those files in the collection of files that are to be downloaded to the computing device when specifically requested. In response to the first request the logic sends the prefetch set to the computing device which causes the computing device to boot up from files in the prefetch set. After the prefetch set has been sent the logic receives a second request for the streaming set and in response thereto sends the streaming set to the computing device.

According to the techniques for desktop streaming described herein in one embodiment a computing device comprises one or more processors one or more storage media coupled to the one or more processors and logic that is stored in the one or more storage media and is executable by the one or more processors. When executed the logic sends over a network a first request for a desktop image of the computing device where the desktop image includes a collection of files for the computing device and where the desktop image is segmented into a prefetch set a streaming set and a leave behind set. In response to the first request the logic receives the prefetch set and boots up the computing device from files in the prefetch set. After the computing device has booted up the logic sends a second request for the streaming set and in response thereto commences receiving the streaming set.

According to the techniques for desktop streaming described herein in one embodiment a computer comprises one or more processors and logic that is stored in one or more storage media and is executable by the one or more processors. When executed the logic receives over a network a first request for a desktop image of a computing device where the desktop image includes a collection of files for the computing device. The logic determines that a first hardware indicated in the desktop image is not compatible with a second hardware of the computing device that is indicated in the first request. The logic generates a rebased desktop image by modifying the desktop image where the rebased desktop image includes a modified collection of files that matches the second hardware of the computing device. The logic segments the rebased desktop image into a prefetch set a streaming set and a leave behind set by assigning each file of the modified collection of files to one of the prefetch set the streaming set and the leave behind set. In response to the first request the logic sends the prefetch set to the computing device which causes the computing device to boot up from files in the prefetch set. After the prefetch set has been sent the logic receives a second request for the streaming set and in response thereto sends the streaming set to the computing device.

According to the techniques for desktop streaming described herein in one embodiment a computing device comprises one or more processors one or more storage media coupled to the one or more processors and interceptor logic that is stored in the one or more storage media and is executable by the one or more processors. The interceptor logic is configured to execute in the kernel of the operating system OS on the computing device. When executed the interceptor logic receives from a first process executing on the computing device a first request to open a file in a file system that is supported by the OS where the first request to open the file specifies a first sharing mode that precludes other processes executing on the computing device from opening the file. In the file system at least one block from the file has not yet been downloaded to the computing device over a network. In response to the first request the interceptor logic modifies the first sharing mode to a read write sharing mode that allows other processes to open the file for reading and writing. The interceptor logic receives over the network one or more blocks from the file and writes the one or more blocks into the file. While the one or more blocks are being received or written into the file the interceptor logic receives a second request to open the file from a second process executing on the computing device where the second request specifies a second sharing mode. The interceptor logic checks the second sharing mode for compatibility with the first sharing mode and denies the second request to open the file when the second sharing mode is not compatible with the first sharing mode even though in the file system the file is opened in the read write sharing mode.

According to the techniques for desktop streaming described herein in one embodiment a computing device comprises one or more processors one or more storage media coupled to the one or more processors and pivot logic that is stored in the one or more storage media and is executable by the one or more processors. The pivot logic is configured to execute during a first boot of the operating system OS on the computing device as a pivot process where the pivot process is the only process running when it performs modifications in a file system on the computing device. During execution the pivot process causes the one or more processors to replace a current set of files in the file system with a new desktop image where the new desktop image presents a complete view of the file system. The new desktop image includes a prefetch set of files where the prefetch set of files includes a smallest subset of files that is needed to boot the computing device without requiring retrieval of additional files over a network. Files other than the files in the prefetch set are represented in the complete view of the file system only by file metadata that is included in the desktop image. After replacing the current files in the file system with the new desktop image the pivot process terminates the first boot and invokes a second boot that is executed based on the prefetch set of files included in the new desktop image.

In other embodiments the techniques for desktop streaming provide one or more methods for performing the functionalities described herein and one or more computer readable storage media that stores the logic for performing these functionalities in the form of executable program instructions.

The implementation of fast desktop streaming over wide area networks is a challenging task. Specifically fast downloading of a desktop image to a remote endpoint device over a wide area network presents several technological challenges.

A typical desktop image which includes both system and user files is typically in the range of 10 50 GB in size. A typical network link connecting an endpoint device to a data center typically has a bandwidth of 1.5 Mbps e.g. a T1 link and latency of 60 120 ms roundtrip delay. Even if it is assumed that downloading the desktop image fully utilizes the T1 link which is rarely the case since the link is also used for other purposes downloading even 20 GB over a T1 link would take roughly 28 hours to complete. What the techniques described herein achieve is to cut the time users have to wait before they resume their work by two orders of magnitude that is they enable users to resume their work within minutes instead of hours or days.

Unlike streaming of user mode applications or regular user data desktop streaming involves sensitive elements that are responsible for the actual operation of an endpoint device itself including the OS kernel drivers security products and elements that need to run the streaming logic itself at the receiving endpoint device.

Dependence on constant network connectivity cannot be assumed required or relied upon when it comes to desktop streaming. For example in a typical operational context the techniques described herein are used for remote and mobile users who typically use laptops as their endpoint devices and need to be able to work offline. To address this the techniques described herein enable the end users to work offline after the restore operation of a new desktop image on an endpoint device has completed.

One goal of the techniques described herein is to ensure that the user experience is such that once the endpoint device is executing the newly downloaded image the performance from the user perspective should be near native and not sluggish e.g. due to network delays or latency etc. .

The techniques described herein do not require or assume that an endpoint device will run as a virtual machine that is hosted by another remote physical machine. This implies that the desktop streaming mechanism needs to be able to install the desktop image on the hardware of the endpoint that initiated the restore download process. In particular the desktop streaming mechanism should be able to perform an atomic switch of images in which the newly downloaded image replaces whatever image was resident and initiated the download process. Alternatively if the endpoint device image does not exist or cannot perform the download task the desktop streaming mechanism provides means to boot the endpoint device over the network and apply the downloaded image onto the native hardware.

The new target hardware onto which a desktop image is to be downloaded may be different than the previous hardware in which the desktop image was executed. Therefore the desktop image needs to rebased into a new image that is capable of installing properly on a different hardware.

In some cases an endpoint device e.g. such as a Netbook may have a small disk but it may be desirable or necessary to enable such endpoint device to operate with a logical disk that is bigger than the physical disk at the device perhaps as part of migrating from one type of device to a device with a smaller disk . The techniques described herein address these cases by streaming only a sub set of the desktop image while supporting on demand requests for missing files via caching.

As used herein computing device refers to a computer system that is operable to execute an operating system OS and software applications and to store user data. Examples of computing devices include but are not limited to desktop computers laptop computers netbook computers and wireless mobile devices such as personal digital assistants PDAs and smart phones like iPhone BlackBerry and Treo. Another example of a computing device is a virtual machine such as VMware s player or ESX which executes an OS and applications just like any other hardware except that the hardware is emulated with software. It is noted that the techniques for desktop streaming described herein are not limited to being implemented for any particular type of computing device rather the techniques described herein may be implemented for any computing device that is operable to execute an OS and software applications and to store user data. For this reason the examples of computing devices provided herein are to be regarded in an illustrative rather than a restrictive sense.

The term operating system or OS is used herein in its commonly accepted meaning and refers to a set of software components including an OS kernel that are responsible for the allocation management coordination and sharing of computer system resources that are used by other applications or components of a computing device a computer system or any type of computer. Examples of such computing resources include without limitation Central Processing Units CPUs or processors memory disk storage space network communication interfaces and various peripheral devices such as a video display e.g. a monitor a pointing device e.g. a mouse and a keyboard. When executed on a computing device an OS controls the operation of the computer system hardware and provides a number of services to software applications that execute on the computing device. Examples of such services include without limitation file system services that allow for storing and maintaining files on storage devices memory management services that allocate and manage dynamic memory for software applications network management services that provide for network access user interface services e.g. shells command line interfaces and graphical user interfaces that allow users to submit commands directly to the OS user logon and other user related security services and a number of other services that provide various functionalities to kernel mode and user mode software applications that may execute on a computing device. Typically a software application is operable to request a service from the OS by making a system call or by executing an OS command and to receive the results of the system call or OS command. Examples of operating systems include but are not limited to Unix operating systems e.g. Solaris OS provided by Sun Microsystems Inc. and AIX provided by IBM Linux operating systems e.g. Red Hat Linux and Debian Linux and the Windows family of operating systems provided by Microsoft Corporation e.g. Windows XP Windows Vista and Windows CE .

As used herein data center refers to a combination of one or more computer systems and one or more storage devices that are communicatively and or operatively connected to the computer systems where the computer systems are operable to store and manage data in the storage devices. Examples of storage devices include without limitation hard disks optical disks and any other now known or later developed electro magnetic or solid state storage devices. In various embodiments and implementations a data center may use storage devices that are installed according to various types of storage configurations. Examples of such storage configurations include but are not limited to directly attached storage that includes physical disks installed in computer systems arrays of physical disks e.g. various RAID configurations network attached storage NAS that is connected to a network and that uses file level protocols to provide file access to various network clients storage area networks SAN that provides for attaching remote storage devices e.g. electro magnetic or optical disk arrays tape devices etc. over a network fabric in such a way that the storage devices appear local to the OSs of computer systems and that allows the OSs of the computer systems to access and operate on data in the storage devices at the disk block level and any combinations of multiple different storage configurations.

It is noted that in the example operational context illustrated in the techniques described herein do not require computing devices to be continuously and constantly connected to data center in order to operate. Rather the techniques described herein provide for computing devices that can operate offline that is users can use computing devices without the computing devices being connected to data center . Thus in the context of the techniques described herein offline refers only to operating a computing device while the computing device is not connected to the data center while operating offline the computing device may or may not be connected to one or more local networks or to the Internet.

CVD server is configured to execute on computer system s and to manage a CVD repository of desktop image s on storage devices . As used herein server refers to a combination of integrated software components and an allocation of computational resources such as memory CPU time and or disk storage space where the integrated software components are operable to perform one or more functionalities when executed by one or more processors of one or more computer systems computing devices or other computers.

For example in some embodiments CVD server is configured to receive from computing devices changes that are made by users and applications to disk contents at the computing devices and to apply the received changes to the corresponding desktop image s in the CVD repository in order to update and keep current the files stored in the images. The changes that are made to the disk contents at computing devices may include but are not limited to changes that are made to OS files including OS configuration files such as for example Windows registry files where such changes may include updating existing files adding new files and deleting files changes that are made to software application files including updating existing application files adding new application files and deleting application files and any other file updates file deletions and file insertions that are made to any user files and directories user configuration files and any other user data.

In another example in some embodiments CVD server may be further configured to associate each desktop image with metadata information not shown in that identifies the particular computing device associated with that image. The metadata information for a particular desktop image may include an image identifier that uniquely identifies that particular desktop image a device identifier that uniquely identifies a particular computing device that stores the disk content of that particular desktop image and any other data e.g. such as user ID and or other user account data that is associated with the particular desktop image and or the particular computing device. The set of metadata information associated with desktop image s is used by CVD server at least to determine which desktop image needs to be updated when disk content changes are received from a particular computing device and to locate or otherwise determine which desktop image to send to a particular computing device upon request. Further for each of desktop images CVD server may also be configured to store and or otherwise associate a machine profile of the corresponding computing device . The machine profile for a computing device is a set of data that may include one or more unique identifiers of the computing device such as a security identifier e.g. SID a device identifier e.g. a MAC address a device name e.g. a unique domain name or a machine name and one or more network addresses e.g. an IP address a hardware identifier that identifies the hardware type of the computing device driver configurations for OS drivers application configurations for one or more software applications that are installed on the computing device OS configurations that are specific to the user s of the computing device and any other configuration information that is specific to the hardware and or software components of the computing device and or to one or more users that have local logon accounts on the device.

According to the techniques for desktop streaming described herein CVD server is configured to segment a desktop image for each computing device into a prefetch set a streaming set and a leave behind set that are specific to that individual computing device. For example CVD server is configured to segment desktop image for computing device into prefetch set streaming set and leave behind set . Prefetch set includes the smallest subset of files in the collection of files stored as part of desktop image that is needed to boot up computing device without requiring retrieval of additional files over network s . Streaming set includes those files in the collection of files stored as part of desktop image that are to be sent after computing device has booted up from the files in prefetch set . Leave behind set includes those files in the collection of files stored as part of desktop image that are to be sent when specifically requested by computing device . Thus desktop image for computing device is segmented in a manner that is specific to computing device

CVD server is configured to segment desktop images to for computing devices to respectively in a similar manner. However it is noted that the desktop image for each individual computing device is segmented according to information received from that individual computing device thus each of the prefetch set streaming set and leave behind set for each individual computing device may include files that are different from the files included in the prefetch set streaming set and leave behind set for any other computing device. In this manner CVD server allows for streamlining the centralized management of desktop images for a large number of computing devices while at the same time enables each individual computing device to start operating as quickly as possible based on the smallest set of files that are necessary for that individual computing device to start normal operation.

In an operational example suppose that CVD server receives a request from computing device to download desktop image . In some embodiments CVD server segments desktop image into prefetch set streaming set and leave behind set in response to the request for the desktop image. In other embodiments CVD server segments desktop image not in response to a request for the image but after receiving information that indicates the usage of the files at computing device in these embodiments CVD server may segment desktop image by storing segmentation information that identifies the files and or any file system paths thereto in each of the prefetch set streaming set and leave behind set and then periodically updating the segmentation information when new file usage information is received from computing device . In response to receiving the request for desktop image CVD server sends prefetch set to computing device . When computing device receives prefetch set the computing device boots up from the files in the prefetch set. After computing device has booted up the computing device sends to CVD server a request for streaming set . In response to receiving the request CVD server commences sending streaming set to computing device

While the transfer of any of prefetch set and streaming set is in progress computing device may send to CVD server a specific request for a specific file in leave behind set . In response to such request CVD server interrupts the sending of the prefetch set or the streaming set and sends the specific file to computing device with the highest priority. This functionality of CVD server ensures that computing device can download any specific file on demand and with the highest priority as soon as an application executing on the computing device requests access to the specific file. For example requests for files in the leave behind set may be issued in a cache miss scenario when an application on the computing device requests access to a file that is not yet present at or fully downloaded to the computing device.

In the example embodiment illustrated in computing device is configured to connect to data center over network s where CVD server in data center is configured to store and manage on storage device s one or more desktop images for the computing device. Computing device comprises one or more processors and one or more volatile memory devices not shown in as well as one or more persistent storage devices such as for example disk . Computing device executes operating system OS which includes OS components executing in kernel mode that provide support and system resource management functionalities for applications that execute in user mode. For example OS may include memory management modules and other routines that are configured to allocate and maintain a kernel memory address space for executing the OS kernel components e.g. system drivers system services etc. and a user mode memory address space for executing non kernel applications and other software modules such as user applications . OS also includes routines configured to support one or more file systems such as file system that are stored on disk .

According to the techniques described herein computing device is provisioned e.g. manually or automatically with endpoint side components for desktop streaming. The endpoint side components on computing device include interceptor logic streaming agent service and pivot application . In some embodiments the endpoint side components for desktop streaming on a computing device may further include a network client logic for bare metal boot over a WAN where the network client logic is configured to initiate the streaming process at boot time in cases where the computing device does not store a runnable image that can be used to boot up the device.

As used herein logic refers to a set of instructions which when executed by one or more processors are configured to perform one or more functionalities. In various embodiments and implementations any such logic may be implemented as one or more software components that are executable by one or more processors or as any combination of one or more software and hardware components such as Application Specific Integrated Circuits ASICs . For example any particular logic may be implemented without limitation as one or more software modules as one or more libraries of functions as one or more dynamically linked libraries and or as a standalone or a client server software application.

According to the techniques for desktop streaming described herein interceptor logic is configured to intercept all file system calls and to collect metadata information about the usage of the files in file system . The collected metadata information is used to determine which files need to be streamed first from data center in order to boot up computing device as fast as possible and which files need to be streamed with priority thereafter in order to ensure smooth operation for example the metadata information collected by interceptor logic may be used by CVD server to predict in what order the files of a desktop image for computing device should be streamed and to segment the image into a prefetch set a streaming set and a leave behind set. Interceptor logic is also configured to serve files that are missing at computing device by blocking file requests from applications executing on the device fetching the files or file blocks thereof through streaming agent service and then returning to the applications proper file handles when at least some portion of the missing files are downloaded to the computing device.

In some embodiments the interceptor logic is implemented as a filter driver that is installed in the kernel of the underlying OS and is configured to execute on top of the file system to track every request for access to any file stored in the file system including the OS configuration files. For example in these embodiments the interceptor logic is configured to track access to the OS configuration database files e.g. Windows registry files at the granular level of individual database entries thus requiring the locking only of individual entries as opposed to the entire database file s . This also allows the interceptor logic to track changes e.g. updates insertions and deletions to individual configuration database entries which facilitates faster and computationally less expensive updates to a corresponding desktop image that is centrally managed at a remote location such as for example a data center. In other embodiments the interceptor logic may be implemented as a driver application or some other software component that is configured for execution in user mode to intercept and track request for access to some or all of the files stored in the underlying file system.

According to the techniques described herein streaming agent service is logic that is configured to communicate with CVD server and to coordinate the streaming of the files in the desktop image stored at data center for computing device . In some embodiments streaming agent service may comprise network optimization modules which may also be included at the server side as part of or in conjunction with CVD server that are configured to optimize the streaming transfer of data over network s by de duplicating and compressing the data.

Pivot application is logic that is configured to execute on computing device during the very early boot stages and to perform an atomic switch operation for a new partially downloaded image for the computing device followed by a re boot from the files in the new image. For example pivot application is configured to atomically perform an in place replacement of current files in file system with the files in the prefetch set of a new desktop image for computing device and then to re boot the device which effectively causes the device to boot from the new files in the prefetch set. In some embodiments pivot application is implemented as a native application that uses a native Application Programming Interface API to trap into the kernel of OS which allows the pivot application to be started very early into the boot up process and to be the only process running when it replaces the current files in file system with the files in the prefetch set of the new desktop image.

In an example embodiment of the techniques for desktop streaming described herein the flow of the streaming procedure between an endpoint computing device and a CVD server is as follows.

1. The streaming client e.g. a streaming agent service on an endpoint computing device issues a request to stream a desktop image for the device.

2. The CVD server receives the client request and authenticates the end user of the computing device based on the user credentials included in the request. Examples of such user credentials may include but are not limited to a network account logon ID a domain or directory account ID and a password or other security information. The CVD server then looks up in the CVD repository the desktop image that matches the user credentials in the client request. The CVD server then determines based on the client request if the endpoint computing device is bare metal or is running an existing image. A typical use case of the latter type is when a new hardware contains a vanilla Windows image or when an image needs to be replaced but is still able to connect to the network and initiate the streaming procedure. A typical case of the former type is when there is no working image at the endpoint device that can execute the streaming procedure in which case the endpoint device needs to boot over the network and then start the streaming procedure. Details of techniques for such bare metal boot over the network are described hereinafter in Section 3.5.

3. The CVD server segments the collection of files in the desktop image into three components the prefetch set the streaming or background fetch set and the leave behind set. The CVD server then sends to the streaming client on the endpoint device the manifest of the prefetch set e.g. a list of files that comprise the prefetch set. Details of techniques for image segmentation and ordering are described hereinafter in Section 3.2.

4. The streaming client on the endpoint device downloads the list of files included in the prefetch set by invoking a network optimization module that is included in or works in conjunction with the streaming client. The prefetch set gets downloaded and stored in a staging area on a permanent storage device e.g. a disk at the endpoint device. Details of techniques for network optimizations are described hereinafter in Section 3.6.

5. Once the download of the prefetch set is complete the streaming client on the endpoint device performs pre boot tasks related to switching the current image on the device with the files from the prefetch set and then requests the user to reboot. During the boot a pivot application performs actions to atomically switch the current image with the new image. Details of techniques for atomic switching of images are described hereinafter in Section 3.4.

6. When the endpoint device completes the boot sequence the user can start working with the newly restored image normally as if the entire image is local and has been downloaded even though only the files in the prefetch set reside physically on the device s disk. While the user is working the streaming client on the endpoint device downloads the files in the streaming set in the background.

7. During the process of streaming the files in the streaming set the user e.g. through an application executing on the endpoint device may request a file that is not in the prefetch set and has not yet been downloaded as part of the streaming set. In this case the interceptor logic on the endpoint device intercepts the file request and issues an on demand request to the CVD server to fetch the missing file. Such on demand requests are expected to incur some delay from the perspective of the user since they involve interaction over the network however in accordance with the techniques for desktop image segmentation described herein the chance of such on demand requests occurring is likely to be below 10 . Details of techniques for processing such on demand requests are described hereinafter in Section 3.3.

8. Throughout the operation of the endpoint device including when the user is offline the interceptor logic continuously collects information related to file usage at the endpoint device. The collected information is sent back to the CVD server periodically and is used by the CVD server to improve the image segmentation and download ordering as described hereinafter.

9. In some cases the CVD server may need to alter the contents of the desktop image before streaming the desktop image to the endpoint device depending on the current hardware configuration of the endpoint device and whether the current hardware configuration differs from the hardware configuration on which the desktop image was last executed. In these cases according to the techniques described herein the CVD server is configured to perform a rebase operation on the desktop image before streaming the desktop image to the endpoint device. Details of techniques for performing such rebase operation are described hereinafter in Section 3.7.

In an example embodiment the flow of the streaming procedure includes a prefetch phase illustrated in a pivot phase illustrated in and streaming phase illustrated in . As illustrated in the prefetch phase the pivot phase and the streaming phase are described with respect to computing device in the operational context illustrated in . In that operational context computing device is configured to connect to data center over network s where CVD server in data center is configured to store and manage on storage device s one or more desktop images for the computing device. Computing device comprises one or more processors one or more volatile memory devices and one or more persistent storage devices such as for example disk . Computing device executes interceptor logic in the kernel address space of OS while streaming agent service and pivot application are executed in user mode on top of OS .

After receiving the list of files in prefetch set and while the user may be working on the current image on computing device streaming agent service commences downloading of the files in the prefetch set and storing these files in staging area B. Staging area B may be configured as a designated directory or a separate possibly hidden partition within file system on disk .

Once the download of prefetch set is completed streaming agent service performs pre boot tasks related to switching the current image which is stored in work area A with the files from the prefetch set. Examples of such pre boot tasks may include without limitation verifying the file system paths for the files in prefetch set against the work area A adjusting as necessary file and directory metadata for the files in prefetch set and or for the files in the current image in work area A and storing an indication e.g. a flag or other entry in an OS configuration file in order to cause pivot application to be executed upon the next reboot of computing device . Streaming agent service then prompts or otherwise requests the user to reboot.

During the process of streaming the files in streaming set a user application may request to access a specific file that was not downloaded as part of prefetch set and has not yet been downloaded as part of streaming set . Interceptor logic intercepts the request for the file determines that the file has not yet been downloaded and blocks the request. Interceptor logic then issues a request to streaming agent service to fetch this missing file. Streaming agent service issues an on demand request for the missing file to CVD server and in response thereto CVD server interrupts the transfer of the files in streaming set and transmits the missing file with the highest priority. Streaming agent service receives the file or at least a portion thereof stores the file or the portion thereof at the appropriate file system path in work area A and notifies interceptor logic accordingly. When interceptor logic determines that the specific file or a sufficiently usable portion thereof has already been downloaded and stored locally the interceptor logic unblocks the request from user application and returns a valid file handle to the requested file.

Throughout the operation of computing device including during the boot phases and when the user is offline interceptor logic continuously collects information related to the usage of and access to files and blocks in file system . The collected information is sent by streaming agent service to CVD server periodically and the CVD server uses the collected information to improve the image segmentation and download ordering for the files in desktop image for computing device

In the above manner the techniques for desktop streaming described herein ensure that computing device is able to boot up from the files in the new desktop image as quickly as possible based on the smallest set of files e.g. the files in prefetch set that are necessary for starting the normal and usual device operation without sacrificing the experience of the end user. The techniques described herein also provide a mechanism for downloading files on demand with the highest priority which ensures that a user application is able to access a missing not yet downloaded file from the new desktop image without any significant delay.

In an example embodiment a desktop image for an endpoint computing device is segmented into the following components 

The prefetch set includes the smallest subset of files in the collection of files included in the desktop image that are needed to reside at the endpoint device in order to be able to 

The streaming set includes the subset of files in the collection of files included in the desktop image that are destined to be downloaded to the endpoint device in the background while the user is already working. This is typically a large set so the techniques described herein provide a mechanism to determine an effective download ordering of the streaming set that predicts the expected usage of the user.

The leave behind set includes those files in the collection of files included in the desktop image that are unlikely to be accessed by the end user which is determined based on previously recorded access patterns. Therefore the files in the leave behind set are kept in the data center and are not downloaded to the endpoint device ahead of time. These files will be downloaded to the endpoint device only if accessed by the user or by an application running on the endpoint device and are downloaded using an on demand mechanism. Determining the files in the leave behind set is performed as part of the streaming set ordering and ranking procedure.

The unmanaged set includes files that are technically not part of the desktop image and contains all the files that reside on the physical endpoint device that are not centrally managed at the data center and hence not protected upon restore from the data center either . In some embodiments the files in the unmanaged set are determined by a policy which may be configured by an administrator to exclude files that are of no interest from a protection perspective. Examples of such files include temporary files and other types of files that are transient in nature. Since the files in the unmanaged set are not part of the centrally managed and protected desktop image handling of these files is not specifically discussed in the present application.

One way to represent the segmentation of a desktop image is as an ordered list of files whose order or rank is based on the importance or expected access to these files. is a block diagram that illustrates the rank assigned to files in a desktop image as part of segmenting the desktop image. Specifically with respect to the operational context described in illustrates how desktop image is segmented into prefetch set streaming set and leave behind set . The rank assigned to each file in desktop image as part of the segmentation process determines order of the sequence in which the files in the desktop image are transferred to endpoint device . On demand requests for files at the endpoint device can impact the streaming order . For example an on demand request for a specific file may cause that file and or other file system objects related thereto to be moved from leave behind set to streaming set . In another example an on demand request for a specific file may cause that file and or other file system objects related thereto to be moved ahead in the streaming order within streaming set .

One approach for segmenting a desktop image may involve varying the boundaries between the three sets prefetch set streaming set and leave behind set based on network conditions. However this approach has a major flaw. Considering a low bandwidth high latency network downloading a large prefetch set to an endpoint device would result in a long period of time before the user of the endpoint device can start working which may be unnecessary if the prefetch set contains files that are unlikely to be accessed by the user. Downloading a too small prefetch set would result in a quick turnaround before the user can start working but will likely incur long delays due to increased chance of requests for missing files e.g. files that have not yet been downloaded which would lead to a bad user experience if a large number of missing files need to be fetched over the network on demand.

To address these and other issues with image segmentation the techniques described herein provide a mechanism for segmenting a desktop image into a prefetch set a streaming set and a leave behind set that is invariant of the network conditions and is configured to operate based on anticipated usage patterns that are determined from file usage information collected at the endpoint device. Specifically according to the techniques described herein the prefetch set should include all the files that the user is likely to access during and soon after boot up the leave behind set should include those files that are highly unlikely to be accessed and the streaming set should be ordered based on the likelihood of the files within the set to be accessed by the user.

According to the techniques described herein another consideration that may be taken into account when segmenting a desktop image is the size of the disk at the endpoint device. For example in some operational scenarios the endpoint device may need to download a desktop image that was previously used by a computing device with a larger disk space. In these scenarios the sum of the size of the files in the prefetch set and streaming set should not exceed the size of the physical disk space of the endpoint device because otherwise the endpoint device might never end the phase of transferring the streaming set as it will perpetually evict files from the local disk and then bring them back as part of the streaming set. To address this in some embodiments the CVD server that performs the image segmentation may be configured to decrease the size of the streaming set and increase the size of the leave behind set in order to ensure that the endpoint device can store the files in the streaming set on its local disk and can resume operation after the streaming set has been downloaded and stored on the local disk.

To implement image segmentation some embodiments provide logic which may be included in a CVD server and which when executed is operable to segment a desktop image into a prefetch set a streaming set and a leave behind set in accordance with the techniques described herein. For example in response to a request for a desktop image the segmentation logic may traverse the files stored in the desktop image and may assign a rank indicator to each file. The segmentation logic determines the rank indicator for each file based on information indicating the most recent usage of that file at the endpoint device associated with the desktop image. The rank indicator for any particular file includes one or more data values that identify one of the prefetch set the streaming set and the leave behind set. For files in the streaming set in some embodiments the rank indicator assigned to a particular file may also indicate the order of that particular file within the streaming set in other embodiments additional order value s may be stored along with the rank indicator to specify the order of that particular file within the streaming set. After determining the rank indicator for a particular file the segmentation logic stores a record or entry that associates the determined rank indicator with a file identifier ID of the particular file in one or more data structures in volatile memory and or on persistent storage. The file ID stored in the record or entry may include a filename and or other identifier such as a file number and or a file system path identifying the directory where the particular file is stored in the file system of the endpoint device. The data structures which store the records or entries with the file ID rank indicator associations for the files in the desktop image may include without limitation lists arrays tables queues and any other data structures that are suitable for storing records or entries in volatile memory and or on permanent storage.

According to the techniques described herein the prefetch set includes at the very least the set of files that are used by an endpoint computing device to reboot possibly without network access or access to the CVD server. In an example embodiment the prefetch set may include two sub sets a static set and a dynamic set.

The static set is not necessarily individualized and includes known files from the OS and core applications that have been analyzed as crucial for enabling the endpoint device to boot. The static set also includes the files that comprise the streaming client software e.g. the files for the streaming agent service that is executed on the endpoint device. The static set typically does not include significant portions from a bare OS installation. Examples of elements that are excluded from the static set include but are not limited to un installation files and data DLL cache user profile files and driver store files. Additionally many OS files are classified as temporary files which should not be downloaded to the endpoint device thereby significantly reducing the size of the prefetch set. In some embodiments the static set may also include files that comprise one or more of the endpoint side components e.g. interceptor logic streaming agent service logic and pivot application or any new versions thereof.

The dynamic set includes a set of files that are maintained on a per device basis and that augment the static set in order to ensure that the endpoint device can operate normally and provide good user experience. The logic used to determine the dynamic set is rooted in the ability of an endpoint device to intercept and record access to files along with a timestamp of the access event. Also the endpoint device can record system events such as a user log on and log off the device is being booted or shutdown etc. Using this collected information the logic applies a set of heuristics to generate a list of the files in the dynamic set. Once collected the list or manifest of files of the dynamic set is uploaded to the CVD server on the next steady state upload. This manifest enables the CVD server to learn and remember what applications and files will be used by the endpoint device when it boots up after an image restore operation. In this learning process the CVD server may perform two steps augment the previous dynamic set with new files that have been recently accessed and or reduce the dynamic set by removing files that have been previously accessed but are not accessed in more recent sessions. Examples of the heuristics that are used to determine the dynamic set include 

Operating systems typically have built in mechanisms for monitoring the most frequently used applications per user . For example in Windows XP such information is collected by Windows Explorer and is internally stored in a data structure referred to as UserAssist. The UserAssist information is displayed on the user s Start menu and is based on application launch count statistics. Thus in some embodiments this built in OS mechanism is leveraged as an additional heuristic for determining the set of files to include as part of the dynamic set. Some additional Windows OS mechanisms which are useful for this purpose are the Prefetch and SuperFetch mechanisms. The Prefetch mechanism records the order of page faults during boot and during process launches and uses these recordings to pre fetch the data when the applications are launched later. The SuperFetch mechanism monitors which applications are used most and preloads these applications into dynamic memory so they re ready when needed by the user.

In case the endpoint device fails to boot successfully from the prefetch set e.g. because there were insufficient files in the set the endpoint device can recover itself by issuing a request to the CVD server for a safe mode restore which involves the downloading of a safe set of files. The safe set is an extension of the static and dynamic sets and ensures successful boot because it includes all the files from the entire OS image but still excludes personal files and user specific applications . The existence of such safe static set with the entire OS image enables the use of a more aggressive e.g. smaller static set and hence a faster restore process since in case the boot from the static set fails the endpoint device would be able to enter safe mode and still boot properly although slower . It is noted that for normal operation after the first phase of the restore operation of a new image onto the endpoint device some services such as networking should work properly on the endpoint device. If this is not the case the last resort for the endpoint device is to boot over the WAN as described hereinafter in Section 3.5.

Since the amount of data stored in a desktop image at the data center may exceed the physical disk at the corresponding endpoint device there could be a situation in which the sum of the sizes of the files in the prefetch set and the streaming set exceeds the physical disk size. To address cases where the disk at the endpoint device is low on available space the techniques described herein provide eviction logic that may execute as a separate application or as part of the steaming agent service on the endpoint device. When executed the eviction logic removes files from the disk on the endpoint device based on criteria that are opposite to the criteria for determining the prefetch set. For example files that are candidates for eviction are least recently used least frequently used and non sticky. The eviction logic performs the eviction procedure until enough disk space is freed. It is noted however that while the files are removed from the disk on the endpoint device these files still exist in the desktop image stored in the data center and can be accessed and restored to the endpoint device on demand. In effect the removal of these files from the disk on the endpoint device has the semantics of adding these files to the leave behind set of the desktop image at the data center.

One goal of effective desktop streaming is to ensure that the user experience post streaming would be acceptable. In particular there is a need to reduce the chances of a cache miss e.g. of a request for a file that has not yet been downloaded at the endpoint device which would cause fetching the file in real time over the network thus causing delays. To minimize the chances of a cache miss according to the techniques described herein the streaming set is ordered based on the file access patterns as detected by the interceptor logic on the endpoint device. This ordering procedure operates similarly to the procedure for generating the dynamic set except that it keeps a rank of the more recently accessed files across multiple user sessions on the endpoint device. Specifically one or more components on the endpoint device e.g. the interceptor logic and or the streaming agent service keep track of which files were used and their frequency of use and create a ranked list of files based on the access patterns. The ranked list is sent to the CVD server and is kept in the data center as metadata information associated with the desktop image for the endpoint device. Upon a request to restore the desktop image onto the endpoint device the streaming set is constructed by the CVD server in such way that more frequently and recently used files are placed higher in the ordered list. The ranked list of files may include program files as well as user data files. By applying this ordering procedure applications and files that are frequently used by the user of the endpoint device are likely to be resident at the device when the user actually needs them thereby avoiding a cache miss scenario.

Files at the bottom of the ranked list of files e.g. files that have not been accessed the longest time are placed on a list that identifies the leave behind set and are never streamed. For example a default threshold value for moving files from the streaming set to the leave behind set may be 6 months. That is files that have not been accessed by the user on the endpoint device for more than 6 months are not going to be part of the streaming set. It is noted that if access to such files is requested these files will be served on demand just like any other streamed file. However if such files are not accessed ever on the endpoint device there is no point in sending them unnecessarily over the network.

Another mechanism to affect the transfer priority of the files in the streaming set is based on on demand access. That is when files are accessed on demand because they have not yet been streamed to the endpoint device then the endpoint device should look at files that are related to these files and place them at the top of the ranked list of files that is sent to the CVD server. For example an on demand request for an executable Winword.exe would increase the priority of the entire c Program Files Microsoft Office directory or of all files with a .docx extension.

When the endpoint device is operating offline e.g. is disconnected from the data center and a user application attempts to access a file that has not yet been downloaded the interceptor logic records this request. When the endpoint device reconnects to the data center the interceptor logic sends to the CVD server the list of missing files for which there were access requests and the CVD server re prioritizes these files by placing them at the top of the streaming set.

Some software programs operate by scanning the entire file system on an endpoint computing device. For example desktop search programs scan the file system in order to generate indexes for future searches and anti virus software scans the file system to identify threats to the endpoint device. Clearly such scanning programs would invalidate the ranking of file access by the user since they access every file in the file system. In order to eliminate their impact on the ranking order according to the techniques described herein the interceptor logic maintains a list of such scanning programs and is configured to ignore file access from such scanning programs when performing the file ordering and ranking procedures to generate ranking lists of files. Additionally in some embodiments the interceptor logic could employ a heuristic such that when a specific process is performing consecutive access open read close to a large number of files the specific process would be automatically entered in to the scanners black list and excluded from the ranking this is similar to Web crawlers being excluded from the access based ranking algorithms .

According to the techniques for desktop streaming described herein an endpoint computing device is provisioned with interceptor logic. In some embodiments the interceptor logic is implemented as a file system mini filter driver that is configured to intercept file system events and requests for multiple purposes. As described hereinafter examples of such purposes include without limitation tracking file and directory modifications determining the dynamic set in the prefetch set virtualizing the file system block level on demand streaming and offline support.

To provide ongoing data protection in various operational contexts the implementations of desktop streaming need to be able to detect file and directory modifications. To address this the techniques for desktop streaming described herein provide for tracking such modifications by using a lightweight tracking layer which is implemented in the interceptor logic. Using a kernel mode interceptor logic for tracking file and directory changes allows embodiments of the techniques described herein to swiftly detect all modified files directories and to provide fast ongoing data protection without the need to repeatedly perform a full scan of the entire file system for syncing the protected data with the data in the corresponding desktop image stored at the data center.

In some embodiments the lightweight tracking layer implemented in the interceptor logic may include one or more optimization mechanisms that minimize the tracking overhead thereby making this layer almost transparent. Examples of such optimization mechanisms include but are not limited to 

In order to provide a good streaming experience the techniques described herein segment a desktop image into a prefetch set a streaming set and a leave behind set. As discussed above one of the components in the prefetch set is the dynamic set. In some embodiments the interceptor logic is configured to track the files included in the dynamic set by intercepting file access requests and keeping track of the identifiers of the accessed files using mechanisms similar to the tracking file modifications mechanisms described above.

In order to accurately record the dynamic set in some embodiments the interceptor logic is configured to start very early in the boot process of the endpoint device before any or very few files are accessed in the file system. It was observed that each boot on the endpoint device is not identical to but is different at least slightly from every other boot for the same user on the same endpoint device. Further it is noted that desktop streaming does not need to be performed each and every time an endpoint device reboots rather around 90 of the boots do not require streaming. However on the occasions when desktop streaming is needed or expressly requested by the user having a very accurate prefetch set dynamic set can increase the chances of a successful boot to almost 100 . In order to achieve such success ratio in some embodiments the interceptor logic is configured to load and execute on each boot before all or substantially all file access requests are made to the file system. Thus the interceptor logic records all or substantially all files that are accessed during each boot and uses the recorded information to make an accurate prediction of which files are likely to be accessed on the next boot. The interceptor logic includes these predicted files in the list for the prefetch set dynamic set that is reported to the CVD server. This prediction of which files should be in the prefetch set dynamic set continuously improves over time because the interceptor logic records all or substantially all accesses to files in the file system during each and every boot.

In addition to downloading fast the prefetch set and downloading in the background the streaming set onto the image that is currently running on an endpoint device the endpoint device is also configured to handle requests for files and other file system objects that are not yet resident on the local disk of the device. While the prefetch set and the ordering procedure for the streaming set lead to an over 90 hit ratio there is still a chance that a user application will request access to a file that has not yet been downloaded. To address such requests the interceptor logic includes a module that is configured to present a full file system to user applications and other clients on the endpoint device but at the same time supports holes in the file system that consist of stubs representing files that have not been downloaded yet. When a user application requests access to such missing files e.g. files identified by stubs the interceptor logic blocks the application request and fetches the missing file over the network. When the file has been fetched on demand and stored locally the interceptor logic unblocks the application request and replies to the requesting application with a file handle. To further minimize the delay in processing such requests for missing files are handled with the highest priority and with precedence over any background streaming activity.

In this manner the interceptor logic is actually responsible for virtualizing the underlying file system for both user mode applications kernel mode drivers and the operating system itself.

While the streaming agent service on the endpoint device is in streaming mode e.g. downloading the streaming set of the desktop image all operating system components observe a completely normal file system and continue to operate normally while the underlying file system may actually be missing data blocks from multiple files. According to the techniques described herein all input output I O requests for missing files are intercepted and blocked until the requested data is fetched from the CVD server. The interceptor logic is configured to process such interception of I O requests completely transparently to the I O requestors which may include user mode applications kernel mode drivers and other OS components.

In some embodiments the interceptor logic may also be configured to throttle the streaming agent service while the streaming set is being downloaded from the CVD server. For example the interceptor logic may be configured to detect and determine the level of activity performed by the user on the endpoint device for example by tracking keyboard activity mouse activity etc. If the interceptor logic determines that the user is active working in order not to slow down the user activity the interceptor logic throttles the background streaming by notifying the streaming agent service accordingly.

In some embodiments while the endpoint device is operating offline e.g. is disconnected from the data center the interceptor logic is configured to cause all requests to missing files to fail as these requests cannot be served offline. In these cases the interceptor logic returns to the file requestors a failure code with a standard code value which indicates that the requested files are offline and which should be properly handled by the requestor applications.

One approach to streaming file data involves fetching the entire file from the CVD server in response to a request from a user application on the endpoint computing device. According to this approach all file open requests are blocked until the file is completely fetched from the CVD server the pending requests are released only after all blocks of the file have been downloaded to the local disk on the endpoint device. This streaming approach however may be inefficient for large files which are only partially read by the requesting application or client on the endpoint device.

To address this issue and in order to further reduce the time period in which a user is waiting for an on demand request for a missing file to complete according to the techniques described herein the interceptor logic is configured to reply to the requestor application after downloading a small subset of the file contents e.g. a subset of all the blocks in the file . This technique is somewhat analogous to desktop streaming except that it is applied to the blocks in a single file. In effect this technique is a block level on demand streaming technique and it provides a useful capability when the accessed file is large and the access pattern to file is random access as opposed to sequential whole file access in which an application first reads the entire file before starting to process it. Example of the former type of file is a file that stores e mail messages e.g. such as .pst files and other Microsoft Outlook files examples of the latter type of files are other Microsoft Office application files e.g. such as Microsoft Word files with .doc extensions . Accordingly in some embodiments the block level on demand streaming may be configured on the endpoint device only for certain types of file and not configured for other types of files that are stored on the device.

To perform block level streaming for files that are opened for read write access according to the techniques described herein the interceptor logic allows applications to open the file regardless of the fact that file data may be missing. The interceptor logic then intercepts block level read requests and blocks them until the desired block is fetched from the CVD server. The interceptor logic keeps a table of missing blocks per file and stops intercepting block level access requests to files which have been completely fetched from the CVD server.

When applications are reading a file the applications usually have some common block access patterns. For example an application may serially read multiple consequent blocks or read several groups of blocks from several distinct parts of a file. However the overhead of fetching these common blocks one by one is high as it is not efficient to perform multiple round trips from the interceptor logic to the streaming agent service within the endpoint device and eventually through the network to the CVD server for each accessed block. Thus in order to reduce this overhead in some embodiments the interceptor logic is configured to track file block access patterns so that it can predict which blocks will probably be required per file. According to this tracking mechanism the interceptor logic collects block access statistics per file and then uses these statistics to predict which blocks will be required on the next block access based on one or more heuristics.

For example some embodiments may use a heuristic that is to track the most frequently accessed blocks per file and or per application. is a block diagram that illustrates an example block level on demand streaming according to one such embodiment. In block level on demand streaming using a frequently accessed heuristic is described with respect to computing device in the operational context illustrated in . In that operational context computing device is configured to connect to data center over network s where CVD server in data center is configured to store and manage on storage device s one or more desktop images for the computing device. Computing device comprises one or more processors one or more volatile memory devices and one or more persistent storage devices such as for example disk . Computing device executes interceptor logic in the kernel mode of OS while streaming agent service is executed in user mode on top of OS .

Referring to in operation a user application opens file for read and or write access where file is stored in work area A of file system but one or more blocks of the file have not yet been downloaded from CVD server . After file is opened interceptor logic intercepts a block level request from a user application to access block in file . Interceptor logic blocks the intercepted request and then accesses the block access statistics that have been previously collected for file . Based on the collected statistics interceptor logic determines that one or more blocks of file are not yet downloaded from CVD server but are frequently accessed and thus are likely to be requested by user application immediately or very soon after the request for block . In response to this prediction interceptor logic blocks the request from user application and notifies streaming agent service to fetch the predicted blocks along with block . Streaming agent service then fetches from CVD server both block and the predicted blocks . After block and predicted blocks are fetched and stored in file interceptor logic unblocks the request from user application and the user application proceeds to access the requested block .

In this manner the technique for block level on demand streaming provides a significant boost in block level streaming performance because the overhead caused by repeated application requests for file blocks of the same file is greatly reduced or outright eliminated.

One technology challenge with implementing desktop streaming while the files are accessed by applications is to overcome file system concurrency control semantics. For example if process P opens file F with a sharing mode that precludes access by other processes then the streaming process SP would also be blocked by the file system thereby creating a deadlock since P is waiting for SP to stream missing data but SP is blocked by P due to a sharing mode violation. Similarly if P is granted a byte range lock on a file segment from a file block that is missing then SP will not be able to write into the missing areas that are locked by P.

To address this problem according to the techniques described herein the interceptor logic changes the original open share mode issued by process P to full maximum sharing e.g. to a share mode that allows other processes to open the file for read and write operations which enables the streaming process SP to open the file and write into the missing areas in the file. However when another process P attempts to access the file the interceptor logic enforces the file system sharing semantics by checking for compatibility between P s requested sharing mode and the original sharing mode requested by P. If incompatible Ps request is denied by the interceptor logic before reaching the file system. Otherwise the request is granted and P s sharing mode is again converted to the full sharing mode on the actual file system. Thus in effect the interceptor logic implements and enforces the file sharing semantics as a layer over the file system and makes the file system fully shareable.

With regards to byte range locks the techniques described herein provide two mechanisms for handling requests for such byte range locks. In cases where byte range lock requests are infrequent the interceptor logic precedes the file system lock request by injecting an artificial read request for the requested byte range this ensures that the file block including the byte range data is streamed into and stored on the endpoint device before the byte range lock is requested at the file system level thereby and preventing locking conflicts. This solution avoids the need to add a layer of concurrency control logic in the interceptor logic for locks in addition to the logic for open sharing modes.

It is noted that the above mechanism might affect the user experience in cases where the lock requests are frequent and or span large byte ranges. In the worst case scenario if the open request is followed by a lock request for the entire file the requesting process would have to wait until the whole file is streamed before making progress thus slowing down the response time to the user. Thus in cases where lock requests are frequent and involve large ranges a mechanism is provided in the interceptor logic that implements locking semantics on top of the file system in a similar manner as the handling of file open sharing mode. That is a lock request by a process P is maintained at the layer of the interceptor logic and is not propagated down to the file system so that the streaming process SP is unaffected by the locking but any other process P that attempts to access the byte range is blocked by the interceptor logic without being propagated to the file system.

The techniques for desktop streaming described herein allow an endpoint computing device to operate also when the user works offline which is a common use case for laptop users. When the endpoint device is offline e.g. is disconnected from the data center there is no way to fetch a missing file on demand. In this case the interceptor logic is configured to turn on the offline bit attribute of missing files. The offline bit of a file indicates to the applications and clients on the endpoint device that the file is offline and properly behaved applications should know how to handle it. In addition in some embodiments that are implemented on a Windows OS the Windows Explorer application indicates files with offline bit with a special marker which informs the users that the file is offline. If an application insists on trying to open an offline file the OS on the endpoint device returns a message to the application that indicates that the file is not locally available e.g. in a Windows OS such message would be a STATUS FILE IS OFFLINE message . Most user applications are configured to handle this error code and will display an appropriate message indicating that the remote storage service was not able to recall the file .

According to the techniques for desktop streaming described herein an endpoint computing device that needs to download a new desktop image can be in one of two states. In the first state the endpoint device is capable of downloading the new desktop image. Typical cases for this first state arise when a new hardware contains a vanilla OS image or an image that needs to be replaced but is still able to connect to the network and download the prefetch set. In the first case once the endpoint device has downloaded the prefetch set onto the staging area the pivot application is executed to atomically replace the previous image with the new image and let the device boot from the new image. In the second state there is no image at the endpoint device that can execute the download of the prefetch set in which case the device needs to boot over the network download and execute a mini client that is configured to fetch the files in the prefetch set from the CVD server and then apply the image with the downloaded prefetch set.

One of the challenges of desktop streaming is to be able to replace all OS components in a manner which is as OS transparent as possible. One of the implications of this transparency is that OS components need to be replaced in a consistent transactional manner. Thus the OS should not be in an intermediate state in which only part of the files have been replaced as this may cause inter file inconsistencies and OS failures.

To address these issues the techniques for desktop streaming described herein may replace in an atomic manner various types of files including but not limited to application files kernel components e.g. drivers OS configuration files e.g. Windows OS registry files and all metadata related to or associated with the replaced files such as for example Access Control Lists ACLs attributes timestamps and short filenames.

In some embodiments the techniques described herein are implemented for endpoint devices that execute a Windows OS. A Windows OS however does not provide a built in mechanism to perform an atomic switch of a current image that is executing on an endpoint device with a new desktop image. Thus in these embodiments an endpoint device is provisioned with a native user mode application that is referred to herein as a pivot application . The pivot application may be implemented as a native application that uses a native API to trap into the kernel of the OS which allows the pivot application to be started very early into the boot up process and to be the only application running when it copies and moves files in the file system. This ensures that other processes will not be accessing or locking the files in the file system while the pivot application is running. The pivot application is configured to execute on the endpoint device during the very early boot stages and to perform an atomic switch operation that replaces a current image with a new partially downloaded image for the endpoint device followed by a reboot from the files in the new image. When downloaded to the endpoint device the new desktop image represents a complete view of the file system but includes only the files in the prefetch set files other than the files in the prefetch set e.g. such as the files in the streaming set or the leave behind set are represented in the new desktop image as file metadata e.g. such as file identifiers or file stubs but the actual data of these files is not included in the new desktop image that is initially downloaded to the endpoint device.

For example in these embodiments the pivot application is launched during the early phases of the Windows OS boot while there are no other applications and or services running. The pivot application moves all the associated files from a staging area which was prepared in the pre boot download phase to store the files in the prefetch set of the new desktop image into the target file system paths and fixes all the metadata associated with new files. If sudden power failures occur on the endpoint device while the pivot application is in the process of switching the current image with the files from the prefetch set the pivot application is configured to retry performing the atomic file replacement until successful completion. Once the atomic switch is completed and all necessary file metadata modifications have been successfully performed the pivot application terminates the current boot and invokes a second boot up of the endpoint device. In the new boot up the Windows OS starts up from the files of the prefetch set which represents a completely consistent view of the newly restored desktop image.

In some embodiments the pivot application is implemented as an application that is invoked early in the boot sequence by a boot component e.g. in the case of a Windows OS it would be the session manager of the OS. No OS files or configuration database entries are moved before the endpoint device is booted up the first time which means that upon the first boot a fully old OS image is initially loaded. Running at a very early boot stage the pivot application has the advantage that the whole hard disk is available and no files are locked at this point and no handles to files exist. This allows the pivot application to replace the configuration database entries and all the files included in the prefetch set by using regular file move operations. Once all necessary files are moved into the target file system paths the pivot application causes the endpoint device to perform a second boot before the OS configuration database is loaded and anything else happens. Upon the second boot a fully new OS image is loaded as the second boot is effectively performed from the files included in the downloaded prefetch set.

According to the techniques described herein the boot process on an endpoint computing device is modified to implement the atomic switch of a current or old image with a new desktop image. For the purpose of updating files following a streaming operation that downloads the prefetch set of the new desktop image to the endpoint device the pivot application performs an atomic file switch during which the following flow occurs 

There are certain use cases in which image switching on an endpoint device is not possible and a complete boot over the network e.g. a WAN needs to take place. Examples of such use cases include 

Starting from the endpoint device s BIOS the procedure of booting the device over a network such as a WAN may be as follows 

According to the techniques described herein in some embodiments network optimizations may be used in the desktop streaming process. Before starting the prefetch phase a streaming client on an endpoint device invokes a scan operation to traverse the local file system and to generate and store a de duplication index of file and file chunk signatures at least for the files that are expected to be included in the prefetch set and the streaming set. For example the de duplication index may include file level signatures that identify entire files and chunk level signatures that identify unique chunks or portions from the files. The de duplication index is used during the process of downloading a desktop image to de duplicate any files or file chunks from the desktop image that already exist at the endpoint device. For example when downloading files from the desktop image the de duplication index may be used to determine and transfer only the file level signatures of those files that are already stored on the endpoint device but not any data from those files and to transfer only the chunk level signatures of those chunks that are already stored on the endpoint device but not any data from those chunks. The de duplication index may be used throughout the streaming procedure including the prefetch and streaming phases.

Examples of some network optimization mechanisms that may be used in conjunction with the techniques for desktop streaming described herein are described in U.S. patent application Ser. No. 12 578 485 filed by Israel Ben Shaul et al. on Oct. 13 2009 and titled STORAGE NETWORK DE DUPLICATION the entire content of which is hereby incorporated by reference as if fully set forth herein.

In some embodiments in addition to on demand support for fetching a missing file during streaming the interceptor logic in an endpoint device is configured not wait for a client application on the device to request missing file blocks. Instead the interceptor logic proactively requests or causes the request of missing blocks from the file in anticipation of future requests by the client application. Further for certain files the interceptor logic is configured to prefetch or cause the prefetching of files that are related to a currently requested file. For example when requesting an application executable file regardless of whether the executable file is already at the endpoint device or is still missing the interceptor logic identifies the set of dynamic link library DLL files that are associated with that application and re prioritizes these DLL files at the top of the list of files in the streaming set.

Using the techniques for desktop streaming described herein it is possible to create and maintain a desktop image containing a huge store of device drivers for the corresponding endpoint device without having to download to the device the entire store upon an operation to restore the desktop image onto the device.

In some embodiments this functionality can be implemented by using the leave behind set as follows. The desktop image in the data center includes all device drivers for the endpoint device but only the device drivers metadata files e.g. such as .inf files are pre fetched to the device. The rest of the device driver files e.g. such as .sys files are assigned to the leave behind set and are thus only downloaded to the endpoint device if they are explicitly requested by the OS executing on the device. Using this mechanism an OS e.g. such as Windows should be able to find the best matching plug and play device drivers by scanning the configuration .inf files. When the OS decides that it would like to install a specific device driver it will attempt to access that driver s .sys file s thereby causing an on demand download for the .sys file s . Thus this mechanism allows the creation of a universal driver store without the overhead of downloading all device drivers in the store upon each operation to restore an image onto the endpoint device. If the OS does not require a specific driver to operate this driver would never be downloaded to the endpoint device which saves network bandwidth while at the same time keeping the flexibility of having a universal driver store.

In some embodiments some device drivers e.g. such as device drivers that are used for booting and network access are included the prefetch set otherwise the endpoint device may not be able to boot or will be able to boot but will not be able to fetch the files included in the streaming set for the device.

As discussed above one of the benefits of the techniques for desktop streaming described herein is that they allow support for a bare metal image and heterogeneous hardware types of endpoint computing devices. This functionality implies that the desktop image for a given endpoint device may need to be adapted to a new endpoint device if the previous device to which the desktop image was bound has a different hardware than the new device. To address this challenge the techniques described herein provide two complementary mechanisms that can be employed by an endpoint device as explained hereinafter. Regardless of the mechanism used to resolve hardware differences the endpoint device leverages its knowledge of the target new hardware configuration which is sent to the CVD server as part of the communication protocol between the endpoint device and the CVD server and is recorded by the CVD server in the CVD repository in association with the corresponding desktop image. Based on this hardware configuration information the CVD server can decide what mechanism to use to resolve the hardware differences when restoring the desktop image onto a new endpoint device with different hardware.

In some embodiments the CVD server determines the hardware type of the target new endpoint device from the request for the desktop image received from the device. The CVD server then compares the received hardware type to the previous hardware type on which the desktop image was last executed where the previous hardware type is stored in the data center as hardware configuration information associated with the desktop image. The CVD server then decides whether the stored desktop image is compatible with the new endpoint device or not. If the desktop image is not compatible with the hardware of the new endpoint device the CVD server performs a rebase operation which effectively switches the base image portion of the desktop image to match the hardware needs of the new endpoint device. User data user installed applications and other user environment and configurations are kept intact in the stored desktop image.

One of the mechanisms for resolving hardware differences when restoring a desktop image onto new hardware involves generation and storing of a multi client image. This mechanism is applicable if both the previous and new endpoint devices that are bound to a given desktop image can be served from the same base image portion of the given desktop image. This mechanism may be implemented by building the base image to support multiple client types. In order to build such a multi client image the device drivers necessary to support the multiple client types and their corresponding OS configuration entries are added to the base image portion of the desktop image. Examples of such device drivers include without limitation both critical device drivers e.g. such as disk controllers and plug and play PnP drivers e.g. such as network and display drivers . Once such a multi client image is built the desktop image can be safely restored in accordance with the techniques described herein onto all devices that have a hardware type that is supported by the multi client image.

Some operational scenarios for restoring a desktop image onto an endpoint device involve hardware replacement. For example a user may lose her laptop or may receive a laptop of an upgraded model. In these cases it is desirable to allow the user to continue to work on the new laptop as quickly as possible while keeping the user s existing desktop image with all of the user specific applications configurations settings and other user specific data.

However a straightforward restore operation of the user s desktop image onto a new laptop which could be of a completely different hardware model may result in blue screens on boot or in malfunctioning devices and services if the new laptop does boot from the desktop image. For example in embodiments that are implemented for endpoint devices that run a Windows OS this scenario may happen because under the Windows OS moving a hard drive from one machine to another may lead to blue screens or other device malfunctions as the Windows OS may be missing device drivers and registry entries which are required by the new hardware. One possible solution to this problem is to ensure that the desktop image contains the device drivers for both the previous and the new hardware models. However creating such a multi device golden image is a very difficult task and may not even be possible in some scenarios.

To address these challenges the techniques described herein provide rebase logic for merging user data and applications which are stored in an existing desktop image in a data center with the device drivers and hardware related applications corresponding to the hardware of the new endpoint device onto which the desktop image needs to be restored. This allows the user to take full advantage of the hardware of the new endpoint device while at the same time continuing to use the existing user specific environment.

According to the techniques described herein to provide better flexibility in some embodiments a CVD server is configured with logic for implementing a rebase operation. As used herein rebase operation refers to a restore operation of a desktop image onto an endpoint device which also includes a change of the base image portion of desktop image. The base image portion of the desktop image includes all device drivers applications configurations and other types of files that need to match the hardware of a target device in order to ensure the proper operation of the device. For example suppose that a laptop computer is executing from a desktop image with a base image portion which corresponds to this specific laptop computer and which includes the matching hardware specific drivers applications and configurations. When this desktop image is restored onto a new laptop computer having a different hardware according to the techniques described herein the base image portion of the desktop image is automatically replaced with a new base image portion which includes hardware specific drivers applications and configurations that corresponds to and matches the new laptop s hardware.

The combined operation of restore and base image replace on a desktop image needs to be performed atomically as the desktop image cannot be restored into the new hardware before the base image portion is updated or otherwise the device having the new hardware may not boot . Therefore according to the techniques described herein the rebase logic performs the restore and base image update operations together requiring a single boot of the target endpoint device to switch it to the desktop image with the new base image portion.

In some embodiments the rebase operation is implemented by rebase logic in the CVD server that is configured to perform a desktop image restore combined with the capability to update the base image portion of the desktop image. To perform a rebase operation the rebase logic performs a calculation that receives as input several parameters such as for example the machine identifier of the new target device the machine identifier currently associated with the stored desktop image and the previous base image portion of the stored desktop image. This calculation takes into consideration the previous and the new endpoint devices file systems and configuration files e.g. such as registry hives .

To generate the new updated base image portion of the stored desktop image in some embodiments the rebase logic first determines whether the hardware type associated with the stored desktop image is compatible with the hardware type that is indicated in the request for the desktop image received from a new target endpoint device. If the new hardware type is not compatible with the hardware type associated with the stored desktop image the rebase logic generates a rebased desktop image by modifying the base image portion of the desktop image to include a modified set of files that matches the hardware type of the new hardware device. After the rebased desktop image is generated in this manner a restore operation for the rebased desktop image is performed in accordance with the techniques described herein. For example the CVD server segments the rebased desktop image into a prefetch set a streaming set and a leave behind set by assigning each file in the rebased desktop image to one of a prefetch set a streaming set and a leave behind set and then sends the prefetch set to the target device followed by the streaming set.

To make possible the merging of user data applications with the device drivers and hardware related applications for a new endpoint device the rebase logic is configured to clean up the base image portion of a desktop image from any machine specific data. For example 

Additionally the techniques described herein ensure that both critical and PnP device drivers are automatically and properly installed on the target endpoint device after the rebase operation without requiring an IT administrator to specially prepare the base image portion of the desktop image. Examples of mechanisms that are employed to achieve this functionality include without limitation 

Depending upon a particular implementation the techniques for desktop streaming described herein may be implemented in any context and on any kind of computing platform or architecture and are not limited to any particular context computing platform or architecture. For purposes of explanation is a block diagram that illustrates an example computer system upon which embodiments of the techniques described herein may be implemented. For example computer system may be used to implement the functionalities of a CVD server and of other server side components in accordance with the techniques described herein. In another example computer system may be used to implement the functionalities of an endpoint computing device and of the endpoint side components in accordance with the techniques described herein.

According to one embodiment the techniques for desktop streaming described herein are implemented by one or more special purpose computing devices. The special purpose computing devices may be hard wired to perform the techniques or may include digital electronic devices such as one or more application specific integrated circuits ASICs or field programmable gate arrays FPGAs that are persistently programmed to perform the techniques or may include one or more general purpose hardware processors programmed to perform the techniques pursuant to program instructions in firmware memory other storage or a combination. Such special purpose computing devices may also combine custom hard wired logic ASICs or FPGAs with custom programming to accomplish the techniques. The special purpose computing devices may be desktop computer systems portable computer systems handheld devices networking devices or any other device that incorporates hard wired and or program logic to implement the techniques. Thus in various embodiments any or all of the endpoint device CVD server streaming agent service interceptor logic pivot application and other server side and endpoint side components configured to perform the functionalities of the techniques for desktop streaming described herein may comprise such special purpose computing devices alone or in combination with other elements.

For example is a block diagram that illustrates a computer system upon which an embodiment of the techniques described herein may be implemented. Computer system includes a bus or other communication mechanism for communicating information and one or more hardware processors coupled with bus for processing information. Hardware processor s may be for example a general purpose microprocessor.

Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor s . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor s . Such instructions when stored in storage media accessible to processor s render computer system into a special purpose machine that is customized to perform the operations specified in the instructions.

Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor s . A storage device such as a magnetic disk or optical disk is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT or Liquid Crystal Display LCD for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor s . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor s and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

Computer system may implement the techniques for desktop streaming described herein using customized hard wired logic one or more ASICs or FPGAs firmware and or program logic which in combination with the computer system causes or programs computer system to be a special purpose machine. According to one embodiment the techniques described herein are performed by computer system in response to processor s executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another storage medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor s to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions.

The term storage media as used herein refers to any non transitory media that store data and or instructions that cause a machine to operate in a specific fashion. Such storage media may comprise non volatile media and or volatile media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Common forms of storage media include for example a floppy disk a flexible disk hard disk solid state drive magnetic tape or any other magnetic data storage medium a CD ROM any other optical data storage medium any physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM NVRAM any other memory chip or cartridge.

Storage media is distinct from but may be used in conjunction with transmission media. Transmission media participates in transferring information between storage media. For example transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications.

Various forms of media may be involved in carrying one or more sequences of one or more instructions to processor s for execution. For example the instructions may initially be carried on a magnetic disk or solid state drive of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor s retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor s .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card cable modem satellite modem or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet or through a proprietary WAN. Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are example forms of transmission media.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface . The received code may be executed by processor s as it is received and or stored in storage device or other non volatile storage for later execution.

In the foregoing specification embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. Thus the sole and exclusive indicator of what is the invention and is intended by the applicants to be the invention is the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction. Any definitions expressly set forth herein for terms contained in such claims shall govern the meaning of such terms as used in the claims. Hence no limitation element property feature advantage or attribute that is not expressly recited in a claim should limit the scope of such claim in any way. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

This section describes additional claims that are directed to example embodiments of the techniques for desktop streaming described herein. Thus the description in this section is to be regarded in an illustrative rather than a restrictive sense.

Example embodiments of techniques for desktop streaming at the server side are described. Claim 1 is directed to a computer implemented method comprising receiving a first request for a desktop image comprising a collection of files segmenting the desktop image into a prefetch set a streaming set and a leave behind set wherein the prefetch set includes a smallest subset of files in the collection of files that is needed for a boot of a computing device without requiring retrieval of additional files the streaming set includes those files in the collection of files that are to be transferred after the boot the leave behind set includes those files in the collection of files that are to be transferred only when specifically requested in response to the first request sending the prefetch set to the computing device after the prefetch set has been sent receiving a second request for the streaming set and in response to the second request sending the streaming set to the computing device.

Claim 2. The method of Claim 1 further comprising sending the prefetch set and the steaming set over a wide area network with low bandwidth and high latency.

Claim 3. The method of Claim 1 wherein the collection of files included in the desktop image comprises operating system OS files shared library files and services executable files application executable and configuration files for one or more user applications a machine state and a profile including one or more of a machine identifier domain account identifier and a network address and user data and settings that are specific for a user.

Claim 4. The method of Claim 1 wherein the first request includes user credentials of a user of the computing device and wherein method further comprises determining based on the user credentials that the desktop image corresponds to the computing device.

Claim 5. The method of Claim 1 further comprising receiving a third request for a specific file included in the leave behind set while the sending of the prefetch set or the streaming set is in progress and in response to the third request lowering the priority of the sending of the streaming set and sending the specific file with high priority.

Claim 6. The method of Claim 1 further comprising determining based on the first request whether at least a portion of a working copy of the desktop image is stored at the computing device.

Claim 7. The method of Claim 1 further comprising receiving first information indicating the usage pattern of files at the computing device and segmenting the collection of files based on the first information.

Claim 8. The method of Claim 1 further comprising determining a static subset of the prefetch set wherein the static subset includes those operating system OS files that are needed to boot the computing device and determining a dynamic subset of the prefetch set wherein the dynamic subset includes files that are specific to a user of the computing device and that are needed to complete the boot until network services of the computing device are operational.

Claim 9. The method of Claim 8 wherein the static subset further includes files that comprise a streaming client which is configured when executed at the computing device to receive the streaming set.

Claim 10. The method of Claim 8 further comprising receiving a list of files that identifies those files that were accessed during one or more previous reboots of the computing device based on the list of files augmenting the dynamic subset of the prefetch set to add files that were accessed during the one or more previous reboots of the computing device and based on the list of files reducing the dynamic subset of the prefetch set to evict files which have not been accessed during the one or more previous reboots of the computing device.

Claim 11. The method of Claim 10 wherein the list of files is generated based on one or more heuristic rules that include one or more of a first heuristic rule that determines which files to include in the list of files based on a configurable time parameter that indicates a time period from the boot time of the computing device until a log in screen is displayed at the computing device a second heuristic rule that determines which files to include in the list of files based on the occurrence of a user log in event at the computing device a third heuristic rule that determines which files to include in the list of files based on one or more parameters that indicate the most recently or frequently accessed files at the computing device a fourth heuristic rule that determines which files to include in the list of files based on one or more configurable parameters and a fifth heuristic rule that determines which files to include in the list of files based on file usage information that is collected by the OS executed by the computing device.

Claim 12. The method of Claim 1 further comprising determining a safe set from the collection of files included in the desktop image wherein the safe set includes all operating system OS files but does not include any application files or user specific files and sending the safe set to the computing device in response to determining that the boot up of the computing device from the files in the prefetch set has failed.

Claim 13. The method of Claim 1 further comprising evicting files from one or more of the prefetch set and the streaming set when the sum of the sizes of the prefetch set and the streaming set exceeds the size of the physical disk storage at the computing device.

Claim 14. The method of Claim 1 further comprising receiving a ranked list of files that identifies files according to the frequency of access of these files at the computing device and ordering the streaming set based on the ranked list of files.

Claim 15. The method of Claim 14 further comprising one or more of re ordering the streaming set based on first data indicating files that are requested by the computing device on demand re ordering the streaming set based on second data indicating files which have not yet been sent to the computing device but access to which was requested at the computing device while the computing device was offline and re ordering the streaming set based on on demand requests for related files.

Claim 16. The method of Claim 1 further comprising generating and storing an index for files in the prefetch set and the streaming set wherein the index comprises file level signatures that identify the files in the prefetch set and the streaming set chunk level signatures that identify unique chunks from the files in the prefetch set and the streaming set based on the index transferring the files in the prefetch set and the streaming set to the computing device over a network wherein transferring the files in the prefetch set and the streaming set comprises transferring only the file level signatures of those files that are already stored on the computing device but not any data from those files wherein the file level signatures are used for comparison with local file level signatures on the computing device and transferring only the chunk level signatures of those chunks that are already stored on the computing device but not any data from those chunks wherein the chunk level signatures are used for comparison with local chunk level signatures on the computing device.

Claim 17. The method of Claim 1 further comprising sending one or more specific files or chunks thereof in response to receiving one or more read ahead requests from the computing device.

Claim 18. The method of Claim 1 wherein the collection of files included in the desktop image comprises a plurality of device driver files and a corresponding plurality of setup files and the method further comprises assigning to the leave behind set one or more device driver files of the plurality of device driver files and assigning to the prefetch set one or more setup files of the plurality of setup files wherein the one or more setup files correspond to the one or more device driver files.

Claim 19. The method of Claim 1 further comprising storing a plurality of desktop images on one or more storage devices in a data center wherein a separate one of the plurality of desktop images is associated with a separate one of a plurality of computing devices that can connect to the data center over a network wherein the desktop image is a particular one of the plurality of desktop images and wherein the computing device is a particular one of the plurality of computing devices.

Claim 20. The method of Claim 1 wherein receiving the first request further comprises receiving the first request from a mini client of the computing device wherein the mini client is included in a generic OS kernel that is downloaded to the computing device from a pre execution environment PXE server and wherein the mini client is configured to boot the computing device from the prefetch set of files.

Claim 21. The method of Claim 20 wherein the first request includes one or more of user credentials of a user of the computing device and hardware information associated with the computing device.

Claim 22. The method of Claim 20 wherein the generic OS kernel further includes a network optimization logic that is configured to optimize the download of the prefetch set of files to the computing device.

Example embodiments of techniques for desktop streaming at an endpoint device are described. Claim 1 is directed to a computing device comprising one or more processors one or more storage media coupled to the one or more processors logic stored in the one or more storage media and executable by the one or more processors wherein the logic is configured to cause the one or more processors to send a first request for a desktop image of the computing device wherein the desktop image includes a collection of files for the computing device wherein the desktop image is segmented into a prefetch set a streaming set and a leave behind set wherein the prefetch set includes the smallest subset of files in the collection of files that is needed to boot the computing device without requiring retrieval of additional files the streaming set includes those files in the collection of files that are to be downloaded to the computing device after the computing device has booted up the leave behind set includes those files in the collection of files that are to be downloaded to the computing device when specifically requested by the computing device in response to the first request receive the prefetch set and boot the computing device from files in the prefetch set after the computing device has booted up send a second request for the streaming set and in response to the second request receive the streaming set.

Claim 2. The computing device of Claim 1 wherein the logic is further configured to send a third request for a specific file included in the leave behind set while the receiving of the prefetch set or the streaming set is in progress and in response to the third request receive the specific file even though the receiving of the prefetch set or the streaming set is not completed.

Claim 3. The computing device of Claim 1 wherein the logic is further configured to in response to determining that the boot of the computing device from the files in the prefetch set has failed send a notification message in response to the notification message receive a safe set from the collection of files included in the desktop image wherein the safe set includes all operating system OS files but does not include any application files or user specific files and cause the computing device to boot from files in the safe set.

Claim 4. The computer of Claim 1 wherein the logic comprises one or more of a streaming agent logic that is configured to receive files of the desktop image an interceptor logic that is configured to intercept file system calls to a file system that is configured on the one or more storage devices and to collect information indicating the usage pattern of files at the computing device a pivot logic that is configured to execute during early boot phases and to replace one or more files in the file system with the files in the prefetch set a network client logic that is configured to boot the computing device over a network if the computing device does not store any previous working copies of the desktop image and an optimization logic that is configured to optimize the transfer of files.

Claim 5. The computing device of Claim 1 wherein the logic is further configured to collect first information indicating the usage pattern of files at the computing device based on the first information generate a list of files that identifies those files that were accessed during one or more previous reboots of the computing device and send the list of files to a computer that stores the desktop image.

Claim 6. The computing device of Claim 5 wherein the logic is further configured to generate the list of files based on one or more heuristic rules that include one or more of a first heuristic rule that determines which files to include in the list of files based on a configurable time parameter that indicates a time period from the boot time of the computing device until a log in screen is displayed at the computing device a second heuristic rule that determines which files to include in the list of files based on the occurrence of a user log in event at the computing device a third heuristic rule that determines which files to include in the list of files based on one or more parameters that indicate the most recently or frequently accessed files at the computing device a fourth heuristic rule that determines which files to include in the list of files based on one or more configurable parameters and a fifth heuristic rule that determines which files to include in the list of files based on file usage information that is collected by an operating system OS executed on the computing device.

Claim 7. The computing device of Claim 5 wherein the logic is further configured to exclude from the usage pattern any file accesses that are performed by one or more applications that scan the entire file system.

Claim 8. The computing device of Claim 1 wherein the logic is further configured to assign to an unmanaged set those files stored on the computing device that are excluded from the desktop image and are not protected upon restoring the desktop image on the computing device.

Claim 9. The computing device of Claim 1 further comprising network client logic stored in the one or more storage media and executable by the one or more processors wherein the network client logic is configured to cause the one or more processors to download at least a generic OS kernel from a pre execution environment PXE server wherein the generic OS kernel includes a mini client that is configured to receive files from storage of the desktop image and cause the one or more processors to execute the mini client.

Claim 10. The computing device of Claim 9 wherein the mini client is configured to cause the one or more processors to send a mini client request for the prefetch set of files in response to the mini client request receive the prefetch set of files and store the prefetch set of files on the computing device and boot the computing device from the prefetch set of files.

Claim 11. The computing device of Claim 9 wherein the mini client is further configured to perform one or more of including user credentials in the mini client request for the prefetch set of files and gathering hardware information and including the hardware information in the mini client request for the prefetch set of files.

Claim 12. The computing device of Claim 9 wherein the generic OS kernel further includes a network optimization logic and when executed by the one or more processors the network optimization logic is configured to optimize the download of the files from the storage of the desktop image.

Claim 13 is directed to a computer readable non transitory storage medium storing one or more sequences of instructions comprising instructions which when executed by one or more processors cause the one or more processors to send a first request for a desktop image of a computing device wherein the desktop image includes a collection of files for the computing device wherein the desktop image is segmented into a prefetch set a streaming set and a leave behind set wherein the prefetch set includes the smallest subset of files in the collection of files that is needed to boot the computing device without requiring retrieval of additional files the streaming set includes those files in the collection of files that are to be downloaded to the computing device after the computing device has booted up the leave behind set includes those files in the collection of files that are to be downloaded to the computing device when specifically requested by the computing device in response to the first request receive the prefetch set and boot the computing device from files in the prefetch set after the computing device has booted up send a second request for the streaming set and in response to the second request receive the streaming set.

Claim 14. The computer readable medium of Claim 13 wherein the one or more sequences of instructions further comprise instructions which when executed by the one or more processors cause the one or more processors to send a third request for a specific file included in the leave behind set while the receiving of the prefetch set or the streaming set is in progress and in response to the third request receive the specific file even though the receiving of the prefetch set or the streaming set is not completed.

Claim 15. The computer readable medium of Claim 13 wherein the one or more sequences of instructions further comprise instructions which when executed by the one or more processors cause the one or more processors to in response to determining that the boot of the computing device from the files in the prefetch set has failed send a notification message in response to the notification message receive a safe set from the collection of files included in the desktop image wherein the safe set includes all operating system OS files but does not include any application files or user specific files and cause the computing device to boot from files in the safe set.

Claim 16. The computer readable medium of Claim 13 wherein the one or more sequences of instructions further comprise one or more of a streaming agent logic which when executed by the one or more processors cause the one or more processors to receive files of the desktop image an interceptor logic which when executed by the one or more processors cause the one or more processors to intercept file system calls to a file system that is configured on the one or more storage devices and to collect information indicating the usage pattern of files at the computing device a pivot logic which when executed by the one or more processors during early boot phases cause the one or more processors to replace one or more files in the file system with the files in the prefetch set a network client logic which when executed by the one or more processors cause the one or more processors to boot the computing device over a network if the computing device does not store any previous working copies of the desktop image and an optimization logic which when executed by the one or more processors cause the one or more processors to optimize the transfer of files.

Claim 17. The computer readable medium of Claim 13 wherein the one or more sequences of instructions further comprise instructions which when executed by the one or more processors cause the one or more processors to collect first information indicating the usage pattern of files at the computing device based on the first information generate a list of files that identifies those files that were accessed during one or more previous reboots of the computing device and send the list of files to a computer that stores the desktop image.

Claim 18. The computer readable medium of Claim 17 wherein the one or more sequences of instructions further comprise instructions which when executed by the one or more processors cause the one or more processors to generate the list of files based on one or more heuristic rules that include one or more of a first heuristic rule that determines which files to include in the list of files based on a configurable time parameter that indicates a time period from the boot time of the computing device until a log in screen is displayed at the computing device a second heuristic rule that determines which files to include in the list of files based on the occurrence of a user log in event at the computing device a third heuristic rule that determines which files to include in the list of files based on one or more parameters that indicate the most recently or frequently accessed files at the computing device a fourth heuristic rule that determines which files to include in the list of files based on one or more configurable parameters and a fifth heuristic rule that determines which files to include in the list of files based on file usage information that is collected by an operating system OS executed on the computing device.

Claim 19. The computer readable medium of Claim 17 wherein the one or more sequences of instructions further comprise instructions which when executed by the one or more processors cause the one or more processors to exclude from the usage pattern any file accesses that are performed by one or more applications that scan the entire file system.

Claim 20. The computer readable medium of Claim 13 wherein the one or more sequences of instructions further comprise instructions which when executed by the one or more processors cause the one or more processors to assign to an unmanaged set those files stored on the computing device that are excluded from the desktop image and are not protected upon restoring the desktop image on the computing device.

Claim 21. The computer readable medium of Claim 13 wherein the one or more sequences of instructions further comprise network client instructions which when executed by the one or more processors cause the one or more processors to download at least a generic OS kernel from a pre execution environment PXE server wherein the generic OS kernel includes a mini client that is configured to receive files from storage of the desktop image and cause the one or more processors to execute the mini client.

Claim 22. The computer readable medium of Claim 21 wherein when executed by the one or more processors the mini client is configured to cause the one or more processors to send a mini client request for the prefetch set of files in response to the mini client request receive the prefetch set of files and store the prefetch set of files on the computing device and boot the computing device from the prefetch set of files.

Claim 23. The computer readable medium of Claim 21 wherein when executed by the one or more processors the mini client is further configured to cause the one or more processors to perform one or more of including user credentials in the mini client request for the prefetch set of files and gathering hardware information and including the hardware information in the mini client request for the prefetch set of files.

Claim 24. The computer readable medium of Claim 21 wherein the generic OS kernel further includes a network optimization logic and when executed by the one or more processors the network optimization logic is configured to optimize the download of the files from the storage of the desktop image.

Claim 25 is directed to a computer implemented method comprising sending a first request for a desktop image of a computing device wherein the desktop image includes a collection of files for the computing device wherein the desktop image is segmented into a prefetch set a streaming set and a leave behind set wherein the prefetch set includes the smallest subset of files in the collection of files that is needed to boot the computing device without requiring retrieval of additional files the streaming set includes those files in the collection of files that are to be downloaded to the computing device after the computing device has booted up the leave behind set includes those files in the collection of files that are to be downloaded to the computing device when specifically requested by the computing device in response to the first request receiving the prefetch set and boot the computing device from files in the prefetch set after the computing device has booted up sending a second request for the streaming set and in response to the second request receiving the streaming set.

Claim 26. The method of Claim 25 further comprising sending a third request for a specific file included in the leave behind set while the receiving of the prefetch set or the streaming set is in progress and in response to the third request receiving the specific file even though the receiving of the prefetch set or the streaming set is not completed.

Claim 27. The method of Claim 25 further comprising in response to determining that the boot of the computing device from the files in the prefetch set has failed sending a notification message in response to the notification message receiving a safe set from the collection of files included in the desktop image wherein the safe set includes all operating system OS files but does not include any application files or user specific files and causing the computing device to boot from files in the safe set.

Claim 28. The method of Claim 25 further comprising one or more of a streaming agent logic receiving files of the desktop image an interceptor logic intercepting file system calls to a file system that is configured on the one or more storage devices and collecting information indicating the usage pattern of files at the computing device a pivot logic replacing one or more files in the file system with the files in the prefetch set a network client logic booting the computing device over a network if the computing device does not store any previous working copies of the desktop image and an optimization logic optimizing of the transfer of files.

Claim 29. The method of Claim 25 further comprising collecting first information indicating the usage pattern of files at the computing device based on the first information generating a list of files that identifies those files that were accessed during one or more previous reboots of the computing device sending the list of files to a computer that stores the desktop image.

Claim 30. The method of Claim 29 further comprising generating the list of files based on one or more heuristic rules that include one or more of a first heuristic rule that determines which files to include in the list of files based on a configurable time parameter that indicates a time period from the boot time of the computing device until a log in screen is displayed at the computing device a second heuristic rule that determines which files to include in the list of files based on the occurrence of a user log in event at the computing device a third heuristic rule that determines which files to include in the list of files based on one or more parameters that indicate the most recently or frequently accessed files at the computing device a fourth heuristic rule that determines which files to include in the list of files based on one or more configurable parameters and a fifth heuristic rule that determines which files to include in the list of files based on file usage information that is collected by an operating system OS executed on the computing device.

Claim 31. The method of Claim 29 further comprising excluding from the usage pattern any file accesses that are performed by one or more applications that scan the entire file system.

Claim 32. The method of Claim 35 further comprising assigning to an unmanaged set those files stored on the computing device that are excluded from the desktop image and are not protected upon restoring the desktop image on the computing device.

Claim 33. The method of Claim 25 further comprising downloading at least a generic OS kernel from a pre execution environment PXE server wherein the generic OS kernel includes a mini client that is configured to receive files from storage of the desktop image and causing the computing device to execute the mini client.

Claim 34. The method of Claim 33 wherein when executed by the computing device the mini client performs sending a mini client request for the prefetch set of files in response to the mini client request receiving the prefetch set of files and store the prefetch set of files on the computing device and causing the computing device to boot from the prefetch set of files.

Claim 35. The method of Claim 33 wherein the mini client further performs one or more of including user credentials in the mini client request for the prefetch set of files gathering hardware information and including the hardware information in the mini client request for the prefetch set of files.

Claim 36. The method of Claim 33 wherein the generic OS kernel further includes a network optimization logic and when executed by the one or more processors the network optimization logic is configured to optimize the download of the files from the storage of the desktop image.

Example embodiments of techniques for dynamic switching of base image portions are described. Claim 1 is directed to a computer comprising one or more processors logic stored in one or more storage media and executable by the one or more processors wherein the logic is configured to cause the one or more processors to receive a first request for a desktop image comprising a collection of files determine that a first hardware indicated in the desktop image is not compatible with a second hardware that is indicated in the first request generate a rebased desktop image by modifying the desktop image wherein the rebased desktop image includes a modified collection of files that matches the second hardware segment the rebased desktop image into a prefetch set a streaming set and a leave behind set by assigning each file of the modified collection of files to one of the prefetch set the streaming set and the leave behind set in response to the first request send the prefetch set to a computing device after the prefetch set has been sent receive a second request for the streaming set and in response to the second request send the streaming set to the computing device.

Claim 2. The computer of Claim 1 wherein the prefetch set includes a smallest subset of files in the modified collection of files that is needed for a boot up without requiring retrieval of additional files the streaming set includes those files in the modified collection of files that are to be sent after the boot up and the leave behind set includes those files in the modified collection of files that are to be sent when specifically requested.

Claim 3. The computer of Claim 1 wherein to generate the rebased desktop image the logic is further configured to remove machine specific data from one or more files in the collection of files included in the desktop image wherein the machine specific data includes one or more of a name identifier that corresponds to the first hardware that matches the desktop image and one or more device identifiers that identify one or more device instances on the first hardware that matches the desktop image.

Claim 4. The computer of Claim 1 wherein to generate the rebased desktop image the logic is further configured to add to the modified collection of files setup files that respectively correspond to device driver files for all device drivers that are included in the rebased desktop image.

Claim 5. The computer of Claim 1 wherein to generate the rebased desktop image the logic is further configured to add to the modified collection of files one or more device drivers for one or more corresponding plug and play devices that are included in the second hardware wherein the added one or more device drivers are used for installation of new device drivers and for cleaning up unnecessary device drivers on the computing device.

Claim 6. The computer of Claim 1 wherein the logic is further configured to store a plurality of desktop images on one or more storage devices in a data center wherein a separate one of the plurality of desktop images is associated with a separate one of a plurality of computing devices that can connect to the data center over a network wherein the desktop image is a particular one of the plurality of desktop images and wherein the computing device is a particular one of the plurality of computing devices.

Claim 7 is directed to a computer readable non transitory storage medium storing one or more sequences of instructions comprising instructions which when executed by one or more processors cause the one or more processors to receive a first request for a desktop image comprising a collection of files determine that a first hardware indicated in the desktop image is not compatible with a second hardware that is indicated in the first request generate a rebased desktop image by modifying the desktop image wherein the rebased desktop image includes a modified collection of files that matches the second hardware segment the rebased desktop image into a prefetch set a streaming set and a leave behind set by assigning each file of the modified collection of files to one of the prefetch set the streaming set and the leave behind set in response to the first request send the prefetch set to a computing device after the prefetch set has been sent receive a second request for the streaming set and in response to the second request send the streaming set to the computing device.

Claim 8. The computer readable medium of Claim 7 wherein the prefetch set includes a smallest subset of files in the modified collection of files that is needed for a boot up without requiring retrieval of additional files the streaming set includes those files in the modified collection of files that are to be sent after the boot up and the leave behind set includes those files in the modified collection of files that are to be sent when specifically requested.

Claim 9. The computer readable non transitory storage medium of Claim 7 wherein the instructions that cause the one or more processors to generate the rebased desktop image further comprise instructions which when executed by the one or more processors cause the one or more processors to remove machine specific data from one or more files in the collection of files included in the desktop image wherein the machine specific data includes one or more of a name identifier that corresponds to the first hardware that matches the desktop image and one or more device identifiers that identify one or more device instances on the first hardware that matches the desktop image.

Claim 10. The computer readable non transitory storage medium of Claim 7 wherein the instructions that cause the one or more processors to generate the rebased desktop image further comprise instructions which when executed by the one or more processors cause the one or more processors to add to the modified collection of files setup files that respectively correspond to device driver files for all device drivers that are included in the rebased desktop image.

Claim 11. The computer readable non transitory storage medium of Claim 7 wherein the instructions that cause the one or more processors to generate the rebased desktop image further comprise instructions which when executed by the one or more processors cause the one or more processors to add to the modified collection of files one or more device drivers for one or more corresponding plug and play devices that are included in the second hardware wherein the added one or more device drivers are used for installation of new device drivers and for cleaning up unnecessary device drivers on the computing device.

Claim 12. The computer readable non transitory storage medium of Claim 7 wherein the one or more sequences of instructions further comprise instructions which when executed by the one or more processors cause the one or more processors to store a plurality of desktop images on one or more storage devices in a data center wherein a separate one of the plurality of desktop images is associated with a separate one of a plurality of computing devices that can connect to the data center over a network wherein the desktop image is a particular one of the plurality of desktop images and wherein the computing device is a particular one of the plurality of computing devices.

Claim 13 is directed to a computer implemented method comprising receiving a first request for a desktop image comprising a collection of files determining that a first hardware indicated in the desktop image is not compatible with a second hardware that is indicated in the first request generating a rebased desktop image by modifying the desktop image wherein the rebased desktop image includes a modified collection of files that matches the second hardware segmenting the rebased desktop image into a prefetch set a streaming set and a leave behind set by assigning each file of the modified collection of files to one of the prefetch set the streaming set and the leave behind set in response to the first request sending the prefetch set to a computing device after the prefetch set has been sent receiving a second request for the streaming set and in response to the second request sending the streaming set to the computing device.

Claim 14. The method of Claim 13 wherein the prefetch set includes a smallest subset of files in the modified collection of files that is needed for a boot up without requiring retrieval of additional files the streaming set includes those files in the modified collection of files that are to be sent after the boot up and the leave behind set includes those files in the modified collection of files that are to be sent when specifically requested.

Claim 15. The method of Claim 13 wherein generating the rebased desktop image further comprises removing machine specific data from one or more files in the collection of files included in the desktop image wherein the machine specific data includes one or more of a name identifier that corresponds to the first hardware that matches the desktop image and one or more device identifiers that identify one or more device instances on the first hardware that matches the desktop image.

Claim 16. The method of Claim 13 wherein generating the rebased desktop image further comprises adding to the modified collection of files setup files that respectively correspond to device driver files for all device drivers that are included in the rebased desktop image.

Claim 17. The method of Claim 13 generating the rebased desktop image further comprises adding to the modified collection of files one or more device drivers for one or more corresponding plug and play devices that are included in the second hardware wherein the added one or more device drivers are used for installation of new device drivers and for cleaning up unnecessary device drivers on the computing device.

Claim 18. The method of Claim 13 further comprising storing a plurality of desktop images on one or more storage devices in a data center wherein a separate one of the plurality of desktop images is associated with a separate one of a plurality of computing devices that can connect to the data center over a network wherein the desktop image is a particular one of the plurality of desktop images and wherein the computing device is a particular one of the plurality of computing devices.

Example embodiments of techniques for on demand block level file system streaming to remote desktops are described. Claim 1 is directed to a computer implemented method comprising receiving from a first process of a computing device a first request to open a file in a file system of the computing device wherein the first request to open the file specifies a first sharing mode that precludes other processes of the computing device from opening the file wherein at least one block from the file has not yet been downloaded to the computing device modifying in response to the first request the first sharing mode to a read write sharing mode that allows other processes to open the file and opening the file in the read write sharing mode receiving one or more blocks from the file and writing the one or more blocks into the file while the one or more blocks are being received or written into the file receiving a second request to open the file from a second process of the computing device wherein the second request specifies a second sharing mode checking the second sharing mode for compatibility with the first sharing mode denying the second request when the second sharing mode is not compatible with the first sharing mode even though in the file system the file is opened in the read write sharing mode.

Claim 2. The method of Claim 1 further comprising notifying the first process that the file is opened in the first sharing mode even though in the file system the file is opened in the read write sharing mode.

Claim 3. The method of Claim 1 further comprising when the second sharing mode is compatible with the first sharing mode modifying the second sharing mode to the read write sharing mode and opening the file in the read write sharing mode in response to the second request notifying the second process that the file is opened in the second sharing mode even though in the file system the file is opened in the read write sharing mode.

Claim 4. The method of Claim 1 further comprising predicting that a lock on a byte range in a particular block from the file will be needed sending a third request to download the particular block from the file.

Claim 5. The method of Claim 1 wherein the first request to open the file needs a lock on a byte range in a particular block from the file that has not yet been downloaded to the computing device and wherein the method further comprises in response to the first request maintaining the lock on the byte range in the particular block from the file but without propagating the lock to the file system while the particular block is being received or written into the file checking the lock for compatibility with any subsequent requests that need locks on the byte range in the particular block from the file denying those subsequent requests which are not compatible with the lock on the byte range in the particular block from the file.

Claim 6. The method of Claim 1 further comprising intercepting one or more subsequent requests for the one or more blocks from the file blocking the one or more subsequent requests until the one or more blocks have been written into the file.

Claim 7. The method of Claim 1 further comprising collecting first information indicating access patterns to a set of blocks from the file receiving a third request for a particular block from the set of blocks in response to the third request based on the first information predicting which other blocks from the set of blocks are likely to be requested sending a fourth request to download the other blocks from the set of blocks prior to requests for the other blocks.

Claim 8. The method of Claim 1 further comprising intercepting calls to access files in the file system and to continuously collect first information indicating the usage of the files.

Claim 9. The method of Claim 8 further comprising based on the first information generating a list of files that identifies those files that were accessed during one or more previous reboots of the computing device sending the list of files to a data center that is configured to store a desktop image for the computing device wherein the list of files is used to segment a collection of files included the desktop image into a prefetch set a streaming set and a leave behind set wherein the prefetch set includes a smallest subset of files in the collection of files that is needed to boot up the computing device without requiring retrieval of additional files the streaming set includes those files in the collection of files that are to be downloaded to the computing device after the computing device has booted up the leave behind set includes those files in the collection of files that are to be downloaded to the computing device when specifically requested by the computing device.

Claim 10. The method of Claim 8 wherein the first information indicates one or more of file and directory creation operations file and directory rename operations and file close operations and the method further comprises storing the first information as entries in an in memory queue that is allocated in volatile memory periodically traversing the in memory queue and remove any duplicate entries from the in memory queue.

Claim 11. The method of Claim 1 further comprising indicating to file requestors executing on the computing device that all files of the file system are stored on the computing device even though not all files have been fully downloaded to the computing device wherein the file system stores metadata for those files that have not yet been downloaded wherein the metadata includes file names file system structure file sizes file attributes and access control lists ACLs and wherein the file requestors include an operating system OS process and a user application process receiving a third request for a particular file determining that the particular file is associated with a particular identifier in the file system wherein the particular identifier indicates that the particular file has not yet been downloaded blocking the third request and cause the particular file to be downloaded with a highest priority after at least a portion of the particular file has been downloaded unblocking the third request and in response thereto provide a file handle to the particular file.

Claim 12. The method of Claim 1 further comprising when a file has not yet been downloaded to the computing device setting an offline bit attribute for the file in file system metadata that corresponds to the file.

Example embodiments of techniques for atomic switching of images in desktop streaming over wide area networks are described. Claim 1 is directed to a computer implemented method comprising executing a pivot process during a first boot of an operating system OS on a computing device wherein the pivot process is the only process running when performing modifications to a file system on the computing device wherein during execution the pivot process causes one or more processors on the computing device to perform the steps of replacing a current set of files in the file system with a new desktop image wherein the new desktop image presents a complete view of the file system wherein a prefetch set of files is included in the new desktop image but other files are represented in the complete view of the file system by file metadata that is included in the new desktop image wherein the prefetch set of files includes a smallest subset of files in the new desktop image that is needed to boot the computing device without requiring retrieval of additional files and terminating the first boot and invoking a second boot that is executed based on the prefetch set of files included in the new desktop image.

Claim 2. The method of Claim 1 wherein the prefetch set of files includes one or more of a kernel driver file for the OS a configuration file for the OS and an application that runs after the second boot is completed.

Claim 3. The method of Claim 1 wherein the file metadata included in the new desktop image comprises file identifiers but not data from the other files.

Claim 4. The method of Claim 1 wherein the pivot process further causes the one or more processors to perform the steps of moving one or more of the prefetch set of files into one or more file system paths that respectively correspond to one or more of the current set of files and adjusting the file system metadata that is associated with the one or more of the prefetch set of files.

Claim 5. The method of Claim 1 wherein the pivot process further causes the one or more processors to perform the steps of overwriting one or more of the current set of files with respectively corresponding one or more of the prefetch set of files and deleting one or more of the current set of files.

Claim 6. The method of Claim 1 wherein the pivot process further causes the one or more processors to perform the step of using OS privileges to grant itself access to any restricted files in the current set of files or in the prefetch set of files.

Claim 7. The method of Claim 1 wherein in response to a power failure during the execution of the pivot process the pivot process further causes the one or more processors to perform the step of retrying to replace the current set of files with the new desktop image until successful completion.

Claim 8. The method of Claim 1 wherein the pivot process is executing in a user mode memory address space that is allocated by the OS.

Claim 9. The method of Claim 1 wherein the pivot process is configured to execute prior to the execution of any file or directory rename operations that are scheduled to execute during the first boot up.

Claim 10. The method of Claim 1 further comprising receiving files from storage of the desktop image.

Claim 11. The method of Claim 10 wherein receiving the files from the storage of the desktop image further comprises receiving the prefetch set of files and storing the prefetch set of files in a staging area of the file system.

Claim 12. The method of Claim 10 wherein the new desktop image represents a collection of files for the computing device wherein the collection of files is segmented into the prefetch set a streaming set and a leave behind set wherein the streaming set includes those files in the collection of files that are to be downloaded after the second boot is completed and the leave behind set includes those files in the collection of files that are to be downloaded when specifically requested wherein receiving the files from the storage of the desktop image further comprises receiving the files in the streaming set after the second boot is completed and the method further comprises while the receiving of the streaming set is in progress requesting a specific file included in the leave behind set and receiving the specific file even though the receiving of the streaming set is not yet completed.

