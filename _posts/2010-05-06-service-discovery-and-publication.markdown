---

title: Service discovery and publication
abstract: A system and methods for service discovery and publication are disclosed. Application programs write requests for service discovery, publication, and subscription to a service discovery application programming interface. The service discovery application programming interface invokes one or more lower-level protocols to satisfy the discovery, publication and/or subscription request. Service information retrieved from lower-layer protocols is formatted into a consistent data model and returned to the client application. In addition, service information may be stored in a persistent data store managed by a discovery persistence service communicatively connected to the service discovery API.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08489759&OS=08489759&RS=08489759
owner: Microsoft Corporation
number: 08489759
owner_city: Redmond
owner_country: US
publication_date: 20100506
---
This application is a Continuation of and claims priority to co pending application Ser. No. 10 693 653 filed Oct. 24 2003 entitled Service Discovery and Publication which is incorporated herein by reference.

The described subject matter relates to digital computing and more particularly to service discovery in computing devices and computing networks.

Application programs that execute on computing devices and computer networks may require the use of services provided by other physical or logical devices connected to the computing device or network. Presently application programs use a wide range of application programming interfaces APIs protocols and object models to discover enumerate and describe services and devices on a local computing device or across a plurality of devices in a computer network. The mechanisms available to discover enumerate and describe services and devices differ significantly even when the services and devices involved are conceptually similar.

For example consider a situation in which an application seeks to enumerate available printers. When executing within an administered corporate environment the application may need to use Lightweight Directory Access Protocol LDAP to communicate with a Microsoft Active Directory directory service store to discover registered corporate printers NetBT to discover print queue servers and Bluetooth to discover personal area network printers. In addition the application might have to invoke device management APIs to discover direct attached printers and UPnP APIs to discover UPnP printers. Each of these mechanisms requires understanding of a particular API protocol and query semantic.

The number of APIs and protocols required to for an application to discover enumerate and describe services complicates the task of software development.

Implementations described and claimed herein address these and other problems by providing a uniform interface that simplifies discovery and publication tasks. The uniform interface permits underlying protocols to be leveraged and eliminates the need for application developers to understand low level protocols. The uniform interface provides a consistent high level abstraction of services and associated operations that targets the discovery and publication of service details over a wide range of lower level APIs protocols stores and network environments.

In one exemplary implementation a method for discovering services available in a computing environment is provided. The method comprises in an application program defining a discovery scope defining a discovery filter and initiating a search request to a first application programming interface and in the first application programming interface parsing the search request retrieving service information corresponding to the requested discovery scope and discovery filter and returning the service information to the application program.

In another exemplary implementation a method for publishing services available in a computing environment is provided. The method comprises in an application program defining a service entry object defining a publication scope assigning a unique key to the service assigning a service type defining properties for the service and defining endpoints for the service and initiating a publication request to a first application programming interface and in the first application programming interface parsing the search request and executing at least one low level API call to publish the service.

In another exemplary implementation a method for deleting a published service in a computing environment is provided. The method comprises in an application program defining a service entry object specifying a key corresponding to the published service defining a deletion scope and initiating a deletion request to a first application programming interface and in the first application programming interface parsing the search request and executing at least one low level API call to delete the service.

In another exemplary implementation a method of subscribing to service events in a computing environment is provided. The method comprises in an application program defining a scope defining a filter defining a callback function and initiating a subscription request to a first application programming interface and in the first application programming interface parsing the search request and executing at least one low level API call to subscribe to service events and returning information from service events to the application program.

In another exemplary implementation a system for managing information about services available in a computing environment is provided. The system comprises a first application programming interface configured to accept service queries from an application wherein the first application programming interface receives service queries in a first service query protocol processes the service queries and launches at least one corresponding service query to a second protocol a discovery persistence service communicatively connected to the first application programming interface wherein the discovery persistence service receives service information from the first application programming interface and stores the service information in a data store.

Described herein are exemplary methods and software architecture for service discovery and publication. The methods described herein may be embodied as logic instructions on a computer readable medium. When executed on a processor the logic instructions cause a general purpose computing device to be programmed as a special purpose machine that implements the described methods. The processor when configured by the logic instructions to execute the methods recited herein constitutes structure for performing the described methods.

Computing device includes one or more processors or processing units a system memory and a bus that couples various system components including the system memory to processors . The bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computing device such as during start up is stored in ROM .

Computing device further includes a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from and writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM or other optical media. The hard disk drive magnetic disk drive and optical disk drive are connected to the bus by an SCSI interface or some other appropriate interface. The drives and their associated computer readable media provide nonvolatile storage of computer readable instructions data structures program modules and other data for computing device . Although the exemplary environment described herein employs a hard disk a removable magnetic disk and a removable optical disk it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks random access memories RAMs read only memories ROMs and the like may also be used in the exemplary operating environment.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into computing device through input devices such as a keyboard and a pointing device . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are connected to the processing unit through an interface that is coupled to the bus . A monitor or other type of display device is also connected to the bus via an interface such as a video adapter . In addition to the monitor personal computers typically include other peripheral output devices not shown such as speakers and printers.

Computing device commonly operates in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to computing device although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment computing device is connected to the local network through a network interface or adapter . When used in a WAN networking environment computing device typically includes a modem or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the bus via a serial port interface . In a networked environment program modules depicted relative to the computing device or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Generally the data processors of computing device are programmed by means of instructions stored at different times in the various computer readable storage media of the computer. Programs and operating systems are typically distributed for example on floppy disks or CD ROMs. From there they are installed or loaded into the secondary memory of a computer. At execution they are loaded at least partially into the computer s primary electronic memory. The invention described herein includes these and other various types of computer readable storage media when such media contain instructions or programs for implementing the steps described below in conjunction with a microprocessor or other data processor. The invention also includes the computer itself when programmed according to the methods and techniques described below.

Application programs invoke service discovery API to discover services available in the computing environment. Service discovery API provides a high level grammar for expressing discovery queries. The grammar may be implemented in OPath a natural query language used for expressing discovery queries. This high level grammar provides software developers a more conceptual mechanism to express the service s the developer is looking for rather than requiring a more granular and protocol specific expression that may be required by the underlying protocols . The developer can construct a query using the high level grammar which may then be forwarded to either a specific set of protocols referred to as a number of concrete scopes or use an abstract scope which is a predefined or configured set of concrete scopes. In addition to supporting service discovery the system supports service publication deleting and monitoring for events.

Service discovery API in turn invokes one or more underlying protocols represented in the diagram by Protocol 1 through Protocol 8 . The particular number of underlying protocols is not important. Certain of the protocols may be directory backed protocols such as e.g. LDAP Universal Description Discovery and Integration UDDI and Domain Name System DNS Server. Other protocols may be ad hoc protocols such as e.g. Bluetooth UPnP and NetBT. One or more of the underlying protocols uses a communication connection to communicate with other components or services available in the computing environment.

In response to the discovery request the service discovery API returns a collection of ServiceEntry objects that represent matching services discovered either on the local machine or on the network. A ServiceEntry object is a generalized data structure that can represent much of the relevant detail returned by the underlying protocols that system supports. Each ServiceEntry object corresponds to a single instance of a service. In one implementation the ServiceEntry object provides descriptive and identifying properties including 1 a service name 2 a service description 3 endpoints which typically contain a network address es for the service 4 a key that identifies the service instance 5 properties e.g. an extensible list of name value pairs for service or device characteristics and 6 a provider e.g. an identifier that identifies the entity that provides the service.

A discovery persistence service communicates with service discover API . Among other things discovery persistence service registers for announcement events over ad hoc protocols. The discovery persistence service is notified when an announcement event is detected and the discovery persistence service copies information about the service announcement into a memory location in data store . Storing service details in a memory location enables discovery of services that may be currently unavailable. For example even if a printer is currently switched off details about the printer may be registered in the memory location and can be discovered. In addition service queries are not restricted to the protocol that communicates with the service. Moreover the performance of querying the memory location may be much better than issuing a broad network discovery query.

In an exemplary implementation the service discovery API provides methods for service discovery service publication and subscribing to service event notifications. is a flowchart illustrating operations for service discovery. At operation an application defines a scope at operation the application defines a filter and at operation the application issues a search request. The service discovery API receives the search request and at operation the service discovery API parses the search request. At optional operation the service discovery API determines whether the search request is resolvable using information stored in the discovery persistence service . In one implementation information managed by the discovery persistence service includes a time of life indicator that specifies the lifespan of the information in the discovery persistence service . Depending upon control and configuration the service discovery API may query the discovery persistence service to determine whether the discovery request can be satisfied using information the discovery persistence service manages on the data store . If the discovery request is resolvable using the discovery persistence service then control passes to operation and the service entry objects retrieved from the discovery persistence service are returned to the application.

By contrast if the discovery request is not resolved or resolvable using information managed by the discovery persistence service then control passes to operation and the service discovery API executes the low level API call s required to fulfill the discovery request. At operation the service information returned from the low level API calls is formatted into service entry objects and at optional operation the service entry objects are forwarded to the discovery persistence service which may store the service entry objects on data store . At optional operation further processing and filtering of the service entry results such as duplicate detection and removal may be performed. At operation the service entry objects are returned to the application for further processing at operation . The particular details of the further processing performed by the application are not important.

The service discovery API receives the publication request and at operation parses the publication request. At operation the service discovery API executes the low level API calls to execute the service publication request. At optional operation the service publication is stored in the discovery persistence service .

The service publication facilities of the service discovery API can also be used to delete a published service. is a flowchart illustrating operations for service deletion. At operation an application defines a service entry object for the service publication. At operation the application specifies the unique key for the service. At operation the application defines a scope for the service deletion. At operation the application generates a service deletion request.

The service discovery API receives the deletion request and at operation parses the deletion request. At operation the service discovery API executes the low level API calls to execute the service deletion request. At optional operation the service publication is deleted from the discovery persistence service .

The service discovery API can also be used to allow applications to be notified of service events such as the arrival or departure of a new service or device of a particular type. is a flowchart illustrating operations for subscribing to service events. At operation an application defines a scope that specifies the particular low level protocol to monitor. At operation the application defines a filter that specifies the type of event. At operation the application defines a callback function that will receive ServiceEntry details as matching events occur. At operation an application generates a subscription request which is forwarded to the service discovery API .

The service discovery request API receives the subscription request and at operation parses the subscription request. At operation the service discovery request executes the low level protocol calls required to implement the subscription service. When a service event occurs the low level protocol will provide the service discovery API with a notification of the event. At operation the event notification is formatted into a service entry object. At optional operation the service entry object may be stored in the discovery persistence service and at operation the service entry object is returned to the application using the previously specified callback function. At operation the application performs further processing on the service entry object. The particular details of the further processing performed by the application are not important.

A Filter is a set of rules by which a service description can be evaluated resulting in true i.e. service description matches the filter or false i.e. service description doesn t match the filter . A filter can be expressed either as a simple filter which specifies particular properties or as a rich filter which uses more expressive grammar. Whether expressed as a simple filter or a rich filter queries can be specified and executed over more than one protocol without modification subject to the capabilities of the underlying protocols. The service discovery request API manages the re expression of the higher level query into the correct format for the underlying low level protocol. For example the service discovery request API can receive a query for a particular service type and express and evaluate it using LDAP for Active Directory and using the UDDI protocol for a UDDI Web service registry. An application developer is not required to work directly with the individual protocols.

In an exemplary implementation the service discovery request API requires discovery modules to support a simple filter providing exact match semantics for provided criteria and a rich filter containing a query expressed in the OPath grammar. It will be appreciated that each may also support additional native filter types. Different discovery modules may have protocol specific native filter types e.g. UPnP may use XPath filters Active Directory may natively use LDAP filters and UDDI may natively use a UDDI filter.

The base level of OPath filter functionality across the modules further insulates applications from underlying discovery protocols. The filter class exposes additional methods to parse and interpret the filter in a way that is shared across the modules.

A simple filter provides for expression of queries by specifying a service type services interfaces and or properties. Any combination of these settings may be provided in a search query and services will be included in the resulting service entry collection only if all of the criteria exactly match.

The service type may be implemented as a string that specifies the type that must match the service instances. A common set of service types are predefined in the service discovery request API . This set may be extended as key entities within protocols and stores are identified. For example for printers in Active Directory this would specify filter.ServiceType CommonServiceTypes.Printer.

The service interfaces may be implemented as a string collection that specifies identifiers for interfaces that services must match. As an example for web services in UDDI the following tModel identifiers could be specified filter.ServiceInterfaces.Add uuid ac104dcc d623 452f 88a7 f8acd94d9b2b filter.ServiceInterfaces.Add uuid 4d2ac1ca e234 142f e217 4d9b2f8acd9b 

Properties may be implemented in a property dictionary that specifies service characteristics that services must match. As an example for printers in Active Directory the following properties could be specified filter.Properties.Add printcolor TRUE filter.Properties.Add pagesperminute 50 

A rich filter provides a mechanism for expressing significantly richer query semantics using e.g. the OPath grammar by setting a Query string property. As an example for web services in UDDI the Query string would specify the required name and a required supported interface filter.Query WebService name Fabrikam and ServiceInterface uuid ac104dcc d623 452f 88a7 f8acd94d9b2b 

As a more expressive example to find printers in Active Directory capable of printing more than 25 pages per minute where A4 paper is not available filter.Query Printer printPagesPerMinute 20 5 and not printmediaReady A4 .

Since the capabilities of the underlying protocols and stores are far from identical ranging from the basic NetBT to the rich Active Directory query semantics the ability to use the more expressive constructs of OPath will depend upon the scope protocol selected.

A scope identifies a query domain that can be searched usually coarse and by network location or administrative boundary. Discovery queries are directed to one or more scopes and the query result includes a subset of the services within those scopes i.e. the query result is the subset of all services within the scope that match the given filter. Exemplary scopes include workgroup localmachine and domain.

The service discovery API accommodates concrete scopes and abstract scopes. A concrete scope specifies a query domain in three pieces. A Protocol identifier that identifies a specific protocol e.g. mapping to a single discovery module such as ConcreteScope.NetBtProtocol. or ConcreteScope.ADProtocol an Address optional identifier that specifies a server to which to direct operations on this scope such as http intra uddi uddi inquire.asm for an intranet UDDI server and a path identifier optional that identifies a partition of the module s namespace such as an LDAP search base which could be set to CN joe dev CN Computers DC corp DC fabrikam DC com or a UPnPv2 scope name.

The service discovery request API passes concrete scopes to modules. The service discovery request API does not preclude modules from performing additional indirection on concrete scopes such as e.g. transmitting the concrete scope over the wire to a second machine and passing the concrete scope to a corresponding API on that second machine.

An abstract scope is a moniker for one or more concrete scopes and possibly further abstract scopes. Abstract scopes provide a mechanism for targeting a query across a logical predefined or configured concrete scope collection. This provides an additional abstraction that allows the developer to target for example an enterprise scope without requiring explicit protocol address and connection details for particular directory servers.

The mapping of abstract scopes to concrete scopes is machine wide and configurable. For example an abstract scope AbstractScope.Enterprise might map to include both of the concrete scopes in Table 1.

Abstract scopes provide a higher level hierarchical abstraction over and above concrete scopes. Abstract scopes are configured to include the concrete or abstract scopes that make them up. This scope mapping will be available to system administrators who can be able to configure exactly how for example the AbstractScope.EnterpriseScope should be resolved.

Both concrete and abstract scopes can be used by a user of the service discovery API . In the case where an abstract scope is provided the service discovery API will resolve this down through the hierarchy to a number of concrete scopes.

Abstract scopes allow developers of application programs to work at a relatively high level and include scope identifying terms such as AbstractScope.Enterprise in code. In this way for example the developer is not required to hardcode the specifics of a particular UDDI server into his code. This abstraction provides for greater reuse and portability of code. The same piece of code can be used in a variety of enterprise environments without change or recompilation. Only the abstract scope configuration would change between environments.

There may be multiple hierarchies of abstract to concrete scope mappings. In AbstractScope.LocalMachine does not map up into AbstractScope.All even though all of its constituents are included.

In an exemplary implementation the scope map configuration may be manipulated through group policy by a system administrator to control the use of the service discover API in the enterprise. By way of example an administrator could define one or more abstract scopes available in the enterprise computing environment or in a portion of the enterprise computing environment. This permits a system administrator to regulate the discovery and use of resources by applications.

An application developer can select appropriate Scope and Filter expression which may then be set as properties on a service finder object. The application can then use the FindOne or FindAll methods to execute a discovery request. The FindAll method returns all services matching the supplied criteria whereas the FindOne method returns a single matching service. The methods may be executed using a synchronous or an asynchronous calling pattern.

Assuming that there are services that match the provided filter within the specified scope the FindOne or FindAll methods will return one or a collection of service entry objects. The service entry object is an abstraction over the various representations of services that the underlying protocols can provide. Each service entry object corresponds to a single instance of a service and as such offers descriptive and identifying properties including those set forth in Table 2.

A public void Save function is provided to create or update the service entry representation in the scopes specified in the scopes collection.

A public void Delete method removes this ServiceEntry object from the scopes specified in the Scopes property. An exception will be thrown if the service is not already published.

As described briefly above the discovery persistence service manages a persistent data store for service information. Periodically or at predetermined events such as startup the discovery persistence service registers to receive ad hoc device service announcements. As an example when a new UPnP device is introduced it will generate a device announcement that will be handled by the UPnP protocol module. This module will then surface details of that event the device and its services to the discovery persistence service through the service discovery API .

Using its persistent data store the discovery persistence service then determines whether this is a new device service or a returning device service. If it is a new device service the details of the device and its services will be registered in the persistent data store. When another consumer of the service discovery API then attempts to find services the service discovery API will be able to return services for ad hoc devices services even if the devices are not currently available. For the above example in the case where the device service is currently available depending upon the scope specified both the UPnP protocol module and the persistent data store module may return results for the device. In addition to UPnP this functionality applies to other ad hoc discovery mechanisms.

Thus the discovery persistence service the service discovery API and the local database store provide a layer of abstraction over the various low level protocols used for device and service discovery. This additional layer of abstraction establishes a common and improved search semantic that application developers may use in developing applications.

In addition the discovery persistence service the service discovery API and the local database store provide a consolidated discovery model for services and devices on a local machine a home network s an enterprise network s and the internet. Thus application developers can discover services in a wide variety of locations by writing to a single consistent API.

Although the described arrangements have been described in language specific to structural features and or methodological operations it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or operations described. Rather the specific features and operations are disclosed as preferred forms of implementing the claimed present subject matter.

