---

title: Server reachability detection
abstract: An application attempts to use a first protocol stack to send a first message to a server. After attempting to send the first message to the server, the application attempts to use a second protocol stack to send a second message to the server. After attempting to send the second message to the server, the application performs a timeout activity before a timeout period for the second message expires when the first message timed out. Alternatively, when the timeout period for the second message expires and the first message did not time out, the application performs the timeout activity. When the client device received a response to the second message from the server before the timeout period for the second message expires, the application performs a different activity.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08407530&OS=08407530&RS=08407530
owner: Microsoft Corporation
number: 08407530
owner_city: Redmond
owner_country: US
publication_date: 20100624
---
Various types of resources can be stored on servers. Client devices communicate with the servers to access such resources. For example a server can store word processor documents. In this example a client device can retrieve word processor documents from the server and store documents back to the server.

A server may become unreachable to a client device. When the server is unreachable by the client device the client device does not receive messages from the server. A server may become unreachable by the client device for a variety of reasons. For example a server may become unreachable by the client device when the server fails when a network connection fails when the client device becomes disconnected from a network or when other events occur.

An application operating on a client device can use a protocol stack to communicate with a server. When the server is reachable by the client device the protocol stack provides data to the application in response to requests by the application. When a server becomes unreachable by the client device the protocol stack does not receive responses from the server. Hence when the protocol stack does not receive a response from the server within a given timeout period the protocol stack provides an error to the application. In some instances the application is not responsive to user input while the application is waiting for responses from the protocol stack. Consequently when the server becomes unreachable the user may be forced to wait for the given timeout period before the application again becomes responsive to user input.

In some circumstances the application uses multiple protocol stacks to communicate with the server. Furthermore the application can be unresponsive to user input when waiting for responses from each of these multiple protocol stacks. Consequently the user may be forced to wait for the expiration of the timeout periods for each of the multiple protocol stacks when the server becomes unreachable to the client device. Being forced to wait in this manner can be annoying to the user and decrease productivity. The application can be unresponsive during this time thereby preventing the user from interacting with the application or using the application to do work.

An application attempts to use a given protocol stack to communicate with a server. Subsequently the application attempts to use another protocol stack to communicate with the server. If the server was reachable when the application attempted to use the given protocol stack to communicate with the server the application performs a timeout activity after waiting for a timeout period to expire. If the server was unreachable when the application attempted to use the given protocol stack to communicate with the server the application performs the timeout activity without waiting for the timeout period to expire.

This summary is provided to introduce a selection of concepts. These concepts are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is this summary intended as an aid in determining the scope of the claimed subject matter.

The server is a computing system that stores documents. In various embodiments the server can be implemented in various ways. For example in some embodiments the server can be implemented using MICROSOFT SHAREPOINT server software. The server can store various types of documents. For example the server can store word processor documents spreadsheet documents note documents slide presentation documents web page documents desktop publishing documents project design documents diagram documents image documents and other types of documents.

A user uses the client device to retrieve and work on documents stored by the server . Furthermore in some embodiments the user can use the client device to create new documents and to store the new documents at the server . To help the user retrieve generate and store documents the client device provides an application. For example the client device can provide a word processing application such as the MICROSOFT WORD word processing document to help the user retrieve generate and store word processor documents. In another example the client device can provide a spreadsheet application such as the MICROSOFT EXCEL spreadsheet application to help the user retrieve generate and store spreadsheet documents.

To retrieve documents stored by the server and to store documents to the server the client device communicates with the server via the network . In particular the application provided by the client device uses multiple protocol stacks to communicate with the server . A protocol stack is a set of communications protocols that work together to enable communication on a network. A communications protocol is a set of rules or standards designed to enable computers to connect with one another and to exchange information. Example types of communications protocols include the Hypertext Transfer Protocol HTTP the File Transfer Protocol FTP the SOAP protocol and so on.

Under certain circumstances the server can become unreachable by the client device . When the server is unreachable by the client device the client device and the server are unable to exchange messages. Consequently when the server becomes unreachable by the client device the client device does not receive messages from the server in response to messages sent by the client device to the server . In other words the client device sends out a message to the server but the client device does not receive a response message back from the server .

The server can become unreachable by the client device for a variety of reasons. For example the server can become unreachable by the client device when the user unplugs a network cable from the client device . In another example the server can become unreachable by the client device when the server crashes. In yet another example the server can become unreachable by the client device when the client device moves outside the range of a wireless network access point through which the client device is communicating with the server .

The client device can communicate with the server using multiple protocol stacks. For example the client device can communicate with the server using a protocol stack that includes HTTP and a protocol stack that includes SOAP. If the client device does not receive a response message from the server in response to a request message generated by one of the protocol stacks the client device determines that the server is unreachable by the client device . The client device uses the knowledge that the server is unreachable at times when the client device would use other protocol stacks to communicate with the server .

If an attempt by the application to communicate with the server using a first one of the protocol stacks times out the client device can perform a timeout activity without waiting for a timeout period to expire when the client device reaches a point where the application would attempt to communicate with the server using the first protocol stack or a second one of the protocol stacks. To elaborate the client device may reach a point in a program that instructs the client device to use a given protocol stack to communicate with the server . The client device can perform various activities if the client device is able to successfully use the given protocol stack to communicate with the server . For example the client device can display a document stored by the server when the server is reachable. In another example the client device can save a document to the server when the server is reachable.

However the client device performs a timeout activity if the server is unreachable. In various embodiments the client device can perform various timeout activities. For example the client device can open a locally stored document instead of a remotely stored document when the server is unreachable. In another example the client device can display an error message to the user when the server is unreachable.

When the server is unreachable but the client device has not previously determined that the server is unreachable the client device uses the given protocol stack to generate a message and to send this message to the server . The client device then waits for a timeout period to expire after sending the message before performing the timeout activity. For example if the client device does not receive a response to the message from the server within one minute the client device performs the timeout activity.

However when the client device has previously determined that the server is unreachable the chances of the client device receiving a response to the message are small. Accordingly when the client device has previously determined that the server is unreachable the client device does not need to generate or send the message to the server . Furthermore when the client device has previously determined that the server is unreachable the client device does not need to wait for the timeout period to expire before performing the timeout activity. In this way the client device does not waste time by waiting for the message to time out when the client device already has the knowledge that the server is unreachable.

As illustrated in the example of the client device includes a data storage system a processing system a network interface a video adapter and an input interface . It should be appreciated that the client device can contain many other devices modules systems interfaces and other components. Such other components are omitted from the example of for the sake of clarity.

The data storage system is a set of one or more computer readable storage media. A computer readable storage medium is a physical device or article of manufacture that is capable of storing computer readable information. The processing system is a system comprising one or more processing units. A processing unit is an integrated circuit or other type of device that executes computer readable instructions. The network interface is a component that enables the client device to communicate with other computing devices via a network. The video adapter is a component that enables the client device to generate a video signal sent to a device e.g. a monitor that displays video represented by the video signal. The input interface is a component that enables the user to provide input to the client device . For example the input interface can be a component that enables the user to provide keyboard and or pointer input to the client device .

As illustrated in the example of the data storage system stores computer readable instructions and other data that when executed or otherwise used by the processing system cause the client device to provide an application a set of protocol stacks A through N a network status module NSM a sync module . In addition the data storage system stores an unreachable servers list and a local cache . The protocol stacks A through N are collectively referred to herein as the protocol stacks . It should be appreciated that the data storage system can store computer readable instructions that when executed by the processing system cause the client device to provide other functionality. Furthermore it should be appreciated that the data storage system can store data other than illustrated in the example of .

The application uses one or more of the protocol stacks to communicate with the server . In various embodiments the application can communicate with the server for a variety of reasons. For example the application can be a word processing application. In this example the application can communicate with the server to retrieve a document from the server and to store documents to the server . In another example the application is a video game application. In this example the application can communicate with the server to obtain mission data and to upload mission results.

In some embodiments where the application enables the user to work with a document stored by the server the application obtains a copy of the document from the server and stores the copy of the document in the local cache . In this specification the copy of the document in the local cache is said to correspond to the copy of the document stored by the server . Documents stored in the local cache are referred to herein as local documents. Documents stored by the server are referred to herein as server documents. After the application stores a local document in the local cache the application can modify the local document in the local cache even if the server becomes unreachable by the client device . When the user is working with the local document without maintaining synchronization between the local document and the corresponding server document the user is working offline with regard to the local document.

Each of the protocol stacks provides a software infrastructure for a different protocol stack. As also discussed elsewhere in this specification a protocol stack is a set of communications protocols that work together to enable communication on a network. In various embodiments the protocol stacks provide the software infrastructure for protocol stacks that include various communications protocols. For example the protocol stack A can provide a software infrastructure for a protocol stack that includes the HTTP protocol. In this example the protocol stack B not shown can provide a software infrastructure for a protocol stack that includes the WebDAV protocol. Furthermore in this example the protocol stack C not shown can provide a software infrastructure for a protocol stack that includes the Web DAV protocol and other protocols.

In some embodiments each of the protocol stacks used by the application to communicate with the server establish a session with the server . The protocol stacks then use these sessions to exchange messages with the server . A session is a semi permanent interactive information interchange. The protocol stacks can maintain state information in such sessions.

The protocol stacks receive requests from the application to send data. In response to such requests the protocol stacks provide server status requests to the NSM . The server status requests are requests for server status indicators for servers. The server status indicators indicate whether the servers are listed in the unreachable servers list . Servers that are listed in the unreachable servers list are referred to herein as listed servers. In some embodiments each of the servers listed in the unreachable servers list in uniquely identified. For instance each of the servers listed in the unreachable servers list can be associated with a Uniform Resource Identifier URI or a Uniform Resource Locator URL . The NSM uses the unreachable servers list to provide appropriate server status indicators in response to the server status requests.

If one of the protocol stacks receives a server status indicator that indicates that a server is on the unreachable servers list the protocol stack provides a timeout stack response to the application without waiting for a timeout period to expire. The timeout stack response comprises a timeout error. If one of the protocol stacks receives a status indicator that indicates that a server is not on the unreachable servers list the protocol stack generates and sends a message to the server. If the protocol stack receives a response from the server the protocol stack provides a stack response to the application . This stack response can comprise data included in the message received from the server. Otherwise if the protocol stack fails to receive a response from the server within a timeout period the protocol stack instructs the NSM to add the server to the unreachable servers list and then provides a timeout stack response to the application .

The NSM can test the servers listed on the unreachable servers list to determine whether the servers are again reachable by the client device . If the NSM determines that a server listed on the unreachable servers list is again reachable by the client device the NSM removes the server from the unreachable servers list . Furthermore the application the sync module and or other components of the NSM can remove servers from the unreachable servers list in response to input from the user .

In some embodiments the NSM is associated exclusively with the application . For example in some embodiments the NSM is instantiated by the application when the application starts. Furthermore in some embodiments the NSM is terminated when the application shuts down.

Although not illustrated in the example of the client device can provide multiple applications. For example the client device can provide a word processing application and a spreadsheet application. In some embodiments these applications are associated with their own NSMs. The NSMs operate in a similar manner to the NSM discussed in this specification. Each of the NSMs uses the same unreachable servers list to provide appropriate server status indicators to the protocol stacks . Furthermore each of the NSMs adds and removes servers from the unreachable servers list . Because each of the NSMs use the unreachable servers list if one of the NSMs adds a given server to the unreachable servers list another one of the NSMs can provide a server status indicator that indicates that the given server is unreachable. In this way if a protocol stack associated with one application determines that a given server did not respond to a request within a timeout period that protocol stack or another protocol stack associated with another application can return a timeout error to the other application without waiting for another timeout period to expire.

The user may use the application to work offline with one or more documents associated with a server that is unreachable by the client device . Furthermore the user may close the application before the server becomes reachable again by the client device . Because the NSM is associated with the application the NSM also closes when the application closes. However the unreachable servers list is independent of the application . Hence servers can remain listed on the unreachable servers list after the application and the NSM close. Keeping servers listed on the unreachable servers list allows NSMs used by other applications to determine which servers are unreachable. However when there are no NSMs testing whether listed servers are reachable some of the servers could remain listed on the unreachable servers list even though these servers are reachable by the client device . The sync module tests listed servers whose reachability status is not being tested by NSMs to determine whether such listed servers are again reachable by the client device .

In response to receiving the input from the user to start the communication operation the application provides a stack request to one of the protocol stacks . For ease of explanation this specification assumes that the application provides a stack request to the protocol stack A in step . Furthermore for ease of explanation the stack request provided to the protocol stack A is referred to herein as the first stack request. The first stack request comprises a request to the protocol stack A to attempt to communicate with the server . For example the first stack request can be a request to retrieve information about folders maintained by the server . By sending the stack request to the protocol stack A the application is attempting to use the protocol stack A to send the message to the server .

After providing the first stack request to the protocol stack A the application receives a stack response from the protocol stack A . In this way the application receives the stack response from the protocol stack A in response to the attempt to use the protocol stack A to send the message to the server . For ease of explanation the stack response received from the protocol stack A is referred to herein as the first stack response. The first stack response can include various types of data. For example the first stack response can include information about folders maintained by the server . Alternately the first stack response can indicate that a connection to the server timed out.

In some embodiments the actions performed by the application depend on the content of the first stack response. Consequently in such embodiments the application may need to wait to receive the first stack response before taking any further action. In some instances the application is not responsive to input from the user while the application is waiting to receive the first stack response. In other words the application can hang while the application is waiting to receive the first stack response from the protocol stack A.

Hence after the application receives the first stack response the application determines whether the first stack response indicates that the first stack request was successful . In other words the application uses the first stack response to determine whether the attempt to communicate with the server using the protocol stack A was successful. In various embodiments the application can determine that the first stack request was successful in various ways. For example the application can determine that the first stack request was successful when the first stack response includes a status code indicating that the first stack request was successful. In another example the application can determine that the first stack request was unsuccessful when the first stack response includes an error code or an error message indicating that the first stack request was not successful.

The first stack request can be unsuccessful for a variety of reasons. For example the first stack request could fail because the first stack request relates to a resource that is not hosted by the server . In another example the first stack request could fail because the user is not allowed to access the first stack request without providing appropriate credentials. In yet another example the first stack request could fail because the server is not reachable by the client device .

If the application determines that the first stack request was successful YES of the application can then process the data in the first stack response . The application can process the data in the first stack response in various ways. For example the first stack response can contain data regarding the folders maintained by the server . In this example the application can process the data in the first stack response by displaying the information about the folders maintained by the server to the user .

The application also sends a stack request to another one of the protocol stacks . For ease of explanation this specification assumes that the application provides a stack request to the protocol stack B in step . Furthermore for ease of explanation the stack request provided to the protocol stack B is referred to as the second stack request. The second stack request comprises a request to the protocol stack B to attempt to communicate with the server . For example the second stack request can be a request to retrieve information about an individual document stored by the server . By sending the second stack request to the protocol stack B the application is attempting to use the protocol stack B to send the message to the server .

Subsequently the application receives a stack response from the protocol stack B . In this way the application receives the stack response from the protocol stack B in response to the attempt to use the protocol stack B to send the message to the server . For ease of explanation the stack response received from the protocol stack B is referred to herein as the second stack response. In some embodiments the actions performed by the application depend on the content of the second stack response. Consequently in such embodiments the application may need to wait to receive the second stack response before taking any further action. As a result the application can become unresponsive to input from the user while the application is waiting to receive the second stack response.

When the application receives the second stack response the application determines whether the second stack response indicates that the second stack request was successful . In other words the application uses the second stack response to determine whether the attempt to communicate with the server using the protocol stack B was successful. If the application determines that the second stack response indicates that the second stack request was successful YES of the application can then perform some activity . In various embodiments the application can perform various activities. The application can display the information about the documents in the particular folder to the user . In another example the application can retrieve a copy of a server document from the server .

However if the application determines that the first stack response does not indicate that the first stack request was successful NO of or if the application determines that the second stack response does not indicate that the second stack request was successful NO of the application performs a timeout activity . In various embodiments the application can perform various timeout activities. For example the application can notify the user that a communication error has occurred. In another example if the first or second responses are not successful the application allows the user to work on a document offline. When the user is working with a document offline the application manipulates a local document stored in the local cache . For example the communication operation can be an operation to open a document stored at the server . In this example the application attempts to identify and open a document in the local cache that corresponds to the document stored at the server . In another example the communication operation can be an operation to upload a document stored in the local cache to the server . In this example the user can continue working on the document offline and the document is stored to the server at a later time.

It should be appreciated that the communication operation is merely an example. In other embodiments the application can perform more complex operations involving multiple ones of the protocol stacks . For example the communication operation can be an operation to open a document stored by the server . In this example the application can use one of the protocol stacks to send one or more Web DAV protocol requests to the server . The Web DAV protocol requests retrieve information that describes a folder hierarchy maintained by the server . The application can then use another one of the protocol stacks to send one or more Web View protocol requests to the server . The Web View protocol requests retrieve data about documents in a particular one of the folders. The application can then use yet another one of the protocol stacks to send one or more FrontPage RPC FPRPC protocol requests to the server . The FPRPC protocol requests retrieve metadata regarding a particular one of the documents. Next the application can use yet another one of the protocol stacks to send one or more Web DAV protocol requests to the server . These Web DAV protocol requests retrieve a file from the server . In other embodiments the application uses a protocol stack to send one or more MS FSSHTTP protocol requests to the server to retrieve the document instead of the Web DAV protocol requests.

In the example of the application sends the second stack request to the protocol stack B. However it should be appreciated that in some cases the application can send the second stack request to the protocol stack A. In other words the application can send the first and second stack requests to the same protocol stack. In such cases the application would not need to wait for the timeout period to expire after providing the second stack request to the protocol stack A if the first stack response was not successful. In other words if the attempt by the application to communicate with the server using a first protocol stack times out the application performs a timeout activity without waiting for a timeout period to expire when the application reaches a point where the application would attempt to communicate with the server using the first protocol stack again.

As illustrated in the example of the operation begins when the protocol stack A receives a stack request from the application to send data to a server . For ease of explanation this specification describes the example of with the assumption that the protocol stack A receives a stack request from the application to send data to the server . In various embodiments the protocol stack A can receive the request from the application in various ways. For example in some embodiments the application can provide the stack request to the protocol stack A by invoking a method of an Application Programming Interface API provided by the protocol stack A an operating system of the client device or another component provided by the client device . In other embodiments the application can use a callback to provide the stack request to the protocol stack A.

After receiving the stack request from the application the protocol stack A sends a server status request to the NSM . The server status request is a request for a server status indicator for the server . The server status indicator indicates whether the server is listed in the unreachable servers list .

In various embodiments the protocol stack A provides the server status request to the NSM in various ways. For example in some cases the protocol stack A provides the server status request to the NSM by invoking one or more methods of an API provided by the NSM the operating system of the client device or another component provided by the client device . In other cases the NSM registers a callback with the protocol stack A when the NSM is initialized. In such embodiments the protocol stack A uses the callback to provide the server status request to the NSM . Furthermore in some embodiments different ones of the protocol stacks can provide the server status requests to the NSM in different ways. For example one of the protocol stacks associated with the HTTP protocol can use an API to provide server status requests to the NSM and one of the protocol stacks associated with the Web DAV protocol can use the callback technique to provide server status requests to the NSM .

After sending the server status request to the NSM the protocol stack A receives a server status indicator for the server from the NSM . The server status indicator for the server indicates whether the server is listed on the unreachable servers list . In response to receiving the server status indicator for the server the protocol stack A determines whether the server status indicator for the server indicates that the server is listed on the unreachable servers list .

If the server status indicator for the server indicates that the server is listed in the unreachable servers list YES of the protocol stack A sends a timeout error message to the application . The timeout error message indicates to the application that the attempt to communicate with the server failed because the client device did not receive a response from the server within a timeout period. When the server status indicator for the server indicates that the server is listed in the unreachable servers list the protocol stack A does not wait for the timeout period to expire before sending the timeout error message to the application .

If the server status indicator for the server indicates that the server is not listed in the unreachable servers list NO of the protocol stack A generates at least one request message . Various ones of the protocol stacks can generate various types of request messages. For example the protocol stack A can generate a HTTP request message that is encapsulated within one or more TCP frames that are encapsulated within one or more IP packets. In another example the protocol stack B can generate a FTP request that is encapsulated within one or more TCP frames that are encapsulated within one or more IP packets. Furthermore the protocol stacks can contain different data depending on data in the stack request from the application on environmental variables and or on other factors. After generating the request message the protocol stack A sends the request message to the server .

Later the protocol stack A determines whether the client device received a response message from the server within a timeout period . In various embodiments the timeout period can have various lengths. For example in some embodiments the timeout period can be one minute. In another example the timeout period can be thirty seconds. Furthermore in some embodiments different ones of the protocol stacks can use different timeout periods. For example the protocol stack A can use a timeout period of ninety seconds and the protocol stack B can use a timeout period of fifty seconds. Furthermore in some embodiments the timeout periods used by one or more of the protocol stacks are user configurable.

If the protocol stack A received a response message from the server within the timeout period YES of the protocol stack A generates a stack response containing data in the response and provides the stack response to the application . For example if the response message contains data representing a list of documents the protocol stack A can generate a stack response containing the data representing the list of documents. Alternatively the response message can contain data indicating that the request message was not successful. For example the response message can contain data indicating that the user does not have authorization to access a given resource requested by the request message. In this example the protocol stack A generates a stack response comprising an error message indicating that the user is not authorized to access the given resource.

If the client device did not receive a response message from the server within the timeout period NO of the protocol stack A requests the NSM to add the server to the unreachable servers list . The protocol stack A then generates stack response comprising a timeout error message and provides the stack response to the application . The timeout error message indicates to the application that an attempt to communicate with the server failed because the client device did not receive a response message from the server within the timeout period.

When the NSM receives the server status request the NSM also receives information that identifies a server. In various embodiments the NSM receives information that identifies the server in various ways. For example the server status request can include a Uniform Resource Identifier URI or a Uniform Resource Locator URL of the server. In this example the URI or URL can specify a protocol a port number and or other information about the server in addition to a domain name and path at the server. For ease of explanation it is assumed in this description of that the identified server is the server .

In response to the server status request the NSM determines whether the server is listed in the unreachable servers list . If the server is listed in the unreachable servers list YES of the NSM provides a server status indicator to the protocol stack A indicating that the server is listed in the unreachable servers list . Otherwise if the server is not listed in the unreachable servers list NO of the NSM provides a server status indicator to the protocol stack A indicating that the server is not listed in the unreachable servers list .

The NSM then updates the unreachable servers list to include the server . In various embodiments the NSM updates the unreachable servers list to include the server in various ways. For example when the unreachable servers list is in a registry of the client device the NSM updates the unreachable servers list to include the server by adding a new registry entry to the registry.

Next the NSM starts a retry timer for the server . The retry timer for the server generates an event received by the NSM when a given amount of time has expired after the NSM starts the retry timer. In various embodiments the retry timer for the server generates an event when various amounts of time have expired. For example the retry timer for the server can generate an event when five minutes have expired after the NSM starts the retry timer. In another example the retry timer for the server can generate an event when seven minutes have expired after the NSM starts the retry timer. Furthermore in some embodiments the amount of time that passes before the retry timer generates an event can differ for different servers for different applications and or for different ones of the protocol stacks . Moreover in some embodiments the amount of time that passes before the retry timer generates an event can be user configurable.

When the NSM receives the event indicating that the retry timer for the server has expired the NSM determines whether the client device currently has any network connections . In other words the NSM determines whether the client device is currently able to communicate with any other computing device through a communications network. In various embodiments the NSM determines whether the client device currently has any network connections in various ways. For example the NSM can determine whether the client device currently has any network connections by invoking one or more methods of an API provided by an operating system of the client device .

If the client device currently has no network connections NO of the NSM restarts the retry timer for the server . The NSM restarts the retry timer for the server when the client device currently has no network connections because when the client device currently has no network connections there is no possibility that the server is reachable by the client device . Hence there is no need to attempt to communicate with the server to determine that the server is still unreachable by the client device .

On the other hand if the client device has one or more network connections YES of the NSM sends a test message to the server . In various embodiments the NSM sends various types of test messages to the server . For example in some embodiments the NSM sends a HTTP HEAD request to the server . The Internet Engineering Task Force IETF RFC 2616 defines the HTTP HEAD request. The HTTP HEAD request can be used for obtaining metadata about a resource indicated by the HTTP HEAD request without transferring the body of the resource to the client. In this example the NSM sends an HTTP HEAD request to the server because many servers respond to HTTP HEAD requests and because most the HTTP status codes in HTTP responses to HTTP HEAD requests indicate whether servers are reachable. The use of HTTP HEAD requests can be more effective in determining whether servers are reachable than the use of Internet Control Message Protocol ICMP echo i.e. ping requests because ICMP echo requests are blocked by many servers and firewalls. In other examples the NSM sends other types of requests to the server such as HTTP OPTIONS requests FTP STAT requests and so on.

Subsequently the NSM determines whether the client device received a response from the server within a timeout period . In various embodiments the timeout period has various lengths. For example the timeout period can be sixty seconds ninety seconds or another length of time. Furthermore in some embodiments the timeout period used by the NSM is user configurable. Moreover in some embodiments the timeout periods used by NSMs used by different applications operating on the client device can differ. If the client device did not receive a response from the server within the timeout period the server is still not reachable by the client device . Hence if the client device did not receive a response from the server within the timeout period NO of the NSM restarts the retry timer for the server . The NSM will typically receive a new event from the retry timer when a given amount of time has expired after the NSM restarted the retry timer.

However if the client device received a response from the server within the timeout period the server is reachable again by the client device . Hence if the client device received a response from the server within the timeout period YES of the NSM removes the server from the unreachable servers list .

In response to the network connection event the NSM determines whether each of the listed servers has been tested . A listed server has been tested if the NSM has during the course of the operation sent a test message to the listed server to determine whether the listed server is again reachable by the client device .

If there are one or more listed servers that have not been tested YES of the NSM selects an untested one of the listed servers . In various embodiments the NSM selects an untested one of the listed servers in various ways. For example in some embodiments the NSM selects one of the untested listed servers based on an order of the listed servers in the unreachable servers list . In another example the NSM selects one of the untested listed servers based on amounts of time that the untested listed servers have been listed in the unreachable servers list .

The NSM then sends a message to the selected servers . In various embodiments the NSM sends various types of messages to the selected server. For example in some embodiments the NSM sends a HTTP HEAD request to the selected server.

Subsequently the NSM determines whether the client device received a response from the selected server within a timeout period . In this way the NSM tests whether the selected server is reachable by the client device . In various embodiments the NSM can use various timeout periods. For example the NSM can use timeout periods of thirty seconds sixty seconds ninety seconds or some other length of time. If the client device received a response from the selected server within the timeout period YES of the NSM removes the selected server from the unreachable servers list .

After either removing the selected server from the unreachable servers list or after determining that the client device did not receive a response from the selected server within the timeout period NO of the NSM determines again whether there are one or more listed servers that have not been tested . If there are one or more listed servers that have not been tested the NSM repeats the steps and possibly with regard to another one of the untested listed servers. If the NSM determines that each of the listed servers has been tested YES of the NSM completes the operation .

It should be appreciated that the operation is merely one example. In other embodiments the NSM removes all of the servers from the unreachable servers list when the NSM receives a network connection event. In such embodiments the NSM does not send test messages to the listed servers when the NSM receives the network connection event. Consequently if one of the servers previously listed on the unreachable servers list is still unreachable the application may wait for a timeout period to expire when attempting to communicate with this server.

In various embodiments the sync module receives the application closing event in various ways. For example the sync module establishes an event listener that listens for application closing events. In another example the sync module receives the application closing event when the application sends a sends a message to the sync module via inter process communication. In yet another example the sync module receives the application closing event when the application invokes a method of an API provided by the sync module .

The NSM can monitor the reachability status for one or more listed servers. In other words the NSM can start retry timers for one or more listed servers and test the reachability status of these servers when their retry timers expire. For example the NSM can start a retry timer for a first server and a second server. In this example the NSM can perform the operation illustrated in example of when the retry timer for the first server expires and the retry timer for the second server expires.

In response to this application close event the sync module starts retry timers for servers monitored by the NSM . For example if the NSM monitored the reachability status of a server A and a server B the sync module can start a retry timer for the server A and a retry timer for the server B. 

In some embodiments the retry timers started by the sync module expire after different lengths of time than the retry timers started by the NSM . For example the retry timers started by the sync module can expire after ten minutes whereas the retry timers started by the NSM can expire after five minutes.

In some embodiments the sync module does not start retry timers for each of the servers monitored by the NSM . Rather the sync module can start retry timers for fewer than all of the servers monitored by the NSM . For example in some embodiments the sync module starts a retry timer for a server monitored by the NSM if the number of documents in the local cache associated with the server is exceeds a given threshold or among the highest related to other listed servers having documents in the local cache .

When the retry timer for the server expires the sync module determines whether the client device has any network connections . If the client device has no network connections NO of the sync module restarts the retry timer for the server .

On the other hand if the client device has one or more network connections YES of the sync module sends a message to the server . Subsequently the sync module determines whether the client device has received a response from the server within a timeout period . If the client device does not receive a response from the server within the timeout period NO of the sync module restarts the retry timer for the server .

Otherwise if the client device received a response from the server within the timeout period YES of the sync module removes the server from the unreachable servers list . The sync module then performs any pending document uploads associated with the server . For example the user may have modified a document associated with the server saved the document in the local cache and then closed the application . In this example an upload of the document to the server is pending. Thus in this example the sync module uploads the document to the server when the server becomes reachable.

In addition the sync module prompts the user to indicate whether the user wants to synchronize open local documents with corresponding server documents stored by the server . For example the user may have modified a document associated with the server saved the document in the local cache closed the application and then re opened the local copy of the document in the application . In this example the sync module prompts the user to determine whether the user wants to synchronize the local copy of the document with the server copy of the document. If the user wants to synchronize the local copy of the document with the server copy of the document the sync module can upload the local copy of the document to the server . In this example the sync module can also prompt the user to determine whether to try to synchronize the local copy of the document with the server copy of the document when the user opens the local copy of the document from the local cache . If the user wants to try to synchronize the local copy of the document when the server copy of the document the sync module performs the operation with regard to the server with the exception of step .

When the sync module starts the sync module removes stale entries from the unreachable servers list . The stale entries indicate servers that have been listed in the unreachable servers list for more than a maximum time limit In various embodiments the maximum time limit can be various amounts of time. For example the maximum time limit can be 24 hours. In another example the maximum time limit is 8 hours. Furthermore in some embodiments the maximum time limit is user configurable.

When the client device shuts down there may still be one or more servers listed on the unreachable servers list . While the client device is shut down neither the NSM nor the sync module is able remove entries from the unreachable servers list . Consequently entries can remain on the unreachable servers list for an indefinite amount of time while the client device is shut down. When the client device starts up one or more of the listed servers may in fact be reachable by the client device . However because these servers are listed in the unreachable servers list the network stacks do not attempt to send messages to these servers until the retry periods for these servers expires. Consequently the user may have to wait for a retry period to expire before the client device can communicate with a server even though the server is reachable by the client device . By removing stale entries from the unreachable servers list when the sync module starts the client device can attempt to communicate with the servers without having to wait for the retry periods for the servers to expire.

After removing the stale entries from the unreachable servers list the sync module starts retry timers on one or more of the servers that remain listed on the unreachable servers list .

In different embodiments computing devices are implemented in different ways. For instance in the example of the computing device comprises a memory a processing system a secondary storage device a network interface card a video interface a display device an external component interface an external storage device an input device a printer and a communication medium . In other embodiments computing devices are implemented using more or fewer hardware components. For instance in another example embodiment a computing device does not include a video interface a display device an external storage device or an input device.

The term computer readable media as used herein may include computer storage media. Computer storage media may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. The memory includes one or more computer storage media capable of storing data and or instructions. As used in this document a computer storage medium is a device or article of manufacture that stores data and or software instructions readable by a computing device. In different embodiments the memory is implemented in different ways. For instance in various embodiments the memory is implemented using various types of computer storage media. Example types of computer storage media include but are not limited to dynamic random access memory DRAM double data rate synchronous dynamic random access memory DDR SDRAM reduced latency DRAM DDR2 SDRAM DDR3 SDRAM Rambus RAM solid state memory flash memory read only memory ROM electrically erasable programmable ROM and other types of devices and or articles of manufacture that store data.

The term computer readable media as used herein may also include communication media. Communication media may be embodied by computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may describe a signal that has one or more characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media may include wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media.

The processing system includes one or more physical integrated circuits that selectively execute software instructions. In various embodiments the processing system is implemented in various ways. For instance in one example embodiment the processing system is implemented as one or more processing cores. For instance in this example embodiment the processing system may be implemented as one or more Intel Core 2 microprocessors. In another example embodiment the processing system is implemented as one or more separate microprocessors. In yet another example embodiment the processing system is implemented as an ASIC that provides specific functionality. In yet another example embodiment the processing system provides specific functionality by using an ASIC and by executing software instructions.

In different embodiments the processing system executes software instructions in different instruction sets. For instance in various embodiments the processing system executes software instructions in instruction sets such as the x86 instruction set the POWER instruction set a RISC instruction set the SPARC instruction set the IA 64 instruction set the MIPS instruction set and or other instruction sets.

The secondary storage device includes one or more computer readable data storage media. The secondary storage device stores data and software instructions not directly accessible by the processing system . In other words the processing system performs an I O operation to retrieve data and or software instructions from the secondary storage device . In various embodiments the secondary storage device is implemented by various types of computer readable data storage media. For instance the secondary storage device may be implemented by one or more magnetic disks magnetic tape drives CD ROM discs DVD ROM discs Blu Ray discs solid state memory devices Bernoulli cartridges and or other types of computer readable data storage media.

The network interface card enables the computing device to send data to and receive data from a computer communication network. In different embodiments the network interface card is implemented in different ways. For example in various embodiments the network interface card is implemented as an Ethernet interface a token ring network interface a fiber optic network interface a wireless network interface e.g. WiFi WiMax etc. or another type of network interface.

The video interface enables the computing device to output video information to the display device . In different embodiments the video interface is implemented in different ways. For instance in one example embodiment the video interface is integrated into a motherboard of the computing device . In another example embodiment the video interface is a video expansion card. Example types of video expansion cards include Radeon graphics cards manufactured by Advanced Micro Devices Inc. of Sunnyvale Calif. Geforce graphics cards manufactured by Nvidia Corporation of Santa Clara Calif. and other types of graphics cards.

In various embodiments the display device is implemented as various types of display devices. Example types of display devices include but are not limited to cathode ray tube displays LCD display panels plasma screen display panels touch sensitive display panels LED screens projectors and other types of display devices. In various embodiments the video interface communicates with the display device in various ways. For instance in various embodiments the video interface communicates with the display device via a Universal Serial Bus USB connector a VGA connector a digital visual interface DVI connector an S Video connector a High Definition Multimedia Interface HDMI interface a DisplayPort connector or other types of connectors.

The external component interface enables the computing device to communicate with external devices. In various embodiments the external component interface is implemented in different ways. For instance in one example embodiment the external component interface is a USB interface. In other example embodiments the computing device is a FireWire interface a serial port interface a parallel port interface a PS 2 interface and or another type of interface that enables the computing device to communicate with external components.

In different embodiments the external component interface enables the computing device to communicate with different external components. For instance in the example of the external component interface enables the computing device to communicate with the external storage device the input device and the printer . In other embodiments the external component interface enables the computing device to communicate with more or fewer external components. Other example types of external components include but are not limited to speakers phone charging jacks modems media player docks other computing devices scanners digital cameras a fingerprint reader and other devices that can be connected to the computing device .

The external storage device is an external component comprising one or more computer readable data storage media. Different implementations of the computing device interface with different types of external storage devices. Example types of external storage devices include but are not limited to magnetic tape drives flash memory modules magnetic disk drives optical disc drives flash memory units zip disk drives optical jukeboxes and other types of devices comprising one or more computer readable data storage media. The input device is an external component that provides user input to the computing device . Different implementations of the computing device interface with different types of input devices. Example types of input devices include but are not limited to keyboards mice trackballs stylus input devices key pads microphones joysticks touch sensitive display screens and other types of devices that provide user input to the computing device . The printer is an external device that prints data to paper. Different implementations of the computing device interface with different types of printers. Example types of printers include but are not limited to laser printers ink jet printers photo printers copy machines fax machines receipt printers dot matrix printers or other types of devices that print data to paper.

The communications medium facilitates communication among the hardware components of the computing device . In different embodiments the communications medium facilitates communication among different components of the computing device . For instance in the example of the communications medium facilitates communication among the memory the processing system the secondary storage device the network interface card the video interface and the external component interface . In different implementations of the computing device the communications medium is implemented in different ways. For instance in different implementations of the computing device the communications medium may be implemented as a PCI bus a PCI Express bus an accelerated graphics port AGP bus an Infiniband interconnect a serial Advanced Technology Attachment ATA interconnect a parallel ATA interconnect a Fiber Channel interconnect a USB bus a Small Computing system Interface SCSI interface or another type of communications medium.

The memory stores various types of data and or software instructions. For instance in the example of the memory stores a Basic Input Output System BIOS an operating system application software and program data . The BIOS includes a set of software instructions that when executed by the processing system cause the computing device to boot up. The operating system includes a set of software instructions that when executed by the processing system cause the computing device to provide an operating system that coordinates the activities and sharing of resources of the computing device . Example types of operating systems include but are not limited to Microsoft Windows Linux Unix Apple OS X Apple OS X iPhone Palm webOS Palm OS Google Chrome OS Google Android OS and so on. The application software includes a set of software instructions that when executed by the processing system cause the computing device to provide applications to a user of the computing device . The program data is data generated and or used by the application software .

The various embodiments described above are provided by way of illustration only and should not be construed as limiting. Those skilled in the art will readily recognize various modifications and changes that may be made without following the example embodiments and applications illustrated and described herein. For example the operations shown in the figures are merely examples. In various embodiments similar operations can include more or fewer steps than those shown in the figures. Furthermore in other embodiments similar operations can include the steps of the operations shown in the figures in different orders.

