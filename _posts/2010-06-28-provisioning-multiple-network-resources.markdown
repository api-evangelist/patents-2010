---

title: Provisioning multiple network resources
abstract: A resource provisioning service allows users to provision multiple, different network resources in an atomic manner and with a single call to a resource provisioning service. In some instances, the multiple, different network resources comprise individual types of resources that form a portion of one or more cloud-computing platforms. For instance, one or more entities may host and operate a cloud-computing platform that includes different types of network resources, such a storage service, a load balancing service, a compute service, a security service, or any other similar or different type of network-accessible service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09178766&OS=09178766&RS=09178766
owner: Amazon Technologies, Inc.
number: 09178766
owner_city: Reno
owner_country: US
publication_date: 20100628
---
Large scale network based computing represents a paradigm shift from traditional client server computing relationships. With large scale network based computing platforms e.g. data centers customers are able leverage shared resources on demand by renting resources that are owned by third parties and that reside in the cloud. With these resources customers of the platform are able to launch and maintain large applications without actually owning or servicing the underlying infrastructure necessary for these applications. As such network based computing platforms have expanded the class of individuals and companies able to effectively compete in the realm of computing applications. Despite these advances these individuals and companies may still experience difficulty in working with hosts of these network based computing platforms for the purpose of provisioning the desired resources.

This disclosure describes an architecture and techniques for allowing users to provision multiple different network resources in an atomic manner and with a single call to a resource provisioning service. In some instances the multiple different network resources comprise individual types of resources that form a portion of one or more cloud computing platforms. For instance one or more entities may host and operate a cloud computing platform that includes different types of network resources such a storage service a load balancing service a compute service a security service or any other similar or different type of network accessible service.

In one example a user may desire to launch an application e.g. a web application with use of multiple network resources offered by one or more third party entities. The user may desire a load balancing service to route workload amongst multiple different resources a compute service to host the application and to provide computing capability an online storage service to store client data and a security service to provide security to users of the application. While a single entity may offer and operate each of these network resources multiple different entities may offer and operate one or more of these resources in other implementations.

In either event a resource provisioning service may communicate with the user to provision these multiple different network resources. For instance the user may make an initial request to the provisioning service to provision a stack of multiple network resources. In some instances the request may be based on a template that includes pre populated instructions for provisioning the multiple resources. This template provides the user with a declarative language to author a stack creation request allowing the user to focus on which resources to provision and the interconnection of these resources rather than on how to build these stacks and which application programming interface API calls to invoke. For instance the template may instruct e.g. in extensible markup language XML format JavaScript Object Notation JSON etc. the provisioning service to provision one or more different network resources.

In some instances the user may then alter the instructions in the template to specify particular parameters associated with the resources and may save this template with the changes as a new template. For instance the user may specify a particular desired size of a storage service a number of desired computers of the compute service and the like to create a new template. Furthermore the user may assign a logical name to one or more of the network resources or components of the network resources when creating the new template. The user may also alter the original template in any other way by for example deleting portions of the instructions or adding new instructions to provision even more network resources than the template previously called out to create the new template. In another example the user may also make a call within the template to another template. As such templates may become building blocks for use in creating stacks of multiple different network resources.

When the user is satisfied with the resulting instructions with or without alterations to the template the user provides instructions back to the provisioning service to store the instructions as a new template. For instance the user may provide a text file comprising the new template. This template may comprise instructions in XML or JSON format or in any other suitable format.

After the provisioning service stores the new template the user may then request to create a stack of resources with use of that template or with use of another template . In response the provisioning service may retrieve and parse the template to identify the stack of desired network resources. In one example for instance the provisioning service may identify that the user would like to employ a load balancing service of a particular size a particular number of servers of a compute service a storage service of a particular size and a particular type of security service. In response the provisioning service may attempt to provision each of the requested network resources on behalf of the user. That is the provisioning service may attempt to secure the desired services of the load balancing service the compute service and the like.

Furthermore the provisioning service may attempt to provision at least a portion of the network resources in parallel with one another. For instance the provisioning service may determine dependencies amongst the multiple network resources and may attempt to provision the resources according to these dependencies. The provisioning service may identify implicit dependencies from the text file or the provisioning service may receive explicit dependencies specified by the user.

In some instances the provisioning service attempts to provision atomically the stack of the network resources. That is the provisioning service will consider a stack successfully created when the provisioning service is able to successfully provision each of the requested network resources. In response to successfully provisioning the stack the provisioning service may notify the user of this success. In instances where the provisioning service fails to provision one or more of the requested resources e.g. after repeated tries the provisioning service may deem the provisioning of the stack a failure and may roll back or tear down those requested resources that the provisioning service has successfully provisioned. In addition the provisioning service may notify the user of this failure. As such the user knows that at the time of submitting the request to provision the stack of multiple network resources that either all of the requested resources will be provisioned or none of them will.

The discussion begins with a section entitled Example Architecture that describes an example architecture that may implement the techniques introduced above. Next a section entitled Example Processes follows and describes example processes for provisioning multiple network resources using the described example architecture of . A section entitled Example Resource Provisioning Service and Processes follows describing specific examples of the resource provisioning service described in and processes that the example service may implement for creating deleting and adopting stacks. This section also describes example transitions of internal and external stack state during these processes. Finally the discussion ends with a brief conclusion.

This brief introduction including section titles and corresponding summaries is provided for the reader s convenience and is not intended to limit the scope of the claims nor the proceeding sections. Furthermore the techniques described above and below may be implemented in a number of ways and in a number of contexts. Several example implementations and contexts are provided with reference to the following figures as described below in more detail. However the following implementations and contexts are but a few of many.

The network meanwhile is representative of any one or combination of multiple different types of networks such as the Internet cable networks cellular networks wireless networks and wired networks. The network may be a public or a private network. Furthermore while illustrates several arrows each of the illustrated services may communicate directly or indirectly with one another via the network or via a different network.

In the illustrated example a representative user uses a computing device to access the resource provisioning service to request the provisioning of one or more of the network resources N . For instance the user may desire to launch a web application using cloud based resources. As such the user may send a request to provision multiple resources such as load balancers from a load balancing servers databases from a storage service and the like.

In response to accessing the resource provisioning service and making such a request the resource provisioning service may serve a user interface UI to the computing device of the user . illustrates one example of such a UI. As illustrated the UI includes a first area that allows the user to select a template to use for making a request to provision a stack of a specific set of the resources N . The UI also includes a second area that allows the user to create a name for the stack that is to be created. Finally the example UI includes an icon that when selected sends the request to the resource provisioning service . In response to receiving this request the resource provisioning service may attempt to create the stack of resources specified in the template as described in detail below. While illustrates one example UI other implementations may employ any other similar or different UI.

As illustrated each of the resources N and the resource provisioning service is embodied as one or more servers that collectively have processing and storage capabilities to receive and send requests. These servers may be embodied in any number of ways including as a single server a cluster of servers a server farm or data center and so forth although other server architectures e.g. mainframe may also be used.

The resource provisioning service comprises one or more processors and memory which stores an interface and a template based stack builder . The service also stores or has access to databases and . The interface comprises a network accessible interface that allows users of the user community to access and communicate with the resource provisioning service . For instance users of the user community may make calls into the interface via certain public APIs. In these and other instances users of the user community access the interface for the purpose of requesting to provision one or more of the network resources N .

The template based stack builder meanwhile functions to receive requests from users to create a stack of network resources as described above and to provide an appropriate template to the users based on the requests. For instance in the illustrated example the builder may receive a request to provision a named stack of resources with use of a particular template selected by the user . In response the builder may locate the selected template from the database which may store or otherwise have access to previously created templates. The resource provisioning service users of the user community and or other entities may have previously created some or all of the templates within the database in some instances.

After locating the selected template the builder provides this template to the computing device of the user . This template may comprise pre populated instructions for provisioning a particular set of the network resources N . The user may then use the template in whole or in part to form the actual request for resources. For instance the user may alter certain parameters of the pre populated instructions to specify a size of a requested resource a number of components e.g. computers databases etc. of a requested resource a particular version of a resource or any other parameter. In some instances the user may specify logical names within the template for one or more components of the resource. These logical names comprise names chosen by the user for the convenience of the user when later managing these resources by making status or request calls to the resource provisioning service .

Additionally or alternatively the user may add instructions to the template to call yet another resource s or may remove instructions effective to remove a resource s from being provisioned. After modifying or refraining from modifying the template provided by the service the user submits the altered template for storage by the resource provisioning service as a new template. The user may then send a request to provision the resources as specified by the new template. In some instances the template may form a text file that includes instructions in extensible markup language XML format JavaScript Object Notation JSON format or the like.

Upon receiving a request to provision resources based on a template the builder may retrieve and parse the template e.g. which may be in the form of a text file to determine the identity and parameters e.g. size etc. of the desired resources as well as the order in which to provision these resources. The builder may determine the order based on implicit dependencies gleaned from the actual instructions of the text file and or based on explicit dependencies provided by the user .

After parsing the file the builder may then attempt to provision each of the requested resources on behalf of the user potentially in an atomic manner. In these instances the resource provisioning service attempts to provision each of the requested ones of the network resources N prior to notifying the user. If the resource provisioning service successfully provisions each of the requested resources then the resource provisioning service notifies the user that the service has successfully created the requested stack. The service may also update the database to reflect the newly provisioned stack. Finally the service may charge costs associated with these provisioned resources to an account of the user maintained by the database .

In instances where the builder of the resource provisioning service is unable to successfully provision each requested resource e.g. after multiple retries the service may notify the user that stack creation has failed. In addition the service may roll back or tear down those ones of the requested network resources that the service has successfully provisioned. The service may or may not charge a user account for these successfully provisioned resources.

By operating in this atomic manner the resource provisioning service provides comfort to the user who knows that the service will either fully succeed in provisioning the requested stack of resources or will return to the state of the system prior to receiving the user s request. That is even in the latter instances the user will not be left with a half completed and non functioning stack as the service will roll back each provisioned network resource. In addition to providing this comfort the architecture and the associated techniques allow the user to make a single request to the resource provisioning service rather than multiple requests corresponding to each requested resource. The service further eases this single call by providing a template to the user on which to base the request.

For discussion purposes the process and the other processes is described with reference to the architecture of although other architectures may implement this process.

In this example at the resource provisioning service receives from the computing device of the user a new template from a user that is effective to attempt to provision a stack of multiple different network resources on behalf of the user. For instance the user may have submitted this template via a UI served by the resource provisioning service . Further this template may have been based on a template previously stored by the service. That is the user may have requested and received a template via the UI of modified this template to form a new template and then sent the new template for storage by the service . In some instances the user may request storage of the template via a Register Template call to the resource provisioning service . At the resource provisioning service stores the received template in the database .

At the resource provisioning service receives a request from the user to provision a stack of resources on behalf of the user. In this example the user requests that the service provision the resources in the manner specified by the template stored at . That is at the user may call the template previously created by the user stored by the service . Of course in other instances the user may call a template created by another user of the user community by the resource provisioning service and or by any other entity.

At in this example the resource provisioning service retrieves the template on which the user based his or her request. In this example the user specifies the recently stored template created by the user and hence the service retrieves this template from the database . As discussed above the user may have customized this template. For instance the user may have specified values of certain parameters such as particular versions of the resources sizes of the resources logical names of the resources and the like.

At the resource provisioning service parses the template to identify the requested ones of the network resources N and to identify an order in which to attempt to provision these requested resources. The service may base this order in whole or in part upon implicit and or explicit dependencies. The service may identify the implicit dependencies by analyzing characteristics of the resources that the user requests. The service may identify explicit dependencies in response to receiving these dependencies explicitly from the user . For instance the user may state a desired order in which to attempt to provision the resources in whole or in part.

At the resource provisioning service attempts to provision the requested network resources potentially in the determined order. In this example the user has requested to provision the network resources and N . In some instances the resource provisioning service attempts to provision at least some of these requested resources in parallel.

At the resource provisioning service receives an indication from each of the resources indicating whether or not the service successfully provisioned the respective resource after one or more multiple tries . In this example each of the resources provides an indication of success and as such the resource provisioning service considers the creation of the stack a success. As such the resource provisioning service updates the database to reflect the new stack at . The resource provisioning service may also update the database to associate this stack with the account of the user and to charge the account of the user for the created resources.

Finally at the resource provisioning service provides an indication of success or failure to the user . For instance the resource provisioning service may provide this indication to the computing device or may communicate this indication via another communication channel. In this example the resource provisioning service provides an indication that the service has successfully provisioned each of the requested network resources and N on behalf of the user . In some instances the user may send a query regarding the status of the requested stack creation prior to receiving the indication at . The service may in turn respond to this request informing the user as to whether or not the stack has yet to be successfully created.

The process includes at the resource provisioning service receiving a template from a client computing device and in response the service storing the received template. This template may facilitate provisioning of a stack of network resources. At the resource provisioning service receives a request to provision a stack of network resources with use of the template. In some instances the template and the request may be received simultaneously e.g. the template may comprises the request although they need not. At the resource provisioning service parses the template to identify the resources and at the resource provisioning service attempts to provision each of the identified resources.

At the resource provisioning service determines whether each provisioning attempt has proven successful. If not then the resource provisioning service rolls back each successfully provisioned network resources at . In some instances the service ceases attempting to provision resources as soon as a single resource call fails. In either instance the resource provisioning service also proceeds to notify the requesting user of the failure at . In some instances the resource provisioning service may also charge a user account of the requesting user for the successfully provisioned resources e.g. as soon as the service successfully provisions these resources and without regard as to whether or not the creation of the entire stack succeeds .

If however the resource provisioning service determines that each provisioning attempt has proven successful then the resource provisioning service notifies the requesting user of this success at . At the resource provisioning service may charge a user account of the requesting user for the successfully provisioned resources.

As discussed above the interface is a network facing component that allows users of the user community to call through public APIs. One function of this layer is to accept validate authenticate authorize and route requests to the network resources N . Other functions include throttling request logging and delegation token exchange. The interface may proxy one or more of the following APIs for the network resources N Register Template Describe Templates Delete Template Create Stack Describe Stack Delete Stack Describe Stack Resources Describe Stack Events and Adopt Stack.

The stack builder service meanwhile provides concrete implementations of various APIs fronted by the interface . This service may also provide one or more internal APIs. APIs provided by this service can be classified as template management APIs stack management APIs and audit trail APIs in some instances.

Template management APIs are responsible for the storage and processing of the templates e.g. in the database of . Raw user provided templates are accepted and validated before being transformed into a canonical reduced form for storage alongside the raw original. The stack builder service provides the ability to look up these uploaded templates by name and to mark them as deprecated. Example template management APIs may include Register Template Describe Template and or Delete Template.

Stack management APIs meanwhile are the entry point for initiating stack creation and deletion and obtaining stack description. The stack creation and deletion calls may be handled in an asynchronous manner. That is the stack builder service validates and records user requests for stack creations and deletions while the stack builder daemon asynchronously handles the actual processing of the users intent. Stack management APIs also enable the reading and writing of stack resource data into underlying storage. Users of the user community can request to inspect the logical physical bindings for their stack s resource via these APIs. Similarly when the stack management workflows allocate or de allocate a stack s resources the stack management workflows use the stack management APIs to record update the physical logical mappings. The stack management APIs may include Create Stack Describe Stack Delete Stack Adopt Stack Describe Stack Resources Add Stack Resource Internal APIs and or Delete Stack Resource Internal APIs .

The stack builder service may also maintain audit trail APIs which enable logging of resource creation deletion actions performed on behalf of a user. In some instances each action is logged for the purpose of maintaining a log of costs charged to the each user account in the database . In addition each user of the user community having an account within the database may retrieve the user s log by invoking the Describe Stack Events API. The audit trail APIs may include Describe Stack Event and or Add Stack Event.

The stack builder daemon meanwhile is responsible for integrating the stack management workflows with the job state storage described above. This daemon may periodically check the stack request table for new un started requests and may spawn stack management workflows to handle these requests. The stack builder daemon may also periodically check up on existing stack management workflows and may mark some of these workflows as complete in the job storage records. This may effectively decouple stack management workflows calls from any front end services.

Finally the stack management workflows are responsible for executing various steps for the creation and configuration of network resources N during stack creation as well as during graceful shutdown and termination of network resources N during stack deletion.

At the interface delegates the request to the stack builder service and particularly to an API server of the stack builder service . The stack builder service first validates the stack name to ensure that the chosen name is not a duplicate of another stack by referencing stack resources . The stack builder service then verifies whether the template name is valid by referencing template metadata . If both the stack name and the template name are valid the stack builder service persists stack metadata Namespace StackName TemplateName Status CREATE PENDING in a stack metadata SDB table and a successful reply is sent back to the user .

At The stack builder daemon picks up stacks with Status CREATE PENDING and starts a CreateStack workflow passing the Namespace TemplateID StackID to the created workflow. The daemon then updates the status of those stacks to CREATE IN PROGRESS. The daemon also enters an audit trail entry into an audit trail table indicating that the stack creation is in progress.

At create stack deciders of the CreateStack workflow type periodically poll the SWF for decision events. When one or more of the CreateStack deciders receives the start workflow request from SWF the respective decider starts processing the create workflow request.

At upon receiving the create stack request the CreateStack decider enters an entry into the audit trail table regarding the stack creation.

At the create stack decider contacts the template service e.g. template metadata to obtain the internal representation of the template for the given template ID. Upon obtaining the template the decider computes the order in which to create the resources. This may be based on implicit dependencies from the template or text file or on explicit dependencies specified by the user . Once the decider determines the order of resource creation the decider schedules the first set of CreateResource activities corresponding to the network resources N in the computed list along with configuration metadata captured in the template to successfully create and configure one of the network resources N .

At the CreateResource activities periodically poll the SWF for work. At upon receiving work to create and configure a specific resource from the SWF the CreateResource activity contacts the corresponding network resource to create and configure the resource. Once the create resource call to the resource returns successfully the CreateResource activity indicates to the SWF via the successful completion of the activity that the resource has successful been created. The physical identifier of the resource that was successfully created by the activity may accompany the activity completion indication.

If however the CreateResource activity receives an error failure from the resource the activity reports a failure to the SWF via the activity failed API. The error failure message obtained from the resource by the activity may accompany the activity failed call to the SWF .

At The CreateStack deciders periodically poll the SWF for work. At if one of the CreateStack deciders receives the information indicating that the create resource activity completed successfully then the CreateStack decider updates the binding service with the information regarding the resource that was created. This includes the mapping of logical resource identifier to physical resource identifier and a creation timestamp. The decider also enters an entry into the audit trail table regarding the successful creation of the resource. The decider then schedules a describe resource activity to describe the status of the created resource.

If the decider receives the information that the create resource activity timed out then the decider reschedules the create resource activity for specified number of times with back off Steps may repeat until the activity completes successfully or until the maximum number of retries is reached. If the maximum number of retries for the create resource activity is reached the decider enters a corresponding entry into the audit trail table and initiates the closure of the workflow. If the decider receives the information that the create resource activity failed the decider examines the error code returned by the activity . Based on the error code the decider may handle the error in a fashion similar to an activity timeout and may retry the activity.

Conversely based on the error code the decider may decide not to retry the activity and may instead update the binding service with the information regarding the failure in resource creation. This update may include logging the error messages received by the activity while trying to create the resource entering a corresponding entry into the audit trail table and initiating the closure of the workflow.

When the decider initiates the closure of the workflow the following sequence of steps may be executed. First the decider annotates the workflow using the state field of the workflow record with the CREATE FAILED tag. Once a workflow has been annotated with the CREATE FAILED tag no decider will schedule any more activities for that workflow. Instead once the previously scheduled create resource activities for the workflow have been accounted for e.g. either completed or failed or a maximum number of retries has been reached the decider closes the workflow via the CloseWorkflow SWF API with an error message indicating that the stack could not be created successfully.

At The DescribeResource activities periodically poll the SWF for work. At upon receiving work to describe a specific network resource from the SWF the DescribeResource activity contacts the corresponding network resource to check the status of the resource. If the resource is in active state the activity completes successfully. Otherwise the activity reports the failure to the SWF .

At The CreateStack decider periodically polls the SWF for work. If the CreateStack decider receives the information indicating that the describe resource activity completed successfully the decider enters a corresponding entry into the audit trail table and once again contacts the template service e.g. template metadata to obtain the internal representation of the template. The decider compares the resources described in the template to the resources that have been created obtained from the workflow stack history for the given stack and determines the resources that are yet to be created. If the set of resources to be created is empty which indicates that the stack has been successfully created the decider closes the workflow. If however the resources are yet to be created the decider schedules the next batch of create source activities . The process may repeat steps until the entire stack is built.

At if the decider receives the information indicating that the describe resource activity has timed out or failed the decider reschedules the create resource activity for a specified number of times with back off. The process may repeat steps until the activity completes successfully or the maximum number of retries is reached. If the maximum number of retries for the create resource activity is reached the decider enters a corresponding entry into the audit trail table and initiates the closure of the workflow. The process by which the decider closes the workflow may be the same as the detailed earlier in step .

At the stack builder daemon periodically polls the SWF to check if the workflow is complete for stacks with status CREATE IN PROGRESS. Once the stack builder daemon finds that the stack creation has been successfully completed the stack builder daemon marks the stacks status as CREATE COMPLETE. However if the stack builder daemon observes that the stack creation has failed via the CREATE FIELD tag in the workflow status the daemon marks the stack status as CREATE FAILED. Details of clean up of a failed stack creation are discussed below in the delete stack section. Once the stack creation workflow closes the stack builder daemon enters an entry into the audit trail table regarding the success failure of the stack creation.

At interface delegates the request to the stack builder service where the stack name is validated. The status of the corresponding stack is marked as DELETE PENDING.

At the Stack Builder daemon looks for stacks in DELETE PENDING status and starts a workflow of type DeleteStack by contacting the SWF . Inputs to the workflow include the stackId and the template ID used by the stack. The stacks status in the stack metadata is now updated to DELETE IN PROGRESS. The Stack Builder daemon writes an entry into the audit trail table indicating that the start deletion has started.

At the deciders of the DeleteStack workflow type periodically poll the SWF for decision events. When one or more of the DeleteStack deciders receives the start workflow request from the SWF the decider begins processing the delete stack request.

At upon receiving the delete stack request the decider enters a corresponding entry into the audit trail table . At the decider contacts the template service e.g. the template metadata to obtain the template corresponding to the stack that is being deleted. Upon receiving the template the decider computes the order in which the resources are to be deleted. This may be done based on dependencies that are implicit in the stack and or the template and or based on explicit dependencies that the user provides.

At based on the resource order computed in step the decider contacts the binding service to obtain the physical resource identifier and the resource type of the resources that are not in DELETED state. Upon obtaining the resource type and identifier the decider schedules the appropriate delete resource activity to delete the resource that is part of the given stack. If the decider is unable to find any resource that is not in DELETED state the stack deletion is complete. The decider then closes the workflow.

At The DeleteResource activities periodically poll the SWF for work. At upon receiving work to delete a network resource from the SWF the DeleteResource activity contacts the corresponding network resource to delete the resource. Input to the specific DeleteResource activity includes the physical identifier of the resource to be deleted. Upon submitting a delete request to the resource the DeleteResource activity periodically polls the corresponding resource to check the status of the resource. Once the resource declares that the requested resource has been successfully deleted the activity indicates to the SWF via the successful completion of the activity that the deletion has successfully occurred. If the network returns a particular error type the activity reports a failure and accompanies the error message returned by the resource to the decider along with the ActivityFailed API.

At deciders of of the DeleteStack workflow type periodically poll the SWF for decision events. At upon receiving the information regarding the activity completion the binding service is updated to reflect the deletion of a resource within the stack. The decider enters a corresponding entry into the audit trail table regarding the successful resource deletion. The process may repeat steps until the entire stack is deleted. If the decider receives information that the delete resource activity has timed out or failed the decider reschedules the delete resource activity a specified number of times. If the maximum number of retry attempts has been exceeded the decider updates the status and reason filed of the resources in the binding service to DELETE FAILED and max delete attempt reached. The decider also enters a corresponding entry in the audit trail table and annotates the workflow with the DELETE FAILED tag using the status filed in the workflow metadata.

At the stack builder daemon periodically polls the SWF to check if the workflow is closed for stacks with status DELETE IN PROGRESS. Once it finds that the stack deletion has been successfully completed the stack builder daemon marks the stacks status to DELETE COMPLETE. If the daemon discovers that the workflow has been annotated with the DELETE FAILED tag it updates the stack status to DELETE FAILED.

In some instances the example user may initiate a deletion of a stack while the creation of a stack is in progress and before the stack is fully created. In this instance the resource provisioning service may interpret this as a request to terminate the stack creation. Under this scenario the stack builder service marks the stack status as CREATE CANCEL PENDING. The stack builder daemon scans for stacks in CREATE CANCEL PENDING status and notes into the corresponding create stack workflow requesting the workflow to terminate. The stack builder daemon then updates the stack status to CREATE CANCEL IN PROGRESS.

Upon receiving the note event the CreateStack decider initiates closure of the workflow by waiting for outstanding activities to be accounted for. The procedure for closing the workflow may be the same as the procedure described above in the create stack scenario.

The stack builder daemon periodically polls the SWF to check if the create stack workflow is closed for stacks with status CREATE CANCEL IN PROGRESS. Once the stack builder daemon discovers that the stack creation has been terminated the stack builder daemon marks the stacks status to DELETE PENDING. The process of stack deletion cleans up any resources that were created during stack creation.

At the interface delegates the request to the stack builder service where the stack name is validated e.g. checked for duplicates etc . If the stack name is invalid a fault is returned to the user. The Stack builder service attempts to validate the template name and if the template name is valid the service then validates the contents of the stack binding map to ensure that the template identified by the template name and the binding map are consistent with one another. If the template name is invalid or the template identified by the name and the binding map are inconsistent a fault is returned to the user.

At the stack builder service then invokes the DescribeResource API describing the resources listed in the template to verify that the resource listed in the binding map exists and is owned by the user . If any of the resources listed in the binding map do not exist a fault is returned to the user. The stack builder service creates a unique identifier for the stack and inserts a new entry into the binding service for the newly generated stack identifier with the binding information present in the binding map. The stack builder service also inserts updates the stack metadata table to add update the association between the user provided stack name and the generated stack identifier. The stack builder service also inserts an entry into the audit trail table indicating the adoption of the stack.

The service may also receive a request to delete the stack at while the state is in Create in Progress as shown at . In response the internal stack state will also transition to Create Cancel Pending as shown at .

When a create stack workflow is in progress and no requests to delete the stack are received the service determines whether or not the create stack workflow is successful at . If so then the internal stack state transition to Create Complete at . If not then the internal stack state transitions to Create Failed at . In the former instances the service may receive a request to delete the stack at . In this instance the internal stack state transitions to Delete Pending as shown at .

In instances where the internal stack state becomes Create Failed meanwhile the transition initiates a stack clean up at . Thereafter the internal stack state transitions to Delete Pending as shown at .

Returning to the internal stack state of Create Cancel Pending at the transition notes into the create stack workflow at as discussed above. The internal stack state then transitions to Create Cancel in Progress at . Thereafter the create stack workflow completes at and the stack state is updated to Delete Pending as shown at .

When the internal stack state is Delete Pending a delete stack workflow begins at . As shown at the internal stack state then transitions to Delete in Progress. At the service determines whether or not the delete stack workflow has successfully completed. If so then the internal stack state transitions to Delete Complete at . If not then the internal stack state transitions to Delete Failed at . Thereafter the service may clean up the workflow and may again receive a request to delete the stack at . In response the internal stack state transitions to Delete Pending as shown at .

At the service receives a request to delete the stack. As such the external stack state transitions to Delete in Progress at . At the service determines whether or not the deletion is successful. If so then the external stack state becomes Delete Complete at . If not then the external stack state becomes Delete Failed at . Thereafter the service may again receive a request to delete the stack as shown at .

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as exemplary forms of implementing the claims.

