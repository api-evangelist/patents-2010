---

title: System and method for switching between environments in a multi-environment operating system
abstract: Various embodiments of the present invention provide a mobile computing device that operates multiple, co-existing and independent operating system environments on a common kernel. A booting process for initiating a multiple operating system environment is also provided. Additionally, various embodiments of the present invention include processes for managing a switch between one operating system environment to a second operating system environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08868899&OS=08868899&RS=08868899
owner: Motorola Mobility LLC
number: 08868899
owner_city: Mountain View
owner_country: US
publication_date: 20100719
---
This application claims the benefit of U.S. Provisional Patent Application No. 61 226 955 titled System and Method for Switching Between Environments in a Multi Environment Operating System and filed on Jul. 20 2009.

The present invention relates generally to multi environment operating systems and methods for switching between different operating environments.

Operating systems are designed and typically optimized based on specific applications and user desired performance. It is often desirable to have features of one type of operating system available to another operating system as user preferred programs can be operating system dependant.

General purpose computer operating systems such as Linux and Windows have an extensive set of features such as file systems device drivers applications libraries etc. Such operating systems allow concurrent execution of multiple programs and attempt to optimize the response time also referred to as latency time and CPU usage or load associated to the servicing of the concurrently executing programs. Unfortunately however such operating systems are not generally suitable for embedded real time applications such as for mobile computing devices. Under certain circumstances it would be desirable for a mobile computing device to have the performance associated with a mobile specific embedded operating system and features of a general purpose operating system.

Linux for example is a well known general purpose desktop operating system with many desirable features for modern devices including modern operating systems features numerous development tools networking etc. However Linux was not designed to be an embedded or real time operating system. Many modern devices such as without limitation set top boxes mobile phones and car navigation systems require not only the features of a general purpose operating system such as Linux but also the features of an embedded or real time operating system including real time performance.

Historically running multiple operating environments on a single device has been accomplished through virtualization techniques such as by example VMware VirtualBox QEMU etc. However when using virtualization a complete computer is emulated and one or more software stacks are operated in the emulated computing device. Emulation is wrought with high overhead costs.

In view of the foregoing there is a need for a system implementing a single kernel environment that efficiently and conveniently provides the performance and features of co existing independent operating systems.

In accordance with at least one embodiment of the present invention a method of switching from a first operating environment to a second operating environment of a mobile device is provided. The method includes initiating at least two co existing independent middleware operating environments coupled to a core kernel where the middleware operating environments each have a corresponding application component. Additionally the method includes receiving a mode state initialization change signal based at least in part upon the device operation releasing first operating environment control of the device and initiating second operating environment control of the device.

In accordance with at least one embodiment of the present invention a mobile device operating system having a core kernel configured to interface a device hardware component and a middleware component is provided. The system includes at least two co existing independent middleware operating environments coupled to the core kernel the middleware operating environments each having a corresponding application component.

In accordance with yet another embodiment a mobile computing device having a first independent operating system and a second independent operating system located on a common kernel is provided. The device also includes a processor based at least in part upon computer executable instructions configured to switch primary control of the device between a first operating environment and a second operating environment.

According to another embodiment a method of operating a mobile computing device includes initiating the operating of a mobile device having at least two independent operating systems on a common kernel and identifying a primary and secondary operating system. The method also includes launching a secondary operating system application while the primary operating system has control of the device.

According to another embodiment of the invention a mobile computing device having a memory storage unit coupled to a computer processor is provided. The memory storage unit includes computer executable instructions capable of operating at least two operating system environments on a common kernel

According to yet another alternative embodiment a mobile telephone having a graphical user interface configured to receive and transmit multimedia information is provided. The telephone includes a computing system with a processor coupled to a memory storage unit and a multi environment operating system having a common kernel. The memory storage unit includes computer executable instructions capable of managing resources shared between at least two co existing independent operating system environments.

In accordance with an alternative embodiment the present invention includes a mobile computing device with a computer processor coupled to a computer memory having computer executable instructions configured to initiate an operating system. The device also includes an operating system configured to simultaneously run a standard Linux distribution operating system environment and an Android operating system environment on a single kernel.

According to yet another alternative embodiment the invention includes a mobile device operating system having a core kernel configured to interface a device hardware component and a middleware component. The device also includes a first independent middleware operating environment configured to run JAVA interpreted applications and coupled to the core kernel and a second independent middleware operating environment configured to run native applications and coupled to the core kernel.

It is envisioned that it would be advantageous to have an embedded operating system and a Linux based operating environment communicate directly with a single Linux kernel running directly upon a computing device s hardware.

Referring to a mobile telephone is provided. The telephone includes a GUI and a plurality of data input buttons . The mobile device is selected from the group including but not limited to a mobile personal computer PC a netbook a mobile telephone a laptop computer a handheld computer and a smart phone. Although the device is mobile it is intended to have significant computing power with a processor speed in excess of 500 mHz although slower processors are not excluded. Considering the computing power a user can connect the device to a variety of peripheral devices not shown . The peripheral devices are selected from a group including but not limited to computer monitor a laptop computer a desktop computer a tablet PC and a screen projector.

Now referring to a block diagram of an exemplary operating system OS in communication with a kernel is provided. The OS can be a Linux distribution system a Linux based operating system or a non Linux based operating system. The device hardware is also in communication with the Linux kernel . The operating system includes a first operating system environment and a second operating system environment in communication with a single Linux kernel . By example the second middleware operating system environment is a standard Linux distribution and the first middleware operating system environment is an embedded operating system environment intended for use in mobile devices such as an Android Open Handset Alliance www.openhandsetalliance.com operating system. A Linux distribution is in communication with the Linux kernel which is in communication with the device hardware . The device hardware can be a memory storage device not shown coupled to a processor not shown which stores computer executable instructions which are configured to perform various functions and operations as described herein.

An exemplary operating system includes Ubuntu Canonical Ltd. www.ubuntu.com for the Linux based operating system environment . It is specifically intended that multiple middleware operating system environments co exist independent of the other s . Exemplary environments that can be included in operating system include Android Ubuntu Canonical Ltd. www.ubuntu.com standard Linux based environments Symbian Symbian Foundation Ltd. www.symbian.com and Windows based environments. In an alternative embodiment it is envisioned that greater than two operating system environments are configured to independently co exist on the same core kernel .

Referring to a block diagram of an exemplary operating system is provided. In the present exemplary embodiment the first OS environment is an Android based operating environment and the second OS environment is Linux based. The first operating system environment includes a portal service module a portal activity module a OS services module and an OS applications module . The second operating system environment includes a resource manager an Android in a window AIW module a second OS applications module and a second OS services module .

The AIW module is configured to display a first OS application window on the GUI while the second OS is the primary operating environment.

The portal service module contains a set of instructions configured to allow service for the first OS and directs all communication with the resource manager . While the device is operating the portal service module is preferably running at all times. Additionally the portal service module is connected to activity associated with the portal activity module as well as first OS broadcast events. The portal activity module is an application or set of computer executable instructions which represents a second OS application located on the first OS stack. By example if the second OS is Ubuntu the portal activity module can represent a specific Ubuntu application and when the portal activity module has focus Ubuntu is in view through the GUI . Numerous applications can run simultaneously also referred to as a stack of running applications within any given operating environment. Logically speaking the topmost application is deemed to have focus .

The kernel includes a set of drivers and an AEV module . Included with the drivers are input device drivers for hardware components . The AEV is a kernel module that takes absolute coordinate and keyboard events from AIW and passes them to an event hub.

The co existing environments within operating system communicate with each other. The resource manager which is part of the second OS communicates directly with the portal service module which is part of the first OS . Furthermore the portal service module which is part of the first OS communicates directly with the resource manager . The resource manager is a set of instructions configured to manage the resources shared by the first OS and second OS . The shared resources include display devices input devices power management services and system state information. Furthermore the resource manager is configured to control OS access to the hardware . Additionally the resource manager identifies and controls which OS user interface is displayed through the GUI .

According to the present embodiment the portal service is the source of all communications from the first OS to the resource manager . Additionally the portal service is a sink for all callbacks from the resource manager to the first OS . The resource manager provides a status discoverable application programming interface API to the portal service . This API is configured to be called by the resource manager at any time. The resource manager is configured to obtain and process runtime status which allows for the resource manager to maintain a state machine. For the first OS the portal service provides runtime status to processes that require them. Similarly the portal service requests and receives status updates from processes which provide status information. A similar communication for the second OS is controlled by the resource manager which provides runtime status to the processes that require them. Resource manager requests and receives status updates from various processes that provide status information. Device drivers logically associated with the kernel communicate directly with the resource manager as well as the processes that provide runtime status information. By example the API arbitrates access to user interface devices such as displays touch screens or the GUI . Yet another example the API arbitrates access to power input devices such as batteries and or AC DC wall plugs.

The first OS and the second OS are independent from the other and co exist with respect to the other. Each OS is a fully functioning operating system environment and does not need the other operating system environment to function. The two operating system environments exist on the same device with 100 independence with respect to the other. As identified above the first and second OS do not co exist in a virtualization or emulation scheme but in fact operate on a single kernel . Instead there is runtime co existence in which both OS run in their respective native environments and neither OS is recompiled as there is no need to leverage a common C runtime environment. Applications can be accessed by a user which are coded purely for one or the other OS without an interruption to a user s computing experience.

Referring to a block diagram provides an exemplary co existence scheme for an Android OS and an Ubuntu OS . Each OS operates on a separate runtime environment which provides software services for programs and or processes while the device is operating. Android processes and Android libraries access a Bionic C Library which is optimized and modified specifically for the Android environment. Ubuntu processes and Ubuntu libraries access a Glibc C Library which is a GNU C library used in many standard desktop Linux based systems. Each OS environment runs on its respective C libraries without conflicting another operating environment.

Referring to a more detailed communication path between the first OS and the second OS described in is provided. An inter process communication IPC system is configured to manage the inter environment communication flow between the first OS and the second OS . The portal service communicates with a DBUS Binding which is a software package containing programming language and executable instructions configured to communicate with a DBUS library . The resource manager communicates with a Glib DBUS binding which also is a software package containing programming language and executable instructions configured to communicate with a DBUS library configured for the second OS . Both the first OS DBUS library and the second OS library communicate through a DBUS Daemon which is logically part of the second OS and acts as the communication link between the two operating environments.

Referring to a flow chart representing a boot sequence is provided. The boot sequence includes both common and operating system environment specific steps. The actual boot sequence is dependent upon rules associated with a predetermined device state that dictates the booting sequence. By example if the device is connected to a peripheral device such as a monitor the device state is considered to be in docked mode and the second OS is the default primary environment. Alternatively if the device is not connected to a peripheral device then it is in mobile mode and the first OS is the default primary operating environment. However the secondary operating environment is launched simultaneously with the primary environment and operates in the background in case the device state changes and the secondary environment is switched to become the primary environment. By example when the device is in docked mode and the peripheral device is unplugged there is an automatic switch to mobile mode which results in the secondary environment becoming the primary environment and vice versa.

The boot sequence is initiated at step followed by launching the core Linux kernel at step . A bootloader program initializes prior to launching the kernel. After the Linux kernel is initialized the kernel launches user space scripts at step . The resource manager is launched at step followed by identifying the mode state at step . Once the mode state is identified a reference library is accessed at step to determine the criteria associated with and or dictated by the mode state that is identified. At step the services common to both the first OS and the second OS are launched. The mode state determined at step is referenced at step . If the mobile state is identified then the first OS is the primary operating environment then the first OS initialization scripts are launched at step followed by the second OS initialization scripts launched at step . If the docked state is referenced at step then the second OS is the primary operating environment and then the second OS initialization scripts are launched at step followed by launching the first OS initialization scripts at step . Regardless of which environment is the primary both environments are launched and running before the device is operational at step . Since the common services are launched first at step for all intents and purposes the primary and secondary environments are launched in parallel. However the primary environment specific services based upon the device state are launched immediately before the secondary environment specific services. By separating the common services launch with the environment specific launch the device can be quickly operational with multiple co existing and independent operating environments.

Referring to a flow chart identifying steps for launching a second OS application while the device is in mobile mode and the first OS has primary control. A second OS application Mobile PC is selected at step . Mobile PC is an application in the first OS which provides a full PC view alternatively referred to as a netbook view while the device is operating in mobile mode and the first OS is in primary control. In an alternative embodiment individual applications from the second OS can be listed in a first OS menu and individually launched which can be similar to a netbook view.

The portal service sends a status update communication to the resource manager at step indicating that the portal activity has gained focus. Thereafter the resource manager disables the first OS input and switches a virtual terminal at step . The mobile PC application is displayed on the GUI at step . While operating the mobile PC application an unsolicited event can occur at step or a user solicited event can occur at step . Unsolicited events include time critical and non time critical events. By example a time critical unsolicited event includes a phone call or a scheduled or unscheduled alarm. Furthermore by example a non time critical unsolicited event includes a SMS message an email message or a device update notification. After an event occurs the portal service sends a communication to the resource manager indicating that the portal activity has lost focus at step . At step the resource manager requests the first OS to enable input event flow and switches the virtual terminal. By example the present embodiment includes separate virtual terminals for switching display control between the first OS and the second OS . Broadly speaking a virtual terminal is a Linux application that allows a system user to switch display controls between Windows based view and a system console.

When an unsolicited event occurs or a user selects the Home key at step the portal activity is switched to the background at step while the unsolicited event continues or the user operates another application from the Home menu of the GUI . Alternatively if the user selects the Back key at step then the portal activity exits the application and the device reverts to the idle main menu at step . User initiated events such as selecting the Home key Back key or initiating a new application are exemplary solicited events. When an event occurs a decision is made at step and the first OS is interrupted at step if the event is an unsolicited event. Alternatively if the event is a solicited event such as the user selecting the Home key then the device reverts to the idle main menu at step . After the OS interruption at step the interrupting application exits and the portal activity regains focus at step and the device reverts to step .

In an alternative embodiment the virtual terminal facility is not utilized. Rendering a second OS application while in the mobile mode can be accomplished through a VNC like application. The second OS application such as Ubuntu can be rendered remotely into the VNC client. Additionally this embodiment doesn t take physical display control away from the first OS .

In yet another alternative embodiment non time critical notifications generated by the first OS are identified and listed in a panel within the second OS view. By listing the notifications in a panel the first OS status information is integrated with the second OS view when the second OS is the primary OS. At the user s leisure the panel is accessed to reveal non time critical status notifications. When the panel is engaged the first OS becomes the primary OS and allows the notifications to be viewed. By example the panel can be a pull down list that comes down from a status area with a slide gesture.

Referring to a message sequence chart identifying the steps for launching a second OS application while the first OS has primary control is provided. The sequence chart provides a step wise flow from top to bottom of the signals transmitted between the portal activity module and the resource manager . The portal activity receives a signal to launch the portal and disable the input. The first OS has primary control before signal changes the mode state to the second OS obtaining primary control. Signal is sent from the portal activity to the resource manager which then generates a responsive signal sent to the portal activity indicating that the second OS is the primary OS. Signal is received by the portal activity and enables the input. Signal is sent from the portal activity to the resource manager changing the mode state of from the second OS to the first OS . After receiving signal the resource manager switches the virtual terminal. The resource manager then sends a status update signal to the portal activity indicating that the first OS is primary.

Referring to a flow chart identifying steps associated with switching from a first operating environment to a second operating environment is provided. The device is idle in the mobile mode OS1 at step . At step the device is connected to a docking station or connected to a peripheral device. By example an HDMI connection can be established between the device and a monitor or a television. The resource manager is notified of the updated connection status at step and the first OS is disabled at step in response to the connection status change. The first OS portal switches the shared memory framebuffer at step followed by the resource manager switching the virtual terminal at step . If the Mobile PC application is in view at step then the portal activity exits at step . Alternatively if the Mobile PC application is not in view then the docked mode is enabled at step . In the event that the device state changes at step then the resource manager receives a status state update at step . By example the state of the system changes when a user removes an HDMI cable or similar connector which is used for connecting the device to a peripheral device. Following an event state update the first OS is enabled and the device operates in mobile mode. A framebuffer switch is requested at step and a virtual terminal switch is requested at step both of which are performed by the portal activity . Following step the device reverts to an idle state in the mobile mode .

Referring to a message sequence chart identifying the steps performed when the device transitions from mobile mode OS1 to docked mode OS2 is provided. The device is operating in mobile mode and the first OS is the primary OS. A cable signal is received by the resource manager which indicates that an HDMI or alternate hardwire plug has been attached to the device . The cable signal is an exemplary mode state initialization change signal. In an alternative embodiment the plug can be wireless communication between the device and a peripheral device and disabling the wireless communication would cause a mode state initialization change signal to be generated. A sequence of signals transitioning the device from mobile mode to docked mode is initiated. Signal is sent from the resource manager to the portal activity indicating a mode status transition and disabling the main data input. The portal activity sends signal to the resource manager identifying the second OS is now primary and switching the virtual terminal. Signal is sent from the resource manager to the portal activity identifying the second OS as the primary and has taken ownership of the framebuffer. A mode state change confirmation signal is sent from the portal activity to the resource manager identifying that the device is now in docked mode and that the second OS is the primary OS. A system mode update signal is sent from the resource manager to AIW .

Referring to a message sequence chart identifying the steps performed when the device transitions from docked mode OS2 to mobile mode OS1 is provided. A cable signal is received by the resource manager which indicates that an HDMI or alternate hardwire plug has been removed from the device . Removal of the plug indicates that a peripheral device not shown is no longer in communication with the device . In an alternative embodiment the plug can be wireless communication between the device and a peripheral or alternate device not shown . A sequence of signals transitioning the device from docked mode to mobile mode is initiated. Signal is sent from the resource manager to the portal activity indicating a mode status transition and enabling the main data input and the main framebuffer. The portal activity sends signal to the resource manager identifying the first OS is now primary and switching the virtual terminal. Signal is sent from the resource manager to the portal activity identifying the first OS as the primary and has taken ownership of the framebuffer. A mode state change confirmation signal is sent from the portal activity to the resource manager identifying that the device is now in mobile mode and that the first OS is the primary OS. A system mode update signal is sent from the resource manager to AIW .

Referring to the device is idle in docked mode and the second OS is the primary operating environment at step . If an unsolicited event occurs at step or the user selects the OS1 in a window application at step then the OS1 in a window application is launched at step . By example if Android is the mobile operating environment then the Android in a Window AIW application is launched. The AIW application enables a user to access Android applications while the device is operating in the docked mode. The resource manager is also notified of the status update at step . Input to the first OS is enabled at step followed by the transmission of first OS display update notifications at step . The AIW application is operating and has focus at step . If the AIW application is exited at step or a user removes AIW from focus at step then the first OS input is disabled at step . The first OS display is stopped at step . If the AIW application is exited at step then the system reverts to the idle docked mode . Alternatively if the AIW application is defocused then the application operates in this state at step . In the event of an unsolicited event at step or a solicited interaction with the AIW application at step the AIW regains focus at step . While the AIW is defocused a user can select the AIW application and continue interaction with the AIW window which refocuses the AIW and notifies the resource manager of the status update. After the AIW regains focus the first OS which is Android for the present embodiment input is enabled at step . The first OS display update notifications are transmitted to the resource manager at step followed by the system reverting to step where AIW is enabled and in focus. When an application is in focus that application is at the logical top of a stack of running applications.

In an alternative embodiment it is contemplated that the device can transition between mode states based upon events other than docking or undocking the device . By example if the device is stationary for a preset period of time the device can be programmed to operate in the most energy efficient mode state regardless of the device status otherwise. In yet another example a user can transition the mode state from docked to mobile even if the device has a connection with a peripheral device. Additionally the type of peripheral device connected to the device can dictate whether an automatic mode state change sequence is initiated or a user is provided a mode state change request. The user thereby being able to select the mode state in which to operate the device . In yet another alternative embodiment additional mode states are contemplated based upon the particular device usage and the applications available in the device memory .

It is specifically intended that the present invention not be limited to the embodiments and illustrations contained herein but include modified forms of those embodiments including portions of the embodiments and combinations of elements of different embodiments as come within the scope of the following claims.

