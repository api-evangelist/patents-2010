---

title: Methods and apparatus for creating markup language documents
abstract: A method for generating markup language documents, e.g., XML documents, uses a code generator that creates programs configured to create dynamic XML documents at run time, avoiding many of the complexities arising from the use of conventional “XML GENERATE” statements. In one embodiment, this process involves (1) creating a template document using a markup language, wherein the template document includes a set of tags associated with the markup language documents; (2) parsing the template document to determine a working storage structure corresponding to the tags in the template document; and (3) generating an application program in the programming language (e.g., COBOL), wherein the application program includes a definition of the working storage structure, and is configured to generate, during run-time, a markup language document corresponding to the original template document.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08255794&OS=08255794&RS=08255794
owner: American Express Travel Related Services Company, Inc.
number: 08255794
owner_city: New York
owner_country: US
publication_date: 20100125
---
This application is a continuation of U.S. application Ser. No. 10 906 020 entitled Methods and Apparatus for Creating Markup Language Documents filed on Jan. 31 2005. The 020 application claims priority to and the benefit of U.S. Provisional Application Ser. No. 60 587 702 filed Jul. 14 2004 and entitled System and Method to Facilitate Creating Dynamic XML Documents in COBOL. Both of which are hereby incorporated by reference.

The present invention generally relates to the generation and processing of markup language documents e.g. extensible markup language XML documents using traditional procedural programming languages e.g. COBOL and the like .

Many organizations have discovered that the cost effort and risk to replace older legacy systems with modern software and database systems are overwhelming. Rather many organizations continue to place an emphasis on supporting legacy systems by bridging gaps between old and new computing technologies wherein bridging the gap often includes modification of existing legacy data and programming languages.

COBOL is one such programming language. Despite the existence of modern object oriented programming languages and Internet based applications COBOL will likely remain a vital part of many organizations computing centers. Traditional COBOL however lacks some of the flexibility of modern languages such as the ability to read extensible markup language XML documents.

XML resembles Hypertext Markup Language HTML in appearance and structure however XML is functionally different HTML specifies how to display data while XML is used to describe data. Accordingly XML has provided developers with a means for displaying different types of data in a consistent manner. Generally a developer may create formatting instructions within a data type definition DTD file. When a data type is defined a developer need only add an XML tag within an HTML document which corresponds to a tag in the DTD.

Because COBOL is a legacy programming language it must often be retrofitted to support various functionality relating to newer computing technologies. Technologies such as XML were not designed with older computing technologies such as COBOL in mind. Modifying the language or creating add on products most often results in extra layers of sophistication and complexity for the developer. One such example is XML GENERATE which is a function included within IBM Enterprise COBOL. While XML GENERATE provides an effective means to generate and process various types of XML the generated XML is limited by the input data structure of the COBOL code both in it s structure and in tag names. Further it typically requires the creation of complex COBOL structures that mimic XML data structures. Enhancing this generated XML to bring it to an installation XML standard requires further processing of this XML.

In general the invention provides a method for facilitating the generation of markup language documents e.g. XML documents through the use of a code generator that creates programs configured to create dynamic XML documents at run time while minimizing or avoiding many of the prior art complexities. In one embodiment the method of the present invention involves 1 creating a sample document using the markup language wherein the sample document includes a set of tags associated with the markup language documents 2 parsing the sample document to determine a working storage structure corresponding to the tags in the sample document and 3 generating an application program in the programming language e.g. COBOL wherein the application program is configured to generate during run time the markup language documents corresponding to the working storage structure.

The following description is of exemplary embodiments of the invention only and is not intended to limit the scope applicability or configuration of the invention in any way. Rather the following description is intended to provide a convenient illustration for implementing various embodiments of the invention. As will become apparent various changes may be made in the function and arrangement of the elements described in these embodiments without departing from the scope of the invention.

The procedure then calls the appropriate XML code the generated code from item wherein the creation process is covered in detail below. The API which in the illustrated embodiment is named xxxxxXMO includes previously created working storage section linkage section and procedure division used to generate the XML code. Finally the resulting XML document is sent to the output destination .

Referring now to an overview of an exemplary method will now be described and a more detailed description is provided thereafter. Initially in step a template XML document is created which includes substantially all possible tags both optional and mandatory that are likely to be encountered in the particular context. The tags may be populated for example with sample values that represent the maximum length of the tag and may be repeated to represent multiple occurrences. Any tags that are not dynamic in nature can be omitted i.e. any static data is automatically returned. Alternatively using a user interface the developer can adjust the field lengths and array sizes as desired. In the illustrated embodiment the system uses the maximum lengths.

The various tags used in XML documents are known in the art and are covered in a variety of language specifications and developer publications. See e.g. Elliotte Harold XML Extensible Markup Language IDG 1998 which is hereby incorporated by reference.

With momentary reference to a typical user interface may appear as shown including a region for selecting the appropriate XML file a region for specifying the name and attributes of the output source file and various options for generating and editing the appropriate copybooks and API code. It will be appreciated that a variety of user interfaces may be employed and that the illustrated interface is not intended to be limiting.

Referring once again to in step the template XML document is fed into the XML GEN tool. This may be completed for example via the user interface just described or may be completed automatically. Steps through all occur in the XML Gen tool.

In steps the XML Gen tool then reads records from the template XML document and creates a corresponding XML string. A suitable parsing statement is then used to parse the XML string e.g. the IBM COBOL XML Parse statement step . For a description of the IBM COBOL XML Parse statement see e.g. IBM Enterprise COBOL Language Reference Version 3 Release 3 Third Ed. February 2004 which is hereby incorporated by reference.

Next in step the XML Gen tool intercepts the various XML events and generates the XML COBOL working storage structure that is used later. The various XML events that are intercepted are described in further detail below.

In step the system generates suitable COBOL procedure division statements e.g. program code to fill each tag or attribute with a corresponding value received from the fixed format input of the linkage section. This may be completed for example using ISPF edit macros and static code snippets. With the program code generated in step subsequent XML documents may be processed as described above in conjunction with .

Having thus given on overview of the illustrated method a detailed discussion of the various procedures will now be discussed. In steps and the system parses the XML by intercepting various XML events and generating the corresponding COBOL working storage structure.

In step the XML is suitably parsed such that each event of START OF ELEMENT and ATTRIBUTE NAME are used to generate a filler field with the appropriate length to have a value clause of the element name or attribute name. Similarly each event of CONTENT CHARACTERS and CONTENT CHARACTER will generate a COBOL variable with appropriate length. The group tags are given COBOL variable names of GRP xxxx the tags that have content are given variable names of XML xxxx with appropriate length and the attribute tags are given variable names of ATR xxxx with appropriate length where xxxx represents the tag name or attribute name. Empty CONTENT CHARACTERS are ignored. In a preferred embodiment the template XML represents all possible tag values.

With respect to the naming conventions described above it will be appreciated that any suitable convention and combination of characters may be used and that variable names given above are merely examples and are in no way limiting.

The START OF CDATA SECTION and END OF CDATA SECTION events preferably generate COBOL filler fields with corresponding value clauses to represent CDATA For general information related to CDATA and other such items see e.g. Elliotte Harold XML Extensible Markup Language 1998 . Similarly the END OF EVENT generates closing filler fields that represent closing tags such as . Additional standard XML events that are intercepted include 

If there is a parsing error that is not fatal i.e. where the XML error code is either between 49 and 100 or between 299 and 500 in one embodiment the system ignores the error and continues parsing the XML.

As mentioned above an exemplary COBOL copybook generator program is developed to parse the XML and intercept the events described above in order to create the corresponding COBOL data structure. show the exemplary COBOL data structure generated from the sample XML shown in .

For example the chart below shows the XML events and the corresponding Cobol copybook statements created for the tag 3000 of line in .

Initially in step an edit macro examines the copybook and identifies repeating groups. The repeated occurrences are deleted and the number of occurrences are reflected in the array size by the OCCURS clause. As described above the user may adjust the field lengths and array sizes using for example the aforementioned user interface.

Next in step all variable names from the data structure copybook that start with XML GRP and ATR are identified and a linkage section is constructed step . The variables in the linkage section are configured to reflect the COBOL copybook both in name and hierarchy. The names are prefixed in the illustrated embodiment using LS to represent linkage variables.

In step procedure division statements are generated for each linkage variable. The caller of this module preferably populates the linkage variables before calling this module. Procedure division statements are created to move each linkage variable into the corresponding XML Cobol copybook variable. In the case of arrays all occurrences are preferably populated.

In step a generic code is appended to compress the XML copybook such that fields represent the actual length of the field. The generic code moves each input XML character to output XML area however the leading spaces in the content of each element are truncated in the output XML.

To assist this compression logic which is shown in and a non blank index is maintained that points to the last non blank character populated in the output XML. Whenever the character N where N is the total number of characters in the XML document before compression step the system sends the compressed output XML step if not then the system continues with step and tests whether the input character is 

The present invention may take the form of an entirely software embodiment an entirely hardware embodiment or an embodiment combining aspects of both software and hardware. Furthermore the present invention may take the form of a computer program product on a computer readable storage medium having computer readable program code means embodied in the storage medium. Any suitable computer readable storage medium may be utilized including hard disks CD ROM optical storage devices magnetic storage devices and or the like.

For the sake of brevity conventional data networking application development and other functional aspects of the systems and components of the individual operating components of the systems may not have been described in detail herein. Furthermore the connecting lines shown in the various figures contained herein are intended to represent exemplary functional relationships and or physical couplings between the various elements. It should be noted that many alternative or additional functional relationships or physical connections may be present in a practical system. The various system components discussed herein may include one or more of the following a host server or other computing systems including a processor for processing digital data a memory coupled to the processor for storing digital data an input digitizer coupled to the processor for inputting digital data an application program stored in the memory and accessible by the processor for directing processing of digital data by the processor a display device coupled to the processor and memory for displaying information derived from digital data processed by the processor and a plurality of databases. Various databases used herein may include client data merchant data financial institution data and or like data useful in the operation of the present invention. As those skilled in the art will appreciate user computer may include an operating system e.g. Windows NT 95 98 2000 OS2 UNIX Linux Solaris MacOS etc. as well as various conventional support software and drivers typically associated with computers. The computer may include any suitable personal computer network computer workstation minicomputer mainframe or the like. User computer can be in a home or business environment with access to a network. In an exemplary embodiment access is through a network or the Internet through a commercially available web browser software package.

Any networks used in connection with the present invention i.e. in the context of a distributed software hardware system shall include any electronic communications means which incorporates both hardware and software components of such. Communication among the parties in accordance with the present invention may be accomplished through any suitable communication channels such as for example a telephone network an extranet an intranet Internet point of interaction device point of sale device personal digital assistant cellular phone kiosk etc. online communications satellite communications off line communications wireless communications transponder communications local area network LAN wide area network WAN networked or linked devices keyboard mouse and or any suitable communication or data input modality. Moreover although the invention is frequently described herein as being implemented with TCP IP communications protocols the invention may also be implemented using IPX Appletalk IP 6 NetBIOS OSI or any number of existing or future protocols. If the network is in the nature of a public network such as the Internet it may be advantageous to presume the network to be insecure and open to eavesdroppers. Specific information related to the protocols standards and application software utilized in connection with the Internet is generally known to those skilled in the art and as such need not be detailed herein. See for example Dilip Naik Internet Standards and Protocols 1998 Java 2 Complete various authors Sybex 1999 Deborah Ray and Eric Ray Mastering HTML 4.0 1997 and Loshin TCP IP Clearly Explained 1997 and David Gourley and Brian Totty HTTP The Definitive Guide 2002 the contents of which are hereby incorporated by reference.

The various system components may be independently separately or collectively suitably coupled to the network via data links which includes for example a connection to an Internet Service Provider ISP over the local loop as is typically used in connection with standard modem communication cable modem Dish networks ISDN Digital Subscriber Line DSL or various wireless communication methods see e.g. Gilbert Held Understanding Data Communications 1996 which is hereby incorporated by reference. It is noted that the network may be implemented as other types of networks such as an interactive television ITV network. Moreover the system contemplates the use sale or distribution of any goods services or information over any network having similar functionality described herein.

Many of the communications inputs storage databases or displays discussed herein may be facilitated through a website having web pages. The term web page as it is used herein is not meant to limit the type of documents and applications that might be used to interact with the user. For example a typical website might include in addition to standard HTML documents various forms Java applets JavaScript active server pages ASP common gateway interface scripts CGI extensible markup language XML dynamic HTML cascading style sheets CSS helper applications plug ins and the like.

It should be understood that the detailed description and specific examples indicating exemplary embodiments of the present invention are given for purposes of illustration only and not as limitations. Many changes and modifications within the scope of the instant invention may be made without departing from the spirit thereof and the invention includes all such modifications. For example while the present invention has been described in the context of COBOL the general framework described herein may be used in conjunction with a number of other legacy software languages e.g. Fortran PL1 Pascal and the like. Corresponding structures materials acts and equivalents of all elements in the claims below are intended to include any structure material or acts for performing the functions in combination with other claim elements as specifically claimed. The scope of the invention should be determined by the appended claims and their legal equivalents rather than by the examples given above.

