---

title: Managing items in a user interface
abstract: User interface changes related to moving items in a user interface are disclosed. An operation (e.g., a drag operation) can be initiated on selected items by moving a cursor or pointing device in the user interface, and an animation can be presented illustrating representations of the selected items moving from their respective original locations toward a current location of the cursor or pointing device and forming a cluster in proximity to the current location of the cursor or pointing device. As the cluster of items is moved over a container object in the user interface, the representations of the items can adopt the appearance style defined by that container object. The representations of the items can also be shown to depart from the cluster and move toward anticipated locations of the items in the container object as a preview of a drop operation into the container object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09323442&OS=09323442&RS=09323442
owner: Apple Inc.
number: 09323442
owner_city: Cupertino
owner_country: US
publication_date: 20100930
---
Modern computing devices often include file systems that store information items in various directories or subdirectories e.g. folders in a file system hierarchy. In a graphical user interface GUI representations of the information items e.g. icons can be shown in respective container objects e.g. the desktop folder windows associated with a parent item of the information items to indicate the locations of the information item in the file system hierarchy.

Each container object can be associated with an appearance style e.g. a large icon view a small icon view a list view a column view etc. . Representations of the information items contained in the container object can take on respective appearances according to the appearance style associated with the container object. When an item is moved from one container to another container having a different appearance style or when the appearance style of a current container is modified the appearance of the item s representation can be changed according to the current appearance style of the item s current container.

Many operating systems enable a drag and drop operation to be performed on items that are currently selected in a GUI. In the drag and drop operation representations of the selected items can be moved or dragged in the user interface from one container object to another container object following the movement of a pointer e.g. a mouse cursor or pointing device on a touch sensitive surface . When the items are released or dropped over the drop zone of a desired target container the selected items become the content items of the target container and the representations of the items appear in the target container according to the appearance style associated with the target container.

A user or application can select one or more item representations in a user interface and initiate an operation e.g. a drag operation on the selected item representations by a movement of a cursor e.g. a mouse cursor or trackball cursor or pointing device e.g. a finger or stylus in the user interface. When the operation is initiated an animation can be presented illustrating the item representations moving toward a current location of the cursor or pointing device in the user interface and forming a cluster in proximity to the current location of the cursor or pointing device. As the cursor or pointing device moves in the user interface the cluster of item representations can move with the cursor or pointing device in the user interface. Each item representation in the cluster can move in the user interface along a different path and at a different speed or acceleration than other item representations in the cluster.

When the item representations are initially selected the item representations can have respective first appearances according to the appearance style associated with the container object from which the item representations are selected. As the cluster of item representations is moved over a drop zone of a container object in the user interface the item representations in the cluster can take on respective appearances based on the appearance style associated with that container object.

In some implementations a change in appearance is not presented if a user is moving the cluster over a container object in passing to reach another destination in the user interface and the change in appearance is presented upon determination that the user is moving the cluster over the container object with the intent to place the cluster in the container object. The user s intent can be estimated based on motion characteristics such as the speed or acceleration of the cursor or pointing device in the user interface as the cluster is moved over the container object.

In some implementations when the cluster of item representations is moved over an area of an ineligible drop target the item representations in the cluster can take on respective appearances that are different from their original appearances in the source container from which the item representations are selected. The new appearances can be based on an appearance style that is defined by the source container for the ineligible drop target. In some implementations the source container can define any number of different appearance styles that can be applied to the item representations based on different trigger events e.g. hovering of the item representations over an ineligible drop target passing of the item representations over particular regions within the source container etc. .

In some implementations when the pointer or the cluster is hovered over a potential target container for more than a defined time period an animation can be presented to show the item representations departing from the cluster and moving toward the representations anticipated locations in the target container object as a preview of a drop operation into the target container object. The item representations can appear in a preview state e.g. as semi transparent overlays at or in proximity to the item representations anticipated locations and adopt the appearance style associated with the potential target container object. If the anticipated locations of some item representations are in an area of the potential target container object that is not currently visible in the user interface those item representations can be shown to move from the cluster into the invisible area along respective paths in the user interface.

In some implementations if the cursor or pointing device is moved away from the potential target container without dropping the selected items the representations of the selected items can be animated to dislodge from their respective locations at or near the anticipated locations and rejoin the cluster in proximity to the current location of the cursor or pointing device. Alternatively if the selected items are released into the potential target container the representations of the selected items can be animated to transition from a first state e.g. a semi transparent state to a second state e.g. an opaque state and settle at the items anticipated locations in the potential target container.

Some implementations include one or more application programming interfaces APIs in an environment with calling program code interacting with other program code being called through the one or more interfaces. Various function calls messages or other types of invocations which further may include various kinds of parameters can be transferred via the APIs between the calling program and the code being called. In addition an API may provide the calling program code the ability to use data types or classes defined in the API and implemented in the called program code.

At least certain implementations include an environment with a calling software component interacting with a called software component through an API. A method for operating through an API in this environment includes transferring one or more function calls messages and other types of invocations or parameters via the API.

In some implementations the item representations can have appearances that are generated by the operating system based on various appearance styles defined by the source container object and various potential drop target containers. Each appearance style can be defined through the API by a corresponding container. Each appearance style can specify one or more layers for the item representation and each layer can be associated with different properties and rules that control the appearance of the layer the animation style of the layer and so on. Different animations can be performed on the different layers independently of one another.

In addition to the appearance style of the individual item representations each container object can also define respective formation styles for the multiple items e.g. all selected items collectively as the item representations are in their various appearances. The formation styles can also be defined by their corresponding container objects through the API. Examples of the formation styles can include the layout of the item representations in their source container the cluster formation near the pointer and the preview formation in a potential drop target container as described herein. Other formation styles can be defined. Different animation styles that can be applied to illustrate the respective transitions between appearances and formations can also be specified by the source container or the potential drop target containers through the API.

The details of one or more implementations of managing items in a user interface are set forth in the accompanying drawings and the description below. Other features aspects and advantages will become apparent from the description the drawings and the claims.

In a file system information items e.g. files and folders can be organized in a file system hierarchy. Each information item e.g. files and folders can be contained in a parent item e.g. a parent folder in the file system hierarchy. In an application program e.g. an html editor a word processor an email editor etc. for editing a document content items e.g. image videos data objects etc. can be embedded at particular locations in the document. In addition information items e.g. address book entries data objects and user interface elements e.g. buttons can be moved from and inserted at defined locations in an application window.

In a graphical user interface GUI container objects such as the desktop folder windows and or application windows can be used to represent folders in the file system hierarchy present new or existing application documents and or present user interface elements or data objects. Representations e.g. icons of information items e.g. files and folders contained in a parent folder can be displayed within the container object e.g. a folder window or the desktop representing the parent folder in the GUI. Similarly representations e.g. thumbnail images or icons of content items e.g. images video clips data objects etc. can be displayed within a container object e.g. an application window presenting an application document in which the content items are embedded. Similarly representations e.g. buttons or icons of data objects of user interface elements and data objects can be presented in a container object e.g. an application window a finder window as well.

In conventional GUIs a user or application can select representations e.g. icons of items in a source container e.g. the desktop or a folder window move e.g. drag the selected item representations into a drop zone of a target container e.g. an available area of the desktop or the window area of a folder window using a pointer e.g. a mouse cursor a stylus or finger on a touch sensitive display and drop the selected item representations into the target container. After the drag and drop operation the selected item representations can be moved from the source container to the target container on the user interface. In the file system the items corresponding to the selected representations are moved from a location associated with the source container to another location associated with the target container in the file system hierarchy.

In conventional GUIs when the user drags the selected items in the user interface the movement of the selected items as a whole can be illustrated as an image containing representations of the selected items being dragged along by the cursor or pointing device. The appearance and spatial relationship of the selected items are static within the image as the image is dragged from one location to another in the user interface. When the items are released after the image enters the drop zone of a target container e.g. as indicated by a change in appearance of the target container the image disappears into the target container indicating the completion of the move.

As disclosed herein a user can select one or more items in a user interface and while the items are selected the user can initiate a defined operation e.g. a drag operation on the selected items by a movement of a cursor or pointing device. When the operation is initiated an animation can be presented illustrating the representations e.g. icons of the selected items moving from their original locations toward a current location of the cursor or pointing device in the user interface and forming a cluster in proximity to the current location of the cursor or pointing device. Hereinafter the term pointer will be used to describe cursors e.g. mouse or trackball cursors and pointing devices e.g. finger or stylus on a touch sensitive display .

In some implementations as the user continues to move the pointer during the drag operation the representations of the selected items can move as a cluster in the user interface following the pointer e.g. a cursor in the user interface or the touch point of a finger or stylus on a touch sensitive display . The individual movement of each item representation in the cluster can be independently represented in terms of path speed and acceleration relative to other item representations in the cluster. In some implementations the item representations can trail behind the current location of the pointer at varying distances within the cluster.

Furthermore in some implementations the container objects displayed in the user interface can be associated with different appearance styles and representations of items displayed within each container object can take on characteristic appearances according to the appearance style associated with the container object. Common appearance styles can include a large icon view a small icon view a list view a column view or a picture view for example. Other appearance styles associated with application windows can be defined by the application programs providing the application windows for example through an API associated with the operating system. In addition to the appearance styles for individual item representations each container object can also define a formation style for the selected item representations collectively. Example formation styles include a free arranged layout a keep arranged layout a cluster etc.

In some implementations when items are initially selected the representations of the selected items can have respective first appearances according to the appearance style associated with the items respective source containers. As the representations of the selected items form a cluster and are moved over the drop zones of different container objects in the user interface the representations of the selected items in the cluster can take on different appearances depending on the appearance style associated with the container object over which the cluster of item representations is currently located. In some implementations when the selected items in the cluster are over areas of ineligible drop target containers the representations of the selected items in the cluster can take on appearances based on other appearance styles that are defined by the source container object for the ineligible drop target containers. The formation style of the selected items can also change according to a formation style defined by the source container for the ineligible drop target containers.

In an exemplary user interface is presented. The exemplary user interface can be a desktop of an operating system. A number of container objects e.g. a folder window a folder window and an application window are displayed on the user interface for example within a display area of the desktop.

As shown in the folder window contains representations of items e.g. item representations and shown in a large icon view. In the large icon view the representation of each item can include a thumbnail image showing a preview of the item s content and a text label showing the name of the item. For example if the item is an image file the representation of the item in the large icon view can be a scaled down replica of the image file with a text label showing the filename of the image file. For another example if the item is a folder the representation of the item in the large icon view can be an enlarged folder icon revealing representative content of the folder on the surface of the enlarged folder icon and a text label showing the name of the folder. Other appearance characteristics can be associated with the representations of items in the large icon view such as size transparency level color scheme etc.

In some implementations a folder window can also be in a small icon view where smaller icons representing the items can be displayed. The small icon representations of the items can include less visual information than the large icon representations of the items. For example the small icon representation of an item can indicate the file type of the item e.g. image file text document folder etc. but omit information on any specific content of the item. The large icon representation and the small icon representation of an item can both include a text label indicating the filename of the item. In some implementations the text labels of an item s large icon representation and small icon representation can have different appearances.

In some implementations the folder window e.g. the folder window in a large icon view or a small icon view can be in either a free arranged state or a keep arranged state. In the free arranged state the representations of items can be located at and moved to any coordinate locations in the display area of the folder window. In the keep arranged state the representations of items can be located on an evenly spaced grid and sorted according to one or more keep arranged criteria e.g. by filename by modification time by size by file type etc. .

In some implementations when the folder window is in a keep arranged state if new items are introduced into the folder window or if the attributes associated with a keep arranged criterion e.g. a sorting criterion are changed for one or more items in the folder window the folder window can be updated to re organize the items on the display area of the folder window according to the one or more keep arranged criterion and the new values of the attributes.

In some implementations the folder window e.g. the folder window may be resized such that only a portion of the display area in the folder window is visible on the user interface . The user can use a scroll control to move the view port of the folder window to reveal the hidden portions of the display area or to enlarge the folder window to reveal more of the display area of the folder window.

As shown in the folder window is currently shown in a large icon view and in a free arranged state. The large icon representations of the items and are located in the display area of the folder window in a free arranged configuration. Also as shown in the user has selected the items and as indicated by the shading of the items and .

Also in the folder window is currently shown in a list view. The folder window represents a folder e.g. folder Drop Target 1 in the file system hierarchy. Items shown in the folder window are items contained in the folder represented by the folder window . Representations of items e.g. item representations and shown in the folder window can each include a small icon representing the item and a text label showing the filename of the item. The small icon of an item s list view representation can be the same as the graphical portion of the item s small icon representation but the text labels in the list view representation and the small icon representation can be positioned differently in the two representations. For example in the list view representation the text label is located to the right of the small icon while in the small icon representation the text label is located below the small icon.

As shown in the item representations e.g. the item representations and within the list view folder window can be sorted according to a keep arranged criterion such as by filename by size by modification time by item type and so on. In the folder window the representations of the two items and are arranged according to their filenames.

Other than the large icon view the small icon view and the list view folder windows can also be shown in a column view not shown in . A folder window in the column view can include one or more columns. Each column can correspond to a respective level in the file system hierarchy and be associated with a respective parent item from a parent level of the respective level in the file system hierarchy. Consecutive columns in the column view folder window correspond to consecutive levels of the file system hierarchy. Each column can present representations of items that are child items of a currently selected item in an adjacent column to the left of the column. The representations of items in a column view folder window can have similar appearances as the representations of the items in a list view folder window.

Other views of folder windows and application windows can be defined. The operating system can provide an application programming interface API that specify the various appearance characteristics that representations of items can have when presented in the folder windows and application windows in the various views. In some implementations each view of the folder window can be specified with an appearance style which controls how individual item representation should appear in this view. Each appearance style can specify one or more layers for the different components of the item representations. For example a respective layer can be defined for the icon image of an item representation the text label of the item representation and a background image of the item representation. Each layer can have associated properties that define how the component should appear and how the component can be animated during a transition to a different appearance style from the current appearance style.

In some implementations while the items remain selected in the user interface the initiation of the defined operation e.g. the drag operation can be indicated by a movement of the pointer from a location inside the folder window to another location outside of the folder window . In some implementations the defined operation begins and continues when the pointer is moved while a hold button e.g. the mouse button or the SHIFT key remains pressed on an input device e.g. the mouse or the keyboard . In some implementations the initiation of the defined operation can be indicated by a movement of the pointer from one location to another location over a defined threshold distance regardless of whether the second location is within or outside of the folder window . In some implementations the hold button needs not be pressed during the defined operation.

As shown in after the initiation of the defined operation e.g. the drag operation is detected e.g. as indicated by the current location of the cursor outside of the folder window an animation can be presented in the user interface to illustrate the movement of the respective representations of the selected items from their original locations toward the current location of the pointer on the user interface . The movement of each item representation can be along a respective path e.g. as indicated by the dashed curves in the user interface . In some implementations respective representations of the selected items e.g. item representations and can remain in their original locations in the folder window while copies of the representations e.g. item representations and can be shown to be peeled off from the representations and and moved toward the current location of the pointer along their respective paths.

In some implementations the speed acceleration and path shape for each item representation e.g. each of the item representations and can be varied independently of one another. In some implementations an item representation located closer to the starting location of the pointer e.g. item representation can be shown to take off earlier than an item representation located farther away from the starting location of the pointer e.g. item representations and in the folder window .

In some implementations the item representations can start their respective movement toward the current location of the pointer as soon as the pointer starts to move and if the selected items are released before the current location of the pointer reaches the edge of the folder window the representations of the selected items can be shown to move back to their original locations in the folder window along their respective paths in the user interface .

In some implementations the item representations e.g. the item representations and can be shown to start their respective movement at a slower and more uniform speed toward the current location of the pointer as soon as the pointer starts to move. And as soon as the currently location of the pointer moves beyond the folder window or alternatively as soon as the pointer has moved beyond a threshold distance from its starting location in the folder window the items representations can be shown to move more rapidly or accelerate toward the current location of the pointer and form a cluster in proximity to the current location of the pointer.

In some implementations when the pointer moves within the folder window the representations of the selected items can follow the movement of the pointer as a static image where the spatial relationship between the selected items do not vary during the movement. And as soon as the pointer moves outside of the folder window the representations of the selected items can be shown to move toward or flock to the current location of the pointer along their respective paths and form a cluster in proximity to the current location of the pointer.

In some implementations the formation of the item representations e.g. the cluster can be defined by the source container object e.g. the folder window through the API. The animation style showing the respective movement e.g. path shape speed acceleration of the item representations from their respective original locations to their respective locations in the formation e.g. the cluster can also be defined by the source container through the API. In some implementations the appearance style and the formation style of the item representations can be determined jointly by the source container and the potential drop target container.

As shown in the respective representations of the selected items representations and have reached their respective locations in proximity to the current location of the pointer e.g. as indicated by the cursor and formed a cluster in proximity to the current location of the pointer. In some implementations the representations of the items can arrive at the cluster at different times.

In some implementations as shown in the cluster formed by the representations of the selected items is a stack containing the representations of the selected items e.g. the item representations and . In some implementations the order of the items representations in the stack can be dependent on the order by which the representations had arrived in the stack which indirectly can depend on the respective distance between each item s original location in the folder window and the starting location of the pointer in the folder window . In some implementations the order of the items representations in the stack can depend on the order by which the items had been selected in the folder window . In some implementations other orderings e.g. random order of the items representations in the cluster are also possible. In some implementations the order of the items representations can be defined in a formation style associated with the potential drop target e.g. the desktop . In some implementations the order of the items representations can be defined in a formation style associated with the source container e.g. the folder window .

In some implementations the items representations do not have to form a stack in the cluster . Other arrangements of the items in the cluster are possible. For example if the number of item representations in the cluster is small the items can be laid out on a grid or along a curved path e.g. in a circle in proximity to the current location of the pointer. In some implementations if the items representations overlap in the cluster the items representations in the cluster can be temporarily spread out to eliminate the overlapping in response to a predefined input command e.g. an expansion command . The different formation styles or arrangements can be defined with different trigger events such as the number of items in the formation the current location of the pointer and so on. The different formation styles can be used to arrange the item representations when their corresponding trigger events are detected in the user interface.

In some implementations after the items representations e.g. the item representations and have formed a cluster in proximity to the current location of the pointer e.g. as indicated by the cursor the item representations can move independently within a defined range in the cluster . For example each item representation and can be shown to move near the current location of the pointer in the cluster in a manner as if the item representations and are floating in water and are being rocked by the currents in the water.

In some implementations a count indicator can be presented in proximity to or attached to the cluster . The count indicator can show a numeral indicating the number of item representations that have gathered in the cluster . As shown in three item representations e.g. item representations and have gathered near the current location of the pointer and formed the cluster and the count indicator attached to the cluster shows the number 3. In some implementations the count indicator can be defined in its own layer in the cluster and be animated independently of the item representations in the cluster. The source container can provide the formation style for the cluster and the formation style can specify how the item representations are to be laid out in the cluster.

As shown in the current location of the pointer is on the display area of the desktop. The desktop itself can be a container displaying representations of items e.g. icons for files and folder in the desktop folder in the display area of the desktop. The desktop can present items in a large icon view or a small icon view and the representations of items in the desktop can be in a free arranged configuration or a keep arranged configuration.

In this example the desktop is in a large icon view. Therefore when the items representations move from the folder window to the current location of the pointer on the desktop the appearance of the item representations are not altered when they form the cluster on the desktop. However if the desktop were in a small icon view the item representations can be changed from their original large icon appearances as shown in the folder window to their small icon appearances when the item representations are clustered on the desktop.

In some implementations before the dragged items are released e.g. by the releasing of the hold button on the pointer or the keyboard or by lifting the finger away from the touch sensitive display the item representations can follow the movement of the pointer in the user interface in a cluster e.g. the cluster .

As shown in as the current location e.g. as indicated by the cursor of the pointer are moved along a path e.g. as indicated by the dashed curve in the user interface e.g. within the display area of the desktop the item representations in the cluster follow the movement of the pointer along the representations respective paths as indicated by the dashed curves .

In some implementations the item representations in the cluster can moved at different speeds and with different accelerations and trail behind the cursor by different distances. In some implementations when the pointer is stopped in the user interface e.g. at the end of curved path in the direction of the arrow each item representation in the cluster can be shown to decelerate when the item representation arrives at a location in proximity to the stop location of the pointer in the user interface .

Continuing with the example shown in if the user continues the dragging operation on the selected item representations and the cluster formed by the item representations and can follow the movement of the pointer into the folder window as shown in . When the cluster initially enters the folder window the appearances of the item representations in the cluster can be the same as the appearances of the item representations in the cluster when the cluster was in the display area of the desktop.

In some implementations if the cluster is dragged across the folder window quickly without stopping or slowing down the appearances of the item representations in the cluster do not need to change. In some implementations the operating system can monitor the motion pattern of the pointer as the cluster is dragged from location to location on the user interface . If the motion pattern of the pointer over a container object e.g. a folder window an application window or the desktop is indicative of the user s consideration of the container object as a potential target container for the selected items in the cluster the change in appearance for the item representations in the cluster can be carried out. If the motion pattern of the pointer over a container object indicates that the user is merely passing over the container object on the way to another location on the user interface the change in appearance for the item representations in the cluster are not initiated.

In some implementations the characteristics in the motion pattern that are indicative of the user s consideration of a container as a potential target container for the selected items in the cluster can include a slow down of the pointer after the pointer has entered the container or a pause of the pointer inside the container for more than a threshold amount of time e.g. hovering . In some implementations the characteristics in the motion pattern indicating that the user is merely moving the pointer over a container to another location in the user interface can include a fast and smooth movement of the pointer over the container without any slowing down.

In some implementations as shown in when the pointer slows down or pauses inside the folder window the appearances of the item representations in the cluster can change from the large icon view associated with the desktop to the list view associated with the folder window . For example the representations and of the selected items are the items large icon representations and in the large icon representations and in the cluster have been replaced by the representations and which are the list view representations of the selected items and respectively.

As shown in each of the list view representations and of the selected items in the cluster can include a small icon and a text label. In some implementations the list view representations in the cluster can be sorted in the cluster according to the keep arranged criterion e.g. by filename by size by file type by modification time etc. of the folder window . In some implementations the order of the list view representations and in the cluster can be kept the same before and after the change in appearance has occurred.

In some implementations an animation can be presented to illustrate the transition of the item representations from their large icon appearances in the cluster to their list view appearances in the cluster. Different animations can be applied to different layers e.g. the icon image layer and the text label layer of the item representations. For example an animation can be applied to the icon image layer illustrating the large icon image of an item representation shrinking into a small icon image of the item representation. At the same time another animation can be applied to the text label layer illustrating the text label of the item representation moving from the bottom of the large icon image to the right side of the small icon image. In addition the appearance of the text label itself can be changed as well during the animation. For example a border can be added around the text label and the color and font of the text label can be changed as well.

In some implementations when the user pauses the pointer inside a container e.g. the folder window for a prolonged period of time e.g. more than a minimum threshold time period or when the user enters a predefined preview command an animation can be shown in the user interface illustrating the item representations e.g. item representations and in the cluster departing from their original locations in the cluster and moving toward their respective anticipated locations if the items were to be released into the container e.g. the folder window .

In some implementations the anticipated locations of the item representations can be determined according to the keep arranged criteria e.g. sorting by filename file size file type modification time etc. associated with the container e.g. the folder window and the relevant attribute values e.g. filenames file sizes files types modification times etc. of the selected items in the cluster and the existing items in the container. For example the selected items and and the existing items and when sorted by their respective filenames would have the following order 1 item 2 item 3 item 4 item and 5 item . Based on this order the anticipated locations of the item representations and in the folder window can be determined.

As shown in the item representations and have departed from the cluster and moved to the respective anticipated locations that the item representations would have in the folder window if the selected items were to be dropped into the folder window . In some implementations representations of existing items e.g. item representations and can be moved in the folder window to make room for the representations of the selected items in the clusters .

In some implementations the item representations e.g. item representations and from the cluster can be displayed at their anticipated locations in the potential target container e.g. the folder window . In some implementations the item representations e.g. item representations and can be displayed in proximity to their anticipated locations in the potential target container e.g. the folder window .

In some implementations when the representations of the selected items are presented at or in proximity to their anticipated locations in the potential target container the representations can be displayed as semi transparent overlays on the user interface. In some implementations other visual indications can be provided in the item representations when the item representations are presented at or in proximity to their anticipated locations during the preview.

In some implementations after the item representations e.g. item representations and in the cluster have departed from the cluster and moved to the respective anticipated locations of the representations in the potential target container e.g. the folder window if the user then chooses to drop the selected items into the potential target container the respective representations of the selected items e.g. the representations and can be shown to move if they are not already displayed at their respective anticipated locations and settle into their respective anticipated locations and change from a first state e.g. a semi transparent state to a second state e.g. an opaque state . In some implementations other appearance characteristics indicating the transitory state of the item representations during the preview can be removed when the item representations are dropped into the potential target container.

In some implementations as shown in at the completion of the drop operation the representations of the selected items in their respective list view appearances have been inserted into the folder window at their respective anticipated locations shown during the preview in . At the completion of the drop the representations of the selected items in the folder window can be removed from the user interface as also shown in . In the above example the drag and drop operation is performed on the selected items and the drag and drop causes a move of the selected items in the file system. In some implementations the drag and drop operation can also be performed on copies of the selected items and the representations of the selected items can be left in the folder window and returned to their regular large icon view e.g. without the shading shown in after the drag and drop.

In some implementations the user can drop the selected items into a potential target container without waiting for the preview of the items at their anticipated locations to be presented. For example the user can release the items immediately after the pointer is moved into the drop zone of the potential target container. For example the drop operation can be initiated when the user interface is in the state as shown in . Alternatively the user can release the items after the items have changed their appearances from the large icon view to the list view. For example the drop operation can be initiated when the user interface is in the state as shown in . When the items are released the items representations can be shown to move from their respective current locations toward their anticipated locations along the items respective paths and finally settle at the items anticipated locations as shown in .

In some implementations if the user decides not to release the item representations e.g. the item representations and into the potential target container e.g. the folder window and moves the pointer to a different location in the user interface e.g. out of the folder window the item representations can be shown to dislodge from their respective anticipated locations in the folder window and move toward the current location of the pointer to rejoin the cluster in proximity to the current location of the pointer.

As shown in as the pointer is moved out of the potential target container e.g. the folder window the cluster follows the cursor of the pointer. In addition when the cluster is on the display area of the desktop the item representations in the cluster can change from their respective list view appearances to their respective large icon view appearances.

Continuing with the example shown in suppose the user did not release the selected items into the folder window and has dragged the cluster of selected items into the application window . The application window can present an existing or new document and the document is ready to be edited. The application window can be provided by a corresponding software application. In some implementations the software application can define how content items e.g. image files video clips data objects etc. can be presented in a document when the document is shown in an application window provided by the software application. In some implementations the software application can communicate with the operating system through an application programming interface API to provide the necessary information e.g. location size resolution and format of the content items in the application defined appearance style for the operating system to implement the changes in appearance for item representations when the item representations are being dragging in and out of the application window .

In some implementations the application can specify multiple layers in the appearance style of the item representation. Each layer can correspond to a component in the item representation e.g. the icon image the text label and a background image . Each layer can be associated with its own properties such as properties that specify the size color location of the component and the animation style of the component when transitioning between appearance styles. Each layer can also be associated with a layer name or key name. For example the layer showing the text label of an item representation can be given a key name Label while a layer showing the icon image of the item representation can be given a key name Icon. The key names of the layers can be used by the operating system to identify the layers in a collection of item representations e.g. in the cluster for which special appearance and or animation can be applied. For example the operating system can identify all the Label layers in the item representations in the cluster and make all or some e.g. all but one of the text labels in the item representations fade out when the item representations have arrived in the cluster.

In the example shown in the software application providing the application window is an email editor and the document presented in the application window is an email message e.g. Message that is being edited. The document currently includes some text but no other content item has been embedded in the document. The software application supports dragging and dropping content items into an insertion point in the document .

When the user has dragged the cluster containing the representations of the selected items e.g. the representations and into the application window initially the representations can maintain their large icon appearances as shown in . The operating system can monitor the motion characteristics of the user s pointer and determine whether the cluster is merely being dragged over the application window in passing or whether the user is considering the application window as a potential target container for the selected items in the cluster .

For example the operating system can monitor the speed by which the cluster has been dragged into the application window and whether the pointer is currently stopped within the application window . If the pointer has slowed down significantly or has stopped within the application window the operating system can decide to change the appearance of the item representations in the cluster according to the appearance style associated with the application window . If the operating system determines that the pointer is moving through the application window without any significant slowing down or stopping the operation system can keep the appearance of the item representations in the cluster as is until a significant change in the motion pattern has been detected.

In this example the user has stopped the pointer in the application window . When the operating system has detected the stopping of the pointer within the application window the appearances of the item representations in the cluster can be changed from their large icon appearances e.g. as representations and to their picture view appearances e.g. as representations and . The picture view appearances of the selected item can be defined by the application program according to how the item would appear if inserted into the document . For example if the selected items are image files and when the images files are inserted into the email message shown in the application window the image are resized to have a uniform lateral size of half the page width. The appearance style of the application window can be provided to the operating system through one or more API calls and the operating system can generate the picture view representations of the selected items according to the appearance style of the application window . After the picture view representations e.g. representations and of the selected items have been generated the picture view representations can be presented in the cluster replacing the large icon representations of the selected items as shown in .

In some implementations the picture view representations of the image files can be a reduced image with less resolution or color information. In some implementations the picture view representation can be semi transparent. The software application can define other appearance styles associated with various views of the content items and the item representations can be generated by the operating system according to the definition of the appearance style provided by the software application for the application window.

As shown in each item representation in the cluster can move toward its respective anticipated locations in the potential target container along a respective path. The anticipated locations of the items representations can be determined according to the content of the document and the specifications of the application program providing the application window . For example the application program providing the application window can specify the order and layout by which the selected items can be inserted into the document and provide the specifications to the operating system through an API. The operating system can implement the user interface changes illustrating the movement of the item representations to their respective anticipated locations in the document in the application window .

In some scenarios the application window can be of a limited size and the document cannot be fully revealed within the view port of the application window . The user can either increase the size of the application window or to use a scroll control to move the hidden portions of the document into the view port of the application window . When the anticipated locations are determined for the item representations in the cluster the anticipated locations of some item representations may be in areas of the document that are not currently visible in the application window . In such scenarios the representations of these items can be shown to depart from the cluster and move toward their respected locations along a respective path. The item representations can be shown to exit the visible area of the application window along a trajectory leading to the anticipated locations that are not currently visible in the application window .

For example as shown in the anticipated location of the item representation is partially within the visible area of the application window . During a preview of the item representations at their anticipated locations an animation can be presented showing the item representation moving partially into the invisible area of the document. Similarly the anticipated location of the item representation is completely outside of the visible area of the application window and during the preview the animation can show the movement of the item representation along the path into the invisible area of the application window . By showing the animation the user can make the mental note that the item representation has not simply disappeared but is located at an insertion point in the document below the image representation .

If the user decides to drop the selected items after seeing the preview of the items representations at their anticipated locations in the application window the user can release the items e.g by releasing the hold button on the mouse or keyboard or by lifting the finger or stylus from the touch sensitive display . illustrates exemplary user interface changes showing that the representations of the selected items have settled into their respective anticipated locations when the items are dropped into the second potential target container e.g. the application window .

As shown in the item representations and have changed from the semi transparent states to an opaque state. Although the item representation is not currently visible in the revealed display area of the application window if the user scrolls down further in the application window the item representation will be revealed. After the drop operation is completed the items representations and can be removed from their original container e.g. the folder window .

Continue with the example above following the state as shown in suppose the user now selects two of the three items e.g. the item representations and that were dropped into the application window and starts to drag the selected items away from the application window as shown in .

As the initiation of the dragging operation by the pointer is detected by the operating system the operating system can present an animation showing the selected item representations e.g. the item representations and moving from their original locations in the application window toward the current location of the pointer as indicated by the cursor . In some implementations the movement of the item representations can be slow and uniform when the pointer has not moved out of the application window and can accelerate toward the current location of the pointer as soon as the pointer has exited the application window .

When the user has enter a command to see a preview of the item representations in their anticipated locations in the free arranged container an animation can be presented to illustrate the item representations and departing from the cluster and moving toward their anticipated locations in the folder window . Since the folder window is in a free arranged state the item representations and will simply be dropped at their current locations with some fixed spacing between them. As shown in the item representations can overlap with existing items in the folder window if dropped into the folder window at their current locations.

After the user releases the selected items in the folder window the items can be shown to settle into their respective locations as previously shown in the preview. As shown in the item representations and have changed from the semi transparent state to an opaque state and settled at their final locations shown in the preview and the items are now represented by item representations and in . The items can be shown to be removed from the application window and the item representation can move up in the screen and be displayed in the application window .

In some implementations as illustrated in the cluster of item representations is displayed in proximity to the current location of the pointer but do not overlap with the current location of the pointer. A gap or distance is kept between the current location of the pointing device and the item representations when the pointer is being moved in the user interface as well as when the pointer is hovered over an area on the user interface. By keeping the distance or gap between the item representations and the pointer the item representations can be kept clear of the area that is directly under and or immediately around the current location of the pointer thus the user can have a better view of the area before deciding to move or drop items to that location.

The above examples are merely illustrative. Although a particular sequence of events are shown as can be easily understood by a person skilled in the art that selection of items the viewing configurations of the container windows and the movement of the pointer from location to location can have many variations.

In some implementations as illustrated in the above examples each source container object e.g. folder window in and application window in can define one or more appearance styles for item representations that are displayed inside the source container. The different appearance styles can be triggered and applied to the item representations upon the occurrence of different trigger events. Example trigger events can be the hovering of the item representations over defined locations in the container object the movement of the item representation according to a defined movement pattern or in a defined direction a user input changing the current appearance style associated with the container object and so on.

In some implementations each source container can also define one or more appearance styles for item representations when the item representations are moved out of the source container object and onto an area of an ineligible drop target container. The source container can define different appearance styles for the item representations when the item representations are over different ineligible drop target containers.

In some implementations each potential drop target container can also define one or more appearance styles when item representations are moved into the drop zone of the potential drop target container. Each of the appearance styles can also have different trigger events and when the trigger event of a particular appearance style is detected the appearance style associated with that trigger event can be applied to the item representations that have entered the drop zone of the potential drop target container. In the above examples the list view appearances of the item representations in the cluster shown in and the large icon appearances of the item representations in the cluster shown in are examples of the appearance styles applied to the item representations.

In some implementations each appearance style can specify one or more layers for an item representation. Each layer can correspond to a component e.g. an icon image a text label etc. of the item representation. Each layer can have one or more associated properties that control the location size color and other appearance properties of the layer. Each layer can also be associated with properties that control the animation style of the component when the item representation is changed from one appearance to another appearance. The properties associated with different layers of an item representation can be different from one another.

In some implementations the appearance styles provided by different container objects can have different number of layers. Each layer can also be associated with properties that specify how the layer can be introduced or removed from the item representation when the item representation is changing its appearances according to the different appearance styles. For example the text label layer can have an associated property that specifies the animation style e.g. pop up fade in slide in from the left etc. of how the text label can be added to the item representation. For another example the text label layer can have another associated property that specifies the animation style e.g. fade out shimmer out slide out to the right etc. of how the text label can be removed from the item representation.

Each source container object can also define one or more formation styles for the item representations that are currently presented in the container object and or in proximity to the pointer over an ineligible drop target. Examples of the formation can be a free arranged layout of the item representations in a container a clustered configuration of the item representations displayed in proximity to the current location of the pointer a keep arranged layout in a list a keep arranged layout in one or more columns and so on. Similarly each potential drop target container can also define one or more formation styles for the item representations when the item representations have entered the drop zone of the potential drop target container. For example the preview formation that shows the item representations in proximity to their respective expected locations in the potential drop target container can be implemented according to the formation style specified by the potential drop target container.

As described herein the appearance styles and formation styles associated with each container object can be specified according to an API by the container object. The different appearances of the item representations and the different formations of a collection of item representations can be generated by the operating system according to the different appearance styles and formation styles of the relevant source container object and or potential drop target container s . The operating system can determine which appearance style and or formation style to apply to the item representations based on which trigger events associated with the different appearance styles and formation styles are currently present or detected by the operating system. Animations showing the transitions from one appearance to another appearance and from one formation to another formation can be presented by the operating system according to the properties associated with the appearance styles and formation styles.

In the exemplary process an input is received . The input can be a movement of a pointer initiating an operation e.g. a dragging operating on one or more selected items in a user interface. In response to the input the operating system can cause an animation to be presented. In the animation respective representations of the one or more selected items can be moved from the items respective original locations in the user interface toward a current location of a pointer in the user interface and forming a cluster in proximity to the current location of the pointer .

In some implementations the cluster includes the representations of the one or more selected items arranged in a stack. In some implementations the cluster is expandable to show individual representations of the selected items in response to a defined input command. In some implementations motions of the items representations in the user interface are asynchronous.

In some implementations in the exemplary process the operating system can cause a count indicator to be presented in proximity to the cluster the count indicator showing a count of item representations in the cluster.

In some implementations the pointer in the user interface is a finger or stylus on a touch sensitive display. In some implementations the pointer in the user interface is a cursor of a mouse a track ball a finger or stylus on a touch sensitive surface. In some implementations respective locations of the items representations are independently variable within a defined range in the cluster.

In some implementations each item representation in the cluster can move along a path that is independent of respective paths of other item representations in the cluster while following the continued movement of the pointer. In some implementations each item representation in the cluster can move at a different speed than other item representations in the cluster while following the continued movement of the pointer.

In some implementations the one or more items were selected from a first container in the user interface and each item s representation has a respective first appearance associated with the first container. In the process the current location of the pointer can be detected within a drop zone of a second container in the user interface . While the current location of the pointer remains within the drop zone of the second container the operating system can cause the representations of the selected items to adopt respective second appearances where the respective second appearances resemble respective anticipated appearances of the items representations if the items were to be dropped into the second container .

In some implementations each of the first container and the second container is one of a desktop or a window on the desktop each of the first container and the second container is associated with a large icon view a small icon view a list view a column view or a picture view respectively and each of the views is in either a free arranged state or a keep arranged state.

In some implementations at least one of the first container and the second container is an application window and the application window is operable to present the selected items in an application defined view. In some implementations the application defined view of the selected items are defined through an application programming interface API associated with the user interface.

In the exemplary process an input requesting a preview of the items representations being dropped in the second container can be detected . In response to detecting the input the operating system can animate the representations of the selected items to depart from the cluster and move toward their respective anticipated locations in the second container where the respective anticipated locations are locations the representations would have if the items were to be dropped in the second container . In some implementations the input requesting the preview is an extended hovering of the pointer over the drop zone of the second container.

In some implementations the representations of the selected items are displayed at or in proximity to the items respective anticipated locations as respective semi transparent overlays.

In some implementations the anticipated location of at least one of the selected items is in an area of the second container that is not currently visible in the user interface and the representation of the at least one item departs from the cluster and moves into the invisible area of the second container along a respective path in the user interface.

In the exemplary process an input releasing the one or more selected items into the drop zone of the second container can be detected . In response to the releasing input the operating system can cause the one or more selected items to be inserted at the respective anticipated locations of the selected items in the second container .

In some implementations for item representations having their respective anticipated locations within a visible area of the second container the item representations can change from a semi transparent state to an opaque state upon completion of the items insertion into the item s respective anticipated locations.

In the exemplary process a movement of the pointer exiting the second container can be detected . In response to the movement exiting the second container the operating system can animate respective representations of the one or more selected items to move from the items respective anticipated locations in the second container toward the current location of the pointer and to rejoin the cluster in proximity to the current location of the pointer .

In the exemplary process the operating system can monitor a motion characteristic of the pointer for dragging the representations of the one or more selected items in the user interface . The operating system can cause the representations of the selected items to adopt the respective second appearances upon determination that the motion characteristic of the pointer over the drop zone of the second container satisfies a defined criterion . In some implementations the motion characteristic of the pointer is one or more of a speed and an acceleration of the pointer and the defined criterion specifies characteristic values of the speed or the acceleration that would cause the items representations to adopt their respective second appearances. In some implementations the characteristic values of the speed or the acceleration are user specified values.

In the exemplary process an input dragging respective representations of one or more selected items from a first container into a drop zone of a second container can be received where the respective representation of each item has a respective first appearance associated with the first container . While the respective representations of the one or more selected items are at least partially within the drop zone of the second container the operating system can cause the representations of the selected items to adopt respective second appearances where the respective second appearances imitate anticipated appearances of the items representations if the items were to be dropped into the second container .

In some implementations the respective first appearance of each item is defined through an application programming interface API by the first container and the respective second appearance of each item is defined through the API by the second container.

In some implementations the representation of each item includes two or more layers for at least one of the item s first and second appearances and the respective representations of the one or more selected items can be animated to illustrate a respective transition from the items first appearances to the items second appearances where a respective animation is performed on each of the two or more layers to illustrate the transition.

In some implementations each of the two or more layers is associated with a respective animation style for the respective animation performed on the layer.

In some implementations while the respective representations of the one or more selected items are at least partially within an area of an ineligible drop target the representations of the selected items can be caused to adopt respective third appearances associated with the first container. In some implementations the respective third appearances are defined through an application programming interface API by the first container.

In some implementations the respective representations of the selected items are in a first formation when shown in their respective first appearances and the respective representations of the selected items are in a second formation when shown in their respective second appearances where the first formation is defined by the first container and the second formation is defined by the second container through an application programming interface API .

Services layer can provide various graphics animations and UI services to support the graphical functions of the drag and drop UI modification engine and applications e.g. the email editor application in applications layer . In some implementations services layer can also include a touch model for interpreting and mapping raw touch data from a touch sensitive device to touch events e.g. gestures rotations which can be accessed by applications using call conventions defined in a touch model API. Services layer can also include communications software stacks for wireless communications.

OS layer can be a complete operating system e.g. MAC OS or a kernel e.g. UNIX kernel . Hardware layer includes hardware necessary to perform the tasks described in reference to including but not limited to processors or processing cores including application and communication baseband processors dedicated signal image processors ASICs graphics processors e.g. GNUs memory and storage devices communication ports and devices peripherals etc.

One or more Application Programming Interfaces APIs may be used in some implementations. An API is an interface implemented by a program code component or hardware component hereinafter API implementing component that allows a different program code component or hardware component hereinafter API calling component to access and use one or more functions methods procedures data structures classes and or other services provided by the API implementing component. An API can define one or more parameters that are passed between the API calling component and the API implementing component.

An API allows a developer of an API calling component which may be a third party developer to leverage specified features provided by an API implementing component. There may be one API calling component or there may be more than one such component. An API can be a source code interface that a computer system or program library provides in order to support requests for services from an application. An operating system OS can have multiple APIs to allow applications running on the OS to call one or more of those APIs and a service such as a program library can have multiple APIs to allow an application that uses the service to call one or more of those APIs. An API can be specified in terms of a programming language that can be interpreted or compiled when an application is built.

In some implementations the API implementing component may provide more than one API each providing a different view of or with different aspects that access different aspects of the functionality implemented by the API implementing component. For example one API of an API implementing component can provide a first set of functions and can be exposed to third party developers and another API of the API implementing component can be hidden not exposed and provide a subset of the first set of functions and also provide another set of functions such as testing or debugging functions which are not in the first set of functions. In other implementations the API implementing component may itself call one or more other components via an underlying API and thus be both an API calling component and an API implementing component.

An API defines the language and parameters that API calling components use when accessing and using specified features of the API implementing component. For example an API calling component accesses the specified features of the API implementing component through one or more API calls or invocations embodied for example by function or method calls exposed by the API and passes data and control information using parameters via the API calls or invocations. The API implementing component may return a value through the API in response to an API call from an API calling component. While the API defines the syntax and result of an API call e.g. how to invoke the API call and what the API call does the API may not reveal how the API call accomplishes the function specified by the API call. Various API calls are transferred via the one or more application programming interfaces between the calling API calling component and an API implementing component. Transferring the API calls may include issuing initiating invoking calling receiving returning or responding to the function calls or messages in other words transferring can describe actions by either of the API calling component or the API implementing component. The function calls or other invocations of the API may send or receive one or more parameters through a parameter list or other structure. A parameter can be a constant key data structure object object class variable data type pointer array list or a pointer to a function or method or another way to reference a data or other item to be passed via the API.

Furthermore data types or classes may be provided by the API and implemented by the API implementing component. Thus the API calling component may declare variables use pointers to use or instantiate constant values of such types or classes by using definitions provided in the API.

Generally an API can be used to access a service or data provided by the API implementing component or to initiate performance of an operation or computation provided by the API implementing component. By way of example the API implementing component and the API calling component may each be any one of an operating system a library a device driver an API an application program or other module it should be understood that the API implementing component and the API calling component may be the same or different type of module from each other . API implementing components may in some cases be embodied at least in part in firmware microcode or other hardware logic. In some implementations an API may allow a client program to use the services provided by a Software Development Kit SDK library. In other implementations an application or other client program may use an API provided by an Application Framework. In these implementations the application or client program may incorporate calls to functions or methods provided by the SDK and provided by the API or use data types or objects defined in the SDK and provided by the API. An Application Framework may in these implementations provide a main event loop for a program that responds to various events defined by the Framework. The API allows the application to specify the events and the responses to the events using the Application Framework. In some implementations an API call can report to an application the capabilities or state of a hardware device including those related to aspects such as input capabilities and state output capabilities and state processing capability power state storage capacity and state communications capability etc. and the API may be implemented in part by firmware microcode or other low level logic that executes in part on the hardware component.

The API calling component may be a local component i.e. on the same data processing system as the API implementing component or a remote component i.e. on a different data processing system from the API implementing component that communicates with the API implementing component through the API over a network. It should be understood that an API implementing component may also act as an API calling component i.e. it may make API calls to an API exposed by a different API implementing component and an API calling component may also act as an API implementing component by implementing an API that is exposed to a different API calling component.

The API may allow multiple API calling components written in different programming languages to communicate with the API implementing component thus the API may include features for translating calls and returns between the API implementing component and the API calling component however the API may be implemented in terms of a specific programming language. An API calling component can in one embedment call APIs from different providers such as a set of APIs from an OS provider and another set of APIs from a plug in provider and another set of APIs from another provider e.g. the provider of a software library or creator of the another set of APIs.

It will be appreciated that the API implementing component may include additional functions methods classes data structures and or other features that are not specified through the API and are not available to the API calling component . It should be understood that the API calling component may be on the same system as the API implementing component or may be located remotely and accesses the API implementing component using the API over a network. While illustrates a single API calling component interacting with the API it should be understood that other API calling components which may be written in different languages or the same language than the API calling component may use the API .

The API implementing component the API and the API calling component may be stored in a machine readable medium which includes any mechanism for storing information in a form readable by a machine e.g. a computer or other data processing system . For example a machine readable medium includes magnetic disks optical disks random access memory read only memory flash memory devices etc.

In Software Stack an exemplary implementation applications can make calls to Service A or Service B using several Service APIs Service API A and Service API B and to Operating System OS using several OS APIs. Service A and service B can make calls to OS using several OS APIs.

Note that the Service B has two APIs one of which Service B API A receives calls from and returns values to Application A and the other Service B API B receives calls from and returns values to Application B . Service A which can be for example a software library makes calls to and receives returned values from OS API A and Service B which can be for example a software library makes calls to and receives returned values from both OS API A and OS API B . Application B makes calls to and receives returned values from OS API B .

Sensors devices and subsystems can be coupled to peripherals interface to facilitate multiple functionalities. For example motion sensor light sensor and proximity sensor can be coupled to peripherals interface to facilitate orientation lighting and proximity functions of the mobile device. Location processor e.g. GPS receiver can be connected to peripherals interface to provide geopositioning. Electronic magnetometer e.g. an integrated circuit chip can also be connected to peripherals interface to provide data that can be used to determine the direction of magnetic North. Thus electronic magnetometer can be used as an electronic compass. Accelerometer can also be connected to peripherals interface to provide data that can be used to determine change of speed and direction of movement of the mobile device.

Camera subsystem and an optical sensor e.g. a charged coupled device CCD or a complementary metal oxide semiconductor CMOS optical sensor can be utilized to facilitate camera functions such as recording photographs and video clips.

Communication functions can be facilitated through one or more wireless communication subsystems which can include radio frequency receivers and transmitters and or optical e.g. infrared receivers and transmitters. The specific design and implementation of the communication subsystem can depend on the communication network s over which a mobile device is intended to operate. For example a mobile device can include communication subsystems designed to operate over a GSM network a GPRS network an EDGE network a Wi Fi or WiMax network and a Bluetooth network. In particular the wireless communication subsystems can include hosting protocols such that the mobile device can be configured as a base station for other wireless devices.

Audio subsystem can be coupled to a speaker and a microphone to facilitate voice enabled functions such as voice recognition voice replication digital recording and telephony functions.

I O subsystem can include touch screen controller and or other input controller s . Touch screen controller can be coupled to a touch screen or pad. Touch screen and touch screen controller can for example detect contact and movement or break thereof using any of a plurality of touch sensitivity technologies including but not limited to capacitive resistive infrared and surface acoustic wave technologies as well as other proximity sensor arrays or other elements for determining one or more points of contact with touch screen .

Other input controller s can be coupled to other input control devices such as one or more buttons rocker switches thumb wheel infrared port USB port and or a pointer device such as a stylus. The one or more buttons not shown can include an up down button for volume control of speaker and or microphone .

In one implementation a pressing of the button for a first duration may disengage a lock of the touch screen and a pressing of the button for a second duration that is longer than the first duration may turn power to the device on or off. The user may be able to customize a functionality of one or more of the buttons. The touch screen can for example also be used to implement virtual or soft buttons and or a keyboard.

In some implementations the device can present recorded audio and or video files such as MP3 AAC and MPEG files. In some implementations the device can include the functionality of an MP3 player such as an iPod . The device may therefore include a pin connector that is compatible with the iPod. Other input output and control devices can also be used.

Memory interface can be coupled to memory . Memory can include high speed random access memory and or non volatile memory such as one or more magnetic disk storage devices one or more optical storage devices and or flash memory e.g. NAND NOR . Memory can store operating system such as Darwin RTXC LINUX UNIX OS X WINDOWS or an embedded operating system such as VxWorks. Operating system may include instructions for handling basic system services and for performing hardware dependent tasks. In some implementations operating system can include a kernel e.g. UNIX kernel .

Memory may also store communication instructions to facilitate communicating with one or more additional devices one or more computers and or one or more servers. Memory may include graphical user interface instructions to facilitate graphic user interface processing sensor processing instructions to facilitate sensor related processing and functions phone instructions to facilitate phone related processes and functions electronic messaging instructions to facilitate electronic messaging related processes and functions web browsing instructions to facilitate web browsing related processes and functions media processing instructions to facilitate media processing related processes and functions GPS Navigation instructions to facilitate GPS and navigation related processes and instructions and camera instructions to facilitate camera related processes and functions. The memory may also store other software instructions not shown such as security instructions web video instructions to facilitate web video related processes and functions and or web shopping instructions to facilitate web shopping related processes and functions. In some implementations the media processing instructions are divided into audio processing instructions and video processing instructions to facilitate audio processing related processes and functions and video processing related processes and functions respectively. An activation record and International Mobile Equipment Identity IMEI or similar hardware identifier can also be stored in memory . Memory can also include other instructions .

Each of the above identified instructions and applications can correspond to a set of instructions for performing one or more functions described above. These instructions need not be implemented as separate software programs procedures or modules. Memory can include additional instructions or fewer instructions. Furthermore various functions of the mobile device may be implemented in hardware and or in software including in one or more signal processing and or application specific integrated circuits.

The features described can be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. The features can be implemented in a computer program product tangibly embodied in an information carrier e.g. in a machine readable storage device for execution by a programmable processor and method steps can be performed by a programmable processor executing a program of instructions to perform functions of the described implementations by operating on input data and generating output.

The described features can be implemented advantageously in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from and to transmit data and instructions to a data storage system at least one input device and at least one output device. A computer program is a set of instructions that can be used directly or indirectly in a computer to perform a certain activity or bring about a certain result. A computer program can be written in any form of programming language e.g. Objective C Java including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment.

Suitable processors for the execution of a program of instructions include by way of example both general and special purpose microprocessors and the sole processor or one of multiple processors or cores of any kind of computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memories for storing instructions and data. Generally a computer will also include or be operatively coupled to communicate with one or more mass storage devices for storing data files such devices include magnetic disks such as internal hard disks and removable disks magneto optical disks and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices such as EPROM EEPROM and flash memory devices magnetic disks such as internal hard disks and removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in ASICs application specific integrated circuits .

To provide for interaction with a user the features can be implemented on a computer having a display device such as a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard a mouse or a trackball or a pointing device e.g. a finger or stylus on a touch sensitive surface or touch sensitive display by which the user can provide input to the computer.

The features can be implemented in a computer system that includes a back end component such as a data server or that includes a middleware component such as an application server or an Internet server or that includes a front end component such as a client computer having a graphical user interface or an Internet browser or any combination of them. The components of the system can be connected by any form or medium of digital data communication such as a communication network. Examples of communication networks include e.g. a LAN a WAN and the computers and networks forming the Internet.

The computer system can include clients and servers. A client and server are generally remote from each other and typically interact through a network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

One or more features or steps as disclosed herein can be implemented using an API. An API can define on or more parameters that are passed between a calling application and other software code e.g. an operating system library routine function that provides a service that provides data or that performs an operation or a computation.

The API can be implemented as one or more calls in program code that send or receive one or more parameters through a parameter list or other structure based on a call convention defined in an API specification document. A parameter can be a constant a key a data structure an object an object class a variable a data type a pointer an array a list or another call. API calls and parameters can be implemented in any programming language. The programming language can define the vocabulary and calling convention that a programmer will employ to access functions supporting the API.

In some implementations an API call can report to an application the capabilities of a device running the application such as input capability output capability processing capability power capability communications capability etc.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be made. For example elements of one or more implementations may be combined deleted modified or supplemented to form further implementations. As yet another example the logic flows depicted in the figures do not require the particular order shown or sequential order to achieve desirable results. In addition other steps may be provided or steps may be eliminated from the described flows and other components may be added to or removed from the described systems. Accordingly other implementations are within the scope of the following claims.

