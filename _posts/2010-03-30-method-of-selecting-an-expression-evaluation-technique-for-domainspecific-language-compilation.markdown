---

title: Method of selecting an expression evaluation technique for domain-specific language compilation
abstract: A method and computer program product for selecting an expression evaluation technique for domain-specific language (DSL) compilation. An application written in DSL for a programming task is provided, the application including a plurality of components configured by expressions. A technique that most quickly implements the programming task is selected from a plurality of techniques for evaluating the expressions. The DSL application is compiled in accordance with the selected expression evaluation technique to generate general-purpose programming language (GPL) code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08495595&OS=08495595&RS=08495595
owner: International Business Machines Corporation
number: 08495595
owner_city: Armonk
owner_country: US
publication_date: 20100330
---
This invention was made with Government support under Contract No. H98230 07 C 0383 awarded by the U.S. Department of Defense. The Government has certain rights in this invention.

In software development a domain specific language DSL is a programming language or specification language dedicated to a particular problem domain a particular problem representation technique and or a particular solution technique. DSLs are compiled into general purpose programming languages for example C or JAVA for speed and portability since many general purpose programming languages have a large body of existing technology and tools already invested in them.

In accordance with an exemplary embodiment of the present invention provided is a framework for evaluating time tradeoffs of differing domain specific language DSL compilation approaches thereby enabling a programming task to be paired with a DSL compilation approach best suited for saving time.

Exemplary embodiments of the present invention provide a method and computer program product for selecting an expression evaluation technique for DSL compilation. An application written in DSL for a programming task is provided received the application including a plurality of components configured by expressions. A technique that most quickly implements the programming task is selected from a plurality of techniques for evaluating the expressions. The DSL application is compiled in accordance with the selected expression evaluation technique to generate general purpose programming language GPL code.

An aspect of compiling a domain specific language DSL application down to a general purpose programming language GPL e.g. code generation is its interplay with expression evaluation. Expression evaluation is a fundamental part in compiling component based applications written using DSLs. Such applications have a large number of reusable components that are configured via expressions. Such expressions are evaluated during execution time. There are various techniques to achieve expression evaluation with varying amounts of work done at compile time versus start up time versus run time. Application of these different techniques may result in different time trade offs where more or less time is spent at each of these steps.

In this disclosure provided is a framework for evaluating expressions in DSLs wherein depending on the context and task at hand different approaches can be selected as the expression evaluation strategy to optimize time trade offs involved in development and deployment of applications written in DSLs. The time trade offs include but are not limited to time to compile e.g. time taken to compile the DSL application down to machine code time to start up e.g. time taken to load the DSL application and make it ready for execution and time to run e.g. time taken to complete a task once the application is started.

In the following description stream processing will be used as the target domain and SPADE as the target domain specific programming language. However the present invention is not limited thereto. SPADE stands for Stream Processing Application Declarative Engine a programming language and compilation infrastructure specifically built for streaming systems. The SPADE programming model is more fully described by Gedik et al. in SPADE The System S Declarative Stream Processing Engine SIGMOD Conference 2008 1123 1134. SPADE is also referred to as the Stream Processing Language SPL . Embodiments of the invention may be used with the INFOSPHERE STREAMS stream processing system commercially available from International Business Machines Corporation of Armonk N.Y.

Stream computing is an emerging paradigm of computation that is targeted at coping with large numbers of information sources and high rates of events typically produced live. It consists of assimilating data readings that are streams of events analyzing the streaming data on the fly and producing actionable results possibly in stream format as well. This represents a move away from the store and then process model of traditional data management systems toward the on the fly processing of near real time data.

In a stream processing system applications take the form of data flow graphs. A data flow graph consists of operators interconnected by streams. The individual operators implement algorithms for data analysis such as parsing filtering feature extraction and classification.

SPADE is a rapid application development language for building stream processing applications. It provides three key functionalities.

One it is a language that composes parameterizable distributed stream processing applications in the form of data flow graphs. The SPADE language provides a stream centric operator level programming model that is used to compose operators into logical data flow graphs by configuring each operator via custom expressions and connecting them to each other via streams.

Two it is a type generic streaming operator model which captures the fundamental concepts associated with streaming applications such as windows on input stream aggregation functions on windows output attribute assignments punctuation markers in streams etc. SPADE comes with a stream relational toolkit of operators which implement relational algebra like operations in the streaming context.

Three it provides support for extending the language with new type generic highly configurable and reusable operators. This enables third parties to create application or domain specific toolkits of operators.

An example SPADE application is illustrated by the program above and a simple graph consisting of three operators namely two Source operators and a Join operator shown in . A few properties of this application which are relevant to the present invention will now be noted.

First this is a component based application where operators serve as components. An important aspect of component based applications is reuse where the same component is used in different contexts. An example of this is the TCPSource operator that is used twice in the above SPADE program.

Second in component based applications individual components are usually parameterizable and their different instances could be configured differently. In the above SPADE program the two TCPSource operators are actually instances of a common TCPSource operator which are configured differently via the address and port parameters.

Third configuration of components involves parameterization via expressions. In the above SPADE program the instance of the Join operator is configured via a match parameter that specifies an expression to indicate the conditions under which pairs of data items are considered matching from the perspective of this Join operator instance.

The expressions that are used to configure different operators in SPADE or any other DSL compiled down to a GPL are evaluated during execution time. There are various ways of achieving this as will be enumerated shortly. Different approaches to expression evaluation have different characteristics in terms of the time spent performing various stages of getting an application to run. These include the following.

Time to compile. This is a major concern if the program changes often and has to be recompiled frequently. For example in the context of SPADE and streaming applications compilation time becomes a crucial factor during application development. This is because the process of development involves making frequent changes and testing the impact of those changes triggering the rebuilding of the application.

Time to start up. This is a major concern in applications that need to be launched often to adapt to changes in the workload characteristics or application level configuration parameters. For example in the context of SPADE and streaming applications start up time becomes a crucial factor for dynamic load balancing where more instances of an application or application components are brought up dynamically to adapt to varying system load and stream rates.

Time to run. This is a major concern if performance is a critical part of the requirements of an application. In the context of SPADE and streaming applications the long running nature of tasks diminishes the importance of time it takes to compile in many deployment scenarios whereas the runtime performance of the application is a critical aspect for low latency high throughput applications.

Hereinafter several techniques for evaluating expressions according to the present invention will now be described. These techniques are exemplified using the SPADE language.

In the first expression evaluation technique according to an exemplary embodiment of the present invention hereinafter referred to as the embed technique expressions are compiled into native processor instructions and then executed by the processor s hardware at run time.

For example as shown in in response to providing an application written in DSL wherein the application includes components configured via expressions expressions that are used to parameterize the components are directly embedded into the code generated by compiling the DSL application down to a GPL . Although a component based system where components are configured via expressions is discussed here the DSL application does not necessarily include only expressions thus there could be other kinds of code generated based on the DSL application. Then the generated code is compiled into native instructions via the GPL s compiler . From the time to run perspective this is an effective approach as the expressions are executed natively by the processor s hardware. However this is a costly solution in terms of time to compile. To see this consider the following two SPADE operator instances 

In this example a DSL compiler in this case the SPADE compiler ends up generating code that looks slightly different for these two operator instances due to the differing literal values 50 and 60 in the filter expressions A.price 50 and A.price 60 . In an application where there are a large number of such expressions differing slightly from each other the amount of code generated and thus the time it takes to compile the generated code into native instructions can potentially be very long.

In the second expression evaluation technique according to an exemplary embodiment of the present invention hereinafter referred to as the fold embed technique as shown in in response to providing a component based application written in DSL parts of expressions that do not require knowledge of run time values are partially evaluated at compile time . The resulting partially evaluated expressions are then compiled into native processor instructions and executed by the processor s hardware at run time .

This is an improvement over the embed technique wherein sub expressions are evaluated at compile time and replaced with their literal values before being embedded into the generated code. Because of the additional semantic knowledge available to the DSL compiler it can be advantageous to perform this optimization before generating the code to be compiled by the target language compiler. This approach may improve time to run over the embed technique but at the cost of further increasing the time to compile. Take the following SPADE example.

In this example the SPADE compiler is able to convert the filter expression into port0.get price 64 and embed that into the generated code C in SPADE s case . Here a function call is simplified into a literal which can be done as long as the function is pure. Note that the function always evaluates to the same result values given the same argument value s and evaluation of the result does not cause any semantically observable side effect or output. Overall this approach suffers from the same deficiency of the previous one long time to compile as it results in generating different code for expressions that only differ in their literal sub expressions. On the other hand it is even faster than the previous approach in terms of time to run due to compile time evaluation of sub expressions that do not depend on run time values.

An expression can be seen as a tree and some of its branches are fully evaluated. Any branch that contains fully evaluated as well as non evaluated partially evaluated branches would be considered partially evaluated.

In the above example the branches marked by are fully evaluated. So 3 4 is fully evaluated and 5 6 is fully evaluated. However b 5 6 is partially evaluated yet it is part of the whole expression. Thus parts of the expressions themselves can be considered partially evaluated.

In the third expression evaluation technique according to an exemplary embodiment of the present invention hereinafter referred to as the fold extract technique as shown in in response to providing a component based application written in DSL parts of expressions that do not require knowledge of run time values are partially evaluated at compile time . Also occurring at compile time the evaluated sub expressions are replaced with placeholder variables whose values will be loaded at run time . The resulting partially evaluated expressions and the code to load up the values of the placeholder variables contained within those expression are compiled into native processor instructions and are executed by the processor s hardware at run time . In this embodiment the values of the placeholder variables are treated as input and are assigned to the placeholder variables at run time during application start up.

This is an extension of the fold embed technique wherein the fundamental constraint with respect to compilation time is alleviated by factoring out the literal values contained in the partially evaluated expressions by replacing them with variables. The values of the literals are carried through as input and are loaded into their corresponding variables at run time. Take the following SPADE example 

The filter expressions in the above operator instances will be replaced with A.price v1 v1 64 and A.price v1 v1 32 respectively.

The first part A.price v1 is the partially evaluated expression that has its literals replaced with variables. This expression will be directly embedded into the generated GPL code. Here both operator instances will share the exact same code thus the compilation time can be cut in half in this particular example. The second part v1 64 is the list of literals extracted from the expression and the names of the variables they are replaced with. This information will be loaded at run time so that the variables can be initialized. In summary the generated C code might look like as follows 

The fold extract approach can be further improved by putting all expressions into a normalized order such that the structural differences in expressions do not always render the optimizations useless. For instance 

In the above example note the re ordering in bold is performed to put the first expression in the same order as the second one taking advantage of commutativity of the addition operator. While this helps with increasing the number of cases where code sharing can be applied ultimately this approach cannot handle expressions that differ in their operations non literal symbols or in their normalized structure. An example is 3 5

These expressions cannot be put into the same form thus they cannot share code. In summary compared to the embed technique and the fold embed technique this approach incurs significantly less overhead in terms of time to compile whereas it performs equally well in terms of time to run due to reliance on native instructions for evaluating the expressions. On the other hand it might slightly increase the time to start up due to the loading of the literals.

In the fourth expression evaluation technique according to an exemplary embodiment of the present invention hereinafter referred to as the interpret technique as shown in the expressions of a component based application written in DSL are treated as input . At run time the expressions are loaded and executed using an interpreter .

This approach strives for minimizing the time to compile. In that regard it treats a complete expression as input to an interpreter which evaluates the expressions at run time via interpretation. This involves parsing the expression at run time and walking the resulting tree representing the expression and evaluating it whenever necessary. This also involves reading the run time values that the expression depends on. The parsing aspect does not need to be repeated and can be done once per expression. Here is a SPADE example 

Using the interpret technique this expression will be replaced with a placeholder variable and a call to an evaluation function in the interpreter where the value of the placeholder variable is the string form of the expression and is loaded at run time. More concretely the generated C code may look like the following 

Here ituples is a list of input tuples one from each port A and B in the above example and otuple is the output tuple to be populated based on the output attribute assignment expression.

The advantage of this approach is that no matter what the assignment looks like for the output attributes the generated code will look that same. However executing the expressions involves making a call to the function Evaluate which is an interpreter.

In summary this approach achieves minimal time to compile but has a high cost in terms of time to run. Compared to other approaches time to start is also relatively high due to the required loading of expression strings as well as the need for parsing them.

In the fifth expression evaluation technique according to an exemplary embodiment of the present invention hereinafter referred to as the jit compile technique as shown in the expressions of a component based application written in DSL are treated as input and compiled . At run time the expressions are loaded and native processor instructions are generated via just in time JIT compilation during application start up . The generated code is then executed on the processor s hardware .

This approach improves upon the interpret technique with respect to time to run. The Evaluate function when it is called for the first time for a given expression performs native instruction generation at runtime to make the subsequent calls execute fast by utilizing the processor directly with no interpretation involved. Note that this comes at an increased cost with respect to time to start up as parts of the compilation process are delayed until run time. This approach has good time to compile like the interpret technique and its time to run can be potentially made comparable to that of the fold extract approach even though this requires a large amount of investment in JIT code generation and optimization.

As shown in there is provided a component based application written in DSL for a programming task . The programming task may include but is not limited to performance debugging semantic debugging syntactic debugging deployment performance deployment performance with adaption or deployment performance with mutation. A description of these tasks will be provided later. Next an expression evaluation technique that most quickly implements the programming task based on factors such as time to compile time to start time to run etc. is selected . The selection process may be done manually or automatically. For example a user could reference that illustrates the best expression evaluation technique for the programming task at hand. In another example the user may consult a table such as the one shown in to determine a technique that may work well for many tasks. The selected expression evaluation technique is then incorporated into a DSL compiler . At this time in accordance with the selected expression evaluation technique the application may be compiled down to GPL and translated to machine code loaded and made ready for execution e.g. the application may be started and an application task may be performed e.g. the application may be run .

Performance debugging. This involves finding performance bottlenecks in an application. Like any debugging task it requires a quick compile run cycle which means both time to compile and time to start up are important but since the performance is the main focus of this type of debugging the time to run is also important.

Semantic debugging. This involves finding problems with the application logic thus the time to run is not important whereas a quick compile run cycle is required due to the debugging nature of the task.

Syntactic debugging. This involves finding problems with the syntax of the application code thus the time to run and time to start up are not important whereas a quick compile run cycle is required to check the validity of syntactic changes on the code.

Deployment performance. For long running applications that are performance sensitive time to compile and time to start up are not relevant as they are amortized by the continuous and long running nature of the applications.

Deployment performance with adaptation. When a long running and performance sensitive application also has adaptation requirements such as load balancing under changing workloads dynamically launching more copies of certain pieces may become a necessity. This will elevate the importance of time to start up compared to the case without adaptation.

Deployment performance with mutation. When a long running and performance sensitive application also has mutation requirements such as extensions via new functional pieces dynamically launching modified pieces of the application may become a necessity. This requires recompilations at run time and elevates the importance of decreasing the time to compile.

An implementation of an exemplary embodiment of the present invention may make use of software running on a general purpose computer or workstation. With reference to such an implementation might employ for example a processor a memory and an input and or output interface formed for example by a display and a keyboard . The term processor as used herein is intended to include any processing device such as for example one that includes a central processing unit CPU and or other forms of processing circuitry. Further the term processor may refer to more than one individual processor. The term memory is intended include memory associated with a processor or CPU such as for example RAM ROM a fixed memory device for example hard drive a removable memory device for example diskette a flash memory and the like. In addition the phrase input and or output interface as used herein is intended to include for example one or more mechanisms for inputting data to the processing unit for example mouse and one or more mechanisms for providing results associated with the processing unit for example printer . The processor memory and input and or output interface such as display and keyboard can be interconnected for example via bus as part of a data processing unit . Suitable interconnections for example via bus can also be provided to a network interface such as a network card which can be provided to interface with a computer network and to a media interface such as a diskette or CD ROM drive which can be provided to interface with media .

Accordingly computer software including instructions or code for performing exemplary embodiments of the present invention may be stored in one or more of the associated memory devices for example read only memory ROM fixed or removable memory and when ready to be utilized loaded in part or in whole for example into random access memory RAM and executed by a CPU. Such software could include but is not limited to firmware resident software microcode and the like.

As shown in examples of a computer readable medium having computer readable program code for carrying out aspects of the present invention embodied thereon may include media and memory .

A data processing system suitable for storing and or executing program code may include at least one processor coupled directly or indirectly to memory elements though a system bus . The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code to reduce the number of times code must be retrieved from bulk storage during execution.

Input and or output or I O devices including but not limited to keyboards displays pointing devices and the like can be coupled to the system either directly such as via bus or through intervening I O controllers.

Network adapters such as network interface may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a RAM a ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article or manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical functions s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

