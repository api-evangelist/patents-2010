---

title: Variable length data protected by seqlock
abstract: Various embodiments of systems and methods for variable length data protected by Seqlock are described herein. Seqlock is a special locking mechanism used in data structures for multithreaded applications that can be read very quickly, when there are no changes being made, at the cost of needing to repeat a read operation when writing has occurred. A Seqlock, in normal use, can only protect a fixed-size data structure with no pointers. This is because the writing thread may invalidate a pointer after a reading thread has followed it. The embodiments specify an algorithm where a Seqlock-protected pointer, once written, is never invalidated. This removes the “no pointers” restriction, allowing the Seqlock to protect a simple singly-linked list, which can be safely increased in size while being read by other threads. The innovation includes the use of the write-once head and next pointers, and the always valid end iterator.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08495309&OS=08495309&RS=08495309
owner: Business Objects Software Limited
number: 08495309
owner_city: Dublin
owner_country: IE
publication_date: 20101022
---
The field relates to memory locking mechanisms that avoid the problem of writer starvation. More precisely the field relates to the Sequence Lock seqlock technique with the ability to store variable length data structures.

A seqlock is a special locking mechanism for supporting fast writes of shared variables. It is a reader writer consistent mechanism which avoids the problem of writer starvation. Writer starvation means that as long as at least one reading thread holds the lock no writer thread will be able to acquire it. The seqlock consists of storage for saving a sequence number in addition to the lock. The lock is to support synchronization between two writers and the counter is for indicating consistency in readers. In addition to updating the shared data the writer increments the sequence number both after acquiring the lock and before releasing the lock. Readers read the sequence number before and after reading the shared data. If the sequence number is odd on either occasion that may mean the writer had taken the lock while the data was being read and it may have changed. If the sequence numbers are different that may mean a writer has changed the data while it was being read. In either case readers simply retry using a loop until they read the same even sequence number before and after. The reader never blocks but it may have to retry if a write is in progress this speeds up the readers in the case where the data was not modified since they do not have to acquire the lock as they would with a traditional read write lock. Also writers do not wait for readers whereas with traditional read write locks they do leading to potential resource starvation in a situation where there are a number of readers because the writer must wait for there to be no readers . Because of these two factors seqlocks are more efficient than traditional read write locks for the situation where there are many readers and few writers. The drawback is that if there is too much write activity or the reader is too slow in this case the readers may starve. It should also be noted that the technique will not work for data that contains pointers because any writer could invalidate a pointer that a reader has already followed.

Various embodiments of systems and methods for variable length data protected by seqlock are described herein. In one embodiment the method includes allocating a first portion of memory to be protected by a lock mechanism for synchronization between writers and an associated sequence number for indicating consistency to readers of the first portion of memory. The method also includes initializing a set of pointers within the first portion of memory to null pointers and initializing a pointer within the set of pointers the pointer pointing to a second portion of memory forming a linked list.

In other embodiments the system includes at least one processor for executing program code and memory for storing data structures with pointers. The system further includes a seqlock allocator module within the memory the seqlock allocator module to allocate portions of memory to be protected by a lock mechanism and an associated sequence number wherein the lock mechanism supports synchronization between one or more writers accessing the allocated portions of memory and the associated sequence number indicates consistency to one or more readers of the allocated portions of memory. The system also includes a pointer initializer module within the memory the pointer initializer module to initialize all pointers within the allocated portions of memory.

These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof presented in connection with the following drawings.

Embodiments of techniques for variable length data protected by seqlock are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

The conventional seqlock technique is unable to store data structures which include pointers to other memory thus limiting the capacity of the data to a fixed size of data. An iterator is an object that allows a programmer to traverse through all the elements of a collection regardless of its specific implementation thus performing reading of data. An end iterator is a special pointer which refers to one past the end of a valid data structure. represents a block diagram of a typical collection of valid data with an end iterator pointing just past the last valid data . As an accessing iterator steps through the collection of data once the accessing iterator has the same value as the end iterator the collection is complete. For an algorithm which steps through the collection of data to work it must be guaranteed that a valid iterator which is repeatedly incremented such as the accessing iterator will eventually be equal to the value of the end iterator . If the list of valid data changes size after the value of the end iterator is retrieved by linking the collection of data to a second collection of data as is typically done in a linked list of arrays implementation for example if a writer thread is appending to the list of valid data while a reader thread is iterating over it the accessing iterator will jump from pointing to data to the first data in the second collection of the list and will never be equal to the end iterator which will cause undefined and undesirable program behavior.

In one embodiment the disadvantage of the conventional seqlock technique of not containing data structures that include pointers is overcome by ensuring that all pointers which are accessed by reader threads are never invalidated by writer threads. This allows the data protected by a seqlock technique to include a linked list of data blocks thus increasing the amount of data that can be stored while retaining its lockless read performance.

At block a set of pointers within the first portion of memory are initialized as null pointers. Initializing a pointer as a null pointer means the pointer is initialized to a fixed value known not to refer to any valid memory address. This means a null pointer does not point to any other portion of memory.

At block a pointer within the set of pointers is initialized the pointer pointing to a second block of memory forming a linked list. In one embodiment the linked list is singly linked. A singly linked list is a data structure that consists of a sequence of data records such that in each record there is a field that contains a reference link to the next record in the sequence. In one embodiment the pointer within the first portion of memory remains unchanged which ensures the second portion of memory is never invalidated. When a pointer to newly allocated portion of memory is written into memory protected by seqlock that memory is never de allocated or used for any other purpose for the duration of the program. Thus all pointers within a linked list protected by a seqlock technique are either a null pointer or a pointer to a memory portion which is valid and will remain valid until the program execution completes. In one embodiment the pointers within a linked list protected by a seqlock technique are referred to as write once pointers. In one embodiment the pointer within a first portion of memory in a linked list is called head pointer and the pointers within the next portions of memory are called next pointers.

In one embodiment the method as described in connection to is performed without a lock for synchronization between writers as there is only one writer to the protected portion of memory and thus no lock mechanism for synchronization between writers is needed.

In one embodiment the method as described in connection to is performed together with an always valid end iterator. An always valid end iterator is an iterator that points to a reserved unit of managed memory which remains valid even if the list of valid data changes size. This ensures that all pointers which are accessed by reader threads are never invalidated by writer threads. In contrast to the conventional seqlock technique where the end iterator is pointing just past the last valid data in the always valid end iterator points to a valid data following a collection of data .

This algorithm works with the always valid end iterator by ensuring that if a reader thread has a copy of the end iterator the end iterator pointing at the last data slot in and while the reader is iterating through the collection if a writer expands the list as in then the end iterator pointing at just past S will always be reached. If the data structure used the typical approach of setting the end iterator in to point to just past S then when an iterator increments from S it would point to the new S and therefore never actually reach the end indicated by the typical not always valid end iterator .

In one embodiment the seqlock technique is performed by an always valid end iterator. An always valid end iterator points to a location in memory which is valid and is either currently in use or may come in use once more items are added to the data structure. This ensures that as an iterator is stepping through the list and being compared with a copy of the data structure s end iterator it will eventually reach the value of the end iterator copy. In a conventional list or list of array data structure when the data structure increases in size after the end iterator is copied no iterator stepping through the list will ever reach that value. This would result in undefined behavior usually a program crash . The outcome is that one or more threads can read from the data structure at the same time as another thread is writing to the data structure with no possibility of invalid iterators or pointers leading to a software crash. In one embodiment the portions of memory protected by the seqlock technique include shared variables between a first parallel operating system routine and a second parallel operating system routine.

Some embodiments of the invention may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment of the invention may be implemented using Java C or other object oriented programming language and development tools. Another embodiment of the invention may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather the scope of the invention is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

