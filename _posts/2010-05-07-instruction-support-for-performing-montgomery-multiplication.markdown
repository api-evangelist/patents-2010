---

title: Instruction support for performing montgomery multiplication
abstract: Techniques are disclosed relating to a processor including instruction support for performing a Montgomery multiplication. The processor may issue, for execution, programmer-selectable instruction from a defined instruction set architecture (ISA). The processor may include an instruction execution unit configured to receive instructions including a first instance of a Montgomery-multiply instruction defined within the ISA. The Montgomery-multiply instruction is executable by the processor to operate on at least operands A, B, and N residing in respective portions of a general-purpose register file of the processor, where at least one of operands A, B, N spans at least two registers of general-purpose register file. The instruction execution unit is configured to calculate P mod N in response to receiving the first instance of the Montgomery-multiply instruction, where P is the product of at least operand A, operand B, and R^âˆ’1.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08583902&OS=08583902&RS=08583902
owner: Oracle International Corporation
number: 08583902
owner_city: Redwood Shores
owner_country: US
publication_date: 20100507
---
This disclosure relates to processors and more particularly to the implementation of processor support for multiple precision arithmetic.

Securing transactions and communications against tampering interception and unauthorized use has become a problem of increasing significance as new forms of electronic commerce and communication proliferate. For example many businesses provide customers with Internet based purchasing mechanisms such as web pages via which customers may convey order and payment details. Such details often include sensitive information that might be subject to misuse if intercepted by a third party.

To provide a measure of security for sensitive data cryptographic algorithms have been developed that may allow encryption of sensitive information before it is conveyed over an insecure channel. The information may then be decrypted and used by the receiver. However as the performance of generally available computer technology continues to increase e.g. due to development of faster microprocessors less sophisticated cryptographic algorithms become increasingly vulnerable to compromise.

Cryptographic algorithms are continually evolving to meet the threat posed by new types of attacks. In particular the use of increased key sizes may help bolster the security of a given algorithm for example by increasing its resistance to a brute force attack. However computational workload can increase dramatically as key sizes increase. For example the use of large key sizes may require an algorithm to perform arithmetic operations on operands that greatly exceed the typical operand size supported by general purpose processor hardware.

Techniques and structures are disclosed herein that allow a processor to provide instruction support for performing a Montgomery multiplication. In one embodiment a processor in disclosed. The processor includes a control unit configured to issue instructions for execution where the instructions are programmer selectable from a defined instruction set architecture ISA . The processor includes a general purpose register file including a plurality of registers. The processor includes an instruction execution unit configured to receive instructions issued by the control unit where the received instructions include a first instance of a Montgomery multiply instruction defined within the ISA. The Montgomery multiply instruction is executable by the processor to operate on at least operands A B and N residing in respective portions of the general purpose register file where at least one of operands A B N spans at least two of the plurality of registers. A size of the respective portions is indicated by a size parameter. The instruction execution unit is configured to calculate P mod N in response to receiving the first instance of the Montgomery multiply instruction. P is the product of at least operand A operand B and R 1 where R is a value based on the size parameter.

In another embodiment a method is disclosed. The method includes a control unit of a processor issuing instructions for execution. The method further includes an instruction execution unit of the processor receiving one or more of the issued instructions including a first instance of a Montgomery multiply instruction defined within an instruction set architecture ISA of the processor. The Montgomery multiply instruction is executable by the processor to operate on operands A B and N residing in respective portions of a general purpose register file of the processor. At least one of operands A B N spans at least two of registers of the general purpose register file where a size of the respective portions is indicated by a size parameter. The method further includes the instruction execution unit calculating P mod N to obtain a result of the first instance of the Montgomery multiply instruction. P is the product of at least operand A operand B and R 1 where R is a value based on the size parameter.

In another embodiment a computer readable storage medium having program instructions stored thereon that are executable by a processor. The program instructions include a first instance of a Montgomery multiply instruction defined within an instruction set architecture ISA of the processor where the Montgomery multiply instruction is executable by the processor to operate on operands A B and N residing in respective portions of a general purpose register file of the processor. At least one of operands A B N spans at least two registers of the general purpose register file where a size of the respective portions is indicated by a size parameter. The first instance of the Montgomery multiply instruction is executable by the processor to calculate P mod N in response to receiving the first instance of the Montgomery multiply instruction. P is the product of at least operand A operand B and R 1 where R is a value based on the size parameter.

While the disclosure is susceptible to various modifications and alternative forms specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood however that the drawings and detailed description thereto are not intended to limit the disclosure to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present disclosure as defined by the appended claims.

In the following discussion instruction support for large operand multiplication and Montgomery multiplication is explored. First an overview is provided of one type of general purpose multithreaded processor in which such instruction support may be provided. Next large operand multiplication is discussed generally. Particular embodiments of a multiplier datapath and control logic pertaining to large operand multiplication are then described as well as embodiments of large operand multiplication instructions and their execution. The disclosure then discusses Montgomery multiplication particular embodiments of a multiplier datapath and control logic pertaining to Montgomery multiplication and then embodiments of Montgomery multiply instructions and their execution. Finally an exemplary system embodiment including a processor that may implement instruction level support for large operand multiplication and or Montgomery multiplication is discussed.

A block diagram illustrating one embodiment of a multithreaded processor is shown in . In the illustrated embodiment processor includes a number of processor cores which are also designated core though core n. Various embodiments of processor may include varying numbers of cores such as 8 16 or any other suitable number. Each of cores is coupled to a corresponding L2 cache which in turn couple to L3 cache via a crossbar . Cores and L2 caches may be generically referred to either collectively or individually as core s and L2 cache s respectively.

Via crossbar and L3 cache cores may be coupled to a variety of devices that may be located externally to processor . In the illustrated embodiment one or more memory interface s may be configured to couple to one or more banks of system memory not shown . One or more coherent processor interface s may be configured to couple processor to other processors e.g. in a multiprocessor environment employing multiple units of processor . Additionally system interconnect couples cores to one or more peripheral interface s and network interface s . As described in greater detail below these interfaces may be configured to couple processor to various peripheral devices and networks.

Cores may be configured to execute instructions and to process data according to a particular instruction set architecture ISA . In one embodiment cores may be configured to implement a version of the SPARC ISA such as SPARC V9 UtraSPARC Architecture 2005 UtraSPARC Architecture 2007 or UtraSPARC Architecture 2009 for example. However in other embodiments it is contemplated that any desired ISA may be employed such as x86 32 bit or 64 bit versions PowerPC or MIPS for example.

In the illustrated embodiment each of cores may be configured to operate independently of the others such that all cores may execute in parallel. Additionally as described below in conjunction with the description of in some embodiments each of cores may be configured to execute multiple threads concurrently where a given thread may include a set of instructions that may execute independently of instructions from another thread. For example an individual software process such as an application may consist of one or more threads that may be scheduled for execution by an operating system. Such a core may also be referred to as a multithreaded MT core. In one embodiment each of cores may be configured to concurrently execute instructions from a variable number of threads up to eight concurrently executing threads. In a 16 core implementation processor could thus concurrently execute up to 128 threads. However in other embodiments it is contemplated that other numbers of cores may be provided and that cores may concurrently process different numbers of threads.

Additionally as described in greater detail below in some embodiments each of cores may be configured to execute certain instructions out of program order which may also be referred to herein as out of order execution or simply OOO. As an example of out of order execution for a particular thread there may be instructions that are subsequent in program order to a given instruction yet do not depend on the given instruction. If execution of the given instruction is delayed for some reason e.g. owing to a cache miss the later instructions may execute before the given instruction completes which may improve overall performance of the executing thread.

As shown in in one embodiment each core may have a dedicated corresponding L2 cache . In one embodiment L2 cache may be configured as a set associative writeback cache that is fully inclusive of first level cache state e.g. instruction and data caches within core . To maintain coherence with first level caches embodiments of L2 cache may implement a reverse directory that maintains a virtual copy of the first level cache tags. L2 cache may implement a coherence protocol e.g. the MESI protocol to maintain coherence with other caches within processor . In one embodiment L2 cache may enforce a Total Store Ordering TSO model of execution in which all store instructions from the same thread must complete in program order.

In various embodiments L2 cache may include a variety of structures configured to support cache functionality and performance. For example L2 cache may include a miss buffer configured to store requests that miss the L2 a fill buffer configured to temporarily store data returning from L3 cache a writeback buffer configured to temporarily store dirty evicted data and snoop copyback data and or a snoop buffer configured to store snoop requests received from L3 cache . In one embodiment L2 cache may implement a history based prefetcher that may attempt to analyze L2 miss behavior and correspondingly generate prefetch requests to L3 cache .

Crossbar may be configured to manage data flow between L2 caches and the shared L3 cache . In one embodiment crossbar may include logic such as multiplexers or a switch fabric for example that allows any L2 cache to access any bank of L3 cache and that conversely allows data to be returned from any L3 bank to any L2 cache . That is crossbar may be configured as an M to N crossbar that allows for generalized point to point communication. However in other embodiments other interconnection schemes may be employed between L2 caches and L3 cache . For example a mesh ring or other suitable topology may be utilized.

Crossbar may be configured to concurrently process data requests from L2 caches to L3 cache as well as data responses from L3 cache to L2 caches . In some embodiments crossbar may include logic to queue data requests and or responses such that requests and responses may not block other activity while waiting for service. Additionally in one embodiment crossbar may be configured to arbitrate conflicts that may occur when multiple L2 caches attempt to access a single bank of L3 cache or vice versa.

L3 cache may be configured to cache instructions and data for use by cores . In the illustrated embodiment L3 cache may be organized into eight separately addressable banks that may each be independently accessed such that in the absence of conflicts each bank may concurrently return data to a respective L2 cache . In some embodiments each individual bank may be implemented using set associative or direct mapped techniques. For example in one embodiment L3 cache may be an 8 megabyte MB cache where each 1 MB bank is 16 way set associative with a 64 byte line size. L3 cache may be implemented in some embodiments as a writeback cache in which written dirty data may not be written to system memory until a corresponding cache line is evicted. However it is contemplated that in other embodiments L3 cache may be configured in any suitable fashion. For example L3 cache may be implemented with more or fewer banks or in a scheme that does not employ independently accessible banks it may employ other bank sizes or cache geometries e.g. different line sizes or degrees of set associativity it may employ write through instead of writeback behavior and it may or may not allocate on a write miss. Other variations of L3 cache configuration are possible and contemplated.

In some embodiments L3 cache may implement queues for requests arriving from and results to be sent to crossbar . Additionally in some embodiments L3 cache may implement a fill buffer configured to store fill data arriving from memory interface a writeback buffer configured to store dirty evicted data to be written to memory and or a miss buffer configured to store L3 cache accesses that cannot be processed as simple cache hits e.g. L3 cache misses cache accesses matching older misses accesses such as atomic operations that may require multiple cache accesses etc. . L3 cache may variously be implemented as single ported or multiported i.e. capable of processing multiple concurrent read and or write accesses . In either case L3 cache may implement arbitration logic to prioritize cache access among various cache read and write requestors.

Not all external accesses from cores necessarily proceed through L3 cache . In the illustrated embodiment non cacheable unit NCU may be configured to process requests from cores for non cacheable data such as data from input output I O devices as described below with respect to peripheral interface s and network interface s .

Memory interface may be configured to manage the transfer of data between L3 cache and system memory for example in response to cache fill requests and data evictions. In some embodiments multiple instances of memory interface may be implemented with each instance configured to control a respective bank of system memory. Memory interface may be configured to interface to any suitable type of system memory such as Fully Buffered Dual Inline Memory Module FB DIMM Double Data Rate or Double Data Rate 2 3 or 4 Synchronous Dynamic Random Access Memory DDR DDR2 DDR3 DDR4 SDRAM or Rambus DRAM RDRAM for example. In some embodiments memory interface may be configured to support interfacing to multiple different types of system memory.

In the illustrated embodiment processor may also be configured to receive data from sources other than system memory. System interconnect may be configured to provide a central interface for such sources to exchange data with cores L2 caches and or L3 cache . In some embodiments system interconnect may be configured to coordinate Direct Memory Access DMA transfers of data to and from system memory. For example via memory interface system interconnect may coordinate DMA transfers between system memory and a network device attached via network interface or between system memory and a peripheral device attached via peripheral interface .

Processor may be configured for use in a multiprocessor environment with other instances of processor or other compatible processors. In the illustrated embodiment coherent processor interface s may be configured to implement high bandwidth direct chip to chip communication between different processors in a manner that preserves memory coherence among the various processors e.g. according to a coherence protocol that governs memory transactions .

Peripheral interface may be configured to coordinate data transfer between processor and one or more peripheral devices. Such peripheral devices may include for example and without limitation storage devices e.g. magnetic or optical media based storage devices including hard drives tape drives compact disc CD drives DVD drives etc. display devices e.g. graphics subsystems multimedia devices e.g. audio processing subsystems or any other suitable type of peripheral device. In one embodiment peripheral interface may implement one or more instances of a standard peripheral interface. For example one embodiment of peripheral interface may implement the Peripheral Component Interface Express PCI Express or PCIe standard according to generation 1.x 2.0 3.0 or another suitable variant of that standard with any suitable number of I O lanes. However it is contemplated that any suitable interface standard or combination of standards may be employed. For example in some embodiments peripheral interface may be configured to implement a version of Universal Serial Bus USB protocol or IEEE 1394 Firewire protocol in addition to or instead of PCI Express .

Network interface may be configured to coordinate data transfer between processor and one or more network devices e.g. networked computer systems or peripherals coupled to processor via a network. In one embodiment network interface may be configured to perform the data processing necessary to implement an Ethernet IEEE 802.3 networking standard such as Gigabit Ethernet or 10 Gigabit Ethernet for example. However it is contemplated that any suitable networking standard may be implemented including forthcoming standards such as 40 Gigabit Ethernet and 100 Gigabit Ethernet. In some embodiments network interface may be configured to implement other types of networking protocols such as Fibre Channel Fibre Channel over Ethernet FCoE Data Center Ethernet Infiniband and or other suitable networking protocols. In some embodiments network interface may be configured to implement multiple discrete network interface ports.

As mentioned above in one embodiment each of cores may be configured for multithreaded out of order execution. More specifically in one embodiment each of cores may be configured to perform dynamic multithreading. Generally speaking under dynamic multithreading the execution resources of cores may be configured to efficiently process varying types of computational workloads that exhibit different performance characteristics and resource requirements. Such workloads may vary across a continuum that emphasizes different combinations of individual thread and multiple thread performance.

At one end of the continuum a computational workload may include a number of independent tasks where completing the aggregate set of tasks within certain performance criteria e.g. an overall number of tasks per second is a more significant factor in system performance than the rate at which any particular task is completed. For example in certain types of server or transaction processing environments there may be a high volume of individual client or customer requests such as web page requests or file system accesses . In this context individual requests may not be particularly sensitive to processor performance. For example requests may be I O bound rather than processor bound completion of an individual request may require I O accesses e.g. to relatively slow memory network or storage devices that dominate the overall time required to complete the request relative to the processor effort involved. Thus a processor that is capable of concurrently processing many such tasks e.g. as independently executing threads may exhibit better performance on such a workload than a processor that emphasizes the performance of only one or a small number of concurrent tasks.

At the other end of the continuum a computational workload may include individual tasks whose performance is highly processor sensitive. For example a task that involves significant mathematical analysis and or transformation e.g. cryptography graphics processing scientific computing may be more processor bound than I O bound. Such tasks may benefit from processors that emphasize single task performance for example through speculative execution and exploitation of instruction level parallelism.

Dynamic multithreading represents an attempt to allocate processor resources in a manner that flexibly adapts to workloads that vary along the continuum described above. In one embodiment cores may be configured to implement fine grained multithreading in which each core may select instructions to execute from among a pool of instructions corresponding to multiple threads such that instructions from different threads may be scheduled to execute adjacently. For example in a pipelined embodiment of core employing fine grained multithreading instructions from different threads may occupy adjacent pipeline stages such that instructions from several threads may be in various stages of execution during a given core processing cycle. Through the use of fine grained multithreading cores may be configured to efficiently process workloads that depend more on concurrent thread processing than individual thread performance.

In one embodiment cores may also be configured to implement out of order processing speculative execution register renaming and or other features that improve the performance of processor dependent workloads. Moreover cores may be configured to dynamically allocate a variety of hardware resources among the threads that are actively executing at a given time such that if fewer threads are executing each individual thread may be able to take advantage of a greater share of the available hardware resources. This may result in increased individual thread performance when fewer threads are executing while retaining the flexibility to support workloads that exhibit a greater number of threads that are less processor dependent in their performance. In various embodiments the resources of a given core that may be dynamically allocated among a varying number of threads may include branch resources e.g. branch predictor structures load store resources e.g. load store buffers and queues instruction completion resources e.g. reorder buffer structures and commit logic instruction issue resources e.g. instruction selection and scheduling structures register rename resources e.g. register mapping tables and or memory management unit resources e.g. translation lookaside buffers page walk resources .

One embodiment of core that is configured to perform dynamic multithreading is illustrated in . In the illustrated embodiment core includes an instruction fetch unit IFU that includes an instruction cache . IFU is coupled to a memory management unit MMU L2 interface and trap logic unit TLU . IFU is additionally coupled to an instruction processing pipeline that begins with a select unit and proceeds in turn through a decode unit a rename unit a pick unit and an issue unit . Issue unit is coupled to issue instructions to any of a number of instruction execution resources an execution unit EXU an execution unit EXU a load store unit LSU that includes a data cache and or a floating point graphics unit FGU . These instruction execution resources are coupled to a working register file . Additionally LSU is coupled to L2 interface and MMU .

In the following discussion exemplary embodiments of each of the structures of the illustrated embodiment of core are described. However it is noted that the illustrated partitioning of resources is merely one example of how core may be implemented. Alternative configurations and variations are possible and contemplated.

Instruction fetch unit may be configured to provide instructions to the rest of core for execution. In one embodiment IFU may be configured to select a thread to be fetched fetch instructions from instruction cache for the selected thread and buffer them for downstream processing request data from L2 cache in response to instruction cache misses and predict the direction and target of control transfer instructions e.g. branches . In some embodiments IFU may include a number of data structures in addition to instruction cache such as an instruction translation lookaside buffer ITLB instruction buffers and or structures configured to store state that is relevant to thread selection and processing.

In one embodiment during each execution cycle of core IFU may be configured to select one thread that will enter the IFU processing pipeline. Thread selection may take into account a variety of factors and conditions some thread specific and others IFU specific. For example certain instruction cache activities e.g. cache fill ITLB activities or diagnostic activities may inhibit thread selection if these activities are occurring during a given execution cycle. Additionally individual threads may be in specific states of readiness that affect their eligibility for selection. For example a thread for which there is an outstanding instruction cache miss may not be eligible for selection until the miss is resolved. In some embodiments those threads that are eligible to participate in thread selection may be divided into groups by priority for example depending on the state of the thread or of the ability of the IFU pipeline to process the thread. In such embodiments multiple levels of arbitration may be employed to perform thread selection selection occurs first by group priority and then within the selected group according to a suitable arbitration algorithm e.g. a least recently fetched algorithm . However it is noted that any suitable scheme for thread selection may be employed including arbitration schemes that are more complex or simpler than those mentioned here.

Once a thread has been selected for fetching by IFU instructions may actually be fetched for the selected thread. To perform the fetch in one embodiment IFU may be configured to generate a fetch address to be supplied to instruction cache . In various embodiments the fetch address may be generated as a function of a program counter associated with the selected thread a predicted branch target address or an address supplied in some other manner e.g. through a test or diagnostic mode . The generated fetch address may then be applied to instruction cache to determine whether there is a cache hit.

In some embodiments accessing instruction cache may include performing fetch address translation e.g. in the case of a physically indexed and or tagged cache accessing a cache tag array and comparing a retrieved cache tag to a requested tag to determine cache hit status. If there is a cache hit IFU may store the retrieved instructions within buffers for use by later stages of the instruction pipeline. If there is a cache miss IFU may coordinate retrieval of the missing cache data from L2 cache . In some embodiments IFU may also be configured to prefetch instructions into instruction cache before the instructions are actually required to be fetched. For example in the case of a cache miss IFU may be configured to retrieve the missing data for the requested fetch address as well as addresses that sequentially follow the requested fetch address on the assumption that the following addresses are likely to be fetched in the near future.

In many ISAs instruction execution proceeds sequentially according to instruction addresses e.g. as reflected by one or more program counters . However control transfer instructions CTIs such as branches call return instructions or other types of instructions may cause the transfer of execution from a current fetch address to a nonsequential address. As mentioned above IFU may be configured to predict the direction and target of CTIs or in some embodiments a subset of the CTIs that are defined for an ISA in order to reduce the delays incurred by waiting until the effect of a CTI is known with certainty. In one embodiment IFU may be configured to implement a perceptron based dynamic branch predictor although any suitable type of branch predictor may be employed.

To implement branch prediction IFU may implement a variety of control and data structures in various embodiments such as history registers that track prior branch history weight tables that reflect relative weights or strengths of predictions and or target data structures that store fetch addresses that are predicted to be targets of a CTI. Also in some embodiments IFU may further be configured to partially decode or predecode fetched instructions in order to facilitate branch prediction. A predicted fetch address for a given thread may be used as the fetch address when the given thread is selected for fetching by IFU . The outcome of the prediction may be validated when the CTI is actually executed e.g. if the CTI is a conditional instruction or if the CTI itself is in the path of another predicted CTI . If the prediction was incorrect instructions along the predicted path that were fetched and issued may be cancelled.

Through the operations discussed above IFU may be configured to fetch and maintain a buffered pool of instructions from one or multiple threads to be fed into the remainder of the instruction pipeline for execution. Generally speaking select unit may be configured to select and schedule threads for execution. In one embodiment during any given execution cycle of core select unit may be configured to select up to one ready thread out of the maximum number of threads concurrently supported by core e.g. 8 threads and may select up to two instructions from the selected thread for decoding by decode unit although in other embodiments a differing number of threads and instructions may be selected. In various embodiments different conditions may affect whether a thread is ready for selection by select unit such as branch mispredictions unavailable instructions or other conditions. To ensure fairness in thread selection some embodiments of select unit may employ arbitration among ready threads e.g. a least recently used algorithm .

The particular instructions that are selected for decode by select unit may be subject to the decode restrictions of decode unit thus in any given cycle fewer than the maximum possible number of instructions may be selected. Additionally in some embodiments select unit may be configured to allocate certain execution resources of core to the selected instructions so that the allocated resources will not be used for the benefit of another instruction until they are released. For example select unit may allocate resource tags for entries of a reorder buffer load store buffers or other downstream resources that may be utilized during instruction execution.

Generally decode unit may be configured to prepare the instructions selected by select unit for further processing. Decode unit may be configured to identify the particular nature of an instruction e.g. as specified by its opcode and to determine the source and sink i.e. destination registers encoded in an instruction if any. In some embodiments decode unit may be configured to detect certain dependencies among instructions to remap architectural registers to a flat register space and or to convert certain complex instructions to two or more simpler instructions for execution. Additionally in some embodiments decode unit may be configured to assign instructions to slots for subsequent scheduling. In one embodiment two slots may be defined where slot includes instructions executable in load store unit or execution units and where slot includes instructions executable in execution units floating point graphics unit and any branch instructions. However in other embodiments other numbers of slots and types of slot assignments may be employed or slots may be omitted entirely.

Register renaming may facilitate the elimination of certain dependencies between instructions e.g. write after read or false dependencies which may in turn prevent unnecessary serialization of instruction execution. In one embodiment rename unit may be configured to rename the logical i.e. architected destination registers specified by instructions by mapping them to a physical register space resolving false dependencies in the process. In some embodiments rename unit may maintain mapping tables that reflect the relationship between logical registers and the physical registers to which they are mapped.

Once decoded and renamed instructions may be ready to be scheduled for execution. In the illustrated embodiment pick unit may be configured to pick instructions that are ready for execution and send the picked instructions to issue unit . In one embodiment pick unit may be configured to maintain a pick queue that stores a number of decoded and renamed instructions as well as information about the relative age and status of the stored instructions. During each execution cycle this embodiment of pick unit may pick up to one instruction per slot. For example taking instruction dependency and age information into account for a given slot pick unit may be configured to pick the oldest instruction for the given slot that is ready to execute.

In some embodiments pick unit may be configured to support load store speculation by retaining speculative load store instructions and in some instances their dependent instructions after they have been picked. This may facilitate replaying of instructions in the event of load store misspeculation. Additionally in some embodiments pick unit may be configured to deliberately insert holes into the pipeline through the use of stalls e.g. in order to manage downstream pipeline hazards such as synchronization of certain load store or long latency FGU instructions.

Issue unit may be configured to provide instruction sources and data to the various execution units for picked instructions. In one embodiment issue unit may be configured to read source operands from the appropriate source which may vary depending upon the state of the pipeline. For example if a source operand depends on a prior instruction that is still in the execution pipeline the operand may be bypassed directly from the appropriate execution unit result bus. Results may also be sourced from register files representing architectural i.e. user visible as well as non architectural state. In the illustrated embodiment core includes a working register file that may be configured to store instruction results e.g. integer results floating point results and or condition code results that have not yet been committed to architectural state and which may serve as the source for certain operands. The various execution units may also maintain architectural integer floating point and condition code state from which operands may be sourced.

Instructions issued from issue unit may proceed to one or more of the illustrated execution units for execution. In one embodiment each of EXU and EXU may be similarly or identically configured to execute certain integer type instructions defined in the implemented ISA such as arithmetic logical and shift instructions. In the illustrated embodiment EXU may be configured to execute integer instructions issued from slot and may also perform address calculation for load store instructions executed by LSU . EXU may be configured to execute integer instructions issued from slot as well as branch instructions. In one embodiment FGU instructions and multicycle integer instructions may be processed as slot instructions that pass through the EXU pipeline although some of these instructions may actually execute in other functional units.

In some embodiments architectural and non architectural register files may be physically implemented within or near execution units . It is contemplated that in some embodiments core may include more or fewer than two integer execution units and the execution units may or may not be symmetric in functionality. Also in some embodiments execution units may not be bound to specific issue slots or may be differently bound than just described.

Load store unit may be configured to process data memory references such as integer and floating point load and store instructions and other types of memory reference instructions. LSU may include a data cache as well as logic configured to detect data cache misses and to responsively request data from L2 cache . In one embodiment data cache may be configured as a set associative write through cache in which all stores are written to L2 cache regardless of whether they hit in data cache . As noted above the actual computation of addresses for load store instructions may take place within one of the integer execution units though in other embodiments LSU may implement dedicated address generation logic. In some embodiments LSU may implement an adaptive history dependent hardware prefetcher configured to predict and prefetch data that is likely to be used in the future in order to increase the likelihood that such data will be resident in data cache when it is needed.

In various embodiments LSU may implement a variety of structures configured to facilitate memory operations. For example LSU may implement a data TLB to cache virtual data address translations as well as load and store buffers configured to store issued but not yet committed load and store instructions for the purposes of coherency snooping and dependency checking LSU may include a miss buffer configured to store outstanding loads and stores that cannot yet complete for example due to cache misses. In one embodiment LSU may implement a store queue configured to store address and data information for stores that have committed in order to facilitate load dependency checking LSU may also include hardware configured to support atomic load store instructions memory related exception detection and read and write access to special purpose registers e.g. control registers .

Floating point graphics unit may be configured to execute and provide results for certain floating point and graphics oriented instructions defined in the implemented ISA. For example in one embodiment FGU may implement single and double precision floating point arithmetic instructions compliant with the IEEE 754 1985 floating point standard such as add subtract multiply divide and certain transcendental functions. Also in one embodiment FGU may implement partitioned arithmetic and graphics oriented instructions defined by a version of the SPARC Visual Instruction Set VIS architecture such as VIS 2.0 or VIS 3.0. In some embodiments FGU may implement fused and unfused floating point multiply add instructions. Additionally in one embodiment FGU may implement certain integer instructions such as integer multiply divide and population count instructions. Depending on the implementation of FGU some instructions e.g. some transcendental or extended precision instructions or instruction operand or result scenarios e.g. certain denormal operands or expected results may be trapped and handled or emulated by software.

In one embodiment FGU may implement separate execution pipelines for floating point add multiply divide square root and graphics operations while in other embodiments the instructions implemented by FGU may be differently partitioned. In various embodiments instructions implemented by FGU may be fully pipelined i.e. FGU may be capable of starting one new instruction per execution cycle partially pipelined or may block issue until complete depending on the instruction type. For example in one embodiment floating point add and multiply operations may be fully pipelined while floating point divide operations may block other divide square root operations until completed.

Embodiments of FGU may also be configured to implement hardware cryptographic support. For example FGU may include logic configured to support encryption decryption algorithms such as Advanced Encryption Standard AES Data Encryption Standard Triple Data Encryption Standard DES 3DES the Kasumi block cipher algorithm and or the Camellia block cipher algorithm. FGU may also include logic to implement hash or checksum algorithms such as Secure Hash Algorithm SHA 1 SHA 256 SHA 384 SHA 512 or Message Digest 5 MD5 . FGU may also be configured to implement modular arithmetic such as modular multiplication reduction and exponentiation as well as various types of Galois field operations. In one embodiment FGU may be configured to utilize the floating point multiplier array for modular multiplication. In various embodiments FGU may implement several of the aforementioned algorithms as well as other algorithms not specifically described.

The various cryptographic and modular arithmetic operations provided by FGU may be invoked in different ways for different embodiments. In one embodiment these features may be implemented via a discrete coprocessor that may be indirectly programmed by software for example by using a control word queue defined through the use of special registers or memory mapped registers. In another embodiment the ISA may be augmented with specific instructions that may allow software to directly perform these operations.

As previously described instruction and data memory accesses may involve translating virtual addresses to physical addresses. In one embodiment such translation may occur on a page level of granularity where a certain number of address bits comprise an offset into a given page of addresses and the remaining address bits comprise a page number. For example in an embodiment employing 4 MB pages a 64 bit virtual address and a 40 bit physical address 22 address bits corresponding to 4 MB of address space and typically the least significant address bits may constitute the page offset. The remaining 42 bits of the virtual address may correspond to the virtual page number of that address and the remaining 18 bits of the physical address may correspond to the physical page number of that address. In such an embodiment virtual to physical address translation may occur by mapping a virtual page number to a particular physical page number leaving the page offset unmodified.

Such translation mappings may be stored in an ITLB or a DTLB for rapid translation of virtual addresses during lookup of instruction cache or data cache . In the event no translation for a given virtual page number is found in the appropriate TLB memory management unit may be configured to provide a translation. In one embodiment MMU may be configured to manage one or more translation tables stored in system memory and to traverse such tables which in some embodiments may be hierarchically organized in response to a request for an address translation such as from an ITLB or DTLB miss. Such a traversal may also be referred to as a page table walk or a hardware table walk. In some embodiments if MMU is unable to derive a valid address translation for example if one of the memory pages including a necessary page table is not resident in physical memory i.e. a page miss MMU may be configured to generate a trap to allow a memory management software routine to handle the translation. It is contemplated that in various embodiments any desirable page size may be employed. Further in some embodiments multiple page sizes may be concurrently supported.

As noted above several functional units in the illustrated embodiment of core may be configured to generate off core memory requests. For example IFU and LSU each may generate access requests to L2 cache in response to their respective cache misses. Additionally MMU may be configured to generate memory requests for example while executing a page table walk. In the illustrated embodiment L2 interface may be configured to provide a centralized interface to the L2 cache associated with a particular core on behalf of the various functional units that may generate L2 accesses. In one embodiment L2 interface may be configured to maintain queues of pending L2 requests and to arbitrate among pending requests to determine which request or requests may be conveyed to L2 cache during a given execution cycle. For example L2 interface may implement a least recently used or other algorithm to arbitrate among L2 requestors. In one embodiment L2 interface may also be configured to receive data returned from L2 cache and to direct such data to the appropriate functional unit e.g. to data cache for a data cache fill due to miss .

During the course of operation of some embodiments of core exceptional events may occur. For example an instruction from a given thread that is selected for execution by select unit may be not be a valid instruction for the ISA implemented by core e.g. the instruction may have an illegal opcode a floating point instruction may produce a result that requires further processing in software MMU may not be able to complete a page table walk due to a page miss a hardware error such as uncorrectable data corruption in a cache or register file may be detected or any of numerous other possible architecturally defined or implementation specific exceptional events may occur. In one embodiment trap logic unit may be configured to manage the handling of such events. For example TLU may be configured to receive notification of an exceptional event occurring during execution of a particular thread and to cause execution control of that thread to vector to a supervisor mode software handler i.e. a trap handler corresponding to the detected event. Such handlers may include for example an illegal opcode trap handler configured to return an error status indication to an application associated with the trapping thread and possibly terminate the application a floating point trap handler configured to fix up an inexact result etc.

In one embodiment TLU may be configured to flush all instructions from the trapping thread from any stage of processing within core without disrupting the execution of other non trapping threads. In some embodiments when a specific instruction from a given thread causes a trap as opposed to a trap causing condition independent of instruction execution such as a hardware interrupt request TLU may implement such traps as precise traps. That is TLU may ensure that all instructions from the given thread that occur before the trapping instruction in program order complete and update architectural state while no instructions from the given thread that occur after the trapping instruction in program order complete or update architectural state.

Additionally in the absence of exceptions or trap requests TLU may be configured to initiate and monitor the commitment of working results to architectural state. For example TLU may include a reorder buffer ROB that coordinates transfer of speculative results into architectural state. TLU may also be configured to coordinate thread flushing that results from branch misprediction. For instructions that are not flushed or otherwise cancelled due to mispredictions or exceptions instruction processing may end when instruction results have been committed.

In various embodiments any of the units illustrated in may be implemented as one or more pipeline stages to form an instruction execution pipeline that begins when thread fetching occurs in IFU and ends with result commitment by TLU . Depending on the manner in which the functionality of the various units of is partitioned and implemented different units may require different numbers of cycles to complete their portion of instruction processing. In some instances certain units e.g. FGU may require a variable number of cycles to complete certain types of operations.

Through the use of dynamic multithreading in some instances it is possible for each stage of the instruction pipeline of core to hold an instruction from a different thread in a different stage of execution in contrast to conventional processor implementations that typically require a pipeline flush when switching between threads or processes. In some embodiments flushes and stalls due to resource conflicts or other scheduling hazards may cause some pipeline stages to have no instruction during a given cycle. However in the fine grained multithreaded processor implementation employed by the illustrated embodiment of core such flushes and stalls may be directed to a single thread in the pipeline leaving other threads undisturbed. Additionally even if one thread being processed by core stalls for a significant length of time for example due to an L2 cache miss instructions from another thread may be readily selected for issue thus increasing overall thread processing throughput.

As described previously however the various resources of core that support fine grained multithreaded execution may also be dynamically reallocated to improve the performance of workloads having fewer numbers of threads. Under these circumstances some threads may be allocated a larger share of execution resources while other threads are allocated correspondingly fewer resources. Even when fewer threads are sharing comparatively larger shares of execution resources however core may still exhibit the flexible thread specific flush and stall behavior described above.

As noted above in some embodiments FGU may be configured to provide hardware support for cryptographic operations including encryption decryption and hashing algorithms. Certain types of cryptographic operations may perform operations on operand values that are significantly larger than the width of the datapath provided by core . For example the Rivest Shamir Adleman RSA public key cryptographic algorithm may employ lengthy cipher keys having 1024 2048 4096 or other numbers of bits. During its course of operation the RSA algorithm may perform modular exponentiation operations on operands that may be at least as wide as the cipher key. These operations may be implemented using integer multiplication necessitating multiplication of 1024 bit or larger operands. Other types of cryptographic algorithms such as Elliptic Curve Cryptography ECC may similarly require multiplication of large operands.

However as the width of the input operands increases the implementation cost of a hardware multiplier in terms of e.g. die area and power consumption typically grows by at least the square of the operand width. Thus it is uncommon for a processor to provide hardware support for multiplication of operands larger than 64 or 128 bits. As described in greater detail below multiplication of large operands as used herein operands that are wider than the processor hardware natively supports may be accomplished through repeated application of the multiplication operations actually implemented by the processor. Multiplication of large operands may also be referred to herein as multiple precision multiplication.

In some embodiments a processor may implement a single large operand multiplication by executing an instruction sequence that includes multiple instances of instructions defined within the processor s ISA. In these embodiments to perform a large operand multiplication a programmer may define an appropriate sequence of instructions that may be fetched from memory and executed by the processor such that upon completion of the sequence the multiplication result is complete. For example the processor s ISA may define general purpose integer instructions such as integer multiply shift arithmetic and Boolean operations that may be individually issued for execution. In some embodiments the processor s ISA may define special purpose instructions designed to facilitate the particular task of large operand multiplication. For example an individual special purpose instruction might combine several aspects of multiply shift and add operations that are specific to the context of large operand multiplication. As a result a sequence of special purpose instructions that is configured to implement a large operand multiplication may be shorter than an equivalent sequence of general purpose instructions and thus may typically execute more quickly than the latter sequence.

Processors that rely on sequences of executable instructions to implement large operand multiplication may present certain implementation challenges particularly in processor embodiments that support multithreaded speculative out of order execution of instructions. For example it may be difficult for scheduling hardware to ensure that the multiple instructions execute in a consistent manner with respect to architectural state while ensuring that the performance of other threads is not unduly affected. In the following discussion embodiments of core are described that are configured to provide single instruction support for large operand multiplication. That is in the described embodiments a large operand multiplication may be accomplished through execution of a single instruction in a manner that is analogous from a programmer s perspective to execution of an ordinary integer or floating point multiplication using the native operand width supported by the multiplier hardware. In some embodiments as discussed below core may be configured to provide single instruction support for large operand multiplications having varying operand widths e.g. for operands that are some multiple of 64 bits . Such an instruction may also be referred to as a multiple precision multiplication or MPMUL instruction.

Broadly speaking in various embodiments multiplier datapath may include a variety of logic elements configured to produce a multiplicative result from input data operands. For example as discussed in greater detail below multiplier datapath may include logic elements configured to generate partial products from multiplicand and multiplier operands e.g. according to a Booth recoding technique or another suitable technique as well as logic elements configured to accumulate the generated partial products into a resultant product e.g. through the use of a Wallace tree or another type of adder accumulator architecture .

In various embodiments MPMUL control logic may include state machines microcode or other control structures configured to coordinate the operation of multiplier datapath during large operand multiplications. For example MPMUL control logic may be configured to coordinate the sequencing of successive multiplication operations the retrieval of operands from other sources within core e.g. register files and the storage of results within architecturally visible state.

Prior to exploring particular embodiments of multiplier datapath and MPMUL control logic it is helpful to examine the dataflow characteristics of large operand multiplications. As an example consider the multiplication of two 512 bit operands A and B where each operand includes 8 64 bit words denoted A7 through A0 and B7 through B0 and where 7 and 0 denote the most and least significant words respectively. Generally speaking the term word is used herein to denote the largest input operand multiplier datapath is capable of receiving during its operation. That is an instance of multiplier datapath having a predetermined word size of MAX bits is capable of multiplying operands having at most MAX number of bits. For example if multiplier datapath is configured to implement multiplication of 64 bit operands then a word corresponds to a 64 bit quantity.

Summing these partial products appropriately accumulating the carry out of each less significant column into the next more significant column then yields the 1024 bit product of A and B. It is noted that in this diagram each column corresponds to one word of the result while each product term may be two words wide. Thus to sum these partial products as shown it may be necessary to output the lower word of each summed column as a word of the result and to carry the remaining bits of each column into the next column as described in greater detail below. In other words for visual clarity this diagram does not attempt to depict the overlap of the carried bits from one column into the next although it is understood that this overlap exists.

In a full precision hardware multiplier most or all partial products might be generated concurrently and then the resultant array of partial products would be accumulated in parallel to generate the resultant product. However by definition a large operand multiplication exceeds the full precision of the available hardware multiplier. Thus adopting a similar approach as the full precision multiplier in which partial products are fully generated and then accumulated may result in a considerable amount of data movement.

A more efficient implementation for large operand multiplication may result from a column oriented accumulation technique. Assume for example that the available hardware multiplier supports multiplication of 64 bit operands to produce a 128 bit product. Starting with the rightmost value in the partial product array shown above the least significant 64 bits of the large operand product may be determined from the lower 64 bits of the 128 bit product A0B0. The next 64 bits of the large operand product may be determined from the lower 64 bits of the sum of the 128 bit products A1B0 and A0B1 summed with the upper 64 bits that effectively carried out of product A0B0.

This process may generally proceed in a columnar fashion where word k of the resultant product may be determined from the sum of the products AiBj where i j k plus the most significant bits carried out of column k 1. In this approach the large operand product may be determined from least significant word to most significant word where any given column k depends only on column k 1.

It is noted that timing elements such as latches or pipeline registers are not specifically shown in but may be included in various embodiments of multiplier datapath . The placement of timing elements relative to other datapath structures may vary depending on factors such as the targeted operating frequency of the processor the electrical characteristics of the process technology used to construct the physical circuits testability concerns and or other design considerations. In addition to the features described below numerous examples of particular circuits and logic configurations that may be employed within or in connection with various embodiments of multiplier datapath may be found in U.S. Patent Application Publication No. 2004 0267855 naming Shantz et al. as inventors filed on Feb. 27 2004 and published on Dec. 30 2004 which is hereby incorporated by reference in its entirety. However to the extent that there exists any conflict between the incorporated application and this specification it is intended that this specification control.

Partial product generation logic may generally be configured to generate partial products from the multiplier and multiplicand operands according to any suitable technique. For example a given partial product that corresponds to a particular bit of the multiplier operand may be generated by shifting the multiplicand left so that the LSB of the shifted multiplicand aligns with the particular bit of the multiplier and multiplying the shifted multiplicand by the value of the particular bit of the multiplier e.g. 0 or 1 . In other embodiments partial product generation logic may implement a radix 4 Booth encoding that may reduce the total number of partial products required to be generated for a given multiplication.

CSAs may be configured to accumulate the partial products generated by partial product generation logic . Generally speaking an N M CSA is an adder circuit that is configured to receive N input bits count them and output the result as an M bit value. For example a 4 2 CSA may be configured to receive 4 input bits and to produce a 2 bit output value as well as a carry out to the next most significant bit position. In some embodiments CSAs may be configured as a Wallace tree although any suitable configuration of CSAs may be employed. Also in some embodiments CSAs may be configured to accumulate a third operand not shown in addition to the generated partial products. For example in embodiments that support multiply accumulate operation two input operands may correspond to the multiplier and multiplicand while the third operand may correspond to the value to be accumulated with the product of the first two.

In many embodiments CSAs may be configured to reduce the several partial products to a pair of values that when added together in an adder such as fast adder yield the final multiplicative product. This pair of values may also be referred to as a sum and carry representation. In various embodiments fast adder may be implemented according to any suitable organization such as a carry lookahead adder CLA for example.

It is noted that in some embodiments multiplier datapath may be configured to perform multiplication over binary fields e.g. Galois field multiplication in addition to multiplication over ordinary integer fields. In a binary field mode of operation addition of two operands may be performed by a bitwise exclusive OR XOR operation between the operands i.e. without carrying any values across bit positions . Binary field multiplication may be performed in a manner similar to integer multiplication except that during binary field multiplication partial products may be accumulated using bitwise XOR operations i.e. without carrying any values across columns of bits . Thus in some embodiments CSAs may be configured to support a binary field mode of partial product accumulation during which carries out of a given bit position within CSAs are suppressed. Other elements of multiplier datapath such as e.g. fast adder may be similarly configured to perform field arithmetic rather than integer arithmetic during a binary field mode of operation for example by suppressing carries between adjacent bits within fast adder . The optional MPXMUL control signal is shown as an input to partial product generation logic CSAs MPMUL CSA and fast adder such that when this signal is asserted the controlled elements perform binary field operations rather than integer field operations. However it is noted that binary field capability may be omitted from embodiments of multiplier datapath .

In the illustrated embodiment processing of the output of CSAs prior to the operation of fast adder depends upon the status of several control inputs which in turn depend upon whether the multiplication being performed is an ordinary multiplication or a large operand multiplication. As shown select muxes are controlled by the MPMUL SELECT signal which may be provided by control logic such as MPMUL control logic . During ordinary multiplication the MPMUL SELECT signal may be deasserted and select muxes may be configured to select the sum and carry values produced by format muxes thus bypassing MPMUL CSA . In various embodiments format muxes may be configured to perform any necessary formatting e.g. shifting value substitution that may be required during the course of ordinary multiplication.

As noted above large operand multiplication may be implemented in a column by column fashion where each portion of the computed final product is dependent in part on the uppermost bits of the immediately less significant portion of the final product. In the illustrated embodiment this procedure may be implemented as follows. During large operand multiplication the MPMUL SELECT signal may be asserted resulting in the selection of the output of MPMUL CSA . Additionally during large operand multiplication the values of registers store the uppermost bits of the immediately prior product. As indicated in these values qualified by the MPMUL ADD signal may be added within MPMUL CSA along with the output of CSAs . Thus during large operand multiplication this embodiment of multiplier datapath may be configured to produce at the output of select muxes a sum and carry representation of a summation of both the outputs of CSAs and the values stored in registers 

During large operand multiplication the output of MPMUL CSA may additionally be right shifted by the amount necessary to align the most significant bits of the product currently being computed with the least significant bits of the product to be computed during the next iteration of large operand multiplication. In the illustrated embodiment this shifting may be performed by shift muxes under control of the MPMUL SHIFT signal and may be stored within register under control of the MPMUL STORE signal. In some embodiments shifting may occur only when the final accumulated product for a given column of the large operand multiplication has been determined. During earlier stages of accumulation within the given column registers may operate to accumulate an intermediate value without shifting.

For example consider the previously discussed case of multiplying two 512 bit operands A and B each consisting of 8 64 bit words within an embodiment of multiplier datapath that is configured to perform multiplication of 64 bit operands. As noted above initially words A0 and B0 may be multiplied to determine a 128 bit result. The least significant 64 bits of this result may correspond to the least significant 64 bits of the final 1024 bit product while the remaining bits of the product of A0 and B0 may be accumulated within the next columnar addition. Thus in the illustrated embodiment the product A0B0 may be right shifted by 64 bits and stored within registers 

To accumulate the next column the product A1B0 or alternatively A0B1 may then be determined and via MPMUL CSA added to the shifted portion previously stored within registers . The result may then be stored within registers without shifting. Then the product A0B1 or alternatively A1B0 may be determined and via MPMUL CSA added to the earlier result. Because this represents the final accumulated product for the current column the least significant 64 bits correspond to bits of the final 1024 bit product while the most significant bits are to be shifted and added to the next column. Accordingly the result may be right shifted by 64 bits and stored within registers . Operation may continue in a similar fashion until all columns of the large operand multiplication have been processed.

It is noted that when multiple N bit values are accumulated within a column of a large operand multiplication a representation of the accumulated value may require more than N bits. For example adding four 128 bit numbers may yield a 130 bit result. Accordingly in some embodiments relevant elements of multiplier datapath e.g. registers MPMUL CSA may be implemented to accommodate the largest accumulated value that is anticipated during large operand multiplication.

As shown in the illustrated embodiment shift muxes and registers are configured to operate on values represented in sum and carry form as produced by CSAs and MPMUL CSA . In other embodiments it is contemplated that a single shift mux and accumulator register may be employed following fast adder such that shifting and accumulation is performed on the final two s complement or other representation produced by fast adder rather than the sum and carry representation.

When properly sequenced the embodiments of multiplier datapath described above may be configured to perform large operand multiplication as a sequence of multiplications and accumulations. In various embodiments MPMUL control logic may be configured to provide the proper sequence of operands and control signals to multiplier datapath such that an entire large operand multiplication may be performed in response to execution of a single instruction issued by issue unit . For example MPMUL control logic may include state machines microcode or other suitable sequencing circuits that may be configured to autonomously perform a large operand multiplication in response to a large operand multiplication instruction without further control or involvement by other programmer visible instructions.

In various embodiments MPMUL control logic may implement a number of counter registers configured to track the progress of a large operand multiplication as well as logic that is configured to carry out certain operations dependent upon the state of the large operand multiplication as reflected by the counter registers. illustrates one example of such an embodiment of MPMUL control logic . In the illustrated embodiment MPMUL control logic includes a set of counters that includes four counters denoted MAX MIN J and K. As described in greater detail below counters J and K may track specific words of the large operands currently being multiplied while MAX and MIN together may track the column of the large operand multiplication currently being performed. In different embodiments the width of counters may vary depending on the maximum operand size supported for a large operand multiplication operation. For example if core supports multiplication of 2048 bit operands and implements a multiplier datapath capable of performing 64 bit multiplications each of the large operands may be divided into 32 64 bit words. In such a case counters J and K may be implemented as 5 bit counters i.e. sufficient to distinguish the 32 input words .

In response to initiation of a large operand multiplication state initialization may occur block . In various embodiments upon commencing a large operand multiplication MPMUL control logic may be configured to set or reset state elements such as counters state machines and or other elements to known initial values. For example MPMUL control logic may be configured to initialize each of the MAX MIN J and K counters to zero. In some embodiments MPMUL control logic may also be configured to initialize state elements within multiplier datapath . For example registers may be initialized to zero at the beginning of a large operand multiplication.

Operand words are then retrieved block and multiplied block . For example counters J and K may respectively denote the words of operand A and B to be retrieved and multiplied together thus if J 0 and K 1 then the words A 0 and B 1 may be retrieved. In some embodiments MPMUL control logic may be configured to coordinate the retrieval of the words as they are needed from architecturally visible storage e.g. registers in an integer register file and or a floating point register file that can be read and written by software . In other embodiments some or all of the words may be copied into non architecturally visible storage e.g. a private register file local to FGU during initialization. To perform the multiplication MPMUL control logic may be configured to control the various control inputs of multiplier datapath . For example MPMUL control logic may cause the MPMUL ADD signal to enable addition of the accumulated values in registers and may cause the MPMUL SELECT signal to select a result from MPMUL CSA each at the appropriate time during datapath operation.

As noted above the process of performing large operand multiplication may be understood as a process of generating and summing products in a column oriented fashion and then repeating this process across the columns of words in the result of the large operand multiplication. Correspondingly when a product of words has been determined it may then be determined whether this product was the last product to be computed for the current column block . In some embodiments MPMUL control logic may be configured to determine this condition by ascertaining whether the values of counter A and counter MAX are equal or equivalently whether B and MIN are equal . If so then the last product for the current column has been computed.

If the currently produced product is not the last to be computed for the current column the counters may be adjusted to reflect the next words of A and B to be retrieved and the currently produced product may be stored within registers block . Operation may then continue from block . In some embodiments adjusting the counters for the next product may include incrementing A and decrementing B.

If the currently produced product is the last to be computed for the current column then it may be determined whether the current column is the last column to be computed block . In some embodiments MPMUL control logic may be configured to determine this condition by ascertaining whether counters MIN and MAX are equal. If so then the last column has been computed. In this case the currently produced product may be output as the most significant portion of the large operand multiplication result block . In some embodiments the most significant portion of the result may be output over several cycles. For example in some implementations multiplier datapath may be configured to output only one word of a product even though the product may be larger than one word e.g. when 64 bit operands are multiplied only 64 bits of the 128 bit result may be output from multiplier datapath . Thus considering the 512 bit large operand multiplication example discussed above in some embodiments generation of the A7B7 product may produce the final 128 bits of the 1024 bit product over two cycles of operation. First product bits may be generated from the lower half of the A7B7 product and then product bits may be generated from the upper half of the A7B7 product which in some cases may be taken from the shifted bits stored within registers as described below with respect to block .

The large operand multiplication may then be finalized as required by the particular implementation of core block . For example in some embodiments a commit process may be required to ensure that only nonspeculative results become architecturally visible. In some such embodiments MPMUL control logic may be configured to coordinate with other units of core to ensure that the results are properly committed.

If the current column is not the last column to be computed several actions may occur in preparation for computing the next column. The least significant word of the currently produced product may be output as the word of the final result that corresponds to the current column block . In some embodiments these output words may be stored within temporary storage that is not architecturally visible e.g. a private register file within FGU until the entire large operand multiplication is complete and the entire result can be committed to architecturally visible state. In other embodiments output words may be stored within architecturally visible state as they are produced though other techniques may be employed to ensure that other instructions cannot utilize interim results until the entire large operand multiplication is complete. For example other instructions from the same thread as the large operand multiplication may be prevented from issuing while the large operand multiplication is executing traps may be prevented from occurring within that thread until the large operand multiplication is complete and or shadow registers may be employed to restore previous architectural state if a large operand multiplication cannot complete after producing partial results.

The currently produced product may be right shifted such that the least significant word is shifted out and the shifted result may be stored within registers block . For example in an embodiment where the word size is 64 bits MPMUL control logic may be configured to cause multiplier datapath to shift the currently produced product by 64 bits and store the result through appropriate manipulation of the MPMUL SHIFT and MPMUL STORE signals.

The counters may also be adjusted in preparation for computing the next column block and operation may continue from block . In some embodiments adjustment of the counters may be performed dependent upon the size in words of the large operand multiplication. For example FGU may be configured to perform large operand multiplication operations using operands having a programmer specified variable size. In other embodiments the operand size may be fixed.

In embodiments using counters such as those shown in a parameter SIZE may be employed where SIZE equals one less than the number of words in an operand of the large operand multiplication or the larger of the two operands if they are of different sizes . Thus for example if 512 bit operands are being multiplied and the word size is 64 bits then there may be 8 words in the operand and SIZE may be set to 7. In some such embodiments the counter adjustment of block may include determining whether counter MAX equals SIZE. If MAX equals SIZE then MAX is incremented and counter MIN is held constant. If MAX does not equal SIZE then MAX is held constant and MIN is incremented. After either MAX or MIN has been incremented in this fashion then counter A is initialized to MIN and counter B is initialized to MAX and operation may continue from block .

It is noted that the sequence of operations illustrated in is merely one example. In other embodiments certain actions may be deleted or performed in a different order than that shown and or other actions may be performed in addition to those shown. Moreover some embodiments of MPMUL control logic may include different configurations of counters or may use fixed state machines or techniques other than counters to control large operand multiplication. Such variations are considered to be within the scope of the present disclosure.

The following table indicates one example of the application of the operations of to the 512 bit large operand multiplication that was previously discussed. Here SIZE equals 7 or 00111 in binary representation . The table indicates the binary values of the MAX MIN A and B counters as operation progresses down and across the columns as well as the specific product term that is produced at each iteration.

As noted above in one embodiment FGU may be configured to provide support for a large operand multiplication instruction such that execution of a single instance of the large operand multiplication instruction results in FGU performing an entire large operand multiplication to completely determine the result of the large operand multiplication instruction. That is rather than using a number of discrete general purpose or special purpose instructions defined within the processor s ISA to perform the large operand multiplication a programmer may specify a single instance of a large operand multiplication instruction such that execution of this instruction determines all bits of the large operand multiplication result without requiring execution of any other programmer selected instruction within the ISA. It is noted that as used herein programmer may refer to either a human programmer who manually specifies a sequence of instructions for example by creating an assembly language program or a machine implemented entity configured to generate executable code sequences such as a compiler for a high level programming language. 

One such embodiment of FGU is shown in . In the illustrated embodiment FGU includes multiplier datapath and MPMUL control logic which may be configured as described above with respect to . Additionally multiplier datapath is shown communicatively coupled to receive operands from a register file under the control of MPMUL control logic .

In the illustrated embodiment MPMUL control logic may be configured to receive for execution a large operand multiplication instruction defined within the processor s ISA. This instruction is denoted with the instruction mnemonic MPMUL though any suitable mnemonic may be employed . In various embodiments MPMUL control logic may directly decode this instruction from opcode bits sent from upstream pipeline stages such as from issue unit or may receive already decoded or partially decoded signals indicative of the occurrence of any of these instructions. Also in the illustrated embodiment the MPMUL instruction may support a programmable SIZE parameter such that large operand multiplications of varying sizes may be performed. The SIZE parameter is illustrated as an additional input to MPMUL control logic although in various embodiments it may be either directly decoded from the MPMUL instruction by MPMUL control logic or received as a decoded field from upstream pipeline stages.

As noted above in some embodiments multiplier datapath may also be configured to perform multiplication over a binary field in addition to integer multiplication. Correspondingly in some embodiments MPMUL control logic may also be configured to receive a large operand binary field multiplication instruction which may be denoted with the instruction mnemonic MPXMUL. Upon execution the MPXMUL instruction may behave in the same fashion as the MPMUL instruction described herein except that as noted above carries across bit positions within the CSAs and fast adder of multiplier datapath may not occur in binary field multiplication. Support for this instruction is optional.

In the illustrated embodiment the operands to be multiplied may be received from register file and the result of the large operand multiplication may be stored to register file . In various embodiments register file may correspond to an architecturally visible integer register file an architecturally visible floating point register file portions of both of these types of register file or an alternatively addressed structure such as a set of memory mapped registers a defined set of memory locations or a private i.e. non architecturally visible storage structure.

In response to receiving a single instance of the MPMUL instruction the instruction execution unit multiplies the operands of the MPMUL instruction within a hardware multiplier datapath circuit to completely determine the result of the MPMUL instruction such that to determine the result of the MPMUL instruction the execution of no other programmer selected instruction within the ISA other than the MPMUL instruction is performed block . For example upon receiving the MPMUL instruction MPMUL control logic may be configured to autonomously and iteratively perform the large operand multiplication according to the method of operation shown in or a similar method. Correspondingly multiplier datapath may produce all of the words of the result of the large operand multiplication in response to execution of the MPMUL instruction.

As a result of executing the MPMUL instruction production of all the words of the result may occur without the need for any other programmer selected instruction to be fetched by IFU or executed. That is in embodiments the MPMUL instruction may behave from an architectural perspective e.g. the perspective of a programmer of core as a single instruction producing a single associated result where the result occupies multiple architecturally defined registers and where the result may be obtained over multiple execution cycles.

In various embodiments the MPMUL instruction may be implemented within any suitable ISA. For example as noted previously processor may be configured to implement a version of the SPARC ISA the x86 ISA or the PowerPC or MIPS ISAs. Because large operands required by the MPMUL instruction may exceed the maximum width of a single operand under the implemented ISA in some embodiments the MPMUL operation may implicitly specify that its operands and result are to be stored in a defined set of architecturally visible registers. For example suppose that a hypothetical ISA defined a flat register file that included 128 individually addressable 64 bit registers denoted R through R and suppose that within this hypothetical ISA the MPMUL instruction is defined to operate on operands of at most 2048 bits in size. In some such instances the MPMUL instruction may implicitly define registers R through R as the source of the first operand registers R through R as the source of the second operand and registers R through R as the destination for the 4096 bit result. Thus prior to executing the MPMUL instruction other instructions may need to ensure that the operands have been properly stored within registers R through R.

Rather than a flat integer register file in which all architectural registers are concurrently visible to software embodiments of the SPARC ISA may employ a set of register windows. In one such embodiment at any given time software may have access to 32 integer registers 8 global registers and 24 registers defined within the current register window. Of the latter 8 registers may be denoted input registers 8 may be denoted local registers and 8 may be denoted output registers. Moreover if the current register window is denoted with a number CWP the output registers of window CWP are identical to the input registers of window CWP 1 and the input registers of window CWP are identical to the output registers of window CWP 1 each of these being determined modulo the number of register windows implemented . illustrates the relationship among register windows for an embodiment that includes 8 register windows denoted w through w. As shown in execution of a SAVE or RESTORE instruction may cause CWP to be incremented or decremented respectively. In alternative embodiments such as some processor embodiments prior to SPARC V9 CWP may instead be decremented on a SAVE and incremented on a RESTORE. In some multithreaded embodiments of core such as described above one complete set of register windows e.g. including the 8 windows shown in may be provided for each thread such that each thread has its own register state that is read and modified independent of the execution of other threads.

One possible example of a MPMUL instruction as it might be defined within a version of the SPARC ISA is as follows. In this example the MPMUL instruction may take a 5 bit argument that defines the SIZE field discussed above. That is the SIZE specified by the MPMUL instruction may denote the quantity N 1 where N is the number of 64 bit words in each operand to be multiplied. Thus in this example the MPMUL instruction may support up to 2048 bit operands although in other embodiments both the size and number of words supported by the MPMUL instruction may vary. It is noted that in some embodiments a single MPMUL opcode may be employed and the SIZE field may be encoded within the MPMUL instruction e.g. as an immediate. In other embodiments multiple distinct MPMUL opcodes may be defined each of which implicitly encodes a single respective value of the SIZE field.

In some embodiments the MPMUL instruction may be executed without regard to the privilege of the executing thread e.g. it may be executed by user level code though in other embodiments execution of the MPMUL instruction may be restricted to privileged code e.g. code that executes in supervisor or hypervisor mode .

In this example the MPMUL instruction makes use of seven integer register windows as well as a number of floating point registers which are not windowed in the described embodiment to store operands and results. Let i denote the current window pointer CWP at the time the MPMUL instruction is executed let multiplier 31 0 and multiplicand 31 0 respectively denote 2048 bit multiplier and multiplicand operands each including 32 64 bit words and let product 63 0 denote a 4096 bit product including 64 64 bit words where the highest numbered words are the most significant. Given these assumptions the following represents one possible correspondence of the MPMUL operands and result to various integer and floating point registers 

As shown here one portion of an operand may be stored within an architecturally visible integer register file and a different portion of the same operand may be stored within an architecturally visible floating point register file. For example words 7 0 of the multiplier may be stored in floating point registers f and f and integer output registers o o corresponding to register window of CWP i 6. It is noted that any other mapping of MPMUL operands and result to any suitable combination of integer and floating point registers including mappings involving only integer registers or only floating point registers may be employed. Moreover in some embodiments different register mappings may be employed for different versions of the MPMUL instruction e.g. for versions specifying different operand sizes .

Given the particular mapping of registers just detailed the following code sequence demonstrates one example of how the MPMUL operands may be retrieved from memory and stored in the appropriate registers and how the MPMUL result may be stored to memory after it has been computed. In the following sequence it is noted that the SAVE and RESTORE instructions may be employed to adjust the current register window.

It is noted that this code sequence represents merely one example of how one embodiment of the MPMUL instruction may be invoked. Numerous other embodiments and applications of the MPMUL instruction are possible and contemplated. For example in other embodiments different register mappings may be employed or a dedicated register file that is distinct from existing integer and floating point register files may be used.

In some embodiments the MPMUL instruction may have scheduling implications for the execution of other instructions. For example in some implementations the MPMUL instruction may be non pipelined such that only one MPMUL instruction from any thread within core may be executing at any given time. In such an implementation the thread that issued the MPMUL instruction may be blocked from executing any further instructions until the MPMUL instruction completes although other threads may continue execution. That is the MPMUL instruction may be blocking with respect to the issuing thread but non blocking with respect to other threads.

Because multiplier hardware tends to require a significant amount of die area relative to other datapath elements multiplier datapath may also be used to execute multiplications other than large operand multiplications. For example it may be employed for integer multiplication and or floating point multiplication. Because MPMUL instructions may take a significant number of execution cycles to complete relative to other instructions in some embodiments an active MPMUL instruction may arbitrate with other instructions for access to multiplier datapath . If the MPMUL instruction loses arbitration it may be temporarily interrupted while another instruction uses the datapath. For example registers which may be actively written only during an MPMUL may hold an intermediate value of the MPMUL instruction while the remainder of multiplier datapath operates on an unrelated multiplication instruction.

In response to receiving the given multiplication instruction execution of the large operand multiplication instruction is suspended block . For example in some embodiments MPMUL control logic may be configured to arbitrate for access to multiplier datapath prior to each iteration of the MPMUL instruction. If MPMUL control logic loses arbitration execution of the MPMUL instruction may be suspended until MPMUL control logic subsequently wins arbitration. In some embodiments the intermediate state of the MPMUL instruction that is suspended may be stored within registers until the MPMUL resumes.

While execution of the large operand multiplication instruction is suspended the result of the given multiplication instruction is determined block . For example the integer or floating point instruction may be allowed to execute within multiplier datapath .

After the result of the given multiplication instruction has been determined execution of the large operand multiplication instruction resumes block . For example when MPMUL control logic subsequently wins arbitration it may retrieve operands and resume execution of the suspended MPMUL instruction. It is noted that in some embodiments an MPMUL instruction may be suspended and resumed multiple times before it finally completes.

As noted previously in some embodiments the MPMUL instruction may commit intermediate results to architectural state as they are generated. For example the various output registers identified above may be modified as result words are iteratively generated by multiplier datapath . In some such embodiments the remainder of core may guarantee that no pipeline flushes occur with respect to the executing thread until the MPMUL instruction finishes in order to prevent architectural state from becoming inconsistent. In other embodiments other suitable techniques may be employed to coordinate the writing of result data taking into account the consistency requirements and implications of the particular implementation of core .

As noted above in some embodiments FGU is configured to provide hardware support in a general purpose processor for certain types of cryptographic operations including encryption decryption and hashing algorithms. As used herein a general purpose processor has its ordinary and accepted meaning in the art and includes a processor that is designed to serve a variety of applications rather than being highly tailored to one specific application or class of applications . In contrast a special purpose processor is a processor that is configured to only perform specialized operations e.g. cryptographic operations DSP operations etc. As will be described below FGU may provide support for instructions usable to calculate a modular exponentiation which is used in various algorithms such as Rivest Shamir Adleman RSA Digital Signature Algorithm DSA and Diffie Hellman DH key exchange. As used herein a modular exponentiation refers to the operation Amod N where A is the base B is the exponent N is the modulus. An exponentiation may be represented herein in the form Aor A B. As used herein mod and modulo operation refer to calculating the remainder of a division operation where the divisor is referred to herein as the modulus. Note that in a modular exponentiation modulo and exponentiation operations can be performed iteratively.

In RSA a user e.g. Alice may wish to receive an encrypted message M from another user e.g. Bob . To accomplish this Alice transmits her public key consisting of the integers n e which may collectively be as large as 4096 bits to Bob. Bob first converts M into an integer representation m having a value between 0 and n using an agreed upon reversible protocol known as a padding scheme. Bob then computes a ciphertext c by computing the modular exponentiation mmod n. Alice can recover m using her private key consisting of d n by performing cmod n. Alice can then recover M by reversing the padding scheme. In some instances Bob and Alice may have to perform multiple modular exponentiations for portions of a message if the message has considerable length.

Modular exponentiation can be performed by performing successive multiplication operations and diving the result by a modulus at periodic intervals. For example xmod 4 can be computed by performing x x mod 4 multiplying the result by x and calculating that product mod 4. One embodiment of an algorithm for computing modular exponentiation is described below in conjunction with . A processor may perform these multiplication operations and modular arithmetic operations using traditional multiplication operations and traditional division operations. Alternatively a processor may perform modular exponentiation using Montgomery multiplication. In some instances Montgomery multiplication is a more efficient algorithm for performing successive multiplications than performing traditional multiplications. Thus Montgomery multiplication is an ideal choice for performing modular exponentiation.

In Montgomery multiplication the modular multiplication A B mod N is computed by first computing a modular multiplication of A B R mod N where R as used herein is a reduction value that is larger than N and proportional to the size of A and B defined by the Montgomery multiply algorithm. The result of this modular multiplication is then multiplied by R and divided by N to produce a remainder which is the result of the modular multiplication A B mod N. In other words the result of the modular multiplication A B mod N is calculated by performing A B R mod N R mod N. To calculate A B R mod N one implementation of the Montgomery algorithm performs a series of one or more Montgomery steps each of which includes performing a multiplication between at least a portion of A and at least a portion of B adding a multiple of N to the product and dividing the result by a factor of R as described next.

In example 1100 a Montgomery step is performed for each digit in the number 789098 starting with the least significant digit 8. In step A the number 8 is multiplied by 123456 to produce 987648. A multiple of 876543 i.e. 3506172 is then added to 987648 to produce the sum 4493820 where the multiple is selected so that the sum will be evenly divisible by a factor of R i.e. 10 which is a factor of 1000000 . Adding a multiple of the divisor 876543 however does not affect the result of the modular exponentiation because 987648 and 4493820 are congruent modulo i.e. they produce the same remainder when being divided by 876543. The benefit of being able to shift out zeros is that the accumulated sum is being reduced so its size does not grow as more steps are performed thus less memory is used than traditional multiplication. Step A concludes with the result of the addition 4493820 being divided by 10 to produce 449382. In step B the next number 9 is multiplied by 123456 and added to the result of step A to produce 1560486. A multiple of 876543 is then added to 1560486 to produce a sum 8572830 that is evenly divisible 10. Step B concludes with dividing the sum by 10 to produce 857283. Montgomery steps C F are performed in a similar manner to produce a result of 793380. As noted above this result 793380 is then used to calculate the final result 770211 by performing 793380 1000000 mod 876543.

Note that example 1100 is a simple illustration of one implementation of Montgomery multiplication. Operands of the Montgomery multiplication may be significantly larger than those used above. Montgomery multiplication may be performed differently in other implementations. In an alternative implementation for example R may be a multiple of 2 instead of a multiple of 10. For example in one embodiment R is 2for a Montgomery multiplication using n bit binary operands. In other implementations instead of performing a Montgomery step for each digit in an operand a Montgomery step may be performed for each byte or word in a multiple byte or word operand.

In some embodiments a processor may implement a single Montgomery multiplication by executing an instruction sequence that includes multiple instances of instructions defined within the processor s ISA. In these embodiments to perform a Montgomery multiplication a programmer may define an appropriate sequence of instructions that may be fetched from memory and executed by the processor such that upon completion of the sequence the Montgomery multiplication result is complete. For example the processor s ISA may define general purpose integer instructions such as integer multiply shift arithmetic and Boolean operations that may be individually issued for execution. In other embodiments the processor s ISA may define special purpose instructions designed to facilitate the particular task of Montgomery multiplication. For example an individual special purpose instruction might combine several aspects of multiply shift and add operations that are specific to the context of Montgomery multiplication. As a result a sequence of special purpose instructions that is configured to implement a Montgomery multiplication may be shorter than an equivalent sequence of general purpose instructions and thus may typically execute more quickly than the equivalent sequence.

In the following discussion embodiments of core are described that are configured to provide single instruction support for Montgomery multiplication. That is in the described embodiments a Montgomery multiplication may be accomplished through execution of a single instruction in a manner that is analogous from a programmer s perspective to execution of an ordinary integer or floating point multiplication using the native operand width supported by the multiplier hardware. In various embodiments as discussed below core is configured to provide support for a single Montgomery multiply instruction. In some embodiments core is also configured to provide support for a single Montgomery square instruction. Such instructions may be referred to herein as MONTMUL and MONTSQR respectfully.

In various embodiments the single Montgomery multiply instruction is executable to calculate P mod N where P is the product of at least operands A and B. For example in one embodiment the single Montgomery multiply instruction is executable to calculate A B mod N thus P is the product of A and B. In other embodiments the single Montgomery multiply instruction is executable to calculate A B R mod N thus P is the product A B and R. In such embodiments additional instructions may be executed to convert the result of calculating A B R mod N into the result of calculating A B mod N e.g. by executing instructions that perform a multiplication by R and a modulo operation using the modulus N. Note in this paragraph the succeeding paragraph and throughout this disclosure the parentheses around for example A B are not intended to require that the value A B is computed first and then a mod N operation is performed on the result of that multiplication. Instead the parentheses around A B is intended to indicate that the expression A B mod N does not mean for example B mod N times A. As used herein computation of A B mod N or a related quantity can involve computing a portion of the A B multiplication performing a modulo operation continuing the multiplication performing another modulo operation etc. to achieve a final result. The same statements are true for the Montgomery square operation described below as well as modular exponentiation operations described herein.

In various embodiments the single Montgomery square instruction is executable to calculate Q mod N wherein Q is the product of at least A. For example in one embodiment the single Montgomery square instruction is executable to calculate Amod N. In other embodiments the single Montgomery square instruction is executable to calculate A R mod N where additional instructions are executed to convert the result of Montgomery square instruction into the result of calculating Amod N.

As will be described below in some embodiments core may execute instances of MONTMUL or MONTSQR instructions using existing hardware structures i.e. structures that are also used for performing operations other than Montgomery multiplications. For example in one embodiment core may use general purpose registers for storing operands such as existing floating point and integer registers as opposed to registers that are used solely for performing a Montgomery multiplication . In one embodiment core may execute an instance of MONTMUL MONTSQR instruction by performing multiplication operations within a multiplier datapath that is configured to perform operations other than Montgomery multiplications. More generally resources of a general purpose processor e.g. general purpose registers may be used to implement one or more ISA level instructions that perform Montgomery multiplication. General purpose registers are those registers in a processor that can be used e.g. by a programmer for a variety of purposes as opposed to registers that are used only for a specific purpose e.g. a 1024 bit or 2048 bit register used only for storing operands for cryptographic operations or as opposed to registers that store values such as the program counter stack pointer etc. In general the use of existing general purpose hardware to implement cryptographic operations including Montgomery multiplication may be advantageous in that specific hardware need not be dedicated for these operations.

In one embodiment multiplier datapath includes a variety of logic elements configured to produce a multiplicative result from input data operands. For example as discussed in greater detail below in conjunction with multiplier datapath may include logic elements configured to generate partial products from operands e.g. according to a Booth recoding technique or another suitable technique as well as logic elements configured to accumulate the generated partial products into a resultant product e.g. through the use of a Wallace tree or another type of adder accumulator architecture .

In one embodiment MONTMUL control logic is configured to coordinate the operation of multiplier datapath during execution of a MONTMUL instruction. For example in one embodiment control logic is configured to coordinate the sequencing of successive multiplication operations the retrieval of operands from other sources within core e.g. register files and the storage of results within architecturally visible state. In some embodiments MONTMUL control logic is also configured to coordinate the operation of multiplier datapath during execution of a MONTSQR instruction. In other embodiments different control logic may be configured to coordinate the operation of multiplier datapath during execution of a MONTSQR instruction.

In one embodiment MONTMUL control logic is configured to directly decode instances of MONTMUL MONTSQR instructions from opcode bits sent from upstream pipeline stages such as from issue unit . In other embodiments control logic may receive already decoded or partially decoded signals indicative of the occurrence of any of these instructions. In one embodiment an instance of a MONTMUL MONTSQR instruction may include a programmable size parameter referred to herein as SIZE and described in detail below in conjunction with indicative of the size of the operands being used by that instance. For example in on embodiment the size parameter specifies the number of words in operands e.g. A B and N. In this way processor in one embodiment can perform public key encryption using various key sizes supported by different public key encryption algorithms. In some embodiments control logic may receive the size parameter as an input such as shown in . In various embodiments control logic may be configured to directly decode the size parameter from that instance of the MONTMUL MONTSQR instruction or may receive the size parameter as a decoded field from upstream pipeline stages.

In one embodiment multiplier datapath is configured to receive operands from a register file such as register file shown in under the control of control logic . In some embodiments the results of a Montgomery multiplication may also be stored to that register file. In various embodiments the register file may correspond to an architecturally visible integer register file an architecturally visible floating point register file portions of both of these types of register files or an alternatively addressed structure such as a set of memory mapped registers a defined set of memory locations or a private i.e. non architecturally visible storage structure. In some embodiments such registers may be general purpose registers. In one embodiment the register file is configured as a flat register. In other embodiments the register file may correspond to one or more sets of registers windows such as described above in conjunction with . In some embodiments multiplier datapath receives operands from respective portions of the register file where the respective portions are fixed by i.e. hardcoded in processor . That is processor may be configured to retrieve operands only from respective portions that are predefined by the ISA of processor . One example of a mapping operands and registers assigned to store those operands is described for a MONTMUL instruction in conjunction with .

In various embodiments multiplier datapath is configured to perform operations other than Montgomery multiplication in response to FGU receiving instances of other types of instructions defined within the ISA. For example in one embodiment multiplier datapath may be configured to perform a floating point multiplication operation in response to a receiving an instance of a floating point instruction. In some embodiments multiplier datapath and MONTMUL control logic are also configured to perform an MPMUL instruction by implementing features of multiplier datapath and MPMUL control logic described above. In various embodiments multiplier datapath may be configured to perform other operations.

Montgomery multiplication can be performed using a combination of multiplications and accumulations. In some embodiments the operands on which a Montgomery multiplication is being performed are larger than the maximum supported operand size for datapath . For example operands may include portions of RSA cipher keys which can have 1024 2048 4096 or more bits depending on the implementation while datapath in one embodiment may be configured to support 64 bit word operands. In order to use these larger operands in one embodiment FGU is configured to perform Montgomery multiplication by performing multiplications on portions of operands within datapath . In some embodiments these multiplications may be performed within datapath in column oriented fashion such as described above with MPMUL.

During the execution of an ordinary multiplication instruction i.e. a non Montgomery multiply instruction one that is not a MONTMUL or MONTSQR instruction and thus does not include for example a modulus operation multiplier datapath in one embodiment uses elements and . In one embodiment partial product generation logic is configured to generate partial products from multiplier and multiplicand operands. In one embodiment CSAs are configured to accumulate the partial products generated by partial product generation logic to produce a carry value and a sum value. In one embodiment format muxes are configured to perform formatting e.g. shifting value substitution on the carry and sum values. In one embodiment select muxes are configured to select between the outputs of format muxes and CSA . In the illustrated embodiment control logic is configured to control select muxes by providing a MONTMUL SELECT signal indicative of whether a MONTMUL MONTSQR instruction is being executed. In one embodiment fast adder is configured to add the formatted carry and sum values to yield a final multiplicative product. Thus in one embodiment when core executes an ordinary multiplication instruction datapath produces a result by generating partial products from portions of operands in logic accumulating those partial produces in CSAs to produce carry and sum values formatting the carry and sum values in muxes and adding the formatted values in fast adder . In various embodiments elements and may function in a similar manner as elements described above in conjunction with .

During the execution of a MONTMUL instruction multiplier datapath in one embodiment uses elements and . In one embodiment CSA is configured to accumulate multiply products produced by logic and CSAs with previous multiply produced by elements and to produce a current result that may be referred to herein as ACCUM. In one embodiment shift muxes are configured to shift the current result i.e. the current product produced by logic and CSAs plus the previous ACCUM right 64 bits for use in the calculation of the next column. That way the current result is already aligned when it is added to the next product produced by logic and CSAs . In the illustrated embodiment control logic is configured to control shift muxes by providing the MONTMUL SHIFT signal. In one embodiment registers are configured to store the uppermost bits of the immediately prior product generated by CSA . In the illustrated embodiment control logic is configured to control registers by providing a MONTMUL STORE signal. Thus when core executes a MONTMUL instruction datapath in one embodiment produces a plurality of carry and sum values in logic and CSAs from portions of the operands where the portions of the operands are small enough to be operated upon using in logic and CSAs . Datapath then accumulates those values in CSA by adding each pair of carry and sum values to a portion of the pervious computed carry and sum values which is stored in registers after being shifted by shift muxes . The accumulated carry and sum values produced by CSA are then added in fast adder to produce a portion of the final result. In various embodiments elements and may function in a similar manner as elements described above in conjunction with . One embodiment of a method for performing a Montgomery multiply is described below in conjunction with .

During the execution of a MONTSQR instruction multiplier datapath in one embodiment uses the same elements as used in executing the MONTMUL instruction with the addition of shift muxes . In various embodiments elements may function in a similar manner as described above during execution of a MONTMUL instruction. In some embodiments control logic is configured to provide select shift and store signals as described above. As will be described below in conjunction with in some embodiments shift muxes are configured to double the current ACCUM by shifting it one bit left. For example if A includes portions A1 and A0 and B includes portions B1 and B0 the multiplication of A and B includes adding A1 B0 and A0 B1. If A and B are different numbers both A1 B0 and A0 B1 are calculated and then summed. If A and B are the same i.e. A A is being calculated A1 A0 and A0 A1 are the same product. Thus a single product A1 A0 can be calculated and then doubled to produce the same result which takes less time than computing multiple products and adding them together. In the illustrated embodiment control logic is configured to cause shift muxes to perform a shift operation by providing a MONTSQR DOUBLE signal. One embodiment of a method for performing a Montgomery multiply is described below in conjunction with .

As noted above a MONTMUL instruction is executable to calculate P mod N where P is the product of at least A and B. MONTSQR instruction is also executable to calculate Q mod N where Q is the product of at least A. Thus the result produced by executing one of these instructions is greater than or equal to 0 and less than N. In some instances however elements may produce a result for a given instance of a MONTMUL MONTSQR instruction that exceeds N. In such instances embodiments of FGU may include a modular reduction unit that is configured to perform a modular reduction on this value to reduce it to a final value that is greater than or equal to 0 and less than N. As used herein the value produced by elements may be referred to as an intermediary value until the value is determined to be less than N or a modular reduction is performed on that value. The value produced by elements is referred to herein as the result of an instance of the MONTMUL MONTSQR instruction once the value is determined to be less than N or a modular reduction is performed on that value.

As shown modular reduction unit includes registers subtraction unit and comparison unit . In the illustrated embodiment registers store the result computed by elements shown as Result and the divisor N. In some embodiments registers may include registers located within FGU . In other embodiments registers may include registers located elsewhere such as within register file shown in . In one embodiment subtraction unit is configured to perform the subtraction Result N and to output a carry bit that indicates whether Result is greater than N. In one embodiment comparison unit is configured to output an indication of whether the Result and N are equivalent.

In one embodiment control logic is configured to determine whether Result is less than N by analyzing the carry bit of subtraction unit and the output of comparison unit . For example control logic may conclude that Result is less than N if the carry bit of unit is a 0 indicating that the result is not greater than N and comparison unit indicates that Result and N not are equivalent. In one embodiment if Result is greater than or equal to N control logic is configured to replace Result with the result of the subtraction performed by unit . On the other hand if Result is less than N control logic is configured to indicate that Result is the result of the instance of the MONTMUL MONTSQR instruction. In some embodiments subtraction unit may perform a first subtraction of N from Result to produce the carry bit and a second subtraction to produce the value that used to replace Result if the result of the first subtraction cannot be buffered while control logic analyzes the carry bit of unit and indication of unit .

When properly sequenced the embodiments of multiplier datapath described above may be configured to perform Montgomery multiplication as a sequence of multiplications and accumulations. In various embodiments MONTMUL control logic may be configured to provide the proper sequence of operands and control signals to multiplier datapath such that an entire Montgomery multiplication may be performed in response to execution of a single instruction issued by issue unit . For example MONTMUL control logic may include state machines microcode or other suitable sequencing circuits that may be configured to autonomously perform a Montgomery multiplication in response to an instance of a MONTMUL MONTSQR instruction without further control or involvement by other programmer visible instructions.

In various embodiments MONTMUL control logic may implement a number of counter registers configured to track the progress of a Montgomery multiplication as well as logic that is configured to carry out certain operations dependent upon the state of the Montgomery multiplication as reflected by the counter registers. illustrates one example of such an embodiment of MONTMUL control logic . In the illustrated embodiment MONTMUL control logic includes a set of counters that includes counters i and j. As described in greater detail below counters i and j may track specific words of the operands currently being used. In different embodiments the width of counters may vary depending on the maximum operand size supported for a Montgomery multiplication. For example if core supports multiplication of 2048 bit operands and implements a multiplier datapath capable of performing 64 bit multiplications each of the large operands may be divided into 32 64 bit words. In such a case counters i and j may be implemented as 5 bit counters i.e. sufficient to distinguish the 32 input words . In some embodiments counters may include additional or less counters such as those described in conjunction with .

In step control logic initializes state for performing method A. In various embodiments control logic may be configured to set or reset state elements such as counters state machines and or other elements to known initial values. For example control logic may be configured to initialize each of the i and j counters to zero. In some embodiments control logic may also be configured to initialize state elements within multiplier datapath . For example registers may be initialized to zero at the beginning of a Montgomery multiplication.

In step A control logic instructs datapath e.g. using logic and CSAs to calculate A B for initial portions of A and B. As noted above the process of performing Montgomery multiplication may be understood as a process that includes generating and summing products in a column oriented fashion and then repeating this process across the columns see the example shown in described below . In one embodiment control logic tracks the current column and portions e.g. words being operated upon using counters i and j where control logic uses counters i and j to specify the portions of A and B that are to be retrieved and multiplied. For example control logic may instruct datapath to perform A j B i j for j 0 to i 1 where j denotes the word being multiplied and i denotes the present column being computed. Control logic may also instruct datapath to perform A i B 0 . In one embodiment control logic updates counter j as portions of A and B are multiplied. In some embodiments control logic may coordinate the retrieval of the portions from architecturally visible storage e.g. registers in an integer register file and or a floating point register file that can be read and written by software . In other embodiments some or all of the portions may be copied into non architecturally visible storage e.g. a private register file local to FGU during initialization.

In step control logic determines whether it is performing the first loop of steps A e.g. if i 0. If control logic is performing the first loop method A proceeds to step . Otherwise method A proceeds to step .

In step control logic instructs datapath e.g. using logic and CSAs to calculate M N for initial portions of M and N where M is a variable representative of a product of a a previously computed summation in step and b N . As used herein N is a value that can be computed according to the expression R R N N 1 where Rand N can both be computed by the extended Euclidean algorithm. In various embodiments N is chosen to be equal in size to the width of datapath and calculated accordingly. For example a 64 bit N may be used on a 64 bit processor architecture where the 64 bit N value may be calculated as N N 1 mod 2 64. In some embodiments N is pre computed once based on a particular value of N and used as an operand in subsequently performed Montgomery multiplication or squaring that uses the same value of N. In some instances pre computing N may improve performance of the Montgomery multiplication or squaring . In one embodiment counters i and j denote the portions e.g. words of M and N that are to be retrieved and multiplied. In one embodiment control logic instructs datapath to perform M j N i j for j 0 to i 1. Control logic may also instruction datapath to perform M i N 0 . In one embodiment control logic updates counter j as portions of M and N are multiplied. In some embodiments control logic may coordinate retrieval of the portions of M and N in the same manner as described in step A.

In step control logic instructs datapath e.g. using CSA registers and fast adder to sum products produced in steps A and . As used herein a sum of products may be referred to as ACCUM . As noted above step may be performed while step A and or step are being performed. In various embodiments control logic may coordinate the summing of products by providing signals to datapath such as MONTMUL SELECT MONTMUL SHIFT and MONTMUL STORE described above. In one embodiment control logic may also instruct datapath to multiply the current sum with N and store a portion e.g. the least significant 64 bits of the result in M i e.g. perform M i ACCUM N for subsequent multiplication operations of M and N. In some embodiments control logic may shift the sum by a predetermined amount e.g. a word before performing subsequent steps e.g. perform ACCUM 64 note denotes a right bit shift . It is noted that in such embodiments this shift operation and the shift operations described in subsequent steps corresponds to a division by a factor of R. In various embodiments control logic may increment the counter i.

In the illustrated embodiment method A performs an iteration of steps A for i 0 to Length where Length is indicative of the size of each operand. For example Length may represent the number of words in an operand. In some embodiments Length may be specified by the SIZE parameter described above. Once i is equal to Length method A then proceeds to step A.

In step A control logic instructs datapath e.g. using logic and CSAs to calculate A B for latter portions of A and B. For example in some embodiments control logic may instruct datapath to perform A j B i j for j i Length to Length. In various embodiments step A may be performed in a similar manner as step A.

In step control logic instructs datapath e.g. using logic and CSAs to calculate M N for latter portions of M and N. For example in some embodiments control logic may instruct datapath to perform M j N i j for j i Length to Length. In various embodiments step may be performed in a similar manner as step .

In step control logic instructs datapath e.g. using CSA registers and fast adder to sum products produced in steps A and . In some embodiments step may be performed while step A and or step are being performed. In one embodiment control logic may also instruct datapath to store a portion e.g. the least significant 64 bits of the sum in X i Length 1 where X is the result of method A. In some embodiments control logic may shift the sum by a predetermined amount e.g. a word before performing subsequent steps e.g. perform ACCUM 64. In various embodiments step may be performed in a similar manner as step .

In the illustrated embodiment method A performs an iteration of steps A for i Length 1 to 2 Length 1. In one embodiment once control logic has completed method A control logic may initiate the performance of method described below.

It is noted that the sequence of operations illustrated in is exemplary. In other embodiments certain actions may be deleted or performed in a different order than that shown and or other actions may be performed in addition to those shown. Moreover some embodiments of control logic may include different configurations of counters or may use fixed state machines or techniques other than counters to control a Montgomery multiplication. Such variations are considered to be within the scope of the present disclosure.

In step control logic initializes state for performing method B. In various embodiments step may be performed in a similar manner as described above.

In step B control logic instructs datapath e.g. using logic CSAs and Shift Muxes to calculate 2 Afor initial portions of A. In one embodiment control logic uses counters i and j to specify the portions of A are to be retrieved and multiplied. For example in one embodiment control logic may instruct datapath to perform 2 A j A i j for j 0 to i 1 1 where j denotes the word being multiplied and i denotes the present column being computed. In some embodiments control logic causes datapath to double A j A i j to produce 2 A j A i j by providing a MONTSQR DOUBLE signal to shift muxes . In one embodiment control logic updates counter j as portions of A are multiplied. In some embodiments control logic may coordinate the retrieval of the portions from architecturally visible storage e.g. registers in an integer register file and or a floating point register file that can be read and written by software . In other embodiments some or all of the portions may be copied into non architecturally visible storage e.g. a private register file local to FGU during initialization.

In step control logic determines whether i is even. If i is even then control logic instructs datapath to perform A i 2 in step . If i is odd then method B proceeds to step .

In step control logic determines whether it is performing the first loop of steps B e.g. if i 0. If control logic is performing the first loop method B proceeds to step . Otherwise method B proceeds to step .

In step control logic instructs datapath e.g. using logic and CSAs to calculate M N for initial portions of M and N. In various embodiments step may be performed in a similar manner as described above.

In step control logic instructs datapath e.g. using CSA registers and fast adder to sum products produced in steps B and . In various embodiments step may be performed in a similar manner as described above.

In the illustrated embodiment method B performs an iteration of steps B for i 0 to Length where Length is indicative of the size of each operand. For example Length may represent the number of words in an operand. In some embodiments Length may be specified by the SIZE parameter described above. Once i is equal to Length method B then proceeds to step B.

In step B control logic instructs datapath e.g. using logic and CSAs to calculate Afor latter portions of A. For example in some embodiments control logic may instruct datapath to perform 2 A j A i j for j i Length to Length. In various embodiments step B may be performed in a similar manner as step B.

In step control logic instructs datapath e.g. using logic and CSAs to calculate M N for latter portions of M and N. For example in some embodiments control logic may instruct datapath to perform M j N i j for j i Length to Length. In various embodiments step may be performed in a similar manner as described above.

In step control logic determines whether i is even. If i is even then control logic instructs datapath to perform A i 2 in step . If i is odd then method B proceeds to step .

In step control logic instructs datapath e.g. using CSA registers and fast adder to sum products produced in steps B and . In various embodiments step may be performed in a similar manner as described above.

In the illustrated embodiment method B performs an iteration of steps B for i Length 1 to 2 Length 1. In one embodiment once control logic has completed method B control logic may initiate the performance of method described below.

It is noted that the sequence of operations illustrated in is exemplary. In other embodiments certain actions may be deleted or performed in a different order than that shown and or other actions may be performed in addition to those shown. Moreover some embodiments of control logic may include different configurations of counters or may use fixed state machines or techniques other than counters to control a Montgomery square. Such variations are considered to be within the scope of the present disclosure.

In step control logic determines whether a result of method A or B shown as Result is greater than N. In one embodiment control logic makes this determination based on the carry bit produced by a subtraction of Result N e.g. by subtraction unit . For example if the carry bit is a 1 then Result is greater than N. Otherwise if the carry bit is a 0 then Result is less than or equal to N. If Result is greater than N method proceeds to step . Otherwise method proceeds to step .

In step control logic determines whether Result is equal to N e.g. using comparison unit . If Result is equal to N method proceeds to step . Otherwise if Result is not equal to N control logic concludes that Result is greater than or equal to 0 and less than N. Thus control logic indicates that Result is the result of the instance of the MONTMUL MONTSQR instruction.

In step control logic coordinates the subtraction of Result N e.g. using subtraction unit and indicates that Result N is the result of the instance of the MONTMUL MONTSQR instruction. In some embodiments control logic coordinates the performance of separate subtractions to produce the carry bit used in step and to produce Result N used in step . In other embodiments the same subtraction is used in both steps and .

Montgomery multiplication begins by computing the results for column A. To compute these results partial product A 0 B 0 is calculated and added to ACCUM. The present value of ACCUM is then stored in M 0 . Next the partial product of M 0 N 0 is added ACCUM. The process of computing the results for column A concludes with the value of ACCUM being shifted by 64 bits a word to the right. This shifted value of ACCUM is then added to partial products in column B. The results of column B are computed in a similar as with column A. Montgomery multiplication continues by calculating results for columns C and D. Once the results for column E have been computed those results are stored in X 0 . The results of columns F and G are then stored in X 1 and X 2 . The final value of ACCUM is then stored in X 3 . Once Montgomery multiplication has computed all words in X a Modular reduction may be performed in accordance with method if X is greater than N.

In response to receiving a single instance of the MONTMUL instruction the instruction execution unit e.g. FGU in one embodiment is configured to calculate P mod N within a multiplier datapath e.g. datapath where P is a product of at least operands A and B. As noted above in one embodiment P is the product of operands A and B such that instruction execution unit is configured to calculate A B mod N in response to receiving a single instance of the MONTMUL instruction. In other embodiments P is a product of A B and Rsuch that instruction execution unit is configured to calculate A B R mod N in response to receiving a single instance of the MONTMUL instruction. Again as noted above the phrase calculate P mod N where P is a product of at least operands A and B does not imply a particular ordering in which operations are to be performed e.g. that P be calculated first and that P mod N be calculated second. Rather this phrase as used herein means that the result of executing an instance of a MONTMUL instruction is equivalent to performing P mod N where P is a product of at least operands A and B.

In one embodiment the instruction execution unit is configured to completely determine the result of the MONTMUL instruction such that to determine the result of the MONTMUL instruction the execution of no other programmer selected instruction within the ISA other than the MONTMUL instruction is performed block . For example in one embodiment upon receiving the MONTMUL instruction MONTMUL control logic is configured to autonomously and iteratively perform the Montgomery multiplication according to the method of operation shown in or a similar method. Correspondingly multiplier datapath may produce all of the words of the result of the Montgomery multiplication in response to execution of the MONTMUL instruction.

As a result of executing the MONTMUL instruction production of all the words of the result may occur without the need for any other programmer selected instruction to be fetched by IFU or executed. That is in various embodiments the MONTMUL instruction behaves from an architectural perspective e.g. the perspective of a programmer of core as a single instruction producing a single associated result where the result may occupy multiple architecturally defined registers and where the result may be obtained over multiple execution cycles.

In various embodiments the MONTMUL instruction may be implemented within any suitable ISA. For example as noted previously processor may be configured to implement a version of the SPARC ISA the x86 ISA or the PowerPC or MIPS ISAs. Because large operands required by the MONTMUL instruction may exceed the maximum width of a single operand under the implemented ISA in some embodiments the MONTMUL operation may implicitly specify that its operands and result are to be stored in a defined set of architecturally visible registers. For example suppose that a hypothetical ISA defined a flat register file that included 128 individually addressable 64 bit registers denoted R through R and suppose that within this hypothetical ISA the MONTMUL instruction is defined to operate on operands of at most 2048 bits in size. In some such instances the MONTMUL instruction may implicitly define registers R through R as the source of the first operand registers R through R as the source of the second operand and registers R through R as the destination for the 4096 bit result. Thus prior to executing the MONTMUL instruction other instructions may need to ensure that the operands have been properly stored within registers R through R. In other embodiments a programmer may be able to specify the set of architecturally visible registers that includes operands for a particular instance of a MONTMUL instruction. In some embodiments operands may be specified by immediate values.

In one embodiment an instance of the MONTMUL instruction specifies a SIZE field discussed above. In some embodiments the SIZE specified by the MONTMUL instruction may denote the quantity N 1 where N is the number of 64 bit words in each operand. In one particular embodiment the MONTMUL instruction supports up to 2048 bit operands although in other embodiments both the size and number of words supported by the MONTMUL instruction may vary. It is noted that in some embodiments a single MONTMUL opcode may be employed and the SIZE field may be encoded within the MONTMUL instruction e.g. as an immediate. In other embodiments multiple distinct MONTMUL opcodes may be defined each of which implicitly encodes a single respective value of the SIZE field. In other embodiments a load instruction may be executed to the value of SIZE in a register prior to execution of the MONTMUL or MONTSQR instruction.

As described above in conjunction with the MPMUL instruction in one embodiment registers used by MONTMUL may be configured as a flat register file. In other embodiments core may employ a set of register windows such as described in conjunction with . The following represents one possible correspondence of the MONTMUL operands and result to various integer and floating point registers 

As shown here one portion of an operand may be stored within an architecturally visible integer register file and a different portion of the same operand may be stored within an architecturally visible floating point register file. For example words 15 8 of the operand A may be stored in floating point registers f and f and integer output registers o o corresponding to register window of CWP i 5. It is noted that any other mapping of MONTMUL operands and results to any suitable combination of integer and floating point registers including mappings involving only integer registers or only floating point registers may be employed. Moreover in some embodiments different register mappings may be employed for different versions of the MONTMUL instruction e.g. for versions specifying different operand sizes .

Given the particular mapping of registers just detailed the following code sequence demonstrates one example of how the MONTMUL operands may be retrieved from memory and stored in the appropriate registers and how the MONTMUL result may be stored to memory after it has been computed. In the Program Sequence A at the end of the detailed description it is noted that the SAVE and RESTORE instructions may be employed to adjust the current register window.

It is noted that this code sequence represents merely one example of how one embodiment of the MONTMUL instruction may be invoked. Numerous other embodiments and applications of the MONTMUL instruction are possible and contemplated. For example in other embodiments different register mappings may be employed or a dedicated register file that is distinct from existing integer and floating point register files may be used.

In some embodiments Montgomery multiply instructions may have scheduling implications for the execution of other instructions. For example in some implementations an instance of a Montgomery multiply instruction may be non pipelined such that only one Montgomery multiply instruction from any thread within core may be executing at any given time. In such an implementation the thread that issued the Montgomery multiply instruction may be blocked from executing any further instructions until the Montgomery multiply instruction completes although other threads may continue execution. That is the Montgomery multiply instruction may be blocking with respect to the issuing thread but non blocking with respect to other threads.

Because multiplier hardware tends to require a significant amount of die area relative to other datapath elements multiplier datapath may also be used to execute multiplications other than Montgomery multiplications. For example datapath may be employed for integer multiplication and or floating point multiplication. Because Montgomery multiply instructions may take a significant number of execution cycles to complete relative to other instructions in some embodiments an active instance of Montgomery multiply instruction may arbitrate with other instructions for access to multiplier datapath . If that instance of the Montgomery multiply instruction loses arbitration it may be temporarily interrupted while another instruction uses the datapath. For example registers which may be actively written only during an Montgomery multiply may hold an intermediate value of the instance of the Montgomery multiply instruction while the remainder of multiplier datapath operates on an unrelated multiplication instruction.

In response to receiving a single instance of the MONTSQR instruction the instruction execution unit in one embodiment is configured to calculate Q mod N within a multiplier datapath e.g. datapath where Q is a product of at least operand A. As noted above in one embodiment P is the product of operand Asuch that instruction execution unit is configured to calculate Amod N in response to receiving a single instance of the MONTSQR instruction. In other embodiments P is a product of Aand Rsuch that instruction execution unit is configured to calculate A R mod N in response to receiving a single instance of the MONTSQR instruction. It is noted that the phrase calculate Q mod N where Q is a product of at least operand A does not imply a particular ordering in which operations are to be performed e.g. that Q be calculated first and that Q mod N be calculated second. Rather this phrase as used herein means that the result of executing an instance of a MONTSQR instruction is equivalent to performing Q mod N where Q is a product of at least operand A.

In one embodiment the instruction execution unit is configured to completely determine the result of the MONTSQR instruction such that to determine the result of the MONTSQR instruction the execution of no other programmer selected instruction within the ISA other than the MONTSQR instruction is performed block . For example in one embodiment upon receiving the MONTSQR instruction MONTMUL control logic is configured to autonomously and iteratively perform the Montgomery square according to the method of operation shown in or a similar method. Correspondingly multiplier datapath may produce all of the words of the result of the Montgomery square in response to execution of the MONTSQR instruction.

In some embodiments support for the MONTSQR instruction may be implemented using various techniques described above in conjunction with the MONTMUL instruction.

In the illustrated embodiment method employs the usage of variables Result Base Exponent and N. At the start of method Base stores the base of the modular exponentiation Exponent stores the exponent and N stores the modulus. Upon completion of method Result stores the result of the modular exponentiation i.e. Result Basemod N.

In step processor determines whether the current value of Exponent is an odd number. In one embodiment processor determines if the current value of Exponent is odd by examining the least significant bit. If the current value of Exponent is odd method proceeds to step . If the current value of Exponent is even method proceeds to step .

In step processor executes an instance of a MONTMUL instruction using the current value of Base the current value of Result and N. Processor then stores the result in Result. Said another way processor performs Result Base Result mod N by executing an instance of a MONTMUL instruction.

In step processor executes an instance of a MONTSQR instruction using the current value of Base and N. Processor then stores the result in Base. Said another way processor performs Base Basemod N by executing an instance of a MONTSQR instruction.

In step processor divides the current value of Exponent by 2. In one embodiment processor performs this division by shifting the current value of Exponent right by 1 bit.

In step processor determines whether the current value of Exponent is 0. If the current value of Exponent is 0 method ends. Otherwise method returns to step .

Consider the situation in which the modular exponentiation Amod N is to be performed. At the start of method Result 1 Base A Exponent 26 11010 in binary . During the first iteration of steps the value of Exponent i.e. 26 is even so the Montgomery square of Amod N is performed. At the end of the first iteration Result 1 Base Amod N Exponent 13 1101 in binary . During the second iteration a Montgomery multiply and Montgomery square are performed. At the end of the second iteration Result Amod N Base Amod N Exponent 6 110 in binary . During the third iteration a Montgomery square is performed. At the end of the third iteration Result Amod N Base Amod N Exponent 3 11 in binary . During the fourth iteration a Montgomery multiply and Montgomery square are performed. At the end of the fourth iteration Result Amod N Base Amod N Exponent 1. During the final iteration a Montgomery multiply and a Montgomery square are performed. At the end of the final iteration Result Amod N Base Amod N Exponent 0. Thus Result stores the outcome of the modular exponentiation.

In this code example a MONTMUL instruction would be executed to perform result base modulus and a MONTSQR instruction would be executed to perform base base modulus.

It is noted that method is merely one exemplary method for calculating a modular exponentiation. In some embodiments method may be performed differently. In other embodiments different methods may be employed to calculate a modular exponentiation. For example while method calculates a modular exponentiation by analyzing bits in the exponent from right to left one alternative method may calculate a modular exponentiation by analyzing bits in the exponent from left to right. Such variations are considered to be within the scope of the present disclosure.

As described above in some embodiments processor of may be configured to interface with a number of external devices. One embodiment of a system including processor is illustrated in . In the illustrated embodiment system includes an instance of processor shown as processor that is coupled to a system memory a peripheral storage device and a boot device . System is coupled to a network which is in turn coupled to another computer system . In some embodiments system may include more than one instance of the devices shown. In various embodiments system may be configured as a rack mountable server system as a standalone system or in any other suitable form factor. In some embodiments system may be configured as a client system rather than a server system.

In some embodiments system may be configured as a multiprocessor system in which processor may optionally be coupled to one or more other instances of processor shown in as processor . For example processors may be coupled to communicate via their respective coherent processor interfaces .

In various embodiments system memory may comprise any suitable type of system memory as described above such as FB DIMM DDR DDR2 DDR3 DDR4 SDRAM or RDRAM for example. System memory may include multiple discrete banks of memory controlled by discrete memory interfaces in embodiments of processor that provide multiple memory interfaces . Also in some embodiments system memory may include multiple different types of memory.

Peripheral storage device in various embodiments may include support for magnetic optical or solid state storage media such as hard drives optical disks nonvolatile RAM devices etc. In some embodiments peripheral storage device may include more complex storage devices such as disk arrays or storage area networks SANs which may be coupled to processor via a standard Small Computer System Interface SCSI a Fibre Channel interface a Firewire IEEE 1394 interface or another suitable interface. Additionally it is contemplated that in other embodiments any other suitable peripheral devices may be coupled to processor such as multimedia devices graphics display devices standard input output devices etc. In one embodiment peripheral storage device may be coupled to processor via peripheral interface s of .

As described previously in one embodiment boot device may include a device such as an field programmable gate array FPGA or application specific intergraded circuit ASIC configured to coordinate initialization and boot of processor such as from a power on reset state. Additionally in some embodiments boot device may include a secondary computer system configured to allow access to administrative functions such as debug or test modes of processor .

Network may include any suitable devices media and or protocol for interconnecting computer systems such as wired or wireless Ethernet for example. In various embodiments network may include local area networks LANs wide area networks WANs telecommunication networks or other suitable types of networks. In some embodiments computer system may be similar to or identical in configuration to illustrated system whereas in other embodiments computer system may be substantially differently configured. For example computer system may be a server system a processor based client system a stateless thin client system a mobile device etc. In some embodiments processor may be configured to communicate with network via network interface s of .

It is noted that the above exemplary assembly language code sequences use the setx instruction. However the setx instruction is defined within the SPARC ISA as a synthetic instruction. As described in section G.3 of the SPARC Architecture Manual Version 9 synthetic instructions may be provided in a SPARC assembler for the convenience of assembly language programmers and they do generate instructions. The synthetic instructions map to actual instructions.

Various embodiments of algorithms described above may include storing instructions and or data implemented in accordance with the foregoing description in an article of manufacture such as a computer readable storage medium including various portions of system memory and or peripheral storage device . Certain embodiments of these computer readable storage media which are tangible and non transitory may store instructions and or data that are computer executable to perform actions in accordance with the present disclosure. For example in some embodiments a computer readable storage medium may store program instructions that include one or more instances of MONTMUL MONTSQR instructions. Generally speaking such an article of manufacture may include storage media or memory media such as magnetic e.g. disk or optical media e.g. CD DVD and related technologies etc. . The article of manufacture may be either volatile or nonvolatile memory. For example the article of manufacture may be without limitation SDRAM DDR SDRAM RDRAM SRAM flash memory and of various types of ROM etc.

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

