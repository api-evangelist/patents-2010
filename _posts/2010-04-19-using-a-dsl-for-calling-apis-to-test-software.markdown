---

title: Using a DSL for calling APIS to test software
abstract: A test case is abstracted into a re-useable script or other declarative form that expresses the intent of a task rather that defining how the test will be performed. Tools translate the declarative test into a series of steps corresponding to code that implements the action indicated in the declarative test. The schema for the tests can be dynamic. New forms of test cases can take advantage of new actions so that the library of actions can be extended. Libraries are interchangeable. Test cases can be generated using a state machine. New test cases can be composed dynamically using a state machine to create new test cases.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08707263&OS=08707263&RS=08707263
owner: Microsoft Corporation
number: 08707263
owner_city: Redmond
owner_country: US
publication_date: 20100419
---
Test cases are typically comprised of program code. Over time a large test bed of many different programs is typically developed. When the software the test programs test changes the test programs need to be refactored and updated. The high cost of maintaining the test programs hinders not only the development of new test cases but also the evolution of the libraries that the test cases use. Writing test cases in program code also makes it more difficult to outsource test work to other companies or vendors because the process of writing code needs to be reviewed and because it requires considerable skill.

The test case is abstracted into a declarative form such as a re useable script or file etc. that expresses the intent of a task rather that defining how the test will be performed. Tools translate the declarative statements into a series of steps corresponding to code that implements the action indicated in the test. The schema for the tests can be dynamic. New forms of test cases can take advantage of existing and new actions so that the library of actions can be extended. Libraries are interchangeable. Test cases can be generated using a state machine. New test cases can be composed dynamically using a state machine to create new test cases.

Because the test is developed in a non traditional programming language the test developer is subjected to a discipline that puts constraints on his or her test making options preventing him or her from creating invalid tests and providing a built in feature that forces the test author to consider how the test will be performed as he or she writes the test case. At any given point only a finite set of available actions are available preventing the test writer from inadvertently causing problems by creating incorrect tests.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Typically tests are written in code and are tightly coupled to implementation. Tests written in code are fragile and difficult to maintain. Implementation changes often render the tests inoperative. Porting tests to a different automation framework tends to be labor intensive and costly. It is often difficult to know what scenarios an automated test case covers because it is hard to perform queries on test code written in a traditional programming language. Tests written in program code are hard to read and hard to write. Tooling support for writing tests is limited. For these reasons and others testing is difficult to outsource.

The subject matter disclosed herein describes methods systems and computer program products for a data driven instead of a code driven test framework in which tests are abstracted into actions that are specified in a declarative or domain specific language or script instead of coded in a traditional programming language. The test cases are independent of the underlying test automation framework and implementations of the software being tested. Tests express what to test and what is expected rather than how to test. A test engine can execute the test by interpreting the actions specified in the test. Interchangeable libraries can be developed for different implementations and or different automation frameworks. The abstraction layer described herein can be layered on top of any automation framework including but not limited to MAUI DTE Microsoft s Visual Studio automation library and other automation frameworks.

Tests written as described herein are easy to write run debug query understand and maintain. Test authors are forced to factor tests in a clean maintainable way that avoids duplication and promotes reuse. The layered architecture enables sharing of common layers across teams of developers. Changes in software implementations are easily managed by having interchangeable libraries. Tests written as described herein can be used to test at the user interface level at the component level at the application programming interface API level and so on.

System may include one or more computers such as computer . The one or more computers may include one or more of a processor such as processor a memory such as memory and one or more modules such as module etc. for using a declarative language to call APIs to perform software testing. Other components well known in the arts may also be included but are not here shown. It will be appreciated that the module s for using a declarative language to call APIs to perform software testing can be loaded into memory to cause one or more processors such as processor to perform the actions attributed to the module s for using a declarative language to call APIs to perform software testing.

The system for using a declarative language to call APIs to perform software testing may include one or more of the following a test engine such as a script executer or scripting engine or an interpreter etc. one or more libraries of test actions such as library library etc. tests such as test etc. a schema a test query engine and a test editor . The system may also include software being tested as illustrated in by software software etc. Software can be for example one implementation of software being tested and software can be another implementation of software being tested. The test engine e.g. interpreter can execute the test step by step by extracting an action from the test finding its implementation in a library of test actions and executing the action. For example interpreter can execute test by interpreting test and executing a corresponding implementation for each step of the test at runtime. Implementation can be provided or changed without changing existing tests by loading a different library into interpreter . A running instance of the software being tested acting as a state machine may also be included in system . System may comprise a portion of an interactive editing environment or read evaluate print loop REPL or an integrated development environment or IDE such as IDE .

A test or test case such as test can be an abstraction of a testing intent. The testing intent can be specified in a declarative form by declarative statements that are independent of implementations of the software and or independent of a testing framework or testing automation framework. Tests such as test etc. can be written in a customized declarative language a scripting language or a domain specific language. Test is not written in a traditional general purpose programming language like C or C . In test the intent of the test is expressed but how the test is conducted is not defined. That is the test expresses what to test but not how to test it. Test intent is separated from implementation so that implementation does not affect the test. This means that if implementation aspects of software change the tests that test the software do not have to be changed. Implementation changes can be handled by changing the library of action implementations for example by loading a different library into the interpreter during testing.

For example a first library of actions may test a first implementation of software using a test and a second library of actions may test a second implementation of software such as a second version of the software for example using the same unchanged test. Similarly a first library of actions may test a first automation framework for software testing using a test and a second library of actions may test a second automation framework for software testing using the same unchanged test. Because tests are not dependent on implementation tests are reusable and are resilient to underlying test framework changes. Automation infrastructure can be modified or replaced without affecting the utility of the tests. Tests as described herein can be used to test software at the user interface level at the component level at the API level and for both test and production software environments. Tests can be created according to a methodology. For example an explicit API design can require actions to have recognizable signatures. A test case can comprise a sequence of actions. An action can be implemented as a call to an API using a method caller as described more fully below.

A test e.g. test can be associated with a schema such as schema . A schema enables a test to be checked for correctness resulting in verifiable tests. For example tests written in XML can be verified with an XML schema. Association with a schema can provide automatic correctness proving and can provide static type checking programming aids such as auto completion member lists and so on when editing and developing tests in a test editor such as test editor . User input e.g. creating a test case can be received by the editor and can by checked for correctness as the user is developing the test case using the schema . A schema can be generated by a schema generation tool that reflects over the libraries and generates a schema that includes all the valid actions and valid signatures for each valid action. That is the schema can establish a finite set of valid actions and a finite set of valid signatures for each action in the finite set of valid actions during development of the test case. A schema defines a valid test file and can be used to provide interactive programmer aids like auto completion and correctness checking when writing or editing test cases.

Because tests are written in a language that is machine readable rich tool support can be provided for test authoring. Examples of tools include editors such as editor in and others including but not limited to generators test searchers navigators and so on. An editor such as editor may be provided for developing tests. Editor may receive one or more schemas such as schema to provide static type checking program aids such as auto completion to the test author as he or she is writing or editing a test . Editor may also be able to provide verification of correctness of the test based on the schema or based on information derived from the schema.

Libraries such as library etc. include one or more action implementations. A library can be an extensible pool of atomic actions. Libraries as described above can be interchangeable. That is an action implementation can be substituted by another action implementation so that the same test can execute on different implementation frameworks or on different implementations of software by loading a different library or set of libraries. More than one library can be loaded into the interpreter or script engine concurrently. If more than one library includes a specified action an algorithm for selecting which action to execute can be provided e.g. use action from the last library loaded from the first library loaded select an action at random cycle through libraries and so on . Each action within the library can be parameterized with data. The data description can form the signature of an action. Each action can provide the data prescribed by the signature of an action. An action implementation can be written in a general purpose programming language such as C C and so on. Duplication of code is more easily avoided by centralization of code in a library.

A state machine e.g. a running instance of the software to be tested such as state machine may provide changes in state so that continuous testing can occur. A query engine such as query engine can search all the tests for occurrences of a specified action e.g. find all tests that exercise push the calculator equals button . Because tests are written in a declarative form untested portions of software under development can be more easily discovered. During test execution one or more libraries can be loaded an action in the library can be identified and dynamically loaded and the action can be executed. A script executing engine or interpreter such as interpreter can receive a test load it load one or more libraries identify the actions to be executed and execute the actions of the test in a sequential order. Interpreter may dynamically load known actions from an action library such as library . An example of a test is illustrated in . Test is written in XML but it will be appreciated that test can be written in any declarative domain specific or scripting language.

The layered architecture described above facilitates sharing common layers across teams of developers. illustrates an example of how layers can be shared. Product unit teams can include developer teams such as a C team a VB team and an F team . Examples of product unit specific functionality is represented by separate testhooks for the C language service specific testhooks the VB language service specific testhooks and the F language service specific testhooks . Common IDE functionality can be shared by all the product teams .IDEWrapper . Common automation frameworks may include frameworks such as TNugget used by the C team while the DTE automation library may be used by the VB team and the MAUI framework with its adapter .Maui may be used by the F team where all the teams are testing a product such as an IDE .

As described above a test engine such as an interpreter can load the test case e.g. test case can identify the actions to be executed and can identify any applicable parameters. For example interpreter of can load test case identify the action ClickCalcButton with parameter ButtonName 2 of statement ClickCalcButton ButtonName 2 . The interpreter can then dynamically load known actions from a library of actions such as library of which can contain the actual code to automate the test scenario. This can be done through a code reflection based mechanism to decouple the test case language from the automation code.

In order to provide context for various aspects of the subject matter disclosed herein and the following discussion are intended to provide a brief general description of a suitable computing environment in which various embodiments may be implemented. While the subject matter disclosed herein is described in the general context of computer executable instructions such as program modules executed by one or more computers or other computing devices those skilled in the art will recognize that portions of the subject matter disclosed herein can also be implemented in combination with other program modules and or a combination of hardware and software. Generally program modules include routines programs objects physical artifacts data structures etc. that perform particular tasks or implement particular data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. The computing environment is only one example of a suitable operating environment and is not intended to limit the scope of use or functionality of the subject matter disclosed herein.

With reference to a computing device for efficient resumption of co routines on a linear stack in the form of a computer is described. Computer may include a processing unit a system memory and a system bus . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit . The system memory may include volatile memory and nonvolatile memory . Nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM or flash memory. Volatile memory may include random access memory RAM which may act as external cache memory. The system bus couples system physical artifacts including the system memory to the processing unit . The system bus can be any of several types including a memory bus memory controller peripheral bus external bus or local bus and may use any variety of available bus architectures.

Computer typically includes a variety of computer readable media such as volatile and nonvolatile media removable and non removable media. Computer storage media may be implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other transitory or non transitory medium which can be used to store the desired information and which can be accessed by computer .

It will be appreciated that describes software that can act as an intermediary between users and computer resources. This software may include an operating system which can be stored on disk storage and which can control and allocate resources of the computer system . Disk storage may be a hard disk drive connected to the system bus through a non removable memory interface such as interface . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It will be appreciated that computers can be implemented with various operating systems or combinations of operating systems.

A user can enter commands or information into the computer through an input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone and the like. These and other input devices connect to the processing unit through the system bus via interface port s . An interface port s may represent a serial port parallel port universal serial bus USB and the like. Output devices s may use the same type of ports as do the input devices. Output adapter is provided to illustrate that there are some output devices like monitors speakers and printers that require particular adapters. Output adapters include but are not limited to video and sound cards that provide a connection between the output device and the system bus . Other devices and or systems or devices such as remote computer s may provide both input and output capabilities.

Computer can operate in a networked environment using logical connections to one or more remote computers such as a remote computer s . The remote computer can be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . Remote computer s can be logically connected via communication connection . Network interface encompasses communication networks such as local area networks LANs and wide area networks WANs but may also include other networks. Communication connection s refers to the hardware software employed to connect the network interface to the bus . Connection may be internal to or external to computer and include internal and external technologies such as modems telephone cable DSL and wireless and ISDN adapters Ethernet cards and so on.

It will be appreciated that the network connections shown are examples only and other means of establishing a communications link between the computers may be used. One of ordinary skill in the art can appreciate that a computer or other client device can be deployed as part of a computer network. In this regard the subject matter disclosed herein may pertain to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. Aspects of the subject matter disclosed herein may apply to an environment with server computers and client computers deployed in a network environment having remote or local storage. Aspects of the subject matter disclosed herein may also apply to a standalone computing device having programming language functionality interpretation and execution capabilities.

A user can create and or edit the source code component according to known software programming techniques and the specific logical and syntactical rules associated with a particular source language via a user interface and a source code editor in the IDE . Thereafter the source code component can be compiled via a source compiler whereby an intermediate language representation of the program may be created such as assembly . The assembly may comprise the intermediate language component and metadata . Application designs may be able to be validated before deployment.

The various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus described herein or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing aspects of the subject matter disclosed herein. In the case of program code execution on programmable computers the computing device will generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may utilize the creation and or implementation of domain specific programming models aspects e.g. through the use of a data processing API or the like may be implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

While the subject matter disclosed herein has been described in connection with the figures it is to be understood that modifications may be made to perform the same functions in different ways.

