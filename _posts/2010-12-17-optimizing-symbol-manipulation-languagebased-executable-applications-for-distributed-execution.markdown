---

title: Optimizing symbol manipulation language-based executable applications for distributed execution
abstract: In one embodiment, a method comprises receiving an application that describes functions according to a prescribed symbol manipulation language, the prescribed symbol manipulation language a non-Turing complete language that does not permit partial functions and describes the functions independent of any attribute of any computing system; identifying, in the application, a distribution annotation that identifies a candidate element in the application, the candidate element configured for execution in a distributed computing operation by a distributed computing system comprising two or more distributed computing devices; generating one or more variants of the application based on executing a nondestructive transformation of the application relative to prescribed equality axioms, at least one of the variants containing a corresponding semantically-equivalent variation of the candidate element; and selecting one of the variants as an optimization for execution of the application by the distributed computing system relative to prescribed metrics.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08762964&OS=08762964&RS=08762964
owner: Cisco Technology, Inc.
number: 08762964
owner_city: San Jose
owner_country: US
publication_date: 20101217
---
The present disclosure generally relates to the writing compiling and execution of executable applications or programs on different computing systems having prescribed hardware and or software specific requirements. More particularly the present disclosure relates to executable applications or programs that are written for execution in a distributed computing environment.

This section describes approaches that could be employed but does not necessarily describe approaches that previously have been conceived or employed. Hence unless explicitly specified otherwise any approaches described in this section are not prior art to the claims in this application and any approaches described in this section are not admitted to be prior art by inclusion in this section.

Processor based applications or programs to date have been written in accordance with constraints imposed by hardware specific and or software specific constraints of the underlying computing system intended to execute the applications or programs. For example assembly language instruction sets are designed for a specific processor circuit for manipulation of digital bits i.e. having a value of either 0 or 1 that can be interpreted by the specific processor circuit either as an executable instruction an address value for a register or memory location accessible by the specific processor circuit or data applications written using the assembly instruction sets must strictly follow the associated software and or hardware based requirements of the assembly language instruction sets e.g. syntax etc. . Operating systems e.g. Microsoft Windows XP Unix Linux etc. provide a level of abstraction that enables application developers to ignore at least some of the hardware or software based constraints of the specific processor circuit however such operating systems in return impose their own hardware and or software based constraints that must be followed by an application executed using such operating systems to perform a prescribed function.

Consequently substantial compatibility problems continue to exist when an attempt is made to employ an existing application developed for a first computing system on a second computing system that is not perfectly compatible with the first computing systems. Moreover more complex computing systems are constantly being developed e.g. newer processor circuits offering multithreading parallel computing or blade computing network based distributed computing cloud computing etc. . Hence application developers continue to confront the difficult requirement of understanding the features and requirements of the more complex computing system in order to modify existing applications for compatibility or develop a new application that operates without failure in the more complex computing system.

In one embodiment a method comprises receiving an application that describes functions according to a prescribed symbol manipulation language the prescribed symbol manipulation language a non Turing complete language that does not permit partial functions and is independent of any attribute of any computing system generating one or more variants of the application based on executing a nondestructive transformation of the application relative to prescribed equality axioms each variant of the application semantically equivalent to any other variant or to the application and selecting one of the variants as an optimization for execution of the application by at least one apparatus relative to prescribed metrics.

In another embodiment a method comprises receiving an application that describes functions according to a prescribed symbol manipulation language the prescribed symbol manipulation language a non Turing complete language that does not permit partial functions and describes the functions independent of any attribute of any computing system identifying in the application a distribution annotation that identifies a candidate element in the application the candidate element configured for execution in a distributed computing operation by a distributed computing system comprising two or more distributed computing devices generating one or more variants of the application based on executing a nondestructive transformation of the application relative to prescribed equality axioms at least one of the variants containing a corresponding semantically equivalent variation of the candidate element and selecting one of the variants as an optimization for execution of the application by the distributed computing system relative to prescribed metrics.

Particular embodiments enable executable applications to be written in a manner that is completely independent of any attribute of any computing system i.e. independent of any computing system deployment model. In particular the executable applications are written according to a prescribed symbol manipulation language SML .

The term application or program is defined as executable information stored on at least one non transitory tangible medium and that can be configured for execution on one or more hardware based processor circuits the executable information can be stored as a single container e.g. an executable file on at least a single non transitory tangible medium described below the executable information also can be stored as multiple components e.g. fragments on one or more non transitory tangible media where execution of the components by the same or distinct processor circuits can result in execution of the application e.g. distributed computing . Unless specified otherwise the execution of components by distinct processor circuits need not necessarily be concurrent rather the components could be executed as distinct and independent events.

Deployment of any computing system requires establishing software or hardware specific requirements on the computing system. Hence a computing system deployment model is defined herein as any computing system having at least one or more software or hardware specific requirements for deployment i.e. physical and tangible execution of the computing system. At least one software and or hardware specific requirement of any computing system can be used to establish a computing system deployment model . Hence a computing system deployment model A will have at least one hardware or software specific requirement that distinguishes the computing system deployment model A from another computing system deployment model B .

Existing programming languages assume hardware specific or software specific parameters i.e. requirements constraints etc. for a particular computing system deployment model. Example hardware specific requirements that have been assumed by existing programming languages for a particular computing system deployment model can include the type of microprocessor used e.g. 32 bit or 64 bit single core dual core or multiple core etc. the manufacturer of the microprocessor e.g. Intel processor vs. ARM processor or Motorola processor whether the application is executed in a stand alone computer or in a network according to a prescribed computation model e.g. client server peer to peer distributed computing etc. . Example software specific requirements that have been assumed by existing programming languages for a particular computing system deployment model can include the type of operating system in use e.g. UNIX Windows etc. or a given version of the operating system in use by the computing system deployment model.

The prescribed symbol manipulation language SML is distinctly different from existing programming languages in that the prescribed symbol manipulation language is a purely functional language that enables an executable application to be expressed as a logical specification that describes functions to be executed by any computing system independent of any hardware specific or software specific requirements of any computing system. In other words the executable application can be expressed as a manipulation of symbols consisting only of the symbol manipulation language elements described below in a manner that is independent of any computing system deployment model. Consequently any application written in the prescribed symbol manipulation language can have absolutely no relationship to any attribute of any computing system deployment model. Hence any application written in the prescribed symbol manipulation language is completely independent of any software and or hardware specific requirements of any computing system.

The transformation system can provide a mapping between the application and a a particular computing system deployment model for example certain hardware based computing systems. The transformation system can provide this mapping based on executing a fully nondestructive logical transformation of the application into a transformed application that is semantically equivalent to the application . This fully nondestructive logical transformation enables an unlimited number of logical transformations as required between the original application and multiple variations e.g. of the original applications where any one variation of the original application i.e. program variant can be an optimization for a prescribed computing system based on axioms and constraints that can be associated with a given computing system.

The transformation system can be configured for implementing a fully nondestructive logical transformation in the form of an optimization of the original SML based application and or the transformed SML based application into an executable application e.g. and or based on prescribed hardware and or software specific requirements e.g. and or of a prescribed computing system deployment model e.g. a distributed computing system containing two or more computing nodes as in . The executable application generated by the transformation system can include hardware and or software specific executable code e.g. optimized for the prescribed computing system deployment model. The executable application also can include SML program elements e.g. and or that describe respective application function operations independent of any hardware or software specific requirements of any computing system deployment model and that are implemented by an SML program interpreter executed by the prescribed computing system deployment model.

In addition to the SML language being a non Turing complete and purely functional language the SML language also should be a higher order language the language must be a strong and statically typed language a language is statically typed only if all expressions have their types determined prior to execution of the application e.g. determined during compilation a language has a strong typing if it doesn t not permit one type to be treated as another type e.g. treating an integer type as a string type . The symbol manipulation language also must support symbols a symbol is a unique element e.g. as in the Scheme programming language that can be stored in one or more physical and tangible data structures e.g. stored within at least one non transitory storage medium and that can be compared with another symbol. The symbol manipulation language also must support the following operations by providing the appropriate syntactic rules Pair and Projection operations for constructing and destructing tuples described blow Tagged Union and Case operations for constructing and destructing union structures Curry and Apply operations for constructing and destructing new functions Identity and Composition operations for building complex operations from simpler ones .

The symbol manipulation language also can provide support for Monads Functors Inductive and CoInductive types Catamorphisms and Anamorphisms. Example programming languages that can be used to implement the disclosed symbol manipulation language can include Polymorphically Typed Lambda Calculus without Fixpoints Charity Joy and subsets of Standard ML Scheme and Haskell. In one embodiment the symbol manipulation language can be implemented using a subset of Haskell.

The symbol manipulation language provides a logical specification for describing functions to be executed in a computing system in that the symbol manipulation language serves as a metalanguage for functions based on describing the semantics i.e. the meanings of the functions. In particular a function is a transformation of one and only one input to one and only one output as described below an input and or an output may be composed of multiple symbols for example a pair as an input e.g. a b c or a pair as an output e.g. a b c . The symbol manipulation language provides a logical specification for the description of the function without describing the input or the output rather the symbol manipulation language can rely on an underlying polymorphic typed lambda calculus without Fixpoints. In particular the functional relationship between inputs and outputs can be described in terms of logical types according to foundational mathematics universal algebra and category theory example logical types include at least a tuple a sum and a lambda type.

As described in further detail below a given symbol can be used to represent a particular value independent of form. In other words a symbol in one example represents a particular value that can be implemented as any one of an integer string alphanumeric Boolean value e.g. a bitmask floating point etc. without explicitly identifying the symbol as any one of the integer string Boolean value floating point etc. Note however that a symbol is not a variable because the value of a symbol does not change a symbol is only ever one value while a variable is some class of values of which the variable currently is assigned one value at a time. Hence a reference to an alphanumeric letter in this specification in quotes e.g. a refers to a symbol and not a variable unless explicitly identified otherwise as a variable .

Hence the symbols a and b in an expression can be used to express the relationship between a and b without identifying whether any one of the symbols is implemented as an integer string Boolen value floating point etc.

A tuple is a pairing or association between one symbol a and another symbol b for example enabling description of a function that maps from the inputs a and b i.e. a b to an output the inputs a and b can be of the same type e.g. a is an integer and b is an integer or different types e.g. a is an integer and b is a floating point . A sum i.e. coproduct identifies a relationship between one symbol a and another symbol b for example enabling description of a function that maps an input a or b i.e. a b to an output where the inputs a and b can be either the same or different types a sum also can be used to describe a conditional operation e.g. if . . . then .

A lambda type changes an existing function into a new function. The existing function serving as an input to the lambda type takes one pair as input and returns one output a b c . The new function output by the lambda type takes one value as input and returns a new function as output a b c . The use of lambda types is the foundation for typed lambda calculus excluding untyped lambda calculus .

These example logical types tuples sums and lambda types can be used to derive additional functions or operations that combine symbols for example products exponentials etc.

Hence the symbol manipulation language provides a logical and semantic specification for describing functions independent of any hardware specific or software specific requirements of any computing system based on the tuple sum and lambda types that define the relationships between the symbols that are manipulated by the functions. Category theory provides that repeating patterns can be described in a manner that is mathematically provable the symbol manipulation language is established based on defining a base category of symbols and adding to the base category tuples sums and lambda types and other optional logical types that describe the functions to be performed.

By way of analogy consider the construction of a building structure for example a commercial office building or a home the application written according to the prescribed symbol manipulation language is analogous to an architect s blueprint plan that can illustrate graphically and with textual annotations the structure of the building based on including plan views e.g. floor plan views elevation views and or cross sectional views without any details as to the specific construction techniques for implementing the blueprint plan. In other words the same blueprint plan can be used to build the same building structure using different construction techniques depending on the time the building structure is built or the particular building codes in effect at the building site.

Consequently an application written according to a prescribed symbol manipulation language as described herein is independent of any hardware and or software specific requirements of a prescribed computing system deployment model such as explicit memory allocation persistent storage serial ordering constraints messaging threading shared state hardware access operating system interaction or real time clocks. The symbol manipulation language also is isolated from any and all interactions with any hardware or software attributes of the computing system deployment model and isolated from any notion of the forward progression of time e.g. as in runtime execution of an executable resource by the computing system .

In addition since the symbol manipulation language is based on category theory which can provide mathematically provable descriptions of repeating patterns absolute backwards compatibility is guaranteed between a first application and a newer application. In particular assume the first application is written in a first symbol manipulation language having an initial set of logical types. Assume further the newer application is written in a later symbol manipulation language having an expanded set of logical types that includes the initial set of logical types and newly added logical types having been discovered according to category theory. Category theory ensures that the first application written in the first symbol manipulation language is compatible with the newer application written in the later symbol manipulation language because the first symbol manipulation language is mathematically consistent with the later symbol manipulation language.

The application written according to the prescribed symbol manipulation language can be executed on any computing system deployment model based on execution of the application by an interpreter that is native to the corresponding computing system deployment model i.e. the interpreter is specific to the hardware and or software requirements of the corresponding computing system deployment model .

The transformation system TS can be configured for evaluating an application written according to a prescribed symbol manipulation language . The evaluation of the application can be performed for example based on determining execution metrics for the application relative to prescribed axioms axiom constraints system constraints and or computing system requirements that are expressed using optimization metrics programs OMPs .

The transformation system also can be configured for executing an optimization of an application written according to a prescribed symbol manipulation language . The optimization of the application can be based on executing a logical transformation of the application into a transformed application including logically converting i.e. logically transforming the initial application written according to a prescribed symbol manipulation language into the transformed application according to a set of prescribed axioms axiom constraints system constraints and optimization metrics programs . The optimization of the initial application into the transformed application enables an application result to be completed more efficiently according to given criteria and or the optimization can provide additional features associated with execution of the transformed application e.g. logging operations auditing distributed or parallel execution etc. .

The logical transformation of the application into the transformed application can be based on logical conversions of prescribed patterns in the application according to a set of prescribed axioms. For example the transformation system can be configured for identifying at least a first prescribed pattern in an application written according to the symbol manipulation language SML and logically converting the first prescribed pattern into a second prescribed pattern in the symbol manipulation language the second prescribed pattern being semantically equivalent at the logical level to the first prescribed pattern according to prescribed rules defining the semantic and functional manipulation of symbols . The first prescribed pattern can be converted into the second prescribed pattern based on a prescribed equality axiom accessible by the transformation system and that identifies the semantic equivalence between the first prescribed pattern and the second prescribed pattern. All prescribed axioms i.e. rules are bidirectional where conversion from the first prescribed pattern to the second prescribed pattern is nondestructive enabling the second prescribed pattern to be converted back to the first prescribed pattern. Axioms also can be associated with certain axiom constraints described below where certain prescribed conditions must be satisfied before the associated logical conversion can be performed. Example conditions can include checking the value of a variable checking the type of an expression etc.

Equality axioms can be used to establish semantic equivalence between symbols and or symbol expressions written in the prescribed SML . Equality axioms also can be used to establish equivalence between a given symbol and or symbol expression and a hardware and or software specific expression for a prescribed computing system deployment model the hardware and or software specific expression for the prescribed computing system deployment model can be defined according to a prescribed primitive type for a manufacturer specific configuration e.g. Intel processor vs. ARM processor a prescribed computer processor architecture e.g. single core processor multiple core processor parallel processors etc. and or a prescribed computing architecture e.g. single computing device client server distributed cloud computing etc. .

An example axiom can be a commutative property x y y x where represents a multiplication operation another example axiom can be a distributive property a b c a b a c another example axiom can be an associative property a b c a b c another example axiom can be a sum product transposition such as a a 2 a . New axioms also can be added as new logical types are discovered according to category theory and added to the later symbol manipulation language in the form of new symbols and or new functional rules where the new axioms identify the semantic equivalence between the first prescribed pattern e.g. prescribed patterns expressed using an initial set of logical types of the first symbol manipulation language and the second prescribed pattern expressed using the newly added logical types of the later symbol manipulation language.

A prescribed equality axiom in addition to identifying the semantic equivalence between a first prescribed pattern and a second prescribed pattern also can impose restrictions i.e. axiom constraints related to the first or second prescribed patterns for example requiring an input output identified in the first prescribed pattern must be a specific type e.g. must be a specific tuple sum or lambda type or that an identified function operating on an input must be maintained etc. For example one axiom can impose a restriction that a prescribed input must be a nonzero value e.g. a b divide a b where b does not equal 0 to ensure safe division. Hence restrictions can be imposed by the axiom in the transformation between the first prescribed pattern and the second prescribed pattern. As described below the combination of axiom constraints and optimization metrics programs enables feature injection parallelization distributed processing incremental or continuous compilation Pareto optimality fault tolerance real time guarantees platform specific and or proprietary extensions network management and or disconnected operations.

The transformation system also includes a prelude portion and system constraints. The prelude portion also referred to as a logical user language interface is an executable application that can be written in the symbol manipulation language . The logical user language interface provides a logical interface for application programmers based on providing a logically equivalent mapping between symbol manipulation language constructs and hardware based and or software based concepts that often are employed by programmers experienced in hardware based programming languages. For example the logical user language interface can provide a library that describes how hardware based elements should be expressed in the symbol manipulation language as interpreted by the transformation system . Example hardware based elements that can be expressed by the prelude portion can include integers Boolen operators and operands data structures such as lists or trees executing functions over functions executing functions on data structures etc.

System constraints can define how the semantics of the application written according to the symbol manipulation language are logically interpreted. Hence the system constraints can ensure the application complies with the requirements of the symbol manipulation language e.g. non Turing complete no partial functions no operations resulting in bottom or halt operation that all operations are derived from tuple sum and or lambda logical types etc. . System constraints also can include security based constraints e.g. the application must be hashed and coded according to a prescribed security key etc. .

The transformation system also includes a compiler circuit . The transformation system can supply the initial application and or the transformed application to the compiler circuit which can be configured for mapping the logical types and operations specified in the supplied application e.g. and or to computing machine specific i.e. native types and native operations for a prescribed machine executable computing system deployment model. The mapping of logical types and operations of the supplied application to native types and operations enables the bidirectional i.e. nondestructive converting of the supplied application into an executable application that can include executable code optimized for the prescribed computing system deployment model based on the prescribed set of primitive types e.g. and or that describe any hardware specific and or software specific requirements of the computing system deployment model.

In particular a primitive type is a base type of input or output from which all other logical types are polymorphically derived example primitive types can include integer string alphanumeric Boolean e.g. a bit mask floating point etc. For example a 32 bit data value stored in a 32 bit memory location can represent an integer an alphanumeric string e.g. one or more ASCII characters a Boolean value e.g. a bit mask or a floating point value depending on the hardware or software constraints applied to the 32 bit memory location.

Additional hardware specific primitive types can include methods for execution or computation for example a remote primitive type for requesting an operation be performed by a remote machine a local primitive type for specifying that an operation must be performed by the local machine and or an any primitive type for specifying that an operation can be performed locally or remotely. Hence a primitive type can provide a hardware specific and or software specific description of a given computing system deployment model. These primitive types can be used to establish equality axioms that can specify a semantic equivalence between a purely functional expression in the SML application and a hardware specific and or software specific expression that describes a particular hardware specific and or software specific attribute of a given computing system deployment model. Hence the equality axioms can provide a nondestructive and reversible mapping between a purely functional expression in the SML application and a hardware specific and or software specific expression of a given computing system deployment model. Primitive types are described in further detail below in Section II of this Detailed Description.

As described below the primitive types can be supplied to the transformation system at different times for example during installation or deployment of the compiler circuit e.g. based on initial compilation of an SML application implementing the compiler circuit during supply of a new SML application that is to be optimized for a new computing system deployment model etc.

Hence the compiler can map a logical type or operation to a machine specific primitive type enabling prescribed patterns of symbols and or operations expressed in the supplied application to be represented as a prescribed machine word for greater execution efficiency.

The prescribed symbol manipulation language enables the development of distributed services designed to enable whole program semantic analysis. Any application written in the SML may be constrained by prescribed policies and constraints and or for security and compliance the application also can be reorganized by the transformation system for distributed or parallel execution any manipulation reorganization and or optimization of the application can be paused stored in a storage medium and resumed at any time.

The transformation system is configured for whole program semantic optimization also referred to as super optimization which achieves near optimal resource utilization for any hardware or software based computing system deployment model. This super optimization by the transformation system is future proof such that any new platform or newly defined resource concern may be added retroactively to all software applications written according to the SML .

The transformation system is configured for leveraging super optimization to inject new features into existing software applications and a catalog of features to be injected for example features such as security distribution decentralization fault tolerance etc. As illustrated in and described in further detail below new features can be injected based on the transformation system injecting a new application containing the new feature e.g. feature Fn 1 into an existing application having existing features e.g. F1 F2 . . . Fn and executing the super optimization for generation of the modified application containing the existing features and the new feature e.g. F1 F2 . . . Fn Fn 1 .

As described in further detailed below each original version of an SML application can be retained e.g. in the storage hence the original version of an SML application can be recompiled into new variants at any time for example as new equality axioms new primitive type sets and or new program fragments e.g. of become available. Since the combination of the SML application with the SML application is semantically equivalent to the modified application and since the original versions of the SML applications and also can be retained by the transformation system the transformation system also can effectively split the modified application into the original application components and or any variation thereof including tens hundreds thousands etc. of application components and or replicas thereof as desired depending on the preferred optimization for a given computing system deployment model e.g. client server computing peer to peer computing distributed computing cloud computing etc. .

The injecting splitting and or replicating of an application by the compilation and execution infrastructure of the transformation system enables the transformation system to build a distributed transaction processor similar to a relational database system and enables the transformation system to provide a series of efficiency improvements based on relevant optimization operations.

The flexibility afforded by the SML of providing a purely functional application providing full semantic analysis enables any one or all of the components and or to be written in the SML allowing future implementers to build next generation systems from a stable mature base.

As described in further detail below the design of the SML and compiler circuit and selection of features for injection can provide a solution for the recurring problems of distributed computing.

The compiler circuit can be configured as a super optimizing compiler where the term super optimizing is defined as the near optimal resource utilization for a prescribed hardware and or software based computing system deployment model. In other words any one of the applications and or of can be executed by a prescribed system A e.g. using an interpreter executed by the prescribed system A however the application is optimized for execution by the system A.

A particular feature of the example embodiments of the transformation system as described in Section I.B above is that time complexity of the compiler circuit can be reduced to mere linear time based on accepting restrictions on the input programs and axioms expressed as axiom constraints . Hence the compiler circuit can execute compilation to optimality for large software projects in a practical timeframe.

Traditional compilers manipulate a program graph which encodes the program being compiled the traditional compiler iteratively performs a series of analysis transform passes . The program graph typically is destructively updated during each pass by the traditional compiler until the program graph is modified to its final compiled form. Hence destructive updates lose additional opportunities for transformation depending on the order in which passes are applied.

The traditional execution of analysis transform passes in the traditional compiler are replaced in the example compiler circuit by a single two phase process illustrated in steps and in step Equality Axioms are repeatedly instantiated on the Equality Graph based on executing pattern matching until no more equalities can be found then an optimality search is executed in step over the saturated equality graph data structure to find an optimal program variant .

An Equality Axiom is a mathematical relationship between two equations. In this case the equations must be semantically equivalent such as a b b a . Equality axioms declare that the two equations mean the same thing intrinsically. This declaration of equivalence by an equality axiom enables the compiler circuit to instantiate the axiom whenever it finds a pattern of code matching one side of the equation adding a new variant of the equation by rewriting it to match the other side of the axiom.

The compiler circuit can be supplied with a set of axioms by default and new axioms can be included in the submitted programs according to prescribed security constraints described below.

Experimental testing has proven the effectiveness of super optimizing compilation on a variety of hardware platforms including commercially available ARM and Intel technologies and a large subset of the Java language.

In this example the compiler circuit can parse the input program in step of into an initial equality graph representing an initial program variant illustrated in . Solid lines represent data flow edges while nodes represent operations. The match rewrite phase executed by the compiler circuit in step can repeatedly instantiate equality axioms to create new program variants illustrated in C and D. illustrates the equality graph based on the compiler circuit instantiating and implementing the equality axiom 4 2 2 . The equality graph provides a representation of the equivalent program variants and where dashed lines represent equality constraints. illustrates the equality graph based on the compiler circuit instantiating the equality axiom k 2 n k

Hence illustrates the initial equality graph EG consisting of a single program variant illustrates the equality graph containing two distinct program variants and illustrates the equality graph containing three distinct program variants and and illustrates the equality graph containing four distinct program variants and including a platform specific e.g. a hardware and or software specific program variant based on an axiom that combines shift and summation operations. Since no more axioms can be instantiated in this example the equality graph is deemed saturated as a Saturated Equality Graph SEG . Hence the saturated equality graph contains four equivalent expression variants i.e. program variants reg6 4 1 reg6 2 2 1 reg6

Once the equality graph is saturated e.g. as in the compiler circuit can initiate optimization in step of . In particular the compiler circuit can calculate a cost variant for each program variant the cost variant specifying a corresponding resource utilization for one or more computing systems. The relative costs of each program variant can be stored in the storage illustrated in as a cost file configured for storing one or more cost variants for a corresponding one or more program variant . Each cost variant can include one or more cost parameters e.g. CPU utilization memory space requirements input output I O bandwidth etc. . As illustrated in the storage contains for the saturated equality graph of identified in as SEG SML a cost file containing cost variants for each of the above illustrated program variants . For example the cost variant costs var1 is associated with the program variant reg6 4 1 the cost variant costs var2 is associated with the program variant reg6 2 2 1 the cost variant costs var3 is associated with the program variant reg6

The minimum cost variant is selected as the output of the compiler based on applying the relevant optimization metrics programs described below for example in Section I.F.5.

The first task of the compiler circuit is to locate nodes in the equality graph that match the pattern for an equality axiom .

Axiom matching by the compiler circuit on a program graph for an application written in SML can be implemented as an example of the tree multi pattern matching problem . This problem can be solved by the compiler circuit in O N M time where N represents the size of the input program graph to be searched and M represents the number of matches found as illustrated by Cai et al. More Efficient Bottom Up Multi Pattern Matching in Trees and Ramesh et al. Nonlinear pattern matching in trees . Hence the compiler circuit can complete axiom based pattern matching in step at near linear time efficiency.

The compiler circuit can execute step based on pre processing the equality axioms allowing individual matches to be recognized in O k time. The parameter k represents the maximum function arity i.e. the number of arguments that a function can accept in the example embodiment of the SML language the value of k is the constant 2 i.e. k 2 . Working from the leaves of the equality graph e.g. the compiler circuit can assign an identifier that represents the set of all possible matching axioms to each node in the tree . As the compiler circuit moves up the tree the compiler circuit can combine sets for each child max O k children per node to generate the parent s identifier a total of O N times .

Matches are implicit in the combined identifiers. For each match the compiler circuit can perform rewrites O M times total. Thus this procedure has complexity of about O kN M .

Another aspect of an SML based application is that the compiler circuit can generate non standard program graphs in some cases which are guaranteed to be Directed Acyclic Graphs DAGs . When operating on a DAG the compiler circuit can execute the matching and rewriting of step in parallel to achieve the desired time bounds since each new rewrite may add a local constant size sub DAG to the equality graph requiring recomputation of the match sets over the affected region.

Hence the compiler circuit can perform matching and rewriting in step for an SML based application in O N M time storing each of the associated results in the storage . While the bounds on M depends greatly on the axioms used prior super optimization projects have reported manageable expansion factors.

According to an example embodiment the equality axioms preferably but not necessarily should be term equalities with O 1 guard predicates. This captures a wide variety of axioms illustrated in Table 1 

The second task of the compiler circuit is to select the optimal solution out of the possible billions of variations offered by the equality graph . The compiler circuit utilizes optimization metrics programs OMPs illustrated in to execute optimization. The OMPs can be executable programs written in SML and which can calculate the cost of an operation for example based on modeling the resources expended by the operation on an identifiable computing system deployment model. OMPs can be used by the compiler circuit to model abstract resources such as operation counts memory allocation and I O bandwidth or advanced chip features such as processor pipelines and support chips such as ASICs.

The compiler circuit can be supplied with a default set of OMPs and new OMPs can be specified within the submitted SML application .

Although a Boolean Satisfiability procedure could be used to search for the optimal program the compiler circuit can be configured to utilize a class of solutions for the Maximum Marking Problem which covers some nondeterministic polynomial time NP class problems such as subset sum and the knapsack problem for combinatorial optimization . In particular the compiler circuit can achieve linear time optimality searches by restricting internal computations to finite domains and constructing specialized constraints on the solution. The compiler can convert the maximum marking problem into a dynamic programming problem which is solvable in O N time where N is the size of the input .

Specifically the compiler circuit can achieve linear time optimization based on the output program graph being a singly rooted DAG each node offering one or more variations to compute the result only one of which can be marked to choose program variants although this restriction could exclude some transformations such as program specialization i.e. partial evaluation these can be recovered as described below in Section I.F. . In addition the cost of a program variant can be the simple sum of all marked nodes cost. The implication of this restriction is that some metrics might not be possible for example some advanced pipelining. Another requirement is that costs as determined during execution of any of the OMPs must be finite non negative integers.

Hence the compiler circuit determines the optimal program as the program variant that has the lowest cost variant . The compiler circuit also can store the parameters associated with identifying the numerous program variants and respective costs including the optimized program variant having the lowest cost as a data structure in the storage . When used as the search phase for the super optimizer of the compiler circuit the input is size O N M . Thus the cost for optimality search is O N M providing near linear time compilation. If however near linear time compilation is not required certain of the aforementioned restrictions can be removed to gain additional expressivity of the equality axioms or optimized metrics programs OMPs at the cost of extended compile times the extended compile times however still produce transformed applications and or in an efficient manner.

Hence the storage of the equality graph e.g. EG or SEG and or the program variants and optionally the respective cost variants in the storage enables non destructible and reversible compiling operations by the compiler circuit including guaranteeing future proof compatibility between different program versions. As described below in Section I.F.2 the storage of the equality graph the program variants and or the respective cost variants also enables incremental compilation.

Feature Injection is the process of the transformation system using automated program generation techniques illustrated in to add functionality to an existing program e.g. . The restrictions imposed by the application written according to SML provide flexibility to automatically inject features written into arbitrary applications written according to SML using super optimization by the compiler circuit . Further the constraints imposed by SML essentially eliminate all system state and enable execution of programs to achieve the illusion of sequential access and persistent resources.

Feature injection can be performed by the transformation system using super optimization based on the operation of the new feature being described in an independent module e.g. the SML based application of then inserting equality axioms and or axiom constraints into the transformation system which equate common operations in a program e.g. with new but equivalent operations which make use of the features included in the independent module .

Parallelization tends to occur locally within a single chassis containing multiple computing devices e.g. processor based devices such as blade servers or distributed across a cluster of similar nodes that are interconnected by physical communication links e.g. high speed data bus or network communication link . illustrates execution of multiple SML applications and across multiple computing nodes based on optimization by the transformation system according to an example embodiment. In the example of parallelization the computing nodes can be implemented as multiple computing devices such as blade servers within a single chassis or computing devices interconnected by physical communications links such as a high speed data bus.

An example of this feature injection by the transformation system is Map Parallelization. Functional programmers can map a function over a list of values. That is a function can be applied to each value in the list in turn generating a new list. This can be referred to as vector processing while CPU manufacturers can refer to it as Single instruction multiple data SIMD . A typical map operation can be illustrated as follows 

This illustrated map operation can be performed in parallel by the compiler circuit for each value in the list recombining the results into a new list at the end. Assuming the transformation system has access to threading SIMD or vector processing primitives the transformation system can be configured to apply an available axiom which matches the map operation and causes the compiler to replace the map operation with a parallel processing operation written in a separate module for example 

This axiom map fn 1st ParallelMap fn 1st declares that the map function and the ParallelMap function are equivalent for all inputs. After the match and rewrite phase is executed by the compiler circuit as described previously in Section I.C.2.a. 2 the equality graph generated by the compiler circuit and which can be stored in the tangible storage medium would contain two different versions of the program 

The super optimizer executed by the compiler circuit then can compute metrics over both versions i.e. program variant and select the one program variant the compiler circuit discovers to be optimal according to the relevant optimization metric programs . If the resource model tracked by the OMPs shows that the thread pool is over taxed or the overhead cost for setting up the vector processing unit outweighs the benefits then the optimizer executed by the compiler circuit would compute the result using the serial implementation.

The map parallelization axiom is an example of a class of more general fold parallel axioms which covers a broad range of parallelism over collections of items. Programs transformed by the compiler circuit using these axioms can provide acceleration for operations over the collections.

In a pure functional language such as the prescribed SML the functions f and g are guaranteed to be independent and may be computed concurrently. This axiom f g ParallelPair f g annotates the operations in a pair or tuple as being parallelizable. The optimizer executed by the compiler circuit can apply metrics to determine if this operation would benefit from parallelization and select the best option.

This is an example of a more general class of parallelization axioms over sub computations embedded in inductive data types. Programs transformed by the transformation system using these axioms provide acceleration when sub computations take roughly the same amount of time to compute thus minimizing synchronization delays .

A complete feature injection by the transformation system for parallelization of an arbitrary application would perform many such rewrites using a plurality of special case axioms. Additionally larger structural adjustments to the program can be made by the transformation system to expose the maximum number of parallelization opportunities. This can be the best possible parallel version of the program given the available axioms because super optimizer executed by the compiler circuit captures all equivalent versions of the program and the optimality search by the compiler circuit selects the globally optimal version given the supplied metrics . This is possible due to the constraints imposed by the symbol manipulation language . For example a programmer is not permitted to define hardware specific operations for example explicitly launching threads or defining synchronization points.

As described previously parallelization tends to occur locally within a single chassis containing multiple computing devices e.g. processor based devices such as blade servers or distributed across a cluster of similar computing nodes that are interconnected by physical communication links e.g. high speed data bus or network communication link . In contrast distributed processing can include computing devices of the same or widely varying capacities including unique special purpose hardware the computing devices configured as network nodes communicating over an unreliable network with varying link capacities and transmission characteristics e.g. local area network LAN or wide area network WAN connections . Hence can illustrate distributed processing where each computing device can be implemented as a network node communicating with other computing nodes via LAN or WAN links. Such a computing device configured as a network node for communication with other network nodes and configured for executing a distributed computation in response to a request from another computing device also can be referred to as a remote node .

In one embodiment the transformation system can be configured to successfully inject distributed processing capabilities into arbitrary applications . Logically any independent sub computation illustrated as in can be copied or split i.e. partitioned from an existing application e.g. of and distributed to another computing device implemented as a network node in the network.

The example embodiments as illustrated by the transformation system can address issues such as choosing what computation to distribute i.e. copy and or partition and send which network node should be sent the distributed computation when to send the request for executing the distributed computation and how the request should be processed. The example embodiments also can address the dynamic nature of a distributed system lost delayed and corrupted messages network partitions erroneous or malicious nodes etc.

In one embodiment axioms are provided that partition the application into all possible independent sub computations example axioms are illustrated in Table 2.

The super optimization process executed by the compiler circuit can select a program variant that optimizes the model exposed by the metrics . For instance if the metrics executed by the compiler circuit select for fastest computation of the result then a program variant can be chosen by the compiler circuit such that the cost of sending the computation remotely is masked by work that needs to be performed locally.

With another set of metrics the program variant chosen by the compiler circuit can ensure multiple nodes compute the same result for fault tolerance or that a particular class of node is always chosen to perform a critical step of the procedure perhaps due to policy compliance etc. Hence a particular program variant may be chosen for optimization of a particular metric.

Experimental testing of the transformation system according to the example embodiment led to the discovery by the inventors of synergy between independent sets of axioms for example the optimization axioms and the distribution axioms the distribution axioms gathered as many remote computations as possible into a single operation allowing a significant reduction in the number of messages transmitted hence the distribution axioms exposed additional opportunities to apply the optimization axioms to the newly coalesced remote computations for example to eliminate redundant sub expressions which may reduce the total bytes transmitted. Hence the combined use of the optimization axioms and the distribution axioms defined not only a protocol for exchanging computation but also a self regulated granularity for the application s application programming interface API over a network. Such optimization can be performed by the transformation system automatically and optimally for each application in the system .

The compiler circuit is implemented based on writing an SML application expressing the compiler operations according to the prescribed symbol manipulation language SML and causing the SML application expressing the compiler operations to compile itself as described previously in Section I.C.2 including causing the SML application to build a program graph in step of applying the equality axioms to generate a saturated equality graph in step and causing the SML application to execute in step an optimality search over the saturated equality graph to determine the optimal variants using the OMPs . The optimized SML application identified by its saturated equality graph its optimized program variant and associated lowest cost variant can be stored in the storage enabling dynamic updates and optimization of the compiler circuit . The optimized SML application also can be reduced to a hardware specific platform for example an application specific integrated circuit ASIC if preferred.

Hence future implementers can extend the transformation system at every level as well as bestowing the system all benefits provided to its applications distributed parallel fault tolerant super optimized etc. This self applied version of the compiler is the basis for the design of a distributed services engine discussed in Section I.F. below.

The deployment of parallelization among a large number of processors is different from that of parallelizing on a few processors. The example embodiments can be implemented as a distributed system with potentially millions of processors.

The example embodiments impose restrictions on the form of the solution such that partial results can be combined to achieve the final result. Data parallel procedures are a fine grained many processor parallelism which assumes communication is the bottleneck rather than computation .

The example embodiments require the function to be parallelized to be a monoid binary closed associative has an identity element and is not required to be commutative. These restrictions enable fine grained parallelism which scales down smoothly ensuring the best possible parallelism for commercially available hardware up to the size of the problem . Hence the function can be computed in O log N communication steps.

According to one example embodiment a Bottom up Tree Multi Pattern Matching technique is used because it fits the monoid requirements allowing efficient parallelization when self compiled in the transformation system .

The optimality search procedure does not meet the monoid requirements but dynamic programming can be profitably distributable enabling the optimality search to be implemented using parallelization.

The compiler circuit can be implemented based on batch processing a single source SML application into a single executable application . The compiler circuit also can be implemented as a complete distributed services engine based on the compiler circuit including an evaluator circuit illustrated in .

The compiler circuit and the evaluator circuit in combination can immediately compile and evaluate incoming program fragments e.g. of and or of . Results from the immediate compiling and evaluating of the incoming program fragments e.g. and or can be returned to a submitting client device either as a transformed application e.g. of or as part of a modified application e.g. of based on the incoming program fragment of and another existing SML application of . As illustrated in the results e.g. of or of and the associated graphs and cost variants also can be stored in a non transitory storage e.g. storage device for later retrieval. Since results can contain functions as well as values the transformation system can implement behaviors needed for distributed services.

The evaluator circuit can implement a runtime infrastructure required to execute an SML application compiled according to the symbol manipulation language and associated constraints and is analogous to a C runtime library or a Java Virtual Machine. The evaluator circuit for the SML is configured for providing a non destructive association with the hardware specific and or software specific attributes of the computing system deployment model that are required for execution of the SML application example attributes including memory management persistence networking etc.

The evaluator circuit can be implemented using any programming language including SML . The evaluator circuit also can be supplied a program e.g. SML application in a form of byte code or statically linked with the program e.g. as a native library that is loaded and executed by the compiler circuit during the compilation process. Executable programs used to implement the evaluator circuit can be general such that they work on any hardware or software platform or specially designed and implemented e.g. as a hardware based logic circuit such as an application specific integrated circuit FPGA for a particular platform or purpose.

At a minimum any executable application for a given computing system deployment model that is used to implement the evaluator circuit must provide a primitive set that establishes a nondestructive equivalence between native versions i.e. hardware and or software specific expressions of each primitive in the SML language enabling all programs to work with all evaluator circuits . Beyond this minimum an evaluator circuit can expose additional primitives such as threading vector processing persistent storage databases networking or other platform specific features described below in further detail in Section II. These features can be used when associated equality axioms and metrics are provided to the compiler circuit .

Thus an SML application compiled for an evaluator circuit with persistence can cause the evaluator circuit to store or retrieve data from a storage medium during the computation of its results. The same SML application compiled for an evaluator circuit with networking could operate as a distributed computation.

Example embodiments disclosed herein can implement distributed services. New SML applications e.g. applications services transactions and axioms constraints e.g. constraints policies can submitted to the transformation system continuously. As described in Section I.C.2.a. 1 previously traditional compilers iteratively performed destructive updates to a program graph of a program. Hence prior systems required each program to be recompiled from scratch i.e. starting with a new program graph each and every time even if the same program is submitted multiple times such as a recurring query to a database .

In one example embodiment the compiler circuit can utilize previous compilation results stored for example in the storage and perform only the incremental compilation for work that is new. As described above in Section I.C the storage can store the saturated equality graph the associated program variants and respective cost variants associated with compiling a given SML application . Hence according to the example embodiment an incremental version of the matching procedure can be utilized.

A Monoid Annotated Binary Tree as described in Section I.E above can convert a parallel prefix procedure into an incremental procedure. The benefit of an incremental procedure is that updates to the equality graph structure e.g. the saturated equality graph of can occur within O log N M time as opposed to O N M time for the batch procedure. Since our match procedure was selected to meet the requirements for parallel prefix it also meets the requirements for monoid annotated binary trees.

The benefits of an incremental system multiply as the system grows if multiple programs use the same module or multiple transactions call the same sub function the majority of the work for these shared components has already been performed.

As described previously in Section I.C.2.a. 3 the restricted form of solutions returned by the near linear time super optimizer could exclude some transformations.

Program specialization is a class of transformations normally provided in a computing system deployment model providing distributed services. Program specialization operates on program fragments as opposed to complete or closed programs.

Program specialization is excluded by the restrictions imposed by axiom constraints and or system constraints because a specialized version of a program may duplicate a function and optimize each copy differently. The transformation system however is configured for optimizing each copy of the function the same way. Without program specialization however program fragments wait for all their arguments before computation begins.

According to an example embodiment program specialization can be implemented as an additional transformation option following generation of a transformed SML application that enables nondestructive optimization of program fragments if platform specific capabilities are available. As described below unique abilities of a particular computing node e.g. platform specific capabilities can be utilized to perform optimized transformations that may not be possible on another node. Hence the transformed SML application having an additional transformation option can be executed as an optimization for a particular computing node comprising the platform specific capabilities relative to the transformed SML application that does not include the transformation option. If platform specific capabilities are not available e.g. the particular computing node is not available the transformed SML application can still be executable by a generic computing system deployment model that lacks particular computing node because the optimization of the transformed SML application is nondestructive. As stated previously since the transformed SML application is semantically equivalent to the original SML application the original SML application also can be optimized to any particular computing system deployment model.

Hence although a generic computing node may not be able to execute a transformed SML application as efficiently as a particular computing node having platform specific capabilities the transformed SML application still can be executed by the generic computing node with no loss of functionality.

As described previously in Section I.C.2.a. 3 intermediate and final compilation results e.g. the equality graphs of and associated cost variants can be stored by the compiler circuit in the storage . Further these intermediate and final compilation results are fully nondestructive and semantically equivalent enabling further optimizations as existing operations are further optimized or new operations are added. Hence the use of a previously cached optimal compilation result can provide a significant performance improvement.

Hence the transformation system can be configured for continuous compilation where applications are continually optimized by the transformation system as new SML applications and or new equality axioms are added.

In one example embodiment continuous compilation can be executed by the transformation system applying a competitive compilation analysis as follows.

In response to receiving an SML application the transformation system can be configured for generating and storing in the storage two copies of the received SML application an active copy which represents the dynamic partial results and a static copy used for incremental compilation. Data structures in the storage can be shared to provide a negligible increase in memory. The transformation system can be configured for causing the compiler circuit to evaluate the active copy of the SML application based on an arbitrary execution plan for example the compiler circuit can be configured to determine the relevant cost variants for execution of or during execution of the received un optimized version of the SML application .

The transformation system also can cause the compiler circuit to execute the matching and rewriting and optimization search on the static copy as described in Section I.C.2.a preferably concurrently with the evaluation of the active copy.

The compiler circuit evaluates the active copy as described in as described in Section I.C.2.a relative to the arbitrary execution plan. In response to the compiler circuit completing evaluation of an identified sub branch of the active copy the compiler circuit replaces the identified sub branch in the active copy with the corresponding sub branch of the equality graph for the active copy as determined by the compiler circuit .

If the compiler circuit identifies an execution plan for the static copy that requires less time to complete the corresponding evaluation than the remaining time required to evaluate the active copy according to the arbitrary execution plan the compiler circuit can terminate and discard the evaluation of the active copy according to the arbitrary execution plan and begin evaluating the more optimal static copy according to the identified execution plan.

The foregoing competitive compilation analysis can be coupled with incremental compilation as described in Section I.F.2 such that the results of the initial execution of compiling a received program could be cached in the storage e.g. as a partially evaluated equality graph EG or a saturated equality graph SEG with associated cost variants enabling subsequent compilations to be accelerated based on retrieving the cached results.

A Pareto Optimal solution balances trade offs among competing constraints or trade offs e.g. price vs. performance execution time vs. memory bandwidth vs. quality etc. such that any improvement that can be made in one constraint measured along one axis requires sacrificing some constraint that is measured along another axis. Prior methods for software improvement and analysis required heuristics to select among such competing tradeoffs. Such heuristics are known to be either inaccurate or detrimental in some domains. For example the decision to inline a function during compilation may allow application of constant folding and other optimizations but causes code growth which raises cache pressure i.e. cache memory size requirements possibly slowing the computation down significantly as a result. In any sufficiently interesting domain containing competing constraints such as software optimization a separation of solutions emerges Fully dominated solutions which are always undesirable or Non Dominated solutions representing trade offs of available resources. Heuristic software optimizers cannot distinguish between these clusters of solutions and often produce fully dominated undesirable results.

Some existing projects attempt to achieve pure optimization at some granularity by thorough analysis of the search space selecting the optimal result. These projects pre select a resource to optimize such that no trade offs can occur their result is optimal only from the perspective of optimizing consumption of the chosen resource.

Pareto optimal solutions typically form a set called the Pareto Frontier in which all solutions are equivalent under the constraints.

According to an example embodiment and as described previously the equality axioms and optimization metric programs OMPs can be used by the transformation system to analyze applications supplied to the transformation system and generate transformed applications from an equality graph e.g. of . As described previously the equality graph e.g. can contain a sufficiently complete graph of the semantics preserving software transformation solution space. This solution space contains nominally all possible transformations of the input program including all possible trade offs of resource usage.

According to an example embodiment these equality axioms and OMPs can be used by the transformation system to generate pareto frontiers PF illustrated in based on the cost variants for the respective program variants . For example one program variant from the saturated equality graph may have a corresponding cost variant that requires less CPU utilization but more memory space e.g. Random Access Memory RAM space while another program variant from the saturated equality graph may have a corresponding cost variant that uses less RAM space but requires more CPU utilization or other requirements e.g. network bandwidth utilization etc. . In the absence of additional constraints or RAM limits CPU quotas etc these program variants can be selected arbitrarily.

According to an example embodiment the arbitrary selection of program variants from the saturated equality graph introduces an opportunity for additional design elements for compiler optimizations described below.

As illustrated in and each program variant of the equality graph has a corresponding cost variant the corresponding cost variant can be annotated into the equality graph for example based on adding to each node of the equality graph an index value that uniquely identifies the corresponding cost variant . Hence the saturated equality graph e.g. of can be annotated with resource consumption metrics for identification of the associated costs across multiple cost dimensions. The availability of searching the saturated equality graph relative to multiple cost dimensions based on the respective costs enables the compiler circuit to execute optimization based on one or more optimization domains each optimization domain including a corresponding set of optimization metrics. For example one optimization domain may specify optimization metrics for execution by a single computing device e.g. in disconnected mode such as CPU utilization memory space requirements etc. other optimization domains can specify optimization metrics for partitioning an SML application according to various criteria for example administration of security policy discussed in Section VII. below execution by a remote computing node that at various times could be disconnected from a network discussed in Sections I.G.6 and VI. below or distributed execution by a distributed computing system having multiple computing nodes discussed in Section V. below .

The Pareto optimization described herein can be implemented for use in any one of multiple execution environments. For example the Pareto optimization can be used as any one of a front end of a multi stage compiler e.g. to annotate software fragments for targeted transformations by future stages a back end of a compiler framework which reduces the result of domain specialized transformations to a final output language and or a whole or complete compiler that reduces a saturated equality graph e.g. of via semantic transformations into the transformed application e.g. and or .

A particular feature of the example embodiment is that the compiler circuit can be configured for executing pruning operations on the saturated equality graph to improve search efficiency. Pruning can become particularly effective as the input SML application and or the available domains of execution systems as described in their respective optimization metric programs increase in complexity. For example a commonly recurring sub region of the equivalence space in the saturated equality graph may be quite large but have only a few useful nodes. Based on the compiler circuit pre generating these regions and pruning the undesirable nodes a large number of repetitive instantiations of the sub region may be avoided. For example a given platform can have a precise hierarchy of mathematical primitives for multiplication e.g. bit mask sum shift multiply . Once this hierarchy is explored by the compiler circuit all future instances of multiplication may enjoy the result there is no need to re instance the graph.

Software optimization axioms might include infinite expansions such as a a 0 . These expansions are rarely useful beyond one instance e.g. a 0 may be useful but a 0 0 is unlikely to be . By limiting the instantiating of these axioms the compiler circuit can avoid infinite model growth.

Improvements in resource consumption occur at a higher rate for abstract code fragments as opposed to low level register or native operations. These larger algorithmic improvements are typically always desirable selections when appropriate e.g. Radix Sort vs Bubble Sort Hash Map vs. Bin Tree Map . Pre calculating algorithmic selection for a given problem instance by the compiler circuit eliminates large undesirable search areas.

Pruning also can be used by the compiler circuit to remove trade offs or program variants in the Pareto frontier that are uninteresting or unrealistic. For example a large class of trade offs or program variants can result in implementations that consume unrealistic amounts of computing system resources for example an input SML application that should only take seconds to finish could be transformed to a program variant that requires weeks to complete execution but which only consumes a few bytes of memory in this example the compiler circuit can prune such program variants providing unrealistic solutions from the saturated equality graph.

Pruning for removal of unrealistic trade offs or program variants can be implemented based on applying feasibility constraints relative to an ideal computation e.g. given an average set of computation resources what would a typical computation consumed the feasibility constraints can be defined relative to the ideal computation to limit the instantiation of program variants to those which use less than an order of magnitude more of any resource. Hence the use of feasibility constraints relative to an ideal computation is distinct from existing optimization techniques that rely on specific metrics of allowed solutions referred to as feasible solution constraints where the feasible solution constraints must be specified in relation to the available variables in the implemented solution i.e. CPU utilization must be less than 100 units memory utilization must be less than 10 gigabytes bandwidth utilization must be less than 64 kilobits per second etc. . Hence the feasibility constraints relative to an ideal computation can be applied by the compiler circuit both for executing pruning of a saturated equality graph as well as defining practical and effective feasible solution constraints.

Pareto optimization by the compiler circuit also can be applied to leverage platform specific capabilities described in further detail below in Section I.G.4. In summary existing techniques cannot leverage specialized hardware capabilities for large scale application restructuring. For example a program which uses cryptography cannot be automatically translated to use a hardware crypto accelerator device.

According to an example embodiment the compiler circuit can be configured to apply Pareto optimization in order to select a hardware accelerator if the overall resource utilization would be improved. Note that non pareto techniques would unanimously select a hardware accelerator if it is available creating a bottleneck for access to the device. Pareto techniques would balance access to the existing hardware and overflow requirements would be supplied by other resources CPU remote machines etc .

The use of Pareto optimization by the compiler circuit also eliminates the requirements for metric weights and transformation order. In particular existing techniques require weight formulas for combining metrics as well as order of application for software transformations. According to an example embodiment the compiler circuit eliminates these requirements allowing any number of metrics and transformations to be intermixed without specification of ordering or weights.

The use of Pareto optimization by the compiler circuit also enables transformations at all levels of granularity to be intermixed. In contrast existing software transformation frameworks typically provide transformations at a single or narrow band of granularity peephole optimizers provide re arrangement of several assembly instructions traditional compilers provide for transforming a single function advanced compilers provide for transformations over a single module etc.

In contrast the compiler circuit enables transformation of all levels of granularity to be intermixed such that large scale algorithmic transformations e.g. quick sort versus bubble sort can be specified along side platform specific peephole optimizations. Hence the compiler circuit efficiency improvements by selecting a concrete solution from a set of solutions with a range of resource trade offs. The compiler circuit also balances utilization of available resources maximizing work performed. The compiler circuit also allows a range of optimization time vs resulting efficiency improvements which are consistent additional resources assigned to perform software improvements are guaranteed to discover improvements if they exist. Execution time may range from just in time compilation to full system inter module optimization.

The compiler circuit also does not rely on ad hoc heuristics to select transformations. A transformation is selected only if its result achieves improvement in the resulting metrics. The compiler circuit also can select platform specific capabilities such as hardware accelerators or specialized ASICs without requiring the software developer to plan for this capability. Further the compiler circuit eliminates the requirement for assigning metric weights when combining independently developed resource consumption metrics and eliminates any requirement for selecting an order to apply transformations.

A processor based computing node executing a continuously running service engine can be configured for tracking available resources RAM CPU time I O bandwidth etc over time and storing the tracked resources as a resource consumption profile RCP in the storage of . The resource consumption profile can specify actual resource consumption or expected resource consumption.

In response to initiating compiling an application the processor based computing node executing the transformation system can retrieve an expected resource consumption profile the retrieved resource consumption profile can be used by the compiler circuit to identify one or more of the cost variants along the pareto frontier and having the closest correlation to the retrieved resource consumption profile. Hence the compiler circuit can identify the one or more optimal program variants based on identifying the respective one or more cost variants along the pareto frontier and having the closest correlation to the retrieved resource consumption profile . Hence the transformation system can identify the optimum program variant from the pareto frontier which balances the consumption of available resources. This balanced resource utilization can optimize the system as a whole translating into higher utilization. Consequently the Pareto optimization by the compiler circuit may apply balanced resource utilization to transform an input SML application in order to fit current or expected resource availability over a short timeframe this technique can be particularly effective in transaction processing.

If users of a computing system executing the transformation system or applications executed by the computing system are assigned resource quotas then the compiler circuit can select the program variant which balances the consumption of the available quota.

For example if a user s storage quota is under utilized then a pareto optimal solution which uses more storage and less CPU RAM could be chosen. This would conserve the sparse remaining quota for future requests.

Execution of an application by a computing system does not instantaneously produce its intended results. Rather there is a pattern of resource consumption over time a shape by a service engine executed by at least one processor circuit in the computing system. The service engine is the application runtime environment implemented by at least one processor circuit storing application state variables and computation data in a tangible memory e.g. DRAM . Hence the application is executed based on the service engine satisfying the data flow requirements of the application. This shape of an application i.e. application shape coupled with the power of a super optimizing compiler can achieve a new kind of optimization the optimization of the shape of a transaction s resource consumption in the time domain is referred to as second order optimization .

The utility of second order optimization by the compiler circuit can be best highlighted by its affect on utilization. For any given mix of executable applications a second order optimizer executed by the compiler circuit can fit the executable applications into a given set of resources more compactly than traditional techniques.

By way of analogy if one imagines programs as pieces of a jigsaw puzzle then a traditional service engine can be seen as placing the pieces side by side without attempting to fit them together. The super optimizer is able to fit the pieces together whenever this is possible. A pareto optimizer is able to change the shape of each piece enabling them to fit together when they might otherwise not.

As described previously the compiler circuit can be configured for generating native code for any platform given the appropriate axioms and metrics . The disclosed compiler circuit has been demonstrated in experimental testing to compete favorably against expert human optimizations i.e. manual optimizations and to balance factors that are often overlooked power efficiency code size vs. execution speed RF interference modeling etc .

The following description identifies optional features that can be added injected into an executable system by the transformation system based on adding the corresponding SML application .

Security validation is defined herein as identifying the existence of some desirable behavior or absence of some undesirable behavior. Such behaviors can be specified using the SML language along with associated axioms and metrics . An important concept in proving the security of software is that checking a proof is easy and fast although generating a proof may be difficult.

For the purposes of this section we assume security of the underlying hardware operating system OS and evaluator circuit .

The equality graph and axioms described previously are ideal for generating security proofs. The super optimizer can generate a proof by listing each axiom instantiated in transforming an original program into the final program variant .

Since the behavior whose existence absence proof to be identified is written in SML this process of security validation can be considered another form of feature injection. If the compiler circuit can successfully derive a program variant i.e. successfully inject the feature then the generated proof provides a mechanically verifiable guarantee that the software holds the behavior its existence or absence .

This proof object can be efficiently checked in real time if necessary before accepting a program for execution. Proof objects may also be transferred among distrustful parties as they represent explicit truths about unknown program fragments.

Policy compliance often can be implemented simply as sets of metrics which track and cap certain operations quotas . An example of policy compliance requiring new axioms is the insertion of logging such as a medical records system that logs accesses to patient records. Another aspect of security arises based on adding new axioms or to the system.

A system of axioms is said to be consistent if no invalid statement can be derived using the system. Proof of consistency for a new axiom added to a system can be attained by requiring a client who submits a new axiom to provide proof of its consistency. Another technique is to attempt to produce a consistency proof but charge the work against the user or program and abort if the effort exceeds some quota.

Once the axiom is proved consistent by the transformation system the axiom may be applied to all programs not just the program for which it was submitted. This behavior causes a multiplicative effect as new axioms added for one program are applied by the transformation system to other programs improving the performance and resource consumption of the system as a whole.

This same strategy applies to modules functions and other sub components of programs. If two programs submitted by independent parties use equivalent sub components the super optimizer can be configured to select the better of the two implementations and use it for both programs. Here proof of equivalence is required which is the series of axiom instantiations transforming the less efficient implementation into the better implementation.

Proofs also can be valuable for capturing domains with strict government certifications. The certification requirements can be encoded as axioms or and the program can be compiled by the compiler circuit under these axioms. If the compilation is successful the program is guaranteed to meet the certification.

Fault Tolerance is the ability of a computing system to tolerate expected but unpredictable failures. Fault tolerance is particularly beneficial for fault prone computing nodes communicating across unreliable communication networks e.g. Internet Protocol IP based networks such as a private wide area network or the World Wide Web . Therefore providing guarantees against expected failures is desirable for many distributed applications.

As illustrated in fault tolerance can be injected into a program based on the transformation system performing consensus on partial results of the program. The program e.g. can be divided into independent sections e.g. etc. and multiple computing nodes in the network can perform computation of each section. As described previously the SML language is non Turing complete hence the independent sections e.g. cannot interfere with each other for instance they cannot have race conditions or deadlocks when executed concurrently . If a quorum of computing nodes agrees on the partial results for a given section e.g. then computation may begin on the next section e.g. .

Any axioms configured for fault tolerance can minor axioms for distribution as the distribution points can be exactly those points where fault tolerance can be inserted. However the metrics for fault tolerance differ where distribution attempts to reduce the time to compute the result by performing some tasks concurrently a fault tolerance algorithm attempts to reduce the cost of a failed consensus which would require re computing the section .

Example metrics can model statistical summaries for ping times a remote computing node s capacity to perform computations reliability estimates for network links and computing nodes and estimated downtimes when failures are detected. Super optimization by the compiler circuit can optimize the granularity of sections e.g. to achieve the best balance between computation throughput and disruption due to failures.

In one example embodiment the transformation system also can be implemented and applied in hardware based real time systems given that the hardware OS and evaluator circuit are valid for real time processing.

The example metrics for super optimization are not limited to finding the fastest program as the optimal program variant to the contrary the example metrics executed by the transformation system can select among program variants with stable consistent processing times. These example metrics referred to as real time metrics can enable the selection of ideal variants for real time scenarios.

The real time metrics can be applied by the compiler circuit to any program written in SML greatly expanding the available software for real time applications reducing the cost and time to market for projects with real time constraints. The compiler circuit also can identify any application that cannot satisfy a constraint or that expresses a project s real time deadline. Hence the compiler circuit can be used to eliminate a large class of potential failures. As with security proofs the compiler circuit can generate verifiable proofs that a program always meets its deadlines.

Certain computing system deployment models can contain specialized hardware ASICs daughter cards vector processors etc . Prior applications have required significant rewrites and tuning to utilize the special hardware.

According to one example embodiment the super optimizer can automate the process of rewriting an application . The evaluator circuit can expose an application programming interface API to access the special hardware and a set of axioms and metrics can be added that define patterns of use. The super optimizer can replace sub computations in the program with calls to the platform specific hardware API. A program variant leveraging the specialized hardware is selected if some benefit is discovered from the corresponding cost variant .

As mentioned before the super optimizer also can be configured for restructuring the architecture of the application to increase opportunities to access the specialized hardware. More generally the example embodiment can be used for any proprietary extensions available on some platform but not others not just specialized hardware . Some examples of proprietary extensions can include cryptography where a program may require a cryptographic algorithm which is only provided by a special node Trade Secrets where a company may choose to add some axioms only to the compiler in their products e.g. improving performance reducing energy costs in this example benefits can be seen only when programs are executed in a system containing these nodes to promote product differentiation and brand loyalty.

Other examples of proprietary extensions can include Value Added Services where services such as logging statistics customer tracking and advertisements can be provided through proprietary extensions. Applications executed in systems without these nodes would not gain the value add features.

The example embodiments simplify system wide management and instrumentation where features can be injected to track the desired data and store it into a stable data storage e.g. . A separate centrally managed application can access this data generating the necessary reports or collating output into an exportable format.

Example management applications include tracking network events collecting statistics on compiler efficiency improvements in speed size energy costs and generating evidence for the return of investment of the IT infrastructure.

Disconnected operation is the continued utility of a program during execution by one or more computing nodes during failures of a communications infrastructure interconnecting the computing nodes. In some sense disconnected operation can be considered the opposite of distributed processing as the program under execution by a computing node can make progress using only locally accessible resources.

Thus if a computing node determines it is disconnected from the network the computing node executing the transformation system can choose to perform actions locally even if those actions cost significantly more. When an operation requires interaction with an unreachable node the computation can be persisted locally cached queued until communication is re established.

In one example embodiment decentralization Peer to Peer is defined as the elimination of globally identifiable knowledge. Decentralized programs can operate without any notion of centralized or global control.

Many distributed applications that are designed to operate in a decentralized manner actually include global concepts within them acting against their desired goal a Globally Unique Identifier is a common example of this problem .

In one embodiment decentralization can be realized in the SML by the transformation system enforcing lexical scopes for all identifiers and eliminating globally accessible state functions and constants. Together with the restrictions discussed previously every program written according to the SML operates only on local knowledge and is therefore formally decentralized .

Programs can be operated in decentralized fashion by providing metrics for selection among multiple sources of a data value e.g. load balancing or rarest first . If a computing node has access to a data value from multiple sources the computing node can choose the best source to retrieve the data value. Centralized deployments are a degenerate case where only one source is provided.

Persistence is the stable storage of information across common failures by one or more computing nodes such as reboots server maintenance and power outages.

Programs written in the SML language can interact with stable storage e.g. based on execution by a compiler circuit having an evaluator circuit with persistence features. As described previously the evaluator circuit can store partial computations in the storage for later retrieval e.g. a pause in computation .

For example an evaluator circuit can store a computation in order to free memory for another operation or while waiting to synchronize concurrent operations.

Another common programming concept is to model entities that evolve independently from the rest of the system. Examples of such entities can be the tables and records stored in databases. These entities can be modeled in the SML language using standard techniques state monads and inductive data structures . When profitable these entities can be persisted to stable storage emulating the function of relational databases.

Computational caching may also be used to improve performance a standard technique called Memorization.

Experimental testing has validated the effectiveness of the example embodiments disclosed herein based on applying various axioms and has proven the effectiveness of additional disclosed features including parallelization Section I.D.1 distributed processing Section I.D.2 load balancing Section I.G.7 persistence and transformations such as map fusion and program specialization Section I.F.3 .

As described previously a primitive type is a base type of input or output from which all other logical types are polymorphically derived. The prescribed symbol manipulation language can be used to write applications that do not rely on any primitives to the contrary the symbol manipulation language is a purely functional language providing a logical specification describing the functions to be executed based on the manipulation of symbols independent of any computing system deployment model. As described previously the prescribed symbol manipulation language can provide a logical specification that describes functions based on manipulation of symbols using types consisting only of tuple sums and lambda types.

The compiler circuit can determine whether a given symbol or an expression containing multiple symbols should be implemented as a particular primitive type during optimization of the SML application .

The optimization of the SML application by the compiler circuit requires that desired properties can be maintained for any application optimized for a given computing system deployment model without introducing undesirable attributes such as instability loss of security or the loss of the ability to perform nondestructible transformations for different computing system deployment models. For example one optimization can exploit the availability of a platform specific hardware component e.g. an application specific integrated circuit although concerns can arise about the loss of the ability to perform nondestructible transformations from the transformed application optimized to use the proprietary features of the application specific integrated circuit.

According to an example embodiment the primitives can be segregated into distinct languages having respective sets of language primitives. Each of the languages also referred to as primitive layers enables the establishment of a hierarchy of primitives that ensures that an application can be optimized into an optimized application for a specific computing system deployment model having one or more specific attributes e.g. application of optimized for System A and or optimized into an optimized application that generically can work on any platform e.g. while maintaining security and stability.

The languages i.e. primitive layers can be segregated based on semantics and prescribed primitive requirements that define the boundaries of each of the languages . Each primitive layer e.g. and has a corresponding set of semantics and prescribed primitive requirements relative to at least one computing system deployment model hence the corresponding set of semantics and prescribed primitive requirements define whether a primitive can be included within the corresponding primitive layer. Hence if the compiler circuit performs optimization for a particular computing system deployment model e.g. disconnected operations the compiler circuit can perform the optimization using one or more associated primitive layers e.g. and that include language semantics and primitives for the corresponding computing system deployment model. The resulting optimized application utilizing a particular primitive layer however must be executed on a computing system having the corresponding computing system deployment model with appropriate privileges .

Hence by reasoned choice of primitives in each language the desired properties can be maintained for any application written using the symbol manipulation language while segregating primitives of other languages to avoid undesirable effects.

Each of the dependent primitive layers through are independent relative to each other. Hence the compiler circuit can utilize one or more primitive layers e.g. and for optimization of an application to be executed by a computing system deployment model having the associated attributes of the selected primitive layers. However the primitive layer imposes a constraint that requires non global identifiers hence any primitive from the primitive layer that specifies a global identifier is rejected by the primitive layer

Hence stability and security can be maintained by the compiler circuit based on the compiler circuit utilizing a one way inheritance to ensure that adverse effects are not introduced from primitives that are not required for optimization according to a particular computing system deployment model.

The core language i.e. the core primitive layer is illustrated as in and includes the syntax and semantics of the symbol manipulation language that enables the SML application to be executed generically of on any computing system deployment model. Hence the core language includes the syntax and semantics and core language primitive requirements for a generic computing system deployment model having no hardware specific or software specific requirements.

The core language also includes the primitive layer requirement consistent with the syntax and semantics that the core language and associated core language primitives are declarative purely functional including integer and character constants tuples unions functions lists and trees. Exemplary semantics of the core language primitive layer include terminal identity composition pair construction projection injection case inspection distribution abstraction application inductive and coinductive data construction and catamorphism fold . Further the primitive layer requirements for the core language primitives specifically exclude general recursion and other turing complete behavior context free identifiers global identifiers and platform specific primitives unique hardware APIs native data types etc available only on a particular machine . Hence the semantics and prescribed primitive requirements of the core language have a uniquely exclusionary relationship to any computing system deployment model other than the generic computing system deployment model in that the core language is independent of any computing system deployment model having any hardware or software based requirements because the core language requires purely functional primitives. Additional core language primitives can be added to the core language as new discoveries are made in foundational mathematics universal algebra and Category Theory.

It should be noted that any reference to integer within the description of the core language refers to a type that is defined in the prelude library using purely symbols illustrated in Section III below and not a numerical integer such as a 32 bit integer.

The primitive layer requirements for the core language primitives ensures that arbitrary third party software written using the core language is trustworthy that the third party software cannot corrupt data cause system instability etc. in other words the third party software written using the core language is safe . Core language modules using the core language may be composed and extended without restriction.

In general application developers typically will write SML applications using the core language . In contrast system developers for specific computing system deployment models in general will write programs using the relevant model dependent languages through while maintaining compliance with the requirements of the core language

The model dependent languages and include semantics and prescribed primitive requirements that are based on at least one or more software and or hardware based requirement of a computing system deployment model. Hence each successive model dependent language e.g. through that is dependent on the core language can provide successive restrictions and primitive requirements for more specific computing system deployment models. In this regard one computing system deployment model e.g. distributed computing can contain one or more specific computing system deployment models e.g. peer to peer computing client server computing using distributed servers based on locality etc. .

The domain language includes primitives that are unique to a computing system deployment model for a corresponding domain example domains can include vector mathematics video processing time or date functions etc. These primitives in the primitive stack can be combined using the core language to form programs operating on domain data. As with the core language the semantics and prescribed primitive requirements for the domain language require that a domain primitive must not introduce turing complete behavior global identifiers nor platform specific concepts.

The domain language inherits the attributes of the core language for an SML application that is optimized by the compiler circuit to include the domain language hence the resulting SML application optimized by the compiler circuit based on the core language and the domain language is a domain module. Hence if software modules using domain primitives are combined with core language modules the resulting module also is a domain module. In this manner domain primitives are viral enforcing domain constraints across all included software modules.

Multiple modules using different and distinct domain languages also can be combined if the domain constraints can be solved under the combined set of constraints. If domain constraints of respective distinct domain languages cannot be solved under the combined set of constraints the attempted composition is rejected and can be resolved using deployment primitives.

Domain modules implementing the domain language also are safe with respect to execution of untrusted third party software. In other words generally only safe programs should be accepted from untrusted entities and unsafe programs should be accepted only from trusted sources.

The deployment language can be combined with the core primitive layer and any one or more of the dependent primitive layers e.g. and or as appropriate by the compiler circuit into a complete executable application also referred to herein as a deployment module. The non global requirement is removed for deployment hence a deployment module can define and propagate global identifiers among modules. Since no global identifiers are used by other modules implementations for all non local functions of those modules must be provided by the deployment module i.e. libraries prelude etc . For example this allows a dictionary module to be written in the domain language then deployed using either a B Tree or a Hash Map as underlying data structure.

Deployment language modules are considered unsafe hence only trusted sources should be used for deployment scripts. Although deployment modules cannot cause a computing system to fail outright deployment modules are considered unsafe because they could possibly cause denial of service through reduced capacity leakage of private data etc.

As described in Sections I.F.6 and I.G.4 the platform native language exposes native platform operations among inherited primitives such as core primitives allowing platform specific implementation of core or domain functions for instance to improve efficiency . The restriction against turing complete and platform specific operations is removed however global identifiers are rejected. Hence if an attempt is made to use the deployment language in combination with the platform native language the compiler circuit will not apply to the platform native language any primitive from the deployment language that employs a global identifier.

Platform language modules that are generated by the compiler circuit employing the platform native language are considered unsafe and should only be sourced from trusted providers. Platform language modules could perform arbitrary actions including malicious destruction of data complete system failure etc.

The languages and illustrate additional properties that can be achieved by adding additional languages to the stack of . Example requirements for the distribution language are described for example in Section I.D.2 Section I.F. and Section V. Example requirements for the disconnected operations language are described for example in Section I.G.6 and Section VI. Example requirements for the persistent operations language are described for example in Section I.G.8. Example requirements for the information security operations language are described for example in Section I.G.1.

Hence the stack of includes calculus that enables the partitioning of programs for distributed execution e.g. with persistent storage e.g. under arbitrary disconnections of the communication fabric e.g. and obeying information security policies e.g. as well as core domain deploy platform segmentation and .

Hence the compiler circuit can provide a solution for secure scalable fault tolerant distributed software by providing a stack of languages in which software is implemented. Segmentation of primitive operations among the languages guarantees the desirable properties. Applications written using core and domain languages and can be transformed easily using standard compiler techniques for optimization native code generation bytecode interpretation etc.

The restrictions imposed in each of the languages ensure the desirable properties can be met for example security distributability fault tolerance scalability. Security is met because insecure operations must either be platform specific or turing complete. Neither is allowed in the specification of a program only in a final deployment since deployment is a trusted operation the deployment officer is left to select trusted primitive libraries . Distributability is met because all identifiers are local thus any component which can be modified must be modified through a locally scoped and thus locally accessible identifier. Patterns of access must pass between distributed nodes in a structurally observable manner amenable to compiler transformations. Fault tolerance is met because the declarative pure functional semantics allows arbitrary recomputation without regard for side effects. Thus non fatal failures and retries are invisible to the program.

Scalability is met because declarative programs allow caching of oft computed values declarative programs are amenable to compiler transformations altering the control and dataflow of their algorithms to match the available parallelization of the platform without global identifiers the patterns of access for distributed data flow is exposed in the structure of the program allowing further analysis of distributed control and dataflow over and above parallelization. Theoretical problems which are commonly intractable under general assumptions also become tractable when turing complete behavior is eliminated such as the equivalence of arbitrary functions up to isomorphism .

Table 3 illustrates an example application written according to the SML language that describes an example user interface of . As described previously the transformation system can be configured for transforming the application in Table 3 into an SML based executable application that can be optimized for a prescribed computing system deployment model.

Table 3 illustrates declarations including declarations of primitives e.g. categorical primitives primitive functions following the let construct. For example the categorical primitive fst returns the first item in a tuple and the categorical primitive snd returns the second item in a tuple the combinators primitive const returns a constant the combinators primitive id is an identity function etc. Table 3 also illustrates manipulation of tuples sums and lambdas using curry and uncurry operations according to lambda calculus. A curry operation can deconstruct a function having multiple inputs into an equivalent function that accepts only a single input and as output the equivalent function returns another function that accepts only a single input etc.

The transformation system of is implemented based on execution in hardware by any one or more of the computing nodes of . Each computing node is implemented as a physical machine i.e. a hardware device that includes a network interface circuit that can be configured for communications with another computing node via a local link e.g. local bus or local link or a network connection based on implementing network communications with other physical machines via a physical communication network e.g. an Internet Protocol over Ethernet network . Each computing node also includes hardware logic circuitry described below and nontransitory and tangible computer readable media.

Hence any of the disclosed circuits of the computing nodes including the compiler circuit can be implemented in multiple forms. Example implementations of the disclosed circuits include hardware logic that is implemented in a logic array such as a programmable logic array PLA a field programmable gate array FPGA or by mask programming of integrated circuits such as an application specific integrated circuit ASIC . Any of these circuits also can be implemented using a software based executable resource that is executed by a corresponding internal processor circuit such as a microprocessor circuit not shown and implemented using one or more integrated circuits where execution of executable code stored in a memory circuit of a computing node causes the integrated circuit s implementing the processor circuit in the computing node to store application state variables in processor memory creating an executable application resource e.g. an application instance that performs the operations of the circuit as described herein. Hence use of the term circuit in this specification refers to both a hardware based circuit that includes logic for performing the described operations or a software based circuit that includes a processor circuit implemented using one or more integrated circuits the processor circuit including a reserved portion of processor memory for storage of application state data and application variables that are modified by execution of the executable code by a processor circuit. The memory circuit can be implemented for example using one or more integrated circuits implemented in the form of a non volatile memory such as a programmable read only memory PROM or an EPROM and or a volatile memory such as a DRAM etc.

Further any reference to outputting a message or outputting a packet or the like can be implemented based on creating the message packet in the form of a data structure and storing that data structure in a non transitory tangible memory medium in the disclosed apparatus e.g. in a transmit buffer . Any reference to outputting a message or outputting a packet or the like also can include electrically transmitting e.g. via wired electric current or wireless electric field as appropriate the message packet stored in the tangible memory medium to another network node via a communications medium e.g. a wired or wireless link as appropriate optical transmission also can be used as appropriate . Similarly any reference to receiving a message or receiving a packet or the like can be implemented based on the disclosed apparatus detecting the electrical or optical transmission of the message packet on the communications medium and storing the detected transmission as a data structure in a non transitory tangible memory medium in the disclosed apparatus e.g. in a receive buffer . Also note that the memory circuit can be implemented dynamically by the processor circuit in the computing node for example based on memory address assignment and partitioning executed by the internal processor circuit.

Further the steps described herein e.g. with respect any of the can be implemented as executable code stored on a computer or machine readable non transitory tangible storage medium e.g. floppy disk hard disk ROM EEPROM nonvolatile RAM CD ROM etc. that are completed based on execution of the code by a processor circuit implemented using one or more integrated circuits the steps described herein also can be implemented as executable logic that is encoded in one or more non transitory tangible media for execution e.g. programmable logic arrays or devices field programmable gate arrays programmable array logic application specific integrated circuits etc. .

As described in Section I use of the SML language in writing the SML application enables an executable application to be written in a manner that is completely independent of any attribute of any computing system deployment model such that an application writer need not be concerned with the manner in which the SML application is executed. In other words the specification of the SML application written according to the SML language cannot express the technology used to implement the application hence platform specific operations such as message passing threading concurrency coherence fault tolerance or distribution are not permitted in the SML application and are therefore of no concern to an application developer. Consequently the requirements of the SML language e.g. a purely functional language non Turing complete declarative terminating containing no global identifiers and no platform specific expressions etc. restricts an application developer from adding any domain specific knowledge to the SML application .

According to an example embodiment the transformation system can be configured for optimizing a received SML application for distributed execution by a distributed computing system comprising two or more distributed computing devices illustrated in . As described previously the SML application describes functions according to the prescribed symbol manipulation language that is non Turing complete and does not permit partial functions hence the symbol manipulation language describes the functions of the received SML application independent of any attribute of any computing system e.g. independent of the distributed computing system .

According to an example embodiment the compiler circuit is configured for identifying in the SML application a distribution annotation that identifies a candidate element e.g. a b Int a Fst etc. in the application the candidate element configured for execution in a distributed computing operation by the distributed computing system . Example distribution annotations can include the primitives Local Remote and or Any . The distribute function is the name of the function performing the transformation that optimizes the placement of the distribution annotations . The distribution annotations enable the compiler circuit to identify that the candidate element can be optimized for a computing system deployment model describing a distributed computing system e.g. of using for example equality axioms and optimization metric programs that can be part of the distribution language and primitives of .

Hence the distribution annotation can be used by the compiler circuit for selective optimization of candidate elements according to an optimization domain for a computing system deployment model describing a distributed computing system.

The example distribution annotations e.g. Local Remote or Any can be used by the compiler circuit to specify a target computing node that should perform the specified operation. For example the local distribution annotation can be used to specify that the corresponding operation should be performed by a local computing device executing the application the remote distribution annotation can be used to specify that the corresponding operation should be performed by a remote computing device that is distinct from the local computing device executing the application the any distribution annotation is an identity identifier that is logically equivalent to a don t care decision.

The compiler circuit also is configured for generating one or more variants e.g. of of of distribution annotations in the received SML application based on executing a nondestructive transformation of the application relative to prescribed equality axioms at least one of the variants containing a corresponding semantically equivalent variation of the candidate element. The compiler circuit also is configured for selecting one of the variants as an optimization for execution of the application by the distributed computing system relative to prescribed optimization metrics.

Hence the compiler circuit can select one of the semantically equivalent variants as an optimization for execution of the application by the distributed computing devices relative to prescribed optimization metrics.

Referring to the compiler circuit is configured for identifying in step the distribution annotations in the received SML application e.g. that identify the candidate elements or functions for distributed computing operations. As illustrated in further detail below a candidate element can consist of a single distribution annotation e.g. a no op a distribution annotation and a single symbol e.g. a constant element or can contain more symbols. The compiler circuit is configured for generating in step one or more program variants based on executing a nondestructive transformation using equality axioms that can be part of the distribution language and primitives of . The compiler circuit can repeat generating semantically equivalent program variants in step until a saturated equality graph e.g. equivalent to of has been completed. The compiler circuit can execute in step an optimality search over the saturated equality graph as described above relative to a distributed computing optimization domain in order to complete optimization of the application for execution by the distributed computing system .

Steps and can be described in further detail with respect to Table 2 described previously in Section I.D.2. and the following Table 4 and . In addition to the Table 2 described previously Table 4 illustrates additional example equality axioms for generating program variants of a particular distributed computing operation in order to provide optimization for distributed computing. For example the equality axioms in Table 4 optimize an application for distributed computing based on minimizing SML elements that need to be sent to a remote node and or bundling SML elements that are sent to a remote node to reduce the number of messages that need to be sent between computing nodes. As described previously other annotations can be added for example if more than two computing nodes are available or if computing nodes are classified according to different computing platforms etc.

The expression Amp is equivalent to the ampersand symbol and represents a logical primitive that constructs a tuple. Hence a tuple consisting of a remote computation for symbol a and remote computation for b can be expressed as Amp Remote a Remote b .

The compiler circuit can implement step of by parsing in step the received SML application to identify distribution annotations including distribution identifiers such as Local Remote or Any . The compiler circuit can implement the Constants equality axioms of Table 4 by determining in step if a remote distribution annotation is assigned to a Constant candidate element any remote distribution annotation i.e. any distribution annotation specifying a Remote distribution identifier assigned to a constant candidate element is replaced by the compiler circuit in step with an Any distribution identifier . The compiler circuit can implement the Trivial Computations equality axioms of Table 4 by determining in step if there is any remote distribution annotation assigned to a trivial computation element that has a trivial computation cost or assigned to a void computation element any such remote distribution annotation assigned to a trivial computation element is replaced by the compiler circuit in step with an Any distribution identifier .

Hence trivial computations including symbols representing constants or void operations are optimized to minimize unnecessary transfer of the trivial computations to a remote computing node especially relative to the costs of transferring such trivial computations to the remote computing node and receiving the trivial computation results from the remote computing node . Such trivial computations however can be bundled with any computations that require computation by a remote node due to minimal additional cost associated with including the trivial computations described in further detail below with respect to step .

The compiler circuit can implement the No Op Fragments vs. Non Trivial Fragments equality axioms of Table 4 based on deleting in step any No op elements e.g. consisting only of a distribution identifier with no associated element to eliminate conflicts and or minimize unnecessary transfers between computing nodes . Hence the expression Remote Local a can be transformed by the compiler circuit into the variant Local a since the Remote distribution identifier was a No op element that do not provide any additional functionality to the expression.

The compiler circuit can implement the remaining equality axioms Bundle Non Trivial Fragments Reduce number of round trips and or Reduce message size by bundling the candidate elements specifying the same distribution identifiers within the distribution annotation or rearranging symbols based on equivalent symbol identities. As illustrated in the equality axiom for reducing message size since the symbol a is equal to the symbol b the expression Remote Amp a b can be replaced with the expression Compose Amp Id Id Remote a where Remote a remotely computes a value which is passed into Amp Id Id which creates a tuple containing two copies of the result. Since a and b are equivalent only one of them needs to be computed and transferred.

Hence the example embodiment can partition an annotated program into fragments such that feature interaction issues such as deadlock can be eliminated network metrics such as number or size of messages sent can be reduced and the requirement for specialized developer knowledge can be reduced or eliminated. Further independently developed fragments may be combined and distributed without feature interaction errors.

As described previously distributed systems can involve deployment of two or more computing nodes that communicate between each other via unreliable network connections. Existing methods for development of distributed software i.e. executable code configured for deployment in a distributed system require significant planning on the part of developers to account for unique aspects of distributed software. Error cases that can occur in a distributed environment include partial system failures slow or reduced connectivity in the network connections lost duplicated reordered communications and total loss of connectivity. Existing methods require that software modules configured for deployment in distributed systems encountering these conditions must be planned and designed for continued operation under each possible pattern of failure. Existing development techniques reduce the design burden by planning for only a few such error cases and treating other cases conservatively typically as total system failure . Software modules which have not been designed for distributed operation or whose designed set of error cases are over conservative cannot operate in an environment under duress.

In one embodiment the compiler circuit can provide automatic partitioning of a distributed software module written as an SML application using solely the symbol manipulation language for arbitrary patterns of connectivity including complete disconnection slow reduced flapping connectivity and arbitrary partitioning of the connectivity graph.

The SML application does not specify any explicit transmission or receipt of a value nor does the SML application specify any explicit name of a remote node channel queue etc. As such the SML application is parallel and distribution neutral and can be optimized by the compiler circuit into a transformed SML application that is resilient to disconnected operation events based on prescribed transformation rules.

In one embodiment the compiler circuit can operate on an SML application comprising fragments having resolved distribution annotations. A resolved annotation can include sets of equivalent computing nodes e.g. server computers which may perform a computation and their known connectivity information e.g. connectivity graph shortest path etc . The selection of fragments for annotation and or the process of resolving assignment of equivalent server computers to Remote annotated fragments can be performed manually by an application developer or automatically by a program analysis.

Once an SML application has resolved annotations the example embodiment can optimize the application based on partitioning the SML application for execution in arbitrary connectivity conditions by application of equality axioms associated with the Disconnected Operations Language and Primitives of also referred to herein as the Disconnected Calculus .

Example classes of transformation in the Disconnected Calculus of the Disconnected Operations Language and Primitives include trivial computations remote queued operations that can be sent to multiple computing nodes reordered fused etc.

Trivial computations can be redacted from remote queued operations reducing communication burden at the expense of local computation and memory this transformation may be applied repeatedly to extract all possible locally computable fragments leaving remote only operations on the queue .

Remote queued operations can be assigned to nodes most likely to be available at the time of transmission. Remote queued operations can be sent to multiple remote processing elements to achieve fault tolerance at the expense of bandwidth. In cases of reduced bandwidth remote queued operations can be re ordered fused or redacted to reduce communication burden and or submit high priority operations preferentially. Communications associated with remote queued operations can be re ordered for submission of high priority operations. Operations can be fused to reduce message size and or number of messages. Operations can be redacted i.e. deleted to reduce message size and or number of messages.

In cases of complete communication failure an example embodiment enables disconnected operation based on enabling maximization of local computation whenever possible without additional design burden on software developers.

In cases of communication graph partitioning an example embodiment enables maximal computation among connected sub components enabling optimized execution for distributed computing systems employing ad hoc mobility .

Hence the example embodiment enables language level techniques for automatic partitioning of SML based applications to achieve continued operation in environments with failure patterns unaccounted for by software developers. The example embodiment utilizes a suite of transformations operating on modules of annotated fragments producing a new set of modules which maximize the computable components for the computing system deployment model. The example embodiment reduces or eliminates the design burden for developers of distributed software modules.

The example embodiment also automatically transforms software modules for execution in arbitrary environments of communication failure including failure cases unimagined or planned for by module developers. The example embodiment can be applied to arbitrary software modules without requiring developers to use specialized libraries specific object hierarchies specific design methodologies agents message queues etc or operating system or platform specific extensions.

Existing techniques for development of software with information security requirements burdens practitioners with significant specialized knowledge in the security domain including operating system internals CPU cache behavior shared or dynamic library internals defensive programming cryptography protocols and algorithms attack vectors etc. Interaction of features written by separate developers must be carefully orchestrated to avoid leaking or revealing private information.

Uniform application of information security policies for an enterprise may not be possible since information security decisions made by developers within an application may not conform to the policies of the enterprise. Further applications which were not designed to provide information security cannot be used in a secure computing environment.

In one example embodiment the compiler circuit can provide for automatic partitioning of software for information security based on equality axioms and optimization metric programs from the information security operation and primitives of also referred to herein as Information Security Calculus . The example embodiment can reduce or eliminate the burden of specialized knowledge by developers eliminate feature interaction issues and enable uniform application of security policies. The example embodiment can be applied to software modules that were not designed to provide information security. The example embodiment also can verify security annotations to prevent information leaks.

The example embodiment requires that an application written according to the SML language cannot specify the explicit transmission or receipt of a value nor the explicit name of a remote node channel queue etc. The example embodiment further requires that the application cannot specify any explicit persistence of a value to stable storage placement or reception of data to locally accessible hardware etc. As such the application is information security neutral and amenable to transformation techniques by the transformation system .

The compiler circuit utilizes the Information Security Calculus from the Information Security Operation and Primitives to optimize a software module annotated with information security policies. As described previously the annotation of selected fragments can be performed manually by an application developer or automatically by a program analysis module.

In one embodiment example security annotations that can be optimized by the Information Security Calculus from the Information Security Operation and Primitives can include Public Shared Secret Black Box and Poison.

The compiler circuit can determine from the Information Security Calculus that any computation or data annotated with the Public security annotation is free to be copied transmitted stored composed or otherwise processed without restriction.

The compiler circuit can determine from the Information Security Calculus that a Shared security annotation refers to any computation for which a restricted group of entities may access or process. Shared annotations include the group identifier. Session keys can be example implementations of shared computations.

The compiler circuit can determine from the Information Security Calculus that a Secret security annotation marks computations which must be accessed only by locally trusted entities e.g. the local machine s CPU or a physically connected ASIC etc . Passwords private keys and associated computations computation of password hash can be example implementations of secret computations.

The compiler circuit can determine from the Information Security Calculus that a Black Box security annotation identifies any data that cannot be re computed locally but which is part of an information security protocol. An examples of Black Box data are a random number selected by another entity as part of a handshake or another entity s public key. While this data is not explicitly dangerous it is a vector for attack and must be handled appropriately. Each Black Box security annotation includes context specific information regarding the computation.

The compiler circuit can determine from the Information Security Calculus that a Poison security annotation marks all data which is entered as free form and thus a vector for chosen plaintext attacks. Poison data must be passed through an antidote procedure before composition with any other computations. Each Poison security annotation includes context specific information regarding the computation.

Table 5 illustrates example transformation rules equality axioms from the Information Security Calculus which enables the compiler circuit to process information security annotations over an SML application allowing partitioning of the module to achieve uniform application of security policies.

Hence the example embodiment provides for arbitrary security policies such as rejecting MD5 as a Trusted Scramble or requiring all Trusted Constructors to be 256 bits . These policies are applied uniformly over all software modules during the partitioning process. The example embodiment provides a language level solution to achieve information security of arbitrary software modules. The example embodiment requires software modules to be developed in an information security neutral language and annotated by a security policy engine. Once annotated the compiler circuit can verify the security of the annotations apply transformations which allow partitioning of the software module for execution and uniform application of security policies.

While the example embodiments in the present disclosure have been described in connection with what is presently considered to be the best mode for carrying out the subject matter specified in the appended claims it is to be understood that the example embodiments are only illustrative and are not to restrict the subject matter specified in the appended claims.

