---

title: Multi-protocol access to files and directories
abstract: An operating system is provided. The system includes an agent component to monitor computer activities between one or more single-item access components and one or more set-based access components. A protocol component is employed by the agent component to mitigate data access between the single-item access components and the set-based access components.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07970747&OS=07970747&RS=07970747
owner: Microsoft Corporation
number: 07970747
owner_city: Redmond
owner_country: US
publication_date: 20100430
---
This application is a continuation of and claims priority to and the benefit of U.S. application Ser. No. 11 612 105 filed on Dec. 18 2006 and entitled MULTI PROTOCOL ACCESS TO FILES AND DIRECTORIES which application is expressly incorporated herein by this reference in its entirety.

Operating systems and the applications that run on them have many tasks to perform which are sometimes difficult to achieve without having conflicts between one type of application and another. At the simplest level an operating system is responsible for two basic aspects whereby the system manages the hardware and software resources of the system. In a desktop computer these resources include such components as the processor memory disk space and so forth whereas on a cell phone the resources include the keypad the screen the address book the phone dialer the battery and the network connection for example. The operating system should provide a stable consistent way for applications to interact with computer hardware without having to be concerned with all the details of the respective hardware.

The first task of the operating system managing hardware and software resources is very important as various programs and input methods compete for the attention of the central processing unit CPU and demand memory storage and input output I O bandwidth for differing purposes. In this capacity the operating system plays the role of the system manager making sure that each application receives the necessary resources while properly interacting with all the other applications as well as monitoring the limited capacity of the system to the greatest benefit possible of all the users and applications. This often requires balancing needs between competing applications.

The second task of the operating system providing a consistent application interface is especially important if there is to be more than one of a particular type of computer using the operating system or if the hardware making up the computer is open to change. Thus a consistent application program interface API allows a software developer to write an application on one computer and have a high level of confidence that it will run on another computer of the same type even if the amount of memory or the quantity of storage is different on the two machines for example. Even if a particular computer is unique the operating system can ensure that applications continue to run when hardware upgrades and updates occur. This is by design since the operating system and not the application is charged with managing the hardware and the distribution of its resources.

Within the broad family of operating systems there are generally four types categorized based on the types of computers they control and the sort of applications they support. These categories can include 

Real time operating system RTOS Real time operating systems are used to control machinery scientific instruments and industrial control systems. An RTOS typically has very little user interface capability and generally no end user utilities since the system will be considered an embedded system when delivered for use. An important part of the RTOS is managing the resources of the computer so that a particular operation executes in about the same amount of time every time it occurs. For example in a complex machine controller scenario having a part move more quickly because system resources are available may be just as catastrophic as having it not move at all due to the system being busy.

Another type of operating system includes single user single task. As the name implies this operating system is designed to manage the computer so that one user can effectively do one thing at a time. The Palm OS for Palm handheld computers is but one example of a modern single user single task operating system.

Similarly a single user multi tasking system may be provided. This is the type of operating system most people use on their desktop and laptop computers today. The most popular of these are Microsoft s Windows and Apple s MacOS platforms that are both examples of operating systems that allow a single user to have several programs in operation at the same time. For example it s common for a user to be writing a note in a word processor while downloading a file from the Internet while printing the text of an e mail message.

Multi user is till yet another type of operating system. A multi user operating system allows many different users to take advantage of the computer s resources simultaneously. The operating system must make sure that the requirements of the various users are balanced and that each of the programs they are using has sufficient and separate resources so that a problem with one user doesn t affect the entire community of users. Some examples include Unix VMS and mainframe operating systems such as MVS.

With respect to single user multi tasking systems conflicts can exist for applications that were created under previous designs of the operating systems and in view of newer designs. Thus these applications often follow the rules of the previous designs from an operational standpoint yet still need to operate with newer systems applications and contexts. In one example current or legacy File Systems generally only support a single item access API to create modify read file directory data. However newer richer storage platforms may employ multi item access rules and expose additional API sets which can be used to create modify read manipulate file directory data as well. Given this requirement between older and newer applications running on the same system there is a need to facilitate cooperation between such applications.

The following presents a simplified summary in order to provide a basic understanding of some aspects described herein. This summary is not an extensive overview nor is intended to identify key critical elements or to delineate the scope of the various aspects described herein. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

A multi access protocol is provided to facilitate cooperation and interaction between legacy style applications developed under one type of operating system framework. Previous applications e.g. handle based applications were developed under the constraint that stored data items would be accessed a single item at a time. Modern systems have developed a richer architecture whereby multiple data items or a set of items can be accessed concurrently. The multi access protocol operates to guide data interactions between such legacy applications and advanced operating systems where data access conflicts may exist between single item access rules expected by previous applications and the more flexible multi item access allowances of the newer systems. Richer access capabilities such as set based or multi item access are often facilitated through different access paths. Existence of multi access paths includes coordination of data access to ensure correctness and consistency of data via the multi access protocol. Such protocol can be employed with an agent component that oversees operations between single item access and multi item access components. For example one or more rules can be enforced by the agent that may allow a given operation to succeed fail with an error or deny access when a possible conflict is detected. The agent can also facilitate such aspects as controlling system cache resources by mitigating stale data that may reside in the cache and resolving respective cache conflicts that may occur when the same data items are accessed concurrently.

To the accomplishment of the foregoing and related ends certain illustrative aspects are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways which can be practiced all of which are intended to be covered herein. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

A multi protocol access system is provided that enables applications developed under one operating system framework to interact with applications developed under another framework. In one aspect an operating system is provided. The system includes an agent component to monitor computer activities between one or more single item access components and one or more set based access components where set based refers to the ability to access multiple data items at a time. A protocol component is employed by the agent component to mitigate data access conflicts between the single item access components and the set based access components.

As used in this application the terms component item protocol agent and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers. Also these components can execute from various computer readable media having various data structures stored thereon. The components may communicate via local and or remote processes such as in accordance with a signal having one or more data packets e.g. data from one component interacting with another component in a local system distributed system and or across a network such as the Internet with other systems via the signal .

Referring initially to a multi protocol access system is illustrated to facilitate cooperation and interactions between disparate applications. The system includes an agent that is employed to monitor and control access to one or more data items . This is achieved by utilizing a multi access protocol that defines one or more rules for how disparate systems can access the data items . In this case disparate implies that at least one system desires access to the data items according to one type of system or rules and at least one other system or application desires access to the data items according to an alternative set of rules. As can be appreciated the multi access protocol can be employed to control access between two or more differing systems employing two or more access rules or principles for operating with the data items . The data items can be substantially any type of data structure including single memory locations arrays files directories applications relational database structures objects classes methods functions and so forth.

As shown one type of system or application to operate on the data items includes one or more single item access components also referred to by acronym SIAC . Such SIAC are known for being able to operate and process one data item at a time and can also be referred to as handle based systems e.g. Win32 . A handle is generally a variable that identifies an object and provides an indirect reference to an operating system resource. A handle can be variable of type long which uniquely identifies any object such as forms desktop items menus or in other words a handle is a unique identifier for each of these objects. Typically application windows in an SIAC operating system are identified by a handle. For example a desktop window can have a handle a Visual Basic form displayed in an application can have a handle and even the controls on a form which are themselves actually windows can have respective handles.

Handle based applications or the SIAC have difficulty with applications that support other protocols such as one or more set based access components also referred to by acronym SBAC that may also access the data items . Set based access components can be associated with a different style of operating system framework that allows multiple data items to be accessed concurrently. Thus the SBAC can cause problems for the SIAC when both types of applications are attempting access to the data items in a concurrent manner. Generally set based access is associated with operating system frameworks e.g. WINFS adapted with relational database capabilities that allow multiple data items to be accessed. The multi access protocol provides rules and mapping to allow the SIAC and the SBAC to co exist on the same platform or across the same memory structures if remote web based applications are employed. This can include having the agent monitor the data items and apply the rule or rules from the multi access protocol for a given type of memory access. Various example protocol rules semantics are shown and described in more detail below with respect to .

In general some File Systems only support SIAC application programming interfaces APIs to create modify read file directory data. Richer storage platforms associated with the SBAC expose additional API sets which can be used to create modify read manipulate file directory data as well. Given this the new storage platforms can define multi protocol access SIAC and SBAC API as an example semantics at for file directory data for example. As an example a file could be opened for write purposes where the open allows shared write via the SIAC where the multi access protocol allows another application to modify the file via the SBAC API. One challenge here is that SIAC API may be handle based where the SBAC is not as noted above. There are a plurality of combinations for accessing the data items via the SIAC and SBAC where such combinations are described in more detail below with respect to . Thus in one example the multi access protocol allows the system to synchronize the SIAC and the SBAC at an agent layer in user mode or other modes where user mode is a system state for computer users and public access. In this mode changes made editing deleting moving renaming files installing upgrading removing software and so forth are temporary and when the system is rebooted items return to their original state. In another aspect the system can be employed to control memory access in a computer. This includes means for monitoring e.g. agent component computer memory access to data items between one or more single item access components and one or more multiple item access components . This also includes means for controlling e.g. multi access protocol memory conflicts at the data items in view of the single item access components and the multiple item access components .

Proceeding to of one or more multi protocol access rules are defined. These can include rules for how access is controlled denied allowed and so forth between single item access components SIAC and set based access components SBAC . Specific example rules for controlling and managing memory access will be described in more detail below with respect to . At the rules defined at are associated with an agent or agent layer. The agent is employed to detect memory accesses via one memory access protocol versus another and then apply the appropriate rule defined at in view of the detected memory access. In order to detect such access the agent monitors one or more data items at . Such monitoring can occur as part of underlying operating system procedures that execute while applications are operating respective applications tasks. This monitoring can detect activities or conflicts whenever a given application performs a memory access for example where memory access includes reading and writing to respective files. Generally the multi protocol access rules defined at are employed when two or more applications attempt a concurrent write change or update to a data item.

At a decision is made as to whether or not a current access has been detected between a single item access component SIAC and a set based access component SBAC . If a concurrent access is detected at one or more access rules are applied at to mitigate potential conflicts between item update activities. This can include various procedures such as raising error flags denying permission to a file holding off one application temporarily while another application operates on an item granting permission to a file and so forth as will be described in more detail below. If no concurrent access is detected at the process allows a data item to be accessed at without further restriction.

Referring now to an example system illustrates multi protocol processing. The system can include a client application having an SIAC API that communicates via an I O manager with a universal naming convention provider UNC that is associated with an MUP component Multiple UNC Provider . These components communicate across an interface to UNC servers . Also an SIAC application may communicate via an SIAC API via an I O manager through a filter stack to a file system . Other components may include an MUP and another filter stack . An SBAC service having an agent and engine can communicate with the filter stack file system and driver . The SBAC service can also be associated with an SBAC API and file property handler .

In general File Backed Items FBIs in an SBAC system are regular items that have real data streams associated with them. The SBAC provides SIAC access to such streams for the purpose of application compatibility via the agent . Generally File I O operations e.g. NtCreateFile NtReadFile NtWriteFile and so forth are handled be the Driver and Agent . Since all SIAC File I O operations e.g. CreateFile ReadFile WriteFile GetFileAttributes and so on are translated into appropriate File I O operations these components can be referred top a SIAC interface components. The driver and driver is a SIAC file system driver employed to intercept namespace and property related operations opening creating files or directories getting setting file attributes and timestamps renaming deleting files or directories and so forth and redirecting such requests to a user mode agent. The agent provides the proper semantics for example by calling the appropriate SBAC stored procedures to create a new file directory or by querying file attribute from SBAC and returning them to the driver or . Accordingly SIAC semantics define that files directories or other structures have a set of properties associated with them which are described in more detail below with respect to .

Turning to example properties that can be processed by an agent component are illustrated. SIAC semantics define that each file directory has a set of properties associated with it. These properties can be split into at least 3 groups including NameSpace properties Basic properties and Security properties . Table 1 Table 2 and Table 3 below show these properties respectively.

For performance reasons an agent maintains a cache of properties associated with each file or directory accessed through the SIAC interface. When a file or a directory is opened through the SIAC interface the agent retrieves the item properties and stores them in appropriate memory objects to avoid roundtrips to the SBAC if it needs these properties again. After the file handle is closed the memory objects containing the file properties are placed into a cache called NameCache and are kept there until the expiration period passes. If the same file directory is opened again the agent reuses the cached objects and restarts the aging process after the last handle is closed. It is noted that the agent may not cache security descriptors directly. Instead it caches so called per user maximum access mask which is the result of evaluating of a security descriptor for the given user. The security cache is a slightly separate cache and can be invalidated independently.

Since file backed items FBI s are regular SBAC items there are at least two ways to modify an FBI Store API update including SBAC API and SIAC update. Generally the agent allows at least two types of SIAC operations regular when a file directory is opened by its name and an open by item id OBID when an encoded item id is used as the pathname where OBID operations can modify a stream. Namespace operations create a new item delete or rename an existing item are generally not allowed. Respective OBID operations can be Transacted when an appropriate database transaction information is passed to the agent and Non transacted. Generally there are at least three ways to modify an FBI including Store API Transacted SIAC access no namespace operations and Non transacted SIAC access any File I O operations .

As noted above the agent can cache properties of files directories accessed through the SIAC interface. Data in a cache entry corresponding to an item may become stale when for example 

Store API transaction modifying the item Data Manipulation Language DML modifying an item s security is in progress Transaction SIAC handle is opened Non transacted SIAC handle is opened and a handle to a child is opened. Across the top of the matrixes and represent the second operation sequence. For the matrix the column headings are DML Update Delete Rename Replace Item DML modifying item s security Transacted SIAC open and Non transacted SIAC open. Across the top of the matrix in are Non transacted SIAC close including file delete SIAC set security object Non transacted SIAC directory delete and non transacted file directory move rename operation. By observing where the rows and columns intersect on the matrixes and one can observe the applicable rule or semantic for a given operation. For example observing the matrix of if a transacted SIAC handle is opened as a first operation at and a DML modifying item s security is attempted as a second operation at then the semantic is illustrated at showing that this transaction is allowed and an agent security cache is invalidated.

For the purposes of brevity all first operation second operation combinations will not be described herein however semantics can be determined by starting to the left of the matrix at a row designator identifying a first operation identifying a second operation along the top of the matrixes and reading the resultant semantic from the intersection of the row first operation and column second operation . As illustrated some example semantics include controlled by server logic operation fails operation succeeds operation allowed sharing violation enforced by agent or server access denied security cache invalidated and so forth.

1. Calls the e.g. GetItem example API store location stored procedure SP . This SP acquires a statement level share lock on the appropriate row in the item table in the context of its own transaction. If this lock conflicts with exclusive lock taken on the same row the operation fails.

2. Calls the GetItem stored procedure passing the transaction context. Further operations are performed in the context of this transaction.

3. GetItem acquires exclusive lock on the appropriate row in the item table. The operation fails if there is lock conflict.

4. GetItem succeeds the agent fills the appropriate cache entry and succeeds the operation. The entry is marked as transacted so further transacted opens will succeed or fail depending on the transaction context passed to the agent. The agent should allow those transacted opens that are made in the same transaction context. This implies that if the file is opened in transacted mode updates made in the context of another transaction will fail. It is noted that 

1. Checks if any properties have been changed and calls SetBasicProperties passing the transaction context stored at open time.

2. SetBasicProperties updates the properties in the store in the context of the given transaction context.

3. If update fails for any reasons the agent ignores the respective error. As can be appreciated other processing can be provided by the agent than the examples outlined in .

Turning to example system processing considerations are illustrated that can be applied with the agent processing described above with respect to . At updates by a Store API are considered. If the system needs to update any property that might potentially be cached by the agent the system 

1. Acquires exclusive lock on the appropriate row in the item table. If there is an SIAC open whether transacted or non transacted in progress this operation will fail because of lock conflict or wait until the row gets unlocked.

2. Calls the provided invalidate name cache entries SP which in turn calls the agent API to invalidate the cache entry entries . If the agent API indicates that the entry can not be invalidated because an SIAC client keeps a handle opened the update should fail.

It is noted that SIAC opens may not be allowed until the transaction commits. This ensures that the agent does not recreate a cache entry that will become stale on commit. The store API updates are not allowed if the file is opened by an SIAC client even if it is opened in the context of the same transaction. This is performed because the agent may not invalidate the cache entry while it is still in use.

At a Replace Item is considered. In this aspect ReplaceItem should guarantee that it does not modify the potentially cached properties. At security updates by the store API are considered. If the system updates security of a folder or an FBI it 

1. Calls the provided invalidate security cache entry SP which in turn calls the agent API to invalidate the security cache entry entries .

It is noted that SIAC opens should not be allowed until the transaction commits. This will ensure that the agent does not repopulate cache entries that may become stale on commit. It is to be appreciated that the possible actions of the agent and the associated system described above are exemplary in nature and that other combinations of actions are possible. Similarly the matrixes shown in described but a subset of possibilities for controlling memory access between at least two disparate operating system frameworks and API sets. Thus substantially any protocol that is employed to facilitate cooperation and interactions between disparate operating system and API frameworks are considered contemplated by the exemplary concepts and broader principles described herein.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a computer program that runs on a computer and or computers those skilled in the art will recognize that the invention also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that performs particular tasks and or implements particular abstract data types. Moreover those skilled in the art will appreciate that the inventive methods may be practiced with other computer system configurations including single processor or multiprocessor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the invention can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects described herein includes a computer . The computer includes a processing unit a system memory and a system bus . The system bus couple system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to 11 bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example a disk storage . Disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that various components described herein can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like monitors speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 802.3 Token Ring IEEE 802.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems and DSL modems ISDN adapters and Ethernet cards.

What has been described above includes various exemplary aspects. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing these aspects but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly the aspects described herein are intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

