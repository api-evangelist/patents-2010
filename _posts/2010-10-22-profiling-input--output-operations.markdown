---

title: Profiling input / output operations
abstract: Implementations of the present disclosure provide methods including executing a virtual machine configured to execute a plurality of applications and perform a plurality of I/O operations; storing meta information for a first I/O operation performed by the virtual machine in an I/O information holder for the virtual machine; receiving a request to begin an I/O profiling session on the virtual machine after storing the meta information; and reporting an I/O event record for a second I/O operation performed by the virtual machine using the meta information for the first I/O operation, wherein the second I/O operation is performed after beginning an I/O profiling session on the virtual machine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08656407&OS=08656407&RS=08656407
owner: SAP AG
number: 08656407
owner_city: Walldorf
owner_country: DE
publication_date: 20101022
---
Software applications running in a distributed application server environment may have a plurality of concurrent users accessing the servers and applications. This can result in performance and scalability problems with the servers and applications running on the servers. Performance monitoring profiling and debugging tools can monitor software applications running on the servers to determine resource consumption information.

Software profiling is a technique for measuring where software application programs consume resources e.g. central processing unit CPU computation times memory accesses . A profiling tool or profiler can analyze the resource consumption of an application running on a server and provide profiling data based thereon. For example a Java profiler can support a broad set of Java virtual machines JVMs . The Java profiler can provide comprehensive profiling of a Java application running on the JVM.

Implementations of the present disclosure provide computer implemented methods for input output I O profiling. In some implementations a method includes executing a virtual machine configured to execute a plurality of applications and perform a plurality of I O operations storing meta information for a first I O operation performed by the virtual machine in an I O information holder for the virtual machine receiving a request to begin an I O profiling session on the virtual machine after storing the meta information and reporting an I O event record for a second I O operation performed by the virtual machine using the meta information for the first I O operation wherein the second I O operation is performed after beginning an I O profiling session on the virtual machine.

In some implementations the first I O operation comprises opening a file or network connection and wherein the second I O operation comprises using the file or network connection opened by the first I O operation. In some implementations the meta information comprises a name of a file or network connection and a time stamp.

In some implementations the I O information holder comprises an array and storing the meta information comprises storing the meta information at a position in the array based on a descriptor for a file or network connection. In some implementations the method further includes synchronizing access to the array at the position.

In some implementations the I O information holder comprises a hash table and storing the meta information comprises storing the meta information in the hash table using a descriptor for a file or network connection to determine a hash table key. In some implementations the method further includes synchronizing access to the hash table.

In some implementations the I O information holder comprises an array and an overflow hash table and storing the meta information comprises determining that a descriptor for a file or network connection has a value greater than a size of the array and storing the meta information in the overflow hash table.

In some implementations first I O operation comprises opening an archive file and the second I O operation comprises performing an I O operation on a sub file within the archive file and reporting the I O event record comprises reporting an archive I O event record for the archive file and a sub file I O event record for the sub file.

In some implementations reporting the I O event record comprises combining the I O event record with method parameter trace data. In some implementations the I O event record includes a stack trace a thread identifier and an operation duration.

The present disclosure also provides a computer readable storage medium coupled to one or more processors and having instructions stored thereon which when executed by the one or more processors cause the one or more processors to perform operations in accordance with implementations of the methods provided herein.

The present disclosure further provides a system for implementing the methods provided herein. The system includes at least a server including one or more processors and a computer readable storage medium coupled to the one or more processors having instructions stored thereon which when executed by the one or more processors cause the one or more processors to perform operations in accordance with implementations of the methods provided herein.

It is appreciated that methods in accordance with the present disclosure can include any combination of the aspects and features described herein. That is to say that methods in accordance with the present disclosure are not limited to the combinations of aspects and features specifically described herein but also include any combination of the aspects and features provided.

Various implementations of the subject matter described in this specification can be implemented to realize one or more of the following advantages. I O related operations performed by applications running on a virtual machine can be profiled. I O profiling can be started on demand e.g. when the application to be profiled is already running without restarting the virtual machine. I O profiling can be provided while limiting additional runtime and memory overhead. For example I O profiling can be limited to only certain users applications sessions or requests so that an I O profiling session for a user A has a minimal effect on the performance of other users on the same system. I O profiling can report I O events at a finer level of granularity than conventional profiling. I O profiling can report I O events for archive files and files within archive files. A profiling front end can aggregate I O profiling data and present the data in a convenient user friendly manner.

The details of one or more implementations of the present disclosure are set forth in the accompanying drawings and the description below. Other features and advantages of the present disclosure will be apparent from the description and drawings and from the claims.

Implementations of the present disclosure are generally directed to analyzing input output I O operations of an application running on a virtual machine. I O operations include file operations e.g. reading and writing to a storage device and network operations e.g. sending and receiving data over a communication link More specifically implementations of the present disclosure relate to a software profiling tool that collects and stores original profiling data at a back end and provides information related to I O operations for display at a front end.

Referring now to a schematic illustration of an exemplar system in accordance with implementations of the present disclosure can include a plurality of clients and a computer system . The computer system can include a server and a database . In some implementations the system may represent a client server system supporting multiple computer systems e.g. computer system including one or more clients e.g. clients and or one or more servers e.g. server that are connectively coupled for communication with one another over a network . In some implementations the clients e.g. clients may be directly connected to the one or more servers e.g. server without connecting by way of network .

The clients can represent various forms of processing devices including but not limited to a desktop computer a laptop computer a handheld computer a personal digital assistant PDA a cellular telephone a network appliance a camera a smart phone an enhanced general packet radio service EGPRS mobile phone a media player a navigation device an email device a game console or a combination of any two or more of these data processing devices or other data processing devices. Each client may access application software on the server .

The server can represent various forms of servers including but not limited to a web server an application server a proxy server a network server or a server farm. For example the server can be an application server that executes software accessed by clients . In operation multiple clients e.g. clients can communicate with the server by way of network . In some implementations a user can invoke applications available on the server in a web browser running on a client e.g. clients . Each application can individually access data from one or more repository resources e.g. database . For example the server can access database .

In some implementations the client devices may communicate wirelessly through a communication interface not shown which may include digital signal processing circuitry where necessary. The communication interface may provide for communications under various modes or protocols such as GSM voice calls SMS EMS or MMS messaging CDMA TDMA PDC WCDMA CDMA2000 or GPRS among others. For example the communication may occur through a radio frequency transceiver not shown . In addition short range communication may occur such as using a Bluetooth WiFi or other such transceiver.

In some implementations the system can be a distributed client server system that spans one or more networks such as network . The network can be a large computer network such as a local area network LAN wide area network WAN the Internet a cellular network or a combination thereof connecting any number of mobile clients fixed clients and servers. In some implementations each client e.g. clients can communicate with the server via a virtual private network VPN Secure Shell SSH tunnel or other secure network connection. In some implementations the network can include the Internet a wireless service network and may include the Public Switched Telephone Network PSTN . In other implementations the network may include a corporate network e.g. an intranet and one or more wireless access points.

Each client e.g. clients can establish its own session with the server . Each session can be semi permanent as it can be established at one point in time and torn down at another. Each session can involve two way information exchange between the computer system and each individual client . For example a Hypertext Transfer Protocol HTTP session enables the association of information with individual users. A session can be stateful where at least one of the communicating parts e.g. the server or the client e.g. clients can save information about the session history in order to be able to communicate. Alternatively stateless communication includes independent requests with associated responses.

Multiple clients e.g. clients can communicate via network with the server . In order to run an application each client e.g. clients can establish a corresponding session with the application server . In some implementations a user can initiate a profiling session for an application running on the server using the client . The client can establish the profiling session with the server . The profiling session can profile an application running on a Java virtual machine JVM on the server . For example a profiler included on the server can record and store profiling data for a profiling session in the database for analysis by the user running the profiling session from the client . In some implementations the profiling data can be stored in a file system on the server . The profiler can also send the profiling data to the client for analysis by the user. The client can display the profiling data recorded for the application running on the JVM in a graphical user interface GUI displayed on display device on the client .

As used herein the term profiling data generally refers to map data and event data. Map data can include a mapping between numeric identifiers and VM structure entities such as stack traces thread names classes methods and class loaders for example. Event data directly relates to profiled actions occurring in a VM. Exemplar actions can include the start of threads object allocations e.g. for the allocation trace method enter events method exit events and the actual method parameters e.g. for the method parameter trace sampled thread stack traces e.g. for the performance trace and or garbage collection events. The map data can be referenced in the event data. Consequently instead of writing explicit class specifications method specifications and complete stack traces within the event data only the corresponding numeric identifier need be written. In this manner the amount of event information from a memory perspective can be drastically reduced.

Profiling data can also refer to information related to I O operations. In some implementations profiling data includes for an application running on a JVM some or all of how many bytes have been sent or received by the application how much time the application has spent reading and writing I O information how many I O operations the application has performed throughput information e.g. transferred bytes per second average write and read time what files are opened closed or deleted and which network connections are established or closed.

For example the profiler can analyze the resource consumption of an application running on a JVM. In some implementations the application can be a standalone Java application. In some implementations the application can be a complex enterprise application that can utilize a plurality of resources. For example the profiler can be a JVM Profiler provided by a software provider.

The profiler can include two components a profiler front end component front end profiler and a profiler back end component back end profiler . The back end profiler can be integrated into a back end virtual machine VM . In some implementations a native application can be provided as a front end the native application understanding the profiling protocol of the back end. In some implementations the front end profiler can be integrated into a front end VM . For example the back end VM and the front end VM can each be a JVM provided by a software developer and or provider. The JVM can run one or more applications integrated with the back end profiler in the back end VM and provides for connection to the front end profiler . The back end profiler can provide profiling data for one or more applications running on the back end VM . The front end profiler can provide a visual representation of the profiling data provided by the back end profiler e.g. client can include front end profiler and display device can display the profiling data to a user in a GUI .

For example a back end profiler for a JVM can expose profiling data from a Java application executing on a back end VM. The back end profiler can use a Java Virtual Machine Tool Interface JVMTI to collect profiling data from the JVM. In some implementations the JVM can provide an interface to load the back end profiler e.g. as an agent into the JVM process. In some scenarios a proprietary implementation can directly integrate the back end profiler into the JVM. For example the JVM can include a proprietary back end profiler directly integrated into the back end VM.

In some implementations during a profiling session a user can directly connect to the VM that includes the profiler e.g. back end VM that includes back end profiler . The user can interactively request profiling data be sent from the back end profiler to the front end profiler . Profilers can communicate with each other using client application programming interface API and server API respectively. For example computer system can establish a socket connection between the back end profiler and front end profiler . The profilers can be located on physically different machines e.g. client and server respectively . The profiling data can be transferred from the back end profiler to the front end profiler e.g. by way of a socket connection or the transfer of one or more files . The front end profiler can receive the profiling data and prepare it for analysis and display to a user. For example the front end profiler can display the profiling data in a GUI on display device . In some implementations the profiling data can be transferred using a file transfer.

In some implementations the computer system may directly connect to client without the use of network . In some implementations the front end VM and back end VM including profiler and profiler respectively may run on the same machine where client server and database are included on the same physical machine.

The front end profiler can be a stand alone application that can communicate with the back end profiler included in the back end VM without the need for a front end VM. More specifically a front end profiler may be a stand alone program or application that is compatible with a back end profiler. In some implementations the front end VM can run the front end profiler stand alone application. The front end profiler stand alone application can analyze additional stand alone applications running on the front end VM . The front end profiler stand alone application can also analyze applications running on the back end VM .

In some implementations the profilers can be integral parts of VMs respectively. This can allow for on demand examination of applications running on the back end VM . Because the VMs include profilers respectively profiling can occur during runtime without the need to restart the VMs . Including a profiler in a VM reduces the memory usage typically required thereby minimizing the memory overhead of the computer system e.g. computer system .

The server API can start and stop the VM included in the back end VM that includes the application for profiling. The back end profiler can record the profiling data for the application running on the back end VM . In some implementations the back end profiler can store the profiling data as one or more profiling files in the database . In some implementations the back end profiler can send the profiling data to the front end profiler for further processing. For example a JVM s debug connection can connect the client to the server to communicate profiling data from the back end profiler to the front end profiler using server API and client API respectively.

In some implementations a developer can use a multi language software development environment to implement test and debug a software project. The software development environment can be an open architecture software development platform that includes an integrated development environment IDE and a plug in system. The plug in system can allow extensions to the IDE with the ability to integrate custom tools. The plug in system can provide a framework for integrating user made applications and infrastructure components. For example a front end profiler that includes a user interface can be provided as a plug in to the software development platform. For example the front end profiler can be an Eclipse plug in that can be integrated into an Eclipse platform. The Eclipse platform can provide an IDE for implementing testing and debugging Java based software development projects. An Eclipse platform that includes a front end profiler plug in can additionally provide profiling of Java based software development projects. For example the front end profiler can be a plug in to a software development platform running on the front end VM .

A remote profiling session can occur when a host or server e.g. server that includes the application for profiling is remotely located from the client e.g. client running the application that initiates the profiling session. For example system shows an exemplar remote profiling session where the back end VM is running an application that includes the back end profiler and the client initiates the profiling session from the front end VM which includes front end profiler . In a remote profiling session opening a debugging port to the back end VM can switch the back end VM into a profiling mode. Using client a user can connect to the back end VM for profiling by connecting to the debugging port. As shown in the back end profiler is an integral part of the back end VM . As described above this can allow the back end VM to be switched into a profiling mode on demand during execution of the back end VM application without the need to restart the back end VM application.

In some implementations a local profiling session can occur when the application for profiling and the application that initiates the profiling session are located on the same host or server e.g. the same physical machine . The local profiling session can perform simultaneous source code implementation testing debugging and profiling. The host can include a local display device that displays a GUI to a user. The GUI can allow the user the ability to control and configure the profiling session.

In some implementations a user can perform a remote or local profiling session in an online or interactive mode. In an online profiling session a front end profiler e.g. front end profiler can initiate a profiling session with a back end profiler e.g. back end profiler . For example a user interacting with a GUI displayed on display device can start and stop the profiling session as well as interact with the back end profiler during the profiling session. The interaction can include configuring and controlling the profiling session as well as receiving profiling data. The user can request the resultant profiling data from the back end profiler for display on the display device . The back end profiler can open a debugging port to the back end VM when the front end profiler initiates an online profiling session with the back end profiler . The back end VM can then wait for a connection. The front end VM that includes the front end profiler can connect to the debugging port using client API and server API by way of network .

In some implementations in an online profiling session a user may optionally store the profiling data received from the back end VM in a local file e.g. a file located on the client as part of a local file system or repository . The user can access the locally stored profiling data file at any time after the completion of the profiling session.

In some implementations a user can perform a remote or local profiling session in an offline or non interactive mode. In an offline profiling session a front end profiler e.g. front end profiler can initiate a profiling session with a back end profiler e.g. back end profiler but there is no interaction between the front end profiler e.g. front end profiler and the back end profiler e.g. back end profiler during the profiling session. For example the system can provide an interface to couple the front end VM to the back end VM using the server API in order to start and stop the profiling session. The back end VM that includes the back end profiler can store the profiling data in the database and or a file. For example a user interacting with a GUI displayed on the display device can start and stop the profiling session. Once complete the user can request the profiling data stored in the file in the database from the computer system e.g. the user can interact with a GUI displayed on display device to initiate the request . The client can receive the profiling data file and display its contents to the user on display device

In an offline profiling session storing profiling data for the profiling session in a profiling file on database can enable a user to retrieve profiling data for a back end VM e.g. back end VM at any point after the profiling session is complete. For example the stored profiling data can be retrieved from the database whether or not the back end VM e.g. back end VM is running.

The back end profiler can include a controller framework . In some implementations the controller framework can start and stop profiling sessions as well as traces during a profiling session. The controller framework can allow a user to select specific back end profiler options and settings for a profiling session. For example the front end profiler can display a GUI to the user on display device that displays the options and settings for the back end profiler . The user interacting with the GUI can select specific back end profiler options and settings for a profiling session.

The back end profiler settings can include functional settings and filter settings. Functional profiler settings can determine the functional area of the application code to profile. For example a functional profiler setting can specify the types of traces to perform for the profiling session e.g. an allocation trace a method parameter trace and or a performance trace . Filter profiler settings can define a validity scope e.g. user session thread VM etc. for the functional profiler setting for the profiling session. For example referring to a user operating client can start an allocation trace in the back end profiler . The validity scope of the profiling session can be for the user.

The profiler options can include specific monitoring debugging and analysis functions. For example profiler options can include memory debugging e.g. memory leak detection performance analysis e.g. hotspot identification synchronization monitoring and application debugging e.g. called method detection . By way of non limiting example the profiling functions can include one or more sub functions e.g. heap dump time based sampling memory based sampling allocation trace method parameter trace garbage collection trace etc. . Allocation analysis can identify and isolate memory related problems in an application. Allocation analysis can be used for memory debugging.

Performance analysis can monitor an application s behavior using information gathered as the application executes. Performance analysis can determine which parts of an application can be optimized for speed. In some implementations performance analysis can indicate where within the application spent its time during execution thereof. Performance analysis can indicate which methods called other methods while the application executes.

In some implementations a user can use the controller framework to start and stop profiling sessions and to enable profiler traces for a session. For example the user can determine one or more profiler traces to enable during a profiling session. In a single profiling session the user may enable an allocation trace that uses the allocation trace module and a method parameter trace that uses the method parameter trace module .

The I O profiling backend reports I O events e.g. to the front end virtual machine . I O events are operations performed by the back end virtual machine or applications running on the virtual machine . An example of an I O event is a file open event. The backend reports a file open event when an application opens a file. The report for the file open event includes related data for example a timestamp the name of the opened file a file descriptor for UNIX systems or handle for Windows systems an identifier of a thread responsible for opening the file and stack trace information e.g. indicating what methods are responsible for opening the file . Another example of an I O event is a file close event. A report for a file close event typically includes similar information as was included for a file open event.

Another example of an I O event is file read event. The backend reports a file read event when an application reads data from a file. The report for the file read event includes for example the number of read bytes the read duration how long it takes to read the data the file descriptor or handle an identifier of the thread responsible for reading the data and stack trace information e.g. indicating what methods are responsible for reading the data . Other examples of I O events are file write events and file delete events. Reports for those events typically include similar information.

The backend can report network related I O events. Examples of network related I O events include connection open events data receive and send events and connection close events. Reports for these events include related information for example network addresses e.g. Internet Protocol addresses number of bytes sent or received an identifier of a thread responsible for sending or receiving and stack trace information.

I O profiling can provide an overview of I O operations performed and I O resources used by methods in an application. Analysis of the I O profiling data can identify I O operations that transmit or receive an excessive amount of data. The analysis of the I O trace data can identify I O operations that consume an excessive number of CPU resources. The analysis of the I O trace data can identify methods that perform an excessive number of I O operations. The analysis of the I O trace data can identify applications that are suspended for an excessive amount of time due to waiting on I O operations. For example where an operating system suspends execution of an application while executing I O operations the application may be suspended for an excessive amount of time while waiting for the operating system to execute I O operations.

A method parameter trace module can trace the values of method parameters. For example a method parameter trace can check if specific parameter values used in a method lead to excessively long execution times for the method. Additionally a method parameter trace can provide an overview of the parameter values used by the method during the execution of the application in a profiling session.

A component statistic module can group one or more consecutive methods in a stack trace into a component. A component can be a specific application programming interface API used by the application. Examples of components can be Java components that can include but are not limited to a persistence API a security API a portal API and a servlet API. The methods in the stack trace can be grouped into components based on a defined entry method for the component. The component statistic module can then categorize the trace data at the stack level. The stack trace including methods can be grouped into components where one or more consecutive methods can be placed into one component group. Each component group can provide allocation statistics for the API associated with the component.

Profiling data can be subdivided into snapshots. A snapshot refers to data for a timeframe or interval where profiling data was collected. For example a user can create a snapshot by selecting a corresponding entry within a context menu of a profiling trace entry in a profile view. As another example the profiling data can be read at the front end e.g. after finishing a dialog step and the user can input a command to create a snapshot. In response the front end can send a command to the back end to create a snapshot of the profiling data. Consequently the back end inserts a snapshot marker into the original profiling data. In the case where the user would like to create a sub snapshot e.g. a snapshot within a snapshot or the user would like to create a snapshot from an arbitrary time period the front end can identify the corresponding sections or sub regions in the original profiling data and can read the profiling data for that section.

Referring to the client can provide a GUI to a user for display on display device that can allow the user to start stop and control profiling sessions in the back end profiler using the client API in communication with the server API by way of network . Additionally the server API can provide the client API by way of network profiling data to display to the user in a GUI on the display device . The user can access and evaluate the displayed profiling data. In some implementations a guided mode can identify problem areas indicated by the profiling data. In some implementations the profiling data can be stored as a profiling file in the database in the computer system . In some implementations the profiling data can be stored as a file in a file system included on the client . Storing of the profiling data can allow for subsequent retrieval and analysis.

The client and the client can connect to the computer system by way of the network . In some implementations the back end profiler can perform in compliance with both the client and the client simultaneously while remaining multiple client compliant. The back end profiler can restrict profiling sessions to particular clients while the server can assign the current client information to its respective thread.

In step the system determines whether I O profiling is active. Typically the system determines whether I O profiling is active using a profiling backend e.g. the profiler of . The profiler receives request to stop and start profiling including I O profiling. The system can send a request to the profiler and receives an indication of whether I O profiling is active. If I O profiling is not active the system performs the I O operation in step . The system can perform the operation for example using instructions for the operation from the Java Development Kit. If I O profiling is active the system performs steps .

In step the system determines the current stack trace. The stack trace can be determined using for example coding inside the virtual machine that allows for walking the complete Java stack trace. In step the system determines a current thread. The current thread is the executing thread performing the I O operation. Various techniques for determining the current thread are possible. In step the system determines a timestamp for the beginning of the I O operation. The timestamp can be labeled e.g. begin. In step the system performs the I O operation. The system can perform the operation for example using instructions for the operation from the Java Development Kit. In step the system determines a timestamp for the end of the I O operation. The timestamp can be labeled e.g. end. 

In step the system notifies an I O profiling backend e.g. the I O profiling backend of . The backend reports the determined information the current stack trace the current thread begin and end timestamps and or a read duration based on the difference between the timestamps . For example the backend may write the information to a file or provide the information to a front end profiler.

In some implementations the steps are implemented by extending method implementations specified by Java Standard APIs or other standardized methods . For example for a Java application that reads data from a file via the java.io.FilelnputStream.read method the method can be extended to include the steps . Extending methods in this manner allows a user to profile I O operations related to an application and exclude I O events related to the internal virtual machine implementation. For example a virtual machine may be configured to provide monitoring or logging information when executing applications and a user profiling an application running on the virtual machine may not want to capture the corresponding I O operations of the virtual machine.

In step the system executes a virtual machine e.g. a Java virtual machine. The virtual machine is configured to execute applications.

In step the system creates an I O information holder. In some implementations the I O information holder is an array. The array can have a fixed size e.g. of 32 768 elements or the array can have a flexible size. The size can be specified as a virtual machine start up parameter. In some other implementations the I O information holder is a hash table. Various data structures are possible for the I O information holder. In some implementations the system allocates two or more I O information holders e.g. one for network connections and one for opened files .

The I O information holder stores meta information for I O events. The I O information holder can store meta information regardless of whether I O profiling is active. Typically the system stores meta information in the I O information holder when the system performs an I O operation involving a new file network connection or the like. For example for a file open operation or a network connection open operation the system may store meta information related to the file or the network connection in the I O information holder. The meta information generally includes basic information e.g. a file descriptor or socket descriptor and additional information e.g. a file name an open timestamp stack track information and so on.

In step the system performs I O operations. In general the system executes applications that run on the virtual machine and the applications perform I O operations. Even though I O profiling has not started for the virtual machine the system stores meta information for opened files and network connections in the I O information holder. The system stores the meta information differently depending on the structure of the I O information holder.

In some implementations where the I O information holder is an array the system uses descriptors e.g. file descriptors or network connection descriptors as indexes to the array. A file descriptor is a value used to identify a file. A network connection descriptor is a value used to identify a network connection. The value of a descriptor can be stored in a long variable e.g. as it is on some Windows systems or a plain 32 bit value e.g. as it is on some Unix systems. In various systems the values of descriptors generally have values in the range from 1 32768. The descriptors typically are reused when a file or network connection is closed. If the value of a descriptor is greater than the size of the array the system can increase the size of the array or alternatively use a hash table as a fallback mechanism. Using a hash table is described in the next paragraph.

In implementations where the I O information holder is an array the system optionally synchronizes accesses to particular array positions rather than the entire array . For example the Java Standard I O API allows for exchanging file descriptors between threads. In that case the system can synchronize access to array positions to prevent contention. For example the system may use an atomic compare and swap procedure to synchronize array accesses. An example contention scenario is illustrated in which is described below.

In some implementations where the I O information holder is a hash table the system uses a descriptor or handle as a key for the hash table. Various hash tables and keying techniques are possible. For each opened file or network connection the system creates a new hash entry. When the file or network connection is closed the system removes the entry from the hash table. In some of these implementations different threads can open and close files and network connections concurrently. To prevent collisions in accessing the hash table the system can synchronize accesses to the hash table. Synchronization can in some cases decrease runtime performance e.g. where file and network operations are serialized.

In step the system begins I O profiling. During I O profiling the system records I O event records for I O operations e.g. as described above with reference to . In step the system performs I O operations and generates I O event records. In some implementations the system performs I O profiling only for specified users applications sessions or requests to reduce consumption of computing resources.

In some implementation the system stores I O event records in the I O information holder. The system can then expose the information in the I O information holder to a front end profiler e.g. the front end profiler of . For example the system may write the information in the I O information holder to a file that is available to the front end profiler.

Because the system stored meta information for opened files and network connections in step before profiling was started I O event records for operations that occur after profiling starts can be accounted to corresponding files and network connections that were open before profiling started. The meta information for those files and network connections can be used to provide additional detail for the I O event records. Thus I O profiling can be on demand so that I O profiling can begin after the virtual machine starts and still capture meta information regarding I O operations for files and network connections that were opened prior to starting I O profiling.

In step the system executes a thread Thread A. Thread A opens a file and the system assigns the value to the file as a file descriptor. In step the system executes another thread Thread B. Thread B receives the file descriptor from Thread A. This is possible for example where the system is using the Java Standard I O API. In step Thread A closes the file with the descriptor . After closing the file the system may reuse the file descriptor even though Thread B still has a reference to the file descriptor and may not have been notified that the file has been closed.

The system performs steps and in parallel e.g. using two processors or computers or using a single processor executing multiple threads . In step the system executes a thread Thread C. Thread C opens another file and the system assigns the value the file as a file descriptor. In step Thread B attempts to close the original file using the file descriptor . 

Because the system uses descriptors as indexes to the array for the I O information holder there is contention at array position . To avoid a system crash the system synchronizes access to individual positions within the array. The system can synchronize accesses to the array for example using atomic compare and swap processes. Some synchronization processes are supported directly by a processor and can be used without consuming large amounts of additional processing time.

In step the system determines I O profiling data for the I O operation. The I O operation is for example a file open close read or write operation. The I O profiling data is for example a timestamp a thread ID for a responsible thread and other data as described above with reference to .

The operation is performed on an archive file. An archive file is for example a zip file or a jar archive. The archive file can include one or more sub files within the archive file. For example Java classes are typically loaded from a jar archive including many Java classes.

In step the system generates an I O event record for the archive file. The event record includes at least some of the I O profiling data determined in step . The event record is associated with the archive file.

In step the system generates an I O event record for a sub file within the archive file. The event record includes at least some of the I O profiling data determined in step . The event record is associated with the sub file within the archive file.

By creating event records for both the archive file and the sub file the system has I O profiling data for both the archive file and the sub file. For example a system executing the steps can determine how long it takes to read a certain Java class from an archive or what classes are read from an archive.

In some implementations the system maintains a cache for opened archive files. Thus if an archive file is opened by a certain thread the file descriptor for the archive file is cached. So when a second thread opens the same archive file the cached file descriptor is returned and a reference count number is incremented. When the zip file is actually closed the reference count is decremented and the archive file remains open. If the reference count is zero then the zip file is closed.

In some implementations the file descriptor of the opened archive file is used to index an I O information holder. The meta information in the I O information holder for an archive file includes information about the opened sub files of the archive file. For example suppose the system reads a class B within a Java archive A . The archive A is opened. A file descriptor is created. Within the meta information of the I O information holder for index the information about the opened class B is maintained in addition to the name of archive. If a second class C is read within the same archive A the meta information of index is extended with the information about the opened class C . When the entry for class C is closed the corresponding information within the meta information is deleted. In some implementations when the last entry within the meta information is removed the complete information for the archive file is removed.

The GUI shown in provides several entry points for a user to analyze I O profiling data. An entry point is a GUI element that a user can select to see a certain display of I O profiling data.

For example consider the GUI elements in . When a user selects the Files icon the profiling front end displays a GUI for analyzing I O profiling data by file names or descriptors e.g. as shown in . When a user selects the Methods Flat icon the profiling front end displays a GUI for analyzing I O profiling data by method where the methods are display in a flat manner e.g. as shown in . When a user selects the Methods Hierarchical icon the profiling front end displays a GUI for analyzing I O profiling data by methods in a hierarchy according to their call relationship e.g. as shown in . When a user selects the Threads by ID icon the profiling front end displays a GUI for analyzing I O profiling data by threads as listed by thread IDs e.g. as shown in . When a user selects the Applications icon the profiling front end displays a GUI for analyzing I O profiling data by application e.g. as shown in . When a user selects the Components Flat icon the profiling front end displays a GUI for analyzing I O profiling data by component e.g. as shown in .

Although the screen shot of shows entry points for analysis of file related I O operations other GUIs can show entry points for analysis of network related I O operations or combinations of network and file related I O operations.

In some implementations a user can select methods from the GUIs of and view files or network connections that the methods used in performing I O operations. The user can then select the files or network connections for viewing in a different GUI e.g. one of the GUIs of .

In some implementations a user can navigate between any of the GUIs of without returning to a menu GUI e.g. the GUI of . For example the user can start viewing I O profiling data organized by thread ID and then select a number of threads and view I O profiling data for methods executed by those threads or files opened by those threads.

In step the system configures a profiler to profile one or more method parameters and I O operations of an application executed on a virtual machine. For example the profiler may be the back end profiler of . The profiler can execute the method parameter trace module of . The profiler determines the values of various parameters passed to a method.

In step the system executes the application. For example the virtual machine e.g. the back end virtual machine of may execute the application that calls methods that are being profiled.

In step the system generates method parameter records and I O event records. The method parameter records specify the values of method parameters at particular times for example when a method is called. The I O event records specify I O profiling data for I O operations.

In step the system combines the method parameter records with the I O event records. The system can determine for example the value of a method parameter when a file was opened or the value of a method parameter when network data was received.

Consider an example involving database operations. The application calls a method executeSqlStatement String sqlStatement . The method executes the specified SQL statement e.g. Select FROM Book Where Price 100.0 or INSERT INTO My table field field field VALUES test N NULL using a certain database. By combining method parameter profiling with I O profiling the system can evaluate SQL queries in great detail. For example the following types of information may be available how many I O operations occur on a database table A how many I O operations occur on a database table B how much time is spent inserting data into database table A compared to how much time is spent inserting data into database table B and that database table B is only read and not written to by the method.

Referring now to a schematic illustration of exemplar hardware components that can be used to execute implementations of the present disclosure is provided. The system can be used for the operations described in association with the methods described in accordance with implementations of the present disclosure. For example the system may be included in the application server . The system includes a processor a memory a storage device and an input output device . Each of the components and are interconnected using a system bus . The processor is capable of processing instructions for execution within the system . In one implementation the processor is a single threaded processor. In another implementation the processor is a multi threaded processor. The processor is capable of processing instructions stored in the memory or on the storage device to display graphical information for a user interface on the input output device .

The memory stores information within the system . In one implementation the memory is a computer readable medium. In one implementation the memory is a volatile memory unit. In another implementation the memory is a non volatile memory unit. The storage device is capable of providing mass storage for the system . In one implementation the storage device is a computer readable medium. In various different implementations the storage device may be a floppy disk device a hard disk device an optical disk device or a tape device. The input output device provides input output operations for the system . In one implementation the input output device includes a keyboard and or pointing device. In another implementation the input output device includes a display unit for displaying graphical user interfaces.

The features described can be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. The apparatus can be implemented in a computer program product tangibly embodied in an information carrier e.g. in a machine readable storage device for execution by a programmable processor and method steps can be performed by a programmable processor executing a program of instructions to perform functions of the described implementations by operating on input data and generating output. The described features can be implemented advantageously in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from and to transmit data and instructions to a data storage system at least one input device and at least one output device. A computer program is a set of instructions that can be used directly or indirectly in a computer to perform a certain activity or bring about a certain result. A computer program can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment.

Suitable processors for the execution of a program of instructions include by way of example both general and special purpose microprocessors and the sole processor or one of multiple processors of any kind of computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memories for storing instructions and data. Generally a computer will also include or be operatively coupled to communicate with one or more mass storage devices for storing data files such devices include magnetic disks such as internal hard disks and removable disks magneto optical disks and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices such as EPROM EEPROM and flash memory devices magnetic disks such as internal hard disks and removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in ASICs application specific integrated circuits .

To provide for interaction with a user the features can be implemented on a computer having a display device such as a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device such as a mouse or a trackball by which the user can provide input to the computer.

The features can be implemented in a computer system that includes a back end component such as a data server or that includes a middleware component such as an application server or an Internet server or that includes a front end component such as a client computer having a graphical user interface or an Internet browser or any combination of them. The components of the system can be connected by any form or medium of digital data communication such as a communication network. Examples of communication networks include e.g. a LAN a WAN and the computers and networks forming the Internet.

The computer system can include clients and servers. A client and server are generally remote from each other and typically interact through a network such as the described one. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

In addition the logic flows depicted in the figures do not require the particular order shown or sequential order to achieve desirable results. In addition other steps may be provided or steps may be eliminated from the described flows and other components may be added to or removed from the described systems. Accordingly other implementations are within the scope of the following claims.

A number of implementations of the present disclosure have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the present disclosure. Accordingly other implementations are within the scope of the following claims.

