---

title: Semantically rich composable software image bundles
abstract: A composable software bundle is created by retrieving a semantic representation of a set of software modules. A functional representation of a set of operations is retrieved. Each operation in the set of operations is to be performed on the set of software modules during at least one virtual image life-cycle phase in a set of virtual image life-cycle phases. A set of artifacts including a set of executable instructions associated with the set of operations is identified. The semantic representation, the functional representation, and the set of artifacts, are stored in a composable software bundle.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09280335&OS=09280335&RS=09280335
owner: International Business Machines Corporation
number: 09280335
owner_city: Armonk
owner_country: US
publication_date: 20100930
---
The present invention generally relates to computing system virtualization technologies and more particularly relates to using semantically rich composable software bundles to design and build virtual image assets.

Compute clouds such as Amazon EC2 and virtualization technologies such as VMWARE are increasing in popularity. However software providers solution providers and end users are facing challenges in packaging software and solutions as virtual image assets either for in house use private clouds or public clouds. Some of the challenges in building virtual image assets are not new. These challenges include well known installation challenges such as installation fragility version compatibility problems and satisfying software dependencies. Some other challenges are specific to the area of virtualization and cloud technologies. They include the need to not only install software but to also configure an activation mechanism that personalizes the software per each image asset deployment. This step is sometimes necessary for the software to be functional e.g. changing the host name configuration and other times is necessary to make it more useful for sharing across different users. In addition image asset builders must deal with multiple different virtualization platforms and technology VMWARE XEN AMIs . . . and multiple different mechanisms APIs processes and meta data per each target cloud. Also packaging a solution including multiple software components on a set of virtual image assets is challenging since software on different virtual image assets must be cross configured implying ordering of script execution at deployment and parameter value dependencies .

In one embodiment a method for creating a composable software bundle. The method comprises retrieving a semantic representation of a set of software modules. A functional representation of a set of operations is retrieved. Each operation in the set of operations is to be performed on the set of software modules during at least one virtual image life cycle phase in a set of virtual image life cycle phases. A set of artifacts comprising at least one of a set of metadata and a set of executable instructions associated with the set of operations is identified. The semantic representation the functional representation and the set of artifacts are stored in a composable software bundle.

In another embodiment a computer readable storage medium for creating a composable software bundle is disclosed. The computer readable storage medium comprises at least one data structure comprising a composable software bundle. The composable software bundle comprises a semantic representation of a set of software modules. The composable software bundle also comprises a functional representation of a set of operations. Each operation in the set of operations is to be performed on the set of software modules during at least one virtual image life cycle phase in a set of virtual image life cycle phases. A set of artifacts or references is also included within the composable software bundle. The set of artifacts comprises at least one of a set of metadata and a set of executable instructions associated with the set of operations.

In yet another embodiment a system for creating a composable software bundle is disclosed. The system comprises a memory and a processor communicatively coupled with the memory. A user interface communicatively coupled with the processor and the memory is for displaying information to a user and for receiving user input from the user. The processor is adapted to perform a method. The method comprises retrieving a semantic representation of a set of software modules. A functional representation of a set of operations is retrieved. Each operation in the set of operations is to be performed on the set of software modules during at least one virtual image life cycle phase in a set of virtual image life cycle phases. A set of artifacts comprising at least one of a set of metadata and a set of executable instructions associated with the set of operations is identified. The semantic representation the functional representation and the set of artifacts are stored in a composable software bundle.

In another embodiment a computer program product for creating a composable software bundle is disclosed. The computer program product comprises a storage medium readable by a processing circuit and storing instructions for execution by the processing circuit for performing a method. The method comprises retrieving a semantic representation of a set of software modules. A functional representation of a set of operations is retrieved. Each operation in the set of operations is to be performed on the set of software modules during at least one virtual image life cycle phase in a set of virtual image life cycle phases. A set of artifacts comprising at least one of a set of metadata and a set of executable instructions associated with the set of operations is identified. The semantic representation the functional representation and the set of artifacts are stored in a composable software bundle.

The server system for example includes a composable software bundle asset and virtual image asset design creation environment herein referred to as the interactive environment . Users of the user systems interact with the interactive environment via a user interface or programmatically via an API. The bundle and image interactive environment in one embodiment comprises a tool that includes at least one of an application s a website a web application a mashup or the like that is used to define and publish composable software bundle assets and also image assets. In other words the interactive environment allows composable software bundle assets to be created and managed and also allows new virtual image assets image assets to be created from these bundle assets. As part of this process execution packages are generated and executed to extend an image with a number of software bundles.

A composable software bundle also referred to herein as a bundle software bundle software bundle asset bundle asset or other similar variations which are used interchangeably is a cloud independent description of software that captures those aspects needed to install and configure it in a virtual machine. This description allows the bundle to be used to support image asset construction for multiple target cloud platforms. The metadata for each bundle describes one or more of 1 the software s requirements and capabilities to ensure valid composition 2 the install steps that need to be executed and their parameters as part of a virtual image build life cycle phase 3 the deploy time configuration steps that need to be executed and their parameters as part of a virtual image deploy life cycle phase 4 the deploy time configurations that can be made with external software via virtual port definitions and 5 the capture time cleanup steps that need to be executed and their parameters as part of a virtual image capture life cycle phase. The metadata can comprise references to specific artifacts scripts binaries response files etc. These can be local references the artifacts are contained in the bundle or remote references to a remote repository . It should be noted that other virtual image life cycle phases such as but not limited to a start phase can be supported as well. The bundle is discussed in greater detail below.

With respect to virtual image assets also referred to herein as a image virtual image image asset or other similar variations which are used interchangeably the interactive environment uses a platform independent image description model that can be used to describe an image asset s 1 contents and capabilities 2 hardware requirements including hypervisor requirements 3 deployment time configuration steps that are to be executed and their parameters and 4 capture time cleanup steps that must be executed and their parameters. As with composable software bundles an image asset comprises both the image description and any required disk images scripts binaries etc. either directly or by reference needed to deploy the image asset.

A build environment is also communicatively coupled to the network s that provides the interactive environment with virtual machines with which it can build virtual image asset assets. The build environment in one embodiment can also comprise the image asset repository . The build environment is discussed in greater detail below. It should be noted that there can be multiple bundle and image asset repositories and multiple build environments .

The interactive environment addresses the needs of both software vendors and consumers by providing a system that allows vendors to focus on providing software as software bundles and allows consumers to easily compose these bundles with base virtual image assets to create custom virtual image assets satisfying their requirements. Software bundles comprise the necessary function to install software and configure it at image deployment together with metadata describing it in a target cloud independent way. At composition time the interactive environment uses this information in an image specific way.

One advantage of the interactive environment is that it is separate from target cloud details. In other words the interactive environment provides a standard way for software to be described in a target cloud independent way that enables the software to be installed and configured in multiple target clouds platforms. Another advantage is that the interactive environment supports different software installation and configuration infrastructures. A further advantage is with respect to the composition of software to images. For example the interactive environment provides tooling and a system to flexibly compose software on a base image asset. This tooling supports base virtual image assets with different operating systems on different system architectures and targeting different cloud platforms. These platforms are able to support different deployment time configuration tooling. Yet another advantage is that the interactive environment supports cross configuration of multiple image asset. For example the interactive environment provides a standard way to describe image asset enabling them to be composed into multi image solutions where valid compositions can be identified and in which deployment time ordering and parameter passing between image asset is supported.

The interactive environment addresses the problems faced by both software vendors and consumers by providing a system that allows software vendors to create cloud independent software bundles and image asset creators to more easily define and build image asset for a particular cloud platform by the vertical composition of those software bundles. A standard cloud independent description language for bundles allows software vendors to focus on creating bundles that address the fundamental installation and configuration issues that arise in a virtual machine setting independent of the eventual target environments. Once an image asset creator has identified the software bundles to be added the interactive environment generates reusable target cloud specific execution bundles that can be used to install and configure the software on a virtual machine.

Image asset creators use the interactive environment to define and publish image asset. An image asset description identifies the software comprising the image asset and describes the operations required including all parameters to configure the image asset at deployment time. An image asset creator can directly import image asset created externally or can define an image asset directly. Image asset creators can then extend image asset creating new image asset by vertically composing bundles onto the image asset. The interactive environment matches the defined requirements and capabilities of the bundles with those of other bundles and the image asset to validate the proposed composition. Furthermore the interactive environment mediates between the image asset definition and a build environment when necessary to deploy a base image asset deploy new software and to recapture the disks as part of a new image asset. Completed image assets can be published as reusable assets to a shared repository as shown in .

The bundle definer and image asset definer comprises logic to manage bundles and image asset . This logic supports the import modification and export of bundles and image assets . An execution package builder converts an image asset into a script or workflow that can be executed by an execution engine for a particular image targeted for a particular cloud platform. This component encapsulates the cloud platform specific configuration logic.

The image asset definer manages the definition of image asset. The image asset definer supports the definition of new image asset and the definition of image asset by extension from an existing base image asset. Existing bundle definitions from a bundle repository can be composed with the image asset to extend it. Specifically the image asset designer builder is responsible to select at least one bundle to add to the image asset. The image asset definer can also specify for each operation available in the chosen bundle when it will be executed. For example the image asset designer can decide that an operation to install a software will be executed one as part of the build phase of the image asset life cycle. He She can further decide that an operation to configure the software will be executed at each new deployment of the new image asset after it is built. The image asset designer can further designate a certain operation for example to reset cleanup logs to execute upon each capture life cycle phase of the new image asset. Other life cycle phases such as start or stop can be supported using this approach. While the bundle definer may specify intended life cycle phase for each operation included i.e. he she can specify that an operation is intended to run as part of build life cycle phase or any other life cycle phase it is ultimately the decision of the image asset designer at what life cycle phase to execute each operation. For example an operation to install or configure a software module may be designated to run at once at build or it can also be designated to run at each deployment of the image asset.

Also various embodiments of the present invention support two methods for extending image asset. The first method captured installed goes through a build of a new image asset and then capture thus producing a new virtual disk. The second method install on Deploy produces the new virtual image asset without capturing a new virtual disk. Thus a build phase is not a valid selection for an operation execution if the image asset designer is choosing to use this method of extension. In the second phase the image asset designer can chose operations from the SW Bundle to execute at each new deployment deployment life cycle phase or other life cycle phases if they are defined such as start stop and eventual future capture of the new image asset.

When necessary or desired the image asset definer uses the execution package builder to convert additions to a base image asset into execution packages which represent the specific binaries and scripts needed to install and configure one or more composable software bundles in a specific image asset targeted at a particular cloud platform as part of the virtual image build life cycle phase. These execution packages are then deployed to a running virtual system not shown in a build environment via an execution engine . The image asset definer reads existing image asset from and publishes new image asset to the image asset repository . It should be noted that an image asset importer can added that imports an image asset from another source such as another cloud another repository a running virtual machine the file system etc.

The execution package builder takes an image asset definition including software bundles that are identified as new bundles to be added to the image asset. The execution package builder converts these details into one or more execution packages that can be executed on the base image asset to install the specified software bundles and to configure anything necessary for deployment time configuration. Specifically the execution package is a workflow that executes all operations provided with the software bundle that are chosen by the image asset builder to execute at the virtual image asset build life cycle phase if it is valid and will configure the rest of the life cycle operations to execute at the designated life cycle phases. For example the workflow will register operations to execute at the deployment life cycle phase aka configuration operations or as part of the capture life cycle phase based on the image asset builder design using the appropriate mechanism. For example when the target cloud is an IBM WebSphere CloudBurst Appliance WCA the Virtual Solutions Activation Engine needs to be configured. The execution package builder creates execution packages that are target cloud specific. The execution package builder combines the cloud independent definition from the software bundles with internal logic to create target specific execution packages. Because the logic necessary to create valid execution packages differs for different target cloud environments an execution package builder in one embodiment is created for each target platform.

The execution engine is used to deploy image asset deploy software bundles as execution packages and recapture the image asset. Execution environments interact with an existing build environment for example an existing cloud or hypervisor. Users can directly access the virtual machines created by an execution environment to inspect changes and to manually modify the image asset. The interactive environment provides an execution engine for interaction with a hypervisor. However this engine can be replaced with an external engine providing in one embodiment the external engine implements a particular Representational State Transfer REST interface. It should be noted that various embodiments of the present invention are not required to implement a REST interface.

As discussed above the build environment provides the interactive environment with virtual machines with which it can build image asset. To support the interactive environment a build environment needs to be able to deploy image asset for example as virtual machines and in one embodiment support capture. Examples of build environments are a hypervisor or an existing cloud.

The interactive environment interacts with bundle and image asset repositories to persist reusable bundle and image assets as discussed above. The interactive environment provides default bundle and image asset repositories . These can be augmented with additional external repositories providing they implement a particular REST interface to allow access to the repository assets.

The interactive environment also comprises an image asset exporter . Image assets can be exported from one repository and prepared for import in a second repository. Image asset exports are target repository cloud platform specific hence each supported target format needs to be supported by a different image asset exporter . The image asset exporter is responsible for creating any necessary target specific metadata and producing a target specific package.

The interactive environment is advantageous because among other things it provides advanced planning separation of roles modularity and re use and flexibility. With respect to advanced planning the interactive environment helps a user find compatible assets such as but not limited to a base image asset compatible with a SW component to be installed resolving dependencies and sorting order of installation and or configuration. With respect to separation of roles modularity and re use users usually cannot take advantage of work done by other users. This is because image asset software packages and configuration scripts are not cleanly separated and are not associated with sufficient information to make sense of available components precluding programmatic automatic approach for planning design. The interactive environment overcomes this problem by providing separation of roles modularity and re use. With respect to flexibility the interactive environment provides a flexible way to configure an activation mechanism for new SW components e.g. drive registration of new configuration scripts .

Most existing tools are basically script based where the user is required to write a script for installation or configuration. In most build tools there is no distinct design phase at all. However with respect to one or more embodiments in the design phase users simply select what SW they want to add and what parameters they want to expose and the tool helps by leveraging semantically rich meta data to filter wrong choices show available assets including deployment configuration and alert on existing gaps and missing pieces. Most existing tools do not support separation of roles and re usability of assets there is one role image builder and there is no way for different image asset builders to re use portions of assets. Activity of image asset building basically starts from scratch each time. In one or more embodiments an expert user defines a composable software image asset bundle that is self describing and can be re used across image assets platforms clouds and with different styles of image asset extension customization. Thus the role of the image asset builder is much simplified by just re using bundles and the amortized complexity of image asset building is reduced significantly. Also various embodiments of the present invention allow life cycle operations to be added to image assets during the design phase of the image asset. Conventional tools do not provide this. Life cycles operations in one example are scripts that are to be executed at distinct life cycle phases such as but not limited to a deploy stage and a capture stage.

The proliferation of virtualization and cloud environments has become a major challenge to software and solution providers. Software providers are increasingly being asked to provide image based distributions of their software products. At the same time constraints on licensing patching monitoring security and other management clients as well as image asset imports preclude the use of a single golden operating system image across clouds. Furthermore the early stage of standardization on image metadata forces software providers to support multiple formats to describe their offerings e.g. OVF WCA parts IBM Smart Business Development and Test on the IBM Cloud parameters.xml etc . Solution providers face similar challenges that are exacerbated by the combinatorial complexity of their multi image solutions requiring deployment orchestration and configuration propagation.

Therefore various embodiments of the present invention support scalable development of software and solution assets that are interchangeable across different clouds. One or more embodiments of the present invention satisfies the following architectural requirements. 1 Separation of the software from the image and cloud on which it is to be added. This is advantageous because the large number of base Operating System images and cloud combinations means that software providers will not be able to build and maintain virtual image assets of their applications on all possible combinations. The providers will therefore find it necessary to provide a packaging of their software which supports users bringing their own OS and cloud target. 2 Composition of software from different providers. This is advantageous because the type of environment being targeted such as development versus staging effects the distribution of middleware and application components across stacks. The addition of security management and monitoring agents results in an exponentially sized space of possible software combinations and thus renders the static creation of images impractical. One or more embodiments therefore allow image asset creators the flexibility to combine software elements for inclusion in an image asset. The resulting image assets are composable to support reuse at the image level. 3 Constraining of valid deployment patterns. This is advantageous because the flexibility afforded by the separation of software and support for composition created challenges to image asset creators. Therefore one or more embodiments support representation and enforcement of patterns for deployment best practices.

In addition various embodiments of the present invention provide an interoperable format across different clouds hypervisors and execution engines such as IBM Smart Business Development Test on the IBM Cloud IBM WebSphere CloudBurst Appliance Virtuoso VMware ESX IBM Rational BuildForge IBM Tivoli Provisioning Manager and IBM Tivoli Service Automation Manager. Also one or more embodiments are compatible with multiple styles of image asset extension a deploy image asset install bundle capture image asset and activate software per deployment b install bundle offline and activate software per deploy c overlay bundle installation artifacts and install per image asset deployment. These embodiments provide a description of the software s requirements and capabilities to ensure valid composition. A description of the steps that need to be executed and their parameters are provided in a manner supporting binding to cloud and image specific activation mechanisms both internal as well as external to the image asset such as in an activation engine . Support for modeling software installation and configuration across different platforms Windows Linux AIX ZOS is also provided.

As discussed above the interactive environment is a tool that allows virtual assets to be designed built using composable image software bundles bundles in a platform and cloud agnostic manner. Based on the result of a design phase a new image asset can be compiled based on the choice of a platform cloud and image asset extension style .

A bundle captures the semantic and topological knowledge of a software component including the installation and runtime requirements the software structure its capabilities and configuration. In addition bundles include artifacts such as installation archives and scripts as well as the operations that need to be invoked such as to execute the installer with a response file along with meta data describing these operations their dependencies parameters and requirements. A bundle can include or be associated with multiple different configuration options. Each such configuration option is by itself a bundle that describes the parameters requirements and affects of the configuration operation in a semantically rich formal manner. An image asset builder can choose to run a configuration operation once e.g. to configure security and then capture the result or expose the option to run it with different parameters at each instance deployment of the image asset.

Stated differently a bundle is an asset capturing knowledge on how to install and or configure software on one or more virtual image asset. The bundle packages the metadata describing the requirements for software installation and or configuration the effects of applying the bundle to an image asset along with the operations that need to be executed and the artifacts associated with these operations. A key requirement for bundles is the ability to use them across different virtualization and cloud computing environments. This universality is achieved through the use of a common model for resource requirements and capabilities as well as operational execution. When a bundle is added to a virtual image asset hosted by a specific cloud its metadata is used to generate cloud specific configuration files and an execution package to invoke the operations on the image asset.

In addition to a bundle various embodiments also utilize the concept of an image asset which packages together a virtual image asset semantic knowledge which represents the image asset software stack and configuration and functional knowledge of deployment configuration options for this image asset. shows a high level example of logically adding a bundle to an image asset. For example shows a bundle comprises metadata and artifacts . also shows an image asset and that add configure software can be used to logically add the bundle to the image asset .

The design process of virtual assets using bundles in one embodiment comprises various roles such as a bundle author and an image asset author. A bundle author defines a bundle by defining the semantic and topological knowledge of the software providing the scripts and their metadata description along with other required artifacts. The bundle author can be an expert on installing or configuring one or more software products on a virtual image asset. This user understands the software requirements on the virtual server in terms of added memory and disk space as well as architectural constraints such as processor type and bus width. Similarly the user understands the requirements on operating system type distribution and level as well as additional software products that may be required. The user also knows the parameters of the software products installed. The user is an expert on the artifacts needed to install or configure the software product involved and can script their invocation. The bundle author does not have to be an expert on metadata formats for describing the requirements capabilities and operations of the bundle but instead can interact with a simple web interface that will collect this information and generate the bundle package.

An image asset author selects a base image asset and extends it with one or more bundles. The image asset author uses one or more bundles to vertically extend one or more base image asset for a particular purpose. The image asset author can an expert in identifying the type of software that needs to be installed and configured but is not required to be proficient in installing manually or in scripting the installation. Instead the user selects bundles which package the desired software leveraging the knowledge on requirements and operational execution that is captured in those bundles.

Another applicable role is a cloud adapter who is an expert who understands the Composable Software Bundle specification the format of a specific cloud s metadata as well as the mechanism for executing operations. The cloud adapter encodes the logic to import export cloud specific metadata to from the bundle models. He she also encodes the logic to generate an execution package to invoke the software install or configuration operations.

Turning now to bundle authoring bundle authoring is a design activity that is performed purposefully in an agnostic fashion with respect to how the bundle is to be used. The bundle design process does not consider peculiarities of particular cloud environments or specifics of different image asset extension styles e.g. install on deploy vs. captured install . The bundle author is an expert in the software domain and thus understands the installation options of the software and its configuration options. The bundle authoring process provides a semantically rich description of the software and the installation and configuration scripts their parameters requirements and affects.

In an install on deploy extension process software and or configuration logic is added to a base image asset. The output is an image asset that references the original disk image. In other words a new virtual disk is not created. The new software from the software bundle is installed at each deployment of the new image asset. In a captured install extension process software and or configuration logic is also added to a base image asset. A new virtual disk is created as a result of the captured install process.

The authoring step step also comprises an or loop step comprising a plurality of processes. For example a first process authors a semantic model describing the resulting software installation and or configuration step . A second process authors software requirements such as operating system types capacity dependencies on other software and the like step . A third process authors operation requirements such as execution container or dependencies on other software step . A fourth process describes parameters to the operation and constraints on values step .

With respect to the composed bundle step this bundle comprises two bundles that are all compatible and optional propagation relationships between parameters. In the process of image asset creation if a composed bundle is selected operations from both bundles are executed. shows with respect to creating a composed bundle step that combinations such as bundle bundle are selected step . Customization is performed such as defining attribute parameter propagation and selecting default mandatory values for parameters step . The composed bundle is then published at the bundle repository as a new software bundle step .

As can be seen from the above discussion a bundle captures the requirements and capabilities for installing or configuring a software package along with the artifacts such as installation archives and scripts as well as the operations that need to be invoked such as to execute the installer with a response file. shows a logical bundle structure resulting from the process discussed above with respect to .

In particular shows that the bundle is associated with requirements capabilities artifacts and operations . A bundle has certain requirements on the image asset that it will be added to. Some of these requirements come from the compatibility matrix for the base software being installed or configured. For example a bundle for DB2 ESE v9.7 on 32 bit Linux requires certain distributions and versions of Linux e.g. SLES10.2 or SLES 11 or RHEL 5.4 or Ubuntu 8.0.4.1 hardware properties e.g. 32 bit processor and disk and memory space. The base software can also require the presence of software on the image asset to enable some functionality. For example the secure remote management capability of DB2 requires the presence of an SSH client on the image asset. Other requirements can come from the scripts that are used to install the software product. For example the installation script can be written in Perl and thus require a Perl interpreter even though the software being installed does not have such a requirement. Similarly the bundle can download the installer ISO from a build server and thus require network access and additional disk space to store and expand the archive.

The requirements for a bundle can become complex in structure. For example DB2 ESE v9.7 on Linux can require SLES10.2 or SLES 11 or RHEL 5.2 or Ubuntu 8.0.4.1 and have different software package requirements based on which operating system is targeted. Some requirements can be over ranges of values such as CPU 2 GHz. Such constraints over multiple related objects can be expressed declaratively as and or trees or can be expressed as object based patterns that must be realized over the configuration of the target image asset.

The specific pattern in expresses that the DB2 ESE v9.7 installed by this bundle needs to be hosted on a Linux operating system shown in block which can be realized by either SLES10.2 or 11 or RHEL 5.2 shown in blocks and . If hosted on SLES10.2 or 11 then the software packages nfs utils shown in block and openssh shown in block must be present to enable certain function but can be installed after DB2 as well . If hosted on a RHEL system then the libaio package shown in block must be present before DB2 is installed. The capacity restriction on the DB2 deployment unit binds to the first unit down its hosting stack of type Server and reserves 256 MB for use by the DB2 server process shown in block .

With respect to capabilities adding a bundle to an image asset changes the contents of the image asset by installing removing or configuring software. The bundle needs to declare its effects on the image asset stack contents. showed a simple example of a generic software install unit to represent the fact that the bundle adds a new software package to the image asset as shown by block . Generic software install units can be associated with dynamic attributes to represent additional configuration information such as the installation directory the license etc. Users can also instantiate subtypes of the software install type which statically declare the attributes of the deployment unit. shows an example of a dynamic as well as a static type extension to the generic software install unit. Deployment units can also host configuration units which are not the same as configuration operations that model structural software configuration. For example the model for the DB2 ESE v9.7 install can include information on new users created as well as DB2 configuration such as the instances created as shown in which is only one non limiting example.

With respect to artifacts a bundle can be associated with one or more artifacts. These artifacts can represent content that can be locally copied into the image asset remotely executable content as well as metadata and documentation content. Locally copied content can include scripts installers archives and configuration files. Remotely copied content can include workflows. shows a logical bundle artifact metadata example. Bundle artifacts are associated with a source location which can be local to the bundle which means that the file contents are packaged with the bundle metadata or reference a remotely accessible resource such a pointer to the latest build of an application. Bundle artifacts can also be associated with a target location which can be local to the image asset such as a full file system path or a logical path where the meaning of the path depends on the target cloud or external such as the image asset record. When the target location is specified adding the bundle to an image asset results in the artifact s contents being copied. Additional properties such as the ownership and permissions associated with the new copy can also be specified. Artifacts are referenced from bundle metadata model elements and thus semantic information can be inferred about their function.

With respect to operations an operation provides implementations of the logic that should be executed at specific life cycle phases of the image asset. In particular operations can include logic to install the software in the bundle on an image asset logic to configure the software when an image asset comprising the software is deployed and cleanup logic to be executed prior to the capture of the image asset as a new image asset. Operations executed at other life cycle phases such as software startup or shutdown can also be included.

The operations are ordered and can be associated with parameters. Operation parameters can be associated with a name label description a set of default values or other items. Operations can further be assigned to execute in a specific stage of the image life cycle. The following three stages are supported. 1 Build this is a stage in which the image asset is built either by an instance being started for modification installation or configuration and then captured or by modifying the image disk in an off line manner. 2 Capture this is the stage where the image asset is about to be shutdown so that its disks can be captured. Bundles contribute cleanup operations to this stage to reset sensitive configuration such as passwords or logs . 3 Deploy this is the stage where an instance of an image asset is deployed. At this stage bundles can contribute all the types of operations that were applicable to the build stage but also configuration or activation operations to reconfigure software based on newly cloud assigned parameters such as the hostname or user assigned parameters such as a password.

In terms of execution context operations can be broadly characterized as internal local to the image asset or externally executed. Presently the specification only supports local operations however the definition of operations is extensible. Various core local image operation types are supported. For example 1 Local execute supports modeling the execution of a script or program on the local operating systems. Supports collecting parameters from the user and expressing how they are to be passed to the program invoked. Also supports specifying the user under which this operation is to be executed as well as the working directory and the shell. Only headless commands can be executed to support unattended deployments. The following are specializations of the local execute operation type 2 Local un archive supports extracting an archive into the image asset. Identifies the destination directory user and group owner. Delegates the determination of the command to execute to the execution framework and thus reduces platform dependencies e.g. paths to specific utilities etc . 3 Local install supports running a platform installation package such as an RPM . Supports defining a package repository to pull the package and or its dependencies automatically e.g. yum . Delegates the determination of the commands to execute to the execution framework to reduce platform dependencies.

The most basic type of operation is the local execute operation which runs a program inside the image asset. The program executed can be already present in the image asset as part of the operating system or the installation of another software product. For example the local execute operation can invoke the Linux operating system adduser program to create a new user on the image asset. Alternatively the command executed locally can have been copied as a file from the bundle artifact.

For example consider a bundle to install DB2 ESE v9.7 on a Linux based image asset. The software product is packaged as a TAR GZ encoded file archive which needs to be extracted. The extracted file archive contains a binary installer called db2setup . Normally the DB2 setup program runs in a graphical interactive mode unless started with a flag to indicate that the installation parameters are to be collected from a response file. Therefore the bundle also includes a response file for DB2 that comprises attribute value pairs for the default values. If the bundle is to support user deploy time parameters then it also needs to include an installation script that transforms the response file based on the values selected by the user.

The following is an activation example. Consider a bundle for configuring a DB2 ESE v9.7 installation by changing some of its attributes such as the hostname and the db2inst1 user password as shown in . This bundle declares in its requirements the fact that DB2 ESE v9.7 has already been installed. Its capability specifies that it changes certain attributes on the image asset. The bundle comprises a run operation with the specified parameters indicating that it is to be executed at image deploy. In this example the run command parameters are serialized using a pattern paramName value specifically usr sbin configDB2.sh db2Hostname value1 db2Inst1Password value2 .

The above discussion was directed mostly towards bundle authoring a more detailed discussion is now given with respect to creating an image asset. During an image asset creation process performed using the interactive environment the image asset author decides which bundle to put on a selected base image asset and what deployment parameters and options to expose. A same base process for designing an image asset is followed and a same collection of bundles can be re used no matter what the target cloud or local build environment and image asset extension style install on deploy or captured install style are.

The process for designing an image asset comprises selecting a base image asset iteratively selecting a bundle to add to the image asset any type configure parameters what will be exposed as asset parameter vs. provide fixed values or default values and decide what operation is to be executed at what life cycle phase i.e. at each instance deployment upon every capture software reset operation and upon capture but only once prior to first capture install software to be captured .

The interactive environment leverages the semantic knowledge both associated with the image asset as well as with the bundles to guide the user through the design process. The interactive environment allows filtering to find compatible asset combinations image asset bundle bundle bundle image asset image asset . The interactive environment alerts the user if there are gaps in the design. For example if a bundle requires another bundle that is not currently available on the image asset nor selected by the user the interactive environment notifies the user. The interactive environment provides information on bundles for configuring software components that are compatible with the software bundles the user selected or composed bundles that are compatible with selected bundle pairs can be used to cross configure these bundles . The interactive environment provide the list of parameters associated with bundles and allows the user to configure them with mandatory or default values as well as check these values against constraints defined in the bundle and propagate values across bundles based on the parameter propagation relationships within composed bundles.

Once the design process which comprises steps and completes synchronization step and publishing step of the image asset occurs. If the design process has not completed after the life cycle decision process step the control flow returns back to step . It should be noted that that alternative orderings of the actions in are also applicable. In particular the user can choose to synchronize at multiple intermediary points. Another example is that a bundle can be selected first and then a base image asset second. The interactive environment filters at each stage and show only compatible assets.

As discussed above a user can chose to execute an operation to install software module provided as part of a software bundle at different life cycle phases. For example the user can chose to install the software once as part of the build life cycle phase or to install the software at each deployment as part of the deployment life cycle phase . The following discussion is directed to various image asset creation examples involving bundle addition. In practice users extending image asset are likely to mix these flows for different bundles based on requirements. For example consider the creator of an image asset to test the latest version of a J2EE application. The application requires a J2EE middleware container which is constant. Therefore the application can be added to the image asset and captured on account that installing WebSphere Application Server is a lengthy process. However adding the application prior to capture requires capturing a new image asset whenever a new build of the J2EE application is made available. Instead the creator can choose to add the J2EE application every time the image asset is deployed deployment life cycle phase . This assures that a tester obtains the latest build the build ID itself could be a bundle parameter to support testing older builds .

A bundle can be added to an instance of an image asset and executed in the context of that instance with the purpose of capturing the changed image asset. shows one example of an instance install and capture process. The advantage of this approach is that users can perform manual configuration steps after executing the bundle build operations and that the effects of these manual steps are persistently shared across all instances in addition to the executed build operations. In a cloud environment the installed software can sometimes cache information that changes across image asset instances such as the hostname and IP address assigned by the cloud. In such cases the configuration of the software needs to be updated every time the image asset is instantiated to fix up activate the instance to the cloud assigned values for that instance. Depending on the cloud used the capture process can lead to a new image asset and associated metadata clone or can result in a replacement of the original image s disk. In either case the effects of adding the bundle likely results in an update of the metadata pointing to the newly captured disks.

The process as illustrated in begins with a running instance of an image asset. The base image asset metadata are used to check if the bundle is applicable to the instance. Having verified compatibility the bundle software is installed and then the instance is captured as a new image asset. As part of the capture process the original image asset s metadata including a semantic model and functional model associated with the original image asset is cloned and is subsequently updated to reflect the capabilities added by the bundle. The semantic model of the image asset describes the software stack that is in the image asset and the functional model includes the life cycle operations that are currently part of the image asset. These life cycle operations in one embodiment are a set of scripts that are to be executed a various different life cycle phases of the image asset such as but not limited to build deployment and capture. For example life cycle operations that are installation scripts are executed during a virtual image asset build life cycle phase. Life cycle operations that are configuration scripts are executed during a virtual image asset deploy life cycle phase. Life cycle operations that are reset scripts are executed during a virtual image asset capture life cycle phase.

A bundle supporting an off line operation which is an operation that can execute against a mounted version of an image asset can be added by executing the operation on a manager server to manipulate the contents of the image disk. shows one example of an off line install process. Depending on the cloud off line disk content updates can result in a new image asset being registered in the catalog or can directly update the disk contents of an existing image asset. In either case the metadata pointing to the changed disk which can be a patch view on the original needs to be updated to reflect the effects of adding the bundle.

The process as illustrated in involves a management server that mounts the image disk at the file system level. Having verified compatibility at the model level the bundles operations are executed on the management server making changes to the mounted disk image. Once completed the image is un mounted and its metadata are updated to reflect capabilities added by the bundle. This pattern in one embodiment needs support for mounting the image disks.

One way of adding a bundle supporting per deployment configuration is to add it to an image asset instance schedule it to be executed by the OS on the next image asset boot and capturing the image asset in this state. This process can be referred to schedule and execute on boot activate and is shown in . Therefore every time the image asset is deployed the activation logic executes. The mechanism used to execute on boot is platform specific e.g. can use the IBM Virtual Solution Activation Engine . One advantage of this approach is that execution of the image asset configuration logic is handled by the image asset itself and is not dependent on any cloud services such as the ability to overlay files at deploy time .

The process as illustrated in begins by starting an instance of an image asset. After checking bundle compatibility the operations of the bundle are scheduled to be executed at the next time the image asset is started. The specific mechanism for scheduling this execution is dependent on the Operating System of the image asset. The instance is captured in this state to execute the bundle on the next boot. Every time the image asset is deployed the bundle operations executes to install the bundle software on the instance.

A bundle can be added to the image asset as part of the deploy process if the cloud supports an overlay mechanism. In this method which is shown in the base image disk does not need to be changed or captured and all customization is performed individually on each instance. The advantage of this approach is that the bundle can retrieve the latest version of its artifacts. If the artifacts are updated daily for example from some build server the image could satisfy the requirements of a software tester who wants to test the latest version of an application. The deploy per instance flow as shown in can support both installation as well as configuration including activation bundles.

It should be noted that the bundle metadata describing the requirements and capabilities of an asset can be useful in itself even if the operations and artifacts are not used. For example a user can install DB2 manually and then use an install bundle for DB2 to update the metadata of an image asset. Alternatively a user can be handed an image asset containing software that has not been modeled and use bundles to describe it. In this flow the image asset contents are not changed and bundles are used only to update the image asset metadata to better reflect the contents of the image asset.

Composable Software Bundles provide great flexibility on how to package software functionality. For example a bundle can combine installation of a software product along with all its deploy time configuration parameterization options. Bundles can also be created to include installation and configuration of multiple products across one or more image asset. Therefore the bundle creator faces the challenge of deciding how to best divide his or her function into bundles. In this section we will discuss some of the best practices in determining how bundles are to be created in the context of some high level use cases.

To reduce the increased complexity brought on by the fine grained nature of bundles two mechanisms are introduced. The first mechanism is a relationship mechanism. Software bundles which contain only install operations can be related to their bundles which contain only configuration operations. Therefore when a user selects a software bundle to install a product they can automatically or through an interaction add the configuration bundles for that product in the correct order. Another mechanism is a pattern mechanism. Users can create patterns of bundle composition that can be shared. Therefore when a user extends an image asset they can add individual bundles or a pattern of bundles which represents the selection and ordering of bundles. Using patterns users can share coarser grained software product and configuration combinations without sacrificing the flexibility of fine grained bundles.

The specification of a bundle in one embodiment is based on a platform independent model of an asset that contains a number of artifacts. The asset is associated with attribute value pairs that describe the asset e.g. the name of the bundle as well as semantic references to artifacts it contains e.g. the requirements and capabilities model . In addition the bundle asset can be related to other bundle and image assets. These relationships are typed and have well defined semantics e.g. a configuration bundle configures an installation bundle . The asset model of various embodiments can be mapped into a simple file based representation as well as richer asset repositories such a Rational Asset Manager RAM . The following discussion specifies the structure of the bundle asset including its attributes relationships and models.

The mapping of logical bundle elements into an asset structure is illustrated in . shows a bundle associated with requirements capabilities artifacts and operations as discussed above with respect to . The capabilities and requirements of the bundle are stored in a semantic topology file . The operations and attributes artifacts associated with the bundle are stored in the functional topology file . In one embodiment the Zephyr deployment topology meta model is used to define the schema and semantics of the semantic and functional topology files . However other models can be used as well. The actual bundle artifacts can be stored directly as files contained in the asset or as links to external artifact repositories. Information about the asset itself such as its name id version creation date as well as the path to the semantic and functional topology model are stored as attributes on the asset . Relationships to other bundle and image assets are also stored in the asset .

The bundle asset is associated with a set of attributes and relationships . The attributes are used to describe the asset as well as identify artifacts that have additional information regarding the asset . With respect to attributes Table 1 below lists example of attributes associated with a bundle asset in one embodiment. The semantic and functional topology attributes identify the asset artifacts representing the bundle s capabilities requirements and operations.

Bundle assets can be related to other bundle and image assets using the following non exclusive example of binary relationships shown in Table 2 below 

The semantic model is used to store the requirements and capabilities of a Composable Software Bundle in the format of a Zephyr deployment model. As discussed above the Zephyr model is only one model applicable to various embodiments of the present invention. The Zephyr deployment topology is an XML formatted file used in a number of IBM products and services to represent and interchange deployment models.

The Zephyr deployment topology is a domain specific language serialized as XML which is built on a core model. The core model introduces the concept of a deployment unit with capabilities and requirements. Units capabilities and requirements can be related through a small set of typed links representing common deployment modeling concepts hosting dependency membership grouping and constraint. Iterative modeling is supported through the concepts of model imports copy by reference and conceptual units. Conceptual units are realized against more concrete units and enable modelers to express structural constraints on the model using a simple yet powerful model based approach.

Consider the semantic model for a bundle asset for installing the IBM DB2 Enterprise Server Edition ESE v9.7 as shown in . shows a graphical representation of a Zephyr deployment topology model for the bundle. The bundle represents an installer which supports RHEL Linux 5.4 represent choices such as RHEL or SLES can also be represented . The semantic model comprises a concrete non conceptual generic software install unit to represent the effect of adding the bundle to the image asset which is that DB2 ESE v9.7 is to be installed. The DB2 unit is to be hosted on an operating system unit that can realize the values of the conceptual unit which is that it must be a RedHat Linux operating system version 5.4 .

The XML representation of the above topology diagram is shown in . Note that the root element is a topology which comprises two units. Each unit comprises its capabilities and requirements as well as the links for which it is the source. The consumption of memory and disk on related resources down the hosting stack is captured using constraints.

The use of conceptual units supports a very rich language for defining patterns. See for example Pattern based SOA deployment . W Arnold T Eilam M Kalantar A Konstantinou A Totok Service Oriented Computing ICSOC 2007 Springer which is hereby incorporated by reference in its entirety. For example in it is shown how complex structured requirements for the DB2 bundle for installation can be specified in either SLES or RHEL. This is achieved by hosting the DB2 Software Install unit on a conceptual operating system that has multiple realizations. The semantics of multiple realizations is that of a structural choice OR . In this fashion users can define requirement for another software install by representing a conceptual unit that is hosted on the generic Linux OS applies to both RHEL and SLES or only on the RHEL or SLES unit which means that it is required only if that realization was matched.

Returning back to the functional model is used to store the operations and artifact properties of the bundle in the format of a deployment model. The deployment topology comprises a Virtual System unit that is associated with a Task which groups a set of Operations with associated parameters. Artifacts are associated with the virtual system and steps. Steps represent actions that are to be executed in the image asset. A small number of basic steps are supported such as run and specializations of run such as install and un archive. The functional model stores the mapping between the source location of the artifacts in the asset and the target location where they are to be copied in the image asset. The logical structure of the functional model is shown in . Using the Zephyr meta model the elements of the logical diagram in are modeled as linked units with requirements and capabilities.

Bundle operations are executed in the context of the image asset to which the bundle is to installed. There are two basic types of operations for the functional model structure of those executing against a file mount of the image asset contents and those executing in a running instance of the image asset. The base abstract type for operations running in the context of an image asset instance is a ImageLocalOperation. ImageLocalOperationis a common supertype of all operations executed in the running instance. In one example ImageLocalOperation attributes are 1 scriptName the name of the script 2 runAt an enumeration of when the operation needs to run in the life cycle of the image asset. The options are 1 imageBuild run as part of the construction of an image asset that will be captured 2 imageCapture run as part of the capture of an image asset typically used for clean up actions 3 imageDeploy run as part of deployment of an image asset typically used to activate image asset but can also be used to install software on every image asset deploy 4 runLevel at which OS runlevel this operation can be executed e.g. 3 5 and 5 serviceName the name of the OS service associated with the operation optional .

The most basic type of operation is one to run a command in the context of the image asset. The command is a string passed to an interpreter in the image asset and executed in the context of a user and a current working directory. The run operation for example adds the following parameters to the base ImageLocalOperation 1 interpreter the interpreter for the command to be executed 2 runAsUser the user who will own the process running the command 3 workingDirectory the working directory of the process running the command and 4 runCommands the command passed to the interpreter.

An un archive operation is used to extract an archive in a platform independent manner. It is the responsibility of the execution framework to translate the un archive operation into a run operation command appropriate for the target image asset e.g. usr bin unzip . The un archive operation adds the following parameters to the base ImageLocalOperation 1 ownerUser the user who will own the extracted files 2 ownerGroup the group that is to own the extracted files 3 archiveType the MIME type of archive and 4 outputPath the location where the archive is to be extracted on the local image disk.

An install operation is used to add a software package in a platform independent manner. It is the responsibility of the execution framework to translate the install operation into a run operation command appropriate for the target image asset e.g. usr sbin rpm . The install operation adds the following parameters to the base ImageLocalOperation 1 packageName the name of the package 2 packagePath the location of the package on the image asset 3 force true if the package is to be installed even if already present or if dependencies are missing 4 usePackageManagementSystem true if required packages that are missing should be retrieved and installed from a repository 5 repositoryUrl the repository from which required packages will be retrieved if this function is enabled 6 repoType the type of repository from which required packages are retrieved if this function is enabled and 7 rpmOptions specific options passed to the package installer.

In addition to the bundle comprising a semantic model and a functional model an image asset similarly comprises a semantic model and a functional model as discussed above. When a software bundle is added to a base image asset to create a new image asset as discussed the new image asset comprises metadata that is based on both the semantic model and functional model of the base image asset and the semantic model and functional model of the software bundle. For example shows a base image asset comprising a virtual disk a semantic model and a functional model . The semantic model indicates that the base image asset comprises an operating system SLES 11 and a software component Activation Engine AE that is installed on the operating system SLES 11. The functional model describes the operations that come with the base image asset . For example the functional model indicates that an operation OP1 which is a network configuration operation is within the base image asset . This operation OP1 is an activation configuration script. Therefore this operation OP1 is executed during a deployment life cycle phase.

The semantic and functional models of the base image asset are updated based on WebSphere being installed and OP1 and OP2 of the bundle being copied over. This results in a new semantic model and a new functional model . The new semantic model in the new image asset showing that the operating system is associated with two software components SLES and WebSphere installed thereon. The functional model comprises OP1 from the base image asset and OP1 and OP2 from the bundle . Therefore whenever the new image asset is deployed i.e. the deployment life cycle phase OP1 from the base image asset and OP2 from the bundle are executed. OP3 is executed during a capture life cycle phase of the new image asset .

The build life cycle phase then occurs where synchronization and capture processes occur as represented by blocks and respectively to build a new image disk. During the synchronization process the bundle is copied onto the base image asset to create a new image asset and any operations such as OP1 designated to run during the build install phase are executed. During the capture process any operations designated to execute in the capture life cycle phase such as reset operations from the base image asset are ran.

After the capture process has complete the new image asset foo is created with a new image disk. During a runtime life cycle phase represented by block and optionally block a deployment phase can occur where any operations such as OP2 which has been copied over from the bundle designated run during the life cycle phase are executed. If this image asset is as a base image asset to create a new image asset capture is run again as shown by block and any operations such as OP3 copied over from the bindle are executed during this capture process.

With respect to an install on deploy image extension process the build phase shown in is not performed. In other words a new image asset is not being produced the base image asset is being used but with updated metadata and artifacts. For example an image asset can comprise a script that installs WebSphere as an activation script at the deployment life cycle phase. Therefore every time the new asset is started it does to the original disk and starts the original disk but since it includes this activation script that runs as part of startup it will install WebSphere. In other words the installation is performed as part of deployment.

In particular shows semantic and functional models of a base image asset and semantic models of a bundle. In this example the image asset semantic model shows that the operating system is SLES 11. This requires a x86 server or virtual machine to be validly deployed. In this requirement is expressed using a conceptual unit one with the conceptual attribute set to true indicated visually using parenthesis around the unit name. Further the semantic model shows that IBM Tivoli Monitoring 6.1 and Perl 5.10.1.1007 are already installed in the image asset. The functional model shows that the image asset has one configuration operation ConfigNET.

The bundle semantic and functional models are used by a WebSphere 7.0.0.7 bundle. The bundle semantic model expresses a requirement for a Linux operating system. The functional model shows that associated with the WebSphere software is an install operation installWAS HV7 . This operation requires runs on the same Linux where the WebSphere software is to be installed and it depends on Perl . In the requirement that the operating system to host WebSphere and the install program is shown using a technique called model import. This is shown by the arrow labeled between the semantic and functional models. This arrow head points at the importing model. The importing model may reference the units in the imported model. That a unit is imported is shown visually using an arrow in the upper left corner of the unit in the importing model.

In order for a bundle to be validly added to an image asset the requirements of the bundle must be satisfied. When these requirements are specified using conceptual units as in the example WebSphere 7.0.0.7 bundle satisfaction can be determined using a process termed realization in which the conceptual units are matched to non conceptual units in a second model. If all the conceptual units can be matched the requirements described by the conceptual units are satisfied. In this process is shown by the dashed arrows labeled .

Once it has been determined that a bundle s requirements are satisfied by an image asset the bundle may be added to the image asset. The addition of the bundle results in changes to the image asset model. In particular the bundle models are combined with the image asset models. Any non conceptual units in the bundle model are added to the image asset model with relationships matching those expressed in the bundle. This resulting image asset model as shown in comprises a semantic model and a functional model .

The user via the interactive environment edits the image asset definition by adding bundles setting parameters etc. step . The user via the interactive environment saves exits the image asset definition edit mode step . The interactive environment updates the image asset based on the user input step . The image asset is out of synch at this point. The user via the interactive environment selects the synchronization option to synchronize the image asset step . The interactive environment initiates the synchronization process step . The interactive environment determines if the image asset is to be deployed step . If so the local build environment performs various operations for deploying the image asset step . If not or after the deployment process the interactive environment generates execution packages step . The local build environment then executes the execution package s step . The interactive environment then updates the models within the image asset accordingly step . The image asset is now synchronized at this point.

If the user wants to continue editing the image asset definition the control flows back to step if not the user via the interactive environment captures the image asset step . The local build environment stops the virtual machine step . The local build environment then captures disks or transfers the disks step . The user via the interactive environment publishes the image asset step and may optionally export the image asset step . In one embodiment the exported image asset comprises a WCA specific Open Virtual Appliance OVA asset properties semantic model functional model WCA specific Open Virtual Format OVF disk image and part definitions. The interactive environment then targets a specific export step .

The user via the interactive environment edits the image asset definition by adding bundles setting parameters etc. step . The user then saves and exits the editing mode of the interactive environment step . The interactive environment then updates the image asset which is now in an out of synch state step . The user via the interactive environment selects a synchronization mode step . The interactive environment starts the synchronization process step . The interactive environment determines if the image asset is to be deployed step . If so then the image asset is deployed in the build environment which is a cloud environment in this example step . The control then flows to step . If the image asset has already been deployed then the interactive environment generates execution packages step . The build environment then executes the execution packages step . The interactive environment updates the models within the image asset accordingly step . The image asset is now synchronized at this point.

If the user wants to continue editing the image asset definition the control flows back to step if not the user via the interactive environment captures the image asset step . The interactive environment the performs a cleanup operation step . The interactive environment then generates execution packages step . The build environment executes the execution packages step . The build environment captures the image asset step . The user via the interactive environment then publishes the image asset to the repository step .

The interactive environment stores the semantic representation the functional representation and the set of artifacts in a composable software bundle step .

As can be seen from the above discussion various embodiments of the present invention help users design new bundles and image assets. One or more embodiments leverage the semantic knowledge in bundles and image assets to provide capabilities such as search and filtering to identify compatible assets bundle bundle bundle image asset image asset image asset identifying gaps and missing software components. Various embodiments also provide at least the following advantages. 1 Separation of roles modularity and re use bundles can be combined in multiple different ways to create different image assets. 2 Advanced design and planning capabilities leveraging the semantic knowledge in bundles and image asset. Such as search and filtering ordering and so on. 3 Reduction of complexity of creating image assets since the image asset author is re using bundles and tool is constructing all necessary workflows. 4 Increase of level of assurance that the result is functional since requirements and dependencies are handled earlier at the planning stage. 5 Support for generation of multiple different formats for different clouds.

It is understood in advance that although the following is a detailed discussion on cloud computing implementation of the teachings recited herein are not limited to a cloud computing environment. Rather various embodiments of the present invention are capable of being implemented in conjunction with any other type of computing environment now known or later developed. For example various embodiments of the present invention are applicable to any computing environment with a virtualized infrastructure or any other type of computing environment.

For convenience the Detailed Description includes the following definitions which have been derived from the Draft NIST Working Definition of Cloud Computing by Peter Mell and Tim Grance dated Oct. 7 2009 which is cited in an IDS filed herewith and a copy of which is attached thereto. However it should be noted that cloud computing environments that are applicable to one or more embodiments of the present invention are not required to correspond to the following definitions and characteristics given below or in the Draft NIST Working Definition of Cloud Computing publication. It should also be noted that the following definitions characteristics and discussions of cloud computing are given as non limiting examples.

Cloud computing is a model of service delivery for enabling convenient on demand network access to a shared pool of configurable computing resources e.g. networks network bandwidth servers processing memory storage applications virtual machines and services that can be rapidly provisioned and released with minimal management effort or interaction with a provider of the service. This cloud model may include at least five characteristics at least three service models and at least four deployment models.

On demand self service a cloud consumer can unilaterally provision computing capabilities such as server time and network storage as needed automatically without requiring human interaction with the service s provider.

Broad network access capabilities are available over a network and accessed through standard mechanisms that promote use by heterogeneous thin or thick client platforms e.g. mobile phones laptops and PDAs .

Resource pooling the provider s computing resources are pooled to serve multiple consumers using a multi tenant model with different physical and virtual resources dynamically assigned and reassigned according to demand. There is a sense of location independence in that the consumer generally has no control or knowledge over the exact location of the provided resources but may be able to specify location at a higher level of abstraction e.g. country state or datacenter .

Rapid elasticity capabilities can be rapidly and elastically provisioned in some cases automatically to quickly scale out and rapidly released to quickly scale in. To the consumer the capabilities available for provisioning often appear to be unlimited and can be purchased in any quantity at any time.

Measured service cloud systems automatically control and optimize resource use by leveraging a metering capability at some level of abstraction appropriate to the type of service e.g. storage processing bandwidth and active user accounts . Resource usage can be monitored controlled and reported providing transparency for both the provider and consumer of the utilized service.

Software as a Service SaaS the capability provided to the consumer is to use the provider s applications running on a cloud infrastructure. The applications are accessible from various client devices through a thin client interface such as a web browser e.g. web based e mail . The consumer does not manage or control the underlying cloud infrastructure including network servers operating systems storage or even individual application capabilities with the possible exception of limited user specific application configuration settings.

Platform as a Service PaaS the capability provided to the consumer is to deploy onto the cloud infrastructure consumer created or acquired applications created using programming languages and tools supported by the provider. The consumer does not manage or control the underlying cloud infrastructure including networks servers operating systems or storage but has control over the deployed applications and possibly application hosting environment configurations.

Infrastructure as a Service IaaS the capability provided to the consumer is to provision processing storage networks and other fundamental computing resources where the consumer is able to deploy and run arbitrary software which can include operating systems and applications. The consumer does not manage or control the underlying cloud infrastructure but has control over operating systems storage deployed applications and possibly limited control of select networking components e.g. host firewalls .

Private cloud the cloud infrastructure is operated solely for an organization. It may be managed by the organization or a third party and may exist on premises or off premises.

Community cloud the cloud infrastructure is shared by several organizations and supports a specific community that has shared concerns e.g. mission security requirements policy and compliance considerations . It may be managed by the organizations or a third party and may exist on premises or off premises.

Public cloud the cloud infrastructure is made available to the general public or a large industry group and is owned by an organization selling cloud services.

Hybrid cloud the cloud infrastructure is a composition of two or more clouds private community or public that remain unique entities but are bound together by standardized or proprietary technology that enables data and application portability e.g. cloud bursting for load balancing between clouds .

A cloud computing environment is service oriented with a focus on statelessness low coupling modularity and semantic interoperability. At the heart of cloud computing is an infrastructure comprising a network of interconnected nodes.

Referring now to a schematic of an example of a cloud computing node is shown. Cloud computing node is only one example of a suitable cloud computing node and is not intended to suggest any limitation as to the scope of use or functionality of embodiments of the invention described herein. Regardless cloud computing node is capable of being implemented and or performing any of the functionality set forth hereinabove.

In cloud computing node there is a computer system server which is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with computer system server include but are not limited to personal computer systems server computer systems thin clients thick clients hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputer systems mainframe computer systems and distributed cloud computing environments that include any of the above systems or devices and the like.

Computer system server may be described in the general context of computer system executable instructions such as program modules being executed by a computer system. Generally program modules may include routines programs objects components logic data structures and so on that perform particular tasks or implement particular abstract data types. Computer system server may be practiced in distributed cloud computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed cloud computing environment program modules may be located in both local and remote computer system storage media including memory storage devices.

As shown in computer system server in cloud computing node is shown in the form of a general purpose computing device. The components of computer system server may include but are not limited to one or more processors or processing units a system memory and a bus that couples various system components including system memory to processor .

Bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnects PCI bus.

Computer system server typically includes a variety of computer system readable media. Such media may be any available media that is accessible by computer system server and it includes both volatile and non volatile media removable and non removable media.

System memory in one embodiment comprises the interactive environment and its components as shown in . These one or more components of the interactive environment can also be implemented in hardware as well. The system memory can include computer system readable media in the form of volatile memory such as random access memory RAM and or cache memory . Computer system server may further include other removable non removable volatile non volatile computer system storage media. By way of example only storage system can be provided for reading from and writing to a non removable non volatile magnetic media not shown and typically called a hard drive . Although not shown a magnetic disk drive for reading from and writing to a removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive for reading from or writing to a removable non volatile optical disk such as a CD ROM DVD ROM or other optical media can be provided. In such instances each can be connected to bus by one or more data media interfaces. As will be further depicted and described below memory may include at least one program product having a set e.g. at least one of program modules that are configured to carry out the functions of embodiments of the invention.

Program utility having a set at least one of program modules may be stored in memory by way of example and not limitation as well as an operating system one or more application programs other program modules and program data. Each of the operating system one or more application programs other program modules and program data or some combination thereof may include an implementation of a networking environment. Program modules generally carry out the functions and or methodologies of embodiments of the invention as described herein.

Computer system server may also communicate with one or more external devices such as a keyboard a pointing device a display etc. one or more devices that enable a user to interact with computer system server and or any devices e.g. network card modem etc. that enable computer system server to communicate with one or more other computing devices. Such communication can occur via I O interfaces . Still yet computer system server can communicate with one or more networks such as a local area network LAN a general wide area network WAN and or a public network e.g. the Internet via network adapter . As depicted network adapter communicates with the other components of computer system server via bus . It should be understood that although not shown other hardware and or software components could be used in conjunction with computer system server . Examples include but are not limited to microcode device drivers redundant processing units external disk drive arrays RAID systems tape drives and data archival storage systems etc.

Referring now to illustrative cloud computing environment is depicted. As shown cloud computing environment comprises one or more cloud computing nodes with which local computing devices used by cloud consumers such as for example personal digital assistant PDA or cellular telephone A desktop computer B laptop computer and or automobile computer system may communicate. Nodes may communicate with one another. They may be grouped not shown physically or virtually in one or more networks such as Private Community Public or Hybrid clouds as described hereinabove or a combination thereof. This allows cloud computing environment to offer infrastructure platforms and or software as services for which a cloud consumer does not need to maintain resources on a local computing device. It is understood that the types of computing devices shown in are intended to be illustrative only and that computing nodes and cloud computing environment can communicate with any type of computerized device over any type of network and or network addressable connection e.g. using a web browser .

Referring now to a set of functional abstraction layers provided by cloud computing environment is shown. It should be understood in advance that the components layers and functions shown in are intended to be illustrative only and embodiments of the invention are not limited thereto. As depicted the following layers and corresponding functions are provided 

Hardware and software layer includes hardware and software components. Examples of hardware components include mainframes in one example IBM zSeries systems RISC Reduced Instruction Set Computer architecture based servers in one example IBM pSeries systems IBM xSeries systems IBM BladeCenter systems storage devices networks and networking components. Examples of software components include network application server software in one example IBM WebSphere application server software and database software in one example IBM DB2 database software. IBM zSeries pSeries xSeries BladeCenter WebSphere and DB2 are trademarks of International Business Machines Corporation registered in many jurisdictions worldwide 

Virtualization layer provides an abstraction layer from which the following examples of virtual entities may be provided virtual servers virtual storage virtual networks including virtual private networks virtual applications and operating systems and virtual clients.

In one example management layer may provide the functions described below. Resource provisioning provides dynamic procurement of computing resources and other resources that are utilized to perform tasks within the cloud computing environment. Metering and Pricing provide cost tracking as resources are utilized within the cloud computing environment and billing or invoicing for consumption of these resources. In one example these resources may comprise application software licenses. Security provides identity verification for cloud consumers and tasks as well as protection for data and other resources. User portal provides access to the cloud computing environment for consumers and system administrators. Service level management provides cloud computing resource allocation and management such that required service levels are met. Service Level Agreement SLA planning and fulfillment provide pre arrangement for and procurement of cloud computing resources for which a future requirement is anticipated in accordance with an SLA.

Workloads layer provides examples of functionality for which the cloud computing environment may be utilized. Examples of workloads and functions which may be provided from this layer include mapping and navigation software development and lifecycle management virtual classroom education delivery data analytics processing transaction processing and composable software bundle and virtual image asset design and creation.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention have been discussed above with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

It should be noted that various aspects of one or more embodiments of the present invention discussed above are further discussed in greater detail in one or more of the following references 

