---

title: Ensuring deterministic thread context switching in virtual machine applications
abstract: Techniques for ensuring deterministic thread context switching in a virtual machine application program include, in one embodiment, providing a single application-level mutex that threads of the executing application program are forced to acquire to execute application code of the virtual machine application program. During a first recorded execution of the virtual machine application program, a record is created and stored in a computer that indicates the order in which threads acquire the application-level mutex. In a subsequent replay execution of the virtual machine application program from the recording, threads of the virtual machine application program are managed to ensure that the application-level mutex is acquired by threads in the same order indicated in the record such that any race conditions that occurred during the recorded execution as a result of executing application code are reproduced during the subsequent replay execution thereby aiding application development personnel in identifying and isolating program errors and bugs related to race conditions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08499299&OS=08499299&RS=08499299
owner: CA, Inc.
number: 08499299
owner_city: Islandia
owner_country: US
publication_date: 20100629
---
Embodiments are generally directed to virtual machines and more particularly to ensuring deterministic thread context switching in virtual machine applications.

Threads are commonly used in computer programs to achieve concurrency in computer systems. Very generally a thread is a sequence of computer executable instructions that executes independently of other sequences of instructions. Many modern computer processors and computer operating systems are capable of scheduling and executing multiple threads concurrently and allowing threads to interact through shared resources or shared program state. A computer program that executes with multiple threads of execution is often said to be a multi threaded computer program.

Among the types of computer programs that can be multi threaded are computer programs that execute on some virtual machines. Such programs typically contain instructions that are interpreted at runtime and executed by a virtual machine that interfaces with the operating system of the physical hardware on which the virtual machine executes. The virtual machine is an entity that executes machine language instructions in response to the interpretation of corresponding virtual machine instructions such as bytecode. The Java Virtual Machine JVM is an example of such a virtual machine although there are several virtual machines capable of executing such programs. Components of the .NET Framework available from the Microsoft Corporation of Redmond Wash. are other examples of such a virtual machine.

It is often desirable to be able to replicate the execution of a virtual machine computer program in a manner such that the executing program exhibits during replay of a recorded program execution the same behavior that the program exhibited when the program originally executed. For example a programmer might wish to record a virtual machine computer program s behavior in a production environment and then replay that program in a debugging environment in order to locate and fix possible errors in the program code errors that caused unexpected or undesirable results in the production environment. Under such circumstances if the program behaves differently when replayed in the debugging environment than the program behaved in the production environment the programmer may have great difficulty in isolating the source of the problems that were previously encountered.

One aspect of a multi threaded virtual machine application program that may behave differently when replayed is thread context switching by the operating system underlying the virtual machine. In this context thread context switching refers to the time at which a processor is switched by the operating system from executing one thread to executing another. This thread context switching is largely non deterministic because this switch time is not readily predictable. Consequently there is no inherent guarantee that the order of virtual machine application code executed by multiple threads will be the same during separate executions of the virtual machine application program. If the order of application code performed by multiple threads is different when replayed in the debugging environment than the order in the production environment the programmer may have great difficulty in isolating the source of the problems that were previously encountered especially if the source of the problems is dependent on the order of application code executed by the multiple threads. Further if the order of application code performed by multiple threads is different when replayed in the debugging environment than the order in the production environment information recorded about the program s behavior in the production environment may become out of sync during replay of the program in the debugging environment.

One source of program bugs and errors in virtual machine application programs that is dependent on the order of application code executed by multiple threads are race conditions. Very generally a race condition occurs when an output or result of computer program depends on the sequence or timing of execution events. A race condition can arise during execution of a multi threaded virtual machine program because of thread context switching. For example two threads may update a shared data structure at nearly the same time and the program may execute correctly only when the two threads perform updates in one and only one order. If because of thread context switching the order of application code performed by multiple threads is different when replayed in the debugging environment than the order in the production environment then a race condition that occurred when the program was recorded in the production environment may not be accurately reproduced when the program is replayed in the debugging environment. This is problematic for computer program developers and testers if the source of a bug in the program is the race condition because the program when replayed may not exhibit the race condition previously encountered in the production environment.

The approaches described in this section could be pursued but are not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated herein the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.

Techniques for ensuring deterministic thread context switching in virtual machine applications are disclosed and described. In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

Techniques for ensuring deterministic thread context switching in a virtual machine application program include in one embodiment providing a single application level mutex that threads of the executing application program are forced to acquire to execute application code of the virtual machine application program. During a first recorded execution of the virtual machine application program a record is created and stored in a computer that indicates the order in which threads acquire the application level mutex. In a subsequent replay execution of the virtual machine application program from the recording threads of the virtual machine application program are managed to ensure that the application level mutex is acquired by threads in the same order indicated in the record such that any race conditions that occurred during the recorded execution as a result of executing application code are reproduced during the subsequent replay execution thereby aiding application development personnel in identifying and isolating program errors and bugs related to race conditions.

In one aspect the techniques include detecting when a thread of the virtual machine application program is about to make a potentially blocking method or function call and forcing the thread to release the application level mutex before making the potentially blocking call thereby allowing another thread of the virtual machine application program to acquire the application level mutex and execute application code. The thread is forced to re acquire the application level mutex after the potentially blocking call completes and before continuing to execute application code. In one embodiment potentially blocking calls include any native method or function call.

In another aspect to prevent the application level mutex from causing deadlocks during execution threads are forced to release the application level mutex before acquiring other mutexes.

In yet another aspect threads are forced to release the application level mutex only when attempting to acquire another mutex currently held by another thread.

In still yet another aspect a record is created and stored in a computer indicating whether threads acquire mutexes other than the application level mutex during execution of the virtual machine application program deterministically or non deterministically. The record is consulted when a thread attempts to acquire a mutex currently held by another thread. If the other thread acquired the mutex deterministically then the thread attempting to acquire the mutex is forced to release the application level mutex so that the other thread can acquire the application level mutex and ultimately release the mutex. If on the other hand the other thread acquired the mutex non deterministically then the thread attempting to acquire the mutex retains the application level mutex until the other thread releases the mutex.

In yet another aspect the techniques are implemented by a combination of instrumented code added to application code of the virtual machine application program and event handling logic of a profiler agent of the virtual machine executing the virtual machine application program. In one embodiment the virtual machine is a Java Virtual Machine JVM executing a Java application program and the profiler agent is a Java Virtual Machine Tool Interface JVMTI agent of the Java Virtual Machine.

In other embodiments the techniques encompasses a computer readable non transitory medium encoded with instructions which when executed may cause one or more processors to perform the functions of the system described in this section and a system comprising means for performing the functions of the system described in this section and a method which may be computer implemented comprising steps corresponding to the functions of the system described in this section.

An application virtual machine runs on the operating system and can execute a virtual machine application program . The virtual machine emulates a computer system defined by a specification allowing virtual machine application to run a wide variety of computer systems and operating systems. One non limiting example of a virtual machine suitable for use as virtual machine is the Java Virtual Machine JVM . Other non limiting examples include the Virtual Execution System VES and the Common Language Runtime CLR that are part of the .NET framework available from Microsoft Corporation of Redmond Wash.

The virtual machine includes virtual machine core for interfacing with the underlying operating system and for abstracting details of the particular underlying operating system from the virtual machine application . Thus in most cases the virtual machine isolates the virtual machine application from the operating system . The virtual machine core provides an Application Programming Interface API to the operating system for the virtual machine application and supervises and controls the virtual machine application . In one embodiment the virtual machine application is developed in a high level programming language e.g. Java C VB.NET and J as source code. The source code is then compiled into an intermediate language such as Java bytecode or the Common Intermediate Language CIL capable of being executed by the virtual machine to carry out of the programmed functions of the virtual machine application . As used herein the term application code and the term bytecode refer interchangeably to any set of instructions of a virtual machine application that are capable of being executed by a virtual machine as opposed to native instructions that are capable of being executed only by the underlying operating system. Further the term bytecode as used herein is not limited to only Java bytecode and includes other types of instructions that are capable of being executed by types of virtual machines other than a Java Virtual Machine.

The virtual machine also includes a profiler agent for profiling the execution of the virtual machine application . Profiling refers to programmatically obtaining analyzing and inspecting state of the virtual machine application and programmatically controlling the execution of the virtual machine application . The virtual machine core provides a profiler API allowing the profiler to gain access to selected state of the virtual machine application during execution and allowing the profiler agent to control aspects of the execution of the virtual machine application . In one embodiment the profiler API provides a two way interface allowing profiling logic to receive notifications of execution events as they occur during execution of the virtual machine application and also allowing profiling logic to query and control the virtual machine application either in response to received notifications or independent of them. In one embodiment the profiler agent is embodied as software as a dynamic link library DLL or other type of software library that is statically or dynamically linked and loaded into the virtual machine. Thus in this embodiment the profiler agent executes in the same process with the virtual machine executing the virtual machine application being profiled. In other embodiments the profiler agent executes as a process separate from the process executing the virtual machine and an inter process communication mechanism facilitated by the operating system is used to facilitate communication between the virtual machine and the profiler agent . In one embodiment in which the virtual machine is a Java Virtual Machine the profiler API includes the Java Virtual Machine Tool Interface JVMTI and the Java Native Interface JNI and the profiler agent executes as a client of the virtual machine as a JVMTI agent.

In some circumstances the virtual machine may not provide a direct interface for the profiler agent to obtain information about certain execution events that the profiler agent is interested in or provide a direct interface to control the execution of the virtual machine application in a desired manner. In these circumstances in addition to bytecode provided by a developer of the virtual machine application and bytecode comprising standard libraries and third party libraries used by the virtual machine application application bytecode may include instrumented bytecode . In one embodiment the virtual machine provides the ability to instrument the virtual machine application with additional bytecode that when executed by the virtual machine as part of executing the virtual machine application provides the profiler agent with the desired information or controls the virtual machine application in the desired manner. The process of programmatically adding bytecode to an existing virtual machine application may be termed as instrumentation of the virtual machine application. Instrumentation may be used to cause the virtual machine application to perform virtually any function that the virtual machine application itself could have been originally programmed to perform. Thus instrumentation refers broadly to programmatically adding any bytecode to existing virtual machine application bytecode such that the added bytecode may be executed along with the existing application bytecode when the virtual machine application is executed by the virtual machine.

In one embodiment the profiler agent contains instrumentation logic for instrumenting the virtual machine application with instrumented bytecode . The instrumentation logic may use a programmatic interface provided by the virtual machine to accomplish the instrumentation of the virtual machine application . In one embodiment the profiler agent instruments the virtual machine application before a class object module or other logical portion of application bytecode is loaded for execution by the virtual machine . When the virtual machine loads a class object module or portion of application bytecode for execution the virtual machine notifies the profiler agent through an API thus giving the profiler agent an opportunity to inspect and instrument the class object module or portion before the class object module or portion begins to execute. Once loaded the class object module or portion executes with the bytecode added by instrumentation. For example in one embodiment in which the virtual machine is a Java Virtual Machine the virtual machine notifies the profiler agent as Java classes referenced by the virtual machine application are loaded by the virtual machine giving the profiler agent the opportunity to inspect and instrument the bytecode of the Java classes before they are loaded for execution by the virtual machine .

In one embodiment the techniques described herein for ensuring deterministic thread context switching in virtual machine applications are embodied in a combination of instrumented code instrumentation logic and profiling logic .

The virtual machine application can be virtually any virtual machine application program capable of executing on the virtual machine . In one embodiment the virtual machine application is a Java application executing on a Java Virtual Machine . However the virtual machine application may be another type of application executing on another type of virtual machine. For example the virtual machine application can be an application executing on the Virtual Execution System VES or executing in the Common Language Runtime CLR environment. The Virtual Execution System VES and the Common Language Runtime CLR are both components of the .NET Platform software available from Microsoft Corporation of Redmond Wash.

In executing the virtual machine application program the virtual machine makes calls into and receives return values from the operating system . At least some functionality intended for the virtual machine application program cannot be achieved by the virtual machine alone without the participation of the operating system . The operations performed by the virtual machine itself while executing the application program will not vary from execution to execution each time that the virtual machine executes the application program virtual machine will perform exactly the same operations in response to the instructions of which the application program is made up. Therefore the behavior of the virtual machine is said to be deterministic. The virtual machine application program is also deterministic in nature. However the virtual machine has little to no control over the inner workings of the operating system and the timing with which the operating system responds to the virtual machine largely cannot be anticipated. Indeed different versions of the virtual machine may be created to interface with different operating systems and while the operations of each version of the virtual machine will remain consistent between versions according to the specification of the virtual machine the different operating systems with which the different versions of the virtual machine interface may behave at least somewhat differently e.g. in timing from each other. Thus the behavior of the operating system is non deterministic. There is no inherent guarantee that the operating system will behave in exactly the same manner during separate executions of the application program despite the fact that the application and the virtual machine remain constant during those separate executions.

In an embodiment information identifying non deterministic sources of input to virtual machine application is recorded and stored by the record and replay system as the virtual machine application executes in a production environment and the recorded execution of the virtual machine application is later replayed by the record and replay system in a debugging environment. As used herein the term production environment refers broadly to any environment in which a virtual machine application s behavior is being programmatically recorded or observed and the term debugging environment refers broadly to any environment in which the virtual machine application s behavior as recorded or observed in the production environment is being replayed. Many mechanisms may provide non deterministic input to the virtual machine application program . For example some known sources of non determinism include execution of native methods garbage collection class loading linking and initialization just in time compilation JIT and thread context switching.

In one embodiment recording execution of the virtual machine application program involves record and replay system programmatically capturing and storing information identifying all sources of non determinism that may affect the program . Replay stream information is stored in persistent storage and identifies non deterministic events and data. Test personnel can attach the stored replay stream information for a portion of a program that contains a bug results to a bug report and send the bug report to a developer. Execution of the virtual machine application program is replayed by record and replay system by running the program and substituting information from the stored replay stream for all non deterministic events that are associated with a recorded execution. This replay step can be performed by a developer who has received a bug report that contains an attached replay stream recording. Replaying enables the developer to immediately reproduce the bug by replaying the recorded replay stream. A non limiting example of a commercially available record and replay system capable of recording and replaying a virtual machine application program is the Replay DIRECTOR available from Replay Solutions Inc. of Redwood City Calif.

As shown inside the virtual machine application of multiple threads may execute within the virtual machine application . The implementation and scheduling of the threads depends on a variety of factors including the thread scheduling strategy of the underlying operating system and the processing environment in which the operating system executes e.g. single processor or multi processor multi core environment . The operating system may achieve concurrency by allowing a thread of the virtual machine application to execute for a small period of time time slice before switching to another thread after the currently executing thread s time slice has expired. The virtual machine may co operate with the operating system to determine when switching of threads occurs. Alternatively the virtual machine may delegate the scheduling of thread switching entirely to the operating system . Relative to the virtual machine application the time at which a processor is switched from executing one thread to executing another thread is not readily predictable so that the order of operations performed by the multiple threads may vary and therefore the path of execution in code of the virtual machine application may vary among execution sessions. Because of this non deterministic thread context switching the path of execution in code by threads of a multi thread virtual machine application program may vary among execution sessions. Thus there is no inherent guarantee that a race condition that occurred in one execution session will also occur in another execution session. In context of record and replay systems because of this non deterministic thread context switching there is no inherent guarantee that a race condition that occurred during a recoding session will also occur in a subsequent replay session.

In an embodiment thread management techniques are provided to ensure that thread context switches are deterministic in a virtual machine application during both record and replay execution of the application. The techniques do not require modifications to source code virtual machine internals or operating system internals or require deployment of a new version of the virtual machine application program through a software development process. The techniques guarantee that any race any and all race conditions that occur as a result of threads executing application code are accurately reproduced when the virtual machine application program execution is replayed. By virtue of ensuring that thread context switches are deterministic in both record and replay execution difficult to isolate race conditions that occur in the production environment can be accurately and repeatedly reproduced in the debugging environment.

In one approach for ensuring thread context switches are deterministic termed a serialized approach an application level mutex is used to ensure that only one thread executes application code at a time. A developer of a virtual machine application can still write the application program as a multi threaded application but during recorded and replayed execution the virtual machine runs in a serialized mode in which only one thread executes application bytecode at a time.

In the serialized mode during both recording and replaying of a virtual machine application each thread of the virtual machine application must acquire the application level mutex before executing any application code of the virtual machine application. During recording of the virtual machine application a record is maintained that records the order in which threads of the virtual machine application acquire the application level mutex. During replay of the virtual machine application acquisition of the application level mutex by the threads is managed to ensure that threads acquire the application level mutex in the same order as indicated by the record. During both record and replay releasing of the application level mutex by threads is managed to ensure that threads release the application level mutex at the same deterministic points in execution. By virtue of such management thread context switches in the virtual machine application when recorded and when replayed are deterministic. In particular the order in which application code is executed by threads during replay execution is the same as the order in which the application code was executed during recorded execution. As such any race conditions that occur during record as a result of threads executing application code are reproduced during replay. In addition as described in greater detail below acquiring and releasing of the application level mutex by threads is managed during both record and replay execution to prevent threads from deadlocking.

In one embodiment process starts in the context of a virtual machine initiating execution of a virtual machine application. In this context the virtual machine allocates data structures and resources for executing the virtual machine application including creation of an initial or main thread of execution and transfers execution control of the main thread to the virtual machine application through a pre defined entry point such as for example main . Once control is transferred to the virtual machine application multiple new threads may be created by the virtual machine application.

At step a single application level mutex is created for the virtual machine application. In one embodiment the application level mutex is created before the virtual machine transfers control of the main thread of execution to the virtual machine application and before the main thread of execution begins to execute application bytecode of the virtual machine application. Creation of the application level mutex can occur through instrumentation of the virtual machine application or by handling an execution event in a profiler agent such as the profiler agent of . The application level mutex may be any synchronization primitive suitable for ensuring mutual exclusion amongst threads of the virtual machine application. In one embodiment the application level mutex is a native synchronization primitive. For example in one embodiment in which the underlying operating system is a Microsoft Windows based operating system the application level mutex is a CRITICAL SECTION object.

Steps through may be performed for each thread of the virtual machine application during both recorded and replayed execution.

At step a thread of the virtual machine application starts execution of application code. Before the thread executes any application code of the virtual machine application the thread is forced to acquire the application level mutex. While the thread holds the application level mutex all others threads are forced to wait to acquire the application level mutex before executing any application code. Thus by virtue of the application level mutex only one thread can execute application code at a time. In one embodiment a profiler agent receives a thread start event from the virtual machine when a thread is started thereby providing the profiler agent an opportunity to force the thread to acquire the application level mutex before the thread begins executing application bytecode. Once the thread has acquired the application level mutex the thread executes application code at step . If at step another thread of the virtual machine application currently owns the application level mutex then execution of application code by the thread attempting to acquire the application level mutex is blocked until the other thread releases the application level mutex.

At step an attempt by the thread to make a potentially blocking call is intercepted or detected and at step the thread is forced to release the application level mutex prior to the thread making the potentially blocking call at step .

At step the thread is forced to reacquire the application level mutex after the potentially blocking call completes and before the thread continues to execute application code at step . If another thread currently holds the application level mutex when the thread completes the potentially blocking call then the thread attempting to re acquire the application level mutex is forced to wait until the other thread releases the application level mutex.

In one embodiment the profiler agent receives an event from the virtual machine notifying that a thread is about to make a potentially blocking call giving the profiler agent an opportunity to force the thread to release the application level mutex. Similarly the profiler agent may receive an event from the virtual machine when the thread has completed the potentially blocking call providing the profiler agent an opportunity to force the thread to re acquire the application level mutex before the thread continues to execute application code.

In one embodiment instrumented code added to the virtual machine application when executed detects when a thread is about to make a potentially blocking call and causes the thread to release the application level mutex prior to the thread making the potentially blocking call. Similarly the instrumented code when executed detects when the thread has completed the potentially blocking call and causes the thread to re acquire the application level mutex before the thread continues to execute application code.

In one embodiment each thread of the virtual machine application is forced to release the application level mutex prior to making selected potentially blocking calls. Which potentially blocking calls are selected depends on a variety of factors. However in general the selected calls may include synchronous input output calls to the operating system hosting the virtual machine such as calls to perform network input output file input output calls to obtain user or programmatic input timer queries asynchronous system callbacks etc. Thus in some embodiments threads do not release the application level mutex before every potentially blocking call. Instead the threads release the application level mutex only before selected potentially blocking calls.

In one embodiment each executing thread of the virtual machine application is forced to release the application level mutex prior to invoking any native call. Native calls include calls specific to the underlying operating environment and operating system in which the virtual machine is executing. For example in an embodiment in which the virtual machine is a Java Virtual Machine each thread executing in the virtual machine application is forced to release the application level mutex prior to invoking any call through the Java Native Interface JNI . The Java Native Interface is a standard Java application programming interface that allows Java programming code of a virtual machine application to integrate with programming code of other programming languages specific to the underlying operating environment and or operating system such as the C C programming language.

At step the thread is about to exit or is exiting. In such case the thread is forced to release the application level mutex at step . In one embodiment a profiler agent receives a thread end event from the virtual machine when a thread is about to exit thereby providing the profiler agent an opportunity to force the thread to release the application level mutex. Once the existing thread releases the application level mutex at step the thread is allowed to exit at step .

In one embodiment the serialized approach of is performed to ensure that the order in which application bytecode of the virtual machine application is executed by threads of the application is deterministic such that any and all race conditions that occur during a recorded execution of the virtual machine application program as a result of threads executing application code are reproduced during a replay execution of the virtual machine application. During the recorded execution a thread context switch record is maintained in a computer that tracks the order in which threads of the virtual machine application program acquire the application level mutex. Such thread context switch record may be maintained as part of or in conjunction with the replay stream information for recording non deterministic input data to the virtual machine application. When a thread acquires the application level mutex at step or step the thread context switch record is updated to reflect the order in which the thread acquired the application level mutex. For example the thread context switch record may comprise an ordered listing of thread identifiers. During the replayed execution the thread context switch record is consulted to ensure that threads of the replayed virtual machine application program acquire the application level mutex in the same order as during the record execution. Specifically during a replay execution before a thread is allowed to acquire the application level mutex at step or step a check of the thread context switch record is made to determine if the thread is next in order. If the thread is next in order according to the thread context switch record then the thread is allowed to acquire the application level mutex and execute application bytecode at step or step .

In one embodiment the thread context switch record does not indicate the order in which threads released the application level mutex during a corresponding recorded execution. Instead during both record and replay execution threads are forced to release the application level mutex at the same deterministic points in execution of the virtual machine application. These deterministic releasing points are pre defined to the record and replay system such as for example before all native calls and before all calls to exit a thread. The serialized approach includes forcing threads to release the application level mutex at the same deterministic points during both recorded and replay execution and includes forcing threads to acquire the application level mutex during replay execution in the same order as indicated in the thread context switch record. By virtue of theses aspects of the serialized approached threads will also release the application level mutex during replay execution in the same order that the threads released the application level mutex during recorded execution. Thus in one embodiment recording the order in which threads release the application level mutex in the thread context switching is not necessary.

Generally a deadlock can occur amongst a set of threads when each thread is waiting for another thread in the set to release a shared resource such as a shared mutex. In this description a shared mutex refers to any mutex other than the application level mutex that is shared amongst one or more threads of the virtual machine application and that is acquired and by threads of the virtual machine application. For example consider the following sequence of execution events 

When Thread attempts to acquire mutex X a deadlock occurs. In particular Thread cannot acquire mutex X until Thread releases mutex X yet Thread cannot release mutex X until Thread releases the application level mutex. Thread and thread are blocked indefinitely each waiting for an event that will never occur.

In one embodiment of process to prevent the application level mutex from causing a deadlock each thread of the virtual machine application is caused to release the application level mutex prior to acquiring a shared mutex. The application level mutex is re acquired once the thread acquires the shared mutex.

In some circumstances it is impracticable or undesirable to ensure that the thread currently holding the application level mutex releases the application level mutex before every attempt to acquire a shared mutex. For example at the time the thread currently holding the application level mutex attempts to acquire a shared mutex if no other thread currently holds the shared mutex then the thread attempting to acquire the shared mutex does not need to release the application level mutex in order to acquire the shared mutex. This is because no other thread can acquire the shared mutex while the thread attempting to acquire the shared mutex holds the application level mutex. When no thread holds a shared mutex at the time a thread attempts to acquire the shared mutex then acquisition of the shared mutex by the thread is said to be not contended. In such a case it is inefficient for a thread holding the application level mutex to release the application level mutex before acquiring the shared mutex.

In one embodiment the virtual machine provides two types of events to a profiler agent through an API such as profiler API of . First when a thread of the virtual machine application attempts to acquire a shared mutex which is currently held by another thread the virtual machine generates what is termed herein as a mutex contended acquire event and sends the event to the profiler agent. Second when a thread of the virtual machine application acquires a shared mutex for which it was contending with another thread the virtual machine generates what is termed a mutex contended acquired event and sends the event to the profiler agent. The actual terminology for these types of events may vary depending on the particular type of virtual machine. For example in an embodiment where the virtual machine is a Java Virtual Machine these two types of events are termed Monitor Contended Enter and Monitor Contended Entered respectively.

Process of starts in the context of a running thread currently holding the application level mutex as in steps or of process .

At step the profiler agent receives either a Mutex Contended Acquire event or a Mutex Contended Acquired event. Assume for the purpose of explanation that a running thread Thread A currently holding the application level mutex attempts to acquire a shared mutex Shared Mutex X which is currently held by another thread Thread B . Upon such attempt a Mutex Contended Acquire event is sent to the profiler agent. In one embodiment information associated with the Mutex Contended Acquire and Mutex Contended Acquired events sent to the profiler agent indicates the thread e.g. Thread A and in the case of a Mutex Contended Acquire event the shared mutex the thread is attempting to acquire or in the case of a Mutex Contended Acquired event the shared mutex the thread acquired.

At step the profiler agent having received a Mutex Contended Acquire event causes Thread A to release the application level mutex. This allows Thread B to acquire the application level mutex execute application code and ultimately release Shared Mutex X. At step Thread A waits until Shared Mutex X can be acquired which cannot occur until Thread B releases Mutex X.

At step Thread A acquires Shared Mutex X after which the profiler agent receives a Mutex Contended Acquired event at step notifying the profiler agent that Thread A has acquired a shared mutex for which it was contending. At step having received a Mutex Contended Acquired event for Thread A and Shared Mutex X the profiler agent causes Thread A to re acquire the application level mutex. At step Thread A continues executing application code.

In most circumstances because the serialized approach requires that threads hold the application level mutex while executing application code a thread will not acquire a shared mutex without holding the application level mutex. Thus in most circumstances acquisition of a shared mutex during replay execution is deterministic and occurs at the same point in execution of the virtual machine application in both a recoded execution and the replay execution from the recording. When a thread acquires a shared mutex while holding the application level mutex the acquisition of the shared mutex by the thread can be said to be a deterministic mutex acquisition . In some circumstances however some potentially blocking calls made by a thread when the thread does not hold the application level mutex cause the thread to attempt to acquire a shared mutex. An example of such a potentially blocking call is provided below. When a thread acquires a shared mutex while not holding the application level mutex the acquisition of the mutex by the thread can be said to be a non deterministic mutex acquisition . The acquisition of the shared mutex in this case is non deterministic because whether the thread contends for the shared mutex with another thread and thus whether Mutex Contended Acquire and Mutex Contended Acquired events are generated by the virtual machine depends on non deterministic factors such as the scheduling and context switching of the contending threads by the underlying operating system. Consequently there is a period of time between a deterministic thread context switch i.e. a period of between when one thread releases the application level mutex and another thread acquires the application level mutex when a thread may make a non deterministic mutex acquisition. Such a non deterministic mutex acquisition can cause the presence of Mutex Contended Acquire and Mutex Contended Acquired events to be different between recorded and replayed executions. To see this consider the following example execution sequence of a multi thread virtual machine application. In the following example to aide in understanding the example reference is made to the Java programming language and Java thread synchronization constructs. However it should be understood that the principles illustrated by the examples are generally applicable to virtually any multi threaded programming language suitable for developing a virtual machine application.

At time t Thread is executing application bytecode while holding application level mutex as in step or step of process .

At time t Thread enters the Java monitor of Object O while holding the application level mutex. As background Java employs a thread synchronization primitive known as a Java monitor for enforcing mutual exclusion. Thus a Java monitor is one type of mutex. Every object in Java has a Java monitor which only one thread can enter at a time. To enforce mutually exclusive access to state of an object a thread can be forced to enter the object s Java monitor before accessing the object s state and forced to exit the object s Java monitor when the thread is finished accessing the object s state. While a thread has entered a Java monitor no other thread may enter the Java monitor. In this description when referring generally to thread mutual exclusion mechanisms the terms mutex acquiring a mutex and releasing a mutex are used. In the context of Java that uses Java monitors for enforcing mutual exclusion reference to a Java monitor entering a Java monitor and exiting a Java monitor should be understood as specific examples of a mutex acquiring a mutex and releasing a mutex respectively.

Continuing the example at time t Thread is about to make a potentially blocking call as in step of process . In particular in this example Thread is about to call wait on Object O. As more background every object in Java provides a method wait . The semantics of wait are such that if the thread calling wait on an object has currently entered that object s Java monitor then the thread is forced to exit the object s Java monitor and wait until another thread calls notify on the object. When another thread calls notify on the object the thread returns from waiting and re enters the object s Java monitor.

Continuing the example at time t before Thread calls wait on Object O Thread is forced to release application level mutex as in step of process . After the application level mutex is released by Thread another thread can acquire the application level mutex and potentially attempt to enter the Object O s Java monitor. If because of non deterministic thread context switching another thread Thread acquires the application level mutex executes application code and attempts to enter Object O s monitor before Thread exits Object O s monitor as a result of calling wait on Object O then the virtual machine will generate a Monitor Contended Acquire event as in step of process for Thread because Thread is contending for Object O s Java monitor with Thread which has not yet exited Object O s Java monitor . On the other hand if Thread calls wait on Object O and as a result exits Object O s Java monitor before a thread context switch to Thread then upon Thread attempting to enter Object O s Java monitor the virtual machine will not generate a Monitor Contended Acquire event for Thread . Thus as illustrated by this example causing a thread to release the application level mutex prior to the thread making some potentially blocking calls can create a window of time in which multiple threads race to contend for a mutex and determining the order in which the contention is resolved is not readily predictable because of the non deterministic nature of thread context switching.

This type of race condition can be problematic when replaying a virtual machine application. For example this type of race condition can cause the replay stream to be out of sync on replay. The term out of sync as used herein refers to encountering sources of non determinism during replay execution of the virtual machine application in the debugging environment differently than they were recorded in the replay stream during the recorded execution of the virtual machine application in the production environment. For example returning again to the example above assume during a recorded execution of the virtual machine application in a production environment that information is recorded in a replay stream based on Thread contending with Thread for Object O s Java monitor. If on replay of the virtual machine Application in a debugging environment because of the non deterministic nature of thread context switching Thread exits Object O s monitor before Thread attempts to enter Object O s Java monitor then Thread will not contend for Object O s Java monitor as it did during record. Because of this the replay stream will be out of sync. In particular a source of non determinism encountered by the virtual machine application on replay may be provided information from the replay stream recorded about the contention between Threads and that occurred during recording in the production environment but did not occur on replay in the debugging environment.

The general approach of process may be summarized as follows. When a thread e.g Thread A of the virtual machine application acquires a mutex the record and replay system creates and stores an entry in a mutex acquisition record indicating whether the thread acquired the mutex while holding the application level mutex i.e. a deterministic mutex acquisition or whether the thread acquired the mutex while not holding the application level mutex i.e. a non deterministic mutex acquisition . The mutex acquisition record may be maintained by a record and replay system in conjunction with the thread context switch record and the replay stream.

When another thread e.g. Thread B attempts to acquire a mutex other than the application level mutex that is currently held by a thread e.g. Thread A the record and replay system examines the mutex acquisition record to determine whether the acquisition of the mutex by the thread currently holding the mutex Thread A was a deterministic mutex acquisition or a non deterministic mutex acquisition. If the acquisition was a deterministic mutex acquisition then the contending thread Thread B releases the application level mutex allowing the thread currently holding the mutex Thread A to acquire the application level mutex and ultimately release the mutex that the contending thread Thread B is attempting to acquire. On the other hand if the acquisition was a non deterministic mutex contention then the contending thread Thread B retains the application level mutex and waits for the thread currently holding the mutex Thread A to release the mutex that the contending thread Thread B is attempting to acquire. By forcing the thread contending for the mutex Thread B to retain the application level mutex in a situation where there has been a non deterministic mutex acquisition the thread that acquired the mutex non deterministically Thread A is forced to release the mutex before that thread Thread A acquires the application level mutex and proceeds to execute application bytecode thereby ensuring that threads of the virtual machine application can be forced to execute application bytecode in the same order across multiple executions.

The steps of process will now be explained in greater detail. At step a thread Thread A acquires a mutex Mutex X other than the application level mutex. As mentioned a thread may acquire a mutex deterministically i.e. while holding the application level mutex or non deterministically i.e. while not holding the application level mutex . As explained above some potentially blocking calls e.g. wait on Java object may cause a thread to acquire a mutex non deterministically.

At step the record and replay system determines whether the thread Thread A acquired the mutex Mutex X deterministically i.e. while holding the application level mutex or non deterministically i.e. while not holding the application level mutex . In one embodiment such determination is made through instrumented code added to the virtual machine application. In another embodiment such determination is performed by a profiler agent upon receiving an execution event from the virtual machine. The determination may involve instrumented code or the profiler agent invoking APIs provided by the virtual machine to determine whether the thread Thread A acquired the mutex Mutex X deterministically or non deterministically.

At step if the determination in step revealed that the thread Thread A acquired the mutex Mutex X deterministically then the record and replay system adds an entry to the mutex acquisition record that indicates for a particular point in a recorded or replayed execution sequence of the virtual machine application corresponding to the acquisition of the mutex Mutex X by the thread Thread A that the thread Thread A acquired the mutex Mutex X at the particular point in the execution sequence while holding the application level mutex i.e. acquired the mutex Mutex X deterministically . At step if on the other hand the determination at step revealed that the thread Thread A acquired the mutex Mutex X non deterministically then the record and replay system adds an entry to the mutex acquisition record that indicates for the particular point in the execution sequence that the thread Thread A acquired the mutex Mutex X while not holding the application level mutex i.e. acquired the mutex Mutex non deterministically .

At step the virtual machine generates a Mutex Contended Acquire event in response to an attempt by another thread Thread B to acquire the mutex Mutex X . In response to the event the record and replay system consults the mutex acquisition record to determine whether the mutex Mutex X was acquired deterministically or non deterministically If the mutex acquisition record indicates that the mutex Mutex X was acquired deterministically then at step the contending thread Thread B is forced to release the application level mutex. On the other hand if the mutex acquisition record indicates that the mutex Mutex X was acquired non deterministically then at step the contending thread Thread B retains the application level mutex until the contending thread Thread B can acquire the mutex Mutex X .

According to one embodiment the techniques described herein are implemented by one or more special purpose computing devices. The special purpose computing devices may be hard wired to perform the techniques or may include digital electronic devices such as one or more application specific integrated circuits ASICs or field programmable gate arrays FPGAs that are persistently programmed to perform the techniques or may include one or more general purpose hardware processors programmed to perform the techniques pursuant to program instructions in firmware memory other storage or a combination. Such special purpose computing devices may also combine custom hard wired logic ASICs or FPGAs with custom programming to accomplish the techniques. The special purpose computing devices may be server computer systems desktop computer systems portable computer systems handheld devices networking devices or any other device that incorporates hard wired and or program logic to implement the techniques.

For example is a block diagram that illustrates a computer system upon which an embodiment of the invention may be implemented. Computer system includes a bus or other communication mechanism for communicating information and a hardware processor coupled with bus for processing information. Hardware processor may be for example a general purpose microprocessor.

Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Such instructions when stored in non transitory media or storage media accessible to processor render computer system into a special purpose machine that is customized to perform the operations specified in the instructions.

Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk or optical disk is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

Computer system may implement the techniques described herein using customized hard wired logic one or more ASICs or FPGAs firmware and or program logic which in combination with the computer system causes or programs computer system to be a special purpose machine. According to one embodiment the techniques herein are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another storage medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions.

The terms non transitory media and storage media as used herein refer to any media that store data and or instructions that cause a machine to operate in a specific fashion. Such media may comprise non volatile media and or volatile media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Common forms of non transitory media and storage media include for example a floppy disk a flexible disk hard disk solid state drive magnetic tape or any other magnetic data storage medium a CD ROM any other optical data storage medium any physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM NVRAM any other memory chip or cartridge.

Non transitory media and storage media are distinct from but may be used in conjunction with transmission media. Transmission media participates in transferring information between non transitory media and storage media. For example transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications.

Various forms of media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk or solid state drive of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card cable modem satellite modem or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are example forms of transmission media.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution.

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

