---

title: Method and system of operating system independence
abstract: A method and system of operating system independent cloud computing is provided. In one embodiment, a method of a client device includes accessing a first application through a first application template. The first application template resides on a server. The method also includes accessing the first application based on a response to a request of a user interface of the client device. Furthermore, the method includes processing the first application through a processor such that the first application accesses the first application template such that the client device permits an access of the first application through the first application template. The method also includes executing the first application through the first application template such that an execution of the first application through the first application template emulates the execution of the first application installed on an operating system of the client device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08346854&OS=08346854&RS=08346854
owner: Deskstream, Inc.
number: 08346854
owner_city: Sunnyvale
owner_country: US
publication_date: 20100630
---
This disclosure relates generally to a technical field of cloud computing and in one example embodiment to method and system of operating system independence.

A Software application may be installed on an operating system of a client device. The software application may be installed such that additional files are added to the operating system and or files of the operating system are modified. As a result the software application may be tied to the operating system of the client device.

The software application may need to be modified and or updated. Each copy of the software application may be on different client devices. Modifying and or updating the software application may require an administrator to install a patch through each client device and or through a central server. It may be time consuming to install each application on each client device of the enterprise. The installation of security patch and or other update through a central server may be time consuming because the installation may require the time of the administrator to troubleshoot the update and or software application. Provisioning a client device of a new user and or restoring the client device of an existing user may be time consuming because the software application and or update may need to be installed on the client device. As a result time and or other resources of the administrator may be wasted causing a negative impact on business productivity.

In one aspect a method of a client device includes accessing a first application through a first application template. The first application template resides on a server device. The method also includes accessing the first application of a user interface of the client device based on a response to a request. In addition the method also includes processing the first application such that the first application accesses the first application template such that the client device permits an access of the first application through the first application template through a processor.

The method includes executing the first application through the first application template such that an execution of the first application through the first application template emulates the execution of the first application installed on an operating system of the client device. The method includes executing a function of the first application template based on a demand of a user through the response to the request of the user such that a file is accessed when required of the first application.

The method further includes accessing a first file of the user and a second file of the user through the first application. The first file is of a type of the first application and the second file is of the type of a second application. In addition the method includes translating between the first application template and the operating system of the client device based on the type of the operating system such that the first application is accessible to a user of the client device. The method also includes translating between the second application template and the operating system of the client device based on the type of the operating system such that the second application is accessible to the user of the client device.

The first application template may include one or more of an executable a library an image a configuration file and a registry key such that the first application through the first application template may be accessible to the client device and another client through the first application template. The first application template of the client device and the first application template of another client device may be the same. The operating system of the client device and another operating system of another client device may be different such that the first application may be accessible to the client device and the another client device through the first application template.

The method further may include accessing the first application template through a software as a service model through a cloud environment such that the first application may be accessible through the first application template. The user of the client device and another user of another client device may access the first application through the first application template. The first application template of the user and the first application template of another user may be the same.

Furthermore the method may include creating the application template through the user interface of an administrator of the client device. The method may also include creating the first application template such that the first application template may be coupled to one of a registry structure and a directory structure such that the first application may be accessible to the user of the client device.

The method may further include converting a first installation program to the first application template. The first installation program may include a file a registry key and a registry value to install the first application to the client device. The method may also include creating the first application template based on a conversion of the first installation program through an installation of the first installation program such that the client device may access the first application through the first application template.

In addition the method may include creating the second application template such that the second application template may be coupled to one of the registry structure and the directory structure such that the second application may be accessible to the user of the client device. The first application template and the second application template share the registry structure and the directory structure.

In addition the method may include creating a file system comprising a layer. The layer may manage the first file of the user such that the first file may be accessible through the first application. The method may also include a setting of the user such that a setting may be customizable through a response of the request of the user such that the setting may be accessible to the user when the first application may be accessed.

The method may further include creating the file system comprising another layer. The another layer may manage another first file of the first application template such that the another first file may be accessible through the first application and the first application template may include the another first file. The method may also include creating the file system comprising yet another layer. The yet another layer may manage a host file. The host file may be the file of the operating system of the client device such that the host file may be accessible through the first application.

Furthermore the method may include marking the another first file of the first application template as deleted based on the response to the request of the user through the user interface of the client device such that the another first file may remain a component of the first application template. The method may also include denying the access to another first file of the first application template through the first application based on a deleted marking. The method of client device may be in a form of a machine readable medium embodying a set of instructions that when executed by a machine may cause the machine to perform the method accordingly.

In another aspect a method of a server device includes permitting an access of a first application through a first application template. The first application template resides on a server. The method may also include permitting the access of a second application through a second application template. The second application template may reside on the server. The method of a server device also includes processing a request based on the request of a user interface of a client device to access one of the first application and the second application through a processor. The first application and the second application may be accessible through the user interface.

In addition the method of the server device includes accessing the first application template and or the second application template based on the request of the user interface of the client device. The method also includes determining a translation file based on a type of an operating system of the client device such that the application may be accessible to a user of the client device.

The first application template may include one of an executable a library an image a configuration file and a registry key such that the first application through the first application template may be accessible to the client device and another client through the first application template. The first application template of the client device and the first application template of another client device may be the same.

The operating system of the client device and another operating system of the another client device may be different such that the first application may be accessible to the client device and the another client device through the first application template. The method may also include permitting the access of a first file of the user and a second file of the user through the first application. The first file may be of the type of the first application and the second file may be of the type of the second application.

Furthermore the method may include permitting the access of the first application template through a software as a service model through a cloud environment such that the first application may be accessible through the first application template. The user of the client device and another user of another client device may access the first application through the first application template. The first application template of the user and the first application template of the another user may be the same.

In addition the method may include permitting the access of the first application and the second application through a binary module coupled to the first application template and the second application template. The binary module may emulate a set of a function call between the first application and the operating system of the client device and the function call between the second application and the operating system of the client device.

In yet another aspect a system includes a server to permit an access of a first application based on a response to a request of a user interface. The system also includes a client device to process the first application through a processor such that the first application is accessible to a user based on the response to the request of the user interface. In addition the system includes a first application template to emulate a function of the first application.

The first application template includes one of an executable a library an image a configuration file and a registry key such that the access of the first application through the first application template is accessible to the client device and another client device through the first application template. The first application template of the client device and the first application template of the another client device are the same.

The system may further include a file system to organize a file such that the file of a second application template may be accessible to the user of the client device through the first application. The first application and a second application may be accessible to the user of the client device. The second application template may include the file of the second application.

In addition the system may also include a translation module to permit the access of the first application through an operating system of the client device such that the first application may be accessible to another operating system of the another client device. The operating system of the client device and another operating system of the another client device may be different.

The methods systems and apparatuses disclosed herein may be implemented in any means for achieving various aspects and may be executed in a form of a machine readable medium embodying a set of instructions that when executed by a machine causes the machine to perform any of the operations disclosed herein. Other features will be apparent from the accompanying drawings and from the detailed description that follows.

Other features of the present embodiments will be apparent from the accompanying drawings and from the detailed description that follows.

A method apparatus and or system of operating system independent cloud computing are disclosed. Although the present embodiments have been described with reference to specific example embodiments it will be evident that various modifications and changes may be made to these embodiments without departing from the broader spirit and scope of the various embodiments.

The server device may include an application template to emulate a function of the application . In one or more embodiments a virtual container may be created for the client device to virtualize the client device . The virtual container may be operatively coupled with the server device and the client device . In one or more embodiments the virtual container may be created through inheritance. Inheritance may include copying of folder structures of the client device to a new location on the server device . The folder structure may be used to create a base template and information associated with the base template may be saved in a storage e.g. a relational database on the server device .

The application template may include but is not limited to an executable a library an image a configuration file and a registry key. The access to the application may be allowed through the application template . In one or more embodiments multiple client devices may be allowed to access one or more applications through one or more application templates in the server device . The client devices may be allowed to use a common application template to access the applications through the common application template. The application may include one or more components including a set of DLLs a set of configuration files and a set of executable files. The system disclosed herein virtualizes one or more resources including the components and operating system resources to access the application through the client device and provides the virtualized resources on demand to the user of the client device .

In one or more embodiments a virtual container may run multiple versions of the application . The virtual container may run different applications through different application templates. For instance consider that the administrator of the client device tries to install a gaming application into the client device . The files registry and data associated with the installation and execution of the gaming application may be transferred to an application template created by an administrator for the gaming application on the server device . When the administrator initiates the installation the gaming application may get installed in the server device and whenever the user tries to execute the gaming application the gaming application may run in the virtual container using a host operating system associated with the application template on the server device. The user accesses the gaming application running in the virtual container through the client device . Similarly for example a Windows Powerpoint application can be run on Linux operating system through the virtual container.

When a user logs on he may access to the virtual desktop assigned by the administrator to the user. When the user installs an application the application may be installed on the virtual desktop of the user. Access to the virtual desktop of the user may be limited to the user.

When an administrator logs on the administrator may install into an application template and or a user virtual desktop. When the administrator installs an application into a template the application may be automatically available to all users connected to the application template. When the administrator installs into a user virtual desktop access to the virtual desktop may be limited to the user.

In one or more embodiments the system may also include a file system. The file system may allow organization of one or more files such that a file associated with a second application template of a second application is accessible to the user of the client device through a first application. The first application and the second application may be accessible to the user of the client device . In one or more embodiments the system may also include a translation module to permit the access of the first application through an operating system of the client device such that the first application is accessible to another operating system of the another client device. For example a Word file can be accessible to a user using an application in linux operating system. The operating system of the client device and another operating system of another client device may be different.

The client device may include a set of applications and or user data settings. To achieve operating system independency the desktop may be decoupled from the operating system of client device to be able to run it on any operating system of the client device . The desktop may include an application a data and a setting. The client device may be physical hardware. In one or more embodiments associating the virtual container with the client device may involve installation and or execution of an executable application supporting the virtual container in the client device . In one or more embodiments the user may run the executable application to access the virtual container.

In one or more embodiments the system disclosed herein gives the ability to run the user desktop of the client device from any other client devices and recover from a hardware operating system failure and similar disasters of the client device . The system may allow running a user desktop on an upgraded hardware OS instantly. In addition the user desktop of the client device can be rendered accessible over the network through one or more of a removable storage e.g. USB drive an external hard drive and or directly on another client device.

Further one or more registry and other files and data associated with the operating system may also be extracted into the virtual container. In one or more embodiments any application accessed executed through the client device may be decoupled from the operating system of the client device and may be executed through the virtual container on either a host operating system associated with a server device or on the operating system of the client device in accordance with the requirements of the application.

The storage layer may be an abstraction including information regarding components including for example a file storage e.g. a uniform naming convention UNC path name of a network drive and the like registry storage e.g. paths to reg.hives names of reg.keys mapped to the reg.hives and layer priority. The virtualization layer may be an abstraction including all virtualization components to virtualize one or more storage layers.

In one or more embodiments the virtual container may also include a virtual file module a virtual registry module and or a virtual service control module . The virtual file module may be configured to encapsulate native file system application programming interface calls for virtualization. The virtual registry module may be configured to encapsulate native registry application programming interface calls for virtualization. The virtual service control module may be configured to encapsulate native Windows service calls. Services may be Windows services that are running in the background of client device.

In one or more embodiments the virtual container may be configurable by a list of storage layers e.g. host layer template layer desktop layer . Each of the virtual file module virtual registry module and or virtual service control module may be software modules and may include one or more virtual engines e.g. functions . According to the list the virtual container creates a required number of virtual engine instances that will operate with pair of storages e.g. desktop template N template N 1 template N 2 . . . template1 host independently. In one or more embodiments the virtual engine may use table of content TOC trees to keep track of the files in various layers. The TOC may be a tree data structure representing in shared memory the content stored in the pristine storage.

The TOC provides search capability for a resource requested by the user of the client device in real time. In one or more embodiments the TOC also keeps track of deleted files from the template and host layers. If the user of the client device deletes any of the files in the layers though the files may not be physically removed from template host layers the files would not appear in the merged file system view for the user . Each virtual engine instance operates with one group of TOC trees. Each TOC group includes a virtual TOC a real TOC and a deleted TOC. The deleted TOC may store information associated with information in the layers marked as deleted.

In one or more embodiments the virtual container further includes a template module . The template module may be configured to manage one or more applications accessed through the client device . One or more administrators of the client device may group applications into one or more templates for ease of management. For example consider a marketing template containing applications for users in marketing department. The system disclosed herein enables for example an administrator to manage marketing applications once instead of managing at multiple client devices. One or more user defined templates may be inherited from one or more system defined root templates. In another embodiment a user defined template may be inherited from another user defined template.

The root templates may include registry directory structure specific to a host operating system. The client devices may be inherited from one or more user defined templates where the changes to templates are reflected in the client devices. The client devices represent a copy on write on the templates with the user specific changes. The template module also allows creation of one or more templates by the administrator of the client device. In one or more embodiments a new template may be created using one or more base templates in the root templates. The creation of the new template may involve a copy operation of the base template. Multiple versions e.g. application template of a given template may be created and stored. A folder of a given template may include all the versions of the template as sub folders. In one or more embodiments the virtual container may further include an operating system translation module .

The operating system translation module may be configured to provide mapping between virtual desktop operating system and the operating system of the client device in terms of registry files services and the like during run time. The operating system translation module may also be configured to dynamically link to the root template e.g. operating system root template containing necessary run time DLLs the executable registry and file structure based on the host operating system for the client device.

Also consider for example a set of applications including a word processing application having resources virtualized in the desktop layer and the template layer a database application having resources virtualized in the template layer and an operating system application having resources virtualized in the host layer. The word processing application may have a text.txt file virtualized in the desktop and template layers and also may have a x.txt file virtualized in the template layer. Similarly the database application may have a y.xls file virtualized in the template layer and the operating system application may have a z.txt file virtualized in the host layer of the VFS . All of the text.txt x.txt and z.txt may be organized in a common c directory within the VFS as illustrated in .

The c drive would be virtualization of a hardware drive of the client device containing the files associated with the word processing data base and operating system applications. In one or more embodiments the system allows various applications to access files within application templates of other applications running on same different operating systems the application templates residing in same different directory within the VFS . For example the database application may be allowed to access the test.txt file of the word processing application during execution of the database application in the virtual container .

In one embodiment the virtual container may run on the server device through terminal sessions such that multiple virtual containers are running on the server device . Each virtual container running on the server device may be associated with a client device . In another embodiment the virtual container may run on the client device .

In an example embodiment illustrates communication between the client device and the server device . The client device may request e.g. the requesting for an application from the server device . The server device responds the client device by virtualizing through a virtual container . In one or more embodiments the application installed on the server device may be accessed through the client device . The application e.g. client application software application etc. from the client device e.g. personal computer a laptop etc. may be executed without installing the application on the client device when requested by a user e.g. the user of of the client device through a binary module of the server device that may emulate a set of function calls between the application and the operating system of the client device . An application may run on the client device through a virtual container without installing the application on the client device which may mean that the operating system of the client device may not be modified to perform the function calls between the application and the operating system .

An application component may be downloaded to the client device when requested by a user e.g. the user of of the client device . The application component may be downloaded to a memory of the client device . The application component may be deleted from the memory e.g. hard disk RAM magnetic disk etc. of the client device when the application executing on the client device is inactive to prevent unauthorized duplication and or access of the application. The application may be directly executed from the virtual container through the binary module of the server device emulating a set of function calls between the application and the operating system of the client device without downloading the application to the client device e.g. workstation mobile device etc. . The virtual container may be software e.g. simulated computer that creates a virtualized environment that works with a host system e.g. for executing an application without installing the application in the host device even though it is independent of the host system e.g. client device .

In one or more embodiments look and feel of a desktop preference of the user may be recreated through the virtual container . The desktop preference may include an arrangement of files and or folders in a file system a color scheme of the file system a background of the file system an icon of the file system an access control preference of the file system a security preference of the file system a bookmark associated with the user a temporary file of the file system a configuration of applications associated with the user and a usability preference associated with the user. The desktop preference may be captured and stored to a user specific area of the server device when the desktop preference is in use on the client device .

In one or more embodiments the template module of the virtual container described in the description of may be used to combine different application templates of a user desktop. The administrator may log in to a user desktop and or an application template to install and or upgrade an application. In case of template a user desktops connected to the application template may automatically get the upgrade. In case of a user desktop the user assigned to the desktop may get the upgrade. The update may include a patch installation to the application and or an upgrade of the application. The binary module may include required resources between the application and the host operating system including a registry data a file system data and or a DLL data. The server device may have an application installed independent of any client side operating system through the binary module of the server.

The server device may execute the application directly from the virtual container through the binary module emulating a set of function calls between the application and the host operating system of the server device without downloading the application to the client device .

The desktop reconstruction module may reconstruct a look and feel desktop of the preference of the user. The delete module may delete the application component from the client device memory e.g. the client device when the application executing on the client device is inactive to prevent unauthorized duplication and or access of the application. The function analyzer module may communicate with the emulation module and the determination module .

The emulation module may communicate with the resources module the delete module the function analyzer module and the virtual container . The desktop reconstruction module may communicate with the function analyzer module and the virtual container . The desktop reconstruction module the function analyzer module and the emulation module may communicate with the virtual container . The binary module may communicate with the operating system of the client device .

The virtual container may include a virtual file system. In one or more embodiments the virtual file system may include one or more layers including for example a desktop file system layer a host file system layer and a template file system layer. The layers may have different access modes. The access modes may include a read only mode and or a writable mode. In one or more embodiments the .desktop layer may be accessed in the writable mode. The template layer and or the host layer may be accessed in read only mode. Each of the layers may include a file system and or a registry.

During run time of an application accessed through the client device the libraries required by the runtime are looked up from the desktop layer down to the host layer. The first match for a requested library is provided for the application. In one or more embodiments the virtual container may be configurable by a list of storage layers e.g. host template1 . . . N desktop . According to the list the virtual container may create required number of virtual engine instances that will operate with pair of storages e.g. desktop template N template N 1 template N 2 . . . template1 host independently. The virtual engine uses TOC tress to keep track of files in different layers. TOC is a tree data structure which represents in shared memory the content stored in the pristine storage. TOC provides the search capability for a requested resource as fast as possible. The TOC may also keep track of deleted files from template and host layers.

The applications may however be installed on the server device when the user initially tries to install the applications in the client devices . On providing appropriate application templates the applications may be executed on a virtual container of each of the client devices. A virtual container may be created for each of the client devices. In one or more embodiments different versions of the applications may be executed on different virtual containers for a given client device. The different virtual containers may include for example different components to support different operating system components e.g. windows components Linux components . On execution the various versions of a given application executed through different virtual containers may run on different host operating systems.

An example of a virtual index mapping algorithm for registry keys would include the steps including finding the root key entry in full TOC iterating sub entries of the root key in full TOC and filling the vector of pointers to the entries sorting vector with all sub entries by name iterating through the vector and filling the virtual indexes mapping table. An example of a pseudo code of mapping table filling algorithm logic for the registry keys is as follows 

In one or more embodiments for mapping registry values virtual indexes to real indexes on correspondent layer RT the one or more operations may be performed. The operations include finding the root entry for values in fullToc getting the TOC entry data value indexes struct from root entry iterating through the value indexes struct vectors starting from a highest layer e.g. desktop layer and filling virtual indexes mapping table. An example of a pseudo code of filling mapping table algorithm for the registry values is as follows 

Upon login an editable copy of the application template may be created in a new location. The administrator can then perform actions allowed in a typical user desktop including installation of any applications updates and patches e.g. patch . During updating the application template in one or more embodiments all file registry changes happening within a given session may be captured and stored within the template structure instance. Upon exit the administrator can choose a version for the new template created. The administrator can then choose to publish the new template version. The server device persists the new template version under the template root folder with administrator provided version number. Once published new client device instances would automatically inherit from the latest template version. In one or more embodiments the administrator may also have a save as option to give a different name to the template instead of creating a version with the existing template allowing the administrators to create a replica of the existing template instead of inheriting from the existing template. In the example scenario illustrated in the administrator updates the application template with the patch to create application including the patch .

Further in one or more embodiments a second application template may be created such that the second application template is coupled to the registry structure and or the directory structure such that the second application is accessible to the user of the client device. The first application template and the second application template may share the registry structure and or the directory structure.

In one or more embodiments in operation a first application is accessed through a first application template. Examples of the first application template may include but is not limited to an executable a library an image a configuration file and a registry key. The first application through the first application template may be accessible to the client device and another client device through the first application template. The operating system of the client device and another operating system of another client device may be different. The first application may be accessible to the client device and another client device through the first application template. In one or more embodiments the first application template of the client device and the first application template of another client device may be the same.

The first application template may reside on a server device. In one or more embodiments the first application template may be accessed through a software as a service model through a cloud environment such that the first application is accessible through the first application template. The user of the client device and another user of another client device access the first application through the first application template. In one or more embodiments in operation the first application may be accessed based on a response to a request of a user interface of the client device. In one or more embodiments in operation the first application may be processed through a processor such that the first application accesses the first application template such that the client device permits an access of the first application through the first application template. In one or more embodiments in operation the first application may be executed through the first application template such that an execution of the first application through the first application template emulates the execution of the first application installed on an operating system of the client device.

In one or more embodiments in operation a function of the first application template may be executed based on based on a demand of a user through the response to the request of the user such that a file is accessed when required of the first application. In one or more embodiments in operation a first file of the user and a second file of the user may be accessed through the first application wherein the first file is of a type of the first application and the second file is of the type of a second application. In one or more embodiments in operation the first application template may be translated to suite the operating system of the client device based on the type of the operating system such that the first application is accessible to a user of the client device. In one or more embodiments in operation the second application template may be translated to suite the operating system of the client device based on the type of the operating system such that the second application is accessible to the user of the client device.

In one or more embodiments a file system may be created such that the file system includes a layer to manage the first file of the user such that the first file is accessible through the first application and a setting of the user such that a setting is customizable through a response of the request of the user. The setting may be accessible to the user when the first application is accessed. In one or more embodiments the file system including another layer may be created such that another layer manages another first file of the first application template. Also another first file may be accessible through the first application and the first application template may include another first file.

In one or more embodiments the file system including yet another layer may be created such that yet another layer manages a host file. The host file may be the file of the operating system of the client device. The host file may be accessible through the first application. In one or more embodiments the another first file of the first application template may be marked as deleted based on the response to the request of the user through the user interface of the client device such that the another first file remains a component of the first application template. In one or more embodiments the access to the another first file of the first application template through the first application may be denied based on a deleted marking.

In one or more embodiments in operation the client may be permitted to access a second application through a second application template residing on the server. A request based on the request of a user interface of a client device to access the first application and or the second application may be processed through a processor coupled to the server device. The first application and or the second application may be accessible through the user interface.

In one or more embodiments in operation the first application template and or the second application template may be accessed based on the request of the user interface of the client device. In one or more embodiments the server device may permit the access of a first file of the user and or a second file of the user through the first application where the first file is of the type of the first application and the second file is of the type of the second application. In one or more embodiments in operation a translation file may be determined based on a type of an operating system of the client device such that the application is accessible to a user of the client device. The operating system of the client device and another operating system of the another client device may be different such that the first application is accessible to the client device and the another client device through the first application template.

In one or more embodiments the server device may permit the access of the first application template through a software as a service model through a cloud environment such that the first application is accessible through the first application template. The user of the client device and another user of another client device may access the first application through the first application template. The first application template of the user and the first application template of the another user may be same.

In one or more embodiments the server device may permit access of the first application and the second application through a binary module coupled to the first application template and the second application template. The binary module may emulate a set of a function call between the first application and the operating system of the client device and the function call between the second application and the operating system of the client device.

Although the present embodiments have been described with reference to specific example embodiments it will be evident that various modifications and changes may be made to these embodiments without departing from the broader spirit and scope of the various embodiments. For example the various devices modules analyzers generators etc. described herein may be enabled and operated using hardware circuitry e.g. CMOS based logic circuitry firmware software and or any combination of hardware firmware and or software e.g. embodied in a machine readable medium . For example the various electrical structure and methods may be embodied using transistors logic gates and electrical circuits e.g. application specific integrated ASIC circuitry and or in Digital Signal Processor DSP circuitry .

With the above embodiments in mind it should be understood that one or more embodiments of the invention may employ various computer implemented operations involving data stored in computer systems. These operations are those requiring physical manipulation of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. Further the manipulations performed are often referred to in terms such as producing identifying determining or comparing. Any of the operations described herein that form part of one or more embodiments of the invention are useful machine operations. One or more embodiments of the invention also relates to a device or an apparatus for performing these operations. The apparatus may be specially constructed for the required purposes such as the carrier network discussed above or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines may be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The programming modules and software subsystems described herein can be implemented using programming languages such as Flash JAVA C C C Visual Basic JavaScript PHP XML HTML etc. or a combination of programming languages. Commonly available protocols such as SOAP HTTP may be used in implementing interfaces between programming modules. As would be known to those skilled in the art the components and functionality described above and elsewhere herein may be implemented on any desktop operating system such as different versions of Microsoft Windows Apple Mac Unix X Windows Linux etc. executing in a virtualized or non virtualized environment using any programming language suitable for desktop software development.

The programming modules and ancillary software components including configuration file or files along with setup files required for providing the method and apparatus for troubleshooting subscribers on a telecommunications network and related functionality as described herein may be stored on a computer readable medium. Any computer medium such as a flash drive a CD ROM disk an optical disk a floppy disk a hard drive a shared drive and storage suitable for providing downloads from connected computers could be used for storing the programming modules and ancillary software components. It would be known to a person skilled in the art that any storage medium could be used for storing these software components so long as the storage medium can be read by a computer system.

One or more embodiments of the invention may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like. The invention may also be practiced in distributing computing environments where tasks are performed by remote processing devices that are linked through a network. One or more embodiments of the invention can also be embodied as computer readable code on a computer readable medium. The computer readable medium is any data storage device that can store data which can thereafter be read by a computer system. Examples of the computer readable medium include hard drives network attached storage NAS read only memory random access memory CD ROMs CD Rs CD RWs DVDs Flash magnetic tapes and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer systems so that the computer readable code is stored and executed in a distributed fashion.

While one or more embodiments of the present invention have been described it will be appreciated that those skilled in the art upon reading the specification and studying the drawings will realize various alterations additions permutations and equivalents thereof. It is therefore intended that embodiments of the present invention include all such alterations additions permutations and equivalents as fall within the true spirit and scope of the invention as defined in the following claims. Thus the scope of the invention should be defined by the claims including the full scope of equivalents thereof.

