---

title: Virtual environment for server applications, such as web applications
abstract: An application virtualization system enables server applications, such as web applications to be easily deployable, separates an application and its state from the system, and allows applications to be easily moved to another server. The application virtualization system provides a way to isolate conflicts and allow multiple applications that provide conflicting information to run independently and avoid conflicts. The application virtualization system receives notification of an application preparation session and monitors the session to collect configuration information that the application uses to run on a client. The application virtualization system stores the collected information until the application to be virtualized is deployed. When an administrator later deploys the application, the system retrieves the stored information and uses the information and information from the client to reconstitute the metadata and virtualize the application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08468542&OS=08468542&RS=08468542
owner: Microsoft Corporation
number: 08468542
owner_city: Redmond
owner_country: US
publication_date: 20100304
---
Virtualization refers to the execution of a virtual machine by physical hardware and then running operating systems and applications on the virtual machine. The virtual machine may represent a least common denominator of hardware functionality or may represent a well known configuration for which it is easy to prepare an operating system OS and applications. Many data centers use virtualization to be able to easily move a virtual machine to new physical hardware as resource requirements increase for maintenance cycles and to balance physical server loads. Virtualization is useful for many situations but can also impose limitations that occur due to many virtual machines contending for the same resources e.g. central processing unit CPU memory and network interface card NIC .

Application virtualization provides a virtual environment at the level of a single application isolating the application from the underlying OS similarly to the way a virtual machine isolates an OS from the underlying hardware. For example an operating system may natively run some applications while providing a virtual environment for running others. This may allow the operating system for example to run applications designed for a different operating system. Application virtualization blurs the distinction for the user between applications running natively in the host operating system and applications running in a virtual environment. For example both types of applications may appear side by side in a taskbar or menu provided by the operating system shell. MICROSOFT Application Virtualization App V for example transforms applications into centrally managed virtual services that are not installed and do not conflict with other applications. In a physical environment every application depends on its operating system OS for a range of services including memory allocation device drivers and much more. Incompatibility between an application and its OS can be addressed by either server virtualization or presentation virtualization but incompatibility between two applications installed on the same instance of an OS is solved by application virtualization.

Virtualizing server applications is typically more difficult than other applications. Unlike client applications that often are launched by a user from an operating system shell by running a dedicated executable server applications may include operating system services worker processes and daemons that run on demand or on some schedule. Administrators would like to virtualize server applications to make them as easy to deploy as copying a package or group of files to a computer system e.g. xcopy deployable . Server components such as MICROSOFT Internet Information Server IIS do not natively support application virtualization for applications that run using the component. Enterprises would like to virtualize server applications like IIS applications to be more dynamic they could take the application from machine to machine without reinstalling the application each time. This is productivity saving for enterprises as they can load balance or maintain their servers with much lower overhead. IIS has the concept of a web application e.g. a web site and these web applications run inside application pools. IIS specifies this application pool name when creating a worker process to respond to requests for the website. One problem is that there can be conflicts on application names. For example an administrator may want to virtualize several IIS applications on a single server where each application or application pool has the standard name Default. Doing this today causes a conflict so that only the first such web application will run correctly.

An application virtualization system is described herein that enables server applications such as web applications to be easily deployable separates an application and its state from the system and allows applications to be easily moved to another server. The application virtualization system provides a way to isolate conflicts such as web server application pool names and allow multiple applications that provide conflicting information to run independently and avoid conflicts. The application virtualization system receives notification of an application preparation session and monitors the session to collect configuration information that the application uses to run on a client. The application virtualization system stores the collected information until the application to be virtualized is deployed. When an administrator later deploys the application the system retrieves the stored information and uses the information and information from the client to reconstitute the metadata and virtualize the application. The application virtualization system extracts a request at packaging time and stores metadata about a web application such as a name of the application s application pool. Upon later deploying the web application the system consults the stored metadata to place the web application into the correct application pool associated with a virtual environment.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

An application virtualization system is described herein that enables server applications such as web applications to be easily deployable separates an application and its state from the system and allows applications to be easily moved to another server. The application virtualization system provides a way to isolate conflicts such as web server application pool names and allow multiple applications that provide conflicting information to run independently and avoid conflicts. Virtualizing an application generally involves three steps metadata extraction metadata storage and reconstitution and runtime management of requests. Metadata extraction is the process of knowing when an application is being prepared for virtualization and monitoring the application to extract configuration information. Configuration information can include any way in which an application ties itself to an operating system or other applications.

The application virtualization system receives notification of an application preparation session and monitors the session to collect configuration information that the application uses to run on a client. For example the system may take a snapshot of configuration information before and after installation of the application and store the differences as application metadata. The application virtualization system stores the collected information until the application to be virtualized is deployed. When an administrator later deploys the application the system retrieves the stored information and uses the information and information from the client to reconstitute the metadata and virtualize the application. For example for MICROSOFT IIS the system may capture an application pool name to which IIS assigns the application and store the application pool name as metadata about the application to use and potentially modify during deployment. Upon later deploying the web application the system consults the stored metadata to place the web application into the correct application pool associated with a virtual environment. Thus the application virtualization system allows multiple server applications to run virtualized side by side on the same physical computer hardware and operating system.

There are many different types of server applications such as NT services COM applications WMI providers SharePoint applications and web e.g. IIS applications. Each have their own challenges in virtualizing them. Web applications in particular present some specifies challenges addressed herein.

The first challenge is that a web server controls when the web application is started and the process that is created to run the web application is a natively installed executable. For NT services it is easy to determine whether or not the service should be virtualized based on its file path. If the file path is within virtual package A a virtualization layer can launch the NT service within the virtual environment for that package. If the path is within virtual package B the virtualization layer can launch the NT service within that virtual environment and so forth. If the path does not fall under any virtual package then the service is not virtualized. For a typical web server like MICROSOFT IIS the executable path is the same for all web sites or web applications hosted by the server namely the path to a worker process such as w3wp.exe for IIS. However the parameters to the worker process may differ such as including an application pool name. The application virtualization system modifies the virtualization layer to use this information to detect web applications to virtualize and to modify how such applications are virtualized. For example the system ensures that the application pool names do not overlap and maintains a map between application pool names and virtual packages. When the worker process is created the system looks up the application pool name in the map to determine if the worker process should be virtualized.

Another challenge involves how to virtualize web server virtual directories that do not have an application pool associated with them unlike web applications . The system solves this challenge by converting the virtual directory into a web application and associating an application pool with the web application.

Another challenge involves how to prevent configuration conflicts upon deploying web applications. Web configuration can be applied at different levels in IIS and other web servers. Configuration can be applied to the server to the web site and to web applications and virtual directories that descend from the web site in a hierarchy. Web application installers are free to configure the web server at any level. If the application virtualization system captured this configuration as is and deployed it at the same level the system could cause conflicts and potentially break locally installed or other virtual web applications. A solution to this problem is to capture the configuration changes made above the web application we care about and apply them at the web application level during deployment so not to affect other web applications on the system. These and other details are described further herein.

The major responsibilities of an application virtualization subsystem are monitoring visualization registration and runtime virtualization. Each of these is described separately herein.

Monitoring involves watching an installation process to detect changes made to a computer system. In some embodiments an application called the Sequencer is responsible for the monitoring phase of application virtualization. Some subsystems may hook application programming interfaces APIs to monitor the installation and others may compare snapshots of the computer system state before and after the installation to detect changes. An example of the former is a virtual services subsystem hooks the CreateService API to detect when new operating system services are added by an installer. The IIS subsystem described in the previous example on the other hand can gather the information it uses by comparing the IIS configuration before and after an install. For example the MICROSOFT tool MSDeploy allows users to run what if deployments tied to a specific web server. The same tool can be used with the application virtualization system to compare snapshots and generate a machine independent piece of metadata such as an extensible markup language filed e.g. sav providers.xml . At the end of monitoring the system removes any web server configuration that was set at the global level and applies the configuration to the individual web applications to help prevent conflicts during deployment. Additionally if top level web virtual directories were created during monitoring the system converts these into web applications associated with an application pool that will allow that virtual directory to be virtualized at deployment.

Visualization involves showing an administrator preparing an application for virtualization a visual indication of the changes made by an application. The Sequencer displays the changes detected during monitoring in a series of tabs. The application virtualization system may invoke subsystems for virtualization particular application types and each subsystem may provide a user interface for visualization that is appropriate for that subsystem. This eliminates the need for the Sequencer to have explicit knowledge of each subsystem during the visualization phase. The subsystems visualization interfaces are responsible for displaying their results in a window created for them by a visualization application of the application virtualization system.

Registration involves preparing a target computer system to run a virtual application. Although virtual applications are not installed on the client some information is published to the client to provide a seamless user experience e.g. so that the application shows up in the Start Menu or so that a web application is available in a web server metabase . The application virtualization system publishes information collected by the subsystem during monitoring to appropriate configuration locations on the client. For example virtual web applications have their application configuration and application pool information registered with the web server. Additionally part of the registration process involves associating the application pool name with a particular virtual application. When the web application is instantiated on a client the client will intercept the request to create a new web server worker process and if the worker process s application pool name matches one for a virtual application the worker process is created within the appropriate virtual environment.

Another responsibility of the subsystem closely related to registration is configuration. Registration is performed once however configuration can occur many times after the system registers its components. An example of registration is creating the web sites applications and application pools described herein. An example of a configuration item is a database connection string. This value may need to change after the application is registered if the backend database for the application is moved. The applicable subsystem is responsible for applying any subsystem specific configuration values such as configuration that requires specific knowledge of the subsystem to be applied e.g. may need to be set by calling a specific API .

Runtime virtualization refers to the hooking of functions and altering the functions behavior during runtime of a virtualized application so that the application can access its resources as if it is locally installed on the client. Runtime virtualization also refers to decision making of whether or not certain system processes i.e. processes not part of the virtual application s package should be virtualized. For example the IIS subsystem determines whether the IIS worker process e.g. w3wp.exe should be virtualized based on an application pool name passed on the command line.

The monitoring component monitors an application being prepared for virtualization to detect configuration data associated with the application. The monitoring component may iterate through registered subsystems asking each subsystem whether the subsystem is interested in handling the present application. The component invokes one or more subsystems that indicate an interest in the application process so that the subsystems can monitor subsystem specific configuration changes made by the application. The monitoring component may also provide snapshot services to take a snapshot of the application before and after monitoring to detect configuration changes made by the application.

The package creation component creates a package for storing configuration data related to the application being prepared for virtualization. The package may include various container file formats which may include compression authentication encryption or other processing such as to make the package smaller or provide security or certainty of the author of a package. For example the package can be a ZIP CAB or other archive file format suitable for storing many files and settings within a single file. The package creation component creates the package when a new application is being prepared for virtualization and may store general configuration information and application specific configuration information such as that detected by a custom virtualization subsystem.

The application package store stores application packages between monitoring of the application being prepared for virtualization and deployment of the virtualized application to one or more target computer systems. The application package store may include various storage media such as a file system network based storage cloud based storage service database and so forth.

The application deployment component deploys an application package to a target computer system so that the target computer system can invoke the virtualized application. The component may perform application specific configuration on the target system such as adding file type associations adding a link to the application package performing operating system service configuration and adding web server configuration information. The application deployment component may invoke a subsystem associated with the application package to perform subsystem specific registration tasks to prepare the virtualized application to run on the target computer system.

The conflict management component detects configuration data associated with a virtualized application and modifies the configuration data to avoid conflicts with other virtual or non virtual applications configured to run on the target computer system. For example the component detects name conflicts for web server applications that specify a named application pool in which to execute. The component may also receive information from an administrator that determines the behavior used to manage conflicts. For example an administrator may override the default behavior and specify a particular name in the instance of a naming conflict for a web application.

The application execution environment provides a level of indirection between the virtualized application and a host operating system of the target computer system. The wrapper may be very thin allowing the application to run nearly natively such as when the application is designed to run on the host operating system. Alternatively or additionally the wrapper may provide APIs and satisfy other constraints expected by applications designed for other operating systems or operating system versions. Thus the application execution environment provides a virtual application with the environment for which the application was designed using the available resources of the host operating system. The application execution environment also invokes an appropriate subsystem or subsystems to provide subsystem specific handling of the virtualized application during run time.

The computing device on which the application virtualization system is implemented may include a central processing unit memory input devices e.g. keyboard and pointing devices output devices e.g. display devices and storage devices e.g. disk drives or other non volatile storage media . The memory and storage devices are computer readable storage media that may be encoded with computer executable instructions e.g. software that implement or enable the system. In addition the data structures and message structures may be stored or transmitted via a data transmission medium such as a signal on a communication link. Various communication links may be used such as the Internet a local area network a wide area network a point to point dial up connection a cell phone network and so on.

Embodiments of the system may be implemented in various operating environments that include personal computers server computers handheld or laptop devices multiprocessor systems microprocessor based systems programmable consumer electronics digital cameras network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and so on. The computer systems may be cell phones personal digital assistants smart phones personal computers programmable consumer electronics digital cameras and so on.

The system may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures and so on that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

Continuing in block the system begins installation of the server application. An administrator may run a setup program and the system may detect creation of a new process and inject a core virtualization system into the process. For example if an administrator turns on monitoring and launches a server application then the system may detect the launch of a worker process associated with the server application start the core virtualization engine and inject the core virtualization system into the work process so that for example the system can monitor API calls and other behavior of the process. Continuing in block the system captures configuration data during installation of the server application. For example the server application may provide an application name associated with a web or other application configure a web server metabase with the name and other information and so forth. The subsystem may detect files and registry keys modified by the process as well as other configuration changes such as MICROSOFT ACTIVE DIRECTORY or IIS metabase changes.

Continuing in block the system concludes monitoring of the installation of the server application. For example an administrator may inform the Sequencer described herein that the installation is complete or the system may automatically detect that the installation has finished. The system may take an ending snapshot of the server application and associated data to compare with a beginning snapshot taken earlier. Continuing in block the system stores the captured configuration data for use during subsequent deployments of the server application. For example the system may create an XML file or other data store and persist the configuration data to the data store for later retrieval.

Continuing in block the system packages the server application for deployment including the stored configuration data. For example the system may create an archive file or other compact representation of the application that an administrator can easily deploy to other servers using tools such as xcopy or other file copying tools. After block these steps conclude.

Continuing in block the system sets application installation parameters that will allow the server application to run on the target computer without conflicting with other applications on the target computer. For example if the system detected a conflicting name in the prior step then the system may set installation parameters with a modified name to avoid conflicts. In some embodiments the system appends a globally unique identifier GUID to an application pool name to avoid conflicts with other application pools having the same name. The system may also receive override information from an administrator or other source that specifies substitute installation parameters to use for configuring the application.

Continuing in block the system configures the target computer system to run the server application with the set application installation parameters. For example the system may write configuration data to a configuration database one or more files a web server metabase and so forth to configure the application. Configuring the application prepares the application to run on the target computer. For example for a web application configuration may include providing a virtual directory port and file locations for the web application to a web server application manager e.g. IIS Manager .

Continuing in block the system receives an application execution indication that indicates a request to launch the configured server application. For example the indication may come from a request received over a network e.g. to access a web page hosted by the server or other source. In some embodiments the system injects components into a server application management component to intercept calls to launch server applications. For example web servers often include a management application that launches worker processes to handle each website hosted on a server. The system may intercept calls to invoke a worker process so that a virtual environment managed by the system can be substituted for native behavior of the management application.

Continuing in block the system loads the application package associated with the received application execution indication and executes the application in a virtual environment. The system may load a module or other executable code associated with the application virtualization system to allow redirection of calls API hooking and other virtualization actions to provide the application with a virtual environment that imitates an environment for which the application was designed. The system may also invoke one or more virtualization subsystems to handle various types of requests that the application might make such as file access requests registry access requests web server specific requests and so forth. As the application executes any hooks or other indirection procedures put in place by the virtualization subsystems allow the system to handle any application requests that require redirection or other handling to permit the isolation provided by virtualization. After block these steps conclude.

One role of the driver is to perform registry and file system virtualization. Registry and file mapping information is uploaded to the driver when a virtual environment is first created using the virtualization library . The driver uses this information to alter the behavior of the registry and file system APIs so that to the virtual application it appears as if the application is locally installed on a target computer system.

The user mode virtualization library e.g. osguard.lib contains APIs to manage virtual environments and processes and is the interface between user mode and the virtualization driver . The virtualization library also has virtual subsystems built into it including virtual file system and virtual registry that are used across various application subsystems. The virtualization library is used to package virtual applications as well as at run time. The sequencer is an application used by administrators to package virtual applications by monitoring the install process and the listener not shown is an operating system service that manages virtual applications at runtime.

A virtualization runtime module e.g. sftldr.dll is a library injected into each virtual process either by the virtualization library or by itself when creating child processes. A detours library is used to hook functions within the virtual application process. Some calls are redirected to the virtualization driver for registry and file system virtualization the others make RPC calls into the virtualization library to perform their respective subsystem virtualization.

During its initialization the virtualization library dynamically loads each subsystem module listed in the registry and stores pointers to their factory interfaces. When the sequencer or listener uses the virtual environment manager to create a virtual environment the factories are used to create an instance of each subsystem. The subsystem instances are stored within the virtual environment object and can be retrieved by the sequencer or the listener.

Many subsystems need access to the virtual file system and registry to perform their virtualization. For example both virtual COM and virtual services subsystems need access to the virtual registry keys to create virtual COM objects and start virtual services respectively. Therefore the virtual registry and file system subsystems are not generalized but rather are core components in some embodiments. Subsystems can get access to these core subsystems through the virtual environment object passed to them through their monitoring and runtime interfaces.

The monitoring interface stores the subsystem changes it detected within a manifest file. This manifest is passed to other interfaces including the visualization interface which displays and allows this information to be edited and the registration interface which uses the information to register components.

In some embodiments the application virtualization system allows administrators to override the application pool name for a virtualized web application. For example an administrator may want to configure two web applications to run in the same pool. In some cases the web application may be designed to use a certain name and the administrator can modify sav providers.xml or another location for storing application metadata to use that application pool name so that the web application will continue to function correctly.

In some embodiments the application virtualization system runs multiple server applications in a single virtual environment. Although the separate virtual environments per application described herein may be desirable in many cases the system can also virtualize applications in a single environment. For example an administrator may want to conserve resources of a target computer system or related applications may want to communicate with one another in a manner not allowed by the isolation of multiple virtual environments.

From the foregoing it will be appreciated that specific embodiments of the application virtualization system have been described herein for purposes of illustration but that various modifications may be made without deviating from the spirit and scope of the invention. Accordingly the invention is not limited except as by the appended claims.

