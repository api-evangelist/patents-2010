---

title: Indexing and querying semi-structured data
abstract: Generating an inverted index is disclosed. Semi-structured data from a plurality of sources is parsed to extract structure from at least a portion of the semi-structured data. The inverted index is generated using the extracted structure. The inverted index includes a location identifier and a data type identifier for one or more entries of the inverted index.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09507848&OS=09507848&RS=09507848
owner: VMware, Inc.
number: 09507848
owner_city: Palo Alto
owner_country: US
publication_date: 20100923
---
This application claims priority to U.S. Provisional Patent Application No. 61 277 571 entitled INDEXING AND QUERYING SEMI STRUCTURED DATA filed Sep. 25 2009 which is incorporated herein by reference for all purposes.

Traditionally organizations have invested in systems that enable rapid access to structured data stored in database systems. However structured data only represents a fraction of all information stored by an organization. It is often difficult to search find and analyze patterns in unstructured and semi structured data using traditional tools. These types of data often cannot be managed efficiently and cost effectively in traditional databases or in data warehouses that try to force a structure on to the unstructured and semi structured data. When the unstructured or semi structured data changes or becomes larger in size it becomes difficult to maintain and scale traditional solutions. Organizations have also tried to utilize keyword search solutions but its success has been limited by its inability to handle sophisticated pattern search analysis. Therefore there exists a need for an efficient and scalable pattern search handling of unstructured or semi structured data.

The invention can be implemented in numerous ways including as a process an apparatus a system a composition of matter a computer program product embodied on a computer readable storage medium and or a processor such as a processor configured to execute instructions stored on and or provided by a memory coupled to the processor. In this specification these implementations or any other form that the invention may take may be referred to as techniques. In general the order of the steps of disclosed processes may be altered within the scope of the invention. Unless stated otherwise a component such as a processor or a memory described as being configured to perform a task may be implemented as a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. As used herein the term processor refers to one or more devices circuits and or processing cores configured to process data such as computer program instructions.

A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.

Enabling pattern search of unstructured and semi structured data is disclosed. An example of semi structured data includes data that may not conform to the formal structure of tables and data models of databases but is associated with tags data types metadata or other markers to identify semantic elements information and or hierarchies of records and or fields of the data. A semi structured data from a plurality of sources are parsed to extract structure data semantic elements information and or hierarchies from the semi structured sources of data. An inverted index is generated using the extracted information. The inverted index includes a location and a data type for one or more entries of the inverted index and or one or more fields from the extracted information. A user may query the inverted index to analyze patterns associated with the unstructured and semi structured data.

For example in the context of technical support support engineers may utilize the inverted index to improve support provided to customers. Typically when customers encounter problems they send semi structured support artifacts such as logs configurations scripts code system status or performance statistics to the product vendor for diagnosis. These semi structured data can be efficiently indexed in an inverted index and the inverted index can be easily searched to analyze patterns associated with the support artifacts to provide efficient support. For example an inverted index that includes data associated with new data can be queried using a signature query of a known problem to determine whether the new data is also associated with the know problem.

Application utilizes index to provide user desired functionality associated with index . For example application facilitates a user interface that can be used to query and view query results of index . In another example application facilitates data pattern search and or analysis using index . Application accesses index via data processor . For example application facilitates pattern searches and or analysis associated with unstructured and semi structured data indexed by index by querying index via data processor . In some embodiments application directly queries index . In some embodiments index can be access by application via an Application Programming Interface API . For example web services APIs allow users to build custom applications that use index .

At the data to be indexed is parsed. In some embodiments parsing the data includes extracting structure information from the received data. Examples of the extracted structure information include tags data types metadata or other markers to identify semantic elements structures information and or hierarchies of records and or fields of the data. In some embodiments parsing the data includes converting at least a portion of the received data to an intermediate format before the data is indexed. Converting the data into the indeterminate format may include identifying data types associated with text elements of a semi structured data by extracting structural information associated with the semi structured data. In various embodiments additional processing is performed on the received data. For example the received data is automatically and dynamically analyzed while the data is being parsed to detect patterns trends commonalties and or differences.

At an index is generated using information parsed at . In some embodiments indexing includes organizing parsed data in a manner that facilitates pattern matching and or searching of semi structured and unstructured data. In some embodiments indexing the received data includes enabling terms of the semi structured or unstructured data to be searched efficiently and associating a data structure type information and or data location information with one or more of the terms. In some embodiments an inverted index is created at .

At data is analyzed using the index. For example a structured query of the index is processed and matching result s of the query is returned. In some embodiments a structured query includes a constraint on data type and value of an element of the index. In some embodiments at least a portion of the process of is performed in a distributed processing environment. For example each of one or more worker processes systems process at least a portion of the processing required in and or and the processing result of these worker processes systems are managed combined by a master process system.

If at it is determined that the data is not associated with a preconfigured parser at at least a determined portion of the data is tested using a library of parse expressions to determine how to parse the data. In some embodiments the received data is scanned to detect segments such as repeating patterns or logical groupings within the received data. At least one of these groupings segments is tested against each parse expression from a library of parse expressions to determine a parse expression that can be used to parse the grouping segment. For example a log file includes multiple log messages and each log message is tested against a library of parse expressions. A parse expression may match with a log message because the parse expression specifies that a matching log entry includes a timestamp a message type and a free text message body. Different parse expressions may match the log message depending upon log attributes or message fields in the free text message body of the log message.

If at a matching parse expression is found at at least a portion of the received data is parsed using at least a portion of a parser associated with the matched parse expression. In some embodiments the parser associated with the matching parse expression is the matching parse expression that can be used to parse at least a portion of the received data. In some embodiments the parser associated with the matching parse expression is used to parse more than the data portion determined at . For example once one log message is matched with a parse expression other associated log messages may be parsed using the parser associated with the matched parse expression. A plurality of parsers and or parser portions may be associated with matched parse expression and one or more of these parsers portions may be used to parse at least a portion of the received data.

In some embodiments parsing the data at and or at includes extracting structure information from the received data. Examples of the structure information include tags data types metadata or other markers to identify semantic elements information and or hierarchies of records and or fields of the data. In some embodiments parsing the data includes converting at least a portion of the received data to an intermediate format before the data is indexed. Converting the data into the indeterminate format may include identifying data types associated with text elements of a semi structured data by extracting structural information associated with the semi structured data. In some embodiments a parser uses a configuration file e.g. eXtensible Markup Language based configuration file to obtain information associated with parsing rules.

At if it is determined that the entire received data has not been parsed the process returns to where at least a portion of the unparsed portion is tested against the library of parse expressions. At if it is determined that the entire received data has been parsed the process ends. At if a parse expression match is not found at at least a portion of the received data is parsed using a standard parser. The standard parser may associate a generic tag data type marker identifier information or hierarchy information with extracted information text of the received data. The data parsed by the standard parser may be unstructured data and or semi structured that does not match any determined parse expression. In various embodiments the standard parser is a generic parser that is able to parse any type of valid data to a desired form. After the process returns to .

At an index is generated using the received parsed information. In some embodiments generating the index includes organizing the parsed information in a manner that facilitates pattern matching searching. In some embodiments elements of data to be indexed are broken into terms that are the basic unit of definable search patterns. For example a log message monitor target 159.170.100.80 may be broken into three terms of monitor target and 159.170.100.80. In some embodiments the index is an inverted index. For example for each term in the previous example an inverted list of log file identifiers that contain the term is created. In some embodiments one or more instances of a term in the index is associated with structure information parsed from indexed data. For example a data type and a position where the term appears in the log file are associated with each instance of the term. Other examples of structure information include tags data types metadata semantic element identifiers hierarchy information and data attributes.

In some embodiments the inverted index is associated with a sequence of documents. Each document is associated with a log file and assigned a unique document identifier. The document may contain one or more fields. Each field is further split into individual terms as appropriate. For example a term includes a text string. The inverted index stores mappings of terms to the documents that contain the term. In some embodiments the inverted index includes for each term a sorted list of document identifiers of documents that contain the term. In some embodiments the inverted index includes for each term and each document a sorted list of positions in the document that includes the term.

To efficiently preserve information of which terms belong to the same log message positions of the first terms of every message in the same document are aligned on fixed boundaries. With the boundary size known a priori deciding whether occurrences of terms belong to the same log message requires one in memory arithmetic operation. For example a log file indexed as doc 0 includes the following.

If the position boundaries are multiples of 2048 the term positions in the inverted index would include the following.

In embodiments a same term is associated with a plurality of fields. The text field is the default field. For example in the following log files the term error appears in both the severity field and the text field.

In some cases log messages contain fields that include numeric values e.g. Timestamps of log messages . Indexing numeric values the same way as regular text fields may slow down range queries because all possible values that fall in the range would need to be searched. To speed up range queries of numeric fields numeric field values are organized in a tree data structure. Each numeric value in the log message is indexed as multiple terms and the terms become the root nodes of the tree. is a chart shows tree data structure for numerical terms and . The root nodes include the numeric terms and the intermediate nodes include successive beginning digit portions of the numeric terms. If a query seeks to find all numeric terms with values between and inclusive only log messages with the four shaded terms as shown in tree data structure of need to searched rather than searching log messages with six terms i.e. and if the numeric values were just indexed as text.

At the received query is translated into an index query. For example the received structured search query is translated to a query form that can be processed by the index. In some embodiments translating the received query includes checking the received query for errors. In some embodiments translating the received query includes using a lexer to tokenize the received query and using a parser to map the received query to a grammar to be used to translate the received query to an index query form.

In various embodiments translating the query includes first parsing the received query including by identifying a query item that specifies a pattern to be matched found. For example the received query is parsed into a logic query tree with constraints. Each leaf of the tree represents an item constraint that may be composed of boolean sub queries on one or multiple fields. A non leaf node describes the relationship constraint among its children. To achieve better performance the logic constraints of the received query is converted to a Disjunctive Normal Form of a logical formula and the constraints are reduced to the simplest form. For example the received query is SELECT FROM WHERE MESSAGE.text scsi retry failed AS i MESSAGE.text reboot MESSAGE.severity critical AS j HAVING COUNT i 2 COUNT j 1. This query is parsed into logic query tree as shown in .

Second each leaf node is converted to a boolean tree. Each leaf node is one sub query on a single field which is a simple inverted index query on a term or a phrase on a field. For the example above the right child leaf for item j is converted to boolean query tree as shown in .

Third the inverted list is retrieved from the index for each term in each sub query on a single field. For example for a phrase sub query MESSAGE.text scsi retry failed three inverted lists are retrieved from index for terms scsi retry and failed on field MESSAGE.text.

At the index is queried using the translated index query. In some embodiments querying the index includes sending the translated index query to a system and or processor e.g. data processor of associated with the index. In some embodiments querying the index includes directly querying an index such as index of . Processing the index query may include walking through elements of a sorted inverted index. For each term a sorted position list is traversed to find a block of positions in which all terms of interest appear in a desired order. The sorted position list enables this search to be performed in a single pass through the index.

For example candidate messages are found by walking through the inverted lists for the terms in an item boolean query tree and it can be determined whether the terms belong to the same log message and a phrase based on the term positions stored in the index. In the meantime the boolean relationship described in the item boolean tree if any is applied to the terms in the same log message. If the constraints are satisfied the log message will become a candidate. Then candidate logs are found. By walking through the candidate message lists it can be determined whether the messages belong to the same log based on the term positions. Applying the constraints described in the logic query tree on the candidate messages from the same log all log candidates can be found if the constraints are satisfied.

At an index query result is received. In some embodiments this result includes one or more of the following identifier s associated with a file s and or location s of the data that matches the query a copy of the data matches the query structural information associated with the data matches query other search results patterns related to the data matches the query and any other information associated with the data that matches the query.

At at least a portion of the received result is returned to a user. For example the query results displayed in a user interface that allows the user to efficiently identify a pattern associated with the received result.

In the context of technical customer support the process of can be used to efficiently trouble shoot user problems. For example a higher tier support engineer can codify his or her knowledge into a signature query after resolving an issue. Next time a beginning tier support engineer receives an issue the support engineer can check a semi structured support artifact e.g. error log or a configuration file against the signature query by querying an index that contains the support artifact using the signature query. If a match is found against one of the signature structured queries a solution associated with the matching signature query can be offered as a solution to the customer. In some cases this process can be automated by generating a report when a support artifact is received. This report includes results of one or more results of a signature query against an index that includes the received support artifact. The report will indicate any matches for known signature queries and associated causes and solutions.

In some cases information technology vendors collect data from systems in use. Using the parsing indexing and searching processes described above the vendor can analyze the collected data efficiently. For example a product manager can find out if a new feature in the latest release of the product is functioning properly by querying an index generated using data collected from users.

In some embodiments the query language described above is the Pattern Insight Query Language PIQL . PIQL allows users to query single item pattern using multiple conditions on item fields using Boolean logic to query for multiple item patterns constrain the data source by specifying section names and log attributes specify multiple types in conditions including string float and version express patterns not only on whether an item occurs but also on how many times it occurs express multiple item patterns on their temporal order add a time range constraint on patterns and limit the scope of query results being returned.

The SELECT FROM and WHERE clauses of PIQL construct the basic form of query statement. The SELECT clause defines what will be returned from the query the FROM clause defines from which sections query results are retrieved from and the WHERE clause defines conditions on items and log attributes. The PIQL query in its basic form has the following syntax SELECT what FROM sections WHERE pattern. In the SELECT clause what can be which means the query will return results at item level. In the FROM clause sections can be in the form of section AS alias section AS alias or use to refer to all sections. Only these section names and aliases specified in the FROM clause can be used in the WHERE clause to define log pattern. In the WHERE clause pattern is defined in a form of a tree using Boolean operators such as AND OR and AND NOT . The following statement for example returns matches satisfying condtion1 and one of condtion2 and condition3 SELECT FROM WHERE condition1 condition2 condition3 .

There three types of leaf conditions item condition log attribute condition and section attribute condition. The item condition specifies conditions at item level while the log attribute condition and the section attribute condition specify conditions at log level and section level respectively. The item condition is defined in form of a tree using Boolean operators. The following statement for example returns matched log items that satisfy both item condition1 and item condition2 SELECT FROM WHERE item condition1 item condition2 AS item alias.

The leaf item condition has syntax section.field compare op value where section must be included in the FROM clause and compare op must be comparable with types of field and value. The following statement for example returns log items which are from section MESSAGES and have reboot and kernel in their field text SELECT FROM WHERE MESSAGES.text reboot MESSAGES.text kernel AS item1.

The log attribute condition has syntax ATTR log attribute compare op value where compare op must be comparable with types of log attribute and value. The following statement for example returns log items which are from section MESSAGES and have reboot and kernel in their field text SELECT FROM WHERE MESSAGES.text reboot MESSAGES.text kernel AS item1 ATTR version 

The section attribute condition has syntax ATTR section section attribute compare op value where section must be included in the FROM clause and compare op must be comparable with types of section attribute and value. The following statement for example returns log items which are from section MESSAGES and have reboot and kernel in their field text SELECT FROM WHERE MESSAGES.text reboot MESSAGES.text kernel AS item1 ATTR MESSAGES system linux . Furthermore all matched log items must be from MESSAGES sections whose attribute system contains the string linux. 

The HAVING clause is an optional part of a PIQL query specifying filter on query matches. COUNT clause specifies filtering condition on item occurrence time while BEFORE clause specifies filtering condition on items. temporal order. The PIQL query with HAVING clause has the following syntax SELECT what FROM sections WHERE pattern HAVING filter. The filter is defined in a form of a tree using Boolean operators such as AND OR and AND NOT . The following statement for example returns matches filtered on filter1 and filter2 SELECT FROM WHERE pattern HAVING filler1 filter2.

There are two types of leaf filters COUNT filter and BEFORE filter. The COUNT filter has syntax COUNT item alias compare op value where item alias must be defined in one of Item clauses at the WHERE clause compare op must be one of and value must be with type of integer. The following statement for example returns log items which are from section MESSAGES and have reboot and kernel in their field text SELECT FROM WHERE MESSAGES.text reboot MESSAGES.text kernel AS item1 HAVING COUNT item1 3. Furthermore the log item must appear for more than 3 times within the same log file.

The BEFORE filter has syntax BEFORE item alias1 item alias2 . The following statement for example returns two item log patterns which are from section MESSAGES and have panic and reboot in their field text respectively SELECT FROM WHERE MESSAGES.text panic AS item1 MESSAGES.text reboot AS item2 HAVING BEFORE item1 item2 . Furthermore the log item has panic must be temporally ahead of the log item has reboot. 

Optionally BEFORE filter can specify minimal distance between two items using syntax BEFORE item alias1 item alias2 minDistance . The following statement for example requires minimal distance between any appearances of the two items to be at least 5 minutes inclusive in addition to requirements mentioned above SELECT FROM WHERE MESSAGES.text panic AS item1 MESSAGES.text reboot AS item2 HAVING BEFORE item1 item2 300 .

The TIMEWINDOW clause is an optional part of a PIQL query specifying time range exclusive of log patterns. Without the TIMEWINDOW clause the default time range is the whole log file. The PIQL query with TIMEWINDOW clause has the following syntax SELECT what FROM sections WHERE pattern TIMEWINDOW seconds.

The LIMIT clause is an optional part of a PIQL query specifying the range of log pattern matches to be returned. Without the LIMIT clause the first 10 log pattern matches are returned. The PIQL query with LIMIT clause has the following syntax SELECT what FROM sections WHERE pattern LIMIT start length.

Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive.

