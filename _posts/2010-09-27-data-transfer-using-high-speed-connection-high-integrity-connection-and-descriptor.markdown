---

title: Data transfer using high speed connection, high integrity connection, and descriptor
abstract: Systems and methods for transfer of data including establishing two separate connections, the two separate connections including a high speed connection and a high integrity connection. Blocks of data are exchanged over the high speed connection while the high integrity connection facilitates communication of descriptor data regarding data received over the high speed connection. As such, the data transfer speed of the high speed connection is utilized while communication via the high integrity connection allows for data reliability features not provided by the high speed connection.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08751682&OS=08751682&RS=08751682
owner: Z124
number: 08751682
owner_city: George Town
owner_country: KY
publication_date: 20100927
---
In order to facilitate communication between computing devices data may be transmitted between devices in a format that is comprehensible by both the sending and receiving devices. In this regard protocols have been developed that enable communication between computing devices connected by way of a network or the Internet. These protocols provide a standardized format in which data may be sent over a network. Accordingly data may be sent between computing devices on a network or over the Internet and be properly interpreted by the receiving computer. The most common set of protocols governing communication over or between networks is the Internet Protocol Suite commonly referred to as TCP IP .

The Internet Protocol Suite includes several layers that provide different functions at different levels of abstraction. These layers consist of the Application layer the Transport layer the Internet layer and the Link layer. Within each of these layers different protocols have been developed to facilitate communication between computing devices. For instance within the Transport layer many protocols have been developed in order to format data for communication over a network such that the sending and receiving computer devices may properly direct the data to and from an appropriate application on each computer. These protocols may provide different features depending upon the nature and intended role of the protocol. For example connection oriented data stream support reliability flow control and error correction may be provided by protocols within the Transport layer. However the feature set for each protocol may be different and may include or omit features to strike a balance between performance e.g. data transfer rates and reliability e.g. data integrity at the receiving device . That is a protocol tailored for high rates of data transfer generally includes fewer data reliability features whereas protocols tailored for high reliability may include reliability features that may limit data transfer rates. Two popular and widely used transport layer protocols demonstrate this inherent balance between performance and reliability. These are the Transport Control Protocol TCP and the User Datagram Protocol UDP .

TCP connections provide data transfers that help to ensure high data integrity at the receiving device but generally provide slower data transfer speeds than speeds obtainable using a UDP connection. A TCP connection utilizes a positive acknowledgement with retransmission technique that requires an acknowledgment message to be exchanged between a receiving entity and a sending entity to confirm that each individual data packet sent from a sender to a receiver was in fact received at the receiver. If not received the data packet is retransmitted until acknowledgement is received from the receiver. While this may help to ensure that the data being sent arrives in the correct order and may assist in ensuring data packet delivery the high reliability of the TCP connection comes at a cost of speed. The acknowledgement messages exchanged between sender and receiver take time to transmit. In turn these messages are exchanged during times that could otherwise be used for transferring data thus limiting the overall transfer rate. For example oftentimes delays in the order of seconds are required waiting for out of order messages or waiting for retransmission of a packet.

A UDP connection on the other hand provides high speed data exchange yet may sacrifice features that help ensure the integrity of data received at a receiving entity. In this regard data packets i.e. datagrams sent via a UDP connection are not subjected to acknowledgement or other integrity checks similar to those present in a TCP connection. Thus the transfer rate of a UDP connection may be higher than that of a TCP connection. However there may be no mechanism in a UDP connection to help ensure that the all data packets were received that all data packets arrived in order and that there was no corruption of data during the transfer. Rather data is simply delivered to the Application layer in the form it was received. As such UDP connections either rely on applications to perform integrity checks or assume that such integrity is of lesser importance than the overall speed of data transport. In this regard UDP connections are valuable in certain applications such as Internet broadcasting voice over IP VoIP transmissions queries to the Domain Name System DNS streaming media applications such as IPTV Trivial File Transfer Protocol TFTP online gaming or other time sensitive communications where a loss in data integrity is preferable to a slow communication due to the time sensitive nature of the data.

In short a UDP connection emphasizes speed at the cost of reliability while a TCP connection emphasizes reliability at the cost of speed.

Other protocols been developed for data exchange that are tailored for particular applications. One example of such a tailored protocol is the BitTorrent protocol. BitTorrent allows for exchange of a relatively large amount of data without dominating the bandwidth of any one computing device participating in the data transfer. In this regard a torrent file is obtained by a receiving computer that in turn uses the file to seek and download small portions of a target file from various locations in the network often called seeds . In this regard the torrent file directs the acquisition of data from a multitude of different sources. However BitTorrent was developed in order to provide relatively low bandwidth usage which is spread across a large number of users in the network in order to transfer data. Additionally transfers using the BitTorrent protocol may use existing transport protocols e.g. TCP and are thus subject to the limitations presented by such transport protocols. As such the data transfer is often slow as the usage of any one user s bandwidth is relatively low.

A first aspect of the present invention includes a method of transferring data between computing devices that are operable to communicate over an electronic network. The method includes sending data from a source device to a destination device using at least one high speed connection. Also the method includes communicating a descriptor regarding the data from the source device to the destination device using at least one high integrity connection. Data received at the destination device is correlated to the descriptor received at the destination device. The method further includes modifying the descriptor to identify data received at the destination device and informing the source device of the identity of data not received by the destination device using the at least one high integrity connection. The method also includes resending data not received by the destination device from the source device to the destination device using the at least one high speed connection.

A second aspect of the present invention includes a computing device that is operable to communicate with other computing devices to perform a parallel data transfer. The computing device includes a microprocessor a memory in operative communication with the microprocessor that is operative to store one or more files a network communication device operative to communicate data packets to a remote device on a network using a high integrity connection and a high speed connection and a parallel data transfer module in operative communication with the microprocessor and the network communication device. The parallel data transfer module is operable to receive a descriptor over the high integrity connection regarding blocks of data received over the high speed connection update the descriptor file based on the blocks of data received over the high speed connection and communicate the updated descriptor file over the high integrity connection using the network communication device.

A third aspect of the present invention includes a method for receiving data at a destination device from a source device. The method includes receiving data at the destination device from the source device over at least one high speed connection. Additionally the method includes acquiring a descriptor at the destination device regarding the data from the source device over at least one high integrity connection. Data received from the source device is correlated at the destination device to the descriptor. The method also includes modifying the descriptor based on data received at the destination device over the high speed connection. In addition the modified descriptor is sent to the source device and the destination device receives data that has been resent by the source device using the at least one high speed connection.

A fourth aspect of the present invention includes a method of sending data from a source device to a destination device. The method includes sending data from the source device to the destination device using at least one high speed connection. Additionally the method includes transmitting a descriptor regarding the data from the source device to the destination device using at least one high integrity connection. Also the method includes receiving at the source device a modified descriptor including the identity of data not received by the destination device using the at least one high integrity connection. The method includes resending at the source device data not received by the destination device to the destination device using the at least one high speed connection.

A number of feature refinements and additional features are applicable to any of the aspects presented herein. These feature refinements and additional features may be used individually or in any combination. As such each of the following features that will be discussed may be but are not required to be used with any other feature or combination of features of the any of the aspects presented herein.

For instance in one embodiment the data may include a first portion of a file. The first portion may include a plurality of blocks. Additionally the descriptor may include a file which contains a set of unique elements. Each unique element may correspond to a different one of the plurality of blocks. For example the unique element may be a bit in the file. In an embodiment the modifying may include toggling at least one bit in response to receipt of a corresponding block of the first portion at the destination device. In this regard the informing may include transmitting the descriptor having toggled bits to the source device via the high integrity connection.

In another embodiment the method may be repeated until each of the blocks in the first portion is received at the destination device. As such the method may be repeated for a plurality of portions until all of the file is transferred.

In yet another embodiment a plurality of parallel data transfer connections may be established. Each parallel data transfer connection may include a high speed connection and a high integrity connection and each parallel transfer connection may be operable to perform a method to transfer a respective one of a plurality of portions of a file. Furthermore a plurality of parallel data transfer connections may be established. Each parallel data transfer connection may include at least one high integrity connection and a plurality of high speed connections. The plurality of parallel high speed connections may be operable to perform a method as recited above in concert with the at least one high integrity connections to transfer a respective one of a plurality of portions of a file.

In another embodiment the at least one high speed connection may employ a User Datagram Protocol UDP . The at least one high integrity connection may employ a Transmission Control Protocol TCP . Also the source device may be a server and the destination device may be a client device. The client device may a handheld computing device e.g. a smartphone PDA tablet computer or the like . In addition the source device and the destination device may both be servers.

In still further embodiments the method may be executed as an application directly controllable by a user. Commands may be received from a user by at least one of a command line interface and a graphical user interface. The method may also executed as a service controllable by an application. The service may be controllable by way of at least one of an application programming interface a script and a remote procedure call. The method may be initiated by the source device or may be initiated by the destination device.

Any of the embodiments arrangements or the like discussed herein may be used either alone or in combination with other embodiments arrangements or the like with any of the disclosed aspects. Any feature disclosed herein that is intended to be limited to a singular context or the like will be clearly set forth herein by terms such as only single limited to or the like. Merely introducing a feature in accordance with commonly accepted antecedent basis practice does not limit the corresponding feature to the singular e.g. indicating that a data transfer protocol includes the high speed connection alone does not mean that the data transfer protocol includes only a single high speed connection . Moreover any failure to use phrases such as at least one also does not limit the corresponding feature to the singular e.g. indicating that data transfer protocol includes a high speed connection alone does not mean that the data transfer protocol includes only a single high speed connection . Use of the phrase at least generally at least partially or the like in relation to a particular feature encompasses the corresponding characteristic and insubstantial variations thereof. Finally a reference of a feature in conjunction with the phrase in one embodiment does not limit the use of the feature to a single embodiment.

While the invention is susceptible to various modifications and alternative forms specific embodiments thereof have been shown by way of example in the drawings and are described in detail herein. It should be understood however that it is not intended to limit the invention to the particular form disclosed but rather the invention is to cover all modifications equivalents and alternatives falling within the scope of the invention as defined by the claims.

The present disclosure is generally directed to parallel data exchange between computing devices. The exchange involves establishing at least one pair of connections that include a high speed connection and a high integrity connection. As used herein each one of the high speed and high integrity connections may be judged relative to the other. That is the high speed connection may be capable of data transfer speeds at least greater than the high integrity connection and the high integrity connection may provide at least greater data reliability than the high speed connection. In one particular embodiment the high speed connection utilizes a UDP protocol and the high integrity connection utilizes a TCP protocol.

The high integrity connection may be a side channel that is used to communicate descriptor data regarding the status of data transferred over the high speed connection. As such while the high integrity connection may provide slower data transfer rates than the high speed connection the amount of data communicated over the high integrity connection may be small compared to the amount of data communicated over the high speed connection.

During a data transfer the majority of the data exchanged between a sender and receiver may be exchanged over the high speed connection. The high integrity connection may be used to exchange information used to provide data integrity features typically not available using the high speed connection.

The protocol may further include the sender and receiver exchanging information via the high integrity connection. This information may include information regarding a file name and a file size of a file to be transferred from the sender to the receiver. Additionally the receiver may based on the exchanged file information allocate an appropriate amount of memory at the receiver device to accommodate the file as will be discussed further below. As this exchanged information may comprise only metadata regarding the information to be exchanged via the high speed connection the amount of data exchanged via the high integrity connection may be small compared to the amount of data to be exchanged via the high speed connection.

With additional reference to a graphical representation of the division of a file into small pieces is shown. A file is represented as a line segment wherein the length of the line segment is representative of the amount of data comprising the file . The file may in turn be divided into a number of superblocks . Each of the superblocks may in turn be divided into portions . Each of the portions may be divided into a number of blocks . Each of the blocks may be transmitted over the high speed connection as a single data packet. Thus each block may be provided with header data corresponding to the protocol used for the high speed connection. Furthermore each portion may have associated with it a descriptor file. The descriptor file may have a bit corresponding to each block in a portion . The relationship between blocks and descriptor files will be discussed further below. Additional data regarding the file such as the number of superblocks to be exchanged the number of portions per superblock and the number of blocks per portion may also be exchanged at step of .

The protocol may include the receiver and or sender initiating the transfer a portion of a superblock via the high integrity connection. For instance in order to initiate the data transfer the receiver may request the first portion of the first superblock. In another embodiment the sender may initiate a transfer of the first portion of the superblock. Thus the initiation of a transfer of a portion may originate at the sender or receiver.

In any regard the protocol may include sending a descriptor file for the portion to be transferred via the high integrity connection. The descriptor file may include a number of unique elements. Each unique element may correspond to a different one of the blocks to be sent for the portion. In one embodiment the descriptor file is a 32 bit word such that the descriptor file corresponds to 32 blocks of data that comprise one portion of a superblock. In this regard each bit is a unique element. Alternative embodiments may include that the unique element is a larger portion of the file such as a byte or other portion of the file.

The sender may send the blocks of the portion from the sender to the receiver via the high speed connection. It will be understood that because the blocks are sent via the high speed connection there may few or no features to help ensure reliable data delivery provided by the high speed connection. For example a data checksum may be provided e.g. in a UDP header to ensure the contents of each individual block are accurately received however no mechanism may be provided to help ensure all blocks are received or to ensure the blocks are received in the correct order.

As such the descriptor file may be updated to reflect whether blocks send by the sender were received at the receiver. Updating the descriptor file may include toggling bits that correspond to blocks that are received at the receiver. Thus the updated descriptor file may include bits indicating the files that have been received at the receiver and files that have yet to be received at the receiver.

As an example for a portion comprising six blocks of data a corresponding six bit descriptor file may be sent . As such upon initial receipt of the descriptor file at the receiver i.e. prior to receiving any blocks via the high speed connection the descriptor file may be populated with zeros indicating no blocks have been received. Thus the descriptor file may be represented as 000000 . After having received the first block block third block block and fourth block block the descriptor file may be updated to reflect which of the blocks were received. Thus the updated descriptor file may be represented as 101100 . When all blocks have been received the descriptor file may be represented as 111111 .

Returning to the receiver may send an updated descriptor file via the high integrity connection to the receiver. At the updated descriptor file may be used to determine which blocks of the requested portion of the request superblock have been received. If not all blocks of the requested portion have been received the sender may resend the blocks that were not received based on the updated descriptor file.

The process may then loop such that the descriptor file is updated based on any newly received blocks the non received blocks are sent via the high integrity connection to the sender and it is determined whether all blocks of the requested portion have been received. This loop may be repeated until all blocks of the requested portion have been received at the receiver or until the process times out e.g. performs a predetermined number of loops without any blocks being received by the receiver or without receiving an updated descriptor file .

If all blocks of the requested portion have been received the protocol may proceed to determining if the entire file transfer has been completed. If all portions of all superblocks e.g. the entire file have been received the transfer may be ended. If there are remaining portions of superblocks to be received the process may loop such that the transfer of the next portion of the superblock is initiated . Alternatively the transfer of the first portion of the next superblock may be initiated . The protocol may be repeated until all portions of all superblocks into which the file was divided have been transferred.

With additional reference to a graphical representation of a descriptor file and a block is shown. For illustrative purposes a 32 bit descriptor file is depicted. Thus in this particular embodiment each superblock may be divided into portions having 32 blocks. However a descriptor file with a different number of bits may be provided such that each portion of the superblock contains a corresponding number of bits e.g. a 20 bit descriptor file would result in portions of 20 blocks etc. . That is the number of bits used for the descriptor file may determine the size of the portions into which each superblock is divided. Prior to being sent over the high speed connection each block may be appended with an identifier . The identifier may be used to correlate the block with the appropriate corresponding bit for the descriptor file . As depicted block of the portion is shown corresponding to bit . Thus the identifier may be used to correlate block with bit when block is received at the receiver. Bit may be toggled i.e. a 0 value changed to a 1 value upon receipt of block at the receiver. In this regard the status of whether each block of the portion being transferred has been received may be tracked using the descriptor file . This is further illustrated with reference to .

It may be the case that all eight blocks are sent via the high speed connection however due to network conditions or other factors some blocks may not all be received at the receiver. In this regard the descriptor file may be updated with respect to the received blocks. This updated descriptor file is designated with a single prime . The bits associated with block block block block and block in the updated descriptor file have been populated with ones to indicate in these blocks were in fact received. The updated descriptor may then be transmitted via the high integrity connection to the sender. Based on this received updated descriptor file the sender may resend the non received blocks i.e. block block and block . Block block and block may subsequently be received via the high speed connection . As such the descriptor file may again be updated. This updated descriptor file is designated with a double prime . Thus the updated descriptor file indicates all blocks have been received i.e. all bits are set to one . The updated descriptor file may then be sent via the high integrity connection to the receiver. Thus the receiver is notified that all blocks have been received at the receiver and that the transfer of the portion corresponding to the descriptor file is complete.

Thus blocks of data corresponding to a bit in a descriptor file may be transferred between machines. Each group of blocks correlated to the same descriptor file may comprise a portion. Blocks may have a predetermined size. For example in one embodiment each block may have about 1440 bytes or less. Blocks may be sized such that the data of the block the identifier correlating the block to a descriptor file and any header information added to the block to facilitate communication via a protocol e.g. a UDP header does not render the block too large to transmit using the selected protocol. In one embodiment each superblock may have associated with it 1000 blocks. As briefly discussed above the number of portions of blocks within a superblock may be determined by the number of bits of the descriptor file. That is a portion may comprise all the blocks correlated to a common descriptor file. For instance in an embodiment where a superblock has 1000 blocks and a 20 bit descriptor file is utilized the superblock may have 50 portions. For each of these portions each bit of a 20 bit descriptor may have a corresponding block. Thus during a transfer each portion may be sent via the process described above with reference to . The transfer of a complete file may entail dividing the file into superblocks dividing the superblocks into portions and correlating each block of a portion to a bit in a descriptor file to facilitate transfer.

Additionally while the foregoing has generally discussed a single instance of a parallel transfer using a high speed connection and a high integrity connection it is also contemplated that a plurality of parallel transfers using the method described above may be carried out simultaneously. In this regard a plurality of pairs of high speed and high integrity connections may be established between a sender and receiver. For instance in an embodiment utilizing a UDP protocol for the high speed connection and a TCP protocol for the high integrity connection a unique port number may be used for each UDP and TCP connection comprising a high speed connection and high integrity connection pair. In one embodiment TCP Port is used as a listening port for the sending device and TCP port is used as a listening port for a remote procedure call to the protocol as will be described further below. UDP Ports and may be used for sending and receiving device pairs. In one embodiment up to 16 parallel transfer connections may be established each parallel transfer connection may include a high speed connection and a high integrity connection. More parallel transfer connections could be provided however the available bandwidth of a device may preclude the effective use of more than 16 parallel connections.

The use of multiple parallel transport connections simultaneously may facilitate even higher data transfer rates as each parallel transfer connection may work to simultaneously transfer a portion of a superblock as described above. In this regard each parallel transfer connection may be tasked with transferring one portion of the superblock. After completing the transfer of a portion of the superblock each connection may be tasked with transfer of another portion of the superblock until all portions have been transferred. Once the superblock has been completely transferred the parallel transfer connections may be tasked with transfer of another superblock.

For example one embodiment may include three parallel transfer connections operative to transfer five portions of a superblock. In this regard the superblock may be divided into portions A B C D and E. The first parallel transfer connection may begin transferring portion A the second parallel transfer connection may begin transferring portion B and a third parallel transfer connection may begin to transfer portion C. The parallel transfer connection that first completes the transfer of a portion may begin transferring the next portion portion D . The next parallel transfer connection that completes a transfer may be tasked with downloading portion E. In the event a parallel transfer connection completes the transfer of a portion and no remaining portions of the superblock are available the parallel transfer connections may be idled until all portions of the superblock have been downloaded. Once all portions of the superblock have been downloaded the process may proceed to a second superblock wherein the foregoing may be repeated. Thus when a parallel transfer connection completes a transfer of a portion the next portion to be transferred may be assigned to the available parallel transfer connection. However once all portions have been transferred or are actively being transferred by another parallel transfer connection any free parallel transfer connections may be idled upon completion of the transfer of the superblock.

In this regard the transfer process may be implemented on a superblock by superblock basis such that each superblock is fully transferred prior to initiating the transfer of another superblock. Thus each superblock of the file may be transferred in this manner until the entire file has been transferred.

Additionally while the foregoing has described a parallel transfer connection including a single high integrity connection and a single high speed connection further embodiments may be provided where additional high speed or high integrity connections are established for each parallel transfer connection. For instance a graphical representation of various embodiments of parallel transfer connections are shown in . In each of the embodiments depicted a parallel transfer connection is established between a source device and a destination device . As shown in a single high integrity connection and a single high speed connection is established. shows a plurality of high integrity connections and a single high speed connection . In this regard multiple descriptors or portions of a single descriptor may be exchanged using the high integrity connections to conduct a transfer as discussed above while blocks are transferred over the single high speed connection .

Additionally depicts a parallel transfer connection wherein a single high integrity connection is provided along with a plurality of high speed connections . The high integrity connection may be operative to transmit descriptor data between the source device and the destination device regarding blocks that have been transmitted received over the plurality of high speed connections . In addition depicts an embodiment of a parallel transfer connection wherein a plurality of high integrity connections and a plurality of high speed connections are provided. In this regard a parallel transfer connection may include more than one high speed connection and or high integrity connection that may be used to carry out the transfer as described above.

Parallel transfer connections may process non adjacent portions of a file simultaneously. By non adjacent portions of a file it is meant that portions of the file may be transferred out of order. Thus the presently contemplated process of data transfer may provide a mechanism of ordering a received file despite individual blocks of the file being received at the receiver out of order.

For instance upon initiation of a file transfer the file name and file size may be provided. Thus the receiver may be aware of the size of the file. This coupled with known information regarding the size and number of superblocks portions and blocks may be used to determine the appropriate location in memory of a given amount of received data. Accordingly despite receiving blocks of a file out of order a receiver may be able to write a block to an appropriate location in memory such that once all blocks have been received the file is identically reproduced at the receiver.

For instance a file having two or more portions may be transferred such that the two or more portions are transmitted simultaneously using two or more parallel transfer connections. Thus blocks may be received simultaneously that belong to different portions of the file. Thus the receiver may be operative to write the received block into memory at an appropriate location despite the receipt of the blocks out of order. For example this may be accomplished by writing to an absolute position associated with the correct location of a particular block or may be accomplished by using a known offset from a known reference in the memory e.g. the location in the memory associated with the beginning of the file 

A graphical representation of one embodiment writing non adjacent data into a memory based on an offset is shown in . The receiver upon initiation of the data transfer may receive information regarding the total size of the file to be received and the size of each block and each portion. Thus the receiver may allocate the appropriate amount of local memory to store the file that is to be received. When receiving the file information the receiver may determine if enough memory exists at the receiver. If insufficient memory is available to store the completed file the receiver may report an error either locally or to the sender.

As shown in the receiver may have received information indicating the received file was to be 30 blocks in length. Furthermore the receiver may receive information regarding the block size and the portion size . With further reference to two simultaneous transfers may occur e.g. using a first parallel data connection and a second parallel data connection . The blocks being received are shown in cross hatch. As shown the first block of the first portion portion block may be received at the same time as the first block of the third portion block . Rather than simply consecutively writing this data into memory as received the receiver may determine the appropriate location of each portion based on identification information associated with the block. For instance portion block may simply be written in the first allocated space in memory as it is the first block of data in the file. However portion block may be written into memory at a location corresponding to an offset . In this case the offset is an amount of memory corresponding to 16 blocks as 16 blocks of data appearing the in file before the appropriate location for portion block . Thus the receiver may begin writing portion block into memory according to the offset value thus allowing the blocks coming before portion block to be written in each blocks corresponding location when received. Each block of data received by the receiver may be written into the appropriate location in memory in this fashion.

Additionally data transfers using parallel transfer connections may support recovery mechanisms in the event that the transfer of a file fails due to any one of a number of failure conditions. For example a recovery file may be generated to track information regarding the status of the transfer. The recovery file may be updated with information regarding the status of the transfer at regular intervals e.g. every 1 second . As such in the event of an interruption of the transfer the recovery file may contain information that allows for recovery of the transfer from a known good portion of the transfer. In this regard various types of transfer interruptions e.g. network unavailability lack of network reliability system failures power interruptions etc. may be successfully recovered from a known good portion of the transfer without completely restarting the transfer.

As discussed briefly above the transfer of a file may be accomplished on a superblock by superblock basis. That is the transfer may fully complete the transfer of a superblock prior to initiating the transfer of another superblock. This may facilitate a reduction in the size of the recovery file required to track the status of the transfer. In one embodiment the recovery file may include data regarding the status of the transfer of individual blocks e.g. whether the block has successfully been transferred . For very large files e.g. on the order of a terabyte or more the recovery file may be excessively large because such a large file may include a large number of blocks. However using superblock by superblock processing a recovery file may be provided for each superblock. Thus the recovery file may be significantly smaller by storing data regarding the identity of the particular superblock corresponding to the recover file and the status of blocks within that superblock. As a superblock may contain only a relatively small portion of blocks in relation to the full file the recovery file may be relatively small by only storing data regarding which particular superblock the recovery file corresponds to and the status of blocks within the particular superblock.

A file that is transferred may divided into discrete blocks as described above. Thus in the event the data transfer is interrupted during transmission of a block the recovery file may contain information regarding which superblock is currently being transferred and which of the blocks of that superblock have been successfully transmitted. As the transfer may be carried out in a superblock by superblock fashion a determination may be made that all superblocks prior to the currently transmitting superblocks have been successfully transferred. Thus all previously transferred superblocks and all successfully transferred blocks of the current superblock may be retained in memory in the event of a failure condition. Any data comprising a partial block may be discarded. Thus when transmission is available again e.g. due to changed network conditions restoration of system power etc. the transmission may restart by requesting any non received blocks of the currently transmitting superblock based on information contained in the recovery file. As such when the sender and receiver are again capable of transferring data the process may continue such that any data belonging to a fully transferred block is retained despite the interruption in the transfer of the file. Any partial data received for a block may not be kept and any bits corresponding to the partially transferred blocks may be set to indicate the blocks have yet to be received. This allows for retention of the partially downloaded portion up to the last full received block. Thus an interruption to the transfer does not require completely restarting the file transfer which in the case of large files could add significant time to a transfer that is interrupted.

Furthermore in addition to the ability to transfer multiple portions simultaneously via multiple parallel transfer connections in one embodiment multiple superblocks may be transferred simultaneously using multiple connections as well. Each process transferring a superblock may be independent such that an independent recovery file is generated for each transfer of a superblock.

A configuration value may be provided e.g. in a configuration file to dictate one or more parameters used to determine if the process should be suspended e.g. due to network fidelity problems or system issues . For instance the configuration file may include a threshold value for a predetermined number of requests by the receiver that may be made without receiving a block before the transfer is suspended. In another example a threshold value for the bitrate i.e. bits per second of a transfer may be provided in the configuration file. The average bitrate for the process may be calculated after the transfer of each superblock and compared to the threshold value. In the event the calculated average bitrate for the superblock drops below the threshold value the process may be suspended. Alternatively the average bitrate may be calculated for the transfer of each block or each portion to determine whether the average bitrate has fallen below the threshold value. Furthermore in an embodiment the instantaneous bitrate may be calculated and compared to the threshold bitrate to determine whether the process should be suspended. In yet another embodiment a user may manually suspend a transfer. Further alternate examples of ways in which the process may be suspended are provided below. In any regard once the process has been suspended the process may remain suspended for a predetermined amount of time e.g. as determined by a user definable value until a user reinitiates the process or at some other predetermined event.

In one embodiment of the presently contemplated transfer when sending blocks over the high speed connection the sender may transmit each of the requested blocks on a cycle such that the cycle is repeated until all blocks of the portion have been received at the receiver. Contemporaneously the sender and receiver may be exchanging information via the high integrity connection regarding which blocks have been received at the receiver i.e. through scrutinizing the returned descriptor file . Upon receipt of each block at the receiver the descriptor file may be updated and sent to the sender. As the descriptor file will be a relatively small amount of data the time required to exchange descriptor files is relatively short. Thus once the sender receives the updated descriptor file indicating a block has been received each block indicated as received may stop being sent in the cycle of blocks being sent. This may continue until all blocks have been received.

Additionally the number of cycles the sender completes may be limited by a configuration value or may be adaptable based on the transfer of previous portions. For example a configuration value may dictate that each block for a first portion is attempted to be transmitted four times e.g. the sender will complete the send cycle of all blocks four times . If additional cycles are required the process may return an error message and suspend the transfer.

Alternatively or additionally each portion transferred may be used to dynamically adapt the number of cycles available for the next portion. For instance once the first portion is completely transferred the number of attempts in sending the block may be adapted for the next portion. For instance if all blocks were received at the receiver as determined at the sender by monitoring returned descriptor files after two cycles the number of cycles available for the next portion may be reduced e.g. to 3 or 2 cycles rather than the original 4 cycles . Furthermore if additional cycles are necessary to transfer the first portions the number of attempts per block for the next portion may be increased e.g. to 5 or more cycles prior to timing out . Furthermore a maximum value for the number of cycles may be established such that if the number of attempts per block reaches or exceeds the maximum value the process may enter an error state and be suspended.

For example in an embodiment where an eight bit descriptor file is exchanged the receiver may request the eight corresponding blocks of the portion. After the sender has sent all eight blocks e.g. completed one cycle the status of the descriptor file may indicate that all but the seventh block was received. Thus the next cycle may include sending only the remaining block that has yet to be received i.e. the seventh block . After sending the seventh block again e.g. competed another cycle the sender may still not have received a descriptor file indicating receipt of the seventh block. Thus the seventh block is sent by the sender until receipt is confirmed by way of the descriptor file or a predetermined number of attempts have been made.

Alternatively the timing associated with returning an updated descriptor file from the receiver to the sender indicating which blocks have yet to be received at the receiver may be dictated according to a configuration value e.g. a value in a configuration file . Default values may be set or the configuration for individual transfers may be modified as desired by a user. For instance the receiver may request all blocks associated with a received descriptor file as described above. The receiver may then wait for a defined duration as determined by the configuration file prior to returning an updated descriptor indicative of non received blocks. The duration the receiver waits may be dependent upon the number of blocks requested. As an example for an eight bit descriptor all eight corresponding blocks may be requested. The configuration file may dictate a certain wait period per the number of blocks requested thus the total wait may be eight times the configuration value of wait time per block. Once the descriptor file is updated and the non received blocks are requested the wait time for updating or returning the descriptor file may correspond to the number of blocks requested. For instance if all but three of the eight blocks were received the new wait time associated with the request for the three remaining blocks may be three times the configuration value of wait time per blocks.

Alternative regimes for timing when the receiver updates the descriptor file may be employed. Examples of such regimes may include but are not limited to setting a threshold value of blocks to be received prior to updating the file or updating upon some other trigger event such as a received message.

The foregoing may be used to transfer files between computing devices that are capable of communicating via a network or series of connected networks. One embodiment of such a system capable of parallel data transfer is depicted in . The system may include but is not limited to a number of computing devices including a server a laptop computer a desktop computer a computer terminal and a mobile computing device e.g. a cellular telephone a smart phone a tablet computer a PDA etc. . The computing devices of the system may be in direct communication with each other may communicate by way of a local area network a wide area network an Intranet or the like or may communicate via the Internet .

The use of a parallel data transfer according to the foregoing in the system may facilitate a number of benefits. For example large files may be exchanged between devices at high speeds while providing for high data reliability. For example where UDP and TCP connections are used the speed of data transfer may approach those experienced using a UDP connection alone and may provide similar data reliability to that experienced using a TCP connection alone. Thus the benefits of each protocol are maximized. In this regard a large amount of data may be exchanged between devices which allows for high speed connection and exchange of data between the devices .

The device may also include a network communications device e.g. a network card or the like in operative communication with parallel data transfer module that is in further communication with a network for communicating to another computing device.

While not shown in alternative embodiments may be provided wherein additional modules are provided modules discussed above are combined or additional communication is established between features. For example the parallel transfer module may be in direct operative communication with the memory . Additionally the functionality discussed below may be accomplished using more or fewer modules than those described and shown in .

In addition the device may execute a number of applications . These applications may provide a variety of functions to communicate data to and receive data. The applications may access the parallel data transfer module to facilitate transfer of data as controlled by the applications . Alternatively the parallel data transfer module may be a standalone application directly controllable by a user e.g. using a command line interface CLI or a graphical user interface GUI . In this regard while not shown in the device may also have input devices e.g. a keyboard mouse touch screen or other input device in order to allow interaction between the CLI or GUI and the user.

If accessed by another application the parallel transfer module may be accessible by way of a remote procedure call RPC may run as a Windows service existing in a component object model COM environment or distributed component object model DCOM environment may be controlled by a script or may be controlled by the application in some other appropriate manner e.g. some other object oriented environment . In any regard the parallel data transfer module may be accessed to utilize the parallel data transfer module to facilitate transfers of files via the network . For example a user may directly control the parallel data transfer module by way of commands entered into a CLI or a GUI. Alternatively the service may be controlled using a script application programming interface API RPC or the like to allow an application to utilize the parallel data transfer protocol to transfer data.

Table 1 illustrates a number of functions which may be used in conjunction with the parallel data transfer module . For instance the functions listed in Table 1 may be received from a CLI of the computing device . Each of the functions presented in Table 1 may also correspond to a feature provided by a GUI that allows for a simplified graphical interface so a user may access and control the parallel data transfer module . Alternatively the commands listed in Table 1 may be utilized by way of an API script RPC or the like such that applications utilize the parallel data transfer module to accomplish tasks or features associated with the applications . As used in Table 1 in represents an input parameter provided by a user whereas out represents an output received in response to a command. Additionally string is used to represent the form of the parameter is a character string and long is a long integer.

In addition to the foregoing the parallel data transfer module may be a standalone application executing on the device that is operative to control the transmission of files between the device and another device in the network. One embodiment of a GUI useful in controlling such an application is depicted in .

As can be seen in an authentication dialog box may be presented to a user. The authentication dialog box may include a selection for a server to which a connection is requested. The authentication dialog box may further include fields for a username and password. Thus access to the parallel data transfer module may be limited based on username and password authentication. Also in the GUI may include a transfer status pane and a detail pane . The transfer status pane may include three tabs. These tabs may be an active transfers tab a completed transfers tab and an error tab . In this regard active transfers may be shown under the active transfers tab in a list appearing in the transfer status pane . Completed transfers may appear in the completed transfer tab and transfers that have experienced an error may be listed under the error tab . Details for a selected transfer may be shown in the detail pane .

Additionally the GUI may include a toolbar containing several buttons. For instance a Put button and a Get button may be used to initiate Put commands and Get commands for file transfers as will be discussed in more detail with respect . Additionally a resume button may be provided to allow a user to resume a suspended transfer or a transfer that has experienced an error. A suspend button may be provided to suspend an active transfer. Also a priority up button and priority down button may be provided to manipulate the order in which a selected transfer is to be completed. A stop all button may be provided to suspend all active transport transfers.

With additional reference to a Put window may be presented to a user after selecting the Put button . The Put command allows a user to initiate a transfer of a local file to a remote machine. The Put window may include a file selector that allows a user to browse a local source in order to select files to add to the selected file window . Additionally a destination field may be provided that allows a user to enter a remote destination for the file transfer. A number of transfer options are provided including a throttle selector that allows the throttle speed to be selected for the transfer e.g. 100 of max 50 of max 25 of max etc. . Additionally a thread selector may provide a user the ability to select the number of threads e.g. parallel data transfer connections used to transfer a file. Additionally a transfer protocol selector may provided to selected protocol used to transfer the file. In this regard the transfer protocol selector may allow a user to select a transfer protocol used by a high speed connection and select a protocol to be used a high integrity connection.

A Get window may be presented to a user upon selecting the Get button . The Get command may allow a user to select a file located remotely to be transferred to a local location. They Get window may have a source file selector that allows a user to select files on a remote source for transfer to the local machine. A local destination field is provided that allows a user to specify the destination of the transfer. Additionally the transfer options described above with respect the Put window may also be presented in the gift window to allow user to control these options with respect to a file transfer initiated as a Get command.

The foregoing may facilitate advantages over prior systems and protocols used for data exchange. Particularly the foregoing may be useful when transferring large files between computing devices such that the large files are transmitted relatively quickly while assuring data integrity. Rather than utilizing a single protocol with the inherent advantages and drawbacks attendant to the protocol the foregoing discussion regarding parallel data transfer allows the advantageous features of two protocols to be realized. In turn the utilization of each protocol in a manner that allows for capitalization of the benefits thereof while mitigating the disadvantages of each protocol provides the consequent advantages of both protocols.

In addition to the foregoing disclosure modifications or alternative approaches may be used without departing from the scope of the currently contemplated parallel data transfer. For instance while the foregoing may describe a system where a destination device requests a portion of blocks from a source device it will be understood that a system may be provided where a source device initiates a transfer of a portion of blocks. Further it will be understood that these features may or may not correspond to Get and Put commands. That is a Get command may involve a destination device requesting data portions or may simply involve a destination device initiating a connection between the destination device and source device such that the source device initiates transfer of each portion. Similarly a Put command may involve a source device initiating transfers over a connection e.g. sending portions as a connection becomes available or may involve a source device initiating a transfer such that the destination device requests initiating of transfers of portions over a connection.

Additionally a parallel data exchange in accordance with the foregoing may be performed between a variety of computing devices without limit to those shown in . For instance the parallel data exchange may occur between two servers between a server and a remote computing device between a server and a mobile computing device etc. Furthermore additional devices may be incorporated into the system in order to accomplish a portion of the process discussed above. For example updated descriptors may be sent to a device which in turn communicates with the sender to notify the sender of the blocks that have yet to be received.

Further still the examples presented herein with regard to superblock size portion size and block sizes are not limiting. Accordingly any variation of sizes of superblocks portions and blocks may be used without limitation. Furthermore one or more of these divisions of the file may not be provided. For instance in one embodiment a file may not be divided into superblocks but rather the file may simply be divided into portions without grouping portions into superblocks.

Also additional protocols may be provided other than those to establish TCP connections or UDP connections. Without limitation some alternate protocols that may be used are Datagram Congestion Control Protocol DCCP Stream Control Transmission Protocol SCTP Resource Reservation Protocol RSVP Explicit Congestion Notification ECN Cyclic UDP Fast and Secure Protocol FASP Reliable User Datagram Protocol RUDP or other Transport layer protocols. Additionally known security protocols may be used in conjunction with the foregoing process. Also additional data integrity checks may be conducted e.g. redundant process checks for higher grade certainty of file integrity .

While the invention has been illustrated and described in detail in the drawings and foregoing description such illustration and description is to be considered as exemplary and not restrictive in character. For example certain embodiments described hereinabove may be combinable with other described embodiments and or arranged in other ways e.g. process elements may be performed in other sequences . Accordingly it should be understood that only the preferred embodiment and variants thereof have been shown and described and that all changes and modifications that come within the spirit of the invention are desired to be protected.

