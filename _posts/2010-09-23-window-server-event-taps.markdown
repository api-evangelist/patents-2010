---

title: Window server event taps
abstract: Methods, devices and an associated application programming interface are described that permits a user to register event tap routines (“ETRs”) with an application such as, for example, a window server application. Event tap routines permit events such as human interface device events to be processed at multiple points and in a manner not provided during normal window server operations. Event tap routines may effect passive or active event responses. Passive ETRs may merely record the occurrence of an event or the time between successive events without modifying or altering the event's processing sequence within a window server. Active ETRs, on the other hand, effect some programmatic response to an event. For example, active ETRs may modify the state of an event, delete the event, create one or more additional events or cause the event to be processed “out of sequence” by the window server application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08438580&OS=08438580&RS=08438580
owner: Apple Inc.
number: 08438580
owner_city: Cupertino
owner_country: US
publication_date: 20100923
---
This disclosure is a continuation application and claims priority to U.S. patent application Ser. No. 11 020 875 now U.S. Pat. No. 7 818 755 entitled Window Server Event Taps by Michael J. Paquette filed 22 Dec. 2004 which is incorporated by reference in its entirety.

The invention relates generally to graphically oriented computer operating systems and more particularly but not by way of limitation to a method and system for processing events in general and human interface device events in particular.

Most modern computer systems employ operating systems that support graphical user interfaces. Central to these operating systems is the use of a low level application referred to as a window server. One function of a window server is to receive annotate and route signals from external devices e.g. human interface devices such as keyboards pointer devices and tablets to the appropriate application e.g. an audio video or multimedia application . It will be recognized that most modern operating systems treat signals generated by human interface devices as events which are typically embodied as data structures or objects. In accordance with this view human interface devices generate input signals which are received by the operating system converted to an event ordinarily by a software routine referred to as a device driver and passed to the window server. The window server in turn associates each event with a given user or session through a series of processing steps and routes the event to the appropriate application.

This general architecture permits a software developer to customize an application s event driven interaction with a user. In accordance with one prior art approach for example a developer may use an Application Programming Interface API to obtain access to events immediately prior to their being delivered to a specified application. Event receipt may be used to trigger execution of a developer specified routine to effect the desired i.e. modified human interface device response. In accordance with another prior art approach all events sent to a window server may be intercepted and processed in accordance with customized developer routines to identify and extract those events for which specialized processing is desired.

One drawback to the former approach is that it limits event response customization to unique specified applications. One drawback to the latter approach is that it requires developers to develop custom software to receive and identify those events they wish to process and further to ensure that those events are subsequently sent to the operating system s window server for conventional processing. Another drawback to the latter approach is that it requires all applications executing in such an environment to communicate with the customized event screening software rather the standard window server application.

Thus it would be beneficial to provide a means for responding to human interface device events as they are processed by a window server on receipt input immediately prior to being routed to the appropriate application output and at processing points within the window server between its input and output.

The invention provides a method to process user interface events through the use of event tap routines ETRs . As used herein an event tap routine is a procedure that is invoked by one or more of a plurality of points during event processing by a controlling application such as for example a window server application. Event tap routines may effect passive or active event responses. Passive ETRs may record the occurrence of an event or the time between successive events without modifying or altering the event s processing sequence within a window server. Active ETRs may be used to effect some programmatic response to an event. In one embodiment the invention provides a method that includes receiving a user interface event from an operating system identifying the user interface event as belonging to at least one of a plurality of registered user interface event types determining the user interface event is associated with an event processing routine causing the event processing routine to process the user interface event and receiving a result from the user level event processing routine. Methods in accordance with the invention may be stored in any media that is readable and executable by a computer system.

In another embodiment the invention provides a user interface event application programming interface API including a function allowing a user to register an event processing routine at a specified one of a plurality of user interface event taps within a window server application wherein the registered event processing routine is associated with a specified user interface event type and is invoked when an event of the associated type is received by the window server application at the specified tap.

Methods and devices to process human interface device events are described. In the disclosed embodiments see applications utilize application programming interface API to register event tap routines ETR with window server application . Event tap routines permit events to be processed at multiple points e.g. tap to tap N and in a manner not provided during normal window server operations . Event tap routines which may also be referred to as event filter routines are separate from and not necessarily associated with the application to which the event is targeted. Illustrative applications include but are not limited to user level applications such as audio video and multimedia applications each of which may present one or more windows to the user. Illustrative human interface devices include but are not limited to pointer devices e.g. a mouse trackpad trackball and joystick keyboards control devices e.g. a front panel knob switch slider or button or a game s data glove throttle or steering wheel and display devices. As used herein events are user actions initiated through one or more human interface devices.

Event processing in accordance with the invention may be passive or active. Passive ETRs may for example merely record the occurrence of an event or the time between successive events without modifying or altering the event s processing sequence e.g. within window server . Active ETRs on the other hand effect some programmatic response to an event. For example active ETRs may be used to effect human interface device event responses that conform to Section 508 of the Rehabilitation Act of 1973 see 29 U.S.C. 794 a primary purpose of which is to ensure that electronic and information technology equipment purchased by Federal agencies is accessible to and usable by individuals with disabilities. Active ETRs in accordance with the invention may also change an event s type alter the processing sequence of an event by window server delete an event so that further processing of the event by window server is halted or generate one or more additional events that are then processed by window server .

The following descriptions are presented to enable any person skilled in the art to make and use the invention as claimed and is provided in the context of the particular examples discussed below variations of which will be readily apparent to those skilled in the art. Accordingly the claims appended hereto are not intended to be limited by the disclosed embodiments but are to be accorded their widest scope consistent with the principles and features disclosed herein.

As noted above ETRs are registered with window server through API one embodiment of which is defined in the section entitled Illustrative API of this disclosure. Registration permits a user to specify an ETR that is to be performed at one or more of a plurality of points taps during window server human interface device HID event processing. When an ETR registers it identifies one or more events to be observed an action to be performed e.g. a routine or function to execute and indicates whether the ETR is passive or active. In one embodiment routines may be designated to run when an event is 1 received and accepted by window server a HID type event 2 prior to being associated with a specific session or user a session type event 3 after being associated with a specific session or user an annotated session type event and or 4 immediately prior to being routed to a target application a connection type event.

Referring to the general operation of window server in accordance with the invention is illustrated. As events are received by window server a first check is performed to determine if the event is associated with a registered HID event type. If it is HID ETR is performed. During continued window server event processing blocks through one or more additional checks may be made and additional ETRs executed block . Prior to routing an event to its targeted application window a final check may be made to cause application and or window specific processing to occur via ETR . One of ordinary skill in the art will recognize that the multiple event tap architecture of is applicable to not only the operation of window server but also to messages transmitted between various applications operating system or user level applications. In a MAC OS environment for example events may be generated by one application and sent to another application by way of Apple events using AppleScript. AppleScript is a registered trademark of Apple Computer Inc. of Cupertino Calif. 

A specific embodiment of window server as designed and implemented for the MAC OS X operating system is illustrated in . MAC OS is a registered trademark of Apple Computer Inc. of Cupertino Calif. As events are received each is time stamped and checked to determine if it is consistent with the current state of the computer system that is not spurious block . Illustrative HID events include but are not limited to keystrokes mouse movements and or clicks trackpad movements and or clicks tablet events scroll wheel actions computer system power switch activation suspend and resume actions associated with a specific application and or process computer system sleep and wake events display brightness changes volume control changes and timer activations. That is substantially any user interface input event.

A check is then made to determine if at least one HID type event ETR has been registered with window server block . If a HID ETR has been registered the YES prong of block the appropriate HID ETR is invoked block . HID ETR represents one or more registered ETRs each of which may have its own callback routine to effect its desired action. In one embodiment each event is presented to the registered ETR as an opaque object referenced by a number of keys to return an appropriate value. If an ETR s callback routine fails to return cleanly the ETR associated with the callback function is disabled. This can happen for example if the callback function raises an exception rather than returning. The affected application may re establish an event tap after a timeout period has expired. On completion of the one or more HID ETRs block or in the event no HID type ETR has been registered the NO prong of block the overall state of the user interface is updated block . Acts in accordance with block include for example moving the displayed cursor s position or presentation and updating the state of any user interface element e.g. windows and applications . In some operating systems HID events A from for example tablets are input to window server at block . Once admitted to window server events A may be processed in accordance with any remaining event tap check e.g. at blocks and or .

Next a check is made to determine if at least one session type event ETR has been registered with window server block . If a session ETR has been registered the YES prong of block the appropriate session ETR is invoked block . It will be recognized that a session is that collection of applications and processes associated with a single user login. Following the acts of block or when no session type event ETR has been registered the NO prong of block the current event object is annotated to for example identify the window and connection e.g. owner application associated with the event block . A check is then made to determine if at least one annotated session type event ETR has been registered with window server block . If an annotated session ETR has been registered the YES prong of block the appropriate annotated session ETR is invoked block . Following the acts of block or when no annotated session type event ETR has been registered the NO prong of block the current event object is routed to its associated connection block . If at least one connection type event ETR has been registered with window server the YES prong of block the appropriate connection ETR is invoked block . Following the acts of block or when no connection type event ETR has been registered the NO prong of block the current event object is delivered to its application process block .

In one embodiment when an event is passed to an ETR window server continues to be responsive to remote procedure calls. In addition the ordering of events is maintained. That is events not being filtered events processed via the NO prongs of blocks or are not permitted to pass earlier events which are being filtered events processed via the YES prongs of blocks or .

As noted above and detailed in the section Illustrative API each ETR may be passive or active. If the ETR is passive it does not generate any side effects. If the ETR is active its callback routine may be used to effect any desired action. For example active ETRs may pass an event back to window server unmodified e.g. at or modify an event discard an event or create one or more additional events that are inserted in window server processing at any specified tap point e.g. at and or .

For security reasons in one embodiment keyboard events are not routed to any event tap other than the HID type tap block when secure text input is active. It will be recognized that secure input is a mode of operation that prevents a program from reading the text input or keyboard events which are directed to the foreground or currently active program. Secure text input is typically used for entering passwords and similar sensitive data that other programs should not see. In addition a notification of secure input being active may be posted through for example an API. For the same reasons if an ETR modifies an event so as to make it a keyboard event that event will not be passed to any further taps on it s way to its associated application while secure text input is active. It will be recognized that HID type ETRs or taps see block have access to events from all sessions and for all users. Thus some embodiments may restrict the registration of HID type ETRs to the super user or administrator e.g. the root user . In contrast session taps e.g. blocks and process events for only a specific user. Accordingly registered ETRs for these event types may be placed under the same security constraints as the session owner. In another embodiment an emergency override key sequence not likely to be encountered by accident is provided to disable all active taps. This will allow a user to regain control over a window server in which an ETR has disrupted normal event flow.

One benefit of the invention is that it provides a user with the ability to customize an application s response to a human interface device event at multiple locations within a window server s processing scheme. Another benefit of the invention is that it provides an easy to use API to facilitate the registration and revocation of ETRs. Yet another benefit of the invention is that device event response can be passive or active where an active response can include the modification or deletion of the triggering event or the creation of one or more additional events. Still another benefit of the invention is that techniques in accordance therewith allows the addition of system wide behaviors in response to input events. Such behaviors may be added by a third party e.g. software vendor without modifying the operating system or the operating system s window server application. Modified system wide behaviors may include support for novel user input methods or the addition of specialized feedback in response to input events such as sound or tactile feedback for example.

Various changes in the components and in the details of the illustrated operational methods are possible without departing from the scope of the following claims. For instance the illustrative system of window server is illustrated as being a monolithic application. This is not necessary. In addition acts in accordance with may or may not incorporate the ability to receive events from external devices such as for example tablets denoted as element A in . Further more than one event tap routine may be registered at any given tap location e.g. and in and that multiple tap routines at multiple tap locations may simultaneously be registered and active. It will also be recognized that acts in accordance with may be embodied in computer software that such software may execute at the kernel protected the user unprotected level or a combination of kernel and user levels within an operating system. For example window server operations identified in at elements and may be performed by computer software executing at the kernel level while individual event tap routines or more precisely ETR callback functions may operate at the user level. In another embodiment events see may originate from an application other than the operating system or an external device. For example one of ordinary skill in the art will recognize that Apple Events and AppleScript may be created and sent by a first application to a second application.

It will also be recognized that computer programs may be executed by a programmable control device. A programmable control device may be a single computer processor a special purpose processor e.g. a digital signal processor DSP a plurality of processors coupled by a communications link or a custom designed state machine. Custom designed state machines may be embodied in a hardware device such as an integrated circuit including but not limited to application specific integrated circuits ASICs or field programmable gate array FPGAs . Storage devices suitable for tangibly embodying program instructions include but are not limited to magnetic disks fixed floppy and removable and tape optical media such as CD ROMs and digital video disks DVDs and semiconductor memory devices such as Electrically Programmable Read Only Memory EPROM Electrically Erasable Programmable Read Only Memory EEPROM Programmable Gate Arrays and flash devices.

The following illustrative embodiment of an Application Programming Interface API in accordance with the invention is applicable to the Apple OS X operating system. Apple is a registered trademark of Apple Computer Inc. of Cupertino Calif. 

The CGEventSource is an opaque representation of the source of an event. This API permits the user to obtain a CGEventSource from an event and to create a new event with a CGEventSource. One typical usage would be to take the event source from an event entering the filter ETR and to use that source for any new events created as a result of the received event. This has the effect of marking the events as being related.

The CGEventRef object may be created or copied retained released and modified. The object provides an opaque representation of one low level hardware human interface device event.

This API provides the ability to create a NULL event or to create specialized events reflecting a state specified as parameters to the creation functions.

CFRetain and CFRelease may be used to retain and release CGEventRefs. A set of type codes accessor functions and data tags are defined to permit access and modification of data within CGEventRefs.

Tablet devices may generate mice events with embedded tablet data or tablet pointer and proximity events. The tablet events as mouse events allow tablets to be used with programs which are not tablet aware.

Additional low level functions provide access to specialized fields of the events include the following.

The CGEventSetPointValueField and CGEventGetPointValueField only works on fields capable of holding point data. The other functions work on any other field in the event record performing the appropriate type conversions and range clamping automatically.

Additional keys and values found in mouse events including the OtherMouse events include the following.

Tablets may generate specially annotated mouse events which will contain additional keys and values. Mouse events of subtype CGEventMouseSubtypeTabletPoint may also use the tablet accessor keys. Mouse events of subtype kCGEventMouseSubtypeTabletProximity may also use the tablet proximity accessor keys.

Additional keys and values found in tablet pointer events and in mouse events containing embedded tablet event data include the following.

Additional keys and values found in tablet proximity events and in mouse events containing embedded tablet proximity data 

A function registers an event tap taking a pointer to the program s tap function also referred to as a callback routine or function and an arbitrary reference to be passed to the tap function and returning a CFMachPortRef the program can add to the appropriate run loop using CFRunLoopAddSource . Taps may be placed at the point where HIDSystem events enter the server at the point where HIDSystem and remote control events enter a session at the point where events have been annotated to flow to a specific application or at the point where events are delivered to the application. Taps may be inserted at a specified point at the head of pre existing filters or appended after any pre existing filters. Taps may be passive event listeners or active filters. An active filter may pass an event through unmodified modify an event or discard an event. When a tap is registered it identifies the set of events to be observed with a mask and indicates if it is a passive or active event filter. Multiple event type bitmasks may be OR ed together. Releasing the CFMachPortRef will release the tap. The CGEventTapProxy is an opaque reference to state within the client application associated with the tap. The tap function may pass this reference to other functions such as the event posting routines.

Events being routed to individual applications may be tapped using another function. CGEventTapCreateForPSN will report all events being routed to the specified application.

A function to post events from a tap is provided. The events are posted to the same points that an event returned from an event tap would be posted to. If an event tap posts new events the new events enter the system before the event returned by the tap enters the system. This order may be changed by explicitly posting the filtered event along with new events in the desired order and then returning NULL from the callback. Events posted into the system will be seen by all taps placed after the tap posting the event.

Functions to post events into the system at various points are provided. Each event posted by these functions enters the system at a point immediately before any taps instantiated for that point and will pass through any such taps. This mechanism permits an external process to establish an event routing policy for example by tapping events at the kCGAnnotatedSessionEventTap and then posting the events to the desired PSN.

