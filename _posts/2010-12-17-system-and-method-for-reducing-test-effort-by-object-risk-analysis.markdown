---

title: System and method for reducing test effort by object risk analysis
abstract: A system, computer readable medium, and method for automatically testing computer objects affected by an update package. The exemplary method may compare computer objects/instances in an update package with those of the installed version of the computer application. A set of computer objects that have changed in the update package as compared to the installed version may be generated. The changes to each of the computer objects in the set of changed objects may be analyzed to determine if an automated test is related to the changed object. If an object has a related automated test assigned to it, the object may be placed in a separate list for testing. The automated tests of the changed objects in the separate list may be organized into a test plan. The automated tests may be executed according to the test plan. The system may have servers and computer processors to implement the method.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08954930&OS=08954930&RS=08954930
owner: SAP SE
number: 08954930
owner_city: Walldorf
owner_country: DE
publication_date: 20101217
---
The present application is related to commonly assigned co pending U.S. patent application Ser. No. 12 847 211 the entire contents of which are incorporated herein by reference.

A factor in the total cost of ownership TOC in the lifecycle of a software application is the testing of changes to software applications e.g. regression tests . Typically whenever an update is made to a software application the various processes supported by the software application are checked for consistency e.g. checked for possible coding conflicts between processes that provide the functionality of the software application . Examples of updates may include software patches support packages enhancement packages i.e. new versions of the installed software modifications of the software or the addition modification deletion of separate customer software running in the same system e.g. software of another vendor .

A software application may generate during execution a collection of data that may affect computer objects that provide functionality or data to the various processes. For example the generated data may cause run time errors system errors and the like. Risk of errors and faults may arise whenever a software application is modified. In order to ensure the correctness of the running processes it may be necessary to perform and repeat tests on the processes of the software application. Each repeated test e.g. after each modification may need to be performed on the entire system which may be an extremely time and resource consuming operation. Alternatively risk based subsets of the processes may be defined and the tests may be directed to only some of the subsets e.g. core functions of the processes. However these risk based subsets typically only relate to the processes known to be critical with no regard for what computer objects were or were not affected by the modification. For example many computer objects may be negatively affected i.e. may cause run time errors and failures but belong to processes deemed less critical and therefore may not be tested. Further many computer objects may be wholly unaffected by a change yet belong to a core function and thus may be needlessly tested. A critical process can be a process which would cause a severe impact on the customer s core business if it is not running as expected.

There already exist analysis tools capable of determining what computer objects are affected by which processes. Known analysis tools such as the Business Process Change Analyzer which is part of the SAP Solution Manager application may compile a list of associations between the various computer objects and various processes for example as described in the above referenced commonly assigned co pending application. The above referenced related application may include embodiments that provide calculations of regression test scope that optimizes the test effort by reviewing criticality attributes of the computer objects and processes affected by the update packages.

The inventors have recognized the need for tool that provides automated testing in response to the identification of different criticality attributes of the affected computer objects and processes.

Embodiments provide a method for automatically testing computer objects affected by an update package. The exemplary method may compare computer objects in an update package with those of the installed version of the computer application. A set of computer objects that have changed in the update package as compared to the installed version may be generated. The changes to each of the computer objects in the set of changed objects may be analyzed to determine if an automated test is related to the changed object. If an object has a related automated test assigned to it the object may be placed in a separate list for testing. The automated tests of the changed objects in the separate list may be organized into a test plan. The automated tests may be executed according to the test plan.

In addition to identifying the criticality level of each process A E and computer object A G a separate list of processes and or computer objects affected by a change may be compiled. For example in an example update stored in the data storage may for example alter the functionality of computer object A and computer object D. The exemplary update package may include a list of the computer objects e.g. A and D which are modified by the update package or a list may be automatically constructed by the application after analyzing the update. Once there is a list of computer objects that are modified e.g. A and D a list of processes A E affected may be constructed. In the example computer object A may only be used by process A so process A may be added to the list and no other with regard to computer object A. Computer object D is used by process and process C which are therefore both added to the separate list of potentially affected processes. This separate list may then define the total set of processes and computer objects that are to be tested. In other example embodiments a list of affected computer objects may be determined. For example here computer objects A to E are all within the test scope since the potentially affected processes A to C use each of them. It may be noted that computer objects B C and E are known to work properly since these computer objects were not modified in any way. However they may ought to be tested in the context of the processes e.g. A that included a modified computer object to ensure they still function as expected within the context of the overall processes. The list may also limit testing to the relevant processes e.g. those processes that call a changed computer object.

The process of compiling the list may be described in more detail with reference to . illustrates a flowchart of an exemplary process according to an embodiment of the present invention. The process may include at step comparing the processes and computer objects of the update package to those in the installed version.

As explained above the system may identify computer objects that have been changed and the extent of the change to the computer object. For example the update to a computer object in the update package may simply be additional developer comments that are required for example for quality assurance purposes. The comments may in no way affect the operation of the computer object. Testing of this updated or changed object may not be necessary. Accordingly the computer object with only comment changes may not be flagged as changed. Meanwhile another computer object may have extensive updates that affect the functionality of the computer object. This object may be flagged as an updated computer object in comparison to the installed version of the computer application. Alternatively the flagging of a computer object may be determined by the type of the computer object. For example computer objects may have a type such as data or coding which may indicate that the object interacts with other objects or not at all. Other types may be for example text or messages to be presented to the end user data dictionary objects i.e. definitions of meta data or user interface metadata that may describe how an end user screen may look. If the object is of the type that does not interact and changes to it do not adversely affect other objects then testing of the object may be unnecessary. Additionally the object instance may be relevant to whether a computer object should be selected for automated testing. For example an object instance may be the current object itself and not it s type. Depending on the usage of the object in the context of the application any change to the object might be uncritical. The criticality of the object may be determined by the usage of the objects number of usages the type of usages e.g. in how many different processes the object is used or by how many industry solutions the object is extended and the context on which they are used critical or uncritical process .

The updated computer objects that are flagged by the system may be added at step to a set of changed objects that may be generated by the process . Either as the computer objects are added to the set of changed objects or after all changed objects have been added to the set of changed objects at step the changed objects in the generated set may be analyzed to determine if an automated test is related to the specific changed object. An automated test may be related directly to the changed computer object or may be related to the changed object because the specific changed object under analysis is dependent upon another changed object that has a directly related automated test. Alternatively or in addition the changed object may be analyzed based on criticality. Criticality may have criteria such as for example the type of object the specific object instance and the type of change which has been applied to the specific object that is analyzed. An example of an object type may be source code objects that may be more critical than documentation objects. An example of an object instance i.e. usage may be a specific source code object which may be used by only a very few processes. This specific source code object may not be considered as critical as a source code object that is used by many business processes. Another may be a type of change such as a change to a source code object where only some comments are added. This type of change may not be as critical as a change for example where a large number of lines of code are replaced. Upon a determination that the computer object does not have an automated test related to it the computer object may be deleted at step from the set of changed objects. The deletion of the changed object from the set of changed objects may optionally at step be confirmed by a graphical user interface that receives a confirmatory input by a user. At step it is determined if all changed objects in the set of changed objects have been analyzed. If not the process returns to step to analyze the next changed object in the set of changed objects. Otherwise the process continues to step where the automated tests for the set of changed objects are organized into an efficient test plan and at step the tests are executed according to the test plan so that the computer objects and related processes are tested automatically by the system. Although the process is explained with a concentration on determining whether an automated test exists for all relevant objects and performing all these tests. In addition all relevant objects which have to be tested but which are not covered by an automated test need to be still included in a list and have to be tested manually by testing the effected processes. So at the end there may be two lists of tests created the automated tests which cover one part of the changed objects and a list of processes which need to be tested manually to cover the other part of the objects. Although described with reference to computer objects the process may be applied to computer processes such as processes A E of for example.

Modification to current analysis systems may require the addition of application programming interfaces API to allow the evaluation of the computer objects and automatic object tests. As illustrated in the system may include the analyzing application and application programming interfaces API and API. The analyzing application may receive as inputs data such as a list of attributes related to each of the computer objects and processes of the installed version of the software under analysis and data such as a list of attributes or change flags related to each of the computer objects and processes of the update package for the software. The analyzing application may process the data from the installed version and the update package . The analyzing application may call an API during the analysis of the update package. For example API may be hosted in a server and upon execution of the analysis step in may determine if one of more automated tests are related to or assigned to the computer object under analysis. The API may use an object identifier to identify whether any automated tests are related to the computer object and return an indication for example of true if a related automated test is available or false if an automated test is not available for the computer object. The computer objects identified as having a related automated test may be stored in a list. The list of computer objects to be tested may be turned over to a test management tool. The list may be provided via another API API that retrieves the list of objects and triggers the test of these objects by a test system connected to the analyzing application . The list of computer objects may be the input for the API from the analyzing application and the API may receive the results of the tests via the analyzing application from the test system .

The tests triggered by API may comprise either a unit test or a full test context which tests are administered may be dependent on the object type. Unit tests provide a very simple test of objects with a clear interface e.g. function modules . In more detail an unit test may be referring to an object with a clearly defined interface and no side effects when tested. So the object can be for example tested automatically by providing a set of input parameters executing the object and checking whether the output matches the expected output. When an object is referring to its contexts during execution e.g. any state of data in a database a simple unit test may not be feasible. Alternatively the full test context framework may fully simulate the context in which the object is normally executed.

It should be understood that there exist implementations of other variations and modifications of the invention and its various aspects as may be readily apparent to those of ordinary skill in the art and that the invention is not limited by specific embodiments described herein. Features and embodiments described above may be combined. It is therefore contemplated to cover any and all modifications variations combinations or equivalents that fall within the scope of the basic underlying principals disclosed and claimed herein.

