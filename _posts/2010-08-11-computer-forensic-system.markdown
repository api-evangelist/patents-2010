---

title: Computer forensic system
abstract: A method for processing, analyzing live and off-line physical memory in order to determine the presence, and initiate the removal, of malware from the system. The internal structures within the host operating system, the drivers, and the user-space executables can be utilized to self-verify the integrity of the processes, their related structures, and the binary execution paths residing on the system. Additionally, these same characteristics are employed for use in comparison with other baseline malicious and benign datasets as well as datasets from live systems to automatically identify malware and remove it from a targeted computer system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08584241&OS=08584241&RS=08584241
owner: Lockheed Martin Corporation
number: 08584241
owner_city: Bethesda
owner_country: US
publication_date: 20100811
---
Current anti virus or the more general anti malware software systems are fighting a battle with malicious intent software i.e. malware that has previously been largely unwinnable. The current systems focus on inspecting and alerting upon known or weakly deduced methods that malware authors and developers are constantly tweaking. The capabilities of current anti malware systems to dynamically change their inspection techniques outside of simple signature updates are limited once installed on a host computer system in the field. This limitation creates numerous false positives and false negatives. True run time dynamic response to changing threats is not an advantage of current anti malware software. These current anti malware systems oftentimes function with only moderate success until they completely fail due to a disruptive technology that is introduced by the malware developers. Until this new disruptive technology is observed reverse engineered and understood by the anti malware developers the anti malware s triggers and subsequent counter measures are bypassed.

Ultimately anti malware will continue to fail so long as it functions within the current paradigm. Two primary characteristics condemn anti malware systems to failure. These characteristics are that it 1 operates in a known manner and 2 operates from within the same context as the malware. Anti malware functions in a known manner because there are operating system rules that it must abide by in order to avoid interfering with healthy system operations and in some cases in order to be approved by the operating system s manufacturer. These rules do not have to be followed by malware and oftentimes depending upon the malware s ultimate goal are stretched to the functional limit. Anti malware also operates from within the same context that the malware operates. The issue of context does not necessarily signal a horrible practice it is arguable that this must occur at some level in the current paradigm. However by combining that anti malware toolsets operate in a largely known way function with the same level of access and act upon the same objects and structures within the system anti malware has not been able to actively attack malware. This is because the anti malware is trying to retain its integrity while attempting to discover malware characteristics.

A paradigm shift must take place in order to be able to detect and remove malware from a computer system. There must be a shift in the strategy of attacking malware from a different context by employing a dynamic system.

In addition to the processes associated with the operating system intentionally loaded into HDD of target host computer system of and in addition to the various executable ancillary and data files the volatile memory may contain one or more malware processes or paths of malicious code execution such as injected or patched dynamic linked libraries DLLs functions drivers etc. . Various means by which malware can be introduced into computer systems are well known and include computer viruses Trojan horses rootkits and the like. The modes of transmission may include any of the paths by which the target host computer system interacts with its environment including network connections accessed by a network interface disk drives and the like. However introduced the malware processes and malicious code paths may become resident within volatile memory and be executed by the processor . When resident only within RAM such malware can be countered by a rebooting the target host computer system to thereby halt power to the RAM which without power and under normal conditions will effectively clear the contents of RAM of any discernible execution paths and b then re loading the RAM with the benign or acceptable processes stored on HDD .

Under some conditions the malware processes may also become resident on HDD of target host computer system . This by itself is not necessarily deleterious as the malware may adversely affect the operation of the target host computer system only when it becomes resident in RAM where it can interact with the benign or acceptable processes. However when the target host computer system is rebooted with malware resident on the HDD the malware is likely to be re introduced into the RAM . Under these conditions the malware can now persist on the target host computer system during periods when the RAM cannot maintain its state or the contents of its memory e.g. when it loses power during events such a reboot or power cycle of the target host computer system . In cases such as these rebooting the target host computer system may not effectively deal with the malware infection. When malware is introduced into the volatile memory it may become intermixed with or infect one or more of the benign acceptable or good processes.

Security programs such as those provided by McAfee Norton Webroot and others are often used with computer systems to counter various types of malware such as spyware and viruses. Such security programs are intended to monitor information introductions to the computer by many potential paths and to sequester information identified as malware render it harmless or at least to warn of the presence of malware.

It is well known that the providers of security programs are at a disadvantage relative to the developers of malware. This disadvantage results from the difficulty of anticipating what new malware will arise and the characteristics that might render the malware amenable to detection and countering. In effect the malware protection available to the operator of a computer such as target host computer system of runs behind the development of security countermeasures. Thus there is always the possibility if the target host computer system is made available for the introduction of information or data that malware will be introduced. It is very desirable considering the possibility that the security programs may be only partially effective that the operator of the target host computer system of allow only data from a trusted source to be introduced into the target host computer system . While some anti virus software might employ anomaly based measures that the companies may claim will help detect future malware these anomaly based measures are simply rulesets which can be circumvented after careful study of the governing rules.

Notwithstanding the strict use of trusted information sources and faithful adherence to up to date security programs and practices introduction of malware into computer systems is a fact of life. The introduction of malware can be highly deleterious potentially allowing a the computer system to be taken over and used as part of a botnet a network of malware components controlled from a command entity for propagating malware or undesired communications such as spam to other computer systems b revelation of sensitive personal data such as bank account numbers and passwords and in the context of national security loss or corruption of sensitive technical strategic or tactical information.

Malware in order to perform its malevolent function when it infects a computer system must be accessible by the CPU or similar processing unit located on the system which typically means that it must be resident in RAM at some point in its execution. Malware that takes up residence in RAM of a computer must have by necessity bypassed all of the identification steps mandated by the resident security program or it must have been confirmed even mistakenly to run by the user of the computer system. The presence of malware may become obvious or be suspected due to untoward operation of the computer. The response is usually to run an anti malware program in a scan mode in which all or most of the processes address spaces in HDD and RAM are inspected for recognized patterns and or behaviors. However it may well be that the malware having already escaped detection by the security program on its way to execution may again escape detection during a scan or even ongoing examination by the security software. In some cases malware once executing may attack the security software s ability to detect certain parts or capabilities of the malware. At this point there may be no remedy except to re format the HDD and re load it with the acceptable or benign programs so as to be able to continue with its use.

Some malware may not make its presence known or suspected by refraining to adversely affect the appearance of normal operation. For example a computer that has been acquired for a botnet may draw unwanted operator attention if the takeover gives overt indications such as execution latency or catastrophic application or operating system failure. Thus such malware attempts to hide its presence on the target host computer system. Since there is no overt indication of infection with malware no countermeasures may be taken and the infected target host computer system may continue to operate apparently normally except that it may run the benign programs and processes with increased yet unnoticeable latency as some of its computing power is diverted to fulfilling its malicious tasks. Due to operating systems behemoth size and inherent latency for non malicious reasons there often is little way for the operator to determine or notice any malware attributable delay.

Increasing attention has lately been directed towards forensic examination of computer systems. United States patent application 2005 0204205 published Oct. 13 2005 in the name of Ring et al. describes a method for finding malicious modules processes and system call patches in a computer system and restoring the system to an uncompromised state. In the method of the Ring publication various analyses are performed including system call table address correlation module linked list address correlation user space and kernel space process view correlation network port binding verification and user and kernel space file view correlation. These analyses are performed on each inspected host computer system and the comparisons are made with regards to a single host computer system. Ring s analyses state that it senses anomalous operating system behavior when activity in the operating system deviates that is fails to adhere to a set of predetermined parameters or premises. Not all malicious software affects systems in ways detectable by Ring s analyses.

Current methods of detection by anti virus and anti malware entities are reaching a point of diminishing return because the depth and breadth of inspection can only be so extensive before noticeable overhead is produced resulting in usability and functionality issues that become unbearable for users.

Numerous methods can be used to analyze the physical memory of a target host computer system. Before analyzing the contents of the physical memory however it must be captured or acquired. There are two primary modes or times at which physical memory capture can occur namely live and off line. Live memory capture occurs on the target host computer system and runs in the context of that operating system. Off line physical memory capture occurs when the target host computer system s physical memory is not in operation and the physical memory has been stored in a binary file such as in the case of a paused VMWare image or a computer in a state of hibernation . This binary file is then moved from the target host computer system e.g. target host computer system of and is analyzed on another host computer system such as analysis host computer system of . Access to live physical memory can be performed through introduction of physical hardware or through software based methods such as by employing Application Programming Interfaces APIs well known in the art. The copying and transfer of the off line physical memory binary file can be performed in several ways. The target host computer system way is through an application that uses Application Programming Interfaces APIs to access and copy the physical memory to a binary file. This binary file is simply an on disk copy of what is stored in physical memory. In the binary file format we can now treat it as any typical system file and copy move read or edit the data. A second way is to obtain physical memory binary files that have been created by virtual machine technologies or by the target operating system such as hibernation files. Moving the data from the target machine can be performed in numerous ways as well. Using any method the data can be transferred as by path of from the target host computer system to the analysis host computer system . Path can involve using human interaction and removable media such as CDs floppies etc. a direct link such as a null modem or a network connection such as in order to transfer the data to the analysis host computer system .

Recent strategies for removing malware from memory have typically focused on removing injected data structures from linked lists or repatching binary code that has been changed by the malware. While these methods are sound the areas that they typically address do not cover the full spectrum of malware targeted methods. As malware detection becomes increasingly proficient malware s methods of hiding itself from discovery improve. This improvement typically means diving deeper into the lower levels of the operating system or taking advantage of increasing levels of indirection. As described earlier it is increasingly difficult to perform these inspections by anti virus malware software during run time execution of the applications due to the increased overhead operations cost. Improved apparatus and methods are desired for cleansing malware from computer systems.

A method is disclosed for cleansing malicious data from a memory of a computer. In the method attributes are extracted from a set of training data including benign non corrupted acceptable training data and or malicious training data. Attribute vectors are formed from the attributes extracted from the training data. The attribute vectors formed from data of an unknown type contained in the memory are compared with the attribute vectors formed from the training data to determine which ones of the attribute vectors formed from the data contained in the memory are similar or dissimilar to the attribute vectors formed from the training data. The data of the unknown type is deemed malicious if its attribute vectors are similar to the attribute vectors of the malicious training data and or if its attribute vectors are dissimilar to the attribute vectors of the benign non corrupted acceptable training data. The data of the unknown type deemed malicious is removed from the memory of the computer.

A system is further disclosed for cleansing malicious data from a memory of a computer. The system comprises one or more processors executing instructions for extracting attributes from a set of training data including benign non corrupted acceptable training data and or malicious training data. The one or more processors execute further instructions for forming attribute vectors from the attributes extracted from the training data. The one or more processors execute further instructions for comparing attribute vectors formed from data of an unknown type contained in the memory to the attribute vectors formed from the training data to determine which ones of the attribute vectors formed from the data contained in the memory are similar or dissimilar to the attribute vectors formed from the training data wherein the data of the unknown type is deemed malicious if its attribute vectors are similar to the attribute vectors of the malicious training data and wherein the data of the unknown type is deemed malicious if its attribute vectors are dissimilar to the attribute vectors of the benign non corrupted acceptable training data. The one or more processors execute additional instructions for removing from the memory of the computer the data of the unknown type deemed malicious.

Analysis host computer system includes hardware and an operating system S that includes a set of drivers and set S of software. Hardware includes a CPU which interacts with HDD and RAM . Driver set includes a network driver and a human interface driver . Software set S includes an attribute vector analyzer interacting with an attribute vector database and also includes an attribute vector extractor and aggregator and a RAM replica designated . A hardware RAM importer interface a network interface and a human interface interact with human interface driver and network driver to produce a RAM replica contained i.e. accessed through physical memory interface .

One of ordinary skill in the art will appreciate that in single host system embodiments the host computer system will also be the analysis host computer system .

In a data path extends from hardware RAM exporter interface to hardware RAM exporter interface a data path extends from network interface to network interface and a data path extends from human interface to human interface . On analysis host computer system a data path extends from the attribute vector analyzer to the target host computer system s cleanser driver to transmit information relevant to the cleansing component. On the target host computer system the attribute vector analyzer communicates with the cleanser through a data path in order to transmit the cleansing information as needed.

A method for detecting and removing malicious software from the target host computer system of of the system will now be described. There are several different operational paths that are contained within the system . Depending upon when in the system s execution a decision block is reached either a user or the environment determines the subsequent steps. These operational paths such as what is shown in and allow for a wide range of paths through the analysis system each path having its own benefits or supplementing the others.

Referring still to and also to the flow chart of method begins at an Initiate Analysis of Target Host block and flows to a block which represents applying user inputs if necessary. Block represents the accessing of the physical memory of the target host computer system . A decision block selects offline or online processing. Online processing is reached by the NO output of decision block and offline processing is reached by the YES output. If offline processing is selected the method leaves decision block by the YES output and flows through blocks and to arrive at a decision block . Block represents the outputting of the physical memory to a binary file and block represents the accessing of the physical memory. The binary file representation of the physical memory is a bit by bit copy of the physical memory to a file. In the online processing path the method flows directly to decision block . Decision block determines whether a target for the analysis has been specified. A target is any section of the target host computer system that contributes to the execution of the malicious software and that once removed will allow for the target host to continue functioning properly. A description of the generation of the target information or known state attribute vectors will be described further on with reference to the flow chart of . If a target for the analysis has been specified the method of flows by way of the YES output to a block which represents a search of the target host s physical memory through the physical memory interface for the specified artifact. The physical memory interface presents the physical memory i.e. elements or which make up the physical memory as an interface to the anti malware system so that the same general analytical process can be implemented whether performing an online or offline analysis of the targeted host s physical memory . If no target for the analysis has been specified the method of flows by way of the NO output of decision block to a block . Block represents a search through the physical memory for the next process or binary execution path. This search iterates around a loop including blocks and so long as a process or binary execution path is not found as decision block routes the method to its NO output and return logic path . If a target for the analysis has been specified in block or if loop finds a process or binary execution path the method is redirected by way of the YES output of decision block and flows to a block . Block represents pre processing of the artifact found by block or by the loop to form an attribute vector. Attribute vectors are structures created during the pre processing stage that describe processes binary execution paths their characteristics as well as the relationships between these attributes the operating system and or the user. To explain it in another way an attribute vector is the n dimensional vector representation of a process s or execution path s characteristics or attributes where n is the number of user desired defined characteristics. When the attribute vector is pre processed as represented by block the method flows to a decision block which determines if the preprocessed attribute vector should be stored on or in the attribute vector database hereinafter the database . If decision block finds that the attribute vector should be stored the method leaves block by the YES output and flows to a block representing the storage of the attribute vector in database . Whether from block or if the pre processed attribute vector is not to be stored from the NO output of decision block the method flows to a block . Block represents the comparison of the next attribute vector with stored attribute vectors from the database. From block the method flows to a decision block . Block accepts the comparison of the current artifact in question with the stored attribute vector and decides if the artifact in question is malicious. If the artifact is not malicious as determined by decision block the method flows by the NO output to a further decision block . Decision block determines if all of the artifacts and the attribute vectors are present within the database. If the artifacts and attribute vectors are located within the attribute vector database the method leaves decision block by the YES path and returns to block to compare the next artifact with an attribute vector. Thus blocks and together define a loop which operates so long as the artifact is not malicious and the elements is within the database. In the event that for any artifact or attribute vector the values are not expressed in the attribute vector database the method of leaves decision block by the NO output and arrives at a further decision block . Decision block determines if the end of the physical memory has been reached and if not the method leaves decision block by the NO output and returns by a logic path including portions and to decision block to start another iteration.

In the event that decision block of determines that the artifact is malicious the method flows by the YES output to a decision block which determines whether the malicious artifact is to be removed. If removal is indicated the method flows by the YES output of block to a block which represents the passing of the malicious attribute vector to the cleansing application on the target host of . From block method flows to a block this represents the use of the cleansing software to clean the host of the malicious process or execution path. From block or from the NO output of decision block method of flows to a decision block . Decision block determines if the analysis is complete. If the analysis is not complete the method leaves decision block by the NO output and flows by a path back to decision block to begin another iteration. If the analysis is complete the method leaves decision block by the YES output and flows to an END or Analysis Complete block .

The system according to the disclosure employs several distinct software components in addition to software sets and described earlier to aid in the execution. These software components automate the collection pre processing and analytic steps through the system and thus if a step is not included in an operational path the software component is not needed. These software components perform the described functions of the method so are not separately described. The software components are responsible for obtaining access to the targeted physical memory or a replica of the targeted physical memory pre processing as well as analyzing which includes processing correlating and classifying transporting and storing it.

Aspects of the disclosure provide novel approaches to malware detection and removal in order to address the great litany of threats seen from the large variety of malware. The analytical method presents a single all encompassing methodology that provides the analyst with one method to address multiple threats of both known and unknown malware.

Upon initiation of the analysis of physical memory the user provides input into the system of typically through an attached device such as a keyboard attached to human interface as suggested by block of . This input describes the type of analysis to be performed selected from among the various types set forth in . The user entered information determines whether the analysis will be performed on the target host computer system or on a separate host computer system as shown in the decision block of how the physical memory will be accessed decision block of if the analysis is directed at a specific process or is a full host analysis decision block of and the number of iterations which will be performed and the searching algorithm to be employed decision block of . Depending upon the type of analysis being performed e.g. on target host versus off target host not all of these decisions would need to be made initially.

Analysis can be performed online live as in blocks or of or offline as in block of however the physical memory interface is meant as an abstraction in order to reduce the complexity of speaking to each method and allow for general access of the physical memory whether online or offline. In online analysis the access of the physical memory is done in real time on the target host computer system targeting the in use physical memory of the running target host computer system . While this provides for a current yet dynamic view of physical memory it also has the potential to suffer from the fact that if done through software and system Application Programming Interfaces APIs it will be executing in the context of the target host computer system . By executing the analysis within the context of the target host computer system the system could potentially be vulnerable to denial or deception attacks. In order to avoid the potential of compromised execution the second type of analysis that can be employed is offline analysis. This type of analysis is performed when the physical memory is copied to or presented in the form of a file representation of physical memory. This file can either be moved from the target host computer system to the analysis host computer system or left residing on the target host computer system . Even though the physical memory binary file is being processed on the target host computer system it is still considered off line since the in use running physical memory is not being examined.

After the initial decisions have been made access to the physical memory must be obtained as described in conjunction with . This access can occur in any of multiple ways all of which are known or common in the art. Logically the physical memory is accessed through an interface so that accessing and analysis of the physical memory will be performed in the same manner whether the analysis is being performed live or offline. Several examples of acquiring a access to the physical memory are as following employing software APIs to create a replica file of the physical memory using hardware tools or modifications to construct a replica file of physical memory exploiting support files that are part of other applications such as VMWare Workstation s .vmem files file representations of physical memory or using continuous live access to physical memory through APIs 317 435 .

The next stage in a method of the forensic system is performed either on the target host computer system that is the target of the analysis or on the analysis host computer system which is dedicated to analysis. Either way the next decision that must be made based upon whether the user decides to perform a live or offline analysis is the selection of the desired granularity of the analysis. The granularity determines whether the analysis will be directed at a specific process or performed against the target host as a whole. If targeted at a specific process the user may enter the process s name process ID or PID or other distinguishable process characteristic. For the targeted search the search algorithms implemented by either the RAM collector or attribute vector extractor and aggregator if on host and if off host will search through the physical memory until it finds the desired process and then performs an in depth analysis of the targeted process s related structures in order to gain a complete process level view for later processing. For the whole host analysis the search algorithms implemented by either the RAM collector or attribute vector extractor and aggregator if on host and if off host searches through the physical memory in order to build data structures that represent processes execution paths drivers kernel objects etc. These structures are used in the later analysis to relate different objects within the physical memory.

Any one of a number of methods can be employed in searching through the physical memory for processes or structures as is performed in the Attribute Vector Extractor Aggregator and the Attribute Vector Analyzer. However there are four specific search methods that are of interest. The first method illustrated in conjunction with B and C is a linear search using common signatures from the variables that reside within the sought after structures. details the address range 550 starting from 0x00 and increasing as one moves down the left most or the first column of the chart contents of memory in the second column and a sample or representative signature in column . The first byte 0x03 of the signature represented by is matched against the first byte 0x45 of the memory contents and is found not to match as suggested by an x on line . The tool in response to the lack of match increases the address range being inspected by a certain amount in this example by one byte represented in as . This brings us to a state represented by or we observe . In is the column of the address range column is a column which represents or displays the contents of memory at the location of the address and represents the signature. The first byte of the signature value 0x03 is compared with the value 0x03 of the contents of the memory at location and a positive match is made represented by an arrow and the lack of an x on line . Then the second byte of the signature at location and having value 0x00 is compared with the second byte of the memory contents at location of column value 0x03 but a positive match is not made x on line . There is no need to inspect the third byte of the signature at this point due to the fact that the second byte of the signature at location did not match the second byte of the memory contents. The analyzed range is increased again as suggested by path . displays the resulting address range as the left most column memory contents as the second column and the signature as a separate column . In first byte of the signature value 0x03 matches the first byte of the memory contents at location value 0x03 with the match result appearing as line with an arrow and without an x. Similarly the second byte of the signature value 0x00 matches the contents of the second byte of the memory value 0x00 as indicated by arrow line without an x. The third byte of the signature value 0x1b matches the value 0x1b of the third byte of the memory as suggested by arrow line without an x. This means that there is reason to believe that the desired structure has been found in the memory. The structure can now be pre analyzed and formed into an attribute vector. While this method is extremely thorough it can be tricked by malicious methods that change the signatures inside of the operating system. These attempts to disguise malicious signatures can be thwarted by performing searches using additional ones of the methods listed here in order to validate and verify the results of the first search method.

The second search method is termed a sequential self referencing scan and can be understood in conjunction with . Several structures within several of the more often used kernels such as Windows have variables within them that self reference the structure. In other words a variable within a certain structure contains that same structure s address in memory. A sequential scan is performed across the physical memory address space and each byte sequence is checked to see if it translates to a similar address. Then a template of the desired possible structure s is laid upon the referenced range. contain representations of memory address ranges in the form of columns and respectively representations of the contents of memory in the form of associated columns and respectively and examples of low level structures in the form of columns and respectively. The value of the first byte of the signature of column of is 0x3d000001 the value of the second byte of the signature is 0xqq09qqqq and the value of the third byte of the signature is 0xnnnnnnn. The q s and n s within columns and are placeholders for unknown values at the time of the comparison. These values are filled in once other signatures such as or characteristics such as the self referencing property of is or are fulfilled. In the value of third byte of the signature may be known to be a self referencing structure. Therefore the memory range is searched as suggested by path until the search comes upon a possibly viable or possibly matching link such as having a value 0x00000000. The value 0xnnnnnnnn of link is checked to validate that the value held in would properly self reference the beginning of the desired structure as suggested by path . It is found that the value 0x3d000001 of the first byte of structure does not match x in line with the desired signature value 0x0568ab1d stored in the address represented by . Similarly the value 0x09 of 0xqq09qqqq of the second byte in of the signature does not match the value 0x00 of 0xee00ee1b in the second byte of the memory location as evidenced by the x in output line .

In the memory address column is the corresponding value column is designated and the signature column is . In the searched range represented in by paths is illustrated by path as having been increased several iterations and in that additional searched range a second possible self referencing link is found having a value 0x0000000c that might be a viable match with the value 0xnnnnnnnn of the third byte of the signature . The structure is moved to match the address range and then comparisons are made. The value 0x3d000001 of the first byte of the signature matches the value 0x03d000001 of the byte occupying location as suggested by arrow line without an x. Additionally the value 0xf009d0d3 of the second byte of the signature matches the value 0xf009d0d3 at location . Therefore the values at memory locations and appear to be correct values meaning that with a high probability the data stored in the memory address range represented by locations and is the sought after structure. If the result is a reasonably accurate representation of a structure with self referencing variables then it is determined to be a match and is recorded as an accurate structure. Then in the same way in which the second part of the signature based sequential scan is performed links are followed from within these verified structures in order to build out a fair representation of the operating system s structure hierarchy.

The third search process described herein is the best fit method. The best fit method as with the self referencing system relies upon candidate structures being laid across byte sequences and a subsequent confidence analysis of the variable values in order to determine the presence or absence of a structure. However the best fit method relies upon the fact that within the physical memory of properly functioning operating systems structures are often relegated to certain ranges that are related to their functionality within and support of the operating system. Therefore the search set is significantly narrowed due to the fact that certain structures should only be found in certain ranges. displays an implementation of the best fit method used to determine whether or not a given memory address range is likely to be or bear the desired structure. In represents a random address in memory column represents a run of address ranges and column displays certain address ranges values. Random address represents a known or chosen starting address value. Some operating systems have well known static addresses for certain structures that make this best fit method especially useful.

The final search process is one in which the internal redundancy of the operating system is exploited to self verify the integrity of the system and crawl through linked structures. One such example of this is the relationship between threads and processes. A process is the execution of a single instantiation of an application. One process can dispatch multiple execution threads in order to complete its task. As threads perform the actual work each process must have at least one thread and under normal operating conditions each thread must be owned by one process. In order to avoid detection malware developers will often remove a process from the system s linked list of processes. Since the process is largely a management structure the application continues to execute as long as the thread is still linked within the system s list of threads to execute as is normal common in the practice . If the thread is not within the system s linked list of threads the application for which it is performing the action for will not execute. Therefore the redundancy search would enumerate all processes. Then it would enumerate all threads correlating each thread to a parent process. Should there be a discrepancy between the two i.e. there is a thread for which a parent process does not exist that thread is marked as suspicious and one of the other means of searching is initiated to determine the reason for the discrepancy.

It should also be noted that these different search methods are not meant to be mutually exclusive and in fact when run as complements of one another they can provide greater confidence in the integrity and accuracy of the search. Additionally due to the freed memory reclamation process it is often the case that structures that are no longer in use can remain resident in the physical memory. In fact testing has found several such structures that remained resident for over four weeks. This residual data can provide greater insight by the forensic analysis system into the malware should any of this data pertain to the malware. Because of this each search method has a degree of error which allows for imprecise matches of structures to also be considered valid. It is left to the user of the system to determine how strict he she desires the searching and matching process to be.

The forensic analysis system provides for a great deal of flexibility in its operation. There are two principal manners in which the system functions. The first manner is as a stand alone system in which the target and the analysis machine is or are the same of and the second manner is as a distributed system in which the target system s physical memory replica of is exported to a separate host such as which performs the analysis upon the physical memory replica .

In the stand alone system the target analysis host obtains either a physical memory replica of and accesses the actual physical memory or RAM through a software API. These methods are all common and known in the art. The RAM driver collector interface illustrates a universal way to represent access to the physical memory whether real or replicated . This can also be understood as being the physical memory interface . The RAM driver collector interface presents a standardized view of the physical memory whether it was obtained through hardware such as port network connections as by port and network driver or other human interface interaction such as port and human interface driver which may be for example a CD ROM. The RAM collector software of organizes and manages the collection of the physical memory real or replicated output if desired to a local RAM replica file pre processes into attribute vectors and uploads the attribute vectors and RAM replica if present into the attribute vector database . The attribute vector analyzer interacts with attribute vector database in order to analyze the new attribute vectors that have been added to the database as well as to update the status of any unknown attribute vectors that previously resided within the database . Upon completion of the analysis and detection of malicious execution paths the cleanser software is initiated and given the attribute vectors that correspond to the malicious execution paths. The cleanser then passes the attributes from the attribute vectors which will determine spatial targeting within the physical memory to the cleanser driver a privileged piece of software at a higher privilege than the cleanser . The cleanser driver then interacts with the CPU in order to access the physical memory directly. The cleanser driver is then able to edit and manipulate the physical memory in order to remove functioning traces of malicious software from physical memory.

Because a stand alone system such as that represented by the target host computer system of with the dash line elements in place functions within the same context as potentially malicious software there is the opportunity for any resident malware to possibly affect the execution and analysis of the system . Therefore a second option is provided within the system . That option is one in which the analysis host computer system of the system of is introduced in addition to the target host computer system . Through multiple means such as RAM interface hardware network interface and human interface the physical memory replica is introduced to analysis host computer system . The replica is moved through the appropriate channels or network and or human interface drivers known in the art and presented to the attribute vector extractor and aggregator . Attribute vector extractor and aggregator is much like the RAM collector of the target host computer system in that it organizes and manages the collection of the physical memory from RAM replica pre processes into either known or unknown attribute vectors and uploads the attribute vectors into the attribute vector database . The attribute vector analyzer then interacts with attribute vector database in order to analyze the new known and or unknown attribute vectors that have been added to the database as well as to update the status of any unknown attribute vectors that previously resided within the database . Upon completion of the analysis and detection of malicious execution paths the attribute vector analyzer then attempts to initiate contact with the cleanser driver of the target host computer system by way of a path . This path can be through networked communications human interaction such as through a keyboard or even through CD ROM media anything known in the art. Note that in this method the cleanser driver is initiated and provided with from attribute vector analyzer the known and or unknown attribute vectors spatial targeting characteristics meaning physical memory addresses in that correspond to the malicious execution paths. In a manner similar to that of the stand alone system the cleanser driver then interacts with the CPU in order to directly access the physical memory . The cleanser driver is then able to edit and manipulate the physical memory in order to remove functioning traces of malicious software from physical memory .

Additional aspects of the disclosure provide for the existence of a third option in physical memory capture live capture and pre analysis. With this model in the two host system computer systems and the pre processing software executes on the target host computer system as opposed to the analysis host computer system . Pre processing of the physical memory is performed on the physical memory of the target host computer system and then these structures are transferred using either data path or data path to the analysis host computer system .

The pre processing and analysis components of the forensic analysis system provide for a manner in which experts can inject their knowledge and aptitude into the system depending upon the algorithms and manners in which they choose to implement the two components. The pre processing performed by the RAM collector or the attribute vector extractor aggregator is an extremely important part of the system . After all structures have been found in the RAM or replica RAM verified to the desired confidence as was described in the search algorithms displayed in conjunction with and and processed meaning that relationships are determined through following pointers known in the art the pre processing of the structures into attribute vectors begins. Attribute vectors components can either be user specified at the start at block in the method of or they can be selected by performing any one of a number of feature selection algorithms known in the art in order to extract the best values to be used for comparison. During the analysis attribute vectors are employed by the attribute vector analyzer and to perform the relational calculations in order to determine the degrees of likeness between multiple attribute vectors. Attribute vectors contain information from the physical memory itself such as structure variable values as well as metadata that describes each structure or related set of structures. Metadata details information about structures such as a process and its related threads in a system level context. This system level context can be used to discern a structure s location in physical memory or the misplacement of a kernel space structure and degree to which it is misplaced within a user space address range. Additional steps taken during this pre processing stage include the normalization if so desired by the user of ordinal data values determination of the method for handling of categorical data and additional data mining activities that are well known in the art.

When performing a live i.e. online analysis there tends to be less of the desire to collect data for later analysis and a greater desire to perform relational analysis on the current data. When employing either live or offline analysis after the physical memory has been searched for structures verified pre processed and arrayed into attribute vectors the attribute vectors can either be loaded into the attribute vector database or or used in the next step analysis by the attribute vector analyzer or . If there is the analysis host computer system involved in the analysis then the attribute vector database or typically resides on the analysis host computer system . In the dashed objects represent elements of the system that are typically present in a live or stand alone forensic system analysis. These dashed elements are not needed on the target host computer system in a distributed forensic analysis system because they are present in a more secure environment on the analysis host computer system . This division of responsibilities provides security confidence integrity and availability for the analysis to be performed by the attribute vector analyzer or as well as for data retention in the attribute vector database or of attribute vectors structures and physical memory files to be used in comparison for future relational comparisons.

It is desirable to examine the attribute vector database because its initial setup and ongoing management are important to the relational analysis stage. As an overview the attribute vector database or is a relational database of any flavor typically during off line analyses set up run and administered on the second or analysis host. The attribute vector database can also be present on the target host computer system when employing a stand alone forensic analysis system which can be either live i.e. online or offline. No change to the standard operating procedures behind these tasks is contemplated or necessary as they relate to relational databases of any kind and these procedures are well known. The data that is initially stored within the database will include data from host computer systems of known states whose attribute vectors have been pre processed analyzed and classified as known state attribute vectors. This means that attribute vectors structures etc. and the physical memory file from one or more host computer systems are uploaded into the database prior to operation on host computer systems of unknown states. Known state host computer systems contain known malware or are known to be free from malware. In order to be a known state host computer system the user should have beyond a reasonable doubt that a if considered an uncompromised host computer system a host computer system s integrity is fully intact or b if considered a compromised host computer system the intended piece of malware is the only one resident on that host and it is designated within the database. Loading of known state host computer systems into the database can occur continuously as long as these entries are marked as known state within the database schema. During both the initial loading and ongoing execution the database performs data mining operations and analysis by the attribute vector analyzer or in order to determine new relationships that can be exploited when examining known state host computer system information against unknown state host computer system information.

When the attribute vector analyzer of is executing the analysis component during a live stand alone analysis a fully loaded attribute vector database is often not employed on the target host computer system . A reduced memory fingerprint attribute vector database will be used. Due to current constraints of databases and the amount of physical memory that they tend to occupy during execution they would tend to monopolize active memory. Therefore both known and unknown historical attribute vectors are limited to either what is loaded into the software or can be dynamically loaded and transmitted if the analysis software has access to a back end data repository through either a network connection null modem CD ROM or other communication strategy common in the art. When not employing a database the analysis software completes a sweep of the physical memory and all relative objects in its entirety . It then alternatively uses either its back end repository as through a connection through paths or to the attribute vector database of the analysis host computer system or pre loaded historical attribute vectors to perform the analysis in order to determine the presence of malicious software.

The Attribute Vector Database 31 or 91 of is responsible for storing the attribute vectors for the current as well as future analyses and in addition assisting with the relational analysis of the newest attribute vectors with the previously stored attribute vectors. After the searching and database upload have been completed by the Attribute Vector Extractor and Aggregator each process or execution path and its related attribute vector are then compared against other historical attribute vectors using any one of a number of comparative or comparison algorithms known in the art such as clustering or cosine similarity. The historical attribute vectors can be of both known and unknown states however generally known state attribute vectors provide a more accurate identification. Additionally the new attribute vectors are not the only adjudicated attribute vectors. Unknown historical attribute vectors can also have their states changed to a known state malicious or benign if sufficient evidence is found to support such an assertion due to the introduction of the new attribute vectors and their related relationships .

Once the state of a process or execution path is discovered in the analysis component two events occur namely a to separate the malicious processes from the benign and b to start the cleansing process. The target event occurs after the location details are transferred or to the cleansing component either the Cleanser Driver or Cleanser on the target computer . The transfer can be done through any number of methods including network based transfer manual entry by an operator or transfer over a null modem. The information being transmitted allows the cleansing component of the system to target the process or execution path deemed to be malicious and to logically separate those pieces from the benign operating system and software. The second event that takes place is the initiation of the cleansing process.

The cleansing component though programmatically complicated due to the necessity to interact with the operating system at an extremely privileged level provides the ability to remove only the areas of memory that are determined to be malicious without affecting the execution of the target host. The Cleanser or Cleanser Driver must accomplish tasks in order to successfully complete its objective of removing software with malicious intent from the target of the analysis. It must perform the following 1. Determine all areas of physical memory that are related to the malware 2. Determine if applicable the operating system control structures that are used to schedule and execute the malware 3. Remove replace or correct any control structures which transfer control either at an application or operating system level to the malware 4. Obtain malware specific supporting i.e. non executing physical memory locations such as heaps and either mark the locations as unused and thus reclaimable by the operating system or manually zero out and release the memory locations to the operating system 5. Terminate purity and allow for the target to continue execution as normal. The most difficult task to complete is the determination of which areas of memory are outright malicious activity and which areas support the malicious activity. Because this is completed in the attribute vector creation components and and the Attribute Vector Analyzers and and then the results are transferred to either the Cleanser Driver or the Cleanser Purity can actually employ methods described in the Ring et al. reference and common in the art in order to remove those offending processes and execution paths from the physical memory.

Using information supplied to the Cleanser or Cleanser Driver from the analysis stage which for ease can be in the form of an attribute vector and obtained through any network based or human entered means the Cleanser or Cleanser Driver again crawls through memory verifying the memory locations listed within the attribute vector and attempts to discover any additional structures that might be part of the process or execution path. These memory locations and structures are all maintained within the Cleanser s or Cleanser Driver s shrunken and contained memory space so as to decrease its physical memory footprint and used in the next stage.

After all parts of the malicious process or executable path have been determined it is necessary for the Cleanser or Cleanser Driver to terminate the malware through indirect methods. Because malware can hijack valid processes or inject malicious commands into valid executable paths it is not enough to simply terminate a process as it might be valid or necessary to the operation of the host. The Cleanser or Cleanser Driver performs the removal of the malware in any combination of three primary ways 1. Removal of pointers from linked lists 2. Replacement of executable code with sterile or harmless code that allows the processor to execute the region without performing any real task and . Correction of hooked or patched pointers that the malware had injected into memory areas in order to re route the execution flow to a desired code area. The Cleanser or Cleanser Driver however is not limited to these methods of malware removal. Malware of lesser complexity will not retain the means or abilities with which to create strong links into the system and therefore will not require low level interference by the Cleanser or Cleanser Driver . Due to the fact that Purity is using similarity analysis the Cleanser or Cleanser Driver will be able to correct and remove even high level malware based upon similarities or outliers when compared with other benign and malicious software.

The disclosure relates at least in part to a process that can be used to detect and remove malicious software from a host through the employment of physical memory analysis and relational data mining. While presented as a single process there are numerous paths of execution that can be taken based upon human or automated interaction. The ability to choose different paths of the inspection while maintaining a uniform overall process allows much greater accuracy in malware determination and removal. In addition it may serve as a seminal foundation upon which future physical memory analysis processes and methods can be built.

Active or running processes are those that are running on the target host at the time of collection of the physical memory. We can still deem those processes in the physical memory raw flat file to be active with respect to the target computer even though they are of course not actually executing once they are being analyzed. Inactive processes are those that are still resident in physical memory because they are not cleaned up by the operating system s memory management.

Additionally the disclosure provides for the existence of a third option in physical memory capture live capture and pre analysis. With this model the pre processing software executes on the target computer as opposed to the analysis computer . Pre processing of the memory is performed on the physical memory of the target machine and then these structures are transferred using 40 to the analysis machine .

While exemplary drawings and specific embodiments have been described and illustrated herein it is to be understood that that the scope of the present disclosure is not to be limited to the particular embodiments discussed. Thus the embodiments shall be regarded as illustrative rather than restrictive and it should be understood that variations may be made in those embodiments by persons skilled in the art without departing from the scope of the present invention as set forth in the claims that follow and their structural and functional equivalents.

