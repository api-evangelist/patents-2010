---

title: TCP/IP stack-based operating system
abstract: Systems and corresponding methods include a system having an operating system based wholly around a protocol stack, such as a Transmission Control Protocol/Internet Protocol (TCP/IP) stack. The system may include a central processing unit (CPU) including the operating system embedded therein, and a network interface coupled with a network and the CPU. The network may be the Internet. The operating system is fundamentally a state machine. The kernel of the operating system is fundamentally just a protocol stack for communicating with one or more devices of the network via the network interface. The protocol stack may be a TCP/IP protocol stack, UDP/IP stack or combinations thereof. A chip may be provided that includes the TCP/IP stack state machine-based operating system embedded in a CPU. The resultant chip may be ultra low power, miniscule in size, and IP-centric.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09436521&OS=09436521&RS=09436521
owner: IOTA Computing, Inc.
number: 09436521
owner_city: Palo Alto
owner_country: US
publication_date: 20101102
---
This nonprovisional patent application claims priority to U.K. Application No. 0919253.5 filed Nov. 3 2009 titled A New Architecture for Software and Hardware Design in Miniscule Microprocessor Systems and to U.K. Application No. 1010886.8 filed Jun. 29 2010 titled A New Architecture for Software and Hardware Design in Miniscule Microprocessor Systems for Internet Connected Devices which are hereby incorporated by reference in their entirety.

The present invention is generally related to computing systems and more particularly to a protocol stack based computing system.

Conventional computing devices such as a desktop laptop or a smart mobile phone such as an Apple iPhone or Nokia E71 run an operating system. Conventional operating systems include Microsoft Windows Apple OS X Symbian or Linux and are quite similar in architecture in that each tends to have conventional file and memory management operations storage and graphical user interface operations and so forth.

Such conventional operating systems are old fashioned in their fundamental design in as much as their core kernels date from architectures and implementations generally several decades old. For instance the Apple OS X and Linux operating systems are each based on the Unix operating system which was developed in the 1970s. Similarly Microsoft s Windows operating system has its roots strongly in MS DOS operating system itself from the 1970s. Typically these and other conventional operating systems follow very similar architectures including a layered design device drivers and Application Programming Interfaces APIs . The executable instructions for these conventional operating systems are all typically coded in high level languages such as C and C .

In a conventional operating system a core kernel executive has essentially master control over all the operation of the overlying software other systems components device drivers applications etc. . Typically the executive allocates timeslices of processor execution time on a pre emptive priority basis in threads and processes. That is the executive deterministically gives in turn registered applications or processes a piece of the action. Ironically most of the time nothing is being done at all. For the Microsoft Windows operating system for example if nothing much is going on the System Monitor may show that the System Idle Process is using 98 of the available microprocessor time or clock cycles.

Conventional microprocessor designs use a fixed frequency continuously running crystal as the timing mechanism for clocking through microprocessor execution cycles. Thus the crystal and the microprocessor continue running even if nothing much is being accomplished in the system uselessly cycling around and waiting for a process to actually perform a action e.g. process an incoming TCP IP packet on the Ethernet interface or perform a calculation in a spreadsheet . This timing paradigm is energy wasteful in two respects. First the crystal and microprocessor transistors are typically executing at their maximum speed at all times thereby consuming excess power and generating excess heat. Secondly it is very inefficient to continue running clock cycles if no substantive process is actually running. However the conventional operating system design forces this inefficiency when using for instance a conventional multitasking pre emptive prioritized operating system such as Windows OS X or Linux .

Furthermore the conventional operating system kernel executive must assume a hostile environment where it must handle badly written or even malicious applications which may hang crash or try to take control of the system. Consequently the operating system must be constantly vigilant.

Moreover such conventional operating systems require various modifications and enhancements year by year to cater to new requirements and technologies. Such enhancements are typically accomplished by bolting on a new layer of functionality.

For instance the rapid rise of the Internet in recent years has made it necessary to bolt on many new components such as the communications layers of Ethernet drivers TCP IP stacks and Web browsers. Generally these are inelegant additions to the conventional operating system often leading to poor performance software crashes and security flaws.

In accordance with various embodiments of the present invention a computing system is provided that includes an operating system of an entirely new architecture. The operating system may be based fundamentally around the TCP IP stack. Rather than bolting on a TCP IP stack onto a conventional core operating system the TCP IP stack is the operating system in various embodiments. All functions run through the conventional interface or similar extensions of the standard Berkeley Sockets or WinSock Application Programming Interface API .

In addition to the conventional Sockets APIs such as socket connect listen and so forth all other functions of the operating system and associated applications may occur around the fundamental core of the TCP IP stack.

According to various embodiments the entire operating system of the enhanced TCP IP stack is a state machine. Instead of including conventional operating system multitasking structures such as threads processes and semaphores etc. the operating system is an amalgam of co operating state machine oriented components.

One of the advantages of such a computing system is that it is inherently and fundamentally Internet oriented. All Internet type functionality is natural and inherent in the computing system design and implementation i.e. not just bolted on as an afterthought.

The operating system may be written in low level Assembler rather than a high level language such as C or C . The use of Assembly language has the advantage of much reduced code size faster execution time less microprocessor clock cycles and therefore less power cycles of the microprocessor. The microprocessor in which the operating system may be embedded may therefore have much lower power consumption than in conventional designs.

According to various embodiments executable instructions code and data for the operating system are stored separately. Thus the read only executable instructions may be executed directly from read only memory ROM and only the read write data needs to be saved in some type of random access memory RAM . As a result there are both substantial power and cost savings.

The code of the operating system may thus be implemented in the actual microcode of the microprocessor or microcontroller system. In some embodiments the code is implemented as a hardwired microcontroller system. As used herein the term central processing unit or CPU encompasses any one of a microprocessor microprocessor system microcontroller and microcontroller system.

The assembled and linked code of the operating system may be highly optimized for low power consumption as well as reduced ROM and RAM size. Conventional computing systems utilize a conventional general purpose microcontroller or microprocessor architecture and a general purpose operating system design. Such designs tend to optimize more commonly used opcode instructions into fewer bytes. Less commonly used opcodes take more bytes and therefore more energy and clock cycles. According to various embodiments an assembler linker code generator analyzes the actual implementation specific usage of opcode instructions and dynamically creates an optimized opcode instruction set to minimize energy clock cycle usage.

In some embodiments the microprocessor design mask may be optimized for binary 1 s and 0 s depending on whether a majority of 1 s or 0 s may produce a lower overall power consumption.

In addition the overall design of TCP IP stack based operating system is inherently secure in the Internet environment as it is fundamentally architected around Internet principles and therefore not prone to security flaws inherent in bolted on afterthought implementations.

Embodiments may provide a method including receiving by an operating system input output I O requests from an application residing in an application layer of a system the operating system being a state machine that comprises a protocol stack for processing the I O requests according to a network protocol the operating system being embedded within and executing within a central processing unit CPU and processing the I O requests from the application according to the network protocol using the operating system.

Further embodiments include computing systems including a network interface coupled with a network and a central processing unit CPU and the central processing unit including an operating system OS embedded therein the operating system being a state machine and including a kernel the kernel comprising a protocol stack for communicating with one or more devices of the network via the network interface.

Embodiments may also include a chip having a central processing unit CPU and an operating system embedded in the CPU the operating system comprising a kernel the operating system kernel being a state machine and comprising a TCP IP protocol stack for communicating with one or more devices via a network interface.

Embodiments may yet further include computer readable storage media having embodied thereon programs for executing one or more exemplary methods according to the present invention.

All the figures provided herein are exemplary only. Also like numbered elements in figures refer to like elements.

Embodiments provide systems and corresponding methods providing an operating system based wholly around a protocol stack such as a Transmission Control Protocol Internet Protocol TCP IP stack. The system may include a central processing unit CPU including an operating system embedded therein and a network interface coupled with a network and the CPU. The network may be the Internet. The operating system is fundamentally a state machine. The kernel of the operating system is fundamentally just a protocol stack for communicating with one or more devices of the network via the network interface. The protocol stack may be but is not limited to a TCP IP protocol stack UDP IP stack combinations thereof or other protocols. A chip may be provided that includes the TCP IP stack state machine based operating system embedded in a CPU.

Among the many advantages provided by various embodiments of the present invention are a small hardware design very compact and efficient software minimal clock cycles for execution a natural Internet connectivity model and extremely low power consumption.

Network may be a local proprietary network e.g. intranet and or may be a part of a larger wide area network. For example the network may be a local area network LAN which may also be communicatively coupled to a wide area network WAN such as the Internet. Network allows for communication between the various components of environment .

The device may communicate with one or more client devices A C over network . Clients A C may be devices described in further detail with respect to and that include the TCP IP stack state machine operating system. Clients A C may each be a chip each having the TCP IP stack state machine operating system embedded in a CPU and communicating with network either wired or wirelessly via a network interface. The device may be a computing device described in further detail with respect to having a browser for communicating with the clients A C over the network to get status or send commands. For example the clients A C may each be a light bulb for example each having a chip having the TCP IP stack state machine operating system embedded in a CPU. The ultra low power and miniscule size of the chips resulting from the present design provide that and countless other application possibilities.

The device may be a HTTP web server or Simple Network Management Protocol SNMP daemon described in further detail with respect to . Alternatively the device may be a device described in further detail with respect to that includes the TCP IP stack state machine operating system.

The operating system kernel does not require an accurate internal clock source since it may get a time reference using the Simple Network Time Protocol SNTP from a remote time server e.g. time server .

Device and time server may comprise any combination of computer hardware and software configured to receive and transmit information over the network thereby communicating with the clients A C.

The element may further include a state machine for executing various instructions and modules stored in memory . The state machine may include one or more state machines as shown and described in further detail with respect to .

A module should be generally understood as one or more routines that perform various system level functions and may be dynamically loaded and unloaded by hardware and device drivers as required. The modular software components described herein may also be integrated as part of an application specific component.

According to various embodiments the modules may each include executable instructions for the operating system embedded into element and may be executed through a sockets applications programming interface API .

The I O request receiver module is configured to receive input output I O requests. The requests may be from an application residing in an application layer of a system as described in further detail with respect to .

The protocol handling module is configured to handle a specific protocol for the protocol stack state machine implementation. The protocol may be a Transmission Control Protocol Internet Protocol TCP IP stack such that the operating system is a TCP IP stack state machine. In some embodiments the protocol stack includes a different protocol stack e.g. a User Datagram Protocol Internet Protocol UDP IP stack which may be used in addition to or in place of the TCP IP stack.

As will be described in greater detail later herein the network in comprises the Internet and the operating system utilizes sockets style API of sockets and ports on IP addresses for handling I O requests. The I O request processing module is configured to process the I O requests from an application according to the network protocol using the operating system.

The optional network interface module may be included and is configured to provide an interface between the protocol stack state machine and a network interface. The corresponding network interface may be a hardware or a soft Ethernet controller as described in further detail with respect to . Alternatively the corresponding network interface hardware may be a wireless interface including but not limited to an 802.11 based interface ZigBee or Bluetooth etc.

In step an I O request is received. The request may be from an application residing in an application layer of a system.

In step the network protocol is determined. According to various embodiments the protocol is TCP IP such that the operating system is a TCP IP stack state machine. In some embodiments the protocol is UDP IP. UDP is an unreliable connectionless protocol sitting on top of IP and TCP is a connection oriented reliable protocol. The protocol may be a hybrid of TCP and UDP wherein a data connection stream includes a mixture of UDP and TCP packets. UDP has less overhead and is suitable for lower importance information than TCP which has a higher overhead but essentially guarantees reception. For instance a stream of data comprising non essential information such as low importance data mixed with critical data could better be transmitted over such a hybrid link. This hybrid protocol may be determined in step .

In step the I O request is processed according to the network protocol. The processing may be performed by the state machine that fundamentally is the operating system e.g. a TCP IP stack state machine operating system. The operating system utilizes sockets style API of sockets and ports on IP addresses for handling I O requests. The conventional Berkeley Sockets style API of sockets and ports on IP addresses may be used. The Berkeley sockets specify the data structures and function calls that interact with the network subsystem of the operating system.

Conventional microprocessors run on fixed frequency clocks driven by a crystal which runs all the time. In contrast according to various embodiments an asynchronous variable clock may serve as an internal clock for the operating system for the system . is a timing diagram illustrating timing for an asynchronous clock for various aspects of .

The asynchronous clock is configurable to automatically stop when clock cycles are not needed. As illustrated in cooperative components cycle in turn around their state machine cycles until they are all in a state of rest at which point the internal clock can stop. As shown at in the asynchronous system clock may be restarted by a wake up daemon signal from the SNMP daemon e.g. an incoming data packet. The system illustrates that there is no point going round an endless idle loop if there is no action is needed.

The executable instructions may be optimized to be much tighter and more efficient than conventional systems so much lower clock rates may be used. A self adjusting cycle rate may be provided depending on load and function to be performed. In addition self learning or pre predicted algorithms for expected scenarios may be utilized to put the CPU into a doze mode of fractional Hz. Any expected external event may cause the CPU to exit the doze mode resume full speed operation to execute necessary operations to handle the external event and return back to doze. In a doze or a deep sleep mode the CPU register contents may be read and stored in special registers with very long deep sleep data maintaining capabilities. Such clock saving measures yield substantial power savings.

In some embodiments no conventional crystal is used. The operating system kernel does not require an accurate internal clock source since it may get a time reference using the Simple Network Time Protocol SNTP from a remote time server coupled to the network see e.g. time server in

In operation the system may function as a simple web server comprising a TCP IP state machine for handling the lower operation of receiving Ethernet packets up through the TCP IP stack and responding to HTTP requests. The system as web server would open a port on a socket on an IP address e.g. port identified at and listen on that port. Port data is read at the HTTP requests are parsed at and responses are sent from a respond block .

When no tasks need to be done the state machine is idle. The clock manager causes a turn off state based on a determination at that there is no data to process. An asynchronous system clock may be restarted by a wake up daemon signal received after a wait for interrupt state . The receive interrupt block sends the interrupt to the wait for interrupt state in response to receiving data.

The fundamental application programming interface API for all operations of the operating system may be the conventional Berkeley Sockets style API of sockets and ports on IP addresses. The Berkeley sockets specify the data structures and function calls that interact with the network subsystem of the operating system. The kernel handles all the normal Sockets APIs. The sockets API may also include some optimized APIs.

Any non conventional functions outside the normal Internet ones are handled in exactly the same manner e.g. by opening sockets and binding to ports. Thus the accessing of local input and output e.g. keyboards mice and display screens may all be accomplished through socket port operations. Consequently it is quite transparent as to whether a device is local or remote a keyboard could be on a localhost at 127.0.0.1 for example or remote on another IP address. Though this transparency may be an aspect of other operating systems it is generally not fundamentally inherent in the operating system design from the outset. Accordingly the naked kernel can be tiny in a minimal configuration perhaps as small as just a few hundred bytes in size.

The network interface may be any device that may receive data from a network or provide data to the system bus . The network interface may be coupled to any digital device via the link . The network interface may include but is not limited to a hardware or software Ethernet interface controller a wireless interface e.g. 802.11 ZigBee or Bluetooth . It will be apparent to those skilled in the art that the network interface can support many wired and wireless standards.

Examples of the state machines and is provided in where state machines and operate along with the TCP IP stack state machine . The state machines and like state machines and may be targeted to handle specific low level tasks e.g. for listening to ports etc. A state machine manager component may be included to tie the various state machines together.

Some of the above described functions can be composed of instructions that are stored on storage media e.g. computer readable medium . The instructions may be retrieved and executed for the state machine . Some examples of storage media are memory devices tapes disks integrated circuits and servers. The instructions are operational when executed by the state machine to direct the state machine to operate in accord with various embodiments of the invention. Those skilled in the art are familiar with instructions processor s and storage media.

The memory system is any memory configured to store data. Some examples of the memory system are storage devices such as RAM or ROM. The storage system is any storage configured to retrieve and store data. Some examples of the storage system are flash drives hard drives optical drives and or magnetic tape. The storage system may comprise a data structure configured to hold and organize data.

The I O interface is any device that may receive data from a client or provide data to the client. The I O interface may include but is not limited to a keyboard a monitor a mouse a speaker a microphone or a camera.

The communication interface may be coupled to any digital device via the link . The communication interface may support communication over a Universal Serial Bus USB connection a firewire connection an Ethernet connection a serial connection a parallel connection or an Advanced Technology Attachment ATA connection. The communication interface may also support wireless communication e.g. 802.11 a b g n or wireless USB . It will be apparent to those skilled in the art that the communication interface can support many wired and wireless standards.

Some of the above described functions can be composed of instructions that are stored on storage media e.g. computer readable medium . The instructions may be retrieved and executed by the processor . Some examples of storage media are memory devices tapes disks integrated circuits and servers. The instructions are operational when executed by the processor to direct the processor to operate in accord with the invention. Those skilled in the art are familiar with instructions processor s and storage media.

Conventional operating systems manage internal tasks and external programs in a dictatorial manner by preemptively multitasking through threads and processes. Such a system is flexible and general purpose in nature. However it may not be optimal since applications and unknown driver components have little or no control over their scheduling.

In contrast to conventional operating systems the operating system according to the various embodiments of the system regards the whole environment as being inherently cooperative and friendly. To that end the whole system is essentially a giant state machine. There is no executive just a cooperative state machine model. All systems and applications components are built together in an open and symbiotic relationship. Only components actually required in a target system are built into the environment. For instance one would not generally find the game solitaire on a server implementing embodiments of the present invention as with some network operating systems.

Running a state machine would not be like the method of running time slices in a conventional pre emptive system which is a very wasteful method. Some of the various advantages provided by the state machine according to various embodiments are illustrated by an example of putting together an internet server system which has the simple task of running a web server.

In a conventional operating system the kernel and other systems components would comprise all the normal functions of file and memory management timers input and output TCP IP etc. A web server would sit on top of the TCP IP stack which is itself sitting on top of the core operating system stacks and drivers. In operation the web server would open a port on a socket on an IP address e.g. port and listen on that. There would be numerous threads and processes going on in the background as the kernel executive cycles usually somewhat uselessly around all the running processes updating clocks checking communication ports updating displays checking on Ethernet traffic and so forth. In this way the conventional operating system provides a highly sophisticated and flexible system but with the downside of a tremendous number of activities and hence clock cycles and therefore energy going on all the time just to run perhaps a simple web server.

In contrast an implementation for this example according to various embodiments of the system may include only the required components e.g. web server implementation further described with respect to . As a result execution times and minimal code size would be optimized resulting in fewer energy cycles. Such a simple web server has just the state machine running handling the lower operation of receiving Ethernet packets up through the TCP IP stack and responding to HTTP requests. When no tasks need to be done the state machine is idle. In essence the system hardware is therefore designed for the good of the software and the software is designed for the good of the hardware.

One of the drawbacks of conventional general purpose microprocessors is that opcodes are predefined and static. Specifically common opcodes are allocated to single byte instructions whereas less common but perhaps more powerful opcodes are allocated to multiple byte opcode structures. This conventional approach provides flexibility but is not optimized. In contrast a system builder according to various embodiments of the present invention may dynamically profile the code and build an optimal opcode set for the microcode depending on the style of the programmer in order to minimize various required parameters such as energy cycles code size or a combination thereof. A library for the pre planned code segments may also be provided to minimize overhead for the code.

The system may also attempt to identify what sub processes in a larger process system need to be executed sequentially and which sub processes might be executable in parallel. The system may provide a simple state machine model of a small number of cooperative elements. For more complex systems a State Machine Manager SMM may be provided to regulate and control the run flow. In operation applications register priority and execution parameter requests with the SMM which in turn handles them accordingly in a fair manner.

As described above the CPU is not designed to be general purpose. To that end the more arcane commands and gates that apply to a vast majority of applications are simply removed. The design philosophy in regards to the opcode instruction set is to design the operating system software first then optimize the operating system for building in silicon. To that end the system reuses as many pieces of microcode pertaining to opcodes and opcode snippets as possible.

In the conventional paradigm the CPU is designed first and thereafter an operating system is designed to run on the CPU. As a result the operating system design is limited by compromises dictated by the CPU chip design. The applications are then designed to run on the operating system. The design of the applications is limited by all the limitations dictated by the particular operating system design.

In contrast to this conventional design paradigm the present embodiments begin with the operating system design. Any unnecessary aspects are removed for the design. The CPU chip layout may then be designed. The design process may be iterated to make still further reductions down to the essential components. A program builder which essentially assembles or may compile and links and binds essentially compiles the mask for the microcode of the microprocessor.

Various embodiments of the system include a core CPU chip with the operating system embedded and may also include different flavors of adjacent personality chips which are programmable with the high level application development translation utility. For example the basic system according to some embodiments may include just a core CPU having the operating system embedded and an IEEE 802.11 Ethernet controller but with no display or keyboard drivers. In some embodiments various elements are added to the basic system individually or in combination including micro web servers and browsers SNMP agents email servers and clients SMS servers and clients etc. Other elements that may be included in a system individually or in combination include power supplies direct and indirect and other connectivity options such as ZigBee or Bluetooth wireless capability etc. The design and build process for various embodiments of the system are targeted for reducing gate count maximizing cycle usage and substantially reducing energy use.

In conventional systems instruction pointers are only incremented after a program fetch when the microprocessor reads the next instruction from memory. According to another aspect of the present invention an instruction pointer register in the microprocessor may be decremented as well as incremented. A string of opcodes may then be executed forwards or backwards i.e. providing executable code capability. As a result code may be reused to save space by running some code backwards.

In conventional systems a code byte is read from the instruction pointer address and executed or another byte is read depending on the opcode etc. The instruction pointer may be revectored automatically by for example executing a JUMP instruction. According to another embodiment of the present invention the instruction pointer may be revectored by a higher level instruction pointer manager in the core CPU microcode. That is the CPU design provides that a higher level instruction pointer manager can force a jump in the instruction pointer to execute preferable code. This revectoring provides a different mechanism over and above a standard software or hardware interrupt controller.

Depending on the particular hardware design implementation binary 1 s or 0 s may take more or less power to support. According to another aspect an optimizing code generator may dynamically analyze the opcode and data binary structures and switch accordingly to the most energy efficient implementation of binary 1 s and 0 s. In other words the microprocessor design mask may be optimized for binary 1 s and 0 s depending on whether a majority of 1 s or 0 s may produce a lower overall power consumption.

According to various embodiments the system and operating system code executes in ROM. The ROM execution execution as a state machine and the saving of register contents during deep sleep provide an instant on capability where it may take just milliseconds for the system to resume execution. RAM memory may be used for only truly read write data that requires it. The execute only code needs only to be in ROM. The slower access times of ROM devices versus RAM devices are not an issue because the instruction cycle times for the system are generally slow albeit for a reduced number of cycles.

According to another aspect the system eliminates wasted internal clock cycles through the use of intelligent tasking in contrast to multi tasking. The intelligent tasking may include having pre plan code nests in the CPU so that different steps of different code streams can execute in the gaps inevitably left in their processes. For example for a code stream a and code stream b as follows 

DO . . . WAIT . . . WAIT . . . WAIT . . . WAIT . . . DO . . . DO . . . WAIT . . . WAIT . . . WAIT . . . DO

WAIT . . . WAIT . . . DO . . . DO . . . DO . . . WAIT . . . WAIT . . . WAIT . . . DO . . . WAIT . . . WAIT

The intelligent tasking interleave these code streams intelligently to greatly reduce the inefficient wait cycles as follows DO . . . WAIT . . . DO . . . DO . . . DO . . . DO . . . DO . . . WAIT . . . DO . . . WAIT . . . DO

The ultra low energy and size reduction provided by the system according to the present invention may make it feasible to include embedded Internet capability in a whole range of devices that would otherwise lack it due to the conventional micro controllers being too big and consuming too much power. The system may reduce power consumption from Watts to microWatts or perhaps even to nanoWatts. For example some light bulbs and switches may be Internet enabled for the first time using embodiments of the system.

Turning to further details regarding the software implementation the operating system software may be completely developed in native assembler. The fundamentally overriding requirement for the system is to aim for the utmost performance in everything from code size ROM execution reversible code clock energy cycle counting and so forth. The system has no conventional requirement for easy portability which would normally point to a C or C based implementation that can be easily ported. In contrast porting the system to a new microprocessor entails recoding the assembler implementation for a new microprocessor a straight forward task for those skilled in the art.

The system may implement at the lowest level of security SSL i.e. HTTPS for web browsing. At a higher level S HTTP may be implemented for web browsing. The system may also implement a lightweight real time streaming protocol LDF . This protocol may be used for data as well as command and control. Data packets may be easily encrypted at several levels from easy low to secure high e.g. private public key encryption.

The system may include ultra low power microprocessors tiny embedded Internet operating systems and associated software products such as Software Development Kits SDKs to enable third parties to develop applications and application suites for managing devices. Various application areas for the system include but are not limited to clean tech green energy medical military aerospace automotive Smartphone Personal Digital Assistant PDA Pocket Computer and so forth. In the clean tech area for example one application for the system of the present invention may be a tiny Internet chip in every light bulb. Such a chip in a light bulb could for instance be wired directly from an available free 240V or 110V AC voltage supply utilizing N type Metal Oxide Semiconductor NMOS for providing super strong high voltage and very low current consumption chips. In some embodiments an inductor may be used to generate isolated low voltage from the power line AC cycles. The network traffic may be transmitted over the power line. One of the advantages of the present system for a chip in a light bulb application is that low data rates can be used to handle the anticipated light data traffic.

Electrical devices in a house or office such as light bulbs switches and plugs which use the present system could be carefully monitored and controlled from a smart meter or desktop web browser. The devices may have the present system implement a micro web server embedded for command and control. A web browser or SNMP management program could display all such devices in a local smart grid monitor them turn them on and off reduce power schedule the device to run at the most efficient and economical time e.g. a dishwasher etc.

Exemplary medical applications include use of the present system for stents. A stent is a synthetic tube inserted into a natural passage conduit in the body to prevent or counteract a disease induced localized flow constriction. A tiny chip implementing an embodiment of the present system could be built into each stent along with a tiny ultra long life and low power RF transmitter receiver. The modified stent could send data about the state of the artery in realtime over the wireless Internet such that a patient s condition can be monitored live perhaps 24 hours a day.

The present system could also be used for other medical patient monitoring applications where the small size low power and Internet monitoring aspects would provide enormous benefits e.g. use in a digital plaster stuck to a patient s body to track vital signs such as heart rate and breathing and then send alerts to doctors over the Internet.

The present system may provide ultra low power Internet operating system and microprocessor products for use in many other product areas such as military aerospace and automotive as well as next generation Smartphones PDAs Pocket Computers. Currently unknown new classes of applications may be made possible by the present system. Other exemplary applications include low power devices needed for unmanned and manned missions to other planets and new network architectures for motor vehicles.

The ultra low power aspect of the present system may provide greatly improved battery life for various devices. Boot up time for devices may be greatly reduced by executing instructions from ROM saving general state information in battery backed SRAM and saving crucial microprocessor register setting and other state information saved in special registers in custom ASICs for example.

Chips implementing the present system may communicate over various means including but not limited to standard twisted pair Ethernet coax ZigBee Bluetooth Low Power Bluetooth and perhaps wireless Ethernet. A server embedded in the dongle of a twisted pair Ethernet connector could be one of the countless potential applications for the present system

The system may include software development tools for the operating system and the microprocessor chip design e.g. assembler linker BIN to ROM tools debugger etc.

A full Internet Protocol stack typically includes an application layer transport layer internet layer and link layer. The basic operating system for the present system may not normally have all the components of a full Internet Protocol stack. A basic kernel may have for example just HTTP on top of TCP on top of IP on top of Ethernet. Alternatively the kernel may be built with SNMP on UDP on IP on Ethernet.

Conventionally TCP IP is not an operating system but a communications stack typically using a Berkeley Sockets or WinSock style API. A simple sequence for a web server for Windows would include 1. Initialize Winsock 2. Create a socket 3. Bind the socket 4. Listen on the socket for a client 5. Accept a connection from a client 6. Receive and send data and 7. Disconnect.

According to various embodiments the operating system API for the system is uniquely purely Sockets based. Since it is also Assembler based the normal C based Sockets APIs are replaced with custom register based analogies. Parameter passing of other programming languages may be replaced by microprocessor register passing.

The operating system kernel is built per application to include only the necessary APIs. The kernel also may provide a configurable set of built in device drivers and application modules. The built in device drivers may include for example drivers for console display graphics display html xml keyboard mouse serial port USB port and Ethernet. Other built in and API application functions may include SMS email Twitter Facebook MySpace Call and Search e.g. Google Bing .

For applications such as clean tech such as smart light bulbs and switches a new protocol at the low level of the Internet Control Message Protocol ICMP may be devised to poll and control smart devices. Such a protocol lies a little above the IP layer but well below protocols such as UDP or TCP. There is not necessarily the need to have the overhead of a full TCP implementation or a conventional SNMP module. Advantages of the new protocol include a smaller kernel and a communications protocol optimized to the particular requirements.

Alternatively SNMP and a web server may be used see as described above . This would be akin to the way it has long been possible to control a router or printer over the internet by connecting to the URL or IP address of the device. With the present system this would be possible for any device no matter how small or cheap.

Microprocessor opcode may be optimized for implementations. A minimal opcode set may form the basis of the operating system CPU instruction set. Many x86 opcodes for example may basically not be used at all in an optimal implementation of a highly Internet centric system of the present invention. Such extraneous opcodes waste transistors in a CPU and therefore are not included in the minimal set. Conversely there are some operations which are often used in an internet software implementation such as Internet Checksum calculations IP address parsing CRC number generation and packet deconstruction which could be optimized even as single opcodes.

The terms computer readable storage medium and computer readable storage media as used herein refer to any medium or media that participate in providing instructions to a CPU for execution. Such media can take many forms including but not limited to non volatile media volatile media and transmission media. Non volatile media include for example optical or magnetic disks such as a fixed disk. Volatile media include dynamic memory such as system RAM. Transmission media include coaxial cables copper wire and fiber optics among others including the wires that comprise one embodiment of a bus. Transmission media can also take the form of acoustic or light waves such as those generated during radio frequency RF and infrared IR data communications. Common forms of computer readable media include for example a floppy disk a flexible disk a hard disk magnetic tape any other magnetic medium a CD ROM disk digital video disk DVD any other optical medium any other physical medium with patterns of marks or holes a RAM a PROM an EPROM an EEPROM a FLASHEPROM any other memory chip or cartridge a carrier wave or any other medium from which a computer can read.

Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to a CPU for execution. A bus carries the data to system ROM or RAM from which a CPU retrieves and executes the instructions. The instructions received by system ROM or RAM can optionally be stored on a fixed disk either before or after execution by a CPU.

The above description is illustrative and not restrictive. Many variations of the invention will become apparent to those of skill in the art upon review of this disclosure. The scope of the invention should therefore be determined not with reference to the above description but instead should be determined with reference to the appended claims along with their full scope of equivalents.

While the present invention has been described in connection with a series of preferred embodiments these descriptions are not intended to limit the scope of the invention to the particular forms set forth herein. It will be further understood that the methods of the invention are not necessarily limited to the discrete steps or the order of the steps described. To the contrary the present descriptions are intended to cover such alternatives modifications and equivalents as may be included within the spirit and scope of the invention as defined by the appended claims and otherwise appreciated by one of ordinary skill in the art.

