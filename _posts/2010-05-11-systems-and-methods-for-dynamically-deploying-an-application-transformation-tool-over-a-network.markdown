---

title: Systems and methods for dynamically deploying an application transformation tool over a network
abstract: The present application is directed towards systems and methods for dynamically deploying an application transformation tool over a network for analyzing and transforming an application from a source installation to a target installation. By using a cloud service for application transformation, the system can provide both flexibility in deployment and advantages in parallel and concurrent processing and transformation of objects of the application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08671222&OS=08671222&RS=08671222
owner: Smartshift GmbH
number: 08671222
owner_city: Mannheim
owner_country: DE
publication_date: 20100511
---
The present application generally relates to analyzing and upgrading an application. In particular the present application relates to systems and methods for dynamically deploying an application transformation tool over a network to transform an application.

Many software applications may be modified or customized by users or administrators to include additional functions objects databases and customized code. When the underlying software application is upgraded to a new version in many instances the modified or customized functions objects databases and code of the prior obsolete version may be incompatible with the new version. Rewriting the modified or customized functions objects databases and or code may be time consuming and expensive.

The present application is directed towards systems and methods for dynamically deploying an application transformation tool over a network to analyze and transform an application from a source installation to a target installation. Customized functions objects databases and code of the source installation may be analyzed in accordance with analysis rules to create a meta model representative of the elements of the customized elements and their relationships with each other and objects of the source installation. Responsive to transformation rules the meta model may be modified to create a transformed meta model representative of the elements and their relationships with each other and objects of the target installation. The transformations may then be applied to the customized functions objects databases and code of the source installation to convert them into transformed functions objects databases and code compatible with the target installation.

In some of the embodiments described herein a system or method may be described as automatic semi automatic or manual. An automatic system or method may be such a system or method that performs any of the upgrades transformations or conversion described herein without any user input during the upgrade transformation or conversion or with a level of user input below a predetermined threshold. A semi automatic system or method may be such a system or method that performs any of the upgrades transformations or conversion described herein with combination of a level of automation and a level of user input during the upgrade transformation or conversion below a predetermined threshold or within a predetermined threshold range. A manual system or method may be such a system or method that performs any of the upgrades transformations or conversion described herein without automation during the upgrade transformation or conversion or with a level of automation below a predetermined threshold. In addition in the following description a objects or code of a system may be referred to as comprising automatic code comprising semi automatic code or comprising manual code. Similar to the systems and methods described above automatic code may be upgraded transformed or converted without any user input during the upgrade transformation or conversion. Semi automatic code may be upgraded transformed or converted with a combination of a level of automation and a level of user input during the upgrade transformation or conversion below a predetermined threshold or within a predetermined threshold range. Manual code may be upgraded transformed or converted without automation during the upgrade transformation or conversion or with a level of automation below a predetermined threshold.

In some aspects the present invention is directed to a method of automation in the analysis and transformation of computing systems of various types. Analysis and transformation are part of a larger process that may be referred to generally as modernization. Modernization of a given computer system or application comprises a variety of tasks and processes including adapting software to operate on new hardware platforms restructuring code to optimize performance rewriting code in new languages introducing new functionality and other types and forms of upgrading.

For example the class of software systems and corresponding market segment referred to as Enterprise Resource Planning ERP is characterized by systems and applications of extremely large breadth and scope of functionality designed to coordinate control and support resources and information related to business processes such as manufacturing supply chain management financials projects human resources and customer relationship management from a shared data store for an entire enterprise. The inherently large scope and complexity of ERP systems poses significant challenges to modernization. Business owners must balance significant business and technical benefits of updating and modernizing these vast systems against the considerable costs risks and disruption associated with large scale modernization projections.

One example of an ERP system is the Systems Applications and Products SAP system developed by SAP AG of Walldorf Germany. SAP uses a proprietary system architecture and programming language the Advanced Business Application Programming ABAP language which includes the concept of Logical Databases LDBs . SAP is prominent in the market and this has spawned an industry sub niche for providers of specialized services and solutions related to SAP systems. Services and solutions serving the SAP ERP market segment must be extremely knowledgeable about and closely aligned with the underlying framework architecture and programming language of SAP systems from both technical and business perspectives.

One advantage of the SAP ERP environment is the ability of customers and consultants to develop customized code objects reports and interfaces for specific business requirements. SAP even allocates a specific repository within its environment to this type of custom code. However when SAP AG releases new versions of underlying SAP software SAP standard upgrade utilities will not operate on any custom code even though the custom code is written in the ABAP language. Specifically the SAP upgrade utilities provide customers with the means to upgrade only the standard SAP components the basis layer the standard modules and the system databases from a given release level to a more recent release level. The upgrade utilities do not provide tools to upgrade any modified or custom code that is deployed in the system. The presence of custom code thus creates an obstacle for SAP customers who need to upgrade to the most current released version of SAP software.

Accordingly the present invention features a solution to automate a comprehensive approach to analysis of a computing system for instance an ERP system such as SAP at a detailed source code level. Furthermore the present invention features a solution to transform custom code. Disclosed herein are embodiments and examples of systems and methods for performing automated analysis and transformation of second and third party code. Although many of the examples discussed below are tied to specific embodiments of systems including ERP systems such as SAP the disclosed systems and methods may be applied to analyzing and transforming custom code in compliance with standards and rules of any language and architecture including proprietary languages and architectures.

In one aspect the present invention features a method for dynamically deploying an application transformation tool over a network to transform an application. The method includes receiving by a service executing on one or more servers via a network from a remote client a request to establish an instance of an application transformation tool. The method also includes dynamically establishing by the service the instance of the application transformation tool on one or more servers accessible by the remote client via the network. The method further includes receiving by the instance of the application transformation tool via the network a plurality of objects from a first instance of the application. The method also includes transforming by the instance of the application transformation tool the plurality of objects to provide a set of transformed objects for a second instance of the application.

In some embodiments the method includes receiving the request from the remote client in communication with a device running the instance of the application. In other embodiments the method includes receiving the request from a communication agent executing on the remote client in communication with the instance of the application.

In one embodiment the method includes requesting by the service a cloud service to establish one or more resources for establishing the instance of the application transformation tool. In a further embodiment the method includes initiating by the service execution of the instance of the application transformation tool using the one or more resources. In another embodiment the method includes establishing by the server the instance of the application transformation tool exclusive to the requestor. In still another embodiment the method includes receiving by the instance of the application transformation tool the plurality of objects via a virtual private network connection to the first instance of the application.

In some embodiments the method includes receiving by the instance of the application transformation tool the plurality of objects via a virtual private network connection to the remote client the remote client in communication with the first instance of the application. In other embodiments the method includes obtaining by a collection agent of the instance of the application transformation tool the plurality of objects from the first instance of the application. In still other embodiments the method includes transforming by the instance of the application transformation tool the plurality of objects to the set of transformed objects by applying a plurality of transformation rules.

In another aspect the present invention features a method for using via a network an application transformation service to transform an application. The method includes receiving by an application transformation service executing on one or more servers via a network from a remote client a request to transform an instance of an application. The method also includes receiving by the application transformation service via the network a plurality of objects from the instance of the application. The method further includes requesting by the application transformation service a cloud service to execute a transformation function on a first set of objects of the plurality of objects using a first set of computational resources. The method also includes requesting by the application transformation service the cloud service to execute the transformation function on a second set of objects of the plurality of objects using a second set of computational resources.

In some embodiments the method includes receiving the request from the remote client in communication with a device running the instance of the application. In other embodiments the method includes receiving the request from a communication agent executing on the remote client in communication with the instance of the application. In yet other embodiments the method includes receiving by the instance of the application transformation tool the plurality of objects via a virtual private network connection to the first instance of the application.

In one embodiment the method includes receiving by the instance of the application transformation tool the plurality of objects via a virtual private network connection to the remote client the remote client in communication with the first instance of the application. In another embodiment the method includes obtaining by a collection agent of the instance of the application transformation tool the plurality of objects from the first instance of the application. In yet another embodiment the method includes determining by the application transformation service the first set of objects from the plurality of objects to process using the first set of computational resources.

In some embodiments the method includes determining by the application transformation service the second set of objects from the plurality of objects to process using the second set of computational resources. In other embodiments the method includes executing by the application transformation tool one of parsing or transformation of the first set of objects. In yet other embodiments the method includes executing by the application transformation tool one of parsing or transformation of the second set of objects. In still yet other embodiments the method includes aggregating by the application transformation services results of performing the transformation function on each of the first set of objects and the second set of objects.

The details of various embodiments of the invention are set forth in the accompanying drawings and the description below.

The features and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings in which like reference characters identify corresponding elements throughout. In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements.

For purposes of reading the description of the various embodiments below the following descriptions of the sections of the specification and their respective contents may be helpful 

Prior to discussing the specifics of embodiments of the systems and methods of the solution of the present disclosure it may be helpful to discuss the network and computing environments in which such embodiments may be deployed. Referring now to an embodiment of a network environment is depicted. In brief overview the network environment comprises one or more systems in communication with one or more clients also generally referred to as remote machine s via one or more networks . Specifically shown are a bridge system a source system a target system an analyzer client and a configuration client . In some embodiments analyzer client and configuration client may be the same client. In other embodiments bridge system may be combined with analyzer client and or configuration client . In yet another embodiment bridge system may be combined with either source system or target system . In some embodiments a client communicates with a server via an intermediary appliance not shown such as a firewall a switch a hub a NAT a proxy a performance enhancing proxy a network accelerator a modem or other network device of any form or type.

As shown in the network can be a local area network LAN such as a company Intranet a metropolitan area network MAN or a wide area network WAN such as the Internet or the World Wide Web. Although not illustrated network may comprise one or more networks coupled either directly or via one or more intermediaries. In one embodiment network may be a private network. In another embodiment network may be a public network. In some embodiments network may be a combination of one or more private networks and one or more public networks. In some embodiments clients may be located at a branch office of a corporate enterprise communicating via a WAN connection over the network to the systems located at a corporate data center.

The network may be any type and or form of network and may include any of the following a point to point network a broadcast network a wide area network a local area network a telecommunications network a data communication network a computer network an ATM Asynchronous Transfer Mode network a SONET Synchronous Optical Network network a SDH Synchronous Digital Hierarchy network a wireless network and a wireline network. In some embodiments the network may comprise a wireless link such as an infrared channel or satellite band. The topology of the network may be a bus star or ring network topology. The network and network topology may be of any such network or network topology as known to those ordinarily skilled in the art capable of supporting the operations described herein.

As shown in bridge system may be a server or workstation configured to include a solution manager and or a collection agent discussed in more detail below. As discussed above although illustrated as a separate entity bridge system may be part of or combined with either or both of analyzer client and configuration client .

Source system may also be referred to as a source installation . In some embodiments source system or source installation may comprise a server or workstation with an installation or configuration of a version of one or more applications. In one embodiment the one or more applications may also include an operating system. In another embodiment the one or more applications may comprise an enterprise resource planning ERP software such as SAP Business Suite or SAP R 3 manufactured by SAP AG of Walldorf Germany Microsoft Dynamics manufactured by Microsoft Corporation of Redmond Wash. PeopleSoft manufactured by Oracle Corporation of Redwood Shores Calif. or any other type and form of enterprise or manufacturing resource planning software. In another embodiment the one or more applications may comprise any application that comprises an installation in a predetermined state and modifications to objects from the predetermined state. In an example of such an embodiment a default installation of an ERP application may be installed on source installation . To account for specific needs of the business or industry the installation may be modified with custom objects code or functions for performing additional tasks or managing additional resources not foreseen by the manufacturer of the ERP application. In another embodiment the source system or source installation may comprise any type or form of application containing modifications from an initial or default state.

An installation in a predetermined state may comprise any type and form of version installation and or state of configuration modernization or customization of the same at any point during development deployment or maintenance of the application. In some embodiments the predetermined state may be an initial or default installation of an application. In some embodiments the predetermined state may be the initial or default installation of a version of an application with a set of one or more configurations customizations or extensions. In some embodiments the predetermined state may be any version of an application with a set of one or more configurations customizations or extensions. In other embodiments the predetermined state may be any version that has been upgraded or transformed using any of the systems and methods described herein. In some embodiments the predetermined state may be any point of configuration or customization of a version of an application whether complete in process or otherwise. For example a predetermined state of an application may be any set point in development configuration or customization of an application. For example the systems and methods described herein may be used to transform the configuration or customization during the development phases before the final customizations or configurations are deployed for production.

Target system may also be referred to as a target installation . In some embodiments target system or target installation may comprise a server or workstation with an installation or configuration of a second version of one or more applications. In some embodiments the second version may be similar to the first version of one or more applications on source system . As described above source system may comprise custom objects codes or functions. Using the methods and systems described herein target system may be efficiently modified to comprise the custom objects codes or functions of source system . In some embodiments target system may comprise additional modifications to allow the custom objects codes or functions to execute or interact properly with the second version of the one or more applications. For example a company with an existing source system may wish to upgrade to a new version of an underlying application on a target system . The existing source system may have modifications and custom objects that the company wishes to include on target system . In some embodiments custom objects and code may be directly transferred and will perform without error on target system . However in many embodiments the custom objects and code may need further modifications due to differences between the underlying application of target system and source system .

Also shown in are analyzer client and configuration client . Although shown as separate clients in some embodiments analyzer client and configuration client may be combined and or may be combined with bridge system . Analyzer client and configuration client may each be a workstation client or server. In some embodiments analyzer client is configured with or executes an analysis agent and or transformer described in more detail below. In some embodiments configuration client is configured with or executes a configuration agent and or a manual conversion agent described in more detail below.

The bridge system source system target system analyzer client and configuration client may be deployed as and or executed on any type and form of computing device such as a computer network device or appliance capable of communicating on any type and form of network and performing the operations described herein. depict block diagrams of a computing device useful for practicing an embodiment of the client server or appliance . As shown in each computing device includes a central processing unit and a main memory unit . As shown in a computing device may include a visual display device a keyboard and or a pointing device such as a mouse. As shown in each computing device may also include additional optional elements such as one or more input output devices generally referred to using reference numeral and a cache memory in communication with the central processing unit .

The central processing unit is any logic circuitry that responds to and processes instructions fetched from the main memory unit . In many embodiments the central processing unit is provided by a microprocessor unit such as those manufactured by Intel Corporation of Mountain View Calif. those manufactured by Motorola Corporation of Schaumburg Ill. those manufactured by Transmeta Corporation of Santa Clara Calif. the RS 6000 processor those manufactured by International Business Machines of White Plains N.Y. or those manufactured by Advanced Micro Devices of Sunnyvale Calif. The computing device may be based on any of these processors or any other processor capable of operating as described herein.

Main memory unit may be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by the microprocessor such as Static random access memory SRAM Burst SRAM or SynchBurst SRAM BSRAM Dynamic random access memory DRAM Fast Page Mode DRAM FPM DRAM Enhanced DRAM EDRAM Extended Data Output RAM EDO RAM Extended Data Output DRAM EDO DRAM Burst Extended Data Output DRAM BEDO DRAM Enhanced DRAM EDRAM synchronous DRAM SDRAM JEDEC SRAM PC100 SDRAM Double Data Rate SDRAM DDR SDRAM Enhanced SDRAM ESDRAM SyncLink DRAM SLDRAM Direct Rambus DRAM DRDRAM or Ferroelectric RAM FRAM . The main memory may be based on any of the above described memory chips or any other available memory chips capable of operating as described herein. In the embodiment shown in the processor communicates with main memory via a system bus described in more detail below . depicts an embodiment of a computing device in which the processor communicates directly with main memory via a memory port . For example in the main memory may be DRDRAM.

The computing device may support any suitable installation device such as a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive tape drives of various formats USB device hard drive or any other device suitable for installing software and programs such as any client agent or portion thereof. The computing device may further comprise a storage device such as one or more hard disk drives or redundant arrays of independent disks for storing an operating system and other related software and for storing application software programs such as any program related to the client agent . Optionally any of the installation devices could also be used as the storage device . Additionally the operating system and the software can be run from a bootable medium for example a bootable CD such as KNOPPIX a bootable CD for GNU Linux that is available as a GNU Linux distribution from knoppix.net.

Furthermore the computing device may include a network interface to interface to a Local Area Network LAN Wide Area Network WAN or the Internet through a variety of connections including but not limited to standard telephone lines LAN or WAN links e.g. 802.11 T1 T3 56 kb X.25 broadband connections e.g. ISDN Frame Relay ATM wireless connections or some combination of any or all of the above. The network interface may comprise a built in network adapter network interface card PCMCIA network card card bus network adapter wireless network adapter USB network adapter modem or any other device suitable for interfacing the computing device to any type of network capable of communication and performing the operations described herein. A wide variety of I O devices may be present in the computing device . Input devices include keyboards mice trackpads trackballs microphones and drawing tablets. Output devices include video displays speakers inkjet printers laser printers and dye sublimation printers. The I O devices may be controlled by an I O controller as shown in . The I O controller may control one or more I O devices such as a keyboard and a pointing device e.g. a mouse or optical pen. Furthermore an I O device may also provide storage and or an installation medium for the computing device . In still other embodiments the computing device may provide USB connections to receive handheld USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry Inc. of Los Alamitos Calif.

In some embodiments the computing device may comprise or be connected to multiple display devices which each may be of the same or different type and or form. As such any of the I O devices and or the I O controller may comprise any type and or form of suitable hardware software or combination of hardware and software to support enable or provide for the connection and use of multiple display devices by the computing device . For example the computing device may include any type and or form of video adapter video card driver and or library to interface communicate connect or otherwise use the display devices . In one embodiment a video adapter may comprise multiple connectors to interface to multiple display devices . In other embodiments the computing device may include multiple video adapters with each video adapter connected to one or more of the display devices . In some embodiments any portion of the operating system of the computing device may be configured for using multiple displays . In other embodiments one or more of the display devices may be provided by one or more other computing devices such as computing devices and connected to the computing device for example via a network. These embodiments may include any type of software designed and constructed to use another computer s display device as a second display device for the computing device . One ordinarily skilled in the art will recognize and appreciate the various ways and embodiments that a computing device may be configured to have multiple display devices 

In further embodiments an I O device may be a bridge between the system bus and an external communication bus such as a USB bus an Apple Desktop Bus an RS 232 serial connection a SCSI bus a FireWire bus a FireWire 800 bus an Ethernet bus an AppleTalk bus a Gigabit Ethernet bus an Asynchronous Transfer Mode bus a HIPPI bus a Super HIPPI bus a SerialPlus bus a SCI LAMP bus a FibreChannel bus or a Serial Attached small computer system interface bus.

A computing device of the sort depicted in typically operate under the control of operating systems which control scheduling of tasks and access to system resources. The computing device can be running any operating system such as any of the versions of the Microsoft Windows operating systems the different releases of the Unix and Linux operating systems any version of the Mac OS for Macintosh computers any embedded operating system any real time operating system any open source operating system any proprietary operating system any operating systems for mobile computing devices or any other operating system capable of running on the computing device and performing the operations described herein. Typical operating systems include WINDOWS 3.x WINDOWS 95 WINDOWS 98 WINDOWS 2000 WINDOWS NT 3.51 WINDOWS NT 4.0 WINDOWS CE and WINDOWS XP all of which are manufactured by Microsoft Corporation of Redmond Wash. MacOS manufactured by Apple Computer of Cupertino Calif. OS 2 manufactured by International Business Machines of Armonk N.Y. and Linux a freely available operating system distributed by Caldera Corp. of Salt Lake City Utah or any type and or form of a Unix operating system among others.

In other embodiments the computing device may have different processors operating systems and input devices consistent with the device. For example in one embodiment the computer is a Treo 180 270 1060 600 or 650 smart phone manufactured by Palm Inc. In this embodiment the Treo smart phone is operated under the control of the PalmOS operating system and includes a stylus input device as well as a five way way navigator device. Moreover the computing device can be any workstation desktop computer laptop or notebook computer server handheld computer mobile telephone any other computer or other form of computing or telecommunications device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein.

In some embodiments a first computing device executes an application on behalf of a user of a client computing device . In other embodiments a computing device executes a virtual machine which provides an execution session within which applications execute on behalf of a user or a client computing devices . In one of these embodiments the execution session is a hosted desktop session. In another of these embodiments the computing device executes a terminal services session. The terminal services session may provide a hosted desktop environment. In still another of these embodiments the execution session provides access to a computing environment which may comprise one or more of an application a plurality of applications a desktop application and a desktop session in which one or more applications may execute.

Shown in is a block diagram of another embodiment of a system for analyzing and transforming an application from a source installation to a target installation. In brief bridge system may be configured with a solution manager which may include a collection agent and may be configured with a remote function call RFC user account A and a dialog user account A. Source system may be configured with a source installation which may include a collection plug in A. Source installation may also be configured with an RFC user account B and a dialog user account B. Target system may be configured with a target installation which may include a collection plug in B. Target installation may also be configured with an RFC user account C a dialog user account C and a tool user account . As shown Analyzer client may be configured with an analysis agent and a transformer . Configuration client may be configured with a configuration agent and a manual conversion agent . In one embodiment the collection agent is able to communicate with collection plug ins A and B via a network . As shown in some embodiments analysis agent and transformer may be configured to use RFC user accounts A C for communicating with systems . Transformer may also be configured to use tool user account . Additionally in some embodiments configuration agent and manual conversion agent may be configured to use dialog user accounts A C.

Still referring to and in more detail in some embodiments bridge system may be configured with or may execute a solution manager . In some embodiments solution manager may be an application process agent function routine logic or any type and form of executable instructions for snapshotting an installation. In some embodiments snapshotting or providing a snapshot of an installation comprises scanning and downloading components and or associations of an installation of an application such as source installation . Snapshotting may also be referred to variously as saving capturing imaging or storing an image copy or an instance of an installation. In additional embodiments solution manager may further comprise functions for compressing a snapshotted image. In still further embodiments solution manager may comprise or be associated with a storage medium capable of storing a snapshotted image. In one embodiment solution manager may connect via a network to a source installation described in more detail below. The solution manager may create a local copy of the entire source installation or in some embodiments may parse the source installation and copy a selected subset of the installation. For example in one such embodiment solution manager may parse the source installation for custom objects or code modified from a predetermined state of the source installation and store only a copy of the custom objects or code. In another such embodiment solution manager may determine a difference between source installation and target installation and store only the difference.

In many embodiments solution manager further comprises functionality for identifying an object as being in a predetermined state or being in a modified state. For example an object that has not been customized may in some embodiments be considered to be in a predetermined state. A predetermined state of an installation in such embodiments may be the state of the installation prior to customization or addition of custom objects functions or code. In further embodiments solution manager may comprise functionality for identifying an object as an asset within scope such as a program a database or a screen or an asset out of scope such as a task management system a scheduler an interface a peripheral system or a development environments. In yet further embodiments solution manager may comprise functionality for storing the identification of objects in a database index or list which may be referred to as a worklist. In some embodiments this worklist may sent to the analyzer client described in more detail below.

In many embodiments solution manager further comprises functionality for checking an object or code for compliance with a language syntax and or semantic rules . For example an object or code modified with custom programming may no longer be compliant with a standard syntax. In such a case solution manager may identify the object as being not in compliance. In another embodiment an object or code may be modified but still be compliant with a standard syntax. In such a case solution manager may identify the object as being compliant.

In some embodiments as shown in solution manager may comprise or include a collection agent . Collection agent may be an application process agent function routine logic or any type and form of executable instructions for downloading or copying all or part of a source installation to bridge system . In some embodiments collection agent connects via a network to a collection plugin A and or collection plugin B described in more detail below. Collection agent may in some embodiments comprise functions for downloading source installation data as described above. In further embodiments collection agent and collection plugins A and B may be a standard application type or comply with a standard application type and be executed by the source installation and or target installation without necessary modifications.

As shown in solution manager source installation and target installation may include user accounts such as Remote Function Call RFC users A C Dialog users A C and Tool user . RFC users A C referred to generally as RFC user s may be an account with authentication features such as a login name and password or other security methods and privileges allowing the account to get data from and insert data into source installation and or target installation . In some embodiments data inserted or retrieved from an installation may comprise objects code or functions. In some embodiments RFC users may also be referred to as System or Communication users. In further embodiments the Dialog users A C referred to generally as Dialog user s may be an account with authentication features similar to those mentioned with regard to RFC users and privileges allowing the account to interact with programs and functions of source installation and or target installation . In some embodiments a dialog user may have fewer privileges or more limited access than an RFC user . In additional embodiments the Tool user may be an account with authentication features similar to those mentioned with regard to RFC users and Dialog users and privileges allowing the account to use modification tools on target installation .

As shown in source system may comprise a source installation . As discussed above in connection with the discussion of source system source installation may be an installation or configuration of a version of one or more applications. In one embodiment the one or more applications may comprise an enterprise resource planning ERP software such as SAP Business Suite or SAP R 3 manufactured by SAP AG of Walldorf Germany Microsoft Dynamics manufactured by Microsoft Corporation of Redmond Wash. PeopleSoft manufactured by Oracle Corporation of Redwood Shores Calif. or any other type and form of enterprise or manufacturing resource planning software. In another embodiment the one or more applications may comprise any application that comprises a default or initial installation in a predetermined state and modifications to objects from the default state. In yet another embodiment the source system or source installation may comprise any type or form of application containing modifications from an initial or default state. As shown source installation may include one or more RFC users and or dialog users discussed above.

Additionally source installation may include or be configured with a collection plugin A generally referred to as a collection plugin . Collection plugins may comprise logic services hooking functions routines or any other type and form of function for gathering data of an installation such as source installation or target installation . In some embodiments collection plugins may further comprise functions for snapshotting or recording an image of an installation as the installation exists at a certain point in time. In some embodiments collection plugins may include the ability to push data over a network to collection agent while in other embodiments collection agent may pull data from the collection plugins.

Target system may comprise a target installation . As discussed above in connection with the discussion of target system target installation may be an installation or configuration of a second or subsequent version of one or more applications such as a version similar to but different from a previous version of one or more applications on source system . As described above source installation may comprise custom objects codes or functions. Using the methods and systems described herein target installation may be efficiently modified to comprise the custom objects codes or functions of source installation . In some embodiments target installation may comprise additional modifications to allow the custom objects codes or functions to execute or interact properly with the second version of the one or more applications. As shown in some embodiments target installation may include or comprise a collection plugin B and may include or be configured with accounts for RFC User C Dialog User C and Tool user discussed above.

As shown analyzer client may comprise or include an analysis agent and or a transformer . Analysis agent may comprise one or more applications logic functions services routines or executable instructions of any type or form for parsing a first and or a second installation of an application and creating a meta model described in more detail below. In some embodiments analysis agent comprises functions for downloading system objects identified by the solution manager for transformation. In additional embodiments analysis agent comprises functions for parsing the source code of programs databases screens task management systems schedulers interfaces peripheral systems development environments and other libraries for keywords functions objects or code corresponding to a defined language and syntax. In further embodiments analyzer client may comprise functions for detecting syntax and language violations. In one such embodiment analyzer client may comprise functions to categorize or identify the object responsive to detected violations as available for automatic upgrade semi automatic upgrade or manual upgrade. In an additional embodiment analyzer client may comprise functionality for presenting the categorized objects and or meta model to a user or administrator. In some such embodiments presenting the objects and or meta model may comprise creating and presenting a report and may include analysis of severity of required upgrades expected processing time percentage of upgrade that may be performed automatically and or cost to perform upgrading of the source installation.

Transformer may comprise one or more applications logic functions services routines or executable instructions of any type or form for transforming a meta model from one corresponding to one installation of an application to one corresponding to another installation of an application such as between a first and second or subsequent installation of the application. In some embodiments transforming a meta model comprises applying rules for modifying an object from a syntax or code language associated with the first installation to a syntax or code language associated with the second installation. For example in one embodiment a first language may include a function for allowing text input into a database. The second language may include a similar function but add different possible text encodings such as Unicode Transformation Format UTF 8 or punycode. In such an embodiment the transformer may apply a rule indicating to add a default encoding type to the function. Thus the object utilizing the function may then be used by the second installation with the second language and syntax. In some embodiments transformer further comprises functions for error checking transformed objects for compliance with rules language and or syntax standards. In another embodiment transformer further comprises functions for uploading transformed objects to target installation .

As shown analysis agent and transformer may in some embodiments be configured to use RFC users A C on the solution manager source installation and target installation respectively. This may enable analysis agent and transformer to retrieve and input data code and objects from and to these three systems. In a further embodiment transformer may be configured to use tool user on target installation . This may enable transformer to interact with system objects of the target installation that an RFC user may not be privileged to modify.

Also shown in configuration client may in some embodiments comprise a configuration agent and or a manual conversion agent . In some embodiments configuration agent and manual conversion agent may be configured to use Dialog Users A C as shown. This may enable a user or administrator interacting with configuration agent and or manual conversion agent to further interact with solution manager source installation and or target installation . In an embodiment not illustrated configuration agent and or manual conversion agent may also control or interact with analysis agent and or transformer for the purpose of modifying their settings.

Configuration agent may comprise one or more applications routines services functions or executable instructions of any form or type for configuring a rules engine discussed in more detail below. In other embodiments configuration agent may comprise functions for configuring solution manager source installation and or target installation . For example in one such embodiment configuration agent may configure the solution manager to only scan certain databases when snapshotting and categorizing objects.

Manual conversion agent may comprise one or more applications routines services functions or executable instructions of any form or type for allowing a user or administrator to perform modifications to objects categorized for semi automatic or manual upgrade. In some embodiments manual conversion agent may present a dialog to a user indicating the object to be upgraded and a language or syntax issue that could cause an error if the object is installed in target installation . In some embodiments manual conversion agent may also present suggested modifications to the object based on rules applied by the analysis agent . In further embodiments manual conversion agent may comprise functions for modifying the object responsive to an instruction from the user. In a further embodiment manual conversion agent may comprise functions for uploading the modified object to target installation and or analyzer client . In one example embodiment the manual conversion agent may present a dialog to a user indicating that an object of the source installation when upgraded to the target installation may perform an illegal operation due to differences in syntax such as dividing by a variable that has been set to zero. The user may instruct the manual conversion agent to make a modification such as changing the value of the variable or directing the operation to a different variable.

Shown in is another embodiment of a system for analyzing and transforming an application from a source installation to a target installation. In brief source system may comprise a source installation and collection plugin A discussed above. Bridge system may comprise a solution manager discussed above which may comprise an object analyzer syntax checkers A B unicode checker and post processing agent . Analyzer client may comprise an analysis agent which may further comprise a download engine and an analysis engine . The analysis engine may categorize code as automatic code A semi automatic code B or manual code C. Semi automatic code B is passed to a rule engine configured on transformer . Rule engine may apply rules to the semi automatic code B and pass the code to conversion engine . Automatic code A is passed from the analysis agent to the conversion engine . Automatic code A and semi automatic code B are passed from the conversion engine to the upload engine . The upload engine may upload converted automatic code A and semi automatic code B and unconverted manual code C to bridge system and solution manager . Configuration client may comprise a configuration agent which may configure rule engine of transformer and a manual conversion agent which may interact with post processing agent of solution manager . Although not shown solution manager may in some embodiments comprise an upload engine for transmitting processed and converted code to target installation of target system .

Still referring to and in more detail solution manager may be configured with an object analyzer . In some embodiments object analyzer may comprise one or more applications routines services functions or executable instructions of any form or type for analyzing an object obtained from collection plugin A. Although not shown object analyzer may further comprise functions for downloading objects identified by collection plugin A such as a collection agent discussed above. Analyzing an object as discussed above in connection with solution manager may comprise determining if the object is compliant with a standard syntax and identifying the object responsive to the determination as compliant or non compliant. Accordingly and as shown object analyzer may interact with syntax checker A. In some embodiments syntax checker A is a separate process while in others syntax checker A is a function or subroutine of object analyzer . In still other embodiments object analyzer may be a function or subroutine of syntax checker A.

Syntax checker A may in some embodiments comprise one or more applications routines services functions or executable instructions of any form or type for comparing an object to a standard syntax. In some embodiments syntax checker A may comprise associated libraries dictionaries databases or other data structures identifying syntax functions connectors comments instructions code or other objects of one or more languages. For example in one embodiment syntax checker A may include or be associated with a library defining objects in the Advanced Business Application Programming ABAP language designed by SAP AG of Walldorf Germany. In another embodiment syntax checker A may include a library defining objects in Java PHP Python Perl SQL or any other code language. In some embodiments syntax checker A compares code within an object identified by or obtained from collection plugin A with code in the library defining objects in a related language. In one example embodiment syntax checker A receives an object from collection plugin A that comprises a WRITE command. The syntax checker A compares the object to a dictionary which indicates that the WRITE command has been replaced by a WRITE TO command. Responsive to this comparison the syntax checker A and or object analyzer identifies the object as being non compliant. In some embodiments the identification of an object as compliant or non compliant may be in a separate object database registry or data structure while in other embodiments the identification may be inserted into the object.

As shown analysis agent may include a download engine . Download engine may comprise hardware and or software components comprising functions or executable instructions for downloading one or more objects and or identifications of objects as compliant or non compliant from solution manager . In some embodiments download engine utilizes an RFC user account on solution manager to download objects and or identifications as discussed above.

Analysis engine may in some embodiments comprise one or more applications routines services functions or executable instructions of any form or type for analyzing a capability of an object for upgrade to a target installation. For example in one embodiment an object identified as compliant with syntax of the language of the target installation may be determined to be capable of automatic upgrading and be identified as automatic code A. In one such embodiment the object may need no modifications to be used by the target installation . In another such embodiment the object may be identified as non compliant but need only minor modifications. For example a comment indicator used by the language of the source installation may be converted to a comment indicator of the language the target installation without requiring additional analysis. Similarly a function that included no variables in the source installation such as CLOSE may be converted to a function that includes optional variables in the target installation such as CLOSE without requiring additional analysis.

In another embodiment analysis engine may determine that a non compliant object needs modifications that may be performed automatically but also needs modifications that require additional input such as from a user or developer. This may be referred to as semi automatic code. For example in one embodiment source installation objects may include unicode characters binary data or a mix of binary data. In one such embodiment the target installation may include a function that interacts with objects differently if they are binary or unicode. In such an embodiment the analysis engine may indicate that some of the objects those that are solely binary or unicode may be converted automatically while objects that are mixed binary and unicode may require a user to designate a mode. In such an embodiment analysis engine may indicate that the objects are semi automatic code B. In another example an object of the source installation may contain a function that writes into a database. In one such embodiment the target installation may have more than one corresponding database. For example source installation may be a single user environment and have only one user database while target installation may be a multi user environment. In some embodiments the WRITE function may need to have modifications that can be performed automatically such as the addition of optional variables or conversion to a WRITE TO statement and modifications that require input from a user such as a path to a specific directory or database in the multi user environment of the target installation. Again in such an embodiment analysis engine may indicate that the objects are semi automatic code B.

In another embodiment analysis engine may indicate that a non compliant object may not be automatically or semi automatically converted to the language and or syntax of the target installation and may identify the object as manual code C. For example a source installation object may use a function of the source installation language that has been obsoleted or for which no corresponding function exists in the target installation. In one such embodiment the source installation object may read from a common memory. However in the target installation a common memory may have been replaced by isolated memory for privacy and security reasons. Accordingly a READ COMMON function may be obsolete. Upgrading the function or an object using the function may in such an embodiment require further input not available to the transformer . Responsive to this determination analysis engine may indicate that the object is manual code C.

In further detail of some of the embodiments of automated systems and methods an object of a source installation may have elements capable of being upgraded transformed or converted to a language and syntax of a target installation in a manner essentially independent of additional user developer input or other external control. These elements may be referred to as automatic code or automatic elements. In other embodiments an object may have elements that are incapable of being upgraded transformed or converted to a language and syntax of a target installation in a manner essentially independent of additional user developer input or other external control. These elements may be referred to as manual code or manual elements. In some embodiments an object may have a combination of both automatic elements and manual elements. In these embodiments the ratio of elements that are capable of upgrade to elements in the object may used to determine an automation value for the object. In further embodiments the automation value may be compared to one or more thresholds. For example if the automation value is equal to or less than a first threshold the object may be categorized as manual. If the automation value is equal to or greater than a second threshold the object may be categorized as automatic. If the automation value is greater than the first threshold but less than the second threshold the object may be categorized as semi automatic. In some embodiments the first threshold may be set at zero such that an object may be categorized as manual only if it has no elements that are capable of upgrade. In other embodiments the second threshold may be set at 1 such that an object may be categorized as automatic only if it has no elements that are incapable of upgrade.

In a further embodiment analysis engine may create a meta model representative of one or more objects of source installation . The meta model in some embodiments may be a syntax tree or abstract syntax tree and may represent relationships between the one or more objects of the source installation . In further embodiments the meta model may be presented to a user in either a textual or graphical format. In additional embodiments the meta model may contain links to corresponding source code of the one or more objects. In such embodiments an element in the meta model may maintain or include a reference to the original source file and line number. In further embodiments the meta model may also comprise a mapping of elements to objects. The meta model in many embodiments is a generic structure of nodes representing objects and connectors representing relationships between objects. In such embodiments the meta model has no syntax itself and does not correspond to a specific language. In additional embodiments the meta model may be used for processing and transforming objects of the source installation into objects usable by the target installation by finding and replacing patterns of connections. In some embodiments the meta model may map mutual relationships between objects and characterize relationships as static or dynamic. In such embodiments a dynamic relationship between objects may change during runtime. For example a first object may depend alternately on a second object or a third object responsive to an indicator within a fourth object. When the indicator within the fourth object changes the first object s dependency likewise changes. In other embodiments the meta model may map the relationship of objects to other system entities such as data elements operating system programs system application programs transactions environment settings etc.

In some embodiments analysis engine may further comprise functions for inserting comments into source code of an object. These comments may indicate suggested modifications to the object or potential errors or warnings if the object is not further modified. For example as discussed above an object classified as semi automatic code B may require explicit identification of a working directory on the target installation that does not correspond to a directory existing on source installation . Accordingly analysis agent may add a comment to source code of the object indicating that a user should add explicit identification of a working directory.

Analysis agent may also in some embodiments comprise functions or executable instructions for generating a report and or presenting the report to a user. In these embodiments the report may include analysis of ratios of automatic code semi automatic code and manual code A C and may include descriptions of objects likelihood of errors when transforming objects estimated time and or cost to transform objects and may include graphs charts and or text. The report may also include a graphical or textual representation of the meta model.

In additional embodiments analysis agent may be configured by a user with analysis rules. In these embodiments analysis rules may be used to ensure that relevant information of interest to the user will be analyzed while increasing efficiency of analysis by ignoring other information. For example rules may be set to allow analysis of just compliant or non compliant objects rather than both sets of objects. In some embodiments rules may be selected to allow or disallow analysis of objects with unicode violations analysis of objects that must change with a transformation analysis of obsoleted objects analysis of statistics relating to the transformation such as time and or cost and analysis of transformations in specified languages such as ABAP or Java. As referred to herein unicode may be source code that complies with syntax and language rules of the target installation. Although referred to as unicode it does not designate a specific embodiment of unicode such as the unicode standard for text. Rather unicode may simply refer to a language utilized by a target or source installation such as Java Python Perl PHP or any other type and form of computing language. In additional embodiments analysis rules may be configured to determine elements in the meta model that match customer defined characteristics such as invocation of customer programs use of text specified modification dates or any other type and form of information relating to or associated with an element.

In some embodiments the analysis agent may be used outside of a transformation context to analyze custom code for objects in a source installation as they are being written. For example the analysis agent may be used to measure whether coding standards are being followed by determining if an object may be classified as automatic code A for transformation to a hypothetical target installation that is identical to source installation . A determination that the object is semi automatic code B or manual code C may indicate that additional data should be added to the object such as full path names to directories or explicit indication of ASCII or binary data in a string.

In some embodiments analysis engine may be configured to detect object clones. An object clone may be objects that are similar to each other or similar to standard objects of the system provided by the application manufacturer. For example one developer may create an object such as a current invoices database with links to customer and sales databases and another developer may create a similar current invoices database with a different name due to miscommunication or lack of communication. Although the names are different the two databases are substantially similar. Future edits or modifications to one database however may result in behavior unexpected to a developer who only knows about the other database. Accordingly an analysis engine may be configured to detect these clones and flag them for removal modification transformation or deletion. In one embodiment clones may be detected by comparing normalized lines of the object code to create a commonality rating. If the commonality rating exceeds a predetermined threshold the objects may be considered clones. Similarly in some embodiments analysis engine may be configured to detect multiple versions of an object and include only the latest version of the object for transformation.

As shown in transformer may include a rule engine . In some embodiments this rule engine may be configured by a configuration agent on configuration client . Rule engine may comprise an application process agent function routine logic or any type and form of executable instructions for modifying semi automatic code B in accordance with rules selected or configured by a user using configuration agent . For example as described above an object classified as semi automatic code B may require explicit identification of a working directory on the target installation that does not correspond to a directory existing on source installation . A user may select or configure a rule that identifies a working directory to be added to the source code of the object. Rules engine may then apply this rule and modify the object accordingly. In some embodiments selecting or configuring rules may be referred to as parameterization.

Objects that are identified as automatic code A or have been modified by the rules engine may in some embodiments be sent to conversion engine . Conversion engine may comprise an application process agent function routine logic or any type and form of executable instructions for transforming objects from a language associated with a source installation to a language associated with a target installation. In many embodiments rules engine and conversion engine may comprise similar functionality with conversion engine applying preset or predetermined rules. In such embodiments conversion engine may comprise or be associated with a database or data structure containing predetermined rules for a language or languages to allow conversion. Unlike rules configured by configuration agent and applied by rules engine rules applied by the conversion engine may in some embodiments be unmodifiable by a user. In some embodiments rule engine and conversion engine may be combined and may use a single rules database. In further embodiments configuration agent may be permitted to modify only a subset of predetermined rules in the rules database. One example of a predetermined rule may be a rule indicating that a comment tag from a language associated with a source installation may be transformed or modified to a comment tag from a language associated with a target installation . Accordingly in one embodiment of this example conversion engine may replace comment tags in a source code of an object responsive to the rule.

As shown transformer may further comprise an upload engine . Upload engine similar to download engine may comprise hardware and or software components for uploading or transferring objects to bridge system . In some embodiments and as illustrated upload engine may upload converted or transformed automatic code and semi automatic code A B and may further upload unconverted manual code C. In some embodiments download engine utilizes an RFC user account on solution manager to upload objects as discussed above.

Solution manager may further comprise a unicode checker and a syntax checker B as shown in . Unicode checker may comprise an application process agent function routine logic or any type and form of executable instructions for checking unicode compliance of a transformed object. Similarly syntax checker B may comprise an application process agent function routine logic or any type and form of executable instructions for checking object compliance with syntax of a language associated with target installation . In some embodiments responsive to failure to comply with syntax and or unicode solution manager may present warnings or errors to a user. In other embodiments responsive to failure to comply with syntax and or unicode solution manager may send the object back to analysis agent for re analysis and re transformation.

Solution manager may comprise a post processing agent . Post processing agent may comprise an application process agent function routine logic or any type and form of executable instructions for modifying an object responsive to instructions from a user interacting with manual conversion agent on configuration client . In some embodiments manual conversion agent may comprise an editing application allowing a user to modify source code of an object and may include features such as automatic recognition of functions of a language display of comments such as those inserted by analysis engine and any other features useful to a developer. Although not shown post processing agent and manual conversion agent may comprise functionality for communicating over a network to allow a user interacting with configuration client to modify an object stored on bridge system . In an example embodiment an object categorized as manual code C may be edited by a user via manual conversion agent and post processing agent to repair unicode functions language features and or syntax inconsistent with a language associated with target installation .

Although not illustrated in solution manager or bridge system may further comprise hardware and or software components for uploading modified and or post processed objects to target installation .

Referring now to illustrated is a block diagram of an embodiment of an analysis and transformation of a source installation into a target installation. As described above a source installation on source system may be analyzed to create a meta model . As shown meta model may comprise objects or nodes and links or structure representative of dependencies and interactions between nodes. In some embodiments the meta model may be transformed into transformed meta model responsive to predetermined rules and or configured rules. For example in a language associated with source installation a first node representing an function may be dependent on a second node representing an included library of the function. However in a language associated with target installation the first node representing the function may be dependent on both a second and third node representing two included libraries. Alternately the first node representing the function may in the language associated with the target installation have no dependencies due to explicit inclusion of code in the included library. Accordingly in this example embodiment transforming the meta model to transformed meta model may comprise moving the first node representing the function to a higher level within the abstract syntax tree.

Shown in is a block diagram of an embodiment of a transformation process . In brief an optimization engine may apply modernization rules to create an optimized abstract syntax tree . The optimized abstract syntax tree may be further modified by a programmer to create target code associated with a target language syntax dictionary . Using test data the target code may be tested at .

Still referring to and in more detail modernization rules may include a language token or tokens language syntax and semantic rules . A token may be a structured element of code as defined by the source language. For example in the expression print hello world tokens include print hello world and . Determining tokens in source code is sometimes referred to as tokenization or tokenizing and may in some embodiments be performed by lexical analysis engine and configured on optimization engine . In some embodiments language tokens may be codified and in some embodiments stored in a database dictionary or other data structure.

Lexical analysis engine may comprise an application process agent function routine logic or any type and form of executable instructions for locating and interpreting language tokens within source code of an object as described above.

Language syntax may be a representation of a grammar system within a language. A grammar may in some embodiments address location and manipulation of tokens. For example a token of a semi colon used in the above example may indicate in a language that it is the end of a statement. Tokens after the semi colon may apply to the following statement while those before the semi colon apply to the preceding statement. Language syntax may in some embodiments be stored in a database dictionary or other data structure. In some embodiments parser engine configured on optimization engine may use grammar identified by language syntax to parse tokens identified by lexical analysis engine . This may be referred to variously as syntactic analysis semantic parsing parsing or analyzing.

As shown parser engine may comprise an application process agent function routine logic or any type and form of executable instructions for interpreting language tokens located in a source code with language syntax to create an abstract syntax tree also referred to above as a meta model by applying semantic rules . Semantic rules may in some embodiments be stored in a database dictionary or other data structure accessible to parser engine . In some embodiments parser engine may comprise a top down parser such as a recursive descent parser or a Left to right Leftmost derivation LL parser. In other embodiments parser engine may comprise a bottom up parser such as a precedence parser a bounded context BC parser or a Left to right Rightmost derivation LR parser.

Using any of the methods or functions described herein programmer may convert abstract syntax tree to an optimized abstract syntax tree . Programmer may in some embodiments comprise part or all of analysis agent discussed in more detail above. Optimized abstract syntax tree may be a transformed meta model discussed above. In some embodiments optimization of an abstract syntax tree may be performed responsive to semantic rules and language syntax associated with a target language syntax dictionary . Objects of a source installation may be transformed to target code responsive to differences between the optimized abstract syntax tree and abstract syntax tree .

In some embodiments test data may be applied to target code for testing purposes . In further embodiments testing may be performed by a user while in other embodiments testing may be performed by a service or application identifying errors such as buffer overruns unescaped loops and other programming errors.

Referring now to shown is a block diagram of an embodiment of a system for analyzing changes in customized code from a previous instance of transformation of the customized code. In some embodiments such a system may be used to maintain an application installation by monitoring and analyzing changes to code databases and or objects for conformance to a predetermined set of code rules. In many embodiments this or a similar system may be used after transformation of an installation as discussed above to analyze and maintain changes to reduce time and expense for future upgrades and transformations. In brief overview a maintenance tool comprises a collection agent and analysis agent . In some embodiments maintenance tool further comprises a transformer . Maintenance tool may connect to a target system or source system not illustrated using any of the methods and systems discussed above. In some embodiments using collection agent and connecting to a collection plugin on the target system or source system the maintenance tool may take one or more snapshots of a target installation or source installation using any of the methods and systems described above. In some embodiments code objects and or databases may comprise default code or code that comes from a manufacturer of an application. Such code may include both original default code with no changes since its installation and modified default code with changes performed by a developer user or administrator of the system. Maintenance tool may be configured to detect and analyze changes to default code because in many instances modifications to this default code may not conform to coding rules for the application. In many embodiments code objects and or databases may comprise custom code which may include code modified or written prior to a last transformation by a transformation system as discussed above and code modified or written since the last transformation. In some embodiments code modified or written prior to the previous transformation may now conform to coding rules because of manual or automated debugging and editing during the previous transformation. However code written or modified since the last transformation may need to be analyzed to ensure compliance or conformation to these rules.

Although referred to in as a maintenance tool one should note the similarity of features to the analyzer client shown in . In many embodiments a system may be referred to interchangeably as an analyzer client or a maintenance tool or may be referred to as an analyzer client during transformation of source installation to a target installation and then referred to as a maintenance tool during later periodic maintenance and analysis of new changes to code or objects.

In some embodiments maintenance tool may be configured to enumerate modifications to code since a previous transformation of the application or may be configured to enumerate a portion of the modifications that violate a predetermined coding rule of the application. In many embodiments maintenance tool may be configured to output a report which may include a name or ID of an object that has been modified a type or class of the object the time or date at which the object was last modified last accessed or both the name or ID of the developer administrator or user who modified the object an ERP transport of the object such as an SAP transport a description of the object including some or all of the code of the object code comments relating to the object interdependencies with other objects a description or name of the predetermined coding rule violated a recommendation for how to modify the object to conform to the coding rule an estimated time and or cost to modify the object to conform to the coding rule or any other information available regarding the object the modification and the application. In many embodiments the maintenance tool may detect and report multiple instances changes to an object or code since a previous transformation including multiple modification times and or multiple developers who made changes. In some embodiments the maintenance tool may report trends such as the number of objects or lines of code changed over time or the number of violations of predetermined coding rules committed by one or more developers over a time period. Such embodiments may be useful for training developers or performing budgetary analysis by management.

In some embodiments maintenance tool may comprise a database of predetermined code rules similar to the rules database or syntax dictionaries discussed above. In many embodiments maintenance tool may comprise a syntax checker and or unicode checker also discussed above.

Referring now to illustrated are block diagrams of embodiments of a system for deploying an analysis or transformation tool. For simplicity not all components shown in or C are illustrated. One skilled in the art may readily envision such other components being included via similar connections to those discussed here. In many embodiments an analysis transformation or maintenance tool may be deployed locally or on site connected to the same local network as the target and or source installations. However this may require physically shipping servers or clients to a corporate headquarters or other installation as well as providing technicians operators and developers and may increase costs. As such in many embodiments it may be desirable to deploy these tools via a wide area network. Additionally deploying tools via such networks provides scalability and stability. Additional servers or clients may be added as necessary and because analysis transformation and maintenance tools may then run in a consistent environment installation costs and complexity may be reduced. Furthermore the analysis transformation and or maintenance tools may be more protected against unauthorized modifications and computer virus or other attacks as opposed to sending physical systems to a customer and letting them be connected to the customer s local network.

For example referring to an analyzer client may access a source system or target system or bridge systems not illustrated via a network connection over a wide area network such as the Internet. For security in many embodiments the analyzer client source system connection may be encrypted or comprise a virtual private network VPN connection. Similarly a configuration client may be deployed on site or elsewhere and connect to the analyzer client through a VPN or secure HTTP HTTPS connection a Secure Socket Layer SSL connection a Transport Layer Security TLS connection an Internet Protocol Security IPSec secured connection or any other type of secured connection. In some embodiments configuration client may include a simplified user interface to the analyzer client or other tools such as a web browser connecting to a dynamically generated web page or may comprise a thin client or remote desktop interface.

Similarly referring to in some embodiments a bridge system may be deployed locally and connect via a local network to a source system or other systems yet still connect to an analyzer client via a wide area network connection. This may reduce the complexity of the wide area network or virtual private network. In some embodiments the bridge system or similar client may serve as a communications redirector between the local source system or other systems and the remote analyzer client or other tools.

In another embodiment shown in the client or tools may be deployed locally on a virtual machine executing on a local machine. Because the virtual machine may be protected from modification installation errors and complexity may be reduced. Furthermore by using a virtual machine the system may be virtually shipped either via download over a wide area network or Internet or may be shipped on a storage medium such as a CD ROM or flash drive at greatly reduced expense from that required to ship an entire server.

The above discussed deployment scenarios can be easily scaled via a server cloud. Shown in is a block diagram of an embodiment of a system for using a cloud service to analyze and transform an application. Multiple customers may simultaneously or concurrently use the analysis transformation and maintenance features provided by a system or portion thereof executing via the cloud service. One or more application transformation service providers control communications redirection routing and load balancing features for the cloud. In many embodiments an application transformation service may comprise one or more servers configured to perform these functions and may be deployed either locally at a customer s location or remotely via a wide area network as discussed above. In some embodiments the application transformation service may receive code and objects from one customer and from another customer simultaneously. The application transformation service may then direct these objects to one or more analyzer clients one or more analysis agents one or more transformers or other tools or clients not illustrated which may be provided by one or more servers in the cloud. In some embodiments application transformation service may direct objects based on load balancing requirements including server or process CPU utilization idle times or memory or other resource requirements. In other embodiments application transformation service may direct objects based on different functions performed by analysis or transformation clients. For example objects requiring unicode verification may be sent to a first analyzer while objects requiring language parsing may be sent to a second analyzer. In some embodiments a single object may be sent to multiple analyzers or transformers for concurrent or parallel analysis or processing. In some embodiments an object may be returned to application transformation service from a first server and redirected to a second server for further analysis or transformation. In many embodiments objects from various customers and may be tagged or identified such that upon receiving them from various servers in the cloud application transformation service may properly direct them to the corresponding customers systems.

Although the director in is referred to above as an application transformation service in many embodiments it may be considered a component of the application transformation service which may also comprise the various tools agents and analyzers of the cloud. Accordingly the term application transformation service may refer to the overall service including the various routers gateways and tools running on one or more servers.

Although denoted in by service type as discussed above analzyer clients analysis agents transformers and other clients and tools not illustrated may be provided by one or more servers in the cloud. Accordingly in some embodiments one or more servers in the cloud may execute a tool such as an analysis agent or transformer responsive to a request by application transformation service or a configuration client bridge system or any other remote client. Thus instances of these tools may be dynamically established as needed.

In many embodiments application transformation service may comprise a Software as a Service SaaS deployment model. In such embodiments execution of analysis and transformation tools may be transparent to customers source systems target systems bridge systems and configuration clients. Clients agents transformers and other tools may be embodied as services or applications of one or more application transformation services . Application transformation services may further comprise functionality for billing and licensing and online or remote storage.

In one such embodiment objects of the application may be transmitted to the application transformation service for analysis and or transformation. In many such embodiments applications or services may be executed by application transformation service or be executed by one or more servers directed by application transformation service .

Accordingly inputs to the application transformation service may comprise a database code a file of objects in a predetermined format exported by the application to be transformed or any other format capable of being transmitted to and processed by application transformation service . Similarly in many embodiments the application transformation service may output a database code or file of objects in the predetermined format for import by the application to be transformed. In many embodiments such input and output files may be compressed and or encrypted for security and efficiency.

In another embodiment analysis and or transformation applications may be transmitted to the source system bridge system target system or other local system for execution. In a further such embodiment application transformation service may comprise a licensing server to control or limit execution of the applications on the customer s servers or computing devices.

In still another embodiment remote access to the source system bridge system target system or other local system may be granted to application transformation service . For example in one such embodiment a VPN connection an SSL connection a TLS connection an HTTPS connection an IPsec connection or any other secure connection may be established between the system to be analyzed or transformed and application transformation service . Accordingly application transformation service may request files objects databases or other code directly from the source or target application and may write transformed files objects databases or other code to the target installation directly. In some embodiments application transformation service may transmit commands to be executed directly on the source or target installation as needed. In some embodiments application transformation service may comprise a broker for a service oriented architecture SOA in which each analysis client transformer or other function acts as a service provider. Each function may thus comprise an application with an application service layer and application transformation service may provide a domain service layer and or enterprise service layer. In another embodiment source and or target installations may also comprise an SOA architecture. One such embodiment includes SAP Business ByDesign provided by SAP AG of Walldorf Germany.

Shown in is a flow chart split across two figures for clarity illustrating an embodiment of a method of analyzing and transforming an application from a source installation to a target installation. In brief at step a snapshot is taken of a source installation. At step a determination is made as to whether the source installation may be upgraded. If the source installation cannot be upgraded the method exits and may in some embodiments return an error or display further instructions. If the source installation may be upgraded then at step the project is defined and configured. At step an object may be downloaded from the source installation. At step an identification of the object may be made to determine if it has been modified from a predetermined state. In some embodiments not illustrated responsive to a determination that the object has not been modified the object may be discarded and the method may move to step described below. If the object has been modified then at step the object may be parsed into a set of elements. At step a meta model may be generated representing the modified object. At step a determination may be made as to whether more objects exist in the source installation. If so steps may be repeated. In some embodiments repetition of step may comprise modifying a generated meta model to include representations of each additional modified object parsed during repetitions of step .

At step analysis rules may be applied to each element in the meta model. At step a determination may be made as to the transformation capability of each object. At step a report may be generated and in some embodiments displayed to a user. At step the user may customize analysis rules. If analysis rules have been customized then steps may be repeated. If analysis rules are not customized at step then at step the meta model may be transferred to a transformer discussed above. At step transformation rules may be applied to the meta model to create a transformed meta model. At step an object may be modified to generate a transformed object responsive to dependencies and rules associated with the transformed meta model. At step a determination may be made as to whether more objects exist. If so steps and may be repeated. If not then at step a comparison report may be generated comparing transformed objects with their untransformed states. At step a user may customize transformation rules. If the rules are customized then steps may be repeated. At step the snapshot taken at step may be compared with a current state of the source installation. If the source installation has changed then steps may be repeated.

At step transformed objects may be uploaded to the target installation. At step the target installation may be post processed which may comprise making additional manual changes to objects uploaded to the target installation. At step the target installation may be compiled and or tested.

Still referring to and in more detail at step a snapshot may be taken of a source installation. As described above in some embodiments taking a snapshot may comprise storing a copy of one or more objects of a source installation as they exist at a certain time. In further embodiments only part of the source installation may be snapshotted. For example in one such embodiment only customized or modified objects of the source installation may be snapshotted to save analyzing unnecessary elements.

At step in some embodiments a determination may be made whether the source installation may be upgraded. For example in one such embodiment the source installation may already have been upgraded to the same version as the target installation and thus not require upgrading. In some embodiments the source installation and target installation may not be compatible for an upgrade. In some embodiments the system determines the number of changes issues or non compliancy exceed a predetermined threshold for upgrading to the target system.

At step the project may be defined and configured. In some embodiments defining and configuring the project may comprise selecting a version and or language for a target installation. In additional embodiments configuring the project may comprise installing and configuring a target installation in a default or predetermined state lacking customized objects. In a further embodiment configuring the project may comprise setting up RFC Dialog and Tool user accounts as discussed above.

At step an object may be downloaded from a source installation using any of the methods and systems described herein such as a collection agent and a collection plugin. At step the object may be identified as modified from a predetermined state. In an alternate embodiment not shown steps and may be reversed such that objects are identified as modified before they are downloaded. Such an embodiment may allow the system to avoid downloading unmodified objects as discussed above. In some embodiments identifying an object modified from a predetermined state may comprise identifying an object that does not exist in a source installation. For example a custom database may not exist in a default source installation and accordingly may be considered to be a modified object.

At step the object may be parsed into a set of elements using any of the methods and systems described herein. For example an object source code may be tokenized and parsed to determine elements and relationships between elements.

At step a meta model may be created and or modified to include the elements and relationships identified at step using any of the methods and systems described above. For example creating the meta model may comprise creating an abstract syntax tree representative of the elements and their interrelationships. The system may generate a meta model for all the elements of the source installation. In some embodiments the system may generate a meta model for a portion of elements of the source installation such as the elements identified as changed from the predetermined state.

At step a determination may be made as to whether more objects and or modified objects exist in the source installation and if so steps may be repeated. In some embodiments this determination may be made by comparing the number of nodes in the meta model with the number of identified objects in the source installation snapshot. In other embodiments this determination may be made by failing to locate an additional object or modified object that has not yet been downloaded and parsed.

At step analysis rules may be applied to each element in the meta model. At step a transformation capability may be determined for each object. For example an object may be classified as automatic code semi automatic code or manual code as described above. At step a report may be generated. In some embodiments applying analysis rules comprises performing the functions described above in connection with the analysis client and or analysis engine. In additional embodiments generating a report comprises analyzing statistics of the transformation capability of each object such as determining ratios of automatic semi automatic and manual code and determining cost and or time to perform upgrades as described above.

At step analysis rules may be customized and steps repeated. For example responsive to determining that upgrading may be too costly due to a large number of objects to be transformed a user may modify analysis rules to exclude a portion of the objects. Steps may be repeated in some embodiments until the user is satisfied with the outcome indicated by the generated report.

At step the meta model may be transferred to the transformer. In some embodiments transferring the model may comprise transmitting the model to the transformer while in other embodiments transferring the model may comprise the analysis client instructing the transformer to access the model on a shared memory element.

At step the transformer may apply transformation rules to the meta model to generate a transformed meta model using any of the systems and methods discussed herein. In one embodiment applying transformation rules may comprise locating a pattern in the meta model corresponding to an entry in a transformation rule database. In a further embodiment applying transformation rules may comprise modifying an abstract syntax tree according to a rule associated with an entry in a transformation rule database. For example in one such embodiment the transformer may determine that a first element is dependent on a second element. The transformer may further determine that the second element is a function call such as a WRITE instruction. The transformer may locate a rule in the rule database associated with target installation language matching a first element dependent on a WRITE instruction and apply the rule to modify the WRITE instruction to a WRITE TO instruction.

At step in some embodiments the transformer may generate a transformed object according to the transformed meta model. In some embodiments generating a transformed object comprises modifying a source object. In other embodiments generating a transformed object comprises generating a new object. In one embodiment a transformed object may be generated responsive to transformation rules discussed above. For example an object including code representing a WRITE instruction as discussed at step may be modified to include code representing a WRITE TO instruction. Further changes may be made responsive to transformation rules and or the transformed meta model. For example a first object dependent on a second object in the original meta model may be dependent on a third and fourth object in the transformed meta model. Accordingly at step the transformer may replace in source code of the first object references to the second object with references to the third and or fourth object. In an example of one such embodiment in a source installation a first object comprising a human resources database may be dependent on another object comprising an organizational hierarchy. However in the transformed meta model the human resources database may further comprise organizational hierarchy and not be dependent on a second object. Accordingly in this example embodiment the transformer may modify the first object to further comprise fields indicating levels and interconnections previously described in object comprising the organizational hierarchy. In further embodiments generating a transformed object may comprise generating an object that possesses desired characteristics defined by the transformation rules such as being free of syntax violations and or naming convention errors or any other type of characteristic of a source code that may be desired by a user.

At step a determination may be made if more objects exist using similar methods to those described above at step . If so steps may be repeated.

At step a comparison report may be generated. In one embodiment a comparison report comprises a comparison of untransformed elements and or objects and transformed elements and or objects. In a further embodiment the comparison report may be displayed or presented to a user. For example in an embodiment of the example discussed above at step a report may be generated showing a the first object comprising the human resources database with source code showing dependency on the second object comprising the organizational hierarchy and b the first object comprising the human resources database with source code showing no dependency on the second object but rather including additional data representing the hierarchical levels and interconnections.

At step the user may customize the transformation rules. In some embodiments this may be done for increasing efficiency adjusting for undesired behavior or any other reason. Referring to the example discussed above at step a user may decide that it is preferable to maintain the separate human resources database and organizational hierarchy and may adjust the transformation rules to exclude or disable this transformation. In another example an organization may be expanding simultaneously with upgrading and may be adding additional manufacturing locations. In such an example a user may modify the transformation rules to incorporate the additional resources for each new manufacturing location such as additional inventory databases additional shipping locations or any other type and form of resource or object. In some embodiments if the user has customized or modified the transformation rules steps may be repeated.

At step the analysis client may determine if the source installation has changed since the snapshot was taken. This could occur for example if analysis transformation and customization have taken a significant amount of time. If so steps may be repeated. In some embodiments repeating steps may comprise repeating steps only on objects that have been modified in the source installation since the previous snapshot. These embodiments may reduce analysis transformation and customization time greatly as only objects that have changed will need to be re analyzed and transformed. In further embodiments transformed objects that have not changed in the source installation may be stored on a storage element until the determination at step indicates that no further changes have occurred in the source installation.

Responsive to no further changes having occurred in the source installation since the previous snapshot was taken at step the object transformations may be applied to the target installation. In some embodiments applying the transformations may comprise uploading or transmitting transformed elements and or objects to the target installation using any of the methods or systems discussed herein.

At step the target installation may be post processed. In some embodiments post processing the target installation may comprise editing manual or semi automatic code as discussed above. In additional embodiments post processing the target installation may comprise optimizing the installation. For example optimization may include compressing the installation removing unnecessary comments and or code cleaning up or removing unused variables or any other type and form of source code optimization.

At step the target installation may be tested. In some embodiments step may further comprise compiling the target installation. In other embodiments the target installation does not require compiling for example if all objects are XML objects. In some embodiments testing the target installation comprises installing test data to the target installation performing modifications to objects and databases and verifying expected results. In some embodiments responsive to errors during testing one or more steps of method may be repeated for example steps .

Referring now to a flow chart of an embodiment of a method of analyzing changes in customized code of an application is shown. In brief overview at step an automated maintenance tool may identify one or more changes to customized code of an enterprise resource planning ERP application. At step the automated maintenance tool may determine which portions of changes to the customized code violate a predetermined set of coding rules. At step the automated maintenance tool may enumerate portions of the changes to the customized code that violate the predetermined set of coding rules by type of object time developer transport or other information. At step the automated maintenance tool may transform the changes of the customized code to conform to the predetermined set of coding rules. Although these steps are discussed as being performed by the automated maintenance tool in many embodiments as discussed above the automated maintenance tool may comprise multiple modules or tools including a collection agent an analysis agent and a transformer. Accordingly these modules may perform some or all of the functionality discussed below. For example in some embodiments the college agent may identify changes to code and the analysis agent may determine which portions of identified changes violate the predetermined coding rules.

Still referring to and in more detail at in some embodiments an automated maintenance tool may identify one or more changes to code of an application. In some embodiments the maintenance tool may look at timestamps of changes and identify any changes since a previous time. In another embodiment the maintenance tool may compare current code or a portion of current code to a snapshot of code take at an earlier point in time such as a previous instance of transformation of the code. Thus the maintenance tool may identify from an instance of an application previously transformed as discussed above customized code changed or modified since the previous execution of transformation. In many embodiments the automated maintenance tool may identify application objects defined by a user or developer within the changed code. Furthermore in some embodiments the automated maintenance tool may also identify changes to default code of the application such as that code provided by the application manufacturer.

In some embodiments the automated maintenance tool may interface with a version control system revision control system software configuration management SCM system transport system or similar system for tracking incremental changes to software code. Such version control system may be integrated into the application in some embodiments while in other embodiments an external auditing version control system may be utilized such as the local based revision control system RCS or the server based concurrent versioning system CVS developed by the GNU project or any similar system capable of tracking revisions to code by time developer object and or transport. In further embodiments the automated maintenance tool may identify changes to code via a change package provided by the version control system.

At step the automated maintenance tool may determine whether the identified changes conform to a set of predetermined coding rules and may determine which portion of the identified changes violate the coding rules. In many embodiments these coding rules may be used to transform an application as discussed above or may be used to transform later changes to the application. Accordingly in some embodiments it may be assumed that changes made prior to a previous execution of transformation are now in conformance with the coding rules reducing the need for the automated maintenance tool to parse the entire code for changes. In many embodiments the automated maintenance tool may identify objects that comprise changed code that violates coding rules or references or are referenced by the changed code. For example the automated maintenance tool may identify a changed object that references a library that did not change and may thus identify the library as being referenced by a changed object. In some embodiments the automated maintenance tool may identify deviations from one or more naming conventions. In other embodiments the automated maintenance tool may identify obsolete programming constructs in the changes such as functions that no longer apply to a new version of the application. This may be valuable for example when developers used to a previous version of the application make modifications to code without realizing that the new version does not include the same functions classes or objects. Accordingly the automated maintenance tool may be used for both maintaining an application over time and for training developers.

At step the automated maintenance tool may enumerate the changes or portions of the identified changes that violate the predetermined set of coding rules. In many embodiments the automated maintenance tool may output a report enumerating the changes. Such report or enumeration may include or be sorted by one or more of the following developer name or ID time type of object object name or ID rule violated version of the application or any other available information. In many embodiments multiple developers may make changes to a single object or a developer may make multiple changes over time. Accordingly in such embodiment the object may be enumerated multiple times with reference to each developer and or time the object was changed. In some embodiments the automated maintenance tool may display training information to a user or developer based on the changes and such training information displayed may be limited to changes made by that developer that violated the coding rules.

At step in some embodiments the automated maintenance tool may transform the identified changes to the code that violate the predetermined set of coding rules such that the changes to the customized code then conform to the coding rules. This may be done using any of the functions and methods discussed above for transforming an application such that the non conforming code may be considered a source installation to be transformed into a target installation. Thus in many embodiments this transformation may comprise providing or generating a second transformed application. In some embodiments the automated maintenance tool may create a snapshot post transformation to identify future changes to the customized code.

Shown in is a flow chart of an embodiment of a method of applying one or more rules that transform objects of an application. In some embodiments an instance of an application may comprise both standard objects provided by the application or the manufacturer of the application and custom objects provided by a developer of the application as discussed above. In many embodiments the developer may have the ability to modify objects and code in ways that are not allowed. For example a developer may modify objects provided by the application manufacturer but doing so may void the warranty provided by the manufacturer or violate a terms of use contract license or agreement. In practice in some embodiments it may be difficult or impossible to prevent the developer from being able to modify these objects. Accordingly although an object may be modified it may not be considered a modifiable object. In addition to being referred to as a not modifiable object such objects may be referred to variously as not permissibly modifiable or alterable not legally modifiable or alterable or that the developer is not allowed or not authorized to modify or alter the object.

Aside from potentially voiding a manufacturer s warranty modifications to these objects may result in run time errors or unpredictable behavior. Accordingly when applying automated transformations using the methods and systems discussed herein it may be desirable to first detect whether an object may be permissibly alterable or whether changes or transformations of an object may result in an unintended modification to a non legally modifiable object. For example a custom object may include a form defined by a non legally modifiable standard object and may reference a global variable. Because the standard object cannot be legally changed the global variable may not be legally renamed without requiring an illegal modification of the standard object or breaking the form. In another example a variable may be defined by a non modifiable object using an obsolete function. Although the function is now obsolete the variable may not be modified with additional arguments or newer functions because the non modifiable object cannot be legally modified.

In some embodiments objects or code may be tagged as not permissibly alterable such as via a flag or string. In other embodiments objects or code may be identified as not permissibly alterable based on their name. For example in one such embodiment an object with a name that starts with a specific letter or string may be identified by the application as a standard object or an object provided by the manufacturer and not legally alterable. In another embodiment an object may be within a group a folder or a type that has been identified as not legally alterable. In still another embodiment an object may be permissibly alterable but reference or interact with a standard object or function that is not permissibly alterable. For example in one such embodiment a custom object may pass data to a standard object and the standard object may expect the data in a certain data type or format such as an integer. Changing code of the custom object to modify the data type to another format such as a string may result in errors when the string is passed to the standard object and interpreted as an integer. Accordingly in some such embodiments the object may be renamed but internal code of the object or variables passed by the standard function may not be altered.

In brief overview at step an application transformation tool may identify objects of an application that have been modified. At step the application transformation tool may detect whether each of the objects are permissibly alterable. At step the application transformation tool may determine whether the objects reference or interact with a standard interface of the application. At step the application transformation tool may apply one or more rules that transform any of the objects that do not reference or interact with the standard interface of the application.

Still referring to and in more detail in some embodiments at step an application transformation tool may identify one or more objects of a current instance of an application that have been modified from a prior instance of the application. This may be done using any of the methods and functionality discussed above in connection with including via an interface to a version control system by comparing a current version of an application to a previous snapshot of the application by identifying objects with recent modification times or any other methods. Although referred to as the application transformation tool in many embodiments an agent of the application transformation tool such as the collection agent may perform these functions.

At step in some embodiments the application transformation tool may detect whether each of the identified modified objects are permissibly or legally alterable. In some embodiments the application transformation tool may detect whether the objects are permissibly alterable based on a flag ID name or portion of a name type class or group of the object. In other embodiments the application transformation tool may detect whether the objects are permissibly alterable based on whether the objects reference a non permissibly alterable object or are referenced by a non permissibly alterable object. In one embodiment the application transformation tool may detect whether an object is permissibly alterable by comparing the name of the object to a list index or database of standard objects of the application. In a further embodiment if the name of the object includes a portion of a name of a standard object it may be considered unalterable. In some embodiments the application transformation tool may detect that an object is alterable based on having a registered namespace such as a namespace reserved for the customer licensing the application. In other embodiments the application transformation tool may detect that an object is alterable based on a name of the object having a predetermined set of characters such as a prefix of Y or Z .

At step in some embodiments the application transformation tool may determine whether each of the permissibly alterable objects reference or interact with a standard interface of the application. In many embodiments the application transformation tool may parse search or scan the code of a modified permissibly alterable object for a name of a standard interface function variable form database or other standard code object to determine whether the alterable object references a standard object. As discussed above such standard interfaces may themselves be unalterable so reference to or interaction with them by the alterable object may make the object unalterable. Similarly in many embodiments the application transformation tool may determine whether the permissibly alterable object is referenced by or interacts with a standard or unalterable object and if so determine that the permissibly alterable object cannot be renamed. In one embodiment the application transformation tool may mark or flag an object as unalterable responsive to the determination. In another embodiment application transformation tool may alert or notify an administrator or developer that an object has been modified but is unalterable due to a reference to or interaction with a standard object.

At step in some embodiments the application transformation tool may transform modified alterable objects that do not reference or interact with the standard interface of the application by applying one or more rules to the objects. In many embodiments transforming an object may be performed through the systems and methods discussed above in connection with .

In some embodiments objects may be identified as partially alterable. For example as discussed above in one embodiment a standard function may reference or interact with an object that may itself be alterable. Accordingly code of the object may be modified but the name of the object must remain the same to avoid error when the standard function attempts to reference or interact with the object by the old name. Thus in an extension of the method discussed above an object may be identified as partially alterable and have an alterable portion of the object transformed by the application transformation tool while an unalterable portion is left untransformed.

As discussed above in connection with in some embodiments an application analysis and transformation tool may be deployed via a network or as part of a cloud service. An application transformation service may serve as a communications director and load balancer for the cloud. Referring now to a flow chart of an embodiment of a method of dynamically deploying an application transformation tool via a network is illustrated. In brief overview at step a service such as the application transformation service executing on one or more servers may receive a request from a remote client. Such request may comprise a request to transform an instance of an application a request to maintain or analyze a previously transformed instance of the application or a request to establish an instance of an application transformation tool. At step the service may receive one or more objects of the instance of the application to be analyzed transformed or maintained. At steps and the service may fulfill the request by establishing an instance of the transformer or transmitting the request to a transformer service respectively. For example in an embodiment utilizing step instances of the transformation tool may be dynamically established and disestablished according to need. In an embodiment utilizing step the transformation tool may be a service or function of an executing service and as such may not need to be established but merely executed or requested to execute. At step the service may transform the objects.

Still referring to and in more detail at step an application transformation service may receive a request via a network from a remote client. In some embodiments the application transformation service may receive a request to transform modify maintain or analyze an instance of an application. In other embodiments the application transformation service may receive a request to establish an instance of an application transformation tool. In many embodiments the request comprises a request to establish a VPN connection SSL or TLS connection HTTPS connection IPsec secured connection or other secure connection with a source and or target system or bridge system as discussed above. In some embodiments the request may be generated by a communication agent executing on the remote client and may be on the same computing device or a different computing device than the application.

At step in some embodiments the application transformation service may receive one or more objects from the instance of the application to be transformed modified maintained or analyzed. As discussed above such objects may comprise executable code databases forms a snapshot a CVS or RCS log or change package or other objects useable by the transformation service. Although illustrated as occurring after step in many embodiments step may occur after steps or discussed below.

At step in some embodiments the application transformation service may establish an instance of the application transformation tool on one or more servers accessible by the remote client via the network. In some embodiments establishing an instance of the application transformation tool may comprise initiating execution of an application initiating a virtual machine or generating a user account corresponding to the remote client. In one embodiment the application transformation service may request a cloud service a server within a cloud service or an application agent or other entity within a cloud service to establish one or more resources for establishing the instance of the application transformation tool such as a virtual machine or server a user account a memory storage element or other resource. In a further embodiment the application transformation service may initiate execution of the instance of the application transformation tool using the established resource or resources. For security and stability in many embodiments the application transformation service may establish separate instances of the application transformation tool for each requesting client of a plurality of remote clients.

At step the application transformation service may request a cloud service server within a cloud or application agent daemon or other utility within a cloud service to execute a transformation function on one or more of the received objects using a set of one or more resources. In some embodiments the application transformation service may request the cloud service to execute a transformation function on a subset of the received objects the subset determined based on object names or IDs classes types or other features. In a further embodiment the application transformation service may request the cloud service to execute a second transformation function on a different subset of the received objects and may indicate to use a second set of one or more resources. In some embodiments the application transformation service may determine the sets of one or more resources responsive to load balancing requirements idle times memory requirements network latency bandwidth usage. In other embodiments the application transformation service may determine the sets of one or more resources responsive to different transformation functions executed by the resources. For example a first resource such as a syntax analyzer may execute an analysis function while a second resource such as a transformer may execute a transformation function. In some embodiments the application transformation service may request the cloud service to execute a first transformation function on an object and then execute a second transformation function on the object using the same or different resources.

At step in some embodiments the established application transformation tool or the application transformation service or cloud service may transform the objects. In some embodiments transforming the objects may comprise applying one or more transformation rules to the objects as discussed above. In other embodiments transforming the objects may comprise parsing the objects transforming the objects applying rules to the objects verifying conformance with rules or any of the other functions and features described above. In some embodiments in which a first set of resources performs a transformation function on a first set of objects and a second set of resources performs a transformation function on a second set of objects the application transformation service may receive and or aggregate the results of the transformation functions or the transformed objects. In many embodiments the application transformation service may transmit the transformed objects or aggregated transformed objects to the remote client and or remote system.

As discussed above these methods of using a cloud service for application transformation provide both flexibility in deployment and advantages in parallel and concurrent processing and transformation of objects of the application. This may reduce the need for customers of the application transformation service to supply local infrastructure and allow the service to support the needs of multiple customers simultaneously.

Shown in are screenshots of an embodiment of a system for analyzing and transforming an application from a source installation to a target installation. The screenshots are intended for illustrative purposes only and are not intended to be limiting. In some embodiments these screenshots may be presented to a user using an analysis client and or configuration client described above. In the following descriptions the system will be referred to as executing on a client. However in many embodiments the system may execute on a bridge system a source system or a target system described above or any computing device.

Shown in is a screenshot of an embodiment of a database connection window. In some embodiments the database connection window may provide a list of databases previously used or connected to. Selecting a database from the list of previously used databases may in some embodiments allow a user to avoid having to type in one or more of a nickname URL username password and schema . In some embodiments previously entered nicknames may be displayed in list . In other embodiments list may display URLs of previously used or connected to databases. In some embodiments username and password may provide authentication such as that discussed with regard to RFC users dialog users and tool users above. In some embodiments schema may comprise an indicator of a type of communication. For example schema may be RFC representing a remote function call BAPI representing a business application programming interface BDC representing a batch data communication or an indicator of any other type and form of communication method. In one embodiment where schema is RFC username and password may be entered for a corresponding RFC User account as discussed above.

Shown in is a screenshot of an embodiment of a SAP system selection dialog. In some embodiments once connected to a database through the connection window shown in the selection dialog shown in is presented to a user. In some embodiments the selection dialog comprises fields for a connection host system number username and description . In further embodiments connection and or host may represent a URL or IP number of a system such as a bridge system a source system or a target system as discussed above. In some embodiments fields may be populated automatically for an entry through a discovery means. In other embodiments fields may be populated automatically for an entry through recall from a previously stored value. In still other embodiments fields may be populated manually by a user entering data as described below in connection with . For example a user may create or edit entries by selecting the new or edit buttons respectively. In some embodiments entries may be deleted by a user selecting the delete button. In still other embodiments connection to a system such as bridge system source system or target system may be tested by a user selecting the corresponding entry and selecting the test button. In such an embodiment the client may test a connection to the selected entry by for example transmitting a network ping to the corresponding IP. In further embodiments testing a connection may comprise the client verifying a username password and or other authentication parameters on the selected system.

Shown in is a screenshot of an embodiment of an system definition dialog. In some embodiments this dialog is presented to a user responsive to the user selecting the new or edit buttons shown in . As shown the definition dialog may comprise a connection description a connection logical name a host address a system number a client number a username a password a system identification SID a pool size a language and a system type . In one embodiment responsive to the user selecting the test button connection to the defined system may be tested as described above.

Shown in is a screenshot of an embodiment of a customer selection dialog. As shown an entry in the customer selection dialog may comprise a customer number a first name part a second name part a city a country and a system type . Although not illustrated responsive to a user selecting the new button a customer definition dialog may be presented to the user. In some embodiments the customer definition dialog is similar to the system definition dialog illustrated in .

Shown in are screenshots of an embodiment of a source and target system selection dialog respectively. In some embodiments source and target system selection dialogs are used to select a source system comprising a source installation to be upgraded to a target system comprising a target installation using any of the systems and methods described herein. As shown a source system dialog may comprise a name description release version and system identification SID . Similarly a target system dialog may comprise a name description release version and SID .

Shown in is a screenshot of an embodiment of a protocol selection dialog. In some embodiments entries in the protocol selection dialog may be populated automatically responsive to protocols defined on the bridge system source system and or target system. As shown protocol selection dialog may comprise fields for mandatory optional status SRTFD logical system creation or modification date creator and description .

Shown in is a screenshot of an embodiment of a verification dialog. In some embodiments verification dialog may allow a user to verify previous selections. For example and as shown session name and session description may in some embodiments correspond to a connection description and connection name discussed above. In other embodiments the session name and session description may be entered manually or modified to describe a specific instance of analysis and or transformation. Also shown are selection options for a language and or locale a project phase . Also shown are fields populated responsive to earlier selections such as system customer source system target system and protocol . Also shown is program field which may be populated automatically by the client with identifications of programs and or installations such as source installation and target installation.

Shown in are screenshots of an embodiment of a comparison report described above. As shown the comparison report may comprise an index or list of objects . The comparison report may further comprise a chart of the ratio of classifications of parser identifications . For example as shown in this example the parser has identified a ratio of objects that may need transformation to those that may not require transformation . Although not illustrated in some embodiments selecting issues may display a ratio of objects with severe errors if not upgraded minor errors if not upgraded and no errors if not upgraded. For example in one embodiment an object may be classified as having a severe error if failure to transform the object would result in an endless loop or a divide by zero error. In another embodiment an object may be classified as having a minor error if failure to transform the object would result in a warning dialog. In some embodiments selecting actions may display a ratio of objects that may be automatically semi automatically and manually transformed. In other embodiments selecting data may display a list of underlying numerical data used to display the chart as shown.

Also shown in is a comparison window and a code window . As shown code window may display a list or index of objects. Selecting an object may in some embodiments cause the source code of the object to be displayed in the before window and the source code of the transformed object to be displayed in the after window . In some embodiments one or more indicators may be displayed between before window and after window indicating where transformations have occurred.

Shown in are screenshots of an embodiment of a project analysis report. As shown a project analysis report may comprise analysis results which may in some embodiments describe the type number and percentage ratios of parser issues. In some embodiments the project analysis report may also comprise parser actions which may describe the type number and percentage ratios of actions to be taken by the parser. In additional embodiments the project analysis report may also comprise a listing of programs or objects in an installation and a corresponding number of issues with each program or object. As shown in some embodiments a project analysis report may also include charts and illustrating the percentage ratios for analysis results and parser actions respectively. In an additional embodiment not illustrated project analysis report may further comprise a report on an estimated time and or cost to transform a source installation to a target installation.

Shown in are screenshots of an embodiment of a parser configuration tool . As shown in parser commands may be selected for display. In some embodiments the commands may be read only as shown while in other embodiments the commands may be editable. In further embodiments commands may be editable responsive to an authentication or privilege level of the user. As shown in display of current parser commands commands may comprise a key a command usage an origin a status for whether the command has started is obsolete or is unavailable and a description of the command. In some embodiments parser commands may comprise tokens and or syntax as discussed above.

As shown in parser issues may be selected for display. In some embodiments the parser issues may be read only as shown while in other embodiments the parser issues may be editable. In further embodiments parser issues may be editable responsive to an authentication or privilege level of the user. As shown in display of current parser issues issues may comprise a classification a code a description in one or more languages a local name a message to be inserted into code in one or more languages a remove name and a release version.

As shown in the parser may utilize handlers . In some embodiments handlers may be xml files comprising analysis configurations. In some embodiments the list of parser handlers may be read only as shown while in other embodiments the list may be editable. In further embodiments the list may be editable responsive to an authentication or privilege level of the user. As shown in display of current parser handlers entries may comprise a name a configuration and a description. In some embodiments the configuration field represents or indicates a memory location where the configuration is stored.

Shown in are screenshots of an embodiment of a report of objects analyzed and transformed from a source installation to a target installation. As shown in one embodiment the report comprises a header . The header may comprise fields such as a rule code a number of occurrences and a classification. The rule code may be a text label numerical code or any combination of numbers and characters to identify a rule. The number of occurrences may in some embodiments reflect the number of occurrences of the rule identified by the rule code being applied in the transformation. In other embodiments the number of occurrences may reflect the number of occurrences of the object in databases objects and other elements of the source installation to which the rule will be applied. The classification may identify a classification of the rule. In some embodiments the classification may be release indicating that the rule is specific to a version of the application such as the version of the target installation. In other embodiments the classification may be unicode indicating that the rule is a unicode violation applicable to all versions of the application. In still other embodiments the classification may be obsolete indicating that the object may be obsolete or unused in the language of the target installation. In yet other embodiments the classification may be customization indicating that the rule is a custom rule added by a user or developer.

As shown in some embodiments header may also comprise a severity a parser action and an action. The severity may in some embodiments be an indication of how likely errors are to occur if the object is installed unmodified in the target installation. In some embodiments the severity may warning which may indicate that the severity is minimal. In other embodiments the severity may be minimal . In still other embodiments the severity may be severe or may be an indicator such as error or UC error indicating a unicode or other error. The parser action may in some embodiments be an indicator whether the object is automatic code semi automatic code or manual code as discussed above. The action may in some embodiments indicator an action for the transformer to take. For example the action may be replace indicating that source code of the object will be replaced or modified according to the rule. In other embodiments the action may be warning indicating that the transformer will add a warning into the source code but may in some embodiments not replace or modify the source code.

Also shown in is a rule description and comments . In some embodiments the rule description and comments may be modified by a user or developer to include more or less information as desired. As shown one or both of these fields may be blank. Also shown in is a message put in code . In some embodiments message put in code may be a comment inserted into source code of an object during transformation. In one embodiment the message put in code may be used to document changes. In other embodiments the message put in code may be used for later searching through source code of a target installation to locate objects that have been modified. This may be done for example for debugging and testing purposes. As shown message put in code may comprise symbols that may be automatically expanded as the message is put in the code. For example in the message put in code includes W which may in some embodiments be expanded to Warn when the message is inserted into source code during transformation. Similarly the message put in code may include a date code such as MM DD YY which may in some embodiments be expanded to the current 2 digit month 2 digit day and 2 digit year when the message is inserted into source code during transformation. Also for example the message put in code may include a version number of a target installation such as 3.1.3 shown in . In some embodiments the message put in code may also include an indicator for automatic semi automatic or manual code or an indicator for a warning such as A or W . In further embodiments indicators such as the above mentioned symbols may be used by a user or developer to search through source code for debugging or testing. In other embodiments the indicators may be used by the analysis tool in generating statistics for reporting as discussed above.

Also shown in is an object with before transformation and after transformation source code segments and an expected automation rate . As shown in some embodiments object may comprise a title name or other identifier of an object such as a path to the object. In some embodiments source code segments may comprise an indicator such as a line number identifying where in the source code of the object the modification will occur during transformation. Source code segments may indicate specific modifications to source code of an object during transformation and may include message put in code as shown. Expected automation rate may comprise an indicator such as a percentage of expected automation success. For example as shown in in the example embodiment 62 occurrences of 83 occurrences of the ZSDR Z56 UPLOAD object include mixed data types and require further information to be transformed. Accordingly the expected automation rate is 25 .

Shown in are screenshots of an embodiment of a report of remaining manual effort RME required to transform an application from a source installation to a target installation. As shown in one embodiment the RME report may comprise a list of issue types each with an associated number of issues. In some embodiments the number of issues for each issue type may be automatically generated by the parser and or analyzer as described above. In some embodiments the list of issue types may be divided into sections corresponding to Unicode issues Release issues Obsolete issues and Customization issues as discussed above in connection with . Additionally in some embodiments each issue listed may be associated with one or more configurations e.g. FIRST indicating Configuration 1 SECOND indicating Configuration 2 etc. or no configurations. Each of these configurations may in some embodiments represent transformation configurations and the association of an issue with a transformation configuration may indicate that the issue is one that has been configured for automated upgrade or transformation in that particular transformation configuration. In an example not illustrated a first configuration may be configured to automatically upgrade issues associated with unicode concatenate commands and may be configured to not automatically upgrade issues associated with obsolete concatenate commands. Accordingly in this example the unicode concatenate issue may have an indicator associating it with the first configuration while the obsolete concatenate issue may not have an indicator associating it with the first configuration.

In some embodiments the RME report may also comprise a configuration analysis window as shown. The configuration analysis window may include a list of object types as shown. Additionally the configuration analysis window may also include for each object type numbers indicating the elements associated with the object type that may be automatically upgraded or transformed e.g. handled and the elements associated with the object type that may require manual upgrading or transformation. In some embodiments the numbers indicating the elements that require manual upgrading or transformation may be further subdivided by estimated complexity of the upgrade or transformation as shown e.g. high medium and low . In further embodiments the formula for estimating complexity of issues may be preconfigured while in other embodiments the formula may be adjusted by a user. In some embodiments the configuration analysis window may further comprise an analysis of one or more automatic transformation configurations compared to manual upgrade of all issues e.g. unassisted . These embodiments may be useful for allowing users to compare different transformation configurations with each other and with an estimated time cost of manual upgrade.

For example in the embodiment illustrated in there are a total of 3121 issues in the application to be transformed to the target installation. A first transformation configuration Conf 1 has been analyzed along with a fully manual unassisted upgrade. The first configuration has a total of 3112 issues that may be handled or upgraded automatically and 9 issues of low complexity that will require manual upgrading. This is compared to the unassisted transformation which has 43 issues of high complexity 812 issues of medium complexity and 2266 issues of low complexity. In this illustrated example these numbers are also displayed as a bar graph.

Additionally the RME report may in some embodiments comprise an estimation of time and or cost for remaining upgrades and transformations and testing and total time and or cost required. For example in the embodiment illustrated the 3112 handled issues of the first configuration will take an estimated 32 days 3 20 hours to upgrade automatically and the remaining 9 low complexity issues will take an estimated 3 days 7 30 hours to upgrade plus 45 hours to test. Accordingly upgrading the source installation using the first transformation configuration will take an estimated total of 36 days 3 35 hours. This is compared in the example shown to a fully manual unassisted upgrade which will require a total 1627 days 6 35 hours to upgrade. In some embodiments these time estimates may be multiplied by an hourly rate to determine an estimated cost.

In some embodiments the time analysis report may further comprise an estimate of time to upgrade objects with issues set to manual or semi auto. In further embodiments the time analysis report may also comprise a comparison between a time estimate to upgrade a source installation without automation e.g. unassisted as discussed above and a time estimate to upgrade a source installation with automation. For example in the embodiment illustrated it is estimated that it will take as much as 368 days 58 hours to upgrade the source installation without automation and 1 56 hours to upgrade the source installation with automation for a savings of 99.9 of the time required to perform the upgrade. In many embodiments the time analysis report may contain further comparisons as shown including a pie or bar chart comparing issue types issues by application program within the source installation estimated time required to upgrade each application program within the source installation etc.

In many embodiments the reports shown in and A D may be dynamic reports. These reports may change in real time reflecting changes made by a user to transformation configurations or other settings. For example if a large portion of high complexity manual upgrades are related to one application program within the source installation and the user determines that said application program need not be upgraded the user may exclude the application program from the upgrade. Accordingly the analyzer would re analyze the time and cost analysis and remaining manual effort analysis removing issues associated with the excluded application program and reducing the estimated time to upgrade the source installation. In these embodiments a user may compare estimates of many transformation configurations for efficiency and time cost savings and adjust configuration parameters before actually performing any transformations.

Although generally described in a network environment the various embodiments of the methods and systems described above may also in some embodiments be utilized in an off line format. In some embodiments the methods and systems described above may also be utilized in a non real time format. For example in one such embodiment solution manager may be used to create a snapshot of a source installation . The snapshot may then be recorded on a portable storage medium such as a CD ROM a DVD ROM a hard disk a floppy disk a flash drive a ZIP drive or any other type and format of storage medium or memory device for transferring data from one computer to another. The storage medium may then be manually transferred to the analyzer client which may be located nearby or may be located in another department building city or country. In some embodiments this may involve shipping or mailing the storage medium to the location of the analyzer client . In other embodiments the snapshot may be digitally transferred to the analyzer client although the analyzer client may not necessarily have RFC access to the bridge system . For example in one such embodiment the snapshot may be emailed to the analyzer client . In another such embodiment the snapshot may be transferred over a network such as the Internet via any type of file transfer protocol such as FTP.

Similarly in some embodiments the metamodel may be transferred to the configuration client using any of the methods described above. Likewise transformation configurations reports and time cost analyses may be transferred between the various systems and clients using any of the methods described above. For example in one such embodiment a consultant may utilize a bridge system to create a snapshot of a source system while in the same building and on the same network as the source system . The consultant may then bring the snapshot to another location such as the consultant s office to perform analysis and transformation configuration. The consultant may transfer reports to and from the client for example over email. Once a transformation configuration has been accepted the consultant may then return to the building containing the source system and execute the transformation.

In still further embodiments the analysis and transformation can be performed on separate client systems. For example in one such embodiment the analysis could be performed on one analyzer client and the transformation configuration could be created. The transformation configuration could then be transferred via a computer readable medium to another client system for performing the transformation. Similarly one skilled in the art can appreciate that other methods described above can be split between one or more client machines with intermediary files such as a partial snapshot or analysis complete snapshot or analysis configuration file report or any other type and form of file being transferred from one client machine to another client machine where the snapshotting analysis configuration and or transformation may be continued.

While various embodiments of the methods and systems have been described these embodiments are exemplary and in no way limit the scope of the described methods or systems. Those having skill in the relevant art can effect changes to form and details of the described methods and systems without departing from the broadest scope of the described methods and systems. Thus the scope of the methods and systems described herein should not be limited by any of the exemplary embodiments and should be defined in accordance with the accompanying claims and their equivalents.

