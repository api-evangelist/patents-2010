---

title: System and method for reporting a synchronization event in a runtime system of a computer system
abstract: A system and computer-implemented method for reporting a synchronization event in a runtime system of a computer system. A synchronization primitive in a runtime system of the computer system is monitored. A synchronization operation performed on the synchronization primitive by a thread in the runtime system is detected. An enumerator for the synchronization primitive is incremented when the synchronization operation satisfies predetermined criteria. A synchronization event that includes data relating to the synchronization operation performed on the synchronization primitive is reported.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09141439&OS=09141439&RS=09141439
owner: SAP SE
number: 09141439
owner_city: Walldorf
owner_country: DE
publication_date: 20101011
---
The disclosed embodiments relate generally to reporting a synchronization event in a runtime system of a computer system.

Many processors include multiple processing cores. In order to take advantage of the multiple processing cores of a processor programmers write multi threaded applications in which multiple threads of an application are distributed across the processing cores of the processor and executed substantially simultaneously by the cores of the processor. The resources of the processor e.g. cache memory are typically shared between the threads of the application. Accordingly a first thread of the application may attempt to use the same resource as a second thread of the application. In order to maintain consistency of the shared resources only one thread is allowed to use a shared resource at any given time. All other threads are blocked from using the shared resource and must wait for their turn to use the shared resource. As a result deadlocks and or performance bottlenecks may occur because only a subset of the threads can execute in parallel while the other threads wait for the shared resources to become free.

The description that follows includes illustrative systems methods techniques instruction sequences and computing machine program products that embody illustrative embodiments. In the following description for purposes of explanation numerous specific details are set forth in order to provide an understanding of various embodiments of the inventive subject matter. It will be evident however to those skilled in the art that embodiments of the inventive subject matter may be practiced without these specific details. In general well known instruction instances protocols structures and techniques have not been shown in detail.

In many runtime systems e.g. a JAVA Virtual Machine it is possible to execute several threads concurrently. A first thread can exchange data with a second thread by storing data in a shared data structure that is accessible to both threads. For example the shared data structured may be stored in shared memory of the runtime system. In order to maintain the consistency of data in the shared data structure synchronization primitives e.g. locks object monitors etc. are used to guard the shared data structure in the shared memory. Using these synchronization primitives it is possible to maintain the consistency of the data by for example allowing only one thread to execute a critical section of code that requires use of the shared data structure. All other threads attempting to access the shared data structure are blocked from entering the critical section.

Due to the blocking nature of most synchronization primitives the throughput and scalability of multi threaded applications may be severely limited if multiple threads contend for few synchronization primitives. The embodiments described herein allow the user to identify contended synchronization primitives and give the user insight into how long each thread of execution is blocked by other threads that are using a synchronization primitive.

In the thread requires use of the shared resource and requests use of the synchronization primitive . Since the thread has not released use of the synchronization primitive the thread must wait e.g. idle until the thread has released use of the synchronization primitive .

In the thread releases use of the synchronization primitive . Accordingly the thread no longer has exclusive use of the shared resource .

In since the thread has released use of the synchronization primitive the thread acquires use of the synchronization primitive . Accordingly the thread now has exclusive use of the shared resource .

Note that requesting acquiring and releasing use of a synchronization primitive are each referred to as a synchronization operation herein. In some embodiments a synchronization event is emitted to a synchronization trace when a thread performs a synchronization operation involving a synchronization primitive.

In some embodiments a synchronization primitive is used to guard a shared resource. In these embodiments the synchronization operation may be an operation that requests use of the synchronization primitive and the corresponding synchronization event is an enter event corresponding to a time when the thread attempts to enter a critical section by requesting use of a synchronization primitive. The synchronization operation may also be an operation that acquires use of a synchronization primitive and the corresponding synchronization event is an entered event corresponding to a time when the thread enters the critical section by acquiring use of the synchronization primitive. The synchronization operation may also be an operation that releases use of a synchronization primitive and the corresponding synchronization event is an exit event corresponding to a time when the thread exits the critical section by releasing use of the synchronization primitive.

In some embodiments a synchronization primitive is used to notify threads of changed conditions. In these embodiments the synchronization operation may be an operation that waits for a change in a state of the synchronization primitive and the corresponding synchronization event is a wait event corresponding to a time when the thread starts waiting for a change in a state of the synchronization primitive. The synchronization operation may also be an operation that stops waiting for a change in the state of the synchronization primitive and the corresponding synchronization event is a waited event corresponding to a time when the thread has finished waiting for the change in the state of the synchronization primitive. The synchronization operation may also be an operation that notifies at least one other thread that the state of the synchronization primitive has changed and the corresponding synchronization event is a notify event corresponding to a time when the thread attempts to notify at least one other thread that the state of the synchronization primitive has changed.

Synchronization primitives that are used to notify threads of change conditions e.g. java.lang.Object.wait and java.lang.Object.notify for JAVA usually provide a mechanism to limit the amount of time a thread waits before the thread continues execution. Therefore wait events include the deadline of the waiting period. To distinguish between the possible outcomes when a synchronization primitive is used for notification a waited event may include one of the following exit types 

Notify events may also include additional thread identifiers. For example the additional thread identifiers may include thread identifiers for threads that the current thread notified. Depending on the synchronization primitive the number of threads may be zero e.g. no thread was notified because no thread was waiting for a changed condition one e.g. exactly one thread was notified of a changed condition or several e.g. more than one thread was notified of a changed condition .

In some embodiments the runtime environment provides monitoring functions to monitor synchronization primitives. Whereas third party application programming interfaces APIs allow a programmer to monitor system calls corresponding to synchronization operations e.g. a wait call the monitoring functions of the runtime environment also allow a programmer to obtain information about the synchronization primitives themselves. Since these monitoring functions are provided by the runtime environment the monitoring functions may also include more information about the contention of synchronization primitives and or shared resources that are not available with third party APIs. For example the monitoring functions may include an accumulated timestamp that indicates the accumulated amount of time that the processor spent performing the runtime environment functions and or a synchronization primitive enumerator that allows the runtime system to correctly order the sequence of synchronization events.

The monitoring functions of the runtime system emit synchronization events to a synchronization trace in response to detecting synchronization operations performed by threads executing in the runtime system. In some embodiments the synchronization events emitted to the synchronization trace are used by a synchronization user interface module to display synchronization information relating to contention of synchronization primitives and or shared resources in the runtime system. Each synchronization event may include but is not limited to a synchronization event timestamp corresponding to a time at which a synchronization event was emitted to the synchronization trace an accumulated timestamp corresponding to the accumulated amount of time that the processor spent performing the runtime environment functions at the time that the synchronization event was emitted to the synchronization trace a value of a synchronization primitive enumerator for the synchronization primitive corresponding to the synchronization event at the time that the synchronization operation was performed an identifier for a thread corresponding to the synchronization event an identifier for a current thread that has acquired use of a synchronization primitive that the thread corresponding to the synchronization event requires an identifier for a next thread that will acquire use of the synchronization primitive that the thread corresponding to the synchronization event requires and a maximum amount of time that the thread may wait to acquire use of the synchronization primitive. Using the synchronization event timestamp the accumulated timestamp and the synchronization primitive enumerator the synchronization user interface module may display information including but not limited to a list of threads that a first thread blocks an amount of time that the first thread blocks each of the threads in the list of threads a number of times that the first thread blocks each of the threads in the list of threads a list of threads blocking a first thread an amount of time that each of the threads in the list of threads blocks the first thread a number of times that each of the threads in the list of threads blocks the first thread a list of threads that a synchronization primitive blocks an amount of time that the synchronization primitive blocks each thread in the list of threads a number of times that the synchronization primitive blocks each thread in the list of threads a list of methods blocking a first method an amount of time that each of the methods in the list of methods blocks the first method and a number of times that each of the methods in the list of methods blocks the first method.

At least two issues arise when attempting to display information about synchronization information relating to contention of synchronization primitives and or shared resources. First an amount of time that a first thread is blocked by a second thread may not correspond to a time interval between a time when the first thread requests use of a synchronization primitive guarding a shared resource and a time when the first thread acquires use of the synchronization primitive guarding the shared resource. This issue and a solution to this issue are illustrated in . Second an order in which synchronization events are emitted to a synchronization trace may not correspond to an order that the synchronization operations corresponding to the synchronization events actually occurred in the runtime system. This issue and a solution to this issue are illustrated in .

At time t the thread attempts to enter the critical section by performing a synchronization operation that requests use of the synchronization primitive that guards the shared resource . However since the thread is currently using the shared resource the thread waits until the synchronization primitive that guards the shared resource becomes free. The monitoring functions of the runtime environment emit to the synchronization trace an enter event corresponding to the synchronization operation that requests use of the synchronization primitive that guards the shared resource .

At time t the thread exits the critical section by performing a synchronization operation that releases use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an exit event corresponding to the synchronization operation that releases use of the synchronization primitive that guards the shared resource . After the thread releases use of the synchronization primitive that guards the shared resource e.g. at the next clock edge of a processor within a predetermined time period after the release of the synchronization primitive etc. the thread enters the critical section by performing a synchronization operation that acquires use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an entered event corresponding to the synchronization operation that acquires use of the synchronization primitive that guards the shared resource .

At time t the thread exits the critical section by performing a synchronization operation that releases use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an exit event corresponding to the synchronization operation that releases use of the synchronization primitive that guards the shared resource

As illustrated in the shared resource is not used before time t is used exclusively by thread between times tand time t is used exclusively by thread between times tand t and is free after time t.

Also as illustrated in the time interval wait between times tand t includes the time that the thread waits for the shared resource due to the fact that the thread is blocking the thread from using the shared resource . However the time interval wait also includes the time the processor is performing runtime system functions and or runtime system functions . Runtime system functions and or the runtime system functions may include functions that are not called by a user application. For example the runtime system functions and may include but are not limited to garbage collection functions functions that generate stack traces of threads functions that inspect memory functions that dump memory etc. The runtime system functions and may occur periodically or randomly during execution of the multi threaded application and affect the accuracy of the determination of the time that the thread blocks the thread . For example the runtime system functions may not be executed during the time interval wait . Similarly only a subset of the runtime system functions illustrated in may be executed during the time interval wait . Thus when the multi threaded application is analyzed over several successive runs of the multi threaded application or over several successive iterations of the execution of the critical sections and the amount of time that the processor spent executing runtime system functions and may vary from run to run or iteration to iteration . Accordingly in some embodiments when determining the amount of time that the thread blocks the thread the amount of time that the processor executes runtime system functions and during the time interval wait is subtracted from the time interval wait .

As discussed above an order in which the synchronization events are emitted to the synchronization trace may not correspond to an order in which the synchronization operations corresponding to the synchronization events actually occurred. For example the synchronization operations may be emitted to the synchronization trace when shared resources are highly contended. is a timing diagram illustrating the identification of the order that threads of a multi threaded application block other threads of the multi threaded application according to some embodiments. As illustrated in before time t the shared resource is free e.g. not used by any threads . At time t the thread attempts to enter the critical section by performing a synchronization operation that requests use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to a synchronization trace an enter event corresponding to the synchronization operation that requests use of the synchronization primitive that guards the shared resource . Since the shared resource is currently free the thread enters the critical section by performing a synchronization operation that acquires use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an entered event corresponding to the synchronization operation that acquires use of the synchronization primitive that guards the shared resource . Note that although refers to the term lock e.g. request lock acquire lock release lock any type of synchronization primitive may be used.

At time t the thread attempts to enter the critical section by performing a synchronization operation that requests use of the synchronization primitive that guards the shared resource . However since the thread is currently using the shared resource the thread waits until the synchronization primitive that guards the shared resource becomes free. The monitoring functions of the runtime environment emit to the synchronization trace an enter event corresponding to the synchronization operation that requests use of the synchronization primitive that guards the shared resource .

At time t the thread attempts to enter the critical section by performing a synchronization operation that requests use of the synchronization primitive that guards the shared resource . However since the thread is currently using the shared resource the thread waits until the synchronization primitive that guards the shared resource becomes free. The monitoring functions of the runtime environment emit to the synchronization trace an enter event corresponding to the synchronization operation that requests use of the synchronization primitive that guards the shared resource .

Based on the synchronization operations e.g. requesting a lock acquiring a lock releasing a lock etc. that have occurred by time t the thread blocks the thread and the threads and block the thread . However the ordering of the synchronization events is determined using the time when the synchronization event is emitted and not when the synchronization operation is performed. Times tand tillustrate how an incorrect ordering of the synchronization events may result in an incorrect set of blocking threads.

At time t the thread exits the critical section by performing a synchronization operation that releases use of the synchronization primitive that guards the shared resource . Also shortly after time t e.g. at the next clock edge of a processor within a predetermined time period after the release of the synchronization primitive etc. the thread enters the critical section by performing a synchronization operation that acquires use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an entered event corresponding to the synchronization operation that acquires use of the synchronization primitive that guards the shared resource . However instead of emitting an exit event at time t one or more runtime system functions delay the monitoring functions of the runtime environment from emitting the exit event until time t. This behavior occurs because it is desirable to reduce the amount of code and the corresponding execution time of the code between acquiring a synchronization primitive and releasing the synchronization primitive to reduce the amount of time that a synchronization primitive and or shared resource is blocked. Accordingly code that reports an exit event is typically executed after the release of the synchronization primitive. As illustrated in at time t the monitoring functions of the runtime environment emit to the synchronization trace the exit event corresponding to the synchronization operation that releases use of the synchronization primitive that guards the shared resource . Thus the exit event occurs after the entered event . This ordering of synchronization events produces results that are not consistent with the order in which the corresponding synchronization operations actually occurred in the runtime system.

At time t the thread exits the critical section by performing a synchronization operation that releases use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an exit event corresponding to the synchronization operation that releases use of the synchronization primitive that guards the shared resource . Shortly after time t e.g. at the next clock edge of a processor within a predetermined time period after the release of the synchronization primitive etc. the thread enters the critical section by performing a synchronization operation that acquires use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an entered event corresponding to the synchronization operation that acquires use of the synchronization primitive that guards the shared resource .

At time t the thread exits the critical section by performing a synchronization operation that releases use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an exit event corresponding to the synchronization operation that releases use of the synchronization primitive that guards the shared resource .

As illustrated in the shared resource is not used before time t is used exclusively by thread between times tand time t is used exclusively by thread between times tand t is used exclusively by the thread between times tand t and is free after time t.

To correctly report the sequence of synchronization operations performed in the runtime system some embodiments provide a synchronization primitive enumerator for a synchronization primitive that is incremented when the synchronization operation satisfies predetermined criteria. In some embodiments the synchronization operation satisfies predetermined criteria when the synchronization operation is an operation that releases the synchronization primitive. In some embodiments the synchronization primitive enumerator is only incremented when at least one other thread is awaiting use of the synchronization primitive. In other words the synchronization primitive enumerator is only incremented when at least two threads are contending for use of the synchronization primitive. In some embodiments the synchronization primitive enumerator is incremented when a number of threads awaiting use of the synchronization primitive becomes less than or equal to one. These embodiments account for the situation in which a synchronization primitive is in an inflated state when two or more threads are contending for the synchronization primitive and reverts to a deflated state when zero or one thread is using the synchronization primitive.

Exemplary values of the synchronization primitive enumerator are illustrated in . For example assuming that a value of a synchronization primitive enumerator is zero before time t the synchronization primitive enumerator is incremented by one when the thread releases the synchronization primitive because the synchronization primitive is in an inflated state starting at time t e.g. both the threads and are contending for use of the synchronization primitive . The synchronization primitive enumerator is incremented by one again when the thread releases the synchronization primitive . However unlike the previous incrementing of the synchronization primitive enumerator this incrementing of the synchronization primitive enumerator is due to the synchronization primitive transitioning from an inflated state to a deflated state. After the synchronization primitive is in the deflated state the synchronization primitive enumerator is no longer incremented when threads release the synchronization primitive . For example a value of the synchronization primitive enumerator remains the same when the thread releases the synchronization primitive . The synchronization primitive enumerator may be incremented again when the synchronization primitive is in the inflated state and a thread releases use of the synchronization primitive . Note that although the discussion above refers to incrementing the synchronization primitive enumerator when threads release the synchronization primitive the synchronization primitive enumerator may be incremented in response to other synchronization operations.

Using the synchronization primitive enumerator the correct ordering of the synchronization events is now achieved. Specifically the value of the synchronization primitive enumerator for the exit event is 0 and the value of the entered event is 1. Thus the exit event is determined to occur before the entered event .

In some embodiments the synchronization event includes a value of a synchronization primitive enumerator at the time that the synchronization operation occurred. In other words the value of the synchronization primitive enumerator is not the value at the time the synchronization event is emitted but is instead the value of the synchronization primitive enumerator at the time the synchronization event e.g. when requesting use of the synchronization primitive when acquiring use of the synchronization primitive when releasing use of the synchronization primitive etc. occurred.

Attention is now directed to which is a block diagram illustrating a synchronization event data structure according to some embodiments. The synchronization event data structure includes synchronization events . A respective synchronization event includes a thread identifier identifying a thread corresponding to a synchronization operation a synchronization primitive identifying a synchronization primitive on which the synchronization operation is performed an event type identifying the type of synchronization operation being performed a synchronization event timestamp identifying a time that the synchronization operation is reported to the runtime system e.g. a time when the synchronization event is emitted to the synchronization trace an accumulated timestamp indicating an accumulated amount of time that the processor has performed runtime system functions at the time the synchronization operating is reported to the runtime system and a synchronization primitive enumerator identifying an ordering of a sequence of synchronization operations performed on the synchronization primitive. In some embodiments the synchronization events include stack traces for respective threads associated with the respective synchronization event.

The computer system also includes an operating system that includes procedures for handling various basic system services and for performing hardware dependent tasks.

The machine is capable of executing a set of instructions sequential or otherwise that specify actions to be taken by that machine. Further while only a single machine is illustrated the term machine shall also be taken to include any collection of machines that individually or jointly execute a set or multiple sets of instructions to perform any one or more of the methodologies discussed herein.

The example of the computer system includes a processor e.g. a central processing unit CPU a graphics processing unit GPU or both and memory which communicate with each other via bus . Memory includes volatile memory devices e.g. DRAM SRAM DDR RAM or other volatile solid state memory devices non volatile memory devices e.g. magnetic disk memory devices optical disk memory devices flash memory devices tape drives or other non volatile solid state memory devices or a combination thereof. Memory may optionally include one or more storage devices remotely located from the computer system . The computer system may further include video display unit e.g. a plasma display a liquid crystal display LCD or a cathode ray tube CRT . The computer system also includes input devices e.g. keyboard mouse trackball touchscreen display etc. output devices e.g. speakers and a network interface device . The aforementioned components of the computer system may be located within a single housing or case e.g. as depicted by the dashed lines in . Alternatively a subset of the components may be located outside of the housing. For example the video display unit the input devices and the output device may exist outside of the housing but be coupled to the bus via external ports or connectors accessible on the outside of the housing.

Memory includes a machine readable medium on which is stored one or more sets of data structures and instructions e.g. software embodying or utilized by any one or more of the methodologies or functions described herein. The one or more sets of data structures may store data. Note that a machine readable medium refers to a storage medium that is readable by a machine e.g. a computer readable storage medium . The data structures and instructions may also reside completely or at least partially within memory and or within the processor during execution thereof by computer system with memory and processor also constituting machine readable tangible media.

The data structures and instructions may further be transmitted or received over a network via network interface device utilizing any one of a number of well known transfer protocols e.g. HyperText Transfer Protocol HTTP . Network can generally include any type of wired or wireless communication channel capable of coupling together computing nodes e.g. the computer system . This includes but is not limited to a local area network a wide area network or a combination of networks. In some embodiments network includes the Internet.

A synchronization primitive may be in an inflated or deflated state depending on the level of contention for the synchronization primitive. When the synchronization primitive is used at most by one thread at a time the synchronization primitive is in a deflated state in which the internal data structure for the synchronization primitive and the executed synchronization code may be lightweight. When contention for the synchronization primitive occurs and or increases the synchronization primitive is inflated so that the threads that are waiting on the synchronization primitive can be registered. When the contention is resolved e.g. only one or zero threads are using the synchronization primitive the synchronization primitive returns to a deflated state. Whereas the synchronization primitive enters the inflated state at the time when the contention for the synchronization primitive occurs there is no predetermined point in time or predetermined event at which the synchronization primitive returns to the deflated state. For performance reasons it may be desirable to only report a synchronization event involving a synchronization primitive to the synchronization trace when the synchronization primitive is under contention by two or more threads. Accordingly in some embodiments the synchronization primitive enumerator is only incremented if at all when the synchronization primitive is under contention by two or more threads. Since a synchronization primitive may change its state between deflated and inflated at any time depending on a current level of contention for the synchronization primitive the synchronization primitive enumerator may or may not be incremented properly. Thus in some embodiments the deflation and inflation process of synchronization primitives is accounted for by incrementing the synchronization primitive enumerator during a deflation operation on a synchronization primitive. Doing so causes the value of the synchronization primitive enumerator to increase even if some synchronization events are not reported due to a lack of contention.

Returning to the synchronization monitoring module reports a synchronization event that includes data relating to the synchronization operation performed on the synchronization primitive. For example the synchronization monitoring module reports the synchronization event to the synchronization trace . The data relating to the synchronization operation performed on the synchronization primitive includes but is not limited to a value of the enumerator for the synchronization primitive at a time the synchronization operation occurred an identifier for the thread an identifier for a current thread that has acquired use of the synchronization primitive an identifier for a next thread that will acquire use of the synchronization primitive a timestamp corresponding to a time at which the synchronization event occurred an accumulated timestamp corresponding to an accumulated time during which a runtime system of the computer system has been executing runtime system operations and a maximum amount of time that a thread may wait to acquire use of the synchronization primitive. In some embodiments a value of the synchronization primitive enumerator is only reported for enter events and exit events. In some embodiments an identifier of a thread currently using a synchronization primitive is only reported for enter events. In some embodiments an identifier of a thread that will acquire use of the synchronization primitive is reported for exit events.

Certain embodiments are described herein as including logic or a number of components modules or mechanisms. Modules may constitute either software modules e.g. code and or instructions embodied on a machine readable medium or in a transmission signal or hardware modules. A hardware module is a tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments one or more computer systems e.g. the computer system or one or more hardware modules of a computer system e.g. a processor or a group of processors may be configured by software e.g. an application or application portion as a hardware module that operates to perform certain operations as described herein.

In various embodiments a hardware module may be implemented mechanically or electronically. For example a hardware module may comprise dedicated circuitry or logic that is permanently configured e.g. as a special purpose processor such as a field programmable gate array FPGA or an application specific integrated circuit ASIC to perform certain operations. A hardware module may also comprise programmable logic or circuitry e.g. as encompassed within a general purpose processor or other programmable processor that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware module mechanically in dedicated and permanently configured circuitry or in temporarily configured circuitry e.g. configured by software may be driven by cost and time considerations.

Accordingly the term hardware module should be understood to encompass a tangible entity be that an entity that is physically constructed permanently configured e.g. hardwired or temporarily configured e.g. programmed to operate in a certain manner and or to perform certain operations described herein. Considering embodiments in which hardware modules are temporarily configured e.g. programmed each of the hardware modules need not be configured or instantiated at any one instance in time. For example where the hardware modules comprise a general purpose processor configured using software the general purpose processor may be configured as respective different hardware modules at different times. Software may accordingly configure a processor for example to constitute a particular hardware module at one instance of time and to constitute a different hardware module at a different instance of time.

Modules can provide information to and receive information from other modules. For example the described modules may be regarded as being communicatively coupled. Where multiples of such hardware modules exist contemporaneously communications may be achieved through signal transmission e.g. over appropriate circuits and buses that connect the modules. In embodiments in which multiple modules are configured or instantiated at different times communications between such modules may be achieved for example through the storage and retrieval of information in memory structures to which the multiple modules have access. For example one module may perform an operation and store the output of that operation in a memory device to which it is communicatively coupled. A further module may then at a later time access the memory device to retrieve and process the stored output. Modules may also initiate communications with input or output devices and can operate on a resource e.g. a collection of information .

The various operations of example methods described herein may be performed at least partially by one or more processors that are temporarily configured e.g. by software code and or instructions stored in a machine readable medium or permanently configured to perform the relevant operations. Whether temporarily or permanently configured such processors may constitute processor implemented or computer implemented modules that operate to perform one or more operations or functions. The modules referred to herein may in some example embodiments comprise processor implemented or computer implemented modules.

Moreover the methods described herein may be at least partially processor implemented or computer implemented and or processor executable or computer executable . For example at least some of the operations of a method may be performed by one or more processors or processor implemented or computer implemented modules. Similarly at least some of the operations of a method may be governed by instructions that are stored in a computer readable storage medium and executed by one or more processors or processor implemented or computer implemented modules. The performance of certain of the operations may be distributed among the one or more processors not only residing within a single machine but deployed across a number of machines. In some example embodiments the processors may be located in a single location e.g. within a home environment an office environment or as a server farm while in other embodiments the processors may be distributed across a number of locations.

While the embodiment s is are described with reference to various implementations and exploitations it will be understood that these embodiments are illustrative and that the scope of the embodiment s is not limited to them. In general techniques for reporting a synchronization event in a runtime system of a computer system may be implemented with facilities consistent with any hardware system or hardware systems defined herein. Many variations modifications additions and improvements are possible.

Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the embodiment s . In general structures and functionality presented as separate components in the exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements fall within the scope of the embodiment s .

The foregoing description for purpose of explanation has been described with reference to specific embodiments. However the illustrative discussions above are not intended to be exhaustive or to limit the embodiments to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain the principles and its practical applications to thereby enable others skilled in the art to best utilize the embodiments and various embodiments with various modifications as are suited to the particular use contemplated.

