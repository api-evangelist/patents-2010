---

title: Dependency resolution in polyphasic modules
abstract: Some embodiments provide a system that facilitates the development, maintenance, and execution of a software program. During operation, the system obtains a module declaration for a module to be used in the software program. Next, the system resolves one or more dependencies of the module using the module declaration and a list of available modules for the software program. Finally, the system uses the resolved dependencies to manage the software program throughout the life cycle of the software program.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09116707&OS=09116707&RS=09116707
owner: ORACLE INTERNATIONAL CORPORATION
number: 09116707
owner_city: Redwood Shores
owner_country: US
publication_date: 20101028
---
This application hereby claims priority under 35 U.S.C. 119 to U.S. Provisional Application No. 61 394 022 entitled Dependency Resolution in Polyphasic Modules by Mark B. Reinhold Alexander R. Buckley and Jonathan J. Gibbons filed on 18 Oct. 2010.

The subject matter of this application is related to the subject matter in a co pending non provisional application by inventors Mark B. Reinhold Alexander R. Buckley Jonathan J. Gibbons and Karen M P Kinnear entitled Polyphasic Modules for Software Development having Ser. No. 12 771 121 and filed on 30 Apr. 2010.

The subject matter of this application is related to the subject matter in a co pending non provisional application by inventors Alexander R. Buckley Mark B. Reinhold and Karen M P Kinnear entitled Access Control in Modules for Software Development having Ser. No. 12 771 654 and filed on 30 Apr. 2010.

The subject matter of this application is also related to the subject matter in a co pending non provisional application by inventors Jonathan J. Gibbons Alexander R. Buckley and Mark B. Reinhold entitled Compile Time Management of Polyphasic Modules having Ser. No. 12 823 918 and filed on 25 Jun. 2010.

The present embodiments relate to module based systems for software development. More specifically the present embodiments relate to techniques for resolving dependencies among polyphasic modules.

Within software systems increasing sophistication and functionality are typically accompanied by corresponding increases in code size and complexity. For example the addition of new features to a software program may require the implementation of new components which in turn may increase the number of dependencies within the software program. Over time changes to the software program may lead to increases in defects debugging time redundancy and lack of readability. The continued development of a software system without effective complexity management may consequently reduce performance and increase maintenance risk to the point of rendering the software system unusable and or unmanageable.

Issues associated with increasing software complexity may be mitigated by modularizing software systems. Modular software utilizes components that are self contained and that facilitate a separation of concerns. For example individual modules may be developed tested and used independently of one another in a software system. In addition a module s functionality and dependencies may be explicitly declared through an interface provided by the module. Modularized software may thus be significantly more maintainable easier to understand and less complex than monolithic software.

Hence increased use of modularity may improve the design maintenance performance scalability and growth of software systems.

Some embodiments provide a system that facilitates the development maintenance and execution of a software program. During operation the system obtains a module declaration for a module to be used in the software program. Next the system resolves one or more dependencies of the module using the module declaration and a list of available modules for the software program. Finally the system uses the resolved dependencies to manage the software program throughout the life cycle of the software program.

In some embodiments resolving the dependencies using the module declaration and the available modules involves 

In some embodiments if the additional dependencies of the first module are not resolved using the available modules the dependency is further resolved by 

In some embodiments the additional dependencies are associated with at least one of a name a version and a reverse dependency constraint.

In some embodiments the subset of the available modules is obtained using at least one of a directory hierarchy for the software program and a library.

In some embodiments enabling execution of the software program using the resolved dependencies involves 

In some embodiments creating the execution context containing the locally connected modules involves selecting a dominant class from a set of identically named classes in the execution context and exposing the dominant class to other execution contexts associated with the software program.

In some embodiments using the execution context to execute the software program involves managing the defining and importing of packages by the execution context and other execution contexts associated with the software program.

The following description is presented to enable any person skilled in the art to make and use the embodiments and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present disclosure. Thus the present invention is not limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

The data structures and code described in this detailed description are typically stored on a computer readable storage medium which may be any device or medium that can store code and or data for use by a computer system. The computer readable storage medium includes but is not limited to volatile memory non volatile memory magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs DVDs digital versatile discs or digital video discs or other media capable of storing code and or data now known or later developed.

The methods and processes described in the detailed description section can be embodied as code and or data which can be stored in a computer readable storage medium as described above. When a computer system reads and executes the code and or data stored on the computer readable storage medium the computer system performs the methods and processes embodied as data structures and code and stored within the computer readable storage medium.

Furthermore methods and processes described herein can be included in hardware modules or apparatus. These modules or apparatus may include but are not limited to an application specific integrated circuit ASIC chip a field programmable gate array FPGA a dedicated or shared processor that executes a particular software module or a piece of code at a particular time and or other programmable logic devices now known or later developed. When the hardware modules or apparatus are activated they perform the methods and processes included within them.

After testing packaging of the software program may involve creating a software package in an archive format from the software program s executable code. The software package may then undergo deployment and installation on a computer system. For example a web application may be deployed and installed on a server computer while a native application may be deployed and installed on multiple personal computers. Finally execution of the software program allows the software program s intended functionality to be provided to an end user.

Those skilled in the art will appreciate that changes such as patches upgrades maintenance and or new releases may be periodically made to the software program. Moreover such changes may be propagated through some or all of the phases of the life cycle. For example the addition of new features to the software program may require that the software program be recompiled tested packaged deployed installed and executed with the new features.

Those skilled in the art will also appreciate that changes to the software program may increase the complexity of the software program which may eventually interfere with the maintainability usability and or performance of the software program. For example modifications to the software program may be difficult to document and or track across all phases of the software program s life cycle. Over time such modifications may interfere with the continued use and development of the software program by obscuring the design of the software program increasing redundancy and introducing new unknown dependencies among components in the software program.

To mitigate issues associated with increased software complexity a module system may be used to facilitate the development and maintenance of the software program. In one or more embodiments module system uses modular information at all phases of the life cycle to manage dependencies in the software program. Such polyphasic modularization may facilitate the development of the software program by improving transparency cohesion performance scalability and maintainability in the software program.

Management of polyphasic modules is discussed in a co pending non provisional application by inventors Mark B. Reinhold Alexander R. Buckley Jonathan J. Gibbons and Karen M P Kinnear entitled Polyphasic Modules for Software Development having Ser. No. 12 771 121 and filed on 30 Apr. 2010 which is incorporated herein by reference.

As mentioned above module system may use polyphasic modules to facilitate the development of software program . In particular polyphasic modularization of software program may begin with the creation of module declarations for a set of modules to be used in software program .

In one or more embodiments modules correspond to standalone components in software program that may be independently programmed tested and modified. Each module may be defined organized and used through a corresponding module identity and module declaration. In addition an interface to a module may be based on the members of the module. For example the module may be accessed through public methods and or data in the module s members. Logical boundaries between modules may further be enforced by enabling inter module interaction only through the interfaces to the modules thus effectively hiding implementation details of modules from one another.

In other words modules may correspond to encapsulated abstractions of functionality in software program with well defined capabilities and dependencies. Modules may thus provide a large amount of flexibility in organizing the structure of software program . For example Java classes may be grouped into modules based on the functionality and or use of the classes in software program instead of language based constraints such as package membership.

In one or more embodiments module declarations for modules are obtained separately from source code for software program . For example module declarations for modules in a Java program may be stored in module definition files that are separate from source files containing Java classes interfaces enumerations and or annotation types. Such decoupling of module declarations from module implementations may further enable the creation of modules based on factors that facilitate the design and development of software program such as separation of concerns scalability and performance.

The independent creation and procurement of module declarations may additionally allow module system to begin modularizing software program before software program is compiled. For example module system may allow module declarations for modules to be created e.g. using SDK before development of source code for software program is complete. Module system may proceed with using the module declarations to manage dependencies in software program through the compilation testing packaging deployment installation and execution phases of the life cycle of software program .

More specifically module declarations for modules may be used by SDK and or runtime system to resolve dependencies in software program . First SDK and or runtime system may resolve one or more dependencies of a module to be used in software program using the module declaration for the module and a list of available modules for software program . Each dependency may be recursively resolved by obtaining a subset of the available modules matching the dependency and analyzing additional dependencies of the subset of the available modules in descending order of version. If each of the additional dependencies is resolved using the available modules the version of the module associated with the dependencies is selected for use in software program . If the additional dependencies are not resolved using the available modules the additional dependencies of a preceding version of the module are analyzed for potential resolution using the available modules.

SDK and or runtime system may then use the resolved dependencies to manage software program throughout the lifecycle of software program . In particular SDK and or runtime system may use one or more local dependencies associated with the resolved dependencies to identify sets of locally connected modules to be used in software program and create execution contexts containing the sets of locally connected modules. SDK and or runtime system may then use the execution contexts to execute software program . For example SDK and or runtime system may manage the visibility of classes and or the defining and importing of packages among the execution contexts.

In one or more embodiments module declarations for available modules are used to obtain a set of resolved dependencies in the software program. As described below resolved dependencies may be based on the dependencies local dependencies and or reverse dependency constraints of available modules . In particular dependency resolution may begin with the module declaration for a module representing an entry point to the software program. For example the module declaration may define a module to be used in the software program that contains a Java class with a method named main. 

Dependencies and or local dependencies of the module may then be obtained from the module declaration. In one or more embodiments each dependency and or local dependency must be associated with a name and may be associated with a version and or reverse dependency constraint. For example a dependency on a module named M may be included in the module declaration as requires M while a local dependency on a module named N with a version of 2.3 or higher may be included in the module declaration as requires local N 2.3 . 

To resolve a dependency local or not a subset of available modules matching the dependency may be obtained. In one or more embodiments the subset of available modules is obtained using a directory hierarchy for the software program. For example available modules may be identified and or located using the directory hierarchy for the software program one or more available modules with names and or versions that match the dependency may then be obtained by searching a list of available modules . Use of a directory hierarchy to identify and locate modules is discussed in a co pending non provisional application by inventors Jonathan J. Gibbons Alexander R. Buckley and Mark B. Reinhold entitled Compile Time Management of Polyphasic Modules having Ser. No. 12 823 918 and filed on 25 Jun. 2010 which is incorporated herein by reference.

On the other hand the subset of available modules may be obtained from a library associated with the software program. For example the library may contain compiled code that may be queried through an Application Programming Interface API for modules that match the name and or version of the dependency.

Those skilled in the art will appreciate that a module in the software program may be associated with a chain of dependencies. In particular a module that matches a dependency may include additional dependencies local dependencies and or reverse dependency constraints such that the dependency may be resolved by the module only if the additional dependencies are also resolved using one or more available modules . For example a module named A may have a dependency on a module named B which has a dependency on a module named C which has a dependency on a module named D. Thus the dependency of A on B may be resolved only if the subsequent dependencies of B on C and C on D are also resolved.

In one or more embodiments chains of dependencies in the software program are resolved in a recursive fashion. In other words matching of dependencies and modules may occur until a connected subset of available modules is selected that resolve one or more chains of dependencies associated with the software program. Moreover each subset of available modules that matches a dependency may be analyzed in descending order of version such that the highest version of a module that resolves a dependency and includes additional dependencies that are resolved using available modules is selected for use in the software program.

For example a module named X may contain the entry point to the software program and have a dependency of Y 1.0 . Two modules from available modules may match the dependency and have module identities of Y 1.5 and Y 1.1. The module identified as Y 1.5 may have a dependency of Z 2.0 3.0 which may be potentially resolved by three modules with module identities of Z 2.8 Z 2.5 and Z 2.0. On the other hand the module identified as Y 1.1 does not have any dependencies.

The dependency of X on Y 1.0 may be resolved by first analyzing additional dependencies of the module associated with the highest version that matches the dependency e.g. Y 1.5 . Because the Y 1.5 module includes an additional dependency of Z 2.0 3.0 the module associated with the highest version that matches the additional dependency e.g. Z 2.8 may also be analyzed. The Z 2.8 module may be selected for use in the software program if dependencies of the Z 2.8 module are resolved using available modules . In other words the Z 2.8 and Y 1.5 modules may resolve the dependency if a chain of dependencies from the Z 2.8 module may also be resolved using available modules or if the Z 2.8 module does not have any dependencies.

If the dependencies of the Z 2.8 module are not resolved using available modules the module associated with the next highest version that matches the additional dependency e.g. Z 2.5 may be analyzed. The Z 2.5 module may be selected for use in the software program if the dependencies of the Z 2.5 module are resolved using available modules or if the Z 2.5 module has no dependencies. If the dependencies of the Z 2.5 module are not resolved using available modules the Z 2.0 module may be selected for use in the software program if all dependencies of the Z 2.0 module are resolved using available modules .

Finally if the dependency of Y 1.5 on Z 2.0 3.0 cannot be resolved using any of the three modules named Z the module identified as Y 1.1 may be analyzed. Because Y 1.1 does not have additional dependencies Y 1.1 may be selected for use in the software program without further analysis. Consequently the Y 1.1 module may be used to resolve the dependency of X on Y 1.0 only if the chain s of dependencies associated with the Y 1.5 module cannot be resolved using available modules . Dependency resolution using available modules is discussed in further detail below with respect to .

Resolved dependencies may then be used to create a set of execution contexts e.g. execution context execution context y . In one or more embodiments the execution contexts are used to simulate the loading of classes in the software program prior to runtime. As a result each execution context may contain information that is used to execute the software program including a set of locally connected modules a set of visible classes a set of defined packages and a set of imported packages .

The information may then be used during runtime of the software program. For example locally connected modules visible classes defined packages and imported packages of execution contexts in a Java program may be used by Java class loaders to manage the loading and visibilities of classes as discussed below.

In one or more embodiments locally connected modules correspond to sets of modules from resolved dependencies that are connected by local dependencies. For example a set of locally connected modules may be formed from a module named A with a local dependency on a module named B which in turn has local dependencies on two modules named C and D. In another example a set of locally connected modules may contain a single module if the module only has non local resolved dependencies on other modules. Local dependencies are discussed in a co pending non provisional application by inventors Alexander R. Buckley Mark B. Reinhold and Karen M. P Kinnear entitled Access Control in Modules for Software Development having Ser. No. 12 771 654 and filed on 30 Apr. 2010 which is incorporated herein by reference.

Because each set of locally connected modules may require loading by a common loader e.g. Java class loader to sidestep runtime errors associated with the loading of split packages an execution context containing the locally connected modules may be created and mapped to the common loader. For example execution contexts for a Java program may map to Java class loaders to ensure that each set of locally connected modules in the Java program is loaded by the same class loader. Locally connected modules are discussed in further detail below with respect to .

Each execution context may also contain information that is used to manage the software program throughout the software program s life cycle. First the execution context may include classes in defined packages e.g. defined packages . Identically named classes may occur in the defined packages of more than one module in a set of locally connected modules causing inconsistency and or errors during class loading if the modules are included in the same execution context. For example an execution context may contain three modules each defining a public Java class named Foo.Bar. The execution of the loadClass method in a Java class loader to which the execution context maps may potentially result in the loading of any one of the three classes named Foo. 

To reduce inconsistency associated with identically named classes in the same execution context a dominant class may be selected from the identically named classes in defined packages and included in the set of visible classes e.g. visible classes . In other words the dominant class may be exposed e.g. visible within the execution context and to other execution contexts while other classes of the same name may be hidden e.g. invisible within the execution context and from the other execution contexts. Furthermore the dominant class may be selected using a variety of mechanisms. For example the dominant class may be selected from a module that is closest in a chain of dependencies to the module containing the entry point of the software program or as the class in a module that is the target of the most dependencies in the software program. Alternatively the dominant class may be manually selected e.g. by a developer if the modules containing the identically named classes cannot be ordered by number of dependencies proximity to the entry point of the software program and or other attributes.

Defined packages and imported packages may also be used to maintain class space consistency among the execution contexts. Defined packages may correspond to packages of classes that are defined within a module of the corresponding execution context. Imported packages may correspond to packages of classes that are defined in other execution contexts by modules on which modules have resolved dependencies . For example a defined package of an execution context in a Java program may correspond to a package containing classes that have as a defining loader a class loader corresponding to the execution context. On the other hand an imported package of the execution context may correspond to a package containing classes that have as an initiating loader the class loader corresponding to the execution context.

In particular defined packages and imported packages may enable adherence to a number of constraints that enforce class space consistency among the execution contexts. First to avoid ambiguity during class loading an execution context may not define a package from a module within the execution context and import a package of the same name from a module in another execution context. As a result the same package name may not appear in both the defined packages and the imported packages of the execution context.

Second to reduce inconsistency associated with identically named packages in different execution contexts identically named packages may not be defined in two execution contexts if a module in an execution context has in the transitive closure of resolved dependencies dependencies on modules in both execution contexts. For example if execution contexts are mapped to Java class loaders this constraint may prevent runtime errors that occur from the passing of a first object whose class is defined by a first execution context to a second object whose class is defined by a second execution context then from the second object to a third object whose class is defined by a third execution context that defines a class of the same name as that of the class defined in the first execution context.

Modules may correspond to a set of available modules for a software program such as software program of . In addition module may contain the entry point of the software program. As a result one or more chains of dependencies beginning at module may be resolved to execute the software program.

As discussed above the dependencies of module may be resolved by obtaining each dependency from the module declaration for module and obtaining a subset of the available modules matching the dependency. One or more modules from the subset of available modules may then be considered for use in the software program and analyzed for additional dependencies in descending order of version. Dependency resolution may continue recursively until a chain of dependencies beginning with the dependency of module is resolved using the available modules .

Beginning with the first dependency of module e.g. requires local N 1.0 the subset of modules matching the dependency may correspond to modules . Module may then be analyzed for additional dependencies because module is associated with a higher version e.g. 1.1 than module e.g. 1.0 . More specifically module includes a local dependency of P 2.0 3.0 which matches modules from available modules . However module includes a reverse dependency constraint e.g. permits O that prevents module from seeing or using module . Consequently the first dependency of module may be resolved by selecting module and module for use in the software program.

Next the second dependency of module e.g. requires O 2.0 may match modules . Module may be analyzed for additional dependencies because module is associated with a higher version e.g. 2.2 than module e.g. 2.1 . As shown in module includes a dependency of P 2.0 which matches modules . However module is selected because module is already used to resolve the dependency of module . In other words a dependency may be resolved using the highest possible version of a module unless a lower version that is already selected for use with the software program also resolves the dependency.

More specifically dependencies in the software program may be resolved by selecting no more than one version of a module of a given name whenever possible. For example two different dependencies of X 1.5 and X 1.0 2.0 may be resolved by selecting a single module named X with a version of between 1.5 and 2.0 for use in the software program even if later versions of X are available.

Dependency resolution in the software program may thus conclude with the selection of modules and for use in the software program. The resolved dependencies may additionally be stored in a structure such as a graph. For example a vertex representing a module may be added to the graph once the module is selected for use in the software program. Along the same lines a directed or undirected edge between two vertices may represent a dependency between the modules represented by the vertices. The completed graph may then be used to identify sets of locally connected modules that are grouped into execution contexts and used to execute the software program as discussed below with respect to .

As mentioned previously modules connected by local dependencies may require loading by a common loader e.g. Java class loader to sidestep runtime errors associated with the loading of split packages. Such locally connected modules may be identified from the resolved dependencies of and used to create an execution context that is mapped to the common loader. For example the locally connected modules may correspond to connected components of a graph with vertices representing the selected modules and undirected edges representing local dependencies connecting the modules.

In other words locally connected components may be identified from the resolved dependencies using techniques for identifying connected components in graphs. For example a technique may begin with module and identify a set of locally connected modules that includes modules and . The technique may then identify module as the sole element of a different set of locally connected modules. Two execution contexts may then be created and used to execute the software program one execution context may contain modules and and the other execution context may contain module .

As discussed above the execution contexts may also include mechanisms and or information for maintaining class space consistency. First a dominant class may be selected from a set of identically named classes in an execution context. For example modules and may each include a class named Foo.Bar. To prevent inconsistency with loading of the Foo.Bar class in the execution context containing modules and the dominant Foo.Bar class may be selected from the module upon which the largest number of modules have a direct or indirect dependency e.g. module or the module that is closest to the entry point of the software program e.g. module .

Similarly an execution context may not define a package from a module within the execution context and import a package of the same name from a module in another execution context. For example if a package named Foo.Bar is defined in module the package is also defined for the execution context containing modules and . Moreover the resolved dependency of module on module in another execution context may prevent package Foo.Bar from being defined in module .

Finally identically named packages may not be defined in two execution contexts if a unique execution context contains a module with transitive resolved dependencies on modules in both execution contexts. Continuing with the above example if module has a non local dependency on N 1.0 three execution contexts may exist e.g. one with module one with modules and and one with module and the execution context containing modules and may be unable to define the same package as the execution context containing module .

Initially a module declaration for a module to be used in the software program is obtained operation . For example a module declaration for a module in a Java program may be obtained from a module definition file e.g. module compilation unit manifest file etc. in the module directory corresponding to the module. The module declaration may include one or more dependencies local dependencies and or reverse dependency constraints associated with the module.

Next one or more dependencies of the module are resolved using the module declaration and a list of available modules for the software program operation . Dependency resolution using available modules and module declarations is discussed in further detail below with respect to . Finally the resolved dependencies are used to manage the software program throughout the life cycle of the software program operation . For example local dependencies from the resolved dependencies may be used to identify sets of locally connected modules in the software program. The locally connected contexts may then be grouped using execution contexts and the execution contexts may be used to execute the software program.

In addition the resolved dependencies may be used during all phases of the life cycle of the software program. For example the resolved dependencies may be used to select modules for compilation and execution. Similarly the resolved dependencies may allow modules in the same execution context to be deployed in the same library. Such polyphasic module based dependency resolution may thus increase transparency cohesion performance scalability and maintainability in the software program

First a dependency is obtained from a module declaration for the module operation . The dependency may be local or non local and indicate that the module requires the functionality of one or more other modules. Next a subset of available modules matching the dependency is obtained operation . The subset of available modules may be obtained using a directory hierarchy for the software program and or a library.

Additional dependencies of a module from the subset of available modules may also be analyzed operation . In particular the subset of available modules may be analyzed in decreasing order of version so that the highest version from the subset of available modules with resolved dependencies may be selected for use in the software program. Beginning with the most recent version of the subset of available modules if the additional dependencies are resolved using the available modules operation the module is selected for use in the software program operation .

However if one or more additional dependencies e.g. reverse dependency constraints dependencies local dependencies etc. associated with the module under analysis cannot be resolved using the available modules and preceding versions of the module are available operation the additional dependencies of the next highest version of the subset of available modules may be analyzed operation .

Operations may be repeated in a recursive manner until all dependencies in the software program are resolved. For example operations may be executed at each level of each chain of dependencies in the software program beginning with the module containing the entry point of the software program until the chain of dependencies reaches a module that has no dependencies.

Computer system may include functionality to execute various components of the present embodiments. In particular computer system may include an operating system not shown that coordinates the use of hardware and software resources on computer system as well as one or more applications that perform specialized tasks for the user. To perform tasks for the user applications may obtain the use of hardware resources on computer system from the operating system as well as interact with the user through a hardware and or software framework provided by the operating system.

In one or more embodiments computer system provides a system for facilitating the execution of a software program. The system may include an SDK and a runtime system. The SDK and runtime system may obtain a module declaration of a module to be used in the software program. The SDK and runtime system may also resolve one or more dependencies of the module using the module declaration and a list of available modules for the software program. The SDK and runtime system may then use the resolved dependencies to manage the software program throughout the life cycle of the software program.

In addition one or more components of computer system may be remotely located and connected to the other components over a network. Portions of the present embodiments e.g. SDK runtime system etc. may also be located on different nodes of a distributed system that implements the embodiments. For example the present embodiments may be implemented using a cloud computing system that provides a module system for managing the life cycles of software programs.

The foregoing descriptions of various embodiments have been presented only for purposes of illustration and description. They are not intended to be exhaustive or to limit the present invention to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present invention.

