---

title: Managing network communications between network nodes and stream transport protocol
abstract: A stream transport protocol supports realtime network communications between communicants operating on respective network nodes. The stream transport protocol supports remote management of client communication sessions, including provisioning of each pair of client network nodes with a respective session definition defining a respective peer-to-peer session over a network connection between the constituent client network nodes of the pair. The stream transport protocol has relatively low computational resource requirements so that realtime communications performance can be achieved using a wide range of computing devices and network connections that currently are available.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08732236&OS=08732236&RS=08732236
owner: Social Communications Company
number: 08732236
owner_city: Santa Clara
owner_country: US
publication_date: 20100629
---
Under 35 U.S.C. 119 e this application claims the benefit of U.S. Provisional Application No. 61 318 156 filed Mar. 26 2010 the entirety of which is incorporated herein by reference.

This application also is a continuation in part of prior U.S. patent application Ser. No. 12 630 973 filed Dec. 4 2009 which claims the benefit of U.S. Provisional Application No. 61 120 372 filed Dec. 5 2008. The entirety of prior U.S. patent application Ser. No. 12 630 973 filed Dec. 4 2009 is incorporated herein by reference.

This application also relates to the following co pending patent applications the entirety of each of which is incorporated herein by reference U.S. patent application Ser. No. 11 923 629 filed Oct. 24 2007 U.S. patent application Ser. No. 11 923 634 filed Oct. 24 2007 and U.S. patent application Ser. No. 12 509 658 filed Jul. 27 2009.

When face to face communications are not practical people often rely on one or more technological solutions to meet their communications needs. These solutions typically are designed to simulate one or more aspects of face to face communications. Traditional telephony systems enable voice communications between callers. Instant messaging also referred to as chat communications systems enable users to communicate text messages in real time through instant message computer clients that are interconnected by an instant message server. Some instant messaging systems additionally allow users to be represented in a virtual environment by user controllable graphic objects referred to as avatars . Interactive virtual reality communication systems enable users in remote locations to communicate over multiple real time channels and to interact with each other by manipulating their respective avatars in virtual spaces.

A successful communications system typically should have relatively low computational resource requirements so that realtime communications performance can be achieved using currently available computing devices and network bandwidth constraints. In addition such a system typically should be implemented in a way that achieves high connectability between a variety of difference devices across diverse network topologies and provides appropriate control over the transports of streams to the communicating devices so that a desired communications experience can be achieved.

In the following description like reference numbers are used to identify like elements. Furthermore the drawings are intended to illustrate major features of exemplary embodiments in a diagrammatic manner. The drawings are not intended to depict every feature of actual embodiments nor relative dimensions of the depicted elements and are not drawn to scale.

A communicant is a person who communicates or otherwise interacts with other persons over one or more network connections where the communication or interaction may or may not occur in the context of a virtual area. A user is a communicant who is operating a particular network node that defines a particular perspective for descriptive purposes.

A computer is any machine device or apparatus that processes data according to computer readable instructions that are stored on a computer readable medium either temporarily or permanently. A computer operating system is a software component of a computer system that manages and coordinates the performance of tasks and the sharing of computing and hardware resources. A software application also referred to as software an application computer software a computer application a program and a computer program is a set of instructions that a computer can interpret and execute to perform one or more specific tasks. A computer data file is a block of information that durably stores data for use by a software application.

A database is an organized collection of records that are presented in a standardized format that can be searched by computers. A database may be stored on a single computer readable data storage medium on a single computer or it may be distributed across multiple computer readable data storage media on one or more computers.

A data sink referred to herein simply as a sink is any of a device e.g. a computer part of a device or software that receives data.

A data source referred to herein simply as a source is any of a device e.g. a computer part of a device or software that originates data.

A network node also referred to as a node is a junction or connection point in a communications network. Exemplary network nodes include but are not limited to a terminal a computer and a network switch. A server network node is a host computer on a network that responds to requests for information or service. A client network node is a computer on a network that requests information or service from a server. The term local network node refers to a network node that currently is the primary subject of discussion. The term remote network node refers to a network node that is connected to a local network node by a network communications link.

A network address is protocol specific coded representation of a source or destination of a message and is used to uniquely identify a network node on a network.

A socket is a network communications endpoint. An application program typically can create a socket for communicating over a network by calling a network services application programming interface API of the operating system hosting the application program.

A protocol port or simply port is an application specific or process specific software construct serving as a communications endpoint within a network node. A transport protocol assigns unique numbers to ports in order to distinguish among different endpoints within a network node.

A network connection or simply connection is a data communications path between two network nodes. From the perspective of a given network node a transport stream or simply stream is a direct connection between the given network node and another network node.

A session is a logical connection between two endpoint network nodes referred to herein as session partners that provides a context for exchanging messages between the two network nodes from the time the session is established to the time that is it torn down. From the perspective of a given network node a session is transported on a transport stream where the transport stream may or may not be addressed to the session partner. For example a transport stream may be addressed to a proxy server that bridges the session to the session partner. A peer to peer P2P session is a session between two network nodes each of which can initiate the P2P session and act as a client and a server during the P2P session.

A universally unique identifier also referred to as a globally unique identifier or GUID is a number that is used to uniquely identify an object in a computer system or on a network e.g. the internet . A universally unique identifier is generated without requiring a centralized service or authority to administer. A universally unique identifier typically is an octet string of 16 octets 128 bits . Depending on the specific mechanism used to generate a universally unique identifier the universally unique identifier either is guaranteed to be different or is at least extremely likely to be different from any other universally unique identifier. A well known UUID is a UUID that is used to reliably identify persistent objects across a network.

Synchronous conferencing refers to communications in which communicants participate at the same time. Synchronous conferencing encompasses all types of networked collaboration technologies including instant messaging e.g. text chat audio conferencing video conferencing application sharing and file sharing technologies.

A realtime data stream is data that is structured and processed in a continuous flow and is designed to be received with no delay or only imperceptible delay. Realtime data streams include digital representations of voice video user movements facial expressions and other physical phenomena as well as data within the computing environment that may benefit from rapid transmission rapid execution or both rapid transmission and rapid execution including for example avatar movement instructions text chat realtime data feeds e.g. sensor data machine control instructions transaction streams and stock quote information feeds and file transfers.

A virtual area also referred to as an area or a place is a representation of a computer managed space or scene. Virtual areas typically are one dimensional two dimensional or three dimensional representations although in some embodiments a virtual area may correspond to a single point. Oftentimes a virtual area is designed to simulate a physical real world space. For example using a traditional computer monitor a virtual area may be visualized as a two dimensional graphic of a three dimensional computer generated space. However virtual areas do not require an associated visualization to implement switching rules. A virtual area typically refers to an instance of a virtual area schema where the schema defines the structure and contents of a virtual area in terms of variables and the instance defines the structure and contents of a virtual area in terms of values that have been resolved from a particular context.

A virtual area application also referred to as a virtual area specification is a description of a virtual area that is used in creating a virtual environment. The virtual area application typically includes definitions of geometry physics and realtime switching rules that are associated with one or more zones of the virtual area.

A virtual area communications application is a client communications application that integrates realtime audio communications and potentially other realtime communications e.g. video chat and realtime other data stream with visual presentations of interactions in a virtual area.

A virtual environment is a representation of a computer managed space that includes at least one virtual area and supports realtime communications between communicants.

A zone is a region of a virtual area that is associated with at least one switching rule or governance rule. A switching rule is an instruction that specifies a connection or disconnection of one or more realtime data sources and one or more realtime data sinks subject to one or more conditions precedent. A switching rule controls switching e.g. routing connecting and disconnecting of realtime data streams between network nodes communicating in the context of a virtual area. A governance rule controls a communicant s access to a resource e.g. an area a region of an area or the contents of that area or region the scope of that access and follow on consequences of that access e.g. a requirement that audit records relating to that access must be recorded . A renderable zone is a zone that is associated with a respective visualization.

A position in a virtual area refers to a location of a point or an area or a volume in the virtual area. A point typically is represented by a single set of one dimensional two dimensional or three dimensional coordinates e.g. x y z that define a spot in the virtual area. An area typically is represented by the three dimensional coordinates of three or more coplanar vertices that define a boundary of a closed two dimensional shape in the virtual area. A volume typically is represented by the three dimensional coordinates of four or more non coplanar vertices that define a closed boundary of a three dimensional shape in the virtual area.

In the context of a virtual area an object also sometimes referred to as a prop is any type of discrete element in a virtual area that may be usefully treated separately from the geometry of the virtual area. Exemplary objects include doors portals windows view screens and speakerphone. An object typically has attributes or properties that are separate and distinct from the attributes and properties of the virtual area. An avatar also referred to herein as a sprite is an object that represents a communicant in a virtual area.

As used herein the term includes means includes but not limited to the term including means including but not limited to. The term based on means based at least in part on.

The embodiments that are described herein provide a stream transport protocol that supports realtime network communications between communicants operating on respective network nodes. The stream transport protocol has relatively low computational resource requirements so that realtime communications performance can be achieved using a wide range of computing devices and network connections that currently are available.

In some embodiments the stream transport protocol supports remote management of client communication sessions and remote configuration and execution of audio and graphic rendering engines as well as switching of data streams in response to instructions also referred to as definitions that are received from a remotely hosted server application. In this way the stream transport protocol enables application developers to maintain control over the presentation of their communication environments on remote client network nodes thereby encouraging the development of a wide variety of different types of virtual areas and increasing the number of users who will want to adopt the communications system.

The stream transport protocol is efficient in connection and disconnection as well as in transport. In some embodiments the stream transport protocol provides a connection oriented encrypted connection over a transport protocol e.g. UDP TCP HTTP and PPP . The stream transport protocol additionally provides between a client application and the transport layer a reconnection mechanism that automatically attempts to reestablish failed connections without intervention by the client application thereby adding reliability on top of an inherently unreliable communication protocol.

The communications applications and the server node together provide a platform referred to herein as the platform for managing communications between communicants operating on the network nodes in accordance with a stream transport protocol that supports remote management of client communication sessions remote configuration and execution of stream processing engines and remote controlled switching of realtime data streams as specified by a server application that is hosted by the server node . The network may include any of a local area network LAN a metropolitan area network MAN and a wide area network WAN e.g. the internet . The network typically includes a number of different computing platforms and transport facilities that support the transmission of a wide variety of different media types e.g. text voice audio and video between network nodes.

Each of the network nodes has a respective set of one or more sources and an exemplary set of one or more sinks. Each source is a device or component that originates data of a particular data stream content type and each sink is a device or component that receives data of a particular data stream content type. A source and a sink of the same data stream content type are referred to herein as being complementary. Exemplary sources include an audio source e.g. an audio capture device such as a microphone a video source e.g. a video capture device such as a video camera a chat source e.g. a text capture device such as a keyboard a motion data source e.g. a pointing device such as a computer mouse and other sources e.g. file sharing source or a source of a customized real time data stream . Exemplary sinks include an audio sink e.g. an audio rendering device such as a speaker or headphones a video sink e.g. a video rendering device such as a display monitor a chat sink e.g. a text rendering device such as a display monitor a motion data sink e.g. a movement rendering device such as a display monitor and other sinks e.g. a printer for printing shared files a device for rendering real time data streams different from those already described or software that processes real time streams for analysis or customized display .

Each source has an active state in which the source is available for originating data and an inactive state in which the source is not available for originating data. Likewise each sink has an active state in which the sink is available for receiving data and an inactive state in which the sink is not available for receiving data. The states of the sources and sinks typically can be controlled by the communicants operating the client nodes via controls provided by the communications applications . For example in some embodiments the communications applications provide user controls for turning on off the local microphones and the local speakers e.g. headsets on the client network nodes .

As explained in detail below in the server sessions the server node sends to each of the client nodes provisioning messages that configure the client nodes to interconnect respective data streams between active ones of their complementary sources and sinks in accordance with switching rules specified in the server application . By enabling a server application developer to control how the connections are established between the sources and sinks on different client nodes the platform enables the application developer to control the experiences of the communicants as they communicate and otherwise interact with each other in the network communications environment . In this way the server application developers are able to optimize the communications between the communicants for particular communication purposes or for particular communication environments e.g. a virtual chat room a virtual art gallery a virtual concert hall a virtual auditorium a virtual conference room and a virtual club house .

In some embodiments the communications applications on the client nodes typically include respective graphical user interface GUI applications that provide a visual interface for visualizing and controlling communicant interactions. These GUI applications are configured to communicate with the server application through the local stream transport service API. In some embodiments the GUI application is a remote controlled terminal application that is configured to pass user inputs e.g. computer mouse inputs to the respective ones of client processes implementing the local API and to render graphical data e.g. chat data and graphical content such as screen share data received from these client processes . These client processes implementing the local API communicate with the stream transport service in order to publish messages containing definitions of user inputs on the appropriate sessions and channels and to subscribe to data received from remote network nodes on the appropriate sessions and channels. In addition one or more of the client processes are remotely configured by instructions received from the communications services on the server network node to create and tear down data processing component graphs for processing inbound data received from other client network nodes. For example some embodiments include a remotely configurable audio processing service of a realtime kernel that creates and tears down graphs of audio processing components in response to definitions received from the communications services on the server network node . Additional details regarding an exemplary realtime kernel that includes remotely configurable processing components are provided in U.S. application Ser. No. 12 630 973 filed Dec. 4 2009.

During a session data is shared between the client network node and other network nodes as definition records over transport protocol sockets. The thin client architecture receives configuration instructions from the server node through definition records that are received over the server session. The thin client architecture also receives content from other client network nodes through definition records that are received on content specific channels on respective sessions with the other client network nodes. Data is shared in accordance with a publish subscribe model. The stream transport service subscribes only to the data that are needed by the client network node . To subscribe the stream transport service negotiates a channel on a session that is established with another network node. The channel is negotiated by well known GUID for the particular server application . Definition records are transmitted only when a subscriber exists on the other end of a transport protocol socket. Definition records that are received by the stream transport service are delivered to the subscribing ones of the client processes on arrival.

As shown in the stream transport service manages a session on a transport stream . In some embodiments a transport stream in the context of a stream transport protocol session is defined by a pair of IP port addresses and a transport GUID which identifies a transport protocol e.g. UDP that is used to create the stream. A session consists of zero or more logical channels where a channel is a sequence of definition records that are appropriate for a particular client process e.g. a graphics engine an audio manager and a stream switching manager . Thus the same transport stream on a single socket can transport definition records on different channels each of which can be subscribed to by zero one or multiple of the client processes . In the illustrated embodiment the stream transport service manages two kinds of channels media channels that contain streaming media records e.g. audio packets and definition record channels that contain records of definitions . Examples of media records include audio codec and text. Examples of definition records include session maintenance definitions e.g. keepalive acknowledgement definition records client provisioning definitions e.g. definitions of processing graph elements such as audio processing elements definitions of 3D rendering assets e.g. texture and mesh and definitions of RDS e.g. avatar motion checkpoints .

The definition records and the media records are encapsulated in stream transport protocol records. The stream transport protocol records are encrypted by an encryption process sequenced with packet numbers and include a message integrity field. The sequencing of the stream transport protocol records is independent of the record source or purpose it is a link level feature used to detect out of order or missing records. The stream transport protocol records are identified by channel. GUIDs are used as channel identifiers. Definition records and media records may be compressed at the channel level using respective channel specific compressors independently of the stream transport protocol record encapsulation. Each stream transport protocol record typically contains one or more definition records or one media packet . The stream transport protocol records are delivered over the transport stream as payloads of packets that are formatted in accordance with a transport protocol e.g. UDP TCP HTTP and PPP .

In the embodiment shown in the stream transport service is a component of a four layer protocol suit that includes an application layer a transport layer a network layer and a link layer . The application layer contains user level processes that interface the communicant to the network. The transport layer includes the stream transport service and a transport protocol e.g. User Datagram Protocol UDP and interfaces the application layer with the network layer . The network layer manages movement of data through the network in accordance with one or more protocols e.g. Internet Protocol IP Internet Control Message Protocol ICMP and Internet Group Management Protocol IGMP . The link layer manages the details of physically interfacing with the network media e.g. Ethernet cable etc. and typically includes a device driver component of the operating system and the physical network hardware components e.g. Network Interface Card NIC of the client node .

In some embodiments data is shared by the network nodes in accordance with publish subscribe model which typically is connectionless. In these embodiments the client nodes subscribe to only the data they need. The server node determines what channels are needed by each of the client nodes based on the respective states i.e. active or inactive of their sources and sinks. The server application sends to each of the client nodes respective publish messages indicating what information streams are available for that client tagging each stream with a GUID handle. Each of the client processes operating on each client node may subscribe to zero or more of the channels. A client process that subscribes to a channel registers with the local stream transport service to receive notification of channel state changes and channel records as they arrive. Each of the client nodes then subscribes to the desired channels from the other client nodes using well known channel GUIDs that are specified by the server application . Any changes to server data for a particular channel will be sent as definition records to all the clients that have subscribed to that channel.

Referring back to the stream transport service maintains a register e.g. a table of local publish and subscribe entries. Each entry in the list contains 

The stream transport service also maintains a register of all arrived publish definitions for use in case a late subscribe is registered in the local list.

Where IDClient is a possibly NULL GUID of a particular client process for which the channel is intended IDServer is the remote source of channel records and IDChannel is a well known GUID of a channel.

When the stream transport service receives a session definition for a connection to another station the stream transport service establishes the stream sends the session definition and then sends all of the stored local publish entries in a definition record on the session channel. When a publish definition arrives at a stream transport service the stream transport service enters that definition into the publish definition table and then sends a subscribe definition on the session channel for each subscribe entry in the local list that had a matching Channel ID in the publish record. When a subscribe definition arrives the stream transport service begins sending definition updates piped from the publishing server application on the given definition record channel containing the definition records for that definition. The definition records may be sent on more than one channel.

When a client process desires to participate in a channel with a server the client process defines a subscribe request whether or not any transport streams exist to any servers. If the server application publishes later i.e. after stream is established then the change in the local table triggers re sending of the publish entries in the remote publish definition table which automatically triggers any latent subscribe on the other end of the transport stream. If a client process subscribes later and there is an entry in the publish table then the stream transport service sends the subscribe request automatically. This process ensures that channel data is sent over a transport stream only if it is desired by the receiver.

In some embodiments the definition records that are transmitted by the network nodes are SODA Sococo Definition Architecture records. Each SODA record contains one or more SODA definitions. Examples of SODA definitions session maintenance definitions e.g. keepalive acknowledgement definition records client provisioning definitions e.g. definitions of processing graph elements such as audio processing elements definitions of 3D rendering assets e.g. texture and mesh and definitions of RDS e.g. avatar motion checkpoints .

SODA records are nested structures with an initial GUID ID and one or more SODA definitions. A SODA definition has a definition type a definition length and zero or more fields. The definition type is a well known GUID e.g. guidAsset and guidAudioMix . The length indicates total size of the SODA definition including all fields. Fields are a combination of type specific fixed fields and nested SODA definitions. That is 

The instances of the stream transport services operating on different network nodes communicate over channels which are logical subdivisions of session traffic. In some embodiments the channels are implemented by STRAW Sococo TRAnsport for WAN channels each of which is identified by a Channel ID and is defined as a Content ID a Compression ID a set of Flags and a string of Compression Preload data. In these embodiments a channel is a logical construct that transfers SODA or media records between two network nodes in a session. A channel can be reliable or unreliable compressed or non compressed.

The content of a channel is identified by the Content ID. Content IDs are well known UUIDs they are placed in header files and published in a database so that application developers can write services to field them. The communications services on the server node are configured to send messages on the appropriate channels so that the content types of the messages match the Content IDs of the channels e.g. chat messages are sent on chat channels and RDS messages are sent on RDS channels . Services will ignore messages that are sent on the wrong channel.

Every Channel on every Session has a different Channel ID. Services e.g. client processes bind to channel data using the Content ID. All of the other fields of the Channel definition are for stream transport service to use in transmitting and prioritizing Channel data.

Channel records are transported in a sequence of STRAW records sharing the same header CHANNEL ID and with sequential packet numbers and a MAC field. The MAC calculation depends upon the packet sequence on the given channel in one direction only. All STRAW records that are transmitted on a single channel share a single set of configuration parameters e.g. Client reliable compressed . Records on a single channel are compressed as a serial stream as illustrated below.

The stream transport service encapsulates SODA definitions in stream transport protocol records that include respective channel identifiers. The stream transport service then sends the stream transport protocol records to the transport protocol for further encapsulation before transmission to the underlying networking and link layers .

Each packet sets the flags as needed. Any Channel may contain packets with flags set in any pattern. Not all combinations are valid.

The MAC field is a hash calculated on everything following the MAC field including the rest of the packet e.g. soda definitions or media . The MAC has a quick check calculation and an exhaustive check calculation. The quick check can be used by a router relay protocol sniffer or transport layer to validate that a UDP packet contains a STRAW packet. An example of a quick check is HighWord XOR LowWord CheckValue . An example of the exhaustive check is XOR packet ID packet number and extension fields as 16 bit words HighWord .

The Extension Type byte determines what immediately follows the STRAW Record. If Extension Type is zero 0 there is no protocol extension. If Extension Type is one 1 and the Extension Length is 6 the protocol extension is the MULTI structure which has a 16 bit PacketFirst field a 16 bit PacketLast field and a 16 bit PacketLength field. MULTI is used to group sequential packets that define a packet that is longer than would fit in a single UDP payload as follows 

Following the STRAW Record is the data packet . The length of the data packet is determined from the payload size of the transport protocol that is used to transport the STRAW packet over the network e.g. UDP . The length of the data packet typically is transmitted to the stream transport service out of band by a transport protocol network API that is provided by the operating system of each network node. The data packet format is specific to the Channel Content ID.

As shown in the STRAW packet is transmitted as a payload of a link layer frame which is transmitted across the network. In the illustrated embodiment the link layer frame starts with a Link Layer Header a Network Layer Header and a Transport Layer Header and ends with a Link Layer Trailer. In general the transport protocol packet may correspond to any type of link layer protocol. shows an exemplary embodiment in which the STRAW Packet is encapsulated in an Ethernet frame which starts with an Ethernet Header an IP Header and a UDP Header and ends with an Ethernet Trailer.

Sessions between the network nodes can be established over any type of serial communications protocol stream e.g. UDP TCP HTTP and PPP . In some embodiments a stream is a bi directional UDP socket between two network nodes defined by two IP address port pairs and a transport GUID. A stream supports sessions of channels. A session is a logical node to node connection. Sessions transport channels for the two nodes. Sessions may pass through one or more proxy nodes and are transported over streams that may contain multiple sessions.

The client nodes and the server node communicate with each other over respective pair wise sessions where each of the client nodes establishes a respective server session with the server node and also establishes a peer to peer P2P session with the other one of the client nodes . The sessions are divided logically into channels that are identified by the identifier contained in the first field of the STRAW Record i.e. the Channel ID field see . Exemplary types of channels include session channels station channels and content channels. Session channels are identified by the presence of a session identifier in the Channel ID field of the STRAW Record and are designated for carrying data e.g. StreamStats Pings and Keepalive messages relating to session management tasks. Station channels are identified by the presence of a station identifier in the Channel ID field of the STRAW Record and are designated for carrying data relating to network address resolution tasks. Content channels are identified by the presence of a content identifier in the Channel ID field of the STRAW Record and are designated for carrying content data e.g. audio data chat data and screen share data .

The server node maintains data for provisioning the client nodes to communicate in accordance with the server application . Among the types of data that the server node maintains are station definitions session definitions channel definitions and content definitions .

In some embodiments each of the client network nodes is assigned a respective unique station identifier. For each of the client network nodes the server network node determines a respective station definition that includes the respective station identifier and one or more entries each of which comprises a respective connectionless transport protocol address and a respective protocol port identifier for a protocol port on the client network node. In some exemplary embodiments each station definition includes a persistent Station ID that uniquely identifies a respective network node and a set of source addresses e.g. IP address Socket Port Protocol ID entries that are associated with the respective network node. In some embodiments the server network node determines the entries in the station definition for a client network node by extracting a respective network address and a respective protocol port identifier for a protocol port on the client network node from each of one or more message received from the client network node.

In some embodiments each session definition includes a Session ID that uniquely identifies a respective session a pair of Station IDs that identify the constituent network nodes designated to communicate over the respective session a Transport ID that identifies the transport protocol to be used for the respective session and an Encryption ID that identifies an encryption protocol to be used for the respective session. In some embodiments the Encryption ID is replaced by a set of Cipher definitions which are SODA definitions that have the following fields 

In some embodiments one or more of the channel definitions is associated with a respective unique content identifier that identifies a respective data stream content type assigned to the channel. In some of these embodiments each channel definition includes a unique Channel ID a well known Content ID a Compression ID a set of Flags and a string of Compression Preload data. Each content definition is a respective SODA definition that has a definition type a definition length and one or more fields. In some of these embodiments one or more of the flags correspond to transport parameter values controlling transport of data on the respective channel independently of transport of data on any of the other channels. In some embodiments one or more of the channel definitions includes a respective reliability transport parameter value that indicates whether data on the respective channel are to be transported by either a reliable transport protocol in accordance with which missed data packets are retransmitted or an unreliable transport protocol in accordance with which missed data packets are dropped. In some embodiments one or more of the channel definitions includes a respective compressed transport parameter value that indicates whether or not data on the respective channel are required to be processed intact. In some embodiments one or more of the channel definitions includes a respective ordering transport parameter value that indicates whether data on the respective channel are to be processed in order or in any order. In some embodiments one or more of the channel definitions includes a respective compression identifier that specifies a respective compression process for compressing data transported on the respective channel.

The server node also maintains global state information that includes a current register of the client nodes that are connected to the server application and interface data that identifies the data sources and sinks of the client nodes and the respective states of the sources and sinks i.e. active or inactive .

The server network node creates a universally unique Channel ID for each pair of currently active complementary sources and sinks between session partners. Therefore each of the currently available channels is identified by a respective Channel ID that is unique to the current conversation between the client network nodes and messages sent with that Channel ID can be trusted as being authentic and from the session partner. For example in response to receipt of a message from the a first session partner to turn off its local microphone the server node instructs the second session partner to tear down its microphone audio channel processing graph which removes the associated subscribe to the original audio channel and in response to a message from the first session partner to turn back on the local microphone the server node creates a new audio channel with a new unique Channel ID and instructs the second session partner to subscribe to the new audio channel and to create a new microphone audio processing graph for processing the microphone data on the new audio channel. The second session partner will ignore any packets that are received on the original audio channel after receipt of the instruction to tear down the original microphone audio channel processing graph.

The server node provisions each of the client nodes for communicating in accordance with the server application by sending definition records over the respective server session channel . In this process the server node sends publish messages indicating the channels that are available to the client nodes tagging each with a GUID handle. The instances of the stream transport service operating on the client nodes send subscribe messages for the desired data streams to the server node . Any changes to the provisioning data for the subscribed channels are sent as definition records to all client network nodes that have subscribed to those channels.

Over each of the server sessions the server network node transports control messages of different content types on different respective channels that logically divide the control messages by content type. Each of the control messages typically is sent with a unique server session identifier that is assigned to the server session and a respective content identifier that identifies the content type of the control message. In some embodiments the server network node transmits to each of the client network nodes connected to the server application the respective unique station identifiers that are assigned to the other client network nodes. In some of these embodiments the server network node also transmits a station definition of a proxy server to each of the client network nodes connected to the server application. The station definition of the proxy server typically includes the respective station identifier assigned to the proxy server and one or more entries each of which includes a respective network address and a respective protocol port identifier for a protocol port on the proxy server.

In response to receipt of the definition records from the server node the respective instances of the stream transport service operating on the client nodes update locally stored tables containing channel definitions station definitions session definitions and content definitions . These definitions are used by the instances of the stream transport service to determine whether or not to process incoming data packets and to determine how the incoming packets should be demultiplexed for consumption by the stream transport service and the other client processes .

In some embodiments a given client network node receives from the server network node a respective station definition for each of one or more of the other client network nodes connected to the server application. In the process of establishing a respective session for each of the received session definitions comprises the given client network node determines the one or more entries in the station definition of the respective session partner client network node based on the station identifier in the session definition and for each of the entries attempts to establish a respective network connection with the respective session partner client network node through the respective network address and the respective protocol port identifier. In some of these embodiments each of the session definitions includes a transport identifier associated with a connectionless transport protocol for establishing the network connection. In the process of establishing a respective session for each of the received session definitions comprises the given client network node attempts to establish the respective network connection with the respective session partner client network node in accordance with the connectionless transport protocol associated with the transport identifier in the respective session definition.

In some embodiments in the process of establishing a respective session for each of the received session definitions the given client network node creates multiple network connections with the respective session partner client network node establishes the respective session over a selected one of the created network connections and maintains one or more of the un selected ones of the created network connections alive during the established session over the selected network connection. In some embodiments one or more of the session definitions is associated with multiple respective addresses for negotiating respective network connections with the respective session partner client network node. In these embodiments for each of the at least one session definition a given client network node will attempt to establish a respective network connection with the respective session partner client network node through all of the multiple respective addresses associated with the session definition. For each of the session partner client network nodes with which the given client network node has successfully established multiple concurrent network connections with the other client network node the given client network node selects one of the multiple network connections with the session partner client network node and establishes a respective session over the selected network connection with the session partner client network node. In some embodiments for each of the session partner client network nodes with which the given client network node has successfully established multiple concurrent network connections with the other client network node the given client network node maintains one or more or more of the un selected ones of the multiple concurrent network connections with the session partner alive during the respective session established over the selected network connection.

In some embodiments a given client network node receives from the server network node a respective address of a proxy server network node. In these embodiments the given client network node attempts to establish a respective network connection with the respective session partner client network node through each of the one or more respective address associated with the session definition and through the respective address of the proxy server.

In some embodiments in the process of establishing a respective session with a respective session partner client network node a given client network node extracts a respective source network address from each of one or more inbound messages containing the respective station identifier assigned to the respective session partner client network node. The given client network node also updates a locally stored station definition indexed by the station identifier assigned to the respective session partner client network node to include each extracted source network address that is not already included in the locally stored station definition.

In some embodiments in the process of establishing a respective session with a respective session partner client network node a given client network node sends an outbound message containing the unique station identifier assigned to the given client network node to the respective session partner client network node. In response to receipt of an inbound message responsive to the outbound message and containing the unique station identifier assigned to the respective session partner client network node the given client network node extracts a respective source network address from the inbound message and binding the respective session partner client network node to the extracted source network address. In some embodiments in the process of establishing a respective session with a respective session partner client network node a given client network node sends another outbound message containing the unique session identifier assigned to the respective session to the respective session partner client network node over a transport stream addressed to the network address to which the respective session partner client network node is bound. In response to receipt of an inbound message responsive to the other outbound message and containing the unique session identifier assigned to the respective session the given client network node designates the transport stream as valid for transmitting data in the respective session. In response to failure of a given one of the created network connections the given client network node typically attempts to re create the given network connection with the respective session partner client network node.

In some embodiments in response to receipt of an identification of local publish channels that are publishable from the given client network node a given client network node publishes the local publish channels on each of the established peer to peer sessions. In response to receipt of a request to subscribe to a given one of the local publish channels on a given one of the established peer to peer sessions the given client network node sends to the respective session partner client network node data associated with the given local publish channel. The given client network node determines local subscribe channels associated with one or more local software entities on the given client network node. In response to receipt of publication of one or more remote publish channels on a given one of the established peer to peer sessions the given client network node sends to the respective session partner client network node a request to subscribe to each of the local subscribe channels matching a respective one of the remote publish channels. In response to receipt of data on the given peer to peer session in a respective one of the remote publish channels matching a respective one of the local subscribe channels the given client network node passes the received data to each of the local software entities associated with the matching local subscribe channel.

In some embodiments a given client network node transmits data streams to the respective session partner client network node on the given session in respective channels according to content type of the data streams. In this process the given client network node typically transmits each of the data streams on a respective one of the channels in packets containing a respective one of the content identifiers corresponding to the content type of the data stream. For each of the channels in the given session that is defined by a reliability transport value indicating that data are to be transported on the channel by the reliable transport protocol the given client network node transmits data packets on the channel and re transmits on the channel respective ones of the transmitted data packets in response to a determination that a count of the transmitted data packets whose receipt has not been acknowledged by the session partner client network node exceeds a window threshold specified by the session partner client network node. For each of the channels in the given session that is defined by a reliability transport value indicating that data are to be transported on the channel by the reliable transport protocol the given client network node retains data packets transmitted on the channel and releases retained data packets in response to receipt of acknowledgement that corresponding ones of the transmitted data packets have been received by the session partner client network node.

In some embodiments the given client network node receives from the respective session partner client network node a session maintenance message comprising a send window size number and a receive window size number. The given client network node transmits data packets to the respective session partner client network node up to the send window size number of transmitted data packets whose receipt has not been acknowledged by the session partner client network node. The given client network node sends to the respective session partner client network node a respective session maintenance message responsive to receipt of at least the receive window size number of data packets from the session partner client network node since a preceding session maintenance message was sent to the session partner client network node. The respective session maintenance message sent by the given client network node typically includes for each of the channels that is in an active state a respective indication of a maximum packet sequence number of the packets received on the channel. The respective session maintenance message sent by the given client network node typically includes for each of the channels that is in an active state a respective identification of missing packets not received on the channel.

In some embodiments the given client network node receives from the respective session partner client network node a session maintenance message comprising a first time parameter value and a second time parameter value. In response to a determination that the given session is in an active state the given client network node transmits packet receipt acknowledgement session maintenance messages to the session partner client network node with a maximum interval set by the first time parameter value. In response to a determination that the given session is in an idle state the given client network node transmits packet receipt acknowledgement session maintenance messages to the session partner client network node with a maximum interval set by the second time parameter value. In some embodiments the client network node determines that the given session is in an active state in response to a determination that at least one data packet has been received from the session partner client network node before two consecutive session maintenance messages are transmitted by the given client network node to the session partner client network node. In these embodiments the given client network node determines that the given session is in an idle state in response to a determination that no data packets have been received from the session partner client network node before two consecutive session maintenance messages are transmitted by the given client network node to the session partner client network node.

In the illustrated embodiments the stream transport service instance operating on a network node is provisioned with a station definition of another network node before it attempts to establish a session with the other network node. In some embodiments the provisioning process is initiated when the network node has been authenticated to the platform. After being authenticated the network node receives a station definition of the server node . The network node uses the server node station definition to establish a session over a server session channel with the server node which provisions the network node for communications with other network nodes that are connected to the server application . Exemplary types of definitions that the server node sends to the client nodes over the server session channel include station definitions session definitions publish and subscribe definitions transport report requests proxy node definitions station down messages that instruct the client to tear down a session and ping messages.

Network authentication typically is made once each time the communications applications are launched on the client nodes . In some embodiments an account service is used to authenticate the client nodes and establish a real user identifier RUID for the communicant. The account service may be provided by the server node or another server node e.g. a dedicated account server node . The authentication process is initiated by the communications applications which contact the account service authenticate and identify the communicants respectively operating the client nodes .

In accordance with the method of the account service receives from the client communications application a login message containing a source address of the client node block . The source address typically is embedded in a header of the packet containing the login message. The login message typically includes a Station ID that was assigned to the client node at the time the communications application was installed on the client node . The communication between the login service and the client communications application typically is an out of band communication via a Web Services exchange e.g. SOAP or over another session.

In response to the login message the account service authenticates the client network node block . In this process the account service creates a token and gives it to the client network node to authenticate itself to other servers e.g. the server node hosting the server application . In some embodiments the account service also provides a random 128 bit challenge phrase to the client network node . The client network node hashes the challenge phrase with a cryptographic digest of the communicant provided password and returns this as a response. The account server also hashes the challenge phrase with the previously obtained digest for that communicant and verifies that the response from the client network node matches. The network connection is now authenticated and the communicant is identified as the owner of the private key. In some embodiments as part of the login process the account service sends the client network node a set of encryption keys including the cipher purpose and encryption keys over a secure connection e.g. an SSL or encrypted in band link .

After authenticating the client network node the account service extracts the source address that is associated with the login message received from the client node and incorporates the extracted source address into a station definition of the client network node block . The account service typically can extract the source address associated with the login message by calling a network service API of an operating system hosting the account service e.g. a call to a network service provided through the Winsock API provided by a Microsoft Windows operating system .

The account service sends to the client network node station definitions of the client node the server node and the proxy node if present block . As explained above each station definition includes a persistent Station ID that uniquely identifies the associated network node and a set of one or more addresses e.g. IP address Socket Port Protocol ID entries that are associated with the respective network node.

The account service also sends to the client network node a definition of a session between the client network node and the server network node block . The session definition includes a Session ID that uniquely identifies a respective session the Station ID of the client node the Station ID of the server node a Transport ID that identifies the transport protocol to be used for the respective session and an Encryption ID that identifies an encryption protocol to be used for the respective session. In some embodiments the Encryption ID is replaced by a set of Cipher definitions.

After the client nodes have established a session with the server node block the server node provisions the client nodes for communications in accordance with the switching rules defined in the server application . In this process the server node acts as a central administrator. Each client node is provisioned explicitly to communicate with other client nodes and it will not talk to any unprovisioned network nodes that are not explicitly provisioned. If an unprovisioned network node attempts to communicate with the client node without first authenticating through the server node the client node will not be able to communicate with it and communications from the unprovisioned network node will be ignored. Until the server node creates a session definition between the client node and the unprovisioned network node and provides both nodes with the session definition and definitions of the channels that are available between the nodes there is no way for the client node to communicate with the unprovisioned network node. In this approach the client node and the unprovisioned network node do not discover each other and they do not work autonomously instead the server node defines the communications that are possible between the client network nodes. This approach precludes possibility of any virus or other attack because each client node ignores communications from network nodes that are not explicitly authenticated and provisioned.

In accordance with the method of a given client network node connects to the server application that is hosted by the server network node and to which are connected one or more other client network nodes where each of the given client network node and the one or more other client network nodes has one or more sources and sinks of respective data stream content types block . The process by which a client node establishes a session with the server node is described in the following section.

The server node determines one or more pairs of client network nodes that are connected to the server application that is being hosted by the server network node where the constituent client network nodes of each of the pairs have one or more active sets of complementary sources and sinks of respective data stream content types block . In this process the server node searches the interface data that the server node maintains for each of the client nodes for complementary active sources of sinks of each data stream content type that is permitted by the server application and determines each pair of client nodes that have at least one active set of complementary sources and sinks between them. Examples of active sets of complementary sources and sinks include an active microphone on one client node and an active speaker on another client node an active screen sharing by one client node and an active screen viewing by another client node and a respective active chat window on each of two client nodes.

For each of the determined pairs of client network nodes the server node sends to each of the constituent client network nodes of the pair a respective session definition defining a respective peer to peer session over a network connection between the constituent client network nodes of the pair block . For each of the determined pairs of client network nodes the server network node typically generates the respective session definition to include i the respective station identifiers assigned to the constituent client network nodes of the pair and ii a transport identifier associated with a connectionless transport protocol for establishing the network connection between the constituent client network nodes of the pair. For each of the determined pairs of client network nodes the server network node also typically generates the respective session definition to include an encryption identifier or a set of Cipher definitions associated with an encryption process for encrypting data transported on the network connection between the constituent client network nodes of the pair. In some embodiments each session definition includes a Session ID that uniquely identifies a respective session the Station ID of a first one of the constituent client nodes the Station ID a second one of the constituent client nodes a Transport ID that identifies the transport protocol to be used by the constituent client nodes for the respective session and an Encryption ID that identifies an encryption protocol to be used by the constituent client nodes for the respective session. In some embodiments the Encryption ID is replaced by a set of Cipher definitions. The server node also typically sends to each of the constituent client network nodes definitions of the channels that are available on the session.

The given client network node receives from the server network node a respective session definition between the given client network node and each of the other client network nodes with which the given client network node has at least one active source or sink that is complementary to an active one of the one or more sources and sinks of the other client network node block .

For each of the received session definitions the given client network node establishes a respective peer to peer session over a respective network connection between the given client network node and the respective other client network node based on the session definition block . The process by which two client network nodes establish a peer to peer session with each other is described in the following section.

Any two network nodes that wish to exchange data with each other first are provisioned with a session definition that references the station definitions of the network nodes and optionally includes a Transport ID and an Encryption ID or alternatively a set of Cipher definitions . The stream transport service on each network node uses the session definition to determine the Station ID of the other session partner network node and then looks up the locally stored station definition of the other session partner network node to find a set of one or more addresses for negotiating respective network connections with the other network node. As described above both the session definitions and the station definitions were received by the network nodes out of band beforehand.

After determining the one or more addresses that are associated with the session partners Station ID the stream transport service on each local network node transmits to each address e.g. IP Port pair a StreamStats message on the Station Channel of the local network node i.e. with the Station ID of the local network node as the Channel ID . This transmission burst to each of the session partner addresses typically is repeated with an exponentially increasing backoff delay starting at for example 50 milliseconds ms and increasing at a rate of 1.5 times after each burst until a value exceeding 3 seconds is reached at which point bursts occur every 3 seconds. In some embodiments each StreamStats message is a STRAW packet that has a Channel ID that identifies the channel e.g. station channel or session channel and a payload that consist of a SODA record that has a SODA ID field and a dropped packets count field.

Typically the session partners concurrently send respective StreamStats messages to each other until one or both of the session partners receives a StreamStats message. When any StreamStats message is received from remote network node identified by the Channel ID the local network node extracts the address e.g. the IP Port address for the remote network node from the StreamStats message. In some embodiments the stream transport service on the local network node extracts the address associated with the StreamStats message by calling a service through a networking application programming interface API of a computer operating system running on the local network node. For example in a network node running the Windows operating system the address extraction functionality is provided through a service contained within the Winsock API. After extracting the address of the remote node from the StreamStets message the local network node sends a StreamElect message back to the extracted address on the Station Channel for the local network node. Each StreamElect message is a STRAW packet has a payload consisting of a SODA record with SODA ID field and a total length field. The local network node sends the StreamElect message on its Station channel by using its Station ID as the Channel ID of the STRAW packet.

When a StreamElect message is received from any remote network node the local network node binds the remote network node to the network address that is extracted from the received StreamElect message. In this process the stream transport service on the local network node promotes the address that is extracted from the StreamElect message to the net address current by setting a bit in the locally stored definition of the remote network node. Setting the net address current bit marks that address as valid for use by the local network node to establish a session with the remote network node. At this point the network address of the remote network node has been resolved and a transport stream has been established between the local network node and the remote network node. The process of sending StreamStats messages and waiting for receipt of a StreamElect message from the remote network node ensures that the remote network node has received a message from the local network node sent to the net address current and that the local network node has received a message by the remote network node from the net address current.

Referring to in response to receipt of a definition of a session with another network node each network node applies the Station ID of the other network node in the Session definition as an index into a locally stored station definition table to determine all the addresses associated with the other network node block . Each network node sends a StreamStats Message e.g. messages and on its own Station ID Channel to each of the addresses associated with the other network node block

In response to receipt of a StreamStats message e.g. messages and from the other network node on the Station Channel of the receiving network node each network node extracts the source address associated with the StreamStats message and sends a StreamElect message e.g. messages and on its own Station ID channel to the extracted source address block . In response to receipt of the StreamElect message e.g. messages and on the Station ID Channel of the other network node each network node extracts the source address associated with the StreamElect message and binds the extracted source address to other network node block .

Once any network node is bound to particular address the stream transport service on the local network node begins sending a Ping message to the remote network node on the Session channel. Each Ping message is a STRAW packet has a payload consisting of a SODA record with SODA ID field and a timestamp field. The local network node sends the Ping message on the Session channel by setting the Channel ID of the Ping message to the Session ID. When a Ping message is received by a local network node from a remote network node on the Session channel a transport stream has been established between the local network node and the remote network node where the transport stream is defined by a pair of addresses e.g. IP port and a transport GUID. In response to receipt of the Ping message the local network node marks a bit associated with the remote network node in the locally stored Station Definitions table as Valid for use. When any remote network node is marked Valid the stream transport service on the local network node examines all the transport streams that have been established between the local and remote network node and selects the highest priority or highest ranking one of the transport streams for sending messages over the Session with the remote network node. The stream transport service on the local network node establishes the session over the selected transport stream established with the remote network node by sending a StreamElect message on the Session Channel to the net address current of the remote network node.

Referring to each network node sends a Ping message messages and on the Session ID channel to the address that is bound to the other network node block . In response to receipt of a Ping message messages and on the Session ID channel from the address bound to the other network node each network node sends a StreamElect message messages and on the Session ID channel to the address bound to the other network node block . In response to receipt of a StreamElect message messages and on the Session ID channel from the address bound to the other network node each network node marks the transport stream with the other network node as valid for use block . If there is only one valid transport stream block each network node establishes a transport stream with the other network node over the valid transport stream block . If there are multiple valid transport streams block each network node selects one of the valid transport stream and establishes a session with the other network node over the selected transport stream block .

In some embodiments for each of the session partner client network nodes with which a given client network node has successfully established multiple concurrent network connections with the other client network node the given client network node maintains one or more or more of the un selected ones of the multiple concurrent network connections with the session partner alive during the session that was established over the selected network connection. In some embodiments the stream transport service keeps these streams alive by periodically sending Pings e.g. every three seconds to the session partner. If a responsive Ping is not received the stream transport service may repeat the process of establishing a transport stream with the session partner see e.g. . If that process fails the stream transport service may repeat both the network address resolution process see e.g. followed by the transport stream establishment process see e.g. .

In some embodiments the transport service creates a single protocol socket e.g. a UDP socket that is bound to a particular socket address i.e. a particular IP address and protocol port number but is not bound to any particular destination address. In this way transport streams may be created with multiple destination addresses. In embodiments in which the socket protocol port is a UDP IP protocol port the transport server sends data over the single protocol port using the sendto API function which takes the destination address i.e. IP address Protocol Port Number of the endpoint network node.

The network layer protocol i.e. IP maintains a thread that manages a set of buffers for receiving packets at the socket protocol port. When a packet arrives in one of the buffers the thread checks the packet e.g. validates the checksum decrypts the packet if it is encrypted and if the packet is valid e.g. the flags the checksum and MAC are valid the thread attempts to match the Channel ID to all a transport service identified by Transport ID listed in the channel definition table to determine the one or more target transport service designated to handle transport of that Channel ID. If a target transport service is found the transport service notifies the stream transport service that the packet has arrived on the channel corresponding to the Channel ID of the packet. The stream transport service determines the Content ID of the packet and sends the packet payload to each of the client processes that subscribed to that Content ID. In this process the stream transport service posts the payload to a queue and on a thread waiting in the queue. If a target transport service is not found in the channel definition table the stream transport service attempts to match the Channel ID to entries in the session definition table and the station definition table. If a matching entry is found the stream transport service processes the packet e.g. for network address resolution or session maintenance processing . If a target transport service is not found in any of the channel definition table the session definition table and the station definition table the packet is dropped.

Channels are transmitted independently of other channels over the same socket. The loss of any packets in one channel does not affect the integrity of other channels. As explained below the stream transport service provides a channel by channel flow control functionality where each channel can have different priorities.

When a communicant on a given client network node inputs a command to exit a communication session the stream transport service sends an exit message to the server node. In response to receipt of the exit message the server node sends to the other client network nodes connected to the server application definition records instructing their respective instances of the stream transport service to tear down their sessions with the given client network node. In response to receipt of these definition records each of the other client network nodes tears down the session with the given client network node and all the audio and screen share processing components associated with the channels created for communication with the given client network node.

In some embodiments sessions between network nodes are established over network connections that include one or more proxy nodes also referred to as proxy relay stations that are provisioned by the server node . A proxy node does not negotiate sessions for itself. Any session negotiation is done end to end by the client nodes with the proxy node simply relaying the messages between the client nodes. Since a proxy node does not participate in session layer flow control proxy node transport implementations simply drop session messages until both participants in a session have been heard from. Since neither client node will send any traffic until Ping messages have been exchanged there is little network traffic over the link.

The server node provisions the client nodes with station definitions of various protocols and priorities such that each client node is capable of communicating P2P with each desired client node through some route. If one or more proxy nodes are available the server node sends the session definition and station definitions for the proxy nodes to the client nodes where each proxy node station definition includes a Proxy Station ID a Transport variant ID and an encryption variant ID. If there are more than one proxy available the area service chooses the best proxy for the current load and decides where each proxy station routes its traffic which may be relayed through one or more other proxy stations. In some embodiments the area service selects a respective route for each session by executing a network traffic balancing process that attempts to minimize bottlenecks in the network based on minimum traffic meshes.

A transport stream between a client node and a proxy node is established using a StreamStats message in the same way that a client node establishes a transport stream with any other node. The proxy node transport implementation negotiates client node links using its own station address. The proxy node may accept and forward messages for any client station that contacts it promiscuous relay or it may ignore StreamStats messages on station channels unknown to it provisioned relay . The provisioning of station definitions for allowed client nodes is done out of band. If the link comes up i.e. a StreamElect message is heard by the client node on a Proxy Station channel from some network address then the client node binds the proxy node to that network address.

After the proxy node is bound to an address the client node sends StreamStats messages to the proxy node at 3 second intervals in order to keep the transport stream active. When a Ping is received from a proxy node on the Session Channel that proxy node is marked Valid for use. When any proxy node is marked Valid all proxy nodes are examined for priority and the best one is selected for sending subsequent Session messages. A StreamElect message is sent to the selected proxy node on the Session Channel. This selection may change many times over the life of the Session as network connectivity changes and proxy nodes of different priority become available or unavailable.

In these embodiments the server node provisions a Proxy for a session between two client nodes using an out of band ProxySession message that includes the Proxy Station ID of the proxy node and the Session ID that is assigned to the session. Once the proxy node is provisioned the server node modifies the session definition to include the Proxy Station ID of the proxy node in its list of possible relay stations.

In some embodiments proxy nodes are provisioned by the server node from a transceiver table in the server database. The list of active proxy nodes is read at server startup and changes to the transceiver table result in notification events to the server node so that it may add or remove active proxy nodes.

A session between the server node and a proxy node is initiated by the server node . The server node first sends a TransceiverSessionStart message containing the server node Station ID and a unique Session ID to the proxy node. If the connection is lost and re established the Session ID will change triggering a clean up phase on the proxy node to remove stale session and channel bindings. When the proxy node receives the TransceiverSessionStart message it responds with a StreamStats message as described above. Receipt of the StreamStats message causes the server node to activate the proxy node and begin using it for client server and peer to peer sessions as determined by the server node s proxy selection heuristic.

Once a proxy node has become activated it is informed of previously established session channel bindings for each selected session. The proxy node is sent a StrawSession message to define the session and the two endpoint client nodes. For each published channel on the session the proxy node is sent a ChannelBind message which maps a ChannelID to a SessionID. As new sessions are established and proxy nodes are selected the selected proxy nodes are notified of the new sessions at the same time the client nodes are informed of the sessions. When new channels are published on proxied sessions ChannelBind messages are sent at the same time the channels are published. When a proxied session ends the proxy node is notified with two TransceiverSessionStop messages providing the StationID and SessionID for each client node involved in the session. If the server node needs to disconnect from a proxy node it sends a TransceiverSessionStop message with the server node StationID and the server proxy SessionID. This will cause the proxy node to remove all session mappings that were previously provided on that session.

When the SESSIONMAINTENANCE flag in a STRAW packet is set the packet is a STRAW Session protocol packet it is unreliable it is idem potent and the packetNum field is not to be interpreted. Examples of STRAW Session protocol packets include Keepalive and ACK.

A Keepalive session starts with a normal STRAW Record with Channel ID equal to the Session ID with the SESSIONMAINTENANCE flag set a zero Extension Type and Length and followed by a single SODA Definition data packet with a SODA ID guidSodaSESSION KeepAliveAck . When SESSIONMAINTENANCE is set in the Flags field the NAKED flag filed is assumed to be set i.e. no Soda Record header will be present .

Referring to the packet following the STRAW Record is a SODA definition with the normal 128 bit SODA ID and 16 bit length with value and is followed by a 32 bit unsigned ActiveTimeout field a 32 bit unsigned IdleTimeout field a 16 bit unsigned SendWindowSize field and a 16 bit unsigned ReceiveWindowSize field. The ActiveTimeout value specifies the maximum number of milliseconds to transpire between ACKs to be transmitted by the receiving station in response to sent STRAW packets not including STRAW protocol packets. The IdleTimeout value specifies the maximum number of milliseconds to transpire between KeepAlive messages to be transmitted by the receiving station when no STRAW packets other than STRAW protocol packets have been transmitted since the last receiving station transmitted ACK. The SendWindowSize value specifies the maximum number of packets to be transmitted by the receiving station before waiting for this station to transmit an ACK. The ReceiveWindowSize value specifies the minimum number of packets to be received by the receiving station before transmitting an ACK to this station. This value is generally supposed to be smaller than SendWindowSize. In that case a sequence of sent packets is ACK d before the sender triggers flow control stops sending permitting the full bandwidth of a session to be filled without wasting time on protocol.

The ACK protocol packet begins as a Keepalive packet but with the SODA length value larger than 30. Following the SodaSESSION KeepAliveAck SODA definition are a set of SDSESSION ChannelAck SODA definitions one for each active reliable channel defined for the Session.

Referring to each SodaSESSION KeepAliveAck SODA definition starts with the normal 128 bit SODA ID with value guidSodaSESSION ChannelAck followed by a SODA length field with value or greater. This is followed by a 128 bit Channel ID a 16 bit PacketNumMax field and zero or more PacketNumMissed fields. The number of PacketNumMissed fields is determined by the SODA length value in excess of 36 divided by two. E.g. if the SODA length value is 40 there are 40 36 2 2 PacketNumMissed fields present.

STRAW Session packet flow is controlled by Keepalive ACK packets. They are idem potent unreliable maintenance messages sent on the session channel and contain ACK interval times packet window sizes and channel acknowledgments. They are completely responsible for tracking all packet flow on channels on a session.

Keepalive messages are never flow controlled They are queued as priority messages head of the queue and re sent periodically in case they were dropped. They are sent in response to inbound flow more often when packets are flowing less often when no packets have occurred since the last interval.

STRAW can be transmitted over any serial channel e.g. UDP TCP HTTP or even PPP . Keepalive messages are used no matter what the channel.

There are two intervals sent in each session Keepalive message cMsActive and cMsIdle. These control the maximum interval between Keepalive messages. When receiving a packet a session becomes Active and Keepalive messages are sent at least as often as cMsActive. When no packets were received between one sent Keepalive and the next the session becomes Idle and subsequent Keepalive messages are sent at least as often as cMsIdle. If a packet is received during this Idle interval the session resumes the Active state.

Normally these intervals are not changed from message to message yet each time a Keepalive is received the intervals should be taken as new values.

A special case exists when both intervals are zero. This marks the Keepalive message as a reiterate request . A station transmits this message when its specified interval the one it sends has expired yet no Keepalive was received from the partner station. A station that receives a reiterate is expected to immediately send a Keepalive with acknowledgments for all subscribed channels. A station may attempt several reiterates and if nothing is received for several ack intervals then the session may be considered lost.

A reiterate can also be sent when flow control has shut down a channel for an extended period. This can happen when a Keepalive is dropped remember they are unreliable and the dropped Keepalive contained a channel acknowledgment not present in subsequent Keepalives.

In accordance with the method of if a session is active block the stream transport service sends Keepalive messages at least as often as the msActive parameter value specified in the last Keepalive value received from the session partner node block . When a packet is received block the session is in an active state block and the stream transport service sends Keepalive messages at least as often as the msActive parameter value specified in the last Keepalive value received from the session partner node block . If a packet is not received block the stream transport service determines if a packet has been received from the session partner node before two consecutive Keepalive messages were sent block . If two consecutive Keepalive messages were not sent since the last packet was from the session partner node block then the stream transport service continues to wait for a packet to be received block .

If two consecutive Keepalive messages were not sent since the last packet was from the session partner node block then the stream transport service sets the session in the idle state block . If the session is in the idle state block the stream transport service sends Keepalive messages at least as often as the msIde parameter value specified in the last Keepalive value received from the session partner node block . When a packet is received block the session is in an active state block and the stream transport service sends Keepalive messages at least as often as the msActive parameter value specified in the last Keepalive value received from the session partner node block .

There are two window sizes sent in each session Keepalive message sSendWindow and sRcvWindow. These are not a pair they control flow for two different streams. The send window limits unacked inbound packets. The receive window limits un ACK d outbound packets.

Given two partners P and P each sending window sizes to one another call them P.send P.rcv P.send and P.rcv. From the point of view of P there are two streams SOut and SIn.

The stream P.SOut is controlled by P.send and P.rcv. Session partner node P will send up to P.send un Ack d packets before blocking the stream. P will ACK the stream when it has received P.rcv packets since the last time it ACK d. Normally P.rcv is calculated from P.send and is smaller. It may be set at half of P.send and adjust up a little if P hasn t had to block the stream in a while down a little each time it has to block. This controls the number and frequency of P ACKs to a reasonable level and keeps the stream flowing as fast as the network will bear.

The stream P.SIn is controlled by P.send and P.rcv. Session partner node P will send up to P.send un ACK d packets before blocking the stream. P will ACK the stream when it has received P.rcv packets since the last time it ACK d. Normally P.send is set to a nominal value 10 or so and adjusted down a bunch if we are seeing skipped packet numbers dropped packets due to congestion . It can be adjusted up slowly if the stream transport service is not seeing retransmissions.

Packets sent over a Channel defined as Unreliable lacking the Reliable bit in their Channel Definition are not ever retransmitted. Their STRAW Record header is the same as packets send over a Reliable Channel and STRAW calculates all header fields identically including an incrementing PacketNumber value and calculated MAC value. But in the event an arriving packet has an incorrect MAC value or skips the next expected PacketNumber value the only result is that STRAW reports to local Services that Subscribe to that Channel that a packet was missed. It is up to the Service to respond appropriately e.g. using their own application layer signaling or synthesizing the missing data by filtering audio data to conceal the missing audio values .

Packets sent over a Channel defined as Reliable having the Reliable bit in their Channel Definition are retransmitted until acknowledged. Reliability is achieved through the STRAW Record PacketNumber field combined with received ACK Session Protocol packets.

In some embodiments the stream transport service sends packets reliably as follows. The stream transport service transmits queued packets until the count of un ACK d packets sent exceeds SendWindowSize. A sent packet is retained by the stream transport service until ACK d. A received ACK acknowledges receipt of a numbered packet when the ACK contains a SodaSESSION KeepAliveAck record with a Channel ID that matches the packet s Channel with a PacketNumMax value that meets or exceeds the packet s PacketNumber AND the packet s PacketNumber is NOT represented in any PacketNumMissed value. Once ACK d the stream transport service resources for the sent packet are freed.

The stream transport service resends un ACK d packets when it receives any SodaSESSION KeepAliveAck message that lists the PacketNumber in a PacketNumMissed field OR when it receives two 2 ACKs for the channel that have PacketNumMax value below the sent packet s PacketNumber.

If the stream transport service stalls with un ACK d packets e.g. no received channel ACK within ActiveTimeout value 2 ms it may send a special premature Keepalive with an ActiveTimeout value of zero 0 and an IdleTimeout value of zero 0 . This message is called a reiterate request . This indicates to the Partner Station that it must immediately ACK all Channels whether active or idle. This special all channel ACK is called a reiterate message .

Reiterate recovers from a missed ACK packet. Since ACK packets are idem potent the Sender and Receiver will be in sync after receipt of the Reiterate. STRAW sends Reiterate Requests at the ActiveTimeout interval until an ACK message is received or its patience is exceeded and the Session is brought down unbound .

In accordance with the method of the stream transport service transmits packets on the reliable channel block . The stream transport service retains copies of the transmitted packets block .

If an ACK was not received block the stream transport service continues to transmit packets until the number of un ACK d packet exceeds the SendWindowSize parameter value block . If the number of un ACK d packet exceeds the SendWindowSize parameter value block the stream transport service determines whether or not the time since the last ACK was received is greater than the stall period e.g. ActiveTimeout value 2 ms block . If the time since the last ACK was received is greater than the stall period block the stream transport service sends a reiterate request to the session partner node block . If a reiterate message is received from the session partner node in response to the reiterate request block the stream transport service re sends un ACK d packets block and continues to transmit packets on the reliable channel block otherwise the stream transport service tears down the session block . If the time since the last ACK was received is less than or equal to the stall period block the stream transport service re sends un ACK d packets block and continues to transmit packets on the reliable channel block .

If an ACK is received block the stream transport service releases the retained packets that were acknowledged as having been received by the session partner node block . If there are any missing packets identified in the ACK block the stream transport service re sends the identified missing packets block .

In some embodiments the stream transport service operating on the sender and receiver network nodes use the cookie field in the STRAW record see in order to optimize the resending of packets by the sender network node. In these embodiments the sender network node sends a unique session level cookie value in the cookie field of the STRAW record sent with each packet. The sender network node stores an ordered list of the cookie values in a data structure e.g. a table . The receiver network node sends with each acknowledgement packet ACK the cookie value of the last packet processed by the receiving network node in the cookie field of the STRAW record send with the ACK packet. As in the embodiments described above each ACK packet also includes a maximum packet number received value and packet numbers of missed packets in the in the PacketNumMax and the PacketNumMissed fields of the ACK SODA definition sent with the ACK packet see . Upon receipt of an ACK packet the sending network node extracts the cookie value of the last packet processed by the receiving network node. The sender network node uses this information in block of the method shown in . In particular the sender network node does not include in the count of un ACK d packets see block any packets with cookie values that were sent after the extracted cookie value. In this way the sender network node avoids re sending packets that were received by the receiver network node but have not yet been processed as a result of unavoidable latency in the processing of received packets.

The cookie value can be any type of data that uniquely identifies the packet during a session e.g. a timestamp value or a non repeating counter value . As explained above a packet number is a number in a unique repeating sequence of numbers that is assigned to the packets in a respective channel. Since ACK ing occurs at the session level for all channels the cookie provides additional information that the channel level packet numbers alone do not since the cookie is a marker within the entire packet stream while packet numbers are markers within each channel s packet stream.

If the receiver network node missed a non ACK packet and it was the last in a series it may mark the session idle and the sender network node may not see another ACK from the receiver network node for several seconds. However this scenario does not lead to a dropped packet. In particular in accordance with the method of when the sender network node currently has the session set in the active state yet does not receive an ACK for longer than the stall period see block the sender network node issues a REITERATE message block causing my receiver network node to immediately send a complete ACK. The sender network node treats the cookie value in the ACK sent in response to the REITERATE message as current and if it doesn t cover the last packets sent to the receiver network node the sender network node marks these last packets sent as missed packets and re sends them block .

In some embodiments the stream transport service receives packets reliably as follows. The stream transport service starts a Session ACK timer for last received ActiveTimeout value upon receiving a non protocol packet if the timer was not already started. When the timer expires the stream transport service sends an ACK containing SodaSESSION KeepAliveAck records for all channels that are active had a packet received since the last ACK . Then if any packets were received since the timer was started the timer is reset to the ActiveTimeout value else it is set to the IdleTimeout value. The stream transport service sends an ACK when any packet is received out of order. The stream transport service sends an ACK when the ReceiveWindowSize is reached that is when a received PacketNum is greater than the last ACK d PacketNum by ReceiveWindowSize. The stream transport service sends an ACK when the Session is bound. The stream transport service sends an ACK when a Reiterate Request is received. When any ACK is sent all active Channels or all Channels if the Session has received a reiterate request are represented with SodaSESSION KeepAliveAck records. When a duplicate message is received one with a PacketNumber that was already ACK d on that Channel the stream transport service marks the session for Reiteration on the next ACK.

In accordance with the method of in response to receipt of a non protocol packet block the stream transport service sets the session timer to the last ActiveTimeout period received from the session partner node block . The stream transport service then waits for the next packet to be received block . If a packet has not been received before the expiration of the session time block the stream transport service sends an ACK for all active channels block and sets the session time to the IdleTimeout period block . If a packet has been received before the expiration of the session time block the stream transport service sends an ACK if the received packet is out of order blocks if the received packet causes the ReceiveWindowSize to be reached blocks if the received packet binds the session blocks or if the received packet is a reiterate request message blocks .

In some embodiments the stream transport protocol includes the following extensions SINGLETON and MULTI. Almost all packets are sent SINGLETON with an Extension Type of zero and an Extension Length of zero. These packets are processed immediately upon receipt. Packets sent MULTI are intended for transmitting oversize records that is records larger than the UDP payload permits. The data payload of such packets is simply appended in PacketNumber order and processed as a single data packet once all STRAW packets in the sequence are received. If MULTI is used on an unreliable Channel then missing one packet in the MULTI sequence results in all of the packets in the sequence being discarded and reported to Subscribed Services as missed .

The stream transport protocol supports a variety of different application environments of the platform provided by the communications applications and the server node .

Some exemplary embodiments apply one or more of the spatial metaphor visualizations on top of realtime chat interactions. These visualizations provide a context for depicting the current communication states of the communicants involved in realtime chat interactions. The spatial metaphor also provides a context for organizing the presentation of various interface elements that are used by communicants to participate in realtime chat interactions. The spatial metaphor visualizations may be applied to any type of instant messaging platform that provides realtime text based communication between two or more communicants over the internet or some form of internal network intranet optionally with one or more other realtime communication channels such as audio video file share and application sharing channels. For example embodiments may be integrated with any of the currently available instant messaging platforms including for example AOL Instant Messenger MSN Messenger Yahoo Messenger Google Talk and Skype.

The network infrastructure service environment manages sessions of the first and second client nodes in a virtual area in accordance with a virtual area application . The virtual area application is hosted by the virtual area and includes a description of the virtual area . The communications applications operating on the first and second client network nodes present respective views of the virtual area in accordance with data received from the network infrastructure service environment and provide respective interfaces for receiving commands from the communicants and providing a spatial interface that enhances the realtime communications between the communicants as described above. The communicants typically are represented in the virtual area by respective avatars which typically move about the virtual area in response to commands that are input by the communicants at their respective network nodes. Each communicant s view of the virtual area typically is presented from the perspective of the communicant s avatar which increases the level of immersion experienced by the communicant. Each communicant typically is able to view any part of the virtual area around his or her avatar. In some embodiments the communications applications establish realtime data stream connections between the first and second client network nodes and other network nodes sharing the virtual area based on the positions of the communicants avatars in the virtual area .

The network infrastructure service environment also maintains a relationship database that contains the records of interactions between communicants. Each interaction record describes the context of an interaction between a pair of communicants.

The network infrastructure service environment typically includes one or more network infrastructure services that cooperate with the communications applications in the process of establishing and administering network connections between the client nodes and other network nodes see . The network infrastructure services may run on a single network node or may be distributed across multiple network nodes. The network infrastructure services typically run on one or more dedicated network nodes e.g. a server computer or a network device that performs one or more edge services such as routing and switching . In some embodiments however one or more of the network infrastructure services run on at least one of the communicants network nodes. Among the network infrastructure services that are included in the exemplary embodiment of the network infrastructure service environment are an account service a security service an area service a rendezvous service and an interaction service.

The account service manages communicant accounts for the virtual environment. The account service also manages the creation and issuance of authentication tokens that can be used by client network nodes to authenticate themselves to any of the network infrastructure services.

The security service controls communicants access to the assets and other resources of the virtual environment. The access control method implemented by the security service typically is based on one or more of capabilities where access is granted to entities having proper capabilities or permissions and an access control list where access is granted to entities having identities that are on the list . After a particular communicant has been granted access to a resource that communicant typically uses the functionality provided by the other network infrastructure services to interact in the network communications environment .

The area service administers virtual areas. In some embodiments the area service remotely configures the communications applications operating on the first and second client network nodes in accordance with the virtual area application subject to a set of constraints see . The constraints typically include controls on access to the virtual area. The access controls typically are based on one or more of capabilities where access is granted to communicants or client nodes having proper capabilities or permissions and an access control list where access is granted to communicants or client nodes having identities that are on the list .

The area service also manages network connections that are associated with the virtual area subject to the capabilities of the requesting entities maintains global state information for the virtual area and serves as a data server for the client network nodes participating in a shared communication session in a context defined by the virtual area . The global state information includes a list of all the objects that are in the virtual area and their respective locations in the virtual area. The area service sends instructions that configure the client network nodes. The area service also registers and transmits initialization information to other client network nodes that request to join the communication session. In this process the area service may transmit to each joining client network node a list of components e.g. plugins that are needed to render the virtual area on the client network node in accordance with the virtual area application . The area service also ensures that the client network nodes can synchronize to a global state if a communications fault occurs. The area service typically manages communicant interactions with virtual areas via governance rules that are associated with the virtual areas.

The rendezvous service manages the collection storage and distribution of presence information and provides mechanisms for network nodes to communicate with one another e.g. by managing the distribution of connection handles subject to the capabilities of the requesting entities. The rendezvous service typically stores the presence information in a presence database. The rendezvous service typically manages communicant interactions with each other via communicant privacy preferences.

The interaction service maintains the relationship database that contains the records of interactions between communicants. For every interaction between communicants one or more services of the network infrastructure service environment e.g. the area service transmit interaction data to the interaction service. In response the interaction service generates one or more respective interaction records and stores them in the relationship database. Each interaction record describes the context of an interaction between a pair of communicants. For example in some embodiments an interaction record contains an identifier for each of the communicants an identifier for the place of interaction e.g. a virtual area instance a description of the hierarchy of the interaction place e.g. a description of how the interaction room relates to a larger area start and end times of the interaction and a list of all files and other data streams that are shared or recorded during the interaction. Thus for each realtime interaction the interaction service tracks when it occurred where it occurred and what happened during the interaction in terms of communicants involved e.g. entering and exiting objects that are activated deactivated and the files that were shared.

The interaction service also supports queries on the relationship database subject to the capabilities of the requesting entities. The interaction service presents the results of queries on the interaction database records in a sorted order e.g. most frequent or most recent based on virtual area. The query results can be used to drive a frequency sort of contacts whom a communicant has met in which virtual areas as well as sorts of who the communicant has met with regardless of virtual area and sorts of the virtual areas the communicant frequents most often. The query results also may be used by application developers as part of a heuristic system that automates certain tasks based on relationships. An example of a heuristic of this type is a heuristic that permits communicants who have visited a particular virtual area more than five times to enter without knocking by default or a heuristic that allows communicants who were present in an area at a particular time to modify and delete files created by another communicant who was present in the same area at the same time. Queries on the relationship database can be combined with other searches. For example queries on the relationship database may be combined with queries on contact history data generated for interactions with contacts using a communication system e.g. Skype Facebook and Flickr that is outside the domain of the network infrastructure service environment .

The communications application and the network infrastructure service environment typically administer the realtime connections with network nodes in a communication context that is defined by an instance of a virtual area. The virtual area instance may correspond to an abstract non geometric virtual space that is defined with respect to abstract coordinates. Alternatively the virtual area instance may correspond to a visual virtual space that is defined with respect to one two or three dimensional geometric coordinates that are associated with a particular visualization. Abstract virtual areas may or may not be associated with respective visualizations whereas visual virtual areas are associated with respective visualizations.

As explained above communicants typically are represented by respective avatars e.g. sprites in a virtual area that has an associated visualization. The avatars move about the virtual area in response to commands that are input by the communicants at their respective network nodes. In some embodiments the communicant s view of a virtual area instance typically is presented from the perspective of the communicant s avatar and each communicant typically is able to view any part of the visual virtual area around his or her avatar increasing the level of immersion that is experienced by the communicant.

A virtual area typically includes one or more zones that are associated with respective rules that govern the switching of realtime data streams between the network nodes that are represented by the avatars in the virtual area. The switching rules dictate how local connection processes executing on each of the network nodes establishes communications with the other network nodes based on the locations of the communicants avatars in the zones of the virtual area. A virtual area typically is defined by a specification that includes a description of geometric elements of the virtual area and one or more rules including switching rules and governance rules. The switching rules govern realtime stream connections between the network nodes. The governance rules control a communicant s access to resources such as the virtual area itself regions with the virtual area and objects within the virtual area. In some embodiments the geometric elements of the virtual area are described in accordance with the COLLADA Digital Asset Schema Release 1.4.1 Apr. 2006 specification available from http www.khronos.org collada and the switching rules are described using an extensible markup language XML text format referred to herein as a virtual space description format VSDL in accordance with the COLLADA Streams Reference specification described in U.S. application Ser. Nos. 11 923 629 and 11 923 634.

The geometric elements of the virtual area typically include physical geometry and collision geometry of the virtual area. The physical geometry describes the shape of the virtual area. The physical geometry typically is formed from surfaces of triangles quadrilaterals or polygons. Colors and textures are mapped onto the physical geometry to create a more realistic appearance for the virtual area. Lighting effects may be provided for example by painting lights onto the visual geometry and modifying the texture color or intensity near the lights. The collision geometry describes invisible surfaces that determine the ways in which objects can move in the virtual area. The collision geometry may coincide with the visual geometry correspond to a simpler approximation of the visual geometry or relate to application specific requirements of a virtual area designer.

The switching rules typically include a description of conditions for connecting sources and sinks of realtime data streams in terms of positions in the virtual area. Each rule typically includes attributes that define the realtime data stream type to which the rule applies and the location or locations in the virtual area where the rule applies. In some embodiments each of the rules optionally may include one or more attributes that specify a required role of the source a required role of the sink a priority level of the stream and a requested stream handling topology. In some embodiments if there are no explicit switching rules defined for a particular part of the virtual area one or more implicit or default switching rules may apply to that part of the virtual area. One exemplary default switching rule is a rule that connects every source to every compatible sink within an area subject to policy rules. Policy rules may apply globally to all connections between the client nodes or only to respective connections with individual client nodes. An example of a policy rule is a proximity policy rule that only allows connections of sources with compatible sinks that are associated with respective objects that are within a prescribed distance or radius of each other in the virtual area.

In some embodiments governance rules are associated with a virtual area to control who has access to the virtual area who has access to its contents what is the scope of that access to the contents of the virtual area e.g. what can a user do with the contents and what are the follow on consequences of accessing those contents e.g. record keeping such as audit logs and payment requirements . In some embodiments an entire virtual area or a zone of the virtual area is associated with a governance mesh. In some embodiments a governance mesh is implemented in a way that is analogous to the implementation of the zone mesh described in U.S. application Ser. Nos. 11 923 629 and 11 923 634. A governance mesh enables a software application developer to associate governance rules with a virtual area or a zone of a virtual area. This avoids the need for the creation of individual permissions for every file in a virtual area and avoids the need to deal with the complexity that potentially could arise when there is a need to treat the same document differently depending on the context.

In some embodiments a virtual area is associated with a governance mesh that associates one or more zones of the virtual area with a digital rights management DRM function. The DRM function controls access to one or more of the virtual area or one or more zones within the virtual area or objects within the virtual area. The DRM function is triggered every time a communicant crosses a governance mesh boundary within the virtual area. The DRM function determines whether the triggering action is permitted and if so what is the scope of the permitted action whether payment is needed and whether audit records need to be generated. In an exemplary implementation of a virtual area the associated governance mesh is configured such that if a communicant is able to enter the virtual area he or she is able to perform actions on all the documents that are associated with the virtual area including manipulating the documents viewing the documents downloading the documents deleting the documents modifying the documents and re uploading the documents. In this way the virtual area can become a repository for information that was shared and discussed in the context defined by the virtual area.

Additional details regarding the specification of a virtual area are described in U.S. application No. 61 042 714 which was filed on Apr. 4 2008 Ser. No. 11 923 629 which was filed on Oct. 24 2007 and Ser. No. 11 923 634 which was filed on Oct. 24 2007 .

The local HIDs enable a communicant to input commands and other signals into the client network node while participating in a virtual area communications session. Exemplary HIDs include a computer keyboard a computer mouse a touch screen display and a microphone.

The audio playback devices enable a communicant to playback audio signals that are received during a virtual area communications session. Exemplary audio playback devices include audio processing hardware e.g. a sound card for manipulating e.g. mixing and applying special effects audio signals and speakers for outputting sounds.

The So3D engine is a three dimensional visualization engine that controls the presentation of a respective view of a virtual area and objects in the virtual area on a display monitor. The So3D engine typically interfaces with a graphical user interface driver and the HID devices to present the views of the virtual area and to allow the communicant to control the operation of the communications application .

In some embodiments the So3D engine receives graphics rendering instructions from the area service. The So3D engine also may read a local communicant avatar database that contains images needed for rendering the communicant s avatar in the virtual area. Based on this information the So3D engine generates a visual representation i.e. an image of the virtual area and the objects in the virtual area from the point of view position and orientation of the communicant s avatar in the virtual area. The visual representation typically is passed to the graphics rendering components of the operating system which drive the graphics rendering hardware to render the visual representation of the virtual area on the client network node.

The communicant can control the presented view of the virtual area by inputting view control commands via a HID device e.g. a computer mouse . The So3D engine updates the view of the virtual area in accordance with the view control commands. The So3D engine also updates the graphic representation of the virtual area on the display monitor in accordance with updated object position information received from the area service.

The system database and storage facility stores various kinds of information that is used by the platform. Exemplary information that typically is stored by the storage facility includes the presence database the relationship database an avatar database a real user id RUID database an art cache database and an area application database. This information may be stored on a single network node or it may be distributed across multiple network nodes.

A communicant typically connects to the network from a client network node. The client network node typically is implemented by a general purpose computer system or a dedicated communications computer system or console such as a network enabled video game console . The client network node executes communications processes that establish realtime data stream connections with other network nodes and typically executes visualization rendering processes that present a view of each virtual area entered by the communicant 

A communicant may interact e.g. input commands or data with the computer system using one or more input devices e.g. one or more keyboards computer mice microphones cameras joysticks physical motion sensors such Wii input devices and touch pads . Information may be presented through a graphical user interface GUI that is presented to the communicant on a display monitor which is controlled by a display controller . The computer system also may include other input output hardware e.g. peripheral output devices such as speakers and a printer . The computer system connects to other network nodes through a network adapter also referred to as a network interface card or NIC .

A number of program modules may be stored in the system memory including application programming interfaces APIs an operating system OS e.g. the Windows XP operating system available from Microsoft Corporation of Redmond Wash. U.S.A. the communications application drivers e.g. a GUI driver network transport protocols and data e.g. input data output data program data a registry and configuration settings .

In some embodiments the one or more server network nodes of the virtual environment creator are implemented by respective general purpose computer systems of the same type as the client network node except that each server network node typically includes one or more server software applications.

In other embodiments the one or more server network nodes of the virtual environment creator are implemented by respective network devices that perform edge services e.g. routing and switching .

The embodiments that are described herein provide a stream transport protocol that supports realtime network communications between communicants operating on respective network nodes. The stream transport protocol has relatively low computational resource requirements so that realtime communications performance can be achieved using a wide range of computing devices and network connections that currently are available.

