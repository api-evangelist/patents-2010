---

title: Method and system for recording streams
abstract: A method of delivering a live stream is implemented within a content delivery network (CDN) and includes the high level functions of recording the stream using a recording tier, and playing the stream using a player tier. The step of recording the stream includes a set of sub-steps that begins when the stream is received at a CDN entry point in a source format. The stream is then converted into an intermediate format (IF), which is an internal format for delivering the stream within the CDN and comprises a stream manifest, a set of one or more fragment indexes (FI), and a set of IF fragments. The player process begins when a requesting client is associated with a CDN HTTP proxy. In response to receipt at the HTTP proxy of a request for the stream or a portion thereof, the HTTP proxy retrieves (either from the archive or the data store) the stream manifest and at least one fragment index. Using the fragment index, the IF fragments are retrieved to the HTTP proxy, converted to a target format, and then served in response to the client request. The source format may be the same or different from the target format. Preferably, all fragments are accessed, cached and served by the HTTP proxy via HTTP.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09038116&OS=09038116&RS=09038116
owner: Akamai Technologies, Inc.
number: 09038116
owner_city: Cambridge
owner_country: US
publication_date: 20101224
---
This application relates generally to delivery online of high definition HD video at broadcast audience scale to popular runtime environments and mobile devices.

Distributed computer systems are well known in the prior art. One such distributed computer system is a content delivery network or CDN that is operated and managed by a service provider. The service provider typically provides the content delivery service on behalf of third parties. A distributed system of this type typically refers to a collection of autonomous computers linked by a network or networks together with the software systems protocols and techniques designed to facilitate various services such as content delivery or the support of outsourced site infrastructure. Typically content delivery means the storage caching or transmission of content streaming media and applications on behalf of content providers including ancillary technologies used therewith including without limitation DNS query handling provisioning data monitoring and reporting content targeting personalization and business intelligence.

While content delivery networks provide significant advantages typically they include dedicated platforms to support delivery of content for multiple third party runtime environments that are in turn based on their own proprietary technologies media servers and protocols. These distinct platforms are costly to implement and to maintain especially globally and at scale as the number of end users increases. Moreover at the same time content providers such as large scale broadcasters film distributors and the like desire their content to be delivered online in a manner that complements traditional mediums such as broadcast TV including high definition or HD television and DVD. This content may also be provided at different bit rates. End users also desire to interact with the content as they can do now with traditional DVR based content delivered over satellite or cable. A further complication is that Internet based content delivery is no longer limited to fixed line environments such as the desktop as more and more end users now use mobile devices such as the Apple iPhone to receive and view content over mobile environments.

Thus there is a need to provide an integrated content delivery network platform with the ability to deliver online content such as HD quality video at broadcast audience scale to the most popular runtime environments such as Adobe Flash Microsoft Silveright etc. as well as to mobile devices such as the iPhone to match what viewers expect from traditional broadcast TV. The techniques disclosed herein address this need.

An integrated HTTP based delivery platform that provides for the delivery online of HD video and audio quality content to popular runtime environments operating on multiple types of client devices in both fixed line and mobile environments.

In one embodiment a method of delivering a live stream is implemented within a content delivery network CDN and includes the high level functions of recording the stream using a recording tier and playing the stream using a player tier. The step of recording the stream includes a set of sub steps that begins when the stream is received at a CDN entry point in a source format. The stream is then converted into an intermediate format IF which is an internal format for delivering the stream within the CDN and comprises a stream manifest a set of one or more fragment indexes FI and a set of IF fragments. The fragments representing a current portion of the stream are archived in the intermediate format in an archiver while older less current portions are sent to data store. The player process begins when a requesting client is associated with a CDN HTTP proxy. In response to receipt at the HTTP proxy of a request for the stream or a portion thereof the HTTP proxy retrieves either from the archive or the data store the stream manifest and at least one fragment index. Using the fragment index the IF fragments are retrieved to the HTTP proxy converted to a target format and then served in response to the client request. The source format may be the same or different from the target format. Preferably all fragments are accessed cached and served by the HTTP proxy via HTTP.

In another embodiment a method of delivering a stream on demand VOD uses a translation tier to manage the creation and or handling of the IF components i.e. the stream manifest the fragment indexes FI and the IF fragments. The translation tier is used in lieu of the recording tier in the live delivery network . In one VOD embodiment the translation tier is implemented using an HTTP proxy and a translation process. The approach enables VOD streaming from customer and CDN based storage origins provides single and multiple bitrate SBR and MBR streaming provides support for origin content stored in multiple different types of file format containers supported mp4 flv codes include among others AAC MP3 PCM for audio and H.264 for video and minimizes download of content beyond what is directly requested by the end user.

According to another aspect of this disclosure Intermediate Format IF generation and handling may occur entirely within an HTTP proxy. In this approach IF can be extended throughout the entire downstream HTTP delivery chain including optionally to the client itself if the client also has an HTTP proxy interface .

The foregoing has outlined some of the more pertinent features of the invention. These features should be construed to be merely illustrative. Many other beneficial results can be attained by applying the disclosed invention in a different manner or by modifying the invention as will be described.

In this representative embodiment a distributed computer system is configured as a content delivery network CDN and is assumed to have a set of machines distributed around the Internet. Typically most of the machines are servers located near the edge of the Internet i.e. at or adjacent end user access networks. A network operations command center NOCC may be used to administer and manage operations of the various machines in the system. Third party sites such as web site offload delivery of content e.g. HTML embedded page objects streaming media software downloads and the like to the distributed computer system and in particular to edge servers. Typically content providers offload their content delivery by aliasing e.g. by a DNS CNAME given content provider domains or sub domains to domains that are managed by the service provider s authoritative domain name service. End users that desire such content may be directed to the distributed computer system to obtain that content more reliably and efficiently. Although not shown in detail the distributed computer system may also include other infrastructure such as a distributed data collection system that collects usage and other data from the edge servers aggregates that data across a region or set of regions and passes that data to other back end systems and to facilitate monitoring logging alerts billing management and other operational and administrative functions. Distributed network agents monitor the network as well as the server loads and provide network traffic and load data to a DNS query handling mechanism which is authoritative for content domains being managed by the CDN. A distributed data transport mechanism may be used to distribute control information e.g. metadata to manage content to facilitate load balancing and the like to the edge servers.

As illustrated in a given machine in the CDN sometimes referring to herein as an edge machine comprises commodity hardware e.g. an Intel Pentium processor running an operating system kernel such as Linux or variant that supports one or more applications . To facilitate content delivery services for example given machines typically run a set of applications such as an HTTP proxy also referred to herein as an edge server process a name server a local monitoring process a distributed data collection process and the like. The HTTP proxy typically comprises a cache and a manager process for managing the cache and delivery of content from the edge machine. For streaming media the machine typically includes one or more media servers such as a Windows Media Server WMS or Flash 2.0 server as required by the supported media formats. When configured as a CDN edge machine or edge server the machine shown in may be configured to provide one or more extended content delivery features preferably on a domain specific customer specific basis preferably using configuration files that are distributed to the edge servers using a configuration system. A given configuration file preferably is XML based and includes a set of content handling rules and directives that facilitate one or more advanced content handling features. The configuration file may be delivered to the CDN edge server via the data transport mechanism. U.S. Pat. No. 7 111 057 illustrates a useful infrastructure for delivering and managing edge server content control information and this and other edge server control information sometimes referred to as metadata can be provisioned by the CDN service provider itself or via an extranet or the like the content provider customer who operates the origin server.

The CDN may include a storage subsystem such as described in U.S. Pat. No. 7 472 178 the disclosure of which is incorporated herein by reference.

The CDN may operate a server cache hierarchy to provide intermediate caching of customer content one such cache hierarchy subsystem is described in U.S. Pat. No. 7 376 716 the disclosure of which is incorporated herein by reference.

For live streaming delivery the CDN may include a live delivery subsystem such as described in U.S. Pat. No. 7 296 082 the disclosure of which is incorporated herein by reference.

As will be described this disclosure describes how the above identified technologies can be extended to provide an integrated HTTP based delivery platform that provides for the delivery online of HD video quality content to the most popular runtime environments and to the latest device both fixed line and mobile environments. The platform supports delivery of both live and on demand content.

As used herein the following terms shall have the following representative meanings. For convenience of illustration only the description that follows with respect to live streaming delivery is in the context of the Adobe Flash runtime environment but this is not a limitation as a similar type of solution may also be implemented for other runtime environments both fixed line and mobile including without limitation Microsoft Silverlight Apple iPhone and others .

An Encoder is a customer owned or managed machine which takes some raw live video feed in some format streaming satellite etc. and delivers the data to an Entry Point encoded for streaming delivery. An Entry Point EP typically is a process running on a CDN streaming machine which receives video data from the customer s Encoder and makes this data available to consumers of the live stream. For Adobe Flash this is a Flash Media Server FMS configured to accept connections from Encoders. A Flash Media Server is a server process for Flash media available from Adobe Corporation. In this embodiment an Intermediate Region IR typically is a Flash Media Server which the CDN has configured to act analogously to a streaming set reflector such as described in U.S. Pat. No. 7 296 082 and U.S. Pat. No. 6 751 673. These machines relay streams from FMS EPs to FMS Edge regions providing fan out and path diversity. A Region typically implies a set of machines and their associated server processes that are co located and are interconnected to one another for load sharing typically over a back end local area network. A Flash Edge machine is a Flash Media Server which has been configured to accept client requests. This is the software running on the Flash EP IR and Edge machines in a representative embodiment. Intermediate Format IF is an internal to the CDN format for sending streaming data from EP to an edge server HTTP proxy. As will be described in more detail below IF preferably comprises several different pieces including Stream Manifest Fragment Indexes and IF Fragments. Live DVR and VOD are defined as follows Live refers to media served in real time as an event occurs DVR refers to serving content acquired from a live feed but served at a later time VOD refers to media served from a single complete i.e. not incrementally changing file or set of files. Real Time Messaging Protocol RTMP is the streaming and RPC protocol used by Flash. Real Time Messaging Protocol Encrypted RTMPE is the encrypted version of RTMP using secrets built into the server and client. SWF or Small Web Format is the format for Flash client applications. SWF verification refers to a technique by which the Flash Player can authenticate to FMS that it is playing an unmodified SWF by sending hashes of the SWF itself along with secrets embedded in the client and server.

Referring to the live streaming process begins with a stream delivered from an Encoder to an Entry Point . An RTMP Puller component e.g. running on a Linux based machine in an EP Region not shown is instructed to subscribe to the stream on the EP and to push the resulting data to one or more Archiver processes preferably running on other machines. As illustrated one of the Archivers may operate as the leader as a result of executing a leader election protocol across the archiving processes. Preferably the Archivers act as origin servers for the edge server HTTP proxy processes one of which is shown at for live or near live requests. The edge server HTTP proxy provides HTTP delivery to requesting end user clients one of which is the Client . A Client is a device that includes appropriate hardware and software to connect to the Internet that speaks at least HTTP and that includes a content rendering engine. The Client device type will vary depending on whether the device connects to the Internet over a fixed line environment or a mobile environment. A representative client is a computer that includes a browser typically with native or plug in support for media players codecs and the like. If DVR is enabled content preferably is also uploaded to the Storage subsystem so that the Storage subsystem serves as the origin for DVR requests as will be described.

As also seen in the content provider may choose to deliver two copies of the stream a primary copy and a backup copy to allow the stream to continue with minimal interruption in the event of network or other problems. Preferably the primary and backup streams are treated as independent throughout the system up through the edge server HTTP proxy which preferably has the capability of failing over from the primary to the backup when the primary is having difficulties and vice versa.

A content request from an end user Client is directed to the CDN edge machine HTTP proxy preferably using techniques such as described in U.S. Pat. Nos. 6 108 703 7 240 100 7 293 093 and others. When an HTTP proxy receives an HTTP request for a given stream the HTTP proxy makes various requests preferably driven by HTTP proxy metadata as described in U.S. Pat. Nos. 7 240 100 7 111 057 and others possibly via a cache hierarchy see. e.g. U.S. Pat. No. 7 376 716 and others to learn about and download a stream to serve to the Client . Preferably the streaming specific knowledge is handled by the edge machine HTTP proxy directly connected to a Client . Any go forward cache miss requests issued from the HTTP proxy preferably are standard HTTP requests. In one embodiment the content is delivered to the Client from the HTTP proxy as a progressive download FLV file. As noted above the references herein to Adobe FLV are used herein by way of example as the disclosed architecture is not limited for use with Adobe FLV. For secure streams preferably the Client first authenticates to the HTTP proxy using an edge server authentication technique and or a SWF verification back channel.

When a Client requests a particular stream the HTTP proxy to which the client has been directed typically via DNS starts the streaming process by retrieving a Stream Manifest that contains preferably only slowly changing attributes of the stream and information needed by the HTTP proxy to track down the actual stream content. The URL to download this manifest preferably is constructed deterministically from metadata delivered e.g. via the distributed data transport mechanism of to the HTTP proxy. Preferably the manifest itself is stored in association with a Stream Manifest Manager system not shown and or in the storage subsystem . Preferably a Stream Manifest describes the various tracks that compose a stream where preferably each track constitutes a different combination of bit rate and type where type is audio video or interleaved AV. The Stream Manifest preferably includes a sequence of indexInfo time ranges for each track that describe forward URL templates stream properties and various other parameters necessary for the HTTP proxy to request content for that time range.

For live requests the HTTP proxy starts requesting content relative to now which in general is approximately equal to the time on the edge machine HTTP proxy process. Given a seek time the HTTP proxy downloads a Fragment Index whose name preferably is computed based on information in the indexInfo range and an epoch seek time. Preferably a Fragment Index covers a given time period e.g. every few minutes . By consulting the Fragment Index an Intermediate Format IF Fragment number and an offset into that fragment are obtained. The HTTP proxy can then begin downloading the file e.g. via the cache hierarchy or from elsewhere within the CDN infrastructure skipping data before the specified offset and then begin serving to the requesting Client from there. Preferably the IF fragments are sized for optimal caching by the HTTP proxy. In general and unless the Stream Manifest indicates otherwise with a new indexInfo range for live streaming the HTTP proxy then continues serving data from consecutively numbered IF Fragments.

As used herein and in the context of live HTTP based delivery the Intermediate Format IF describes an internal representation of a stream used to get data from the RTMP Puller through to the edge machine HTTP proxy. A source format SF is a format in which the Entry Point provides content and a target format TF is a format in which edge machine HTTP proxy delivers data to the Client . According to this disclosure these formats need not be the same. Thus SF may differ from TF i.e. a stream may be acquired in FLV format and served in a dynamic or adaptive variable bit rate format. The format is the container used to convey the stream typically the actual raw audio and video chunks are considered opaque data although transcoding between different codecs may be implemented as well. By passing the formats through the HTTP proxy and delivering to the Client via conventional HTTP the container used to deliver the content can be changed as long as the underlying codecs are managed appropriately.

Referring now to the HTTP streaming architecture for live content may work as follows. At step 1 a content provider s encoder pushes a live FLV stream to Entry Point EP . At step 2 the RTMP Puller pulls the stream from the EP and breaks it up into Intermediate Format IF file fragments and corresponding index information. A Demuxer process facilitates this operation. The Puller preferably uses metadata from a Stream Manifest file to determine how large to make each individual IF fragment. Preferably and as noted above IF fragment size is optimized for caching in the cache associated with an edge machine HTTP proxy.

At step 3 the Archiver retrieves from the Puller the IF fragments along with their corresponding index information. The Archiver appends the index information for each IF fragment to the current Fragment Index FI file. Preferably the Archiver caches a predetermined number of IF fragments for live play back. As the fragments age out preferably they are deleted from the Archiver and at step 4 they are archived e.g. to the Storage subsystem . Thus at set intervals e.g. every few minutes the Archiver closes the current FI file archives it to the Storage subsystem and begins creating a new FI file.

At step 5 and after an end user Client has been associated with a particular edge machine the HTTP proxy in that machine gets the fragments for live play back and limited DVR time periods from the Archiver possibly via the cache hierarchy . Fragments no longer available on the Archiver are retrieved from the Storage subsystem . A Muxer process that operates in association with the HTTP proxy facilitates this operation. Preferably each IF fragment is a separate object for the HTTP proxy that can be and is accessed through HTTP. In other words according to this disclosure the live stream is broken up into many small objects fragments. The HTTP proxy receives DVR commands from the Client player typically on a separate HTTP connection. When the client player requests to begin playing from a new stream position the HTTP proxy uses metadata from the Stream Manifest file to calculate which FI file contains the target time offset. The FI file is retrieved from the Archiver or the storage sub system or alternatively from a peer machine co located with the edge machine and contains the IF fragment and byte offset to begin streaming to the client player.

The Fragment Indexes enable the HTTP proxy process to which a particular Client has been associated to find a frame around a desired seek time. Preferably each Fragment Index file contains index information covering a fixed amount of time. The exact interval is stored in the Stream Manifest for each indexInfo range. The desired seek time epoch time can be rounded down to the nearest interval boundary to find the Fragment Index to request.

Preferably each stream is represented completely by the Stream Manifest the Fragment Index and the IF Fragments. In an illustrative embodiment the Stream Manifest is an XML file that contains the following information stream epoch time this time may be the time when the stream started or may be the oldest archived portion of the stream still available stream Properties like bit rate video size codec information etc. information about fragment indexes and which URL pattern to use to request FI file and URL pattern for the fragments. The Fragment Index FI typically comprises the following information about which key frame to start streaming from for a given time slice key frame to fragment number mapping key frame to time mapping key frame to byte offset in that fragment mapping and so forth. Each IF Fragment contains approximately N seconds of stream preferably optimized for HTTP proxy caching and not necessarily fragmented on time boundaries. Each fragment is composed of a fragment header fragment stream header and a payload and each fragment is uniquely identified by the fragment number. Fragment numbers incrementally increase.

Typically and with reference back to the Archiver has the fragments for the most recent N minutes of the stream and the rest of the fragments are on the Storage subsystem . The Archiver creates a Stream Manifest XML file for each stream. It puts all the necessary information that an HTTP proxy can use to make fragment and fragment index requests. For the Archiver to construct a Stream Manifest preferably RTMP Puller sends the stream properties downstream. Preferably the IF Fragment is used to serve time related data i.e. actual video audio bytes. Also preferably the HTTP proxy to which the Client has been associated makes requests for IF Fragments only. Thus it is desirable to isolate fragments from packets that have stream properties.

The Muxer subsystem associated with or within the HTTP proxy determines how to request IF converts IF to the output stream and passes this data to the HTTP proxy for serving to the requesting client. In addition preferably the HTTP proxy process supports a control channel by which the client can make any combination of various requests against an active stream including without limitation sessionToken seek and switch. The control channel facilitates flow control when working in some runtime environments such as where the client lacks its own flow control facilities. In this situation the control channel passes throttle commands that may be based on a percentage of an average bit rate over the server to client connection to help maintain full a target buffer on the client side of the connection. A sessionToken request is a request to provide additional authentication information e.g. via SWF Authentication. A seek is a request to start sending data as of a different time in the stream including jump to live . A switch is a request to start sending data from a different track from the same Stream Manifest. This might be a bit rate switch and or an angle change.

Thus the HTTP proxy receives DVR commands from the client player preferably on a separate HTTP connection. When the client player requests that playback begin from a new stream position the HTTP proxy uses metadata from the Stream Manifest file to calculate which FI file contains the target time offset. The FI file is retrieved e.g. from the Archiver or the Storage subsystem or from a peer machine and contains the IF fragment and byte offset to begin streaming to the client player.

As described the Stream Manifest preferably is an XML file and contains information about fragment indexes and how to construct the URL for an FI file how to construct the URL for the now request and how to construct the URL for the fragments. The HTTP proxy caches the manifest which can be retrieved to the proxy either from an Archiver which may be tried first or the Storage subsystem. Client players connect to the HTTP proxy to play the live stream i.e. connect to the stream s now time . In response the HTTP proxy makes a forward request to the Archiver to fetch the now time on a live stream. Metadata in the Stream Manifest is used by the HTTP proxy to create the now URL.

As also described a stream has a number of FI files. Each contains stream keyframe information for a given time slice. The Fragment Index allows time offsets to be mapped to fragment numbers and byte offsets. The Stream Manifest file defines the time slice for each FI file.

Each IF Fragment contains approximately N seconds of a stream. Each fragment is composed of a header and a payload. The HTTP proxy understands the data in the header but the payload is opaque. The HTTP proxy links together with a Muxer component to convert the IF formatted payload to the target format that is streamed to the client player. The fragments are cached in the HTTP proxy for re use and each fragment is identified with its stream name and an integer suffix that increases incrementally. As described above Archiver has the fragments for the most recent N minutes of the stream and the rest of the fragments are on the Storage subsystem.

For non authenticated content preferably the client player connects to an http URL to play a stream. Query string parameters can be used to request a particular seek time if the default live if the stream is live or the beginning of the stream if it is not live is not appropriate. For authenticated content preferably the original http URL additionally contains a shared authentication token query string parameter generated by the customer origin. This enables the HTTP proxy process to serve the stream for some configured amount of time e.g. a given number of seconds . After that time the HTTP proxy process terminates the connection unless for example an out of band control POST is received with a signed session token. Although not meant to be limiting in one approach this token preferably is generated by the client by connecting to an FMS or equivalent edge machine that can perform SWF Verification as shown in . The machine returns the signed session token to the client to be forwarded back to the HTTP proxy process as a control channel POST. Once the session token is received by the HTTP proxy the stream preferably will play indefinitely. Other types of stream authentication may be implemented as well.

A Demuxer process may be integral to the Puller likewise a Muxer process may be integral to the HTTP proxy process. There may be one Demuxer process for multiple Pullers there may be one Muxer process for multiple HTTP proxies within a particular Region .

As noted above in terms of functionality Demuxer converts regular stream packets into IF fragments and Muxer does the opposite. By definition Demuxer and Muxer should complement each other. As noted Demuxer can be part of an RTMP Puller process or can be a separate process running on the RTMP Puller machine. Demuxer receives input via the RTMP Puller. It is responsible to do the following generate IF Fragment Header take the source format and package the same into IF body add Fragment Stream Header Push IF fragment to Archiver analyze the fragment and generate index information pertinent to key frame location within a given FLV packet Push Key frame information to the Archiver. This can be done synchronously asynchronously with respect to the IF fragment transmission. Preferably Demuxer also is responsible for determining an optimal size of the fragment which fragment size should be optimal for HTTP proxy caching. Demuxer can base its decision regarding the optimal size of the fragment by examining the following stream properties incoming live stream byte rate bit rate Key Frame Interval or a combination of both. Apart from constructing IF Fragments Demuxer is also responsible to push Stream Properties and key frame information to the Archiver. Archiver can then create the Stream Manifest file that will be used by the HTTP proxy Muxer to make fragment index and individual fragment requests. As described above Muxer complements Demuxer. As Demuxer is responsible for constructing IF Fragments Muxer is responsible for deconstructing the IF Fragments and converting the IF Payload format to the target format TF that the Client requested. The Muxer may also provide the following information to the HTTP proxy statistics information about HTTP delivered Streams and client session playback Information such as playback duration etc. and Muxer health data.

The Demuxer and Muxer enable dynamic transmux output to other file formats. This enables the system to leverage a single set of content sources for different device capabilities e.g. iPhone 3.0 streaming using MPEG 2 TS Segments Microsoft Silverlight 3 with H.264 playback Shoutcast and so forth.

As a variant to the above described pull model that operates between an Encoder and an Archiver it is also possible to use a push based approach.

The above described architecture is useful for live streaming particularly over formats such as Flash. The following section describes adding video on demand VOD support to the platform. In particular the solution described below provides VOD streaming from customer and Storage subsystem based origins provides single and multiple bitrate SBR and MBR streaming provides support for origin content stored in flv and mp4 flv containers supported mp4 flv codes include among others AAC MP3 PCM for audio and H.264 for video and minimizes download of content beyond what is directly requested by the end user.

For VOD delivery the stream recorder tier of is replaced preferably with a translation tier as will be described. For VOD delivery using HTTP the Fragment Indexes may be generated from the origin content on the fly e.g. by scanning FLV or parsing MP4 MOOV atoms and caching these indexes. Actual data retrievals may then be implemented as partial object caching POC retrievals directly from source material at the edge region or via an intermediate translation e.g. by a cache h parent into an Intermediate Format. As used herein partial object caching refers to the ability of an HTTP proxy to fetch a content object in fragments only as needed rather than downloading the entire content object. The HTTP proxy can cache these fragments for future use rather than having to release them after being served from the proxy. An origin server from which the content object fragments are retrieved in this manner must support the use of HTTP Range requests.

Before describing a VOD implementation in detail the following section describes several ways in which VOD content is off loaded for HTTP delivery to the CDN. In a first embodiment a conversion tool a script is used to convert source content flv to IF with the resulting IF files then uploaded to the Storage subsystem. In this approach metadata is used to have an HTTP proxy go forward to the Storage subsystem to retrieve the stream manifest which then references the Storage subsystem for the remaining content. In this approach files in mp4 flv are first converted to flv e.g. using ffmpeg copy mode to change the container to fly. Another approach is to have a CDN customer upload raw media files to the Storage subsystem and to run a conversion tool there. Yet another alternative is to have the customer or encoder produce content in IF directly.

The translation tier approach is now described. In this approach an on demand dynamic IF generator machine takes requests for IF manifests indexes and fragments and satisfies these requests by dynamically retrieving flv or mp4 f4v input file ranges either from the Storage subsystem or customer origin . From there HTTP proxy treatment is essentially the same as the conversion tool options described above. The generator machine preferably runs its own HTTP proxy the translator HTTP proxy to cache various inputs and outputs together with a translator process described below that accepts requests e.g. from a localhost connection to the translator HTTP proxy and generates IF based on data retrieved from the HTTP proxy via an associated cache process. In an alternative the translator process may comprise part of the translator HTTP proxy in which case IF generation takes place within the proxy. Fragment generation may also be carried out in an edge machine HTTP proxy or even further downstream into the Client itself such as where a Client maintains a session connection with one or more peer clients.

An architecture and request flow of a preferred approach is shown in . In this embodiment which is merely representative and non limiting a translation tier is located between an origin e.g. customer origin or the Storage subsystem or both and the stream player tier . In a representative embodiment the translation tier executes in its own portion e.g. a Microsoft IIS or equivalent network within the CDN preferably in a Region dedicated to this purpose. Alternatively a translator as described below may run on a subset of HTTP based edge machine Regions.

The process flows in illustrates a typical work flow of an Http Stream Request to play live content. Preferably in this embodiment every new request to the HTTP edge server process referred to in the drawing as an Edge Ghost for Http stream is considered as a progressive download stream. The workflow in and B highlights the interaction between the edge server process and MuxerAdaptor Http Stream Muxer library. In particular and as will be described typically steps and are performed by one or more of the process classes shown in . Typically steps and are performed by the Muxer Adaptor Class. Muxer Adaptor will call the necessary Http Stream Muxer library APIs to perform certain steps.

By way of background and to facilitate what is represented in the drawing a set of connectors is shown namely a Player Connector P a Cache Store Connector C an Archiver Storage Connector N and a Workflow Connector W . Generally a client player connects to an edge server process via the CDN DNS or otherwise to play live streams i.e. connect to the stream s now time . The edge server process makes a forward request to an Archiver to fetch the now time on a live stream. Metadata in the Manifest File is used by the edge server process to create a now URL.

The Player Connector represents an end user Player making request with Stream ID and query parameters to seek to a now time. As noted above a stream has a number of FI files and each contains stream key frame information for a given time slice. The fragment index allows time offsets to be mapped to fragment numbers and byte offsets. The Stream Manifest file defines the time slice for each FI file. An input associated to the FI is the now request and an output is the last received keyframe information for the now request. At step the edge server process accepts the connection for a stream and creates a driver object. Using the Stream ID the edge ghost process then creates a Stream Manifest object and constructs a Stream Manifest URL. This is step . Using the Stream Manifest URL the edge server process obtains the Stream Manifest either its local cache Cache Store or from an Archiver or Storage illustrated as . This is step . The edge server process then continues at step using the Stream Manifest File to parse the Stream Manifest and to store it in a Manifest object. Using the play time as now as identified in the query parameters the edge server process generates a now URL at step . Using this now URL at step the edge server process creates the Now response using local cache or by going forward to the Archiver or Storage as necessary. The Now response which contains a latest keyframe epoch time is then used by the edge server process at step to create a MuxerAdaptor Class object. The keyframe epoch time is then passed. The MuxerAdaptor Class object so created constructs Http stream headers using the MuxerManifestAdaptor class. This is step . These stream headers are then returned to the edge server process which then sends those headers back to the player in step . The keyframe epoch time is then used by the MuxerAdaptorClass object to calculate a Fragment Index File number. This is step shown in . Using the Fragment Index File number control returns back to the edge server process which at step gets the Fragment Index file from either local cache or Archiver Storage. Using the Fragment Index file the edge server process continues at step to parse the file and pass the keyframe details to the MuxerAdaptorClass object. At step the MuxerAdaptorClass object using fragment number offset passed from the edge server process to make a request for the fragment. This request is made to the edge server process using the fragment number. Thus at step the edge server process gets the IF fragment from the Archiver Storage as the case may be. The fragment is then passed back to the MuxerAdaptorClass object which at step reads the IF fragment and constructs data for the player in the target format. The stream data is then passed back to the edge server process which at step returns it to the player.

At step the MuxerAdaptorClass object tests whether the fragment is complete. If not control continues at step while the object waits for the remaining portion. If however the outcome of the test at step indicates the fragment is complete the MuxerAdaptorClass continues its processing at step either by returning to step for the next Fragment or by returning to step for the next Fragment index . If there is no more stream data control returns to the edge server process which at step closes the Player connection to complete the process of responding to this particular request.

In a seek mode preferably the client player does not establish a new connection for the seek request. For Http based streaming preferably the client only initiates a new connection to the edge ghost process to post a seek control message. Preferably the session id for this seek request is the same as that used when the connection is first established. When the edge ghost process receives the seek control message from the client player preferably it uses the same objects that were created when the session first started. For seek requests the edge ghost process may calls a dedicated Muxer process function. The MuxerAdaptorClass and Http Stream Muxer library handle the transition from the previous mode e.g. live mode to the new seek mode.

As noted above a representative IF Fragment includes a fragment header a fragment stream header and a payload. The fragment header is a fixed size header and each fragment has only one such header. It provides IP specification version fragment number fragment creation time fragment stream type audio video interleaved AV the latest stream manifest file version payload offset field to indicate the start of the payload data header type and header length. The fragment stream header can be of variable size and each fragment has only one such header. It provides information about the stream properties stream name stream source format and sub type e.g. FLV IF payload format and sub type e.g. FLV F MP4 etc. header type and header length.

As described preferably each IF fragment contains approximately n seconds of stream. Preferably IF files are sized for optimal edge ghost process caching and not necessarily fragmented on time boundaries. As noted above each fragment is composed of a header and a payload. The edge ghost process understands the data in the header but typically the payload is opaque. As illustrated in the the edge ghost process links together with the muxer component to convert the IF formatted payload to the target format which is then streamed to the client player. Preferably the edge ghost process also caches the fragments preferably as regular StoreEntries. Each fragment is identified with its stream name and an integer suffix that increases incrementally. Archiver has the fragments for the most recent N minutes of the stream and the rest of the fragments are on Storage. Preferably any fragment for a particular stream type has an associated IF Fragment Number which is a unique identifier. The fragment number increases incrementally. The edge ghost process requests for IF fragment using its fragment number. RTMP Puller is responsible to assign a unique number to each fragment.

As noted above the content provider or a third party encoder pushes a live FLV stream to the entry point e.g. over RTMP. The RTMP Core pulls the stream from the entry point and breaks it up into the file fragments. The RTMP Core contacts the Stream Manifest Manager and provides stream information. The Stream Manifest Manager supplies information regarding which Archiver is set to push IF Fragments. The RTMP Core creates the IF Fragments and pushes them to the Archiver. The IF Fragment size is optimized for edge server ghost process caching. The Archiver retrieves from the RTMP Core the IF Fragments along with stream keyframe information. It then appends the stream s keyframe information to a current Fragment Index FI file. The Archiver caches a predetermined number of IF Fragments and fragment indexes for live playback. As the fragments age out they are deleted from the Archiver and archived to Storage. At set intervals e.g. every few minutes the Archiver closes the current FI file archives it to Storage and begins creating a new FI file. The edge ghost process gets the fragments for live playback and limited DVR time periods from the Archiver. Fragments no longer available on the Archiver are retrieved from Storage. Each IF fragment is a separate object for the edge ghost process that can be accessed through HTTP. Thus the live stream is broken upon into many small objects fragments. The edge ghost process receives DVR commands from the client player on a separate HTTP connection. When the client player requests that playback begin from a new stream position the edge ghost process uses metadata from the Stream Manifest File to calculate which FI file contains the target time offset. The FI file is retrieved from a peer from an Archiver from Storage as the case may be and contains the IF fragment and byte offset to begin streaming to the client player. Thus requests are dynamically re assembled by the edge ghost process from fragments on the fly.

As also noted above the muxer and demuxer enable dynamic transmux output to other file formats. This enables the system to leverage a single set of content sources for different device capabilities e.g. iPhone 3.0 streaming using MPEG 2 TS Segments Microsoft Silverlight 3 with H.264 playback Shoutcast and so forth.

Preferably the functionality described herein is implemented as a separate subsystem in the edge server process. is a diagram that shows the relationship between the C classes in one embodiment. These classes are now described. As noted above preferably there are a set of edge server process classes that are not exposed to the muxer implementations. They include a Driver SessionManager StreamRepository StreamEntry Stream Manifest . The abstract classes for the muxer include MuxerIOHandler Muxer MuxerManifestAdapter and FlvMuxer .

There is an instance of the Driver in request t for each request that is configured for Http streaming. This is the overall driver. It looks up the Stream instance for a Stream ID from the StreamRepository . If necessary the Driver fetches and parses the stream manifest for the stream. It also gets from the Archiver the now time for the stream and checks to be sure that the time requested by the client is permitted if not an error is returned. The Driver is also responsible for creating a Muxer . Further the Driver sends a startStream message to the Muxer. The Muxer responds by assembling the stream using the MuxerIOHandler interface from the Driver . When the stream is finished the Muxer informs the Driver which terminates the chunk encoded response to the client.

The edge server process generates a unique session ID for each stream client. The SessionManager maps each session ID to its current Driver. In particular the session ID is added to the generated stream by the Muxer using an onMeta FLV tag. The client can make control requests to the edge server process to change the current time of a stream DVR functionality or change the bitrate or switch to a different rendition of the stream. SessionManager also is used for reporting purposes.

The StreamRepository is a hash table with a list of all the streams keyed by StreamID where StreamID is a metadata parameter. The value for each StreamID is a StreamEntry. StreamRepository can be used for reporting purposes to see all the streams currently served by the edge server process.

The StreamEntry is a set two streams primary and backup. These streams show the same event but might come from two different entrypoints which may not be synchronized. Each of these streams preferably has its own manifest. The StreamEntry knows which one is the preferred stream.

The Stream has a manifest and a set of functions to asynchronously fetch the now time indexes and fragments and it keeps track of miscellaneous statistics number of concurrent clients etc. . The Manifest encapsulates the stream manifest. Another class called Fetcher not shown is used to fetch a variety of objects such as manifests now time IF indexes and IF fragments.

The Muxer interfaces provide the FLV muxer implementation. MuxerIOHander is used by the Muxer to handle asynchronous I O. The Muxer transforms an input made of IF fragments into a stream that a player can use. The MuxerManifestAdapter is a class that gives the Muxer access to the Manifest . The muxer implementation is done by creating a streaming FlvMuxer class which implements the streaming Muxer interface.

As noted above the Stream Manifest is an XML file that contains Stream epoch time when the stream started or may be the oldest archived portion still available information about fragment indexes and how to construct the URL for a FI file how to construct the URL for the now request and how to construct the URL for the fragments. The edge server process caches the manifest as a regular StoreEntry. It is assumed that the manifest URL is the same as the incoming URL without the query string. Preferably there is a manifest file on the Archiver and one on Storage. When the manifest is needed the Archiver is tried first.

A stream has a number of FI files. A Fragment Index FI contains stream index information for a given time slice. The FI allows time offsets to be mapped to fragment numbers and byte offsets. The Stream Manifest file defines the time slice for each FI file. The input to the FI is now or a requested time offset. The output of the FI is a fragment number or byte offset. As described above client players connect to the ghost edge server process to play live streams. i.e. connect to stream now time . In response the edge server process makes a forward request to the Archiver to fetch the now time on a live stream. Metadata in the manifest file is used by the process to create the now URL.

Each fragment contains approximately n seconds of stream. As noted above preferably IF files are sized for optimal caching and not fragmented on time boundaries. Each fragment is composed of a header and a payload. The edge server process understands the data in the header but the payload is opaque. The edge server process links together with a muxer component to convert the IF formatted payload to the target format which is then streamed to the client player. The edge server process caches the fragments as regular StoreEntries. Each fragment is identified with its stream URL and a query string parameter indicating the fragment number. Archiver has the fragments for the most recent N minutes of the stream and the rest of the fragments are on Storage.

There may be several incoming source formats to an EP. Preferably the incoming source formats get converted to the IF format at the RTMP Puller. The edge server process converts the IF format to the target format based on the user request.

As illustrated in the RMTP Puller acts like a Flash client when interacting with the Flash EP and it connects to Archivers and by querying the stream manifest file. Preferably the RTMP Puller resides in edge server machines and pulls streams from the Flash entry points in a same or nearby CDN region. Preferably more than one instance of RTMP Puller exists in a given machine. The RTMP Puller has knowledge of a set of one or more entry points it should connect as identified in metadata or via some other means . Upon startup the RTMP Puller establishes a master connection e.g. an RTMP channel used for control messages with the target entry points. Once a stream announcement e.g. as described in U.S. Pat. No. 6 751 673 reaches the RTMP Puller the RTMP Puller will connect authenticate e.g. using an authentication scheme as described above and then pull the Flash streams from the Flash EP. The RTMP Puller injects the incoming FLV stream into Demuxer. As noted above the Demuxer packages the incoming stream into an appropriate IF fragment and pushes the IF fragments to the Archivers interested in the stream. The actual stream may be pulled from the EP on a separate stream connection.

As shown in preferably the RTMP Puller pulls the stream S1 from EP1 and will push the demuxed stream to Archiver 1 and Archiver 2 in Region 1 and to Archiver 1 in Region 2 by choosing the Archiver targets via a stream manifest file supplied by the stream manifest manager.

Preferably the RTMP Puller acts as a leader node. The diagram in illustrates one possible interaction between the Flash EP and RTMP Puller.

Preferably the RTMP Puller retains the original live stream name coming from the EP and based on whether the stream is a primary or secondary stream tags the IF fragment name and then involves an Archiver access plug in to share the data. RTMP Puller knows or can ascertain whether a given streamed is provisioned as a multi bitrate MBR stream or a regular stream. For MBR streams one instance of RTMP Puller pulls all the pertinent MBR streams from the Flash EP but preferably over separate connections.

As noted above RTMP Puller uses the Demuxer to convert the source format to the IF before pushing the packets to the Archiver. Demuxer can be part of RTMP Puller or a separate process running in association therewith as described above.

Preferably RTMP Puller pushes multiple copies of identical IF fragments to configurable number of Archivers. Preferably communications between the RTMP Puller and the Archiver occur via an Archiver access adaptor which reads the stream manifest file chooses an appropriate Archiver and appends the Archiver s information along with the Archiver role as primary or backup . describes the interaction between the RTMP Puller and Archiver using the RTMP Puller s archiver access adaptor.

An RTMP Puller preferably uses an Archiver Client library to interact with the Archivers and the Stream Manifest Manager SMM system. The library ensures that the Stream Manifest is updated to indicate the newly published stream. As noted above and based on the RTMP Puller s region a set of Archivers is chosen to handle the stream. Internally RTMP Puller uses the demuxer as a library to split the incoming stream into FLV tags identify key frames and package the resulting data in Intermediate Format. The Archiver Client library pushes the stream content to each Archiver in the set. Preferably the Client library pushes out all of the stream data using chunk encoded HTTP requests authentication. To ensure that FLV tags are delivered atomically preferably each HTTP chunk contains an integral number of complete FLV tags. Chunks carry additional information such as when to start new fragments where key frames can be found and per chunk integrity hashes. If any of the connections fail the client library issues a special request to the Archiver to discover the correct resume position and then start another POST from that point forward.

The Archiver receives data from RMTP Puller and incrementally writes this data to a RAM disk or equivalent. If an edge server process requests a fragment or fragment index which is currently in the process of being receiving from RTMP Puller Archiver sends the response in a chunk encoded HTTP response so that the data can be sent as soon as it is received without the full file size in advance. If a response is interrupted before the edge server process receives the end of response marker from Archiver the edge server process simply discards the object and re requests the data gain if the data is still needed. Once a fragment or fragment index is complete a designated leader Archiver attempts to upload the resulting file to Storage. In the alternative several fragments may be combined into a single serve from zip like archive to allow Storage to store fewer larger objects. In this situation Storage hides this aggregation from the edge server process by looking up the right fragment from the archive. The non lead Archivers monitor the lead Archiver s progress and perform the Storage uploads if the lead Archiver is not doing so.

The following provides details regarding a Stream Manifest Manager SMM component and its application programming interface. Stream Manifest Manager requests are standard HTTP requests with specific methods URL paths headers and body content. The hostname for each request typically depends on whether the stream is a primary or backup stream preferably independent SMM instances are run for primary and backup streams. The source RTMP Puller may use domain names configured via a network configuration file. These domain names may be resolved to a specific live SMM machine by the process described in U.S. Pat. No. 7 111 061. Preferably an SMM instance runs on two separate ports a first port that accepts read only requests while a second port accepts all requests. This port separation allows separate processes to service update requests and edge server process download requests in the future. Preferably request parameters are specified in a request URL and request headers. Preferably SMM specific request headers are prefixed with X smm .

In operation the source RTMP Puller forwards all X smm headers from an SMM START response to the Archiver Client Library which in turn forwards these values to the Archiver. This data flow eliminates the need for per stream provisioning configuration information in Archiver. To prevent confusion among Stream Manifest Managers and Archivers when multiple sources RTMP Pullers are involved each time a source begins dealing with a stream preferably it assigns a unique identifier within that particular track . This identifier is represented as two separate values X smm source start which is the epoch time the source received the first request related to this stream and X smm source identity which is an identifier for the source itself e.g. IP address. Preferably source identifiers are assigned an order based first on a major comparison of the start time and requests from the source to SMM include a source identifier. Preferably this same identifier information is passed to the Archiver which is accomplished implicitly by forwarding the X smm headers to Archiver . In one embodiment smm supports setting the stream type i.e. the type attribute on the track tag which contains the actual ranges. Preferably the stream type is set by adding A V or AV after the primary backup designator in the START STOP or DELETE url. If omitted the default AV is assumed.

Preferably communication between the source RTMP Puller SMMs and Archivers is protected by a single encryption key set and RTMP Puller will accept streams only from valid EPs and EPs accept streams only from authorized encoders. In one embodiment global configuration file variables define the keys for internal communication. To support rotation a first key listed is used to sign requests while a full set is used to verify requests. Preferably Archiver uses two additional sets of keys for its own use a per customer Storage upload postfile key and a per customer edge server process download keys. Preferably the actual key secrets are distributed by MDT such as described in U.S. Pat. No. 7 111 057 to both Archiver and SMM. To eliminate the need for per stream provisioning and configuration information in Archiver each set of keys in the MDT channel is named and SMM sends to Archiver via the source the key set name to be used for Storage uploads and the key set name to be used for ghost process downloads for each individual stream track. Preferably SMM consumes an MDT key channel to authenticate Stream Manifest GET requests from the edge server process.

The SMM uses an application programming interface API . A START request is used to initiate streaming. A STOP request is used by the stream source e.g. RTMP Puller to indicate that a stream has ended. A request to an SMM also may be used to DELETE a manifest a specific track or a specific range. Manifests are retrieved through the API using a GET request. A RESUME MODE request is a variant on a START request. When SMM wants to reuse the same URL path as an existing stream which SMM believes might still be live SMM needs assistance from RTMP Puller to determine the correct starting fragment number. This request is used for this purpose. A REMAP request is used by the stream source to initiate an evaluation of quality for a particular Archiver set and to determine whether a remap to another set is needed. Preferably requests to SMM are standard HTTP requests with authentication headers. SMM machines include a utility that is an authentication wrapper around CURL.

When a source RTMP Puller learns of a new stream track it begins by making a START request against the SMM domain name associated with the primary backup status of the stream. This START request has one of several different replies. A give up reply case 1 indicates that another source with a higher source identifier has already started streaming. Another reply 2 is to start a new URL path and start with fragment 0. This case applies to a brand new track when the status of a previous source cannot be determined and when certain index parameters need to be changed. In this case the source can initialize an Archiver Client Library to begin pushing the stream to the Archiver set specified by SMM starting with fragment 0. Another reply 3 is to use an existing URL path beginning with a non zero fragment. This applies to a previously existing track when the previous source stopped the stream cleanly or when it could be determined when the previous source closed the stream . In this case the source can initialize the Archiver Client Library to begin pushing the stream to the Archiver set and fragment specified by SMM. Another reply is a request that the source attempt to determine the correct resume point fragment in an existing URL path. This applies to a previously existing track when the previous source was not cleanly stopped. When SMM chooses this option the source must use the Archiver Client Library to determine the correct resume fragment number. Once this number is determined the source makes a second START resume mode SMM request with some additional information. SMM will reply with either one of 1 2 and 3 described above. If the reply is case 2 the source may need to close the Archiver Client Library instance and create a new one because arbitrary parameters may have changed. Case 3 uses the same Archiver Client Library instance which computed the resume offset. To help the source decide whether or not to start a new Archiver Client Library instance the resume mode reply includes a special X smm reset header that directly tells the source whether a new Client instance needs to be created.

When a source sees the end of the stream it makes a STOP request to SMM once it has received a close notification from the Archiver Client Library for that stream.

In an alternative embodiment SMM may also make periodic now requests against the Archivers to determine whether the stream is actually still live. If the Archivers have not received data in some configured amount of time the SMM will declare the stream dead. To enable this behavior the now reply should include header fields to indicate how many seconds have elapsed since the most recent update to now or the epoch time of said update . Additionally the most last fragment number may be useful to terminate the range. If SMM cannot contact a sufficient number of Archivers no update will be made to the Stream Manifest. There are two basic requests START and STOP. A START request is used by the stream source e.g. RTMP Puller to initiate streaming. This request creates and or updates whichever XML tags are necessary to indicate to the edge server process that the stream is live. A resume mode request is a variation on a START request. When Stream Manifest Manager would like to reuse the same url path as an existing stream which SMM believes might still be live SMM needs some help from RTMP Puller to determine the correct starting fragment number. When SMM responds to a START request with the reply header X smm first fragment 1 RTMP Puller must attempt to determine whether the returned Archiver set is able to resume the stream and if so what the first fragment number of the new stream will be.

As noted above incoming media packets are demuxed into an Intermediate Format. The muxer component residing closer to or on the edge muxes the packets to the desired target format before the packets reach the end clients. above depicts the flow of media packets into and out of the framework. In one embodiment the ingress and egress format is in Adobe FLV but this is not a limitation as noted. In this example implementation the encoder pushes the CDN customer content into the Flash entry point EP . The RTMP Puller then pulls the content from the Flash EP and passes the data to the demuxer. Demuxer converts that incoming source format e.g. FLV to IF fragments before injection into the Archiver sub network.

The above described embodiments provide a format agnostic streaming architecture that utilizes an HTTP edge network for object delivery.

The above described approach provides numerous advantages. The techniques described herein facilitate the delivery of high definition video and audio including advanced video features such as DVR over an HTTP edge network which in a typical CDN is the network that has the largest footprint. By implementing the techniques a provider can leverage its existing HTTP based servers instead of having to implement and maintain dedicated server networks to support multiple third party runtime environments. Moreover because the delivery is HTTP based the content can be seamlessly delivered to clients operating across fixed line and mobile environments. No special client software is required as the HTTP proxy that responds to the client request dynamically re assembles fragments that it obtains and serves the requested content via HTTP. Further because delivery within the set of interconnected machines of the CDN preferably takes advantage of an intermediate format the network can ingest content in one format yet serve it in another all while preserving single or multi bitrates and DVR like functionality. Thus for example the network may take in live RTMP packets and serve the content as an FLV progressive download. Preferably each IF fragment of the stream is a separate object for the HTTP proxy that can be accessed cached and served via HTTP. According to the scheme the stream is broken up into many small objects fragments with each fragment managed separately.

The network is not limited for use with any particular runtime environment such as Flash. By leveraging the approach as described a single set of content sources can be leveraged for different device capabilities. Thus the techniques as described herein include dynamically transmuxing content to other file formats in a manner that is transparent to the content provider and the end user.

The intermediate format may be based on or adapted from any convenient multimedia file format that can be used delivery and playback of multimedia content. These include without limitation fragmented mp4 protected interoperable file format piff and others. More generally any linked list based file format may be used.

Preferably the CDN service provider provides an extranet a web based portal through which the stream delivery is provisioned.

Each above described process preferably is implemented in computer software as a set of program instructions executable in one or more processors as a special purpose machine.

Representative machines on which the subject matter herein is provided may be Intel Pentium based computers running a Linux or Linux variant operating system and one or more applications to carry out the described functionality. One or more of the processes described above are implemented as computer programs namely as a set of computer instructions for performing the functionality described.

While the above describes a particular order of operations performed by certain embodiments of the invention it should be understood that such order is exemplary as alternative embodiments may perform the operations in a different order combine certain operations overlap certain operations or the like. References in the specification to a given embodiment indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic.

While the disclosed subject matter has been described in the context of a method or process the subject matter also relates to apparatus for performing the operations herein. This apparatus may be a particular machine that is specially constructed for the required purposes or it may comprise a computer otherwise selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including an optical disk a CD ROM and a magnetic optical disk a read only memory ROM a random access memory RAM a magnetic or optical card or any type of media suitable for storing electronic instructions and each coupled to a computer system bus. A given implementation of the present invention is software written in a given programming language that runs in conjunction with a DNS compliant name server e.g. BIND on a standard Intel hardware platform running an operating system such as Linux. The functionality may be built into the name server code or it may be executed as an adjunct to that code. A machine implementing the techniques herein comprises a processor computer memory holding instructions that are executed by the processor to perform the above described methods.

While given components of the system have been described separately one of ordinary skill will appreciate that some of the functions may be combined or shared in given instructions program sequences code portions and the like.

