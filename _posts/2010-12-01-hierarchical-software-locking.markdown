---

title: Hierarchical software locking
abstract: A processor chip may have a built-in hardware lock and deterministic exclusive locking of the hardware lock by execution units executing in parallel on the chip. A set of software locks may be maintained, where the execution units set and release the software locks only by first acquiring a lock of the hardware lock. A first execution unit sets a software lock after acquiring a lock of the hardware lock, and other execution units, even if exclusively locking the hardware lock, are unable to lock the software lock until after the first execution unit has reacquired a lock of the hardware lock and possibly released the software lock while exclusively locking the hardware lock. An execution unit may release a software lock after and while holding a lock of the hardware lock. The hardware lock is released when a software lock has been set or released.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08468169&OS=08468169&RS=08468169
owner: Microsoft Corporation
number: 08468169
owner_city: Redmond
owner_country: US
publication_date: 20101201
---
Computer software often runs in parallel on a given computer. For example a program may have multiple threads executing concurrently or in parallel. At times these threads may operate on shared data or hardware such as a memory block a register an object a device driver etc. To avoid data collisions and data corruption locks are used to allow one thread to lock the shared data. To share an object for example a group of threads may each have code that requires acquisition of a lock before accessing the shared object. When a thread has acquired the lock no other thread can acquire the lock and therefore the thread with the lock has exclusive and deterministic access and control of the shared object.

As processor chips have been built with increasing numbers of cores the need for efficient locking has increased. Such multicore processors have provided for cache coherency by which cores can deterministically share data. For example a chip may implement a cache coherency protocol to implement a coherency model. However as the number of cores on a single chip increases cache coherency schemes may not scale well and may become inefficient and complex. Yet it may not be practical to eliminate all forms of chip based or hardware based locking as parallelism may not be practicable defeating the purpose of multiple cores or sharing behavior may become non deterministic.

It may be desirable to provide locking without the use of complex cache coherency protocols possibly by using lightweight hardware based locking mechanisms. Techniques related to hybrid hardware software locking are discussed below.

The following summary is included only to introduce some concepts discussed in the Detailed Description below. This summary is not comprehensive and is not intended to delineate the scope of the claimed subject matter which is set forth by the claims presented at the end.

A processor chip may have a built in hardware lock and deterministic exclusive locking of the hardware lock by execution units executing in parallel on the chip. A set of software locks may be maintained where the execution units set and release the software locks only by first acquiring a lock of the hardware lock. A first execution unit sets a software lock after acquiring and while holding a lock of the hardware lock. Other execution units even if later exclusively locking the hardware lock are unable to lock the software lock until after the first execution unit has reacquired a lock of the hardware lock and released the software lock while exclusively locking the hardware lock. An execution unit may release a soft lock while holding a lock of the hardware lock. The hardware lock is released when a software lock has been set or released.

Many of the attendant features will be explained below with reference to the following detailed description considered in connection with the accompanying drawings.

Embodiments described below relate to software locking with minimal hardware support. New generations of multicore processor chips may have inefficient and complex hardware locking facilities or may have minimal rudimentary locking support. Techniques described below may implement software locks with access to software locks controlled by a hardware lock provided by a chip.

In operation a lock bit or other form of hardware lock may be used by a group of cooperating cores to prevent data collisions on shared data e.g. shared memory or a shared cache . The lock bit of a designated core in the group may by handshake or the like act as a group or master lock bit. When a first core in the group is to modify the shared data it first attempts to lock the group lock bit by issuing an atomic lock instruction implemented by the chip . The atomic lock instruction is guaranteed to either set the lock bit to locked e.g. set the value to 1 or fail. The atomic lock instruction is implemented such that for example when a core successfully locks the lock bit another core issuing the same instruction will not change the state of the group lock bit either one core or the other is guaranteed to successfully set acquire the lock and the other is guaranteed to fail. Note that cores are referred to only as examples of an execution unit threads or processes may also manipulated locks.

While the single lock bit or any other simple exclusive locking hardware is efficient and can be readily constructed this hardware approach may have limitations. The availability of only a fixed number of hardware locks may create bottlenecks or long waits to acquire locks when many threads are attempting to share many objects at the same time.

The locking facility may include a logic component that implements an application programming interface API or the like which is invoked by portions of the applications that need to lock shared data. The locking facility may also have data structure in memory that stores software locks see . The locking facility may also have an interface to the hardware locking of the multicore chip. For example the interface may have wrapper functions that wrap atomic locking instructions provided by the chip. Operation of the locking facility will be described further below. It should be noted that use of kernel or user space for different components is a design choice the example of is only one of many possible configurations. For example software locks may be stored modified etc. by user code but access to same may be managed by kernel level code. In another embodiment the entire scheme may be implemented in user space.

A user level kernel level split as mentioned above may also allow a limited amount of hardware resources to be safely shared by multiple applications. This isolation of trust can provide trust compartments. That is some embodiments can be used to allow mutually non trusted applications to implement an arbitrary number of software locks within each trust compartment. As the hardware locks can be managed by the operating system kernel one user level application does not need to rely on the correctness of another user level application with respect to hardware lock access.

The software locks may serve as locks for any programmatic objects. That is the software locks are used by the cores to control access to objects or other high level data structures e.g. an array of file descriptors a tree of floats etc. . When a thread for example is to access a shared object the thread first locks the lock data structure then acquires a software lock corresponding to the shared object releases the hardware lock and proceeds with the assurance that the shared object will behave deterministically while the software lock is held. Other threads lacking a lock of the shared object by convention do not access or modify the shared object i.e. the object is locked . Usually multiple different shared objects will not be mapped to the same software lock each unit of data to be locked has its own software lock. Software locks may be created and used as needed and without limit. Moreover the locking facility may maintain a mapping of software locks to shared objects. When a user application is to lock a shared object the application requests a lock of the shared object and the locking facility handles the details of identifying the corresponding software lock attempting to lock the hardware lock and checking the software lock.

As will be described below the data structure may be a hierarchy of software locks with some software locks such as software lock A having pointers to lower layers of the hierarchy. To acquire a software lock at a lower layer of the hierarchy the hardware lock is obtained and then software locks that point to the lower layers are tested and if available are set until the layer containing the desired software lock is reached. If a core or execution unit will be using many related software locks in a given layer those locks can be acquired by locking the software lock in the layer above that points to the given layer. For example if layer is to be locked by a process or core the hardware lock is acquired and then software lock A is acquired. When the hardware lock is then released the process retains the lock of layer and none of the software locks in that layer can be locked by another process thread core etc.

As can be seen from the processes of an extensible set of software locks can be maintained with a hardware supported guarantee of deterministic access to the software locks and consequently deterministic locking unlocking of the software locks. Furthermore because the hardware lock data structure may be locked only as long as needed to lock or unlock a software lock the hardware lock may have high availability i.e. a low duty cycle where locked time is small relative to unlocked time . At the same time the software locks have state that extends beyond the time when the hardware lock has been released.

