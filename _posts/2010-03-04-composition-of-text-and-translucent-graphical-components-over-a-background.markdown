---

title: Composition of text and translucent graphical components over a background
abstract: The present invention relates to methods and apparatus for the composition of text and translucent graphical components over a background. A compositor includes a color analyzer and a color selector. The color analyzer analyzes the colors of a graphical component and the color selector selects two or more colors over each of which the graphical component is rendered. A shader then completes the rendering of the graphical component by performing linear interpolations on the graphical component color, the background colors and a received background color.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08611646&OS=08611646&RS=08611646
owner: Google Inc.
number: 08611646
owner_city: Mountain View
owner_country: US
publication_date: 20100304
---
Modern personal computers use complex graphical systems with display tasks often being performed both by a central processing unit CPU and a graphical processing unit GPU . While basic display tasks may be performed by the CPU more complex graphical operations may be performed by the GPU with increased performance. Legacy applications however such as the Netscape Plug In Application Program Interface NPAPI may not be able to fully utilize the advanced graphics capabilities of the GPU. When the NPAPI is used in a modern web browser that uses a GPU to composite pages such as GOGGLE CHROME from Google Inc. of Mountain View Calif. decreased performance can occur. When using the NPAPI to display translucent graphical objects that are displayed in a web browser plug in the CPU must generally be supplied with a known background before rendering can occur. This requirement that the CPU wait for a background before rendering may cause latency in the display of certain graphical objects.

Another performance issue that can arise relating to CPU and GPU rendering involves the rendering of sub pixel anti aliased SPAA text over an unknown background. As with the display of plug ins above under traditional methods SPAA text must be rendered over a known background wherein if the background is not available SPAA processing can stall until the background is provided.

Accordingly what is needed are new methods and apparatus for the composition of translucent graphical components and SPAA text over a background.

Embodiments described herein relate to methods and apparatus for the composition of text and translucent graphical components over a background. According to an embodiment computer implemented method of displaying a graphical component is provided. The method includes analyzing the graphical component wherein at the time of the analyzing a background over which the graphical component is to be displayed is unknown. The method further includes creating a first and second version of the graphical component based on the analyzing and receiving an indication of the background over which the graphical component is to be displayed. The method further includes creating a third version of the graphical component based on the first version of the graphical component the second version of the graphical component and the background. Finally the method displays the third version of the graphical component over the background.

According to another embodiment a graphical component processor apparatus for compositing a graphical component over a background includes a color analyzer that receives and analyzes the graphical component wherein at the time of the analyzing the background over which the graphical component is to be displayed is unknown and a color selector that selects a first color and a second color based on the analyzing of the graphical component. The graphical component processor further includes a central processing unit CPU that receives the first color the second color and the graphical component. The central processing unit renders a first version of the graphical component using the first color and a second version of the graphical component using the second color. Upon the availability of a background over which the graphical component is to be composited a graphical processing unit GPU composites the graphical component using the first version of the graphical component the second version of the graphical component and the background.

Further features and advantages as well as the structure and operation of various embodiments are described in detail below with reference to the accompanying drawings.

Embodiments described herein relate to the composition of text and translucent graphical components over a background. Different approaches are described that allow embodiments for example to composite text and translucent graphical components over a background that is unknown at the time of the compositing.

While specific configurations arrangements and steps are discussed it should be understood that this is done for illustrative purposes only. As would be apparent to a person skilled in the art given this description other configurations arrangements and steps may be used without departing from the spirit and scope of the present invention. As would be apparent to a person skilled in the art given this description that these embodiments may also be employed in a variety of other applications.

It should be noted that references in the specification to one embodiment an embodiment an example embodiment etc. indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic. Moreover such phrases are not necessarily referring to the same embodiment. Further when a particular feature structure or characteristic is described in connection with an embodiment it would be within the knowledge of one skilled in the art given this description to incorporate such a feature structure or characteristic in connection with other embodiments whether or not explicitly described.

Web pages may be composed of overlapping elements. Some of the elements that comprise a web page may be translucent. For certain modem web browsers for example the GOOGLE CHROME browser it is desirable to use graphics processing unit GPU to composite the layers of a web page. This is because a GPU can perform the compositing task with less latency than a central processing unit CPU . In addition because a GPU can typically composite layers of a web page with higher throughput the GPU can also be relatively more power efficient which is important for applications executed on laptop and netbook computers.

NPAPI is an API that is commonly used to create plug ins for virtually all web browsers. Released in the 1990s this plug in API is commonly referred to as a legacy API meaning it is an older API that still continues to be used even though newer technology or more efficient methods are now available. One problem associated with legacy APIs is that they often were designed before modem technological advances were developed. For example a NPAPI generally cannot use a GPU to render and composite plug ins for display.

When the web browser requires an NPAPI plug in to render itself for example a web browser invokes a callback to NPAPI passing a device context DC . This device context DC is platform dependent and is used to define the attributes of text and images that are output to the screen. When the NPAPI uses the received DC it can determine the background upon which the plug in is to be rendered.

Through this device context the plug in using NPAPI can make regular calls to an operating system to render itself. For example to achieve the effect of translucency when rendering a translucent plug in a NPAPI can read back information from the device context to discover the colors of the pixels that have already been rendered for layers beneath it. Components that could have already been rendered underneath the plug in include regular HTML elements or other plug in instances. In GOOGLE CHROME for example these components may have been rendered and composited using a GPU.

In MICROSOFT WINDOWS from Microsoft Corp. of Redmond Wash. for example the DC used to service requests from a NPAPI is a Handle to the Device Context HDC in Microsoft Graphics Device Interface GDI . The NPAPI uses these GDI calls to determine the current background below the plug in for rendering.

For modem web browsers that composite pages using GPU the NPAPI approach to rendering plug ins is a less efficient design because the plug in must be rendered on the CPU before being later composited with other layers by a GPU. That is the translucent plug in cannot be rendered before the colors of the layers beneath it are known. With an unknown background when NPAPI attempts to read back the existing background pixels in order to render the plug in with a translucent effect the rendering stalls because the pixels are not yet available.

Because plug ins use a variety of third party code it is generally not possible to modify the plug in to bypass the above noted approach. For modem web browsers therefore a different approach to rendering plug in graphics is needed such approach working within the existing NPAPI rendering structure.

As used herein the term graphical component is used interchangeably with a plug in created with a NPAPI. Though embodiments described herein may be described with respect to a NPAPI the general approaches of embodiments may be applied to any graphical component displayed in similar circumstances. The term NPAPI will be used herein to refer generally to a legacy browser plug in API specifically one that does not support compositing a plug in using GPU . The NPAPI label is non limiting and as would be apparent to a person skilled in the art given this description other components modules APIs can also share the rendering limitations noted above with reference to NPAPI .

Computing device can be any commercially available and well known computer capable of performing the functions described herein such as computers available from International Business Machines Apple Sun HP Dell Compaq Digital Cray etc. Computing device also may be a mobile device or other mobile processing system such as a smartphones mobile phone or tablet personal computer.

The embodiment of system as depicted on is a solution to the rendering and compositing of legacy plug ins with reduced latency. One solution to NPAPI plug in rendering latency arrived at by the present Inventor is to use compositor CPU GPU and operating system . In one feature compositor processes legacy graphical components by receiving graphical component for rendering before the background color upon which graphical component is to be rendered is available from background source . In an embodiment graphical component is a plug in implemented with NPAPI .

Compositor then analyzes the graphical component and selects at least two background colors to use for the rendering of offline bitmaps. Graphical component and the offline bitmaps are analyzed and when the background becomes available GPU shader performs a linear interpolation to finalize the rendering such interpolation combining graphical component the offline bitmaps and the received background color.

Because a known background is not needed before rendering embodiments of this approach allow plug ins to be rendered earlier than traditional approaches. The earlier rendering may lead to increased graphical performance for the plug in. The specifics of embodiments of this process are described below along with a comparison to traditional approaches to plug in rendering.

Both timelines start at point with a request by web browser to the NPAPI to render graphical component . Upon receipt of a graphical component in embodiments color analyzer analyzes the component colors and color selector selects colors with which to render offscreen versions of graphical component as shown at point on . These background colors may or may not be selected based on the color of pixels in the graphical component. In embodiments the background colors are selected so as to be different from one another. In one example the background colors are selected so as to be maximally different from one another. As discussed further below having this difference allows later steps of embodiments disclosed below to have increased accuracy. This increased accuracy may be even more significant when background colors are selected that have a maximum or substantially maximum different from one another.

In an example embodiment the first color selected is solid black and the second color selected is solid white. In an embodiment color selector creates an offscreen bitmap for each color e.g. offscreen bitmaps A and B .

A problem can occur with embodiments if a plug in display changes in the time period between the rendering with the first background color Back and the second background color Back . Embodiments can avoid this problem by not providing the plug in with any other events between first and second background renders.

Though some embodiments described herein disclose the selection of two colors and two renderings by the CPU to address the above noted NPAPI latency this is non limiting. Any number of selected colors and renderings can be used by embodiments herein to perform the steps below.

One approach to the processing performed by compositor color analyzer and color selector as used by embodiments is determined with the equations detailed below. Embodiments use the following variables to implement processes described herein 

In the traditional approach using the equation below a plug in is set to render a pixel with color CP with a translucency T where T 0 would be completely transparent and T 1 would be completely opaque over a background color CB . In this traditional approach the background color CB is known at the time of plug in rendering and the GPU is not used for compositing. As would be apparent to a person skilled in the art given this description NPAPI could calculate the determined output color CD using the following equation 1 

This traditional process used by NPAPI to render graphical component by the CPU is shown on as occurring between points and . In an embodiment once the rendering of graphical component is completed by the CPU point the rendered graphical component is transferred to the GPU for compositing onto the display page. On conventional timeline this completion occurs at point . As would be apparent to a person skilled in the art given this description CPU does not have the rendering capacity of GPU and point on may take relatively more time than is depicted.

One aim of some embodiments described herein is to achieve substantially the same result but without knowing the color of the background CB e.g. before point on . Embodiments described herein can complete CPU rendering of the plug in at point as opposed to point for the traditional approach.

At point color analyzer analyzes the colors of graphical component and color selector selects two or more colors based on this analysis. As noted above these colors are selected to be maximally different from the color of graphical component and each other. One approach to this color selection used by embodiments uses the following equation 

In another embodiment the first background color Back is always black 0 and the second background color is always white 1 . As would be apparent to a person skilled in the art given this description different approaches exist for selecting colors maximally different from a given pixel color.

In an embodiment after color selector selects the colors for rendering point on and creates offscreen bitmaps A and B compositor sends graphical component to operating system along with the offscreen bitmaps for rendering as shown at point on . As would be apparent to a person skilled in the art given this description other techniques exist for performing this rendering function such as sending graphical component along with values corresponding to the selected colors.

Once graphical component and the two or more offscreen bitmaps e.g. and are received by operating system operating system renders offline versions of graphical component as depicted from points to on returning each version to compositor . In embodiments this rendering is performed by CPU using CPU rendering module . It is worth noting that as shown on on conventional timeline no rendering has been performed at a comparable point because the background available point has not occurred.

In an embodiment once graphical component has been rendered using the selected background colors as shown at point on the rendered versions e.g. rendered component A and rendered component B are sent back to compositor for further processing routing. In another embodiment these renditions are sent directly to another component e.g. GPU for further processing.

In embodiments when graphical component is to be composited on the GPU both renditions of the plug in are supplied as textures. In embodiments a pixel shader e.g. GPU shader is used to first estimate what translucency effect was intended by the translucency settings specified in graphical component the intended translucency of graphical component as shown on timeline as point . In other embodiments other components with shader functions could also perform this task.

One approach to determining the intended translucency of each pixel of graphical component as used by embodiments uses the following equation. Inputs to the equation include the color of the pixel CP the translucency or alpha coverage of the pixel T the selected color of the first background Back and the selected color of the second background Back . In the equations below two colors are determined C C based on the selected background colors Back Back 0 Back0 1 1 Back1 1 

As noted above embodiments described herein may always use black for the first background color Back 0 and white for the second background color Back 1 . In an example where black and white are used for Back and Back respectively the equations above simplify to the following equations 1 1 1 

As noted above with respect to color selector background colors are selected by embodiments to be maximally different from the other selected background and the color of graphics component color. In embodiments having this maximal difference increases the accuracy of the linear interpolation.

At point on the actual background CB becomes available from background source and the rendering process can proceed. In embodiments a second linear interpolation is used to complete the rendering. GPU shader performs a second linear interpolation using the above determined intended translucency values C C along with the actual background color CB and the two rendered versions of the plug in as shown at point on .

One approach to this second linear interpolation used by embodiments uses the following equation to linearly blend the determined intended translucency of the first background C the determined intended translucency of the second background C and the actual background color CB 1 1 0

As noted above embodiments described herein may always use black for the first background color Back 0 and white for the second background color Back 1 . In an example where black and white are used for Back and Back respectively the equation above simplifies to the following equation 1 

Portions of the approaches described above with embodiments of compositor also may also be used in embodiments to render sub pixel anti aliased SPAA text over an unknown background. depicts several examples of text rendering over a background. Text is non anti aliased text such text having obvious angular jagged edges where curves in the text are displayed. Text depicts SPAA text such text using variations in color channels sub pixels e.g. red green and blue to smooth the curves of the individual letters. As would be apparent to a person skilled in the art given this description SPAA text is generally rendered using a combination of the text color and the background color upon which it is to be displayed.

Under traditional approaches to SPAA when the background color is not known at the time the SPAA text is rendered as depicted in text a halo effect may be caused around text and the background upon which the text is rendered. This halo effect reduces or eliminates the advantages of the SPAA process.

Computing device can be any commercially available and well known computer capable of performing the functions described herein such as computers available from International Business Machines Apple Sun HP Dell Compaq Digital Cray etc. Computing device also may be a mobile device or other mobile processing system such as a smartphones mobile phone or tablet personal computer.

Broadly speaking in embodiments SPAA text processor analyzes and selects colors to allow the composition of SPAA text over a background that is unknown at the time of SPAA rendering.

Broadly speaking embodiments herein receive text analyze the text color select two or more background colors render the SPAA text over the two different selected background colors and have a shader approximate how the text should appear over a received third background color that was unknown at the time the text was originally rendered.

In an embodiment color analyzer can be used to analyze text colors and convey information to color selector . Based on the information from color analyzer two background colors are chosen by color selector as shown on point on .

Because SPAA uses all three color channels sub pixels for the anti aliasing process embodiments described herein analyze select and determine colors using three channel color vectors e.g. color R G B . Embodiments described below will use each channels having a value from zero 0 to one 1 wherein zero corresponds to black and one corresponds to full presentation of the color channel.

One approach to analyzing and selecting colors used by embodiments of color analyzer and color selector is to consider each channel separately in a three part conditional. In an example analysis and selection equation the following variables are used 

In embodiments the background colors are selected so as to be maximally different from one another. As discussed further below having this broad difference allows the later steps disclosed to have increased accuracy. An embodiment uses the following logic to approximate these determinations for each channel. The red channel is described below for example but the same logic is used to select the green and blue channels 

The same determinations from table are performed independently for the green and blue channels. Based on the determination approach shown above regardless of the RT value the first background color will be darker than the second background color. Description of the approach shown in Table is not intended to limit the scope of potential embodiments rather it is illustrative of an approach that a person skilled in the art and familiar with the teachings herein could use to select appropriate background colors for further processing by embodiments described herein.

Using the above example approach a text color of black TextV 0 0 0 would yield grey BackV 0.5 0.5 0.5 as a first background color and white BackV 1 1 1 as a second background color.

In an embodiment once the first background color and the second background color are selected offscreen bitmap A is cleared to a color corresponding to BackV and offscreen bitmap A is cleared to a color corresponding to BackV. These bitmaps may be managed within the compositor component as shown in or within any other type of storage.

Embodiments described herein do not perform the actual anti aliasing of the text rather the colors are selected and a request is made to an external component e.g. SPAA component to perform the SPAA as shown at point on . Other embodiments could include a SPAA function within compositor .

In an embodiment the SPAA process is performed by operating system executed by CPU . As would be apparent to a person skilled in the art given this description one example of a SPAA component is a CLEARTYPE processing module from Microsoft Corp. of Redmond Wash. CLEARTYPE is a feature of Microsoft GRAPHICS DEVICE INTERFACE MS GDI . Progammatic access to the CLEARTYPE SPAA in Microsoft WINDOWS operating system can be performed by application programming interface API calls to the MS GDI. Other programmatic approaches exist in WINDOWS as well as other operating systems . Embodiments described herein could use various types of SPAA component .

In an embodiment offscreen bitmap A is submitted along with text color and text to SPAA component and rendered text A is received back. Similarly in an embodiment offscreen bitmap B is submitted along with text color and text to SPAA component and rendered text B is received back. Text color could be submitted in any form required by SPAA component and could be submitted once instead of twice as described above. In embodiments SPAA component may transfer the above noted rendered text directly to GPU for further processing described below.

In an embodiment rendered text A and B are SPAA output from SPAA component . Rendered text A is text SPAA rendered over the first background color BackV in offscreen bitmap A and rendered text B is text SPAA rendered over the second background color BackV in offscreen bitmap B . In embodiments the pixel color values returned from SPAA text rendering over the first background BackV and the second background BackV are C and C respectively.

As would be apparent to a person skilled in the art given this description in some cases when SPAA processes are applied to text the width of the lines that compose the text are dependent on both the color of the text and the color of background it is SPAA rendered over. In an embodiment by performing the steps described above operating system chooses the width of the lines and other properties of the rendered text according to its own rules based on the text text color and the submitted background colors BackV and BackV in offscreen bitmaps A and B respectively .

For further processing embodiments take the SPAA results from the previous step and perform a normalization step. SPAA component does not necessarily return SPAA results as a vector with coverage for each color channel. Embodiments described herein use a normalization step to determine per channel values for the SPAA results for subsequent processing as shown at point on .

As would be apparent to a person skilled in the art given this description this normalization step is different from some traditional approaches to SPAA which use a single coverage for the whole pixel. Embodiments described herein treat each color channel a spatially separate subpixel independently for processing.

To provide these per channel values embodiments normalize each pixel of rendered text A and rendered text B to estimate the coverage for each color channel. In embodiments CON R G B is a vector of coverage values for a single pixel that is the result of SPAA of text color vector T R G B over the first background color and CN R G B is a vector of coverage values for a single pixel that is the result of SPAA of text color vector T R G B over the second background color.

The normalization process described above may be performed by SPAA component before the rendered text is sent or this normalization may be performed in GPU by GPU shader along with the steps detailed below. Embodiments may perform this normalization step in either GPU shader or SPAA component depending on which solution yields better performance at the time. As would be apparent to a person skilled in the art given this description in embodiments other components may perform this normalization step. Additional variables are used with the variables described above in subsequent processing 

The following details an example of an approach to per channel normalization that is performed by embodiments 

After the normalization step the GPU shader now has per channel coverage values CN CN for the text as though it was rendered over the offscreen background colors BackV and BackV.

At point on the actual background CBV becomes available from background source and the rendering process can proceed. Starting at on the GPU shader does a linear interpolation between the two selected background colors BackV and BackV and the actual received color CBV . In the embodiment the shader determines what combination of the two colors most closely resembles actual background color

Because the SPAA text uses all three channels of the pixels that represent each letter in an embodiment this approximation is performed on all three of the color channels separately. In one embodiment using the first linear interpolation the following equation represents an approximation of the coverage A R G B as though rendered over color CBV R G B 

A R G B is a vector with per channel coverage values used to blend the text color TextCV R G B with the background color CBV R G B .

In an embodiment once the coverage value for each color channel A R G B has been selected a second linear interpolation is performed by the shader. This second linear interpolation uses the determined coverage values for each channel A R G B and applies them to each channel of each of the text color TextCV R G B . An example equation for performing this second linear interpolation is as follows 

After GPU shader completes ifs linear blend as shown at point on CDV R G B represents the final color of an individual pixel with text color TextCV R G B as if it were originally rendered over the actual background CBV R G B .

The process above can be applied by embodiments to non translucent SPAA text. Translucent SPAA text can be rendered using substantially the same process by scaling down coverage A before calculating CDV. If the translucency factor is T then the following equation would determine the determined color produced by applying coverage values with translucency to each color channel of the SPAA text Text 1 

Systems and and associated modules stages processes and methods described in embodiments described herein for processing text and graphics may be implemented by software firmware hardware or a combination thereof. Hardware software or any combination of such may embody any of the depicted components in and any stage in .

If programmable logic is used such logic may execute on a commercially available processing platform or a special purpose device. One of ordinary skill in the art may appreciate that embodiments of the disclosed subject matter can be practiced with various computer system configurations including multi core multiprocessor systems minicomputers mainframe computers computer linked or clustered with distributed functions as well as pervasive or miniature computers that may be embedded into virtually any device.

For instance at least one processor device and a memory may be used to implement the above described embodiments. A processor device may be a single processor a plurality of processors or combinations thereof. Processor devices may have one or more processor cores. illustrates an example computer system in which embodiments described herein or portions thereof may be implemented as computer readable code. For example compositor of carrying out stages of method of and system of carrying out stages of method of may be implemented in computer system . Various embodiments described herein are described in terms of this example computer system . After reading this description it will become apparent to a person skilled in the relevant art how to implement the invention using other computer systems and or computer architectures. Although operations may be described as a sequential process some of the operations may in fact be performed in parallel concurrently and or in a distributed environment and with program code stored locally or remotely for access by single or multi processor machines. In addition in some embodiments the order of operations may be rearranged without departing from the spirit of the disclosed subject matter.

Computer system includes one or more processor devices such as processor device CPU and GPU . Processor device may be a special purpose or a general purpose processor device. As will be appreciated by persons skilled in the relevant art processor device may also be a single processor in a multi core multiprocessor system such system operating alone or in a cluster of computing devices operating in a cluster or server farm. Processor device is coupled to a communication infrastructure for example a bus message queue network or multi core message passing scheme.

Computer system also includes a main memory for example random access memory RAM and may also include a secondary memory . Secondary memory may include for example a hard disk drive and or a removable storage drive . Removable storage drive may comprise a floppy disk drive a magnetic tape drive an optical disk drive a flash memory or the like. The removable storage drive reads from and or writes to a removable storage unit in a well known manner. Removable storage unit may comprise a floppy disk magnetic tape optical disk etc. which is read by and written to by removable storage drive . As will be appreciated by persons skilled in the relevant art removable storage unit includes a computer usable storage medium having stored therein computer software and or data.

In alternative implementations secondary memory may include other similar means for allowing computer programs or other instructions to be loaded into computer system . Such means may include for example a removable storage unit and an interface . Examples of such means may include a program cartridge and cartridge interface such as that found in video game devices a removable memory chip such as an EPROM or PROM and associated socket and other removable storage units and interfaces which allow software and data to be transferred from the removable storage unit to computer system .

Computer system may also include a communications interface . Communications interface allows software and data to be transferred between computer system and external devices. Communications interface may include a modem a network interface such as an Ethernet card a communications port a PCMCIA slot and card or the like. Software and data transferred via communications interface may be in the form of signals which may be electronic electromagnetic optical or other signals capable of being received by communications interface . These signals may be provided to communications interface via a communications path . Communications path carries signals and may be implemented using wire or cable fiber optics a phone line a cellular phone link an RF link or other communications channels.

In this document the terms computer program medium and computer usable medium are used to generally refer to media such as removable storage unit removable storage unit and a hard disk installed in hard disk drive . Computer program medium and computer usable medium may also refer to memories such as main memory and secondary memory which may be memory semiconductors e.g. DRAMs etc. .

Computer programs also called computer control logic are stored in main memory and or secondary memory . Computer programs may also be received via communications interface . Such computer programs when executed enable computer system to implement the embodiments as discussed herein. In particular the computer programs when executed enable processor device to implement the processes of embodiments such as the stages in the method illustrated by flowchart of discussed above. Accordingly such computer programs represent controllers of the computer system . Where embodiments are implemented using software the software may be stored in a computer program product and loaded into computer system using removable storage drive interface hard drive or communications interface .

Embodiments may also be directed to computer program products comprising software stored on any computer useable medium. Such software when executed in one or more data processing device causes a data processing device s to operate as described herein. Embodiments can employ any computer useable or readable medium. Examples of computer useable mediums include but are not limited to primary storage devices e.g. any type of random access memory secondary storage devices e.g. hard drives floppy disks CD ROMS ZIP disks tapes magnetic storage devices and optical storage devices MEMS nanotechnological storage device etc. .

Embodiments described herein provide methods and apparatus for the composition of text and translucent graphical components over a background. The summary and abstract sections may set forth one or more but not all exemplary embodiments of the present invention as contemplated by the inventors and thus are not intended to limit the present invention and the claims in any way.

The embodiments herein have been described above with the aid of functional building blocks illustrating the implementation of specified functions and relationships thereof. The boundaries of these functional building blocks have been arbitrarily defined herein for the convenience of the description. Alternate boundaries may be defined so long as the specified functions and relationships thereof are appropriately performed.

The foregoing description of the specific embodiments will so fully reveal the general nature of the invention that others may by applying knowledge within the skill of the art readily modify and or adapt for various applications such specific embodiments without undue experimentation without departing from the general concept of the present invention. Therefore such adaptations and modifications are intended to be within the meaning and range of equivalents of the disclosed embodiments based on the teaching and guidance presented herein. It is to be understood that the phraseology or terminology herein is for the purpose of description and not of limitation such that the terminology or phraseology of the present specification is to be interpreted by the skilled artisan in light of the teachings and guidance.

The breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the claims and their equivalents.

