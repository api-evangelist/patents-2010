---

title: Techniques for supporting multiple devices in mobile applications
abstract: Techniques for interacting with a client process on a mobile device connected to a network over a wireless link includes managing information at a mobile applications server executing on a platform connected to the network. The information includes device profile information about the mobile device. First data is received from an application. The first data describes graphical elements for display on the mobile device. It is determined whether the first data exceeds a capacity of the mobile device based on the device profile information. If it is determined that the first data exceeds the capacity, then a subset of the first data is formed that does not exceed the capacity of the mobile device. The subset of the first data is sent to the client process. If it is determined that an external converter does not convert using a particular format, then a first description of graphical elements is converted internally into a second description using the particular format. Second data including the second description is sent to the client process. These techniques allow network-based services to be made readily available to a wide range of mobile devices without having to explicitly program each application for providing one or more network-based services to support all forms of mobile devices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08700993&OS=08700993&RS=08700993
owner: Oracle International Corporation
number: 08700993
owner_city: Redwood Shores
owner_country: US
publication_date: 20101206
---
This application is a divisional application of U.S. application Ser. No. 12 119 376 which is a continuation of U.S. patent application Ser. No. 09 872 566 filed May 31 2001 now U.S. Pat. No. 7 373 422 issued May 13 2008 which is incorporated herein by reference as if fully set forth herein under 35 U.S.C. 120 

which claims priority to U.S. provisional application Ser. No. 60 222 817 filed Aug. 4 2000 entitled Techniques for Implementing Mobile and Industrial Database Applications by Jyotirmoy Paul Jeff Barton Anit Chakraborty and Siva Dirisala hereby incorporated by reference in its entirety and

which also claims priority to and is a Continuation In Part of U.S. application Ser. No. 09 631 884 filed Aug. 4 2000 now U.S. Pat. No. 7 200 809 issued Apr. 3 2007 entitled Multi Device Support for Mobile Applications Using XML by Jyotirmoy Paul Jeff Barton Anit Chakraborty and Siva Dirisala hereby incorporated by reference in its entirety.

This application is related to U.S. patent application Ser. No. 09 872 066 filed May 31 2001 now U.S. Pat. No. 7 188 183 issued Mar. 6 2007 entitled Maintaining State Information in Mobile Applications by Jyotirmoy Paul Jeff Barton Anit Chakraborty and Siva Dirisala.

This application is related to U.S. patent application Ser. No. 09 872 986 filed May 31 2001 now U.S. Pat. No. 7 051 080 issued May 23 2006 entitled Techniques for Navigating in Mobile Applications by Jyotirmoy Paul Jeff Barton Anit Chakraborty and Siva Dirisala.

This application is related to U.S. patent application Ser. No. 09 872 978 filed May 31 2001 now U.S. Pat. No. 7 013 329 issued Mar. 14 2006 entitled Techniques for Programming Event Driven Transactions in Mobile Applications by Jyotirmoy Paul Jeff Barton Anit Chakraborty and Siva Dirisala.

The present invention generally relates to network based services for mobile wireless devices. The invention relates more specifically to providing each network based service for a wide variety of mobile wireless devices.

Society is becoming increasingly reliant on network based services. Network based services are any services provided to devices over a network. Common network based services include for example services provided over the World Wide Web database services etc.

Services provided over the World Wide Web are typically presented in the form of one or more web pages. A web page is data expressed in a HyperText Markup Language HTML and transferred over a network using the hypertext transfer protocol HTTP of the Internet protocol JP . The network can be a local network a wide area network or the Internet itself a public network of computer networks.

Database services may be provided by a database application which in turn may access a database through services provided by a database server. A database application is a software application that communicates with a database server process on the network to store data into and retrieve data from a database.

According to the Internet protocol IP a program on one device connected to the network interacts with another program located on another device with asynchronous stateless messages. The two programs run independently and interact only through these messages. The messages are asynchronous in that each can take an arbitrary amount of time to travel from source device to destination device. Consequently two successive messages may arrive out of order. The messages are stateless in that each message is sent transmitted and received independently without inheriting or relying on characteristics from any previous messages sent.

The program that initiates the communication is a client process and the program that waits for and responds to a request from the client process is the server process. The term client is often used to refer to either the client process or the machine on which the client process runs or both. The term server is similarly used to refer to either the server process or the machine on which the server process is executing or both.

A widely used client process supported by many servers on the Internet is a browser. A browser communicates with servers to retrieve and decode data expressed in HTML. HTML marks portions of the data with tags related to the manner in which the portions are to be displayed.

Adding programs referred to as plug ins to a browser can extend a browser s functionality. A browser that has added functionality due to one or more plug ins is referred to herein as an extended browser. Extended browsers may for example use input forms into which the user can enter data that is validated in some regard before being sent back to the server. Standard HTML does not provide for this client side validation process.

Portable devices capable of wireless communications are finding ever more uses and popularity. Some of these mobile devices are able to connect to a network. It is desirable to make network based services available for access by such network capable mobile devices.

When making network based services available for mobile devices one cannot count on the ability to use software designed for a general purpose computer. The smallest laptops are too cumbersome for some uses such as for wireless telephony and for warehouse inventory control. Handheld devices used by agents of an enterprise in the field for these uses have limited hardware and software due to constraints imposed by limited size and low power availability.

For example screen size memory and plug in functionality on the handheld device may be significantly less than what is available through a browser on a laptop so that a Web page easily viewed on a low end laptop is essentially unintelligible on the mobile device. A network based service cannot rely on a particular mobile device having a screen of a needed size or having the power to execute a full browser or to accept plug ins such as those that allow the browser to use forms.

Some of these small footprint handheld devices may not run a World Wide Web browser at all. For example mobile telephones use a wireless application protocol WAP which does not respond to the full set of HTML tags. These devices use data presented in a wireless markup language WML a specific implementation of the extensible markup language XML using a WML specific document type definition DTD . Other handheld devices used in industry such as bar code readers communicate with a network using a teletype protocol Telnet which accepts or sends one character at a time with little or no display options such as font size font type italics and color and without the capability for displaying images.

Unfortunately conventional approaches for communicating information to a device are not always suitable when the transaction involves a mobile device. For example a mobile device running the WAP protocol has the capacity only for a limited amount of information in each page of information received. Specifically in most mobile telephones a page is limited by a maximum of about 1500 bytes a byte is 8 binary digits and usually represents one character of text . In such a WAP device an entire page of information sent by an application exceeds the capacity of the mobile device.

Because there is a wide variety of mobile devices with a wide range of screen sizes colors memory sizes page buffers processor types and client protocols among other properties it is generally cost prohibitive to try to duplicate all the functionality of a network based service for each possible mobile device.

Based on the foregoing there is a clear need for techniques that allow network based services to be made readily available to a wide range of mobile devices or to support complex transactions or both without having to explicitly program each network based service to support all forms of mobile devices.

Techniques are provided for interacting with a client process on a mobile device connected to a network over a wireless link. According to one aspect of the invention the techniques include managing information at a mobile applications server executing on a platform connected to the network. The information includes device profile information about the mobile device. First data is received from an application. The first data describes graphical elements for display on the mobile device. It is determined whether the first data exceeds a capacity of the mobile device based on the device profile information. If it is determined that the first data exceeds the capacity then a subset of the first data is formed that does not exceed the capacity of the mobile device. The subset of the first data is sent to the client process.

According to another aspect of the invention techniques include managing information at a mobile applications server executing on a platform connected to the network. The information includes data indicating a particular data format for communicating with the mobile device. First data is received from the client process. The first data includes a first description of a graphical element for display on the mobile device. The first description uses a first format different than the particular format. It is determined whether an external converter converts from the first description to a second description using the particular format. If it is determined that the external converter does not convert using the particular format then the first description is converted into the second description using the particular format. Second data including the second description is sent to the client process.

According to an embodiment of this aspect if it is determined that the external converter converts to the second description using the particular format then the first data is sent to the external converter.

These techniques allow network based services to be made readily available to a wide range of mobile devices without having to explicitly program each application for providing one or more network based services to support all forms of mobile devices.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

To illustrate network applications interacting with mobile devices employing a wireless link consider . is a block diagram that illustrates one embodiment of a mobile applications server connected to a network with which a mobile device communicates over a wireless link .

The mobile device includes a screen display one or more keys and a client process running on a microprocessor not shown in the mobile device . Some mobile devices may include a sensor such as a microphone or barcode reader. The mobile device communicates with a base station using a wireless link that may be proprietary. Examples of wireless links include a local radio frequency link such as IEEE 802.11 a wide area radio frequency link a satellite link and a personal communication services PCS data link through a WAP Gateway.

The base station is connected to the network . The base station passes network message traffic between the client and the servers on the network . The network may be any network using an asynchronous stateless protocol like TCP IP including a local network a private wide area network or the Internet.

The mobile applications server includes one or more processes executing on a machine connected to the network . According to one embodiment the mobile applications server provides functionality for the mobile device beyond the functionality built into the processor and client on board the mobile device itself.

In one embodiment the mobile applications server provides one or more applications that may be used by a mobile device over the network . For example assume that mobile device is a device having a barcode reader as the sensor . Such a device may be used in conjunction with an inventory application to update an inventory database. The update may be performed by scanning the barcode on an item and pressing a key to indicate whether the item is being added to the inventory or is being removed from the inventory due to damage due to sale or due to transport to another warehouse.

For another example a database application for mobile device having a microphone such as a mobile phone could identify the user of the mobile device based on a comparison of the user s voice with a voice print for the user. The voice print may be maintained in a database by a database server on the same platform as the mobile applications server or some other server platform on the network .

The mobile applications server may also provide non database applications. For example if the sensor is a global positioning system GPS then the mobile application could compute the area walked off by a user carrying the mobile device based on positions output from the sensor and transmitted to the mobile applications server .

According to several embodiments applications on mobile applications server interact with mobile device through a mobile interactions server in the applications layer. The network device on which mobile applications server executes also includes processes that execute in a network layer a transport layer and a security layer that are not significantly modified by the invention and are not described further.

Referring to mobile applications server is one or more processes executing on a computing device connected to the network that provides services for a mobile device in response to one or more requests for services from the client process executing on the mobile device .

Mobile applications server includes one or more applications . In general an application is a set of instructions that can be called to cause one or more processors to perform a series of related tasks for providing a requested service. An application often requires input data and produces output data. An application often comprises one or more methods that can be invoked separately each with their own input and output.

Many ways of producing applications are known in the art. For example in one embodiment the application is a package of JAVA classes containing public methods that can be invoked separately by the name of the method and the name of the class. Input for each public method is provided as one or more data structures called parameters and output is provided as a returned data structure. The names of the public methods and the names and definitions of the input and returned data structures are published as an application programming interface API . In another embodiment the application is a library of methods created in another language that also has a published API. In still other embodiments the application is a compiled program executed by a command line in the operating system language for the platform on which the applications reside. The compiled program operates on input in data files or on an input stream and produces output in data files or on an output stream all defined in the operating system language. In yet other embodiments the application is a script in the operating system language that executes several compiled programs in sequence.

Each application of the mobile applications on the mobile applications server provides functionality for mobile devices. As described in the background section different mobile devices may have different characteristics. For example different devices may communicate on the network through their base stations with different protocols e.g. WAP HTTP Telnet may have different keys and sensors and may have different screen sizes different memory capacities and different processing power. Such differences in characteristics complicate obtaining input for the application and presenting output from the application. These applications are special in that they communicate with the mobile device through a mobile interactions server described next in a manner that does not require developers of the application to address specific characteristics of the individual mobile device .

The mobile applications server includes the mobile interactions server that provides data or methods or both for obtaining input data from the mobile device for presenting output data at the mobile device and for managing the data communicated with the mobile device. The mobile interactions server receives requests from the client process through the mobile device base station and returns responses to the client process through the base station . The mobile interactions server also passes data to the applications involved causes methods of the applications involved to be executed and receives any output from the applications for the mobile device . The mobile interactions server thus operates to intercede between the application and the mobile device to insulate the application from dealing with specific characteristics of individual mobile devices.

In the embodiment of the mobile interactions server generates additional components at runtime in response to an initial request from the client process . These additional components include a listener a state machine and a state information database . The listener is a process launched by the mobile interactions server . The listener monitors a port associated with input having a particular protocol e.g. HTTP WAP or Telnet on the mobile applications server. The listener acts in response to requests received from a client process on the port and causes data to be sent back to the client process over the network.

In the embodiment depicted the listener produces descriptions in the extensible Markup Language XML of graphical elements for display on the screen of mobile device which are sent to a conventional XML converter described below. When monitoring some ports however the listener does not send an XML document. Instead the listener produces a response for the mobile device in the protocol used by the base station . For example when listening on a Telnet port the listener produces a response using the Telnet protocol. In this case the response is sent to the base station via the network and bypasses the conventional XML converter . If the response produced by the listener for the client process uses the methods of an application or information from previous requests and responses then the listener causes a method of a state machine to be executed and the listener bases the response for the client process on the data returned from the state machine .

The state machine is a process that is launched by the listener. In some embodiments the state machine is a library of methods invoked as controlled by the listener . In other embodiments the state machine is a background process that executes in parallel waiting for a particular message upon which to act. The state machine receives data from the listener based on requests from the client process and returns responses to the listener for the client process. The state machine also determines which methods of which applications are involved and causes the involved methods to be executed.

The state machine also manages information about multiple requests and responses involving the client process for each client process communicating over the port. The state information database is persistent storage for the information managed by the methods of the state machine for the client process during the client communication session with the mobile interactions server. Thus the state machine and state information database enable applications to perform complex transactions in which a response passed to the client in response to a request contains or depends on information carried in a previous request or response. In some embodiments the state information database survives for a limited time after communication with the client terminates in case the break in communications is an unintentional interruption. If the client reestablishes communication within the limited time then the state machine method invoked by the listener to commence a session with the client identifies the existing state information database for the client and employs the existing database instead of creating a new one.

The mobile applications server also includes a conventional XML converter process which translates descriptions in the extensible Markup Language XML of graphical elements for display on the screen of mobile device to descriptions used by the base station for several protocols. Conventional XML converters use an extensible Stylesheet Language XSL to translate from XML to any of several markup languages used by a variety of base stations. However there is not a standard markup language for Telnet devices and conventional XML converters do not translate XML descriptions into a markup language for Telnet. In an alternative embodiment shown in the listener produces Telnet protocol responses that are sent to the network bypassing the conventional XML converter .

For example the data from the state machine indicates a menu of 10 items but the screen of the particular mobile device has only five lines. The device sensitive presentation manager receives data indicating the menu with the ten items determines that the mobile device has a display screen that only shows five lines and reformats the data to send one of three subsets of the data each subset indicating five lines of graphical display or less. For example the first subset of data indicates four menu items for the first four lines and a button labeled next items for the fifth line. The second subset of data indicates three menu items for the middle three lines a button labeled prey items for the first line and a button labeled next items for the fifth line. The third subset of data indicates a button labeled prey items on the first line followed by the last three menu items on the next three lines.

In the illustrated embodiment the information particular to a mobile device comes from a device profile database holding information about the characteristics of mobile devices. In other embodiments the information comes from prompting the mobile device for its characteristics and obtaining an answer in a process called negotiating. In some embodiments the process is performed by invoking a method in a library of methods in another embodiment the process executes in the background waiting for input from the listener.

In the illustrated embodiment the output from the device sensitive presentation manager is in XML which is used as a common markup language relatively easily converted to device specific protocols. In another embodiment a different markup language is used as the common markup language.

Listener also includes an internal XML to protocol converter . The internal converter is a process that receives data in XML and converts it to a protocol used by the base station of the mobile device . Some protocols use data in mark up languages produced by an external conventional XML converter . For these protocols the internal XML to protocol converter sends the XML data to the external conventional XML converter with little or no change as shown in by arrow . The external XML converter uses XSL to produce different markup languages tailored to types of mobile device and sends data in these markup languages over the network as shown in by arrow . The external XML converter produces various versions of HTML for HTTP clients like web browsers a Handheld Device Markup Language HDML for some devices a markup language for voice capable gateways VoxML and various versions of WML such as for ERICSSON and NOKIA 7110 devices. An Example of a conventional XML converter suitable for the external converter is PORTAL TO GO of the ORACLE Corporation.

For other protocols for which there is not a standard markup language the internal XML to protocol converter performs parsing of the XML data and converts the data to messages that follow the protocol. For example for the Telnet protocol the internal XML to protocol converter determines which XML elements are displayed on the next line and sends the contents of those elements character by character to the base station as dictated by the Telnet protocol. These Telnet responses are not sent to the external conventional XML converter but are sent directly to the network as indicated by arrow in for the base station bypassing the external conventional XML converter . This internal XML to protocol converter is especially useful with industrial devices for example with industrial bar code readers used on the floor of a warehouse or factory which communicate with an inventory database application over a local area network using the Telnet protocol.

According to the present invention the applications communicate indirectly with the mobile devices through the mobile interactions server using data that describes one or more graphical elements that may be displayed on the screens of the mobile devices and may be associated with actions by a user of the mobile device such as moving a cursor and pressing a key. Several types of known graphical elements are associated with known actions by a user who manipulates a cursor on the screen of the mobile device and coordinates the use of one or more keys on the mobile device. Among the known graphical elements are a text field a button a check list a set of radio buttons and a pull down menu also called a popup menu . According to the disclosed techniques the application employs these graphical elements and others to prompt for and obtain a series of inputs from a user of the mobile device in order to conduct a complex transaction. The techniques allow an application designer to include graphical elements without the application designer providing the details of how the graphical elements are communicated to the mobile device or how much information is stored on the mobile device.

For example an application can be built to allow a mobile telephone user to search for a name in a telephone directory maintained in a telephone directory database by a third party and to download the name and number to the mobile telephone s speed dial list maintained in persistent memory on the mobile telephone. The application constructs a first set of graphical elements for the mobile telephone to prompt the user of the telephone to input each character of the name being searched for. This set of graphical elements used together is called a page. The application uses the name input by the user to construct a query to send to the third party database to obtain a list of names and numbers that match the name being searched for. The application then constructs another page of one or more graphical elements to present the one or more resulting names and prompt for the user to select one or more. In response to further user action the application then constructs another page of graphical elements to prompt the user to indicate whether the selected names should be added to the speed dial directory or dialed or ignored. Based on the response the application issues a command that causes the telephone to add the numbers to the telephone s speed dial directory or to dial a selected one number or to simply end the application. According to the techniques described below this application can employ all the graphical elements needed without dealing with the details of the protocol to communicate with the device or how the graphical element is rendered on the screen of the mobile device or maintaining all the user inputs in persistent storage.

The fundamental building block for a graphical user interface for interacting with a user of the mobile device is the graphical element. A page is constructed of one or more graphical elements that are intended to be used together by a user of the mobile device. An application is built of one or more pages. When a user first requests services from the mobile applications server the user is presented with a main menu including a menu item for each selectable application on the mobile applications server. When the user selects one of the menu items the user is presented with the first page of the corresponding application.

The graphical element and the page and the menu item are implemented as objects in an object oriented language like JAVA . In object oriented implementations an object is a data structure that is a particular instance of a data structure type defined in a class. The objects are said to be instantiated from the class. The class defines the attributes and methods for all the objects in the class. While all objects instantiated from the same class have the same attributes the values that those objects store for those attributes may vary from object to object. Furthermore an attribute may be defined to refer to an object of a second class so that the value this attribute takes is an object of the second class. Classes can inherit some or all of their attributes and methods from other classes which themselves may inherit attributes and methods from other classes. In JAVA the classes form a hierarchy and a class can only inherit from classes above them in the hierarchy to avoid cyclic inheritance. In JAVA several classes are stored together in a package. Each class in the package has a unique name and the names together constitute a namespace.

According to the object oriented implementation a menu item object corresponding to the application includes one or more page objects as attribute values and each page object includes one or more field objects as attribute values. A field object corresponds to a graphical element.

A bean is a class of objects with at least a minimum set of attributes and methods including a bean name and a method for listing the attributes i.e. properties and attribute values of each object. This method gives the bean class the behavior of introspection. In one embodiment the bean class methods includes a method for setting a value for an attribute of the object and a method for getting the value of the attribute. These methods give the bean class the behavior of persistence and by providing a standard format for storing and retrieving information give the bean class the behavior of serialization. In this embodiment the methods provide the functionality to store and retrieve the attributes and attribute values of instances of the bean class or of instances of classes that inherit from the bean class.

In another embodiment the bean class includes a vector of event handling methods. An event is an object generated by a listener in response to a message from a client process. Different listeners produce different event types. The event received from the listener is the input parameter for the event handler corresponding to the event type. The vector of event handlers in the bean class handle events in response to a user of the mobile device activating a control of the mobile device such as by pressing a key of the mobile device using a pointing device on the mobile device or turning on the sensor . In some embodiments event handling methods are implementations of interfaces for handling event objects. An interface is data that defines the name for a method and the names of the parameters used as input to the method and the class of the objects used as values for the parameters and the class of the object returned if any. The class is often identified by the name of the class the name of the class of which an object is an instance is also called the type of the object. An implementation of an interface provides the instructions to use the parameters to produce the returned value.

A JavaBeans class is a commercially available published bean class including methods for providing introspection persistence and event handling.

According to the present disclosed techniques mobile applications beans are provided to an application developer and used in the application. A mobile applications bean is a class that inherits the attributes attribute values and methods of a bean class and extends them for describing a graphical element a page or an application menu item. The mobile applications bean extends the bean class by providing an additional one or more attributes or by replacing one or more methods or by adding one or more methods or interfaces or by some combination of these changes. A menu item bean is a mobile applications bean extended to provide the attributes and methods used when an application is invoked or launched and when the application terminates. A page bean is a mobile applications bean extended to provide the attributes and methods used when a page is entered and exited. A field type bean class is a mobile applications bean class extended for each graphical element. A different field type bean class is defined for each of the known graphical elements used to interact with a user of a mobile device. For example a field type bean class is defined for a text field a button a radio button a checklist a list and a list of selectable values as described in more detail below.

The mobile applications bean includes a method for generating an XML document that describes the graphical element to be displayed on a screen of the mobile device to represent an object of the mobile applications bean. An XML document that describes a graphical element for display on a variety of mobile devices is described in more detail in the related application incorporated by reference in its entirety above.

The mobile applications bean includes a method for handling an event generated by a listener when a graphical element corresponding to the bean is involved in an action by the user of the mobile device. For some mobile applications beans this method is just an abstract method naming the method and the parameters and the parameter types and including a return statement to end the method but not performing any significant functions. The event handling method is to be written by the application programmer when the application is built in order to have the event handling method perform the desired tasks of the application as described with an example below. The mobile applications beans include default event handlers for all events generated by the mobile interactions server. In addition a set of event handlers corresponding to a limited set of predefined events is defined in a mobile applications interface so that the application developer can provide the instructions to execute upon occurrence of one of the predefined events. The predefined events are high level generic events that insulate the application from the device specific details of user actions on the mobile device such as keys stroked and pointing device characteristics manipulated.

For example a predefined field entered event is generated when a cursor on the screen of the mobile device enters a graphical element associated with a field type bean. A pre defined special key pressed event is generated when a special key of the keys is pressed to move to a different page without completing and submitting the current page. A pre defined page exited event is generated when a user indicates the user is finished with the page such as when an enter key is pressed with the cursor placed on a button labeled submit. If the application does not include instructions for the event handling methods for these events the mobile interactions server employs one of the built in event handlers for these events. More details on the event handling methods and interfaces are described in a later section.

The field beans describe the attributes and behavior of the graphical elements displayed on the screen of the mobile device and used to display information to the user or collect data from the user or both.

According to one embodiment a set of nine field types are defined by corresponding field type bean subclasses of a field bean subclass of the mobile applications bean. The set of nine field bean types are provided to the application developer to instantiate and add event handlers to provide the behavior for the application being developed. The nine field type beans include a text field bean a list of values LOV field bean a list field bean a multi list field bean a checkbox field bean a radio field bean a button field bean a heading field bean and a separator field bean. The values assigned to properties of the field beans are used to customize the instantiated field type for particular applications. For example the hidden property of a text bean may be set to true to suppress display of the value. Similarly the editable property of a text bean may be set to true to allow the user to type characters that replace the characters currently in the value of the bean. Default values provided for some attributes are assigned if the application does not explicitly assign other values. In the preferred embodiment a method for generating an XML document for each field type bean is built in and need not be written or replaced by the application developer.

The editable attribute of this text field element is indicated by the XML document produced by method for this bean. The editable field is rendered as a reversed background highlight according to the XML to protocol converter based on information in the device profile database about the display used by this device. For example it is determined from the device profile database that the display on the particular mobile device in which the client process is executing supports reverse background text. Then the editable text is highlighted on this Telnet display by reversing black and white for the characters and background. The user of the mobile device may replace the characters in the value of this field bean with other characters indicating a different account number. As the user strokes each character key the built in event handling method for the text field bean automatically uses the XML generating method to produce an XML document that describes the new character in the field and the cursor moved to the next position. The application developer does not have to replace either method or and therefore does not need to know the details of communicating with the mobile device.

Sample attributes of the nine field bean classes are provided in Tables 1 through 9. Values are assigned to these attributes by the application to specify the layout of the graphical elements with which a user of the mobile device receives and enters data. The information in each of the following tables is also used in the method to generate XML documents for the objects instantiated from the bean. The method to generate XML uses an XML document type definition DTD for the bean. The DTD defines XML element tags that correspond to the field bean types and attributes that correspond to the entries in the Attribute column. The DTD also specifies data types for the attributes that correspond to the entries in the Allowed Values column and default values that correspond to the entries in the Default Value column in the Tables 1 through 9. A corresponding style sheet is used by the XML converters and to translate the XML document into other markup languages or protocols.

If an attribute is inherited from the field bean of the mobile applications bean a yes appears in the Inherited column in Tables 1 through 9. A short description of the graphical effect of the attribute on a corresponding graphical element ultimately produced on the screen of a mobile device is included in the column titled Graphical Effect. The get set and is columns refers to the bean class methods used to access the attribute the is method is used to get an attribute value that holds a logical value true or false .

A text field bean object is used to display text or receive text input from a user. Constraints on user input if any are described by some of the attributes for this bean. Table 1 shows attributes of the text field bean.

A list of values LOV field bean object is used to present the user with a pop up list of selectable items and obtain user input signifying one of the selectable items such as in a pop up or pull down menu. The bean for these objects allows the list of selectable items to be determined dynamically at runtime by providing an attribute to store a command that launches a procedure to generate the list. The command is a structured query language SQL statement or a call to a packaged procedure in JAVA or PL SQL a proprietary extension of SQL supported by the ORACLE Corp. A result set produced in response to executing the procedure may include more than one subfield for each listed item so the bean provides attributes to describe the subfields and their display. An example of how a LOV bean object is displayed on a Telnet device is provided later. Table 2 shows attributes of the LOV bean.

The input for the procedure in the LOV statement attribute may be provided directly when the object is instantiated from the LOV bean. The LOV bean also allows the parameters input to the procedures to be obtained from the information managed by the state machine for the session as indicated in Table 2 by the expression session memory. In the illustrated embodiment session memory is the state information database . If the input parameter comes from session memory the input parameter is provided not by a value but instead by the reference to the information in the session memory. In some embodiments the reference is a unique name for the information as described in more detail later. The InputParameterTypes attribute holds strings that indicate whether each input parameter is an actual string AS number AN date AD or time AT in which case the type begins with the letter A or whether each input parameter is a reference to a string S number N date D or time T in the session memory in which case there is no A prefix.

A list field bean object is used to display lists of related items or receive text input from a user for some or all of the listed items or both. Constraints on user input if any are described by some of the attributes for this bean. Table 3 shows attributes of this field bean.

A multi list field bean object is used to display multiple lists of related items or receive text input from a user for some or all of the listed items or both. Constraints on user input if any are described by some of the attributes for this bean. A multi list bean is useful for receiving input into a table of rows and columns. Table 4 shows attributes of this field bean.

A checkbox field bean object is used to allow a user to select none one some or all of one or more options. The checkbox is especially useful when the options require many characters to specify. Table 5 shows attributes of the checkbox field bean.

A radio button field bean object is used allow a user to select one or more of several related options. The radio button is especially useful when the options are mutually exclusive. Table 6 shows attributes of the radio button field bean.

A button field bean object is used to present a button to a user of a mobile device and receive input indicating completion of input for the current page. For example a SUBMIT or DONE or OK button is instantiated from the button field bean. Typically a task is performed by the application and then a new page is displayed to the user. Table 7 shows attributes of the button field bean.

The header field bean is used to insert text into the header or title area of a screen on a mobile device. Attributes of a header field bean are shown in Table 8.

The separator bean is used by some of the other beans to provide a consistent use of characters that signal to a user of the mobile device the type of input expected after a prompt. For example in one embodiment a colon is used as a separator between a prompt and a text value in a text field bean and a greater than sign is used as a separator between a prompt and a value selected from a list of values in a list of values bean. Attributes of a separator bean are shown in Table 9.

A page object is intended to represent a group of graphical elements that are used together. A page object includes instances of one or more field beans listed in the page bean s attribute named field beans vector. The page bean extends the bean class to include a constructor method that instantiates the page and a method to add field beans to the field beans vector attribute. The page bean also extends the bean class to include page event handling methods. Logic can be included in the page bean s event handling methods to add field beans at runtime so that the pages can respond dynamically for example in response to the information managed by the state machine.

The page bean class also includes a multiple instance attribute which determines whether a user can navigate to a particular page object more than once. For example the user may press a submit button that returns the user to a page named Shopping Cart . This can either be treated as a return to a Shopping Cart page with values for the attributes as they were when the page was left e.g. with one or more items in the cart or treated as a new instance of the page with newly generated attributes e.g. a second shopping cart that is empty. The multiple instance attribute allows the second instance of the shopping cart page in the example. The mobile interactions server allows for multiple instances of a page bean if this attribute has a value of true. The two pages with the same name are distinguished by an instance number. For example the mobile applications server allows a Shopping Cart 1 page and a Shopping Cart 2 page.

A menu item bean extends the mobile applications bean with methods that should be executed when an application is first started or when the application is exited. An applications developer extends the menu item bean for a particular application by providing event handlers. One of the event handlers includes a reference to the first page bean of the application. Any application specific start up and exit procedures are provided as event handling methods.

The file and name of the menu item bean for a particular application are registered with the mobile interactions server by the applications developer when the application is ready for offering to users of mobile devices. At the time of registration the applications developer also provides the mobile applications server with a label to be presented to a user when the user first starts a communication session with the mobile applications server. The label becomes one item in a menu presented to the user as a first response after the user logs in with the mobile applications server .

Furthermore in one embodiment the value of the menu item bean name attribute is used with the values of the page name and field name to uniquely identify every graphical element in the application. This property is very useful for maintaining state information as it is described in more detail in a later section.

The first page bean includes a method to construct the page object and a vector listing one or more application specific event handling methods associated with the page. The methods may be included in the file with the page or may be in any class file associated with the application. In the illustrated embodiment the first page constructor creates instances of several field beans including field bean objects and . The first page constructor also lists an application specific event handling method associated with field bean . The event handling methods for the page listed in vector are for generic events described in more detail below which insulate the application from details of the mobile device .

With this structure the page can generate instances of field beans that depend on conditions at the time the page is generated. That is the page entered method of the page event handlers listed in vector may include instructions that determine what additional field beans to instantiate and the values of field bean attributes based on the date or time the identity of the user or any information managed by the state machine about the current session with the client at the time the page is generated. For example if the user had indicated on a previous page that the telephone numbers of two people with the name John Smith are desired the current page can obtain that information from the state information database and add two instances of text field beans to the page built by the constructor and use the two new text fields to display the phone numbers of the two John Smiths.

The first page bean also includes a reference to a subsequent page e.g. the next page. In the embodiment shown the reference to the next page is an attribute external to page event handling methods listed in vector . In another embodiment the exit page event handling method of the listed page event handlers in vector makes the reference to the next page. In still another embodiment a field bean includes the reference to the next page. In one embodiment the application specific value of the Next Page attribute in a field bean object indicates the reference to the next page. An application specific page bean may include different references to different pages in the Next Page attributes of several different field bean objects in this case the next page generated by the application depends upon the field object a user of the mobile device is acting on. In some embodiments the reference is a file name where the next application specific page bean is stored.

The page beans continue for as many pages as necessary to provide the desired functionality for the application. When the last page is exited the page event handler method of the last page issues a message indicating that no more pages follow. In this embodiment an exit application event occurs and the exit application event handler method if any in the menu item bean is executed. In one embodiment to deal with any circumstance that results in no new page being generated the application specific methods generate an exception that is a message to the mobile interactions server. Such circumstances include exiting the application redirecting control to another network based service or encountering an error while executing the logic of the event handler method.

An advantage of this arrangement is that the overall application is broken up into a series of pages that each approximately correspond to the amount of information that a user of the mobile device should consider at one time. The pages are constructed and operated independently and in series so that only one occupies the processor at any one time for one session. As a result the number of program instructions that must occupy the memory of the processor at any one time is a small subset of the overall instructions needed to provide all the functionality of the application. What information needs to be shared between one page and another is stored in the session state information maintained by the state machine of the mobile interactions server.

Another advantage of this arrangement is that each page of the application may be extended without regard to the detailed properties of individual mobile devices. Those details are handled by the methods and attributes inherited from the mobile applications beans provided to the application developer.

The operation of the mobile interactions server shall now be described with reference to the structures of the embodiment illustrated in B C and D. The steps followed when a client process first contacts the mobile interactions server are described in the following section on client log in. The steps followed by the mobile interactions server after receiving a subsequent request message from the client indicating actions by the user are described in the next sections. The state information maintained by the mobile interactions server to facilitate interaction during the entire course of a session between the client and the mobile applications server is described in the section on session state maintenance. Separate sections below are directed to describing in more detail navigation between pages the event driven interface the presentation manager and application development. A hardware overview section is also provided.

In step the mobile interactions server waits for a request from the client to start a session. In step the mobile interactions server determines whether a request was received from the client to start a session. In other embodiments steps and are replaced by different steps. For example steps and are replaced by steps of an event trigger mechanism that passes control to the following steps when a request is received without intermediate checking Alternatively steps and are replaced by a step that calls routines that implement the following steps on a predetermined schedule.

If a login is required then control is transferred to a log in process not shown and returned to step if successful.

When control passes to step the mobile interactions server launches listeners to respond to further requests from the client process. The client process is identified by the network address of the mobile device and the port through which the messages are arriving at the platform on which the mobile interactions server is executing. A different port is assigned by the operating system of the mobile applications server for each communication protocol and the port is passed to the mobile interactions server. For example messages using HTTP are typically assigned port and Telnet messages are typically assigned to a port with a different port number. One listener responds to the initial request. A second listener responds when the request message from the client indicates the user has pressed a key. The request includes data indicating the value of the key pressed and the name of the graphical element where the cursor was located when the key was pressed. A third listener responds to a logoff request. In other embodiments the first second and third listeners are combined. The steps in performed by a listener are performed by the listener that responds to the initial request.

In step information about the mobile device on which the client is executing is obtained and stored in the device profile for the session by the listener. In some mobile devices some of this information is obtained by negotiating directly with the client process on the mobile device. During negotiations one or more messages are sent to the mobile device from the mobile applications server and the responses are used to construct the mobile device profile or determine the device type. For example negotiations are used in some embodiments with industrial devices such as bar code readers that communicate via the Telnet protocol. For mobile devices that do not negotiate such as devices using the WAP protocol information pertinent to the devices and available from the manufacturer or published sources are maintained by the mobile interactions server in a database of device properties. Based on the request from the mobile device which includes some identifying information such as a manufacturer name and model name and date a device type for the mobile device is determined. The listener or in some embodiments the separate presentation manager of the mobile interactions server then retrieves device profile information from the database based on the device type.

In step the listener checks a list of registered menu items corresponding to available applications and determines which menu items should be made available to the client requesting the session based on the device profile. If a log in procedure has been required then the security policy also determines which clients have access to which applications.

In step the listener invokes a new session method of a state machine library of methods to initiate management of session state information generated during the session with the client. Included in the session state information passed to the state machine method from the listener for management is information describing the connection used to route packets to the client such as the IP address of the base station the port number at the base station used for the wireless connection the port number of the platform on which the mobile interactions server is executing and the menu items available to the client. The state machine generates a session object to store this state information and places the passed information into the session object. The structure of the session object is described in more detail below. In the illustrated embodiment the state machine stores the session object in a session state database. In other embodiments the session object is stored in other manners such as in main memory within a special memory buffer called session memory.

In step the state machine method generates a page for the mobile device. In the illustrated embodiment the page is represented as an XML document listing the menu items to be displayed on the mobile device. The state machine method returns the XML document to the listener . The listener employs the presentation manager which reformats the page for the particular mobile device based on the device profile database . The presentation manager is described with more detail in a later section.

All the steps described in occur outside the application specific menu item bean page beans and field beans. The only involvement of the application developer for these steps to occur is that the developer register the application with the mobile interactions server as described in more detail below so that the application appears as one of the options on the main menu presented to the user. In the illustrated embodiment the state machine and the listeners handle subsequent interactions between the application and the client.

In the illustrated embodiment control then passes back to step to wait for another client to request a session.

In the depicted embodiment the client process communicates with the mobile applications server using the Telnet protocol in which each key pressed is communicated to the server as a request message. In this case the listener detects when a request message arrives on the Telnet port from the client process indicating a user has pressed a key. In other embodiments the client may communicate with another protocol such as HTTP extended with forms in which the request message may indicate a higher level action such as indicating that the user has submitted a completed form without intervening messages indicating each character typed by the user. Using HTTP the listener detects when a request message arrives on port with a string of characters indicating some of the attributes and values of the completed form.

In step a Telnet listener launched by the mobile interactions server during step waits for a request message from the client process indicating a user of the mobile device has pressed a key. Step represents a branch point based on receiving the request message indicating a user action. If a request message indicating a user action is not received the listener continues to wait as represented by the arrow returning control to step . If a request message indicating a user action is detected control passes to step . For example if a message indicates the user has pressed a numeric key while the cursor is located in the text input field then the user action is key pressed. As another example on the screen of the cursor may be on text field graphical element placed after the character 4 when the user presses the enter key of the keys on the mobile device.

In step the listener generates an event object and invokes a handler of the state machine with the event object as an input parameter. The event object has an attribute for the key pressed and an attribute naming the field in which the cursor was located when the key was pressed. In this embodiment an event object is an extension of a JAVA event object class. One embodiment of an event object is depicted in . The event object includes several attributes and corresponding values that hold the name of the field bean associated with the graphical element in which the cursor was located at the start of the user action and the name of the key that was pressed. For example the attribute Name may have the value Selected Menu Item and the key pressed attribute may have value 319 . The event object is formed to pass information about the user action to the handlers implemented in the mobile applications beans.

The event object includes several methods for retrieving information from the state information managed by the state machine methods. The event object inherits a get source method from the JAVA event object class. The get source method returns a field bean object based on the stored state information for the field bean associated with the graphical element where the cursor was located. For example the get source method returns the text field bean object named Selected Menu Item associated with the text field graphical element displayed on the screen of the mobile device.

The get session method of the event object returns the session object in which information about all the field beans sent to the client and all attributes modified by a user of the mobile device. In one embodiment a reference to the session object that can be employed to access the information in the session object is returned rather than the session object itself. An embodiment of the session object is described in more detail later.

The get action method of the event object returns the user action in the source field. For example the get action method returns the string key 3 pressed or the string enter key pressed. 

The state machine has a handler for the example key 3 pressed event and generates other more generic events with more generic actions for the generic event handlers of the application as described below. The generic events produced by the state machine include field entered field exited page entered page exited special page key pressed application entered and application exited. Six generic actions are associated with events passed to handlers of an application. The six generic actions are next field previous field submit page back page forward page and menu page. The generic events and actions insulate the application from details of determining which keys are on which mobile devices and how cursors are used in each device to move from field to field on a page.

In step the state machine method determines whether the key pressed action corresponds to one of the generic events an exit field event. For example a field is exited when an enter key is pressed or a pointing device is clicked on a button field or if the field does not involve a list and either a cursor up key is pressed or a cursor down key is pressed. If the key pressed indicates a field is being exited then the state machine handler sets the action in the event object to previous field if the exit is indicated by a cursor up key and next field if the exit is indicated otherwise. If the action does not correspond to exiting a field then control passes to step . The key 3 pressed does not correspond to a generic event such as field exited thus in this example control passes to step .

In step a field handler of the state machine specific to the field bean type is invoked with the event object as the input parameter to deal with the pressed key. A different handler is available for each type of field bean. Handlers for the nine field type beans are built in for the state machine and are not produced by the application developer and are not considered application handlers. In step the state machine field handler revises the field based on the key pressed updates the state information stored about the field in the session object and generates an XML document to return to the listener for sending on to the client process on the mobile device. After step control then passes to step to wait for further user action.

For example the built in text field handler for the key 3 pressed event revises the Value attribute of the Selected Menu Item to 3 and stores this Value in the Session object and generates an XML document with the new value. In one embodiment the XML document includes descriptions of the entire page recovered from the session object. In another embodiment the XML document includes just the description of the revised field object. The XML document is returned to the listener that causes the new value to be rendered on the mobile device and the cursor to be moved to the position after the 3 as is described in more detail below. For an example list field element as depicted in a list field handler responds to a cursor down key being pressed by revising the field to show a different list item highlighted updating the state information to indicate the highlighted item and generating an XML document with the next item of the list highlighted and the former item if any changed from highlighted to not highlighted.

If the action is associated with the generic event field exited in step then control passes to step to invoke a state machine exit field handler with the event object as the input parameter. For example if the action is associated with a generic next field action or a generic previous field action then the action is associated with the generic field exited event type. A different exit field handler is invoked for each field type. The state machine includes exit field handlers and enter field handlers for the nine field types. The application can include its own application specific handlers for the event types when a page object is constructed. Note that the Main Menu Screen depicted in is not constructed by the application but is automatically provided by the state machine and listener of the mobile interactions server. Thus no exit field handlers or enter field handlers for the field objects corresponding to the graphical elements on that page are provided by the application. On the other hand if the field being exited was generated on a page provided by the application then the field object information stored in the session object obtained with the event object identifies any application specific exit field handler. The state machine exit field handler determines whether the field object includes an application specific exit field handler and if so invokes the application specific exit field handler.

In step the exit field handler determines whether a Next Page attribute contains a reference to page object of the application or whether the exit field is the option input field of the main menu screen or whether there is no remaining field on the page. If any of these conditions is true control passes to step described later. Otherwise another field on the same page is being entered.

If the step determines that another field on the same page is being entered control passes to step in which the state machine exit field handler invokes the state machine change field handler to leave a field without generating a new page object. In step the state machine change field handler updates information in the session object about the field object being exited and determines which field object if any is being entered based on the action included in the event object. For example if the page is as depicted in and the field being exited is the text field element with the prompt ACCT and the action is next field then the field being entered is the next one on the page in order which is the text field element with the prompt ITEM. If instead the action were previous field then the field being entered would be the LOV field element with the prompt TXN TYPE. The change field handler then adds a field entered event to the event object and a name of the field that will be entered. The source of this event does not change it is still the field that is exited but another field object is added to the event naming the field entered.

In step the state machine invokes the state machine enter field handler for the field type of the field being entered. The state machine enter field handler determines whether the field object includes an application specific enter field handler and if so invokes the application specific enter field handler. Control then passes to step .

In step the state machine generates an XML document describing the page object indicating which field element is the current field element and indicating the position of the cursor. In some embodiments only the changed field objects and cursor position are included in the XML document. In other embodiments the entire page object is described in the XML document. The XML document is then returned to the listener for preparing to present to the client process for display to the user of the mobile device. Control passes to step to wait for another request message indicating user action at the mobile device.

If in step the exit field handler determines that a new page must be generated it adds the page entered event to the event object and control passes to step . In step the state machine invokes an exit page handler for the current page passing the event object as the input parameter. The state machine exit page handler determines whether the current page object includes an application specific exit page handler and if so invokes the application specific exit page handler passing the event object as the input parameter. Control then passes to step .

In one embodiment if the current page is the main menu page then the state machine exit page handler uses the information in the session object to map the value of the option selected by the mobile device user on the main menu screen to a file where the application specific menu item bean and page beans are stored. The exit page handler then adds an application entered event to the event object and invokes the enter application handler of the menu item bean passing the event object as the input parameter. The enter application handler returns a menu item object with a reference to the first page of the application. A menu item object is added to the session object in session memory.

If there is not another field on the page and the Next Page reference is empty then the end of the application has been reached. The state machine exit page handler then adds a application exited event to the event object and invokes the exit application handler of the menu item bean. The exit application handler performs any application specific end of application functions and returns. The next page is the main menu screen and the state machine exit page handler invokes the main menu method passing control to step of .

In step the state machine invokes the instantiate page handler passing the event object. This handler uses the reference in the Next Page attribute or the reference to the first page obtained through the event object to determine whether the page already exists in the session object and if so whether it supports multiple instances. If the page is not already in the session object or if the page supports multiple instances the handler invokes the constructor method for the page bean to instantiate the page. The page bean is identified in the Next Page attribute of the exited field or in the reference to the first page. The constructor method does not accept the event object as an input. The constructor method instantiates the page object and the field objects contained in the page object. The constructed page object includes a vector indicating any enter handlers and exit handlers for the page object and field objects on the page. Control then passes to step .

In step the state machine invokes the state machine enter page handler with the event object as the input parameter. The state machine enter page handler makes the first field the current field and adds a field entered event to the event object. The state machine enter page handler determines whether the current page object includes an application specific enter page handler and if so invokes the application specific enter page handler passing the event object as the input parameter. The enter and exit handlers included in the vector accept event objects as parameters. Therefore any field objects included on the page based on state information are instantiated by the application specific enter page handler. Similarly any attributes that depend on the state information are assigned values in the application specific enter page handler. Control then passes to step to update and store the session object to step to invoke the enter field handler for the current field on the new page and step to generate and return the XML document.

An advantage of these event handling techniques in the described embodiment is that the application developer can employ the observer observable paradigm for software development. In the observer observable paradigm a program element deals only with observable objects and ignores other objects. The observer registers the objects that are to be observable and the system notifies the observer when an observable object is generated changes or terminates. As applied to mobile applications developers the mobile application is built to observe certain events e.g. the generic events. Other events such as the user pressing each key while entering data into a text field or the user moving a cursor up and down on a list field are not registered observables and so the developer does not develop instructions to handle events associated with those actions. As implemented in the embodiment described the built in methods of the mobile interactions beans such as the nine field type beans handle the intra field actions and most of the intra page actions by the user.

The state machine enter field handlers include built in procedures to provide the behavior expected of the field types. For some field types the built in behavior is complex. For example when a LOV field is entered such as the LOV field element in the LOV field entered handler retrieves the contents of the LOVstatement attribute provided by the application which is a stored procedure or an SQL statement as described above. The handler causes the statement to be executed with the parameters provided by the application and included in the InputParameters attribute. If indicated by the InputParameterTypes attribute one or more of the InputParameters may be retrieved from the session memory e.g. the session object. The result set produced in response to executing the LOVstatement is stored by the built in handler the result set is referenced by the LOV field name for example in the session object. The result set is made up of records each of one or more subfields.

If the results set is empty after execution of the LOVstatement the text value remains unchanged an error message such as Invalid Value or No Values Found is generated and stored referenced to the LOV field name such as in the session object and data is generated indicating the cursor position remains in the field. The error message and cursor data are included in the XML document produced in step . If the results set contains only one record then the one record is placed into the SelectedValues attribute of the LOV field the Value attribute is set to a subfield of the record that has a type that matches the type in the ValueType attribute the event object is modified to add a next field action and control passes to step where the built in exit LOV field handler is invoked with the modified event object. The built in exit LOV field handler generates data indicating the cursor is positioned at the next field.

If the results set contains several records then the displayed subfields of the records as indicated by the SubfieldDisplays attribute are placed into a list by the enter LOV field handler the event type is modified to include the special action generate LOV page and control passes to step and following steps. In step a built in handler is invoked to instantiate the LOV page using the list. is an example LOV page listing the transaction types TXN TYPE from which the value presented in LOV field can be selected. In one embodiment as shown in this handler includes a select button field. The select button has a NextPage attribute set to a reference to the previous page the previous instance of the page not a new instance of the previous page . In an embodiment in which the page is implemented as a single list field the reference to the previous page is assigned to the NextPage attribute of the list field. In step a built in enter LOV page handler is invoked to set the selected item of the list to one of the list items e.g. field . In an embodiment in which the page is implemented with a single list field the enter LOV page handler sets the single list field as the current field. Control then passes to step to update the session object to include the page object with the list corresponding to the page . In step a LOV enter field handler is invoked with the event object. In one embodiment this handler selects one of the items of the list field as the selected item and locates the cursor on that item e.g. field . In step the state machine generates an XML document with the list and returns the XML document to the listener for display to the user.

In one embodiment the user employs the up and down arrow keys without leaving the list field through steps to as described above. When the user presses the enter key the state machine determines that a next field condition is satisfied and generates an event object with the next field and passes control to step . In an alternative embodiment each cursor move is interpreted as an exit field event not associated with submitting a page and is processed through steps to as described above. When in a field pressing an enter key selects the corresponding list item replacing any prior selections. When the user presses enter in the select button then the page is submitted. In either case a page exited event is added to the event object and the event is processed through steps and through .

In step the reference to the previous page as the next page is detected the state machine adds a page exited event to the event object and control passes to steps to invoke the built in exit LOV page handler with the event object. The built in exit LOV page handler generates data indicating the cursor is positioned on the next field of the previous page e.g. field and the Value attribute is set to the appropriate subfield of the SelectedValues attribute. In step the previous page is returned with the new selection occupying the Value attribute. In step the state machine enter page handler for the previous page selects the field object corresponding to the cursor as the field being entered and invokes any application specific enter page handler. In step the session object is updated and in step the state machine enter field handler is invoked for the field where the cursor is located which itself invokes any application specific handlers. In step the XML document for the current page is generated and returned to the listener.

An advantage to the application developer is that the complex behavior of the LOV field may be obtained simply by instantiating the LOV bean. The application developer does not have to generate handlers for any of the LOV field events.

Session object includes a hierarchy of state information objects corresponding to the menu item objects the page objects and the field objects in the applications in the order they were instantiated during the session. For example an application state information object includes information from the first instance of the application such as a unique name among the names of the applications available on the mobile applications server. The unique name is generated by the state machine based on the file name of the application and instance number. As each page is generated during interactions with the client process a page state information object is added to the application state information object.

For example first page state information object is added when the first page is generated and returned to the state machine. This object includes a property for a unique name for the page. Object includes state information objects for each field object on the page object. A field state information object includes at least a unique name for the field an identification of the type of field and values for at least some of the attributes of the objects belonging to that type. Ellipses indicate additional field state information objects to be included in the page state information object . Ellipses indicate additional page state information objects may be included in the application state information object . Ellipses indicate additional application state information objects may be included in the session object .

If multiple instance pages are allowed several instances of the same page can be maintained in the session object . However if multiple instance pages are not allowed then as a user of the mobile device steps back to a previous page the current pages are deleted and forgotten. On the second visit to a page the attributes values may change. For example the value of the TXN TYPE LOV field in field of may change from RECEIPT to SHIP after obtaining user input. In this case no record would be kept of the former values for the attributes of the items on the page. For example a page state information object would not exist in which the TXN TYPE was RECEIPT memory of that state of the page would be lost. Only the most recent visit to the page would be stored in the session object .

A unique namespace for every object generated during the session is maintained. In one embodiment a unique name is generated for the session a unique name is generated for an application within the session a unique name is generated for each page within an application and a unique name is generated for each field object within a page. Then even though the same page name may be used in different applications or the same field name in different pages of the same application a unique name is generated for each object by appending its name separated by a period after the name of its parent and continuing on to the session name. For multiple instances of the same application page or field an instance number can also be appended.

For example a unique session name is generated based on the client network address appended to a port number. For example if the IP address of the mobile device is 002.002.002.002 and the port is 19 then a unique name for the session can be constructed by appending the latter to the former omitting periods to yield 00200200200219. A unique name for an application executed by this client is generated from the main menu item corresponding to the application and an instance number for the application. For example if the main menu item for the application is option 3 with a label Inventory Database Input associated with a JAVA file inv.java in directory Mobile Database Inventory of the platform of the mobile applications server then a unique name for the application can be one of 3 InventoryDatabaseInput and Mobile Database Inventory inv.java. Assuming that InventoryDatabaseInput is used for balancing brevity with descriptiveness and that the application is invoked for the first time of possibly multiple invocations the unique name for the application is 00200200200219.1InventoryDatabaseInput. A unique name for a second instance of a page bean named Location would then be 00200200200219.1InventoryDatabaseInput.2Location. A unique name for the first field object named Address on the page would then be 00200200200219.1InventoryDatabaseInput.2Location.1Address 

The unique name of an object in the namespace combined with the storage in a session memory of state information for all objects in association with their unique names allows the name to serve as a reference for all the information about that object.

The unique namespace also facilitates storage and retrieval in some embodiments. For example a database index is generated based on the unique name in one embodiment. The index maps the unique name of each object to a location in the database where the object or information about the object is stored. Then a particular object can be retrieved quickly from the database based on the unique name for the object.

In the preferred embodiment the session object is an instance of a bean class that includes as attributes the instances of the menu item beans page beans and field beans generated during the session. For example an instance of each page bean including its instances of field beans with all their attributes and attribute values is added to the session object as the page object is returned to the state machine methods. In this embodiment the bean methods for storing and retrieving attributes and attribute values of instances of the beans are used to store and retrieve the session object and thereby every object included in the session object. Thus the session object provides persistence and serialization for the state information managed by the state machine.

Using these techniques the state machine is able to manage the state information for the session on behalf of one or more applications during a communication session with a particular client. The state machine adds state information at each branch point of a hierarchy as a page is constructed for the client. The state machine thus develops a complete tree representing the navigational path followed by the user.

At the same time the state machine builds a namespace that uniquely identifies each field object. The unique identifier provides access for retrieving state information from the session object. Furthermore the state machine has sufficient information at its disposal to handle up and down movements of a cursor on a page displayed at the mobile device so that the applications would not have to provide methods to respond to such user actions.

As described above the page object can include field objects that depend on information in the session object because the event object passed to the page entered handler includes a method to get a reference to the session object. For example if the user had indicated on a previous page that the telephone numbers of two people with the name John Smith are desired the current page entered handler can obtain that information from the session object. Then for example the page entered handler can add two instances of text field beans to the page object to display the phone numbers of the two John Smiths.

These techniques free the developers of applications from the responsibility for managing their session state information. This greatly simplifies and accelerates the development of applications.

To illustrate how a user navigates through pages presented by an application consider . is a diagram that illustrates an embodiment of a page on a display of a mobile device. On this page each graphical element appears on a different line of the display. Depending on the display device either the entire page is displayed to the user of the mobile device or only one or a few lines of the page are displayed to the user of the mobile device. In either case one or more keys on the mobile device allow the user to position a cursor on one of these lines. The position of the cursor may be indicated by a movable symbol or simply by highlighting the area of the graphical element such as by outlining or reversing color. The user may then perform some further action on the graphical element by pressing one or more keys on the mobile device. As used herein selecting a graphical element includes placing the cursor on the graphical element and pressing a key on the mobile device when the cursor is positioned on the graphical element.

The manner in which the graphical element is rendered may provide cues to the user about what user actions are allowed. For example on a Telnet device an editable text field is indicated by prompt followed by a highlighted value. A button is indicated by a button name between characters. A graphical element indicating one choice from a list of predetermined values is indicated by a prompt followed by a highlighted field including the character. In the preferred embodiment the behavior of the display in response to user actions is provided in the built in methods defined in the field type beans. Because of the built in methods there is no burden on the developer of the application to render instances of the beans on various mobile devices.

The user is free to navigate up and down this page editing the editable fields as desired. When the user is done with editing graphical elements on a page the user selects a graphical element indicating the user s desire to exit the page. In the example the submit button provides that capability. Because the submit button is a button moving the cursor to the line is not sufficient to exit the page. Rather the user must also press another key such as an enter key. If the application provides for additional functionality then the user is presented with a new page of graphical elements with which to interact. In one embodiment the state machine or client process provides the behavior for the cursor movement keys and changing fields on the same page the application provides the behavior from when the page is submitted until the next page is rendered.

Interaction with a list of values field element also involves displaying a new page to the user in this example. is a diagram that illustrates an embodiment of a next page on a display of a mobile device as a result of selecting the list of values field element. In this case the new page includes a numbered list of values that can be selected as the current value for the LOV graphical element. In some embodiments this list is an instance of a list bean one of the nine field type beans. After the user selects one or more of the values on this list the user selects the select button at the bottom of the page to make the choice effective. If only one value is allowed as in the illustrated example then it would be sufficient for the user to press a key when the cursor is located over the desired value. After making this choice the user is presented with another instance of the previous page but with the chosen value in the list of values field element.

The application developer may allow a user to navigate to multiple pages from the same page. The application developer simply includes references to different pages in several different fields. For example a page may have three text field objects and have a different page reference in the Next Page Name attribute of each of the three text field objects. Depending upon which text field the user exits the mobile interactions server invokes the page constructor of a different page as the next page. This replaces links to other pages with field objects and page event handlers on the server. The next page is identified not with a link but with a name of the next page.

Using this method to navigate among the graphical elements of the application only references to the graphical elements themselves are passed between the mobile applications server and the client. It is not necessary to provide a full URL padded with values for parameters needed by the destination application as in conventional methods for providing services on request over a network. It is not necessary to revise the WAP standard to allow cookies. It is not even necessary to send the full unique name of the field object or the next page name to the mobile device. All the information needed by the application is kept on the mobile applications server in the state information maintained by the state machine for the session and is referenced by the unique name of the field object. A mapping between the graphical element reference sent to the mobile client and the unique name of the field object is kept at the listener and used to retrieve useful information in the session memory associated with the graphical element. When a user action is detected by the listener with reference to the graphical element the listener maps it to the unique name of the field object that corresponds to the graphical element and passes this information to a method such as an event handler. The method obtains any information needed from the session memory using the unique name of the field object.

Navigation from one page to another is also accomplished in some embodiments using special navigation keys and an event handler for the special keys. illustrates the flow associated with a special key event. Six generic actions are associated with events passed to handlers of an application. The six generic actions are next field previous field submit page back page forward page and menu page. The first three have been described as associated with a cursor down cursor up and enter key with respect to . The last three actions back page forward page and menu page are generated in response to a user pressing a special key such as ALT with the cursor up cursor down and enter keys or with keys F1 F2 and F3 on a personal computer keyboard. Steps and correspond to steps in respectively and represent a listener waiting for and detecting a request message indicating a keystroke by the user generating an event and invoking a state machine event handler. In step the state machine handler determines whether the keystroke described in the event object is associated with a special key. If not control passes to step in to determine whether the keystroke is associated with an exit field. Otherwise control passes to step .

In step the state machine invokes a state machine special key handler with the event object which invokes an application specific special key handler if one is provided for the page. The state machine special key handler includes methods for retrieving pages from the session object in either direction from the current page or to exit the application and return to the main menu and to return the resulting XML document to the listener. The forward page action reverses the back page action if the current page is the last instantiated page then the forward page action has no effect. The application specific special key handler allows the application developer to provide logic for dealing with the special keys before invoking the state machine methods for moving back or forward through the pages stored in the state machine.

This page by page navigation leaves more room in the limited memory of the mobile device to present the user with more options than is often possible using either cookies or URLs with parameter information as in the conventional approaches.

In the illustrated embodiment in which interactions with the client are segregated from the data and logic of the application the application interacts with a state machine of a mobile interactions server. In the illustrated embodiment the application receives input from the state machine as generic events rather than device specific keystroke events. Consequently the application in this embodiment includes one or more methods called event handling methods or simply handlers to respond to the generic events issued by the state machine. The state machine includes handlers for the all the events and determines whether the application has application specific handlers for the event as described above with respect to .

A particular handler for a page object observes only particular events for the pages that instantiate it not other events or events for other pages. Similarly a particular handler for a field object observes only particular events for the fields that instantiate it not other events or events for other fields. This technique implements an observer observable paradigm in which the events are the observables and the object with included handlers are the observers.

The listeners respond to transport layer request messages from the client process. The requests involve specifics of the base station protocols from which the application is being insulated. The application layer events produced by the listeners and the generic events produced by the state machine are designed to continue to insulate the application from the keystroke specifics of interacting with any of a number of the mobile devices. The generic events for which the application developer may include application specific handlers are 

Within each handler for these events application specific behavior is programmed that depends on one or more of the six generic actions next field previous field submit page back page forward page and menu page generated by the mobile interactions server in response to one or more keystrokes by a user of the mobile device.

In step an application specific page event handler is invoked by the corresponding state machine page event handler. The page event is either a page entered event or a page exited event or a special key pressed event. If the event handler does not return control to the invoking method the event handler throws an exception. Step represents a branch point for the case in which no exception is thrown. If no exception is thrown control passes back to the invoking method in step to invoke the next handler for the event object.

If the event handler determines that a condition for termination of the application has occurred the handler throws a no more pages exception. Step represents the branch point for the case in which the exception is a no more pages exception. In step the exception handler for the no more pages exception invokes the state machine exit application method which determines whether there is an application specific exit application handler in the application s menu item bean. As described above after the application specific exit application handler is invoked the state machine regenerates the main menu and presents the main menu to the client process through the presentation manager.

If the event handler determines that a request should be issued to another resource on the network such as a database server the handler throws a redirect exception. Such a redirect is expected only from a page entered event handler for a page. The other resource is identified by its URL complete with any parameters needed to particularize the request. For example if the other resource is a database server the URL includes the SQL statement that specifies the database operation desired. The redirect exception includes the URL loaded with input parameters. In step it is determined that the exception is a redirect to a URL and control passes to step . In step the redirect exception handler sends a request addressed to the URL receives an HTML document in response adds the HTML to the session object in association with the page and invokes a method of the page such as the page entered handler or the page exited handler the latter shown in . The page method invoked produces or modifies field objects on the page based on the HTML document.

Though depicted in as being thrown by a page event handler the next three exceptions can be thrown by a field event handler or a menu item event handler as well. If the event handler throws an abort handler exception as indicated by the branch point in step then control passes to the abort exception handler which performs step . In step the exception handler skips any other handlers of the event object. Data is generated that indicates the location of the cursor is in the graphical element corresponding to the field object that is the source of the event object.

If the event handler throws an interrupted handler exception as indicated by the branch point in step then control passes to the interrupted exception handler which performs step . In step the exception handler invokes the other handlers of the event object. Data is generated that indicates the location of the cursor is in the graphical element corresponding to the field object that is the source of the event object.

If the event handler throws a default only handler exception as indicated by the branch point in step then control passes to the default only exception handler which performs step . In step the exception handler skips the other handlers of the event object. Data is generated that indicates the location of the cursor is in the graphical element corresponding to the field object that is the source of the event object. The state machine handler for that field object is then invoked if not already invoked.

The proper application handler is invoked during the corresponding event through the event driven interface. As noted above an interface specifies the name and type of the parameters of a method and the name and type of the returned value if any.

Table 10 shows statements used to define the event handlers interface. The event handlers respond to the generic events generated by the mobile interactions server rather than to transport layer events that the listener responds to. In the terminology used in the following tables the Listeners are the application specific event handlers that are invoked by the mobile interactions server when a generic event is generated.

Line 1 indicates that the mobile interactions server event handler herein named the MWAListener where MWA stands for mobile wireless applications is an interface that extends the EventListener interface provided by the Java utilities package java.util. 

Lines 2 though 7 further define the interface for the field event handler herein named MWAFieldListener for generic field events. These statements indicate that the field event interface extends the mobile interactions server event handler interface by defining two event handling interfaces. In lines 3 4 a fieldEntered handler interface is defined that takes an event object e of type MWAEvent and may throw any of the three named exceptions. The MWAEvent is defined elsewhere in the JAVA class file where the statements of Table 10 are stored. In lines 5 6 a fieldExited handler interface is defined with similar properties.

Similarly lines 18 through 23 further define the interface for the application level menu item event handler herein named MWAAppListener for two generic events. This interface defines the AppEntered handler interface and an AppExited handler interface defined similarly to the FieldEntered and FieldExited interfaces described above respectively.

Similarly lines 8 through 17 further define the interface for the page event handler herein named MWAPageListener for three generic events. This interface defines the PageEntered handler interface and an PageExited handler interface defined similarly to the FieldEntered and FieldExited interfaces described above respectively. Furthermore as indicated in line 11 the PageEntered handler may also throw a RedirectHandlerException to redirect the mobile interactions server to a network resource with a specified URL as described above. Also as indicated in line 14 the PageExited handler may throw a NoMorePagesHandlerException to allow the mobile interactions server to invoke the AppExited handler as described above. In addition the MWAPageListener interface includes another interface for the specialKeyPressed handler as defined in lines 15 16.

Table 11 shows statements used to implement an event handler interface in one embodiment. In this example application specific handlers are implemented only for the generic event for a special key being pressed used during page navigation and not for page entered and page exited events of the page interface.

The statement in line 1 indicates that the class named NavigHandler provides the instructions for the methods that are consistent with the MWAPageListener interface. That is the methods of NavigHandler have the names parameter names and types and return types specified in the MWAPageListener interface listed in Table 10.

Lines 2 3 indicate that two methods do almost nothing. The pageEntered method and the pageExited method simply accept the event object as input and return immediately. This means that all the functionality performed on entering and exiting pages is based on the state machine methods alone. The methods perform no application specific functions.

The statements on lines 4 20 are the instructions for a specialKeyPressed method. Line 5 indicates the getSession method of the event object e is invoked to return a session object type MWASession defined elsewhere in the java code and not shown here associated with the event object. The developer has chosen to call this session object S for purposes of this method. In line 6 the term MWA BACK is compared to the generic action based on the user input that is included in the event object e. The comparison method that disregards capitalization called equalsIgnoreCase returns a value true if the term input as a parameter MWA BACK is the same ignoring case as the text string returned from the getAction method of the event object e. MWA BACK is the special action in this embodiment corresponding to the page back action described above. If the expression in line 6 is true then the instruction in lines 7 8 are followed. If not the instructions on lines 11 13 are followed. In line 7 it is determined whether the source of the event is named PAGE2 if so the MWA library routine setError is invoked to throw an exception. The effect of lines 6 9 is to throw an exception to the mobile interactions server if the user tries to press a special key signifying a page back action while the page named PAGE2 is being displayed. This block prevents a user from navigating to pages visited prior to PAGE2.

The statements in lines 11 13 are followed if the user is paging back from some other page. These instructions add the word Again to the title field of the page being revisited in response to the page back action. These instructions illustrate the use of the state information maintained by the state machine in a session object by an application. The statement in line 11 indicates that the previous page is obtained using the getPreviousPage method of the session object S and assigned to a PageBean object named PP. This page bean has a name indicated by PP.Name. A field named Title on the previous page is referenced in the session object by a unique name in the namespace as described above by appending the field name to the page name. Thus the expression PP.Name .Title indicates the unique name of the field. In line 13 the text field object named Title on the previous page is placed in a text field object called TF. The statement on line 13 indicates that the string in the prompt field of the Title text field is set using the text field bean method setPrompt to the text passed as a parameter. The text passed as a parameter is the text already in that field obtained using the text field bean method getPrompt. with the word Again appended.

The statements in lines 16 17 do not allow a user to page forward even after paging back through an application. The user is forced to submit each page using the normal procedures not using the special key for paging forward. The statement in line 1.6 determines whether the action is MWA FORWARD. If so the statement in line 17 is followed which invokes the setError method to throw an exception.

The statement in line 19 determines whether the action is the page to menu action represented by MWA MENU in this embodiment. If so the method simply returns without doing anything more. Therefore the menu action is handled entirely by the state machine menu special key event handler.

The NavigHandler of Table 11 is used on pages that the developer wants to prevent the user from leaving by paging forward or prevent the user from leaving by paging back beyond PAGE2. The developer warns the user that a page is reached through a page back action by adding the word Again to the title each time. None of the statements in Table 11 require the developer to know any specifics about the mobile device on which the client is operating. Furthermore the developer is not required to know the details about how the state information employed is stored or retrieved. The state information is readily available for any event handler that employs it.

Table 12 shows statements used to include the event handler defined in Table 11 in a page bean in one embodiment. In this example a LOCATION page defines two text fields A and B for reporting the address and adds the two text fields to the page. Table 12 also employs event handlers to allow a text field to be affected by user actions in another text field.

The statement in lines 1 20 define a LOCATION page bean by extending the mobile interactions server page bean. This LOCATION page bean inherits all the attributes and methods of a mobile applications page bean described above and the LOCATION page bean is instantiated at runtime to generate a LOCATION type page object.

The statement in line 3 indicates the event handling methods of the NavigHandler class defined in Table 11 are instantiated in this page bean. The addListener method of JAVA beans is employed to instantiate the methods of the NaviHandler. This statement ensures that when a LOCATION page object is entered or exited the NavigHandler method will be invoked.

The statements in lines 4 5 instantiate event handling methods defined by the classes AListener and BListener defined in lines 21 25 and 26 39 respectively. The only event handler with application specific logic in these two classes of methods is a field exited handler defined in the BListener in lines 28 34. These statements are described in greater detail below. Because the AListener does not provide any application specific logic in this embodiment the same effect would be obtained if the AListener class had not been included.

The statements in lines 6 10 instantiate a text field bean and assign values to the attributes Name ValueType Prompt and Length. The statement in line 6 defines the object A of type TextFieldBean to be a new instance of the text field bean. When instantiated in line 6 the object A has the default attributes defined in Table 1 for a text field bean object. For example the text field is editable the Editable attribute is true . Thus the object A can be used to accept user input text. The bean set attribute methods are used to assign values that override the default values in lines 7 10. As a result of these assignments text field object A on Page LOCATION has a bean name AddressA and prompts a user for input with the text string Street Address. 

The statement in line 11 associates an event handler with events that involve object A. The bean method addListener of the text field bean object A is employed to add an instance of the event handlers of the class BListener to the object A. The effect of adding these event handlers is described below.

The statements in lines 12 16 for text field bean object B correspond to the lines 6 10 for text field bean object A. The only difference is that the bean name of object B is AddressB and the prompt is City State Zip. No event handler is added to the text field bean object B.

The statements in lines 17 18 employ a bean page method named addFieldBeans to add field beans to the page when the page is instantiated. The statement in line 17 adds the instance of field A to the LOCATION page when the page is instantiated at runtime. The statement in line 18 adds the instance of field B to the LOCATION page when the page is instantiated.

Lines 21 39 of Table 12 include statements that define the application specific event handler methods in the classes AListener and BListener. Only the fieldExited handler of the BListener in lines 28 36 includes application specific logic. When a field associated with the BListener is exited in response to a user operating a mobile device the handler is invoked and the expression in the statement in line 29 produces a value of true if the source or owner of the event is a field named AddressA. The expression uses the event object method getOwner and the getOwner method equalsIgnoreCase to determine whether the source is a field named AddressA . If this expression is not true then the handler simply returns without doing anything more.

The object A is associated with the BListener by the statement in line 11. Thus if the user strokes a cursor up or a cursor down or an enter key while the cursor is located on a graphical element associated with object A then the event handler in lines 28 36 is invoked. In this case the expression evaluated in line 29 is true the source of the event is the field object A with name AddressA. 

The statement in line 30 is then executed to obtain the session object from the event object so that state information can be obtained and used. The statements in line 31 and 32 create local text field bean objects TF and TF to hold the bean objects returned from the getField method of the session object S. Each of the desired fields is obtained by reference using the unique name generated by appending the field name to the page name LOCATION. In line 33 the prompt for the AddressB object is replaced by a string consisting of the Value in the AddressA object at the time the field is exited with the words is in which appended and the former value of the prompt also appended. In this way the information input into the field object A becomes part of the prompt for field object B.

For example a user has typed the text 1600 Pennsylvania Ave. into a graphical element corresponding to field object A and pressed the enter key. This causes the application specific event handler exitField of BListener associated with object A to be invoked. The handler retrieves the value of object A using the object session and incorporates that string into the prompt string for field B which now reads 1600 Pennsylvania Ave. is in which City State Zip. 

Using this event driven interface events are triggered in the application layer allowing a developer to program applications as a hierarchy of observers each dealing with a manageable number of observables. Application specific event handlers can be included in field objects page objects and the menu item object of the application hierarchy to provide the desired behavior for the application. There is no restriction on how many handlers an application can define. Built in state machine event handlers insulate the application handlers from low level user actions such as pointing device manipulation and individual keystrokes. The built in state machine event handlers also provide automatic navigation from page to page of the application. In addition the application specific handlers may throw exceptions to invoke built in exception handlers for obtaining a response from a separate network resource for exiting an application specific handler abnormally and for terminating the application.

In step the presentation manager receives an XML document describing a page object or field object for rendering at the client process on the mobile device. For example a XML document describing a page object is received that is sent with the original menu in step of . As another example a page object is received that is sent from an application to the state machine and from the state machine to the presentation manager in steps of . At this stage it has not been determined whether the entire page will fit on the display or in the page buffer of the mobile device. The page object represents the device independent view from the application perspective concerning the amount of information the user of the mobile device should have at one time to effectively navigate through the application.

In step the presentation manager obtains information about the specific mobile device on which the client is executing. This information is obtained from the device profile and is constructed when the session began as described above in at step . This device specific information includes a form factor describing the dimensions of the display capabilities of the display input buffer size or other device specific information.

In step the presentation manager builds one or more pages in a common markup language based on the received page object and the display form factor from the device profile. For example if the page object includes 14 field beans as shown in but the particular mobile device to which the page is to be sent is so tiny that it can only display four lines at a time and its page buffer can only hold the text for 128 characters including non displayed characters like line end tab and page end then the entire page object cannot be sent to the particular mobile device at one time.

An embodiment of step divides the information shown in and described in the common markup language such as XML among device specific pages. For example an embodiment of step generates four device specific pages each with one line displaying both the page title and the submit button while the other three lines on each device specific page display three of the remaining 12 field beans. Each device specific page includes a subset of the graphical elements in the page object. Among the graphical elements in the subset is the current graphical element where the cursor is located also called the graphical element in focus. In one embodiment only the device specific page for the subset including the graphical element in focus is formed.

In this embodiment the device specific pages are expressed in a common markup language. In the preferred embodiment XML is used as the common markup language. The use of XML is advantageous because among other reasons converters already exist that convert XML documents to HTML documents for use by browsers and WML documents for use by WAP devices as well as for HDML and VoxML.

In step the device specific XML pages are sent to a converter routine to convert them to a format for the client protocol such as WML HDML. VoxML Telnet and HTML.

When a page object generated by the application has been reformatted into more than one device specific pages the user of the mobile device may use the cursor placement keys such as an up key and a down key to move off a particular device specific page. For example the user of the mobile device hits a down key when the cursor is positioned on the fourth and final line of the device specific page described above with respect to step of . According to one embodiment the device handler of the application does not include logic to handle this circumstance. The application is unaware of the device specific pages built by the presentation manager. According to this embodiment the listener still invokes the state machine method for the key pressed and the state machine generates a responsive XML document and the presentation manager re generates a device specific page that includes the current field.

In step the developer generates an application made up of one or more pages each comprising one or more fields. In the preferred embodiment each field is an instance of one of nine field type beans. In this embodiment each page is an instance of a page bean.

In step the developer generates a page event handler for each event associated with the page. The page event handler includes logic to execute based on a generic event generated by the mobile interactions server in response to a user of the mobile device acting on a graphical element corresponding to a field object on the page. The event includes an indication of a generic action performed by the user and a reference to session state information. In the preferred embodiment the page is a page bean object and the event handler is a page bean event handler method and the fields are field type bean objects. A listener process passes an event object to the event handler method when calling the method and the event object includes a reference to the field bean in the session object maintained by a state machine. Also the field beans include built in field even handlers. Then the application specific logic can be based on any information in the event object or the session object.

In step the developer registers the application with the mobile interactions server. In the preferred embodiment the developer generates a menu item bean including a method to execute when the application is first called and a reference to the first page. Then a reference to the menu item bean such as a URL identifying a file where a menu item bean is stored is associated with a menu item added to a list of menu items presented to a client by the mobile interactions server as a main menu. In the preferred embodiment the mobile interactions server provides a registration process. The developer runs the registration process and enters the reference to the menu item bean when prompted by the registration process. The developer also enters a label for the application that is used as the text for the label item on the main menu.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

The invention is related to the use of computer system for providing network applications for wireless mobile devices. According to one embodiment of the invention a page for display on the mobile device is provided by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another computer readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term computer readable medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media and volatile media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory .

Common forms of computer readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge or any other medium from which a computer can read.

Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface . In accordance with the invention one such downloaded application provides for a user interface as described herein.

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain application code in the form of a carrier wave.

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. In particular the order of some steps in the flow charts can be changed without affecting adversely the practice of the invention. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

