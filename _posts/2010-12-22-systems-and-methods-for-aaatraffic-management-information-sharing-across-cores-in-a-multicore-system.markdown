---

title: Systems and methods for AAA-traffic management information sharing across cores in a multi-core system
abstract: A method for propagating authentication session information to a plurality of cores of a multi-core device includes establishing, by an authentication virtual server executing on a first core of a device intermediary to at least one client and server, a session for a user, the authentication virtual server authenticating the session. A traffic management virtual server executes on a second core of device, and receives a request to access a server via the session. The traffic management virtual server may identify, responsive to a determination that the session is not stored by the second core, from an identifier of the session that the first core established the session. The second core may send to the first core a request for data for the session identified by the identifier. The second core may receive from the first core a response to the second request identifying whether the session is valid.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08667575&OS=08667575&RS=08667575
owner: Citrix Systems, Inc.
number: 08667575
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20101222
---
This present application claims the benefit of and priority to U.S. Provisional Application No. 61 289 539 entitled Systems and Methods for AAA Traffic Management information Sharing Across Cores in a Multi Core System filed Dec. 23 2009 which is incorporated herein by reference in its entirety.

The present application generally relates to managing network access to data communication networks. In particular the present application relates to systems and methods for managing authentication authorization and auditing within a multi core system managing network access to data communication networks.

There exist multi core systems that can balance network traffic across one or more cores in the multi core system. These multi core systems can be included within an appliance or a computing system and can comprise any number of cores or processors. In many instances systems designed for single core systems do not work when functioning in a multi core system.

The present disclosure and the solution described herein is directed towards systems and methods for AAA traffic management information sharing across cores in a multi core system. Authentication authorization and auditing AAA systems for authenticating application traffic exist for single core systems and to some degree for multi core systems. These AAA systems steer application data packets from a traffic management application e.g. vServer or packet engine to a packet engine where AAA sessions are present. In these systems the AAA system can reside on a single core. Thus only a single core is used to authenticate authorize and audit logins and sessions. There exists a need for a solution that takes advantage of the processing power of a multi core system by allowing not only traffic processing but also authentication authorization and auditing to take place on multiple cores in a multi core system. In this solution an AAA session could be propagated to all cores that receive a request to authenticate along with a valid session cookie.

In one aspect the present disclosure is directed to a method for propagating authentication session information to a plurality of cores of a multi core device. The method includes establishing by an authentication virtual server executing on a first core of a plurality of cores of a device intermediary to a plurality of clients and one or more servers a session for a user the authentication virtual server authenticating the session. A traffic management virtual server executes on a second core of the plurality of cores. The traffic management virtual server may receive a first request via the session to access a server of the one or more servers. The traffic management virtual server may identify responsive to a determination that the session is not stored by the second core from an identifier of the session that the first core established the session. The second core may send to the first core a second request for data for the session identified by the identifier. The second core may receive from the first core a response to the second request. The response may identify whether the session is valid.

In some embodiments the authentication virtual server sets a cookie for the session. The cookie may include a domain session cookie. The traffic management virtual server may determine that the session is not stored in memory local to the second core. The second core may decode a core identifier of the first core encoded in the identifier of the session. The second core may generate a core to core message specifying the identifier of the session. The second core may receive from the first core the response comprising a failure message identifying that the first core determined the identifier of the session is invalid.

In some embodiments the second core may receive from the first core the response comprising data to create the session on the requesting core. The second core may create the session in memory local to the second core. The second core may determine that the cookie for the session received from the first core is invalid. Responsive to the determination the second core may send a redirect to the authentication virtual server. In some embodiments the second core may receive from the first core the response comprising a successful message. Responsive to the successful message the second core may perform a local session lookup using the identifier of the session.

In one aspect the present disclosure is directed to system for propagating authentication session information via a plurality of cores of a multi core device. The system may include a device intermediary to a plurality of clients and one or more servers. The device may include a plurality of cores. An authentication virtual server may execute on a first core of the plurality of cores establishing a session for a user. The authentication virtual server may authenticate the session. A traffic management virtual server may execute on a second core of the plurality of cores. The traffic management virtual server may receive a first request via the session to access a server of the one or more servers. The traffic management virtual server may identify responsive to a determination that the session is not stored by the second core from an identifier of the session that the first core established the session. The second core may send to the first core a second request for data for the session identified by the identifier. The second core may receive from the first core a response to the second request. The response may identify whether the session is valid.

In some embodiments the authentication virtual server sets a cookie for the session the cookie comprising a domain session cookie. The traffic management virtual server may determine that the session is not stored in memory local to the second core. The second core may decode a core identifier of the first core encoded in the identifier of the session. The second core may generate a core to core message specifying the identifier of the session. In certain embodiments the second core receives from the first core the response comprising a failure message identifying that the first core determined the identifier of the session is invalid.

In certain embodiments the second core may receive from the first core the response comprising data to create the session on the requesting core. The second core may create the session in memory local to the second core. The second core may determine that the cookie for the session received from the first core is invalid and responsive to the determination sending a redirect to the authentication virtual server. The second core may receive from the first core the response comprising a successful message. Responsive to the successful message the second core may perform a local session lookup using the identifier of the session.

In yet another aspect described herein are systems and methods for AAA traffic management. An authentication vServer an AAA daemon and or a SSL module can be used by the packet engines of one or more cores to authenticate login requests issued by users of a client machine communicating with the multi core system. In some embodiments an authentication vServer can receive login requests authenticate the user and start a user session. Session information including a session ID and or user login credentials can be stored in a session buffer on each core or can be stored in a shared memory buffer. The session information can be used by any one of the cores to create a session. A session owner core can manage a session by deleting a session when a session times out on each core accessing that particular session. In some embodiments each core can perform its own authentication process using an AAA daemon and or a SSL module to authenticate login requests and issue SSL certificates.

The features and advantages of the methods and systems described herein will become more apparent from the detailed description set forth below when taken in conjunction with the drawings in which like reference characters identify corresponding elements throughout. In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements.

For purposes of reading the description of the various embodiments below the following descriptions of the sections of the specification and their respective contents may be helpful 

Prior to discussing the specifics of embodiments of the systems and methods of an appliance and or client it may be helpful to discuss the network and computing environments in which such embodiments may be deployed. Referring now to an embodiment of a network environment is depicted. In brief overview the network environment comprises one or more clients also generally referred to as local machine s or client s in communication with one or more servers also generally referred to as server s or remote machine s via one or more networks generally referred to as network . In some embodiments a client communicates with a server via an appliance .

Although shows a network and a network between the clients and the servers the clients and the servers may be on the same network . The networks and can be the same type of network or different types of networks. The network and or the network can be a local area network LAN such as a company Intranet a metropolitan area network MAN or a wide area network WAN such as the Internet or the World Wide Web. In one embodiment network may be a private network and network may be a public network. In some embodiments network may be a private network and network a public network. In another embodiment networks and may both be private networks. In some embodiments clients may be located at a branch office of a corporate enterprise communicating via a WAN connection over the network to the servers located at a corporate data center.

The network and or be any type and or form of network and may include any of the following a point to point network a broadcast network a wide area network a local area network a telecommunications network a data communication network a computer network an ATM Asynchronous Transfer Mode network a SONET Synchronous Optical Network network a SDH Synchronous Digital Hierarchy network a wireless network and a wireline network. In some embodiments the network may comprise a wireless link such as an infrared channel or satellite band. The topology of the network and or may be a bus star or ring network topology. The network and or and network topology may be of any such network or network topology as known to those ordinarily skilled in the art capable of supporting the operations described herein.

As shown in the appliance which also may be referred to as an interface unit or gateway is shown between the networks and . In some embodiments the appliance may be located on network . For example a branch office of a corporate enterprise may deploy an appliance at the branch office. In other embodiments the appliance may be located on network . For example an appliance may be located at a corporate data center. In yet another embodiment a plurality of appliances may be deployed on network . In some embodiments a plurality of appliances may be deployed on network . In one embodiment a first appliance communicates with a second appliance . In other embodiments the appliance could be a part of any client or server on the same or different network as the client . One or more appliances may be located at any point in the network or network communications path between a client and a server .

In some embodiments the appliance comprises any of the network devices manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. referred to as Citrix NetScaler devices. In other embodiments the appliance includes any of the product embodiments referred to as WebAccelerator and BigIP manufactured by F5 Networks Inc. of Seattle Wash. In another embodiment the appliance includes any of the DX acceleration device platforms and or the SSL VPN series of devices such as SA 700 SA 2000 SA 4000 and SA 6000 devices manufactured by Juniper Networks Inc. of Sunnyvale Calif. In yet another embodiment the appliance includes any application acceleration and or security related appliances and or software manufactured by Cisco Systems Inc. of San Jose Calif. such as the Cisco ACE Application Control Engine Module service software and network modules and Cisco AVS Series Application Velocity System.

In one embodiment the system may include multiple logically grouped servers . In these embodiments the logical group of servers may be referred to as a server farm . In some of these embodiments the serves may be geographically dispersed. In some cases a farm may be administered as a single entity. In other embodiments the server farm comprises a plurality of server farms . In one embodiment the server farm executes one or more applications on behalf of one or more clients .

The servers within each farm can be heterogeneous. One or more of the servers can operate according to one type of operating system platform e.g. WINDOWS NT manufactured by Microsoft Corp. of Redmond Wash. while one or more of the other servers can operate on according to another type of operating system platform e.g. Unix or Linux . The servers of each farm do not need to be physically proximate to another server in the same farm . Thus the group of servers logically grouped as a farm may be interconnected using a wide area network WAN connection or medium area network MAN connection. For example a farm may include servers physically located in different continents or different regions of a continent country state city campus or room. Data transmission speeds between servers in the farm can be increased if the servers are connected using a local area network LAN connection or some form of direct connection.

Servers may be referred to as a file server application server web server proxy server or gateway server. In some embodiments a server may have the capacity to function as either an application server or as a master application server. In one embodiment a server may include an Active Directory. The clients may also be referred to as client nodes or endpoints. In some embodiments a client has the capacity to function as both a client node seeking access to applications on a server and as an application server providing access to hosted applications for other clients 

In some embodiments a client communicates with a server . In one embodiment the client communicates directly with one of the servers in a farm . In another embodiment the client executes a program neighborhood application to communicate with a server in a farm . In still another embodiment the server provides the functionality of a master node. In some embodiments the client communicates with the server in the farm through a network . Over the network the client can for example request execution of various applications hosted by the servers in the farm and receive output of the results of the application execution for display. In some embodiments only the master node provides the functionality required to identify and provide address information associated with a server hosting a requested application.

In one embodiment the server provides functionality of a web server. In another embodiment the server receives requests from the client forwards the requests to a second server and responds to the request by the client with a response to the request from the server . In still another embodiment the server acquires an enumeration of applications available to the client and address information associated with a server hosting an application identified by the enumeration of applications. In yet another embodiment the server presents the response to the request to the client using a web interface. In one embodiment the client communicates directly with the server to access the identified application. In another embodiment the client receives application output data such as display data generated by an execution of the identified application on the server .

Referring now to an embodiment of a network environment deploying multiple appliances is depicted. A first appliance may be deployed on a first network and a second appliance on a second network . For example a corporate enterprise may deploy a first appliance at a branch office and a second appliance at a data center. In another embodiment the first appliance and second appliance are deployed on the same network or network . For example a first appliance may be deployed for a first server farm and a second appliance may be deployed for a second server farm . In another example a first appliance may be deployed at a first branch office while the second appliance is deployed at a second branch office . In some embodiments the first appliance and second appliance work in cooperation or in conjunction with each other to accelerate network traffic or the delivery of application and data between a client and a server

Referring now to another embodiment of a network environment deploying the appliance with one or more other types of appliances such as between one or more WAN optimization appliance is depicted. For example a first WAN optimization appliance is shown between networks and and s second WAN optimization appliance may be deployed between the appliance and one or more servers . By way of example a corporate enterprise may deploy a first WAN optimization appliance at a branch office and a second WAN optimization appliance at a data center. In some embodiments the appliance may be located on network . In other embodiments the appliance may be located on network . In some embodiments the appliance may be located on network or network . In one embodiment the appliance and are on the same network. In another embodiment the appliance and are on different networks. In another example a first WAN optimization appliance may be deployed for a first server farm and a second WAN optimization appliance for a second server farm 

In one embodiment the appliance is a device for accelerating optimizing or otherwise improving the performance operation or quality of service of any type and form of network traffic such as traffic to and or from a WAN connection. In some embodiments the appliance is a performance enhancing proxy. In other embodiments the appliance is any type and form of WAN optimization or acceleration device sometimes also referred to as a WAN optimization controller. In one embodiment the appliance is any of the product embodiments referred to as WANScaler manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. In other embodiments the appliance includes any of the product embodiments referred to as BIG IP link controller and WANjet manufactured by F5 Networks Inc. of Seattle Wash. In another embodiment the appliance includes any of the WX and WXC WAN acceleration device platforms manufactured by Juniper Networks Inc. of Sunnyvale Calif. In some embodiments the appliance includes any of the steelhead line of WAN optimization appliances manufactured by Riverbed Technology of San Francisco Calif. In other embodiments the appliance includes any of the WAN related devices manufactured by Expand Networks Inc. of Roseland N.J. In one embodiment the appliance includes any of the WAN related appliances manufactured by Packeteer Inc. of Cupertino Calif. such as the PacketShaper iShared and SkyX product embodiments provided by Packeteer. In yet another embodiment the appliance includes any WAN related appliances and or software manufactured by Cisco Systems Inc. of San Jose Calif. such as the Cisco Wide Area Network Application Services software and network modules and Wide Area Network engine appliances.

In one embodiment the appliance provides application and data acceleration services for branch office or remote offices. In one embodiment the appliance includes optimization of Wide Area File Services WAFS . In another embodiment the appliance accelerates the delivery of files such as via the Common Internet File System CIFS protocol. In other embodiments the appliance provides caching in memory and or storage to accelerate delivery of applications and data. In one embodiment the appliance provides compression of network traffic at any level of the network stack or at any protocol or network layer. In another embodiment the appliance provides transport layer protocol optimizations flow control performance enhancements or modifications and or management to accelerate delivery of applications and data over a WAN connection. For example in one embodiment the appliance provides Transport Control Protocol TCP optimizations. In other embodiments the appliance provides optimizations flow control performance enhancements or modifications and or management for any session or application layer protocol.

In another embodiment the appliance encoded any type and form of data or information into custom or standard TCP and or IP header fields or option fields of network packet to announce presence functionality or capability to another appliance . In another embodiment an appliance may communicate with another appliance using data encoded in both TCP and or IP header fields or options. For example the appliance may use TCP option s or IP header fields or options to communicate one or more parameters to be used by the appliances in performing functionality such as WAN acceleration or for working in conjunction with each other.

In some embodiments the appliance preserves any of the information encoded in TCP and or IP header and or option fields communicated between appliances and . For example the appliance may terminate a transport layer connection traversing the appliance such as a transport layer connection from between a client and a server traversing appliances and . In one embodiment the appliance identifies and preserves any encoded information in a transport layer packet transmitted by a first appliance via a first transport layer connection and communicates a transport layer packet with the encoded information to a second appliance via a second transport layer connection.

Referring now to a network environment for delivering and or operating a computing environment on a client is depicted. In some embodiments a server includes an application delivery system for delivering a computing environment or an application and or data file to one or more clients . In brief overview a client is in communication with a server via network and appliance . For example the client may reside in a remote office of a company e.g. a branch office and the server may reside at a corporate data center. The client comprises a client agent and a computing environment . The computing environment may execute or operate an application that accesses processes or uses a data file. The computing environment application and or data file may be delivered via the appliance and or the server .

In some embodiments the appliance accelerates delivery of a computing environment or any portion thereof to a client . In one embodiment the appliance accelerates the delivery of the computing environment by the application delivery system . For example the embodiments described herein may be used to accelerate delivery of a streaming application and data file processable by the application from a central corporate data center to a remote user location such as a branch office of the company. In another embodiment the appliance accelerates transport layer traffic between a client and a server . The appliance may provide acceleration techniques for accelerating any transport layer payload from a server to a client such as 1 transport layer connection pooling 2 transport layer connection multiplexing 3 transport control protocol buffering 4 compression and 5 caching. In some embodiments the appliance provides load balancing of servers in responding to requests from clients . In other embodiments the appliance acts as a proxy or access server to provide access to the one or more servers . In another embodiment the appliance provides a secure virtual private network connection from a first network of the client to the second network of the server such as an SSL VPN connection. It yet other embodiments the appliance provides application firewall security control and management of the connection and communications between a client and a server .

In some embodiments the application delivery management system provides application delivery techniques to deliver a computing environment to a desktop of a user remote or otherwise based on a plurality of execution methods and based on any authentication and authorization policies applied via a policy engine . With these techniques a remote user may obtain a computing environment and access to server stored applications and data files from any network connected device . In one embodiment the application delivery system may reside or execute on a server . In another embodiment the application delivery system may reside or execute on a plurality of servers . In some embodiments the application delivery system may execute in a server farm . In one embodiment the server executing the application delivery system may also store or provide the application and data file. In another embodiment a first set of one or more servers may execute the application delivery system and a different server may store or provide the application and data file. In some embodiments each of the application delivery system the application and data file may reside or be located on different servers. In yet another embodiment any portion of the application delivery system may reside execute or be stored on or distributed to the appliance or a plurality of appliances.

The client may include a computing environment for executing an application that uses or processes a data file. The client via networks and appliance may request an application and data file from the server . In one embodiment the appliance may forward a request from the client to the server . For example the client may not have the application and data file stored or accessible locally. In response to the request the application delivery system and or server may deliver the application and data file to the client . For example in one embodiment the server may transmit the application as an application stream to operate in computing environment on client .

In some embodiments the application delivery system comprises any portion of the Citrix Access Suite by Citrix Systems Inc. such as the MetaFrame or Citrix Presentation Server and or any of the Microsoft Windows Terminal Services manufactured by the Microsoft Corporation. In one embodiment the application delivery system may deliver one or more applications to clients or users via a remote display protocol or otherwise via remote based or server based computing. In another embodiment the application delivery system may deliver one or more applications to clients or users via steaming of the application.

In one embodiment the application delivery system includes a policy engine for controlling and managing the access to selection of application execution methods and the delivery of applications. In some embodiments the policy engine determines the one or more applications a user or client may access. In another embodiment the policy engine determines how the application should be delivered to the user or client e.g. the method of execution. In some embodiments the application delivery system provides a plurality of delivery techniques from which to select a method of application execution such as a server based computing streaming or delivering the application locally to the client for local execution.

In one embodiment a client requests execution of an application program and the application delivery system comprising a server selects a method of executing the application program. In some embodiments the server receives credentials from the client . In another embodiment the server receives a request for an enumeration of available applications from the client . In one embodiment in response to the request or receipt of credentials the application delivery system enumerates a plurality of application programs available to the client . The application delivery system receives a request to execute an enumerated application. The application delivery system selects one of a predetermined number of methods for executing the enumerated application for example responsive to a policy of a policy engine. The application delivery system may select a method of execution of the application enabling the client to receive application output data generated by execution of the application program on a server . The application delivery system may select a method of execution of the application enabling the local machine to execute the application program locally after retrieving a plurality of application files comprising the application. In yet another embodiment the application delivery system may select a method of execution of the application to stream the application via the network to the client .

A client may execute operate or otherwise provide an application which can be any type and or form of software program or executable instructions such as any type and or form of web browser web based client client server application a thin client computing client an ActiveX control or a Java applet or any other type and or form of executable instructions capable of executing on client . In some embodiments the application may be a server based or a remote based application executed on behalf of the client on a server . In one embodiments the server may display output to the client using any thin client or remote display protocol such as the Independent Computing Architecture ICA protocol manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. or the Remote Desktop Protocol RDP manufactured by the Microsoft Corporation of Redmond Wash. The application can use any type of protocol and it can be for example an HTTP client an FTP client an Oscar client or a Telnet client. In other embodiments the application comprises any type of software related to VoIP communications such as a soft IP telephone. In further embodiments the application comprises any application related to real time data communications such as applications for streaming video and or audio.

In some embodiments the server or a server farm may be running one or more applications such as an application providing a thin client computing or remote display presentation application. In one embodiment the server or server farm executes as an application any portion of the Citrix Access Suite by Citrix Systems Inc. such as the MetaFrame or Citrix Presentation Server and or any of the Microsoft Windows Terminal Services manufactured by the Microsoft Corporation. In one embodiment the application is an ICA client developed by Citrix Systems Inc. of Fort Lauderdale Fla. In other embodiments the application includes a Remote Desktop RDP client developed by Microsoft Corporation of Redmond Wash. Also the server may run an application which for example may be an application server providing email services such as Microsoft Exchange manufactured by the Microsoft Corporation of Redmond Wash. a web or Internet server or a desktop sharing server or a collaboration server. In some embodiments any of the applications may comprise any type of hosted service or products such as GoToMeeting provided by Citrix Online Division Inc. of Santa Barbara Calif. WebEx provided by WebEx Inc. of Santa Clara Calif. or Microsoft Office Live Meeting provided by Microsoft Corporation of Redmond Wash.

Still referring to an embodiment of the network environment may include a monitoring server A. The monitoring server A may include any type and form performance monitoring service . The performance monitoring service may include monitoring measurement and or management software and or hardware including data collection aggregation analysis management and reporting. In one embodiment the performance monitoring service includes one or more monitoring agents . The monitoring agent includes any software hardware or combination thereof for performing monitoring measurement and data collection activities on a device such as a client server or an appliance . In some embodiments the monitoring agent includes any type and form of script such as Visual Basic script or Javascript. In one embodiment the monitoring agent executes transparently to any application and or user of the device. In some embodiments the monitoring agent is installed and operated unobtrusively to the application or client. In yet another embodiment the monitoring agent is installed and operated without any instrumentation for the application or device.

In some embodiments the monitoring agent monitors measures and collects data on a predetermined frequency. In other embodiments the monitoring agent monitors measures and collects data based upon detection of any type and form of event. For example the monitoring agent may collect data upon detection of a request for a web page or receipt of an HTTP response. In another example the monitoring agent may collect data upon detection of any user input events such as a mouse click. The monitoring agent may report or provide any monitored measured or collected data to the monitoring service . In one embodiment the monitoring agent transmits information to the monitoring service according to a schedule or a predetermined frequency. In another embodiment the monitoring agent transmits information to the monitoring service upon detection of an event.

In some embodiments the monitoring service and or monitoring agent performs monitoring and performance measurement of any network resource or network infrastructure element such as a client server server farm appliance appliance or network connection. In one embodiment the monitoring service and or monitoring agent performs monitoring and performance measurement of any transport layer connection such as a TCP or UDP connection. In another embodiment the monitoring service and or monitoring agent monitors and measures network latency. In yet one embodiment the monitoring service and or monitoring agent monitors and measures bandwidth utilization.

In other embodiments the monitoring service and or monitoring agent monitors and measures end user response times. In some embodiments the monitoring service performs monitoring and performance measurement of an application. In another embodiment the monitoring service and or monitoring agent performs monitoring and performance measurement of any session or connection to the application. In one embodiment the monitoring service and or monitoring agent monitors and measures performance of a browser. In another embodiment the monitoring service and or monitoring agent monitors and measures performance of HTTP based transactions. In some embodiments the monitoring service and or monitoring agent monitors and measures performance of a Voice over IP VoIP application or session. In other embodiments the monitoring service and or monitoring agent monitors and measures performance of a remote display protocol application such as an ICA client or RDP client. In yet another embodiment the monitoring service and or monitoring agent monitors and measures performance of any type and form of streaming media. In still a further embodiment the monitoring service and or monitoring agent monitors and measures performance of a hosted application or a Software As A Service SaaS delivery model.

In some embodiments the monitoring service and or monitoring agent performs monitoring and performance measurement of one or more transactions requests or responses related to application. In other embodiments the monitoring service and or monitoring agent monitors and measures any portion of an application layer stack such as any .NET or J2EE calls. In one embodiment the monitoring service and or monitoring agent monitors and measures database or SQL transactions. In yet another embodiment the monitoring service and or monitoring agent monitors and measures any method function or application programming interface API call.

In one embodiment the monitoring service and or monitoring agent performs monitoring and performance measurement of a delivery of application and or data from a server to a client via one or more appliances such as appliance and or appliance . In some embodiments the monitoring service and or monitoring agent monitors and measures performance of delivery of a virtualized application. In other embodiments the monitoring service and or monitoring agent monitors and measures performance of delivery of a streaming application. In another embodiment the monitoring service and or monitoring agent monitors and measures performance of delivery of a desktop application to a client and or the execution of the desktop application on the client. In another embodiment the monitoring service and or monitoring agent monitors and measures performance of a client server application.

In one embodiment the monitoring service and or monitoring agent is designed and constructed to provide application performance management for the application delivery system . For example the monitoring service and or monitoring agent may monitor measure and manage the performance of the delivery of applications via the Citrix Presentation Server. In this example the monitoring service and or monitoring agent monitors individual ICA sessions. The monitoring service and or monitoring agent may measure the total and per session system resource usage as well as application and networking performance. The monitoring service and or monitoring agent may identify the active servers for a given user and or user session. In some embodiments the monitoring service and or monitoring agent monitors back end connections between the application delivery system and an application and or database server. The monitoring service and or monitoring agent may measure network latency delay and volume per user session or ICA session.

In some embodiments the monitoring service and or monitoring agent measures and monitors memory usage for the application delivery system such as total memory usage per user session and or per process. In other embodiments the monitoring service and or monitoring agent measures and monitors CPU usage the application delivery system such as total CPU usage per user session and or per process. In another embodiments the monitoring service and or monitoring agent measures and monitors the time required to log in to an application a server or the application delivery system such as Citrix Presentation Server. In one embodiment the monitoring service and or monitoring agent measures and monitors the duration a user is logged into an application a server or the application delivery system . In some embodiments the monitoring service and or monitoring agent measures and monitors active and inactive session counts for an application server or application delivery system session. In yet another embodiment the monitoring service and or monitoring agent measures and monitors user session latency.

In yet further embodiments the monitoring service and or monitoring agent measures and monitors measures and monitors any type and form of server metrics. In one embodiment the monitoring service and or monitoring agent measures and monitors metrics related to system memory CPU usage and disk storage. In another embodiment the monitoring service and or monitoring agent measures and monitors metrics related to page faults such as page faults per second. In other embodiments the monitoring service and or monitoring agent measures and monitors round trip time metrics. In yet another embodiment the monitoring service and or monitoring agent measures and monitors metrics related to application crashes errors and or hangs.

In some embodiments the monitoring service and monitoring agent includes any of the product embodiments referred to as EdgeSight manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. In another embodiment the performance monitoring service and or monitoring agent includes any portion of the product embodiments referred to as the TrueView product suite manufactured by the Symphoniq Corporation of Palo Alto Calif. In one embodiment the performance monitoring service and or monitoring agent includes any portion of the product embodiments referred to as the TeaLeaf CX product suite manufactured by the TeaLeaf Technology Inc. of San Francisco Calif. In other embodiments the performance monitoring service and or monitoring agent includes any portion of the business service management products such as the BMC Performance Manager and Patrol products manufactured by BMC Software Inc. of Houston Tex.

The client server and appliance may be deployed as and or executed on any type and form of computing device such as a computer network device or appliance capable of communicating on any type and form of network and performing the operations described herein. depict block diagrams of a computing device useful for practicing an embodiment of the client server or appliance . As shown in each computing device includes a central processing unit and a main memory unit . As shown in a computing device may include a visual display device a keyboard and or a pointing device such as a mouse. Each computing device may also include additional optional elements such as one or more input output devices generally referred to using reference numeral and a cache memory in communication with the central processing unit .

The central processing unit is any logic circuitry that responds to and processes instructions fetched from the main memory unit . In many embodiments the central processing unit is provided by a microprocessor unit such as those manufactured by Intel Corporation of Mountain View Calif. those manufactured by Motorola Corporation of Schaumburg Ill. those manufactured by Transmeta Corporation of Santa Clara Calif. the RS 6000 processor those manufactured by International Business Machines of White Plains N.Y. or those manufactured by Advanced Micro Devices of Sunnyvale Calif. The computing device may be based on any of these processors or any other processor capable of operating as described herein.

Main memory unit may be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by the microprocessor such as Static random access memory SRAM Burst SRAM or SynchBurst SRAM BSRAM Dynamic random access memory DRAM Fast Page Mode DRAM FPM DRAM Enhanced DRAM EDRAM Extended Data Output RAM EDO RAM Extended Data Output DRAM EDO DRAM Burst Extended Data Output DRAM BEDO DRAM Enhanced DRAM EDRAM synchronous DRAM SDRAM JEDEC SRAM PC100 SDRAM Double Data Rate SDRAM DDR SDRAM Enhanced SDRAM ESDRAM SyncLink DRAM SLDRAM Direct Rambus DRAM DRDRAM or Ferroelectric RAM FRAM . The main memory may be based on any of the above described memory chips or any other available memory chips capable of operating as described herein. In the embodiment shown in the processor communicates with main memory via a system bus described in more detail below . depicts an embodiment of a computing device in which the processor communicates directly with main memory via a memory port . For example in the main memory may be DRDRAM.

The computing device may support any suitable installation device such as a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive tape drives of various formats USB device hard drive or any other device suitable for installing software and programs such as any client agent or portion thereof. The computing device may further comprise a storage device such as one or more hard disk drives or redundant arrays of independent disks for storing an operating system and other related software and for storing application software programs such as any program related to the client agent . Optionally any of the installation devices could also be used as the storage device . Additionally the operating system and the software can be run from a bootable medium for example a bootable CD such as KNOPPIX a bootable CD for GNU Linux that is available as a GNU Linux distribution from knoppix.net.

Furthermore the computing device may include a network interface to interface to a Local Area Network LAN Wide Area Network WAN or the Internet through a variety of connections including but not limited to standard telephone lines LAN or WAN links e.g. 802.11 T1 T3 56 kb X.25 broadband connections e.g. ISDN Frame Relay ATM wireless connections or some combination of any or all of the above. The network interface may comprise a built in network adapter network interface card PCMCIA network card card bus network adapter wireless network adapter USB network adapter modem or any other device suitable for interfacing the computing device to any type of network capable of communication and performing the operations described herein. A wide variety of I O devices may be present in the computing device . Input devices include keyboards mice trackpads trackballs microphones and drawing tablets. Output devices include video displays speakers inkjet printers laser printers and dye sublimation printers. The I O devices may be controlled by an I O controller as shown in . The I O controller may control one or more I O devices such as a keyboard and a pointing device e.g. a mouse or optical pen. Furthermore an I O device may also provide storage and or an installation medium for the computing device . In still other embodiments the computing device may provide USB connections to receive handheld USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry Inc. of Los Alamitos Calif.

In some embodiments the computing device may comprise or be connected to multiple display devices which each may be of the same or different type and or form. As such any of the I O devices and or the I O controller may comprise any type and or form of suitable hardware software or combination of hardware and software to support enable or provide for the connection and use of multiple display devices by the computing device . For example the computing device may include any type and or form of video adapter video card driver and or library to interface communicate connect or otherwise use the display devices . In one embodiment a video adapter may comprise multiple connectors to interface to multiple display devices . In other embodiments the computing device may include multiple video adapters with each video adapter connected to one or more of the display devices . In some embodiments any portion of the operating system of the computing device may be configured for using multiple displays . In other embodiments one or more of the display devices may be provided by one or more other computing devices such as computing devices and connected to the computing device for example via a network. These embodiments may include any type of software designed and constructed to use another computer s display device as a second display device for the computing device . One ordinarily skilled in the art will recognize and appreciate the various ways and embodiments that a computing device may be configured to have multiple display devices 

In further embodiments an I O device may be a bridge between the system bus and an external communication bus such as a USB bus an Apple Desktop Bus an RS 232 serial connection a SCSI bus a FireWire bus a FireWire bus an Ethernet bus an AppleTalk bus a Gigabit Ethernet bus an Asynchronous Transfer Mode bus a HIPPI bus a Super HIPPI bus a SerialPlus bus a SCI LAMP bus a FibreChannel bus or a Serial Attached small computer system interface bus.

A computing device of the sort depicted in typically operate under the control of operating systems which control scheduling of tasks and access to system resources. The computing device can be running any operating system such as any of the versions of the Microsoft Windows operating systems the different releases of the Unix and Linux operating systems any version of the Mac OS for Macintosh computers any embedded operating system any real time operating system any open source operating system any proprietary operating system any operating systems for mobile computing devices or any other operating system capable of running on the computing device and performing the operations described herein. Typical operating systems include WINDOWS 3.x WINDOWS 95 WINDOWS 98 WINDOWS 2000 WINDOWS NT 3.51 WINDOWS NT 4.0 WINDOWS CE and WINDOWS XP all of which are manufactured by Microsoft Corporation of Redmond Wash. MacOS manufactured by Apple Computer of Cupertino Calif. OS 2 manufactured by International Business Machines of Armonk N.Y. and Linux a freely available operating system distributed by Caldera Corp. of Salt Lake City Utah or any type and or form of a Unix operating system among others.

In other embodiments the computing device may have different processors operating systems and input devices consistent with the device. For example in one embodiment the computer is a Treo or smart phone manufactured by Palm Inc. In this embodiment the Treo smart phone is operated under the control of the PalmOS operating system and includes a stylus input device as well as a five way navigator device. Moreover the computing device can be any workstation desktop computer laptop or notebook computer server handheld computer mobile telephone any other computer or other form of computing or telecommunications device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein.

As shown in the computing device may comprise multiple processors and may provide functionality for simultaneous execution of instructions or for simultaneous execution of one instruction on more than one piece of data. In some embodiments the computing device may comprise a parallel processor with one or more cores. In one of these embodiments the computing device is a shared memory parallel device with multiple processors and or multiple processor cores accessing all available memory as a single global address space. In another of these embodiments the computing device is a distributed memory parallel device with multiple processors each accessing local memory only. In still another of these embodiments the computing device has both some memory which is shared and some memory which can only be accessed by particular processors or subsets of processors. In still even another of these embodiments the computing device such as a multi core microprocessor combines two or more independent processors into a single package often a single integrated circuit IC . In yet another of these embodiments the computing device includes a chip having a CELL BROADBAND ENGINE architecture and including a Power processor element and a plurality of synergistic processing elements the Power processor element and the plurality of synergistic processing elements linked together by an internal high speed bus which may be referred to as an element interconnect bus.

In some embodiments the processors provide functionality for execution of a single instruction simultaneously on multiple pieces of data SIMD . In other embodiments the processors provide functionality for execution of multiple instructions simultaneously on multiple pieces of data MIMD . In still other embodiments the processor may use any combination of SIMD and MIMD cores in a single device.

In some embodiments the computing device may comprise a graphics processing unit. In one of these embodiments depicted in the computing device includes at least one central processing unit and at least one graphics processing unit. In another of these embodiments the computing device includes at least one parallel processing unit and at least one graphics processing unit. In still another of these embodiments the computing device includes a plurality of processing units of any type one of the plurality of processing units comprising a graphics processing unit.

In some embodiments a first computing device executes an application on behalf of a user of a client computing device . In other embodiments a computing device executes a virtual machine which provides an execution session within which applications execute on behalf of a user or a client computing devices . In one of these embodiments the execution session is a hosted desktop session. In another of these embodiments the computing device executes a terminal services session. The terminal services session may provide a hosted desktop environment. In still another of these embodiments the execution session provides access to a computing environment which may comprise one or more of an application a plurality of applications a desktop application and a desktop session in which one or more applications may execute.

Hardware layer provides the hardware elements upon which programs and services within kernel space and user space are executed. Hardware layer also provides the structures and elements which allow programs and services within kernel space and user space to communicate data both internally and externally with respect to appliance . As shown in the hardware layer includes a processing unit for executing software programs and services a memory for storing software and data network ports for transmitting and receiving data over a network and an encryption processor for performing functions related to Secure Sockets Layer processing of data transmitted and received over the network. In some embodiments the central processing unit may perform the functions of the encryption processor in a single processor. Additionally the hardware layer may comprise multiple processors for each of the processing unit and the encryption processor . The processor may include any of the processors described above in connection with . For example in one embodiment the appliance comprises a first processor and a second processor . In other embodiments the processor or comprises a multi core processor.

Although the hardware layer of appliance is generally illustrated with an encryption processor processor may be a processor for performing functions related to any encryption protocol such as the Secure Socket Layer SSL or Transport Layer Security TLS protocol. In some embodiments the processor may be a general purpose processor GPP and in further embodiments may have executable instructions for performing processing of any security related protocol.

Although the hardware layer of appliance is illustrated with certain elements in the hardware portions or components of appliance may comprise any type and form of elements hardware or software of a computing device such as the computing device illustrated and discussed herein in conjunction with . In some embodiments the appliance may comprise a server gateway router switch bridge or other type of computing or network device and have any hardware and or software elements associated therewith.

The operating system of appliance allocates manages or otherwise segregates the available system memory into kernel space and user space . In example software architecture the operating system may be any type and or form of Unix operating system although the methods and systems described herein are not so limited. As such the appliance can be running any operating system such as any of the versions of the Microsoft Windows operating systems the different releases of the Unix and Linux operating systems any version of the Mac OS for Macintosh computers any embedded operating system any network operating system any real time operating system any open source operating system any proprietary operating system any operating systems for mobile computing devices or network devices or any other operating system capable of running on the appliance and performing the operations described herein.

The kernel space is reserved for running the kernel including any device drivers kernel extensions or other kernel related software. As known to those skilled in the art the kernel is the core of the operating system and provides access control and management of resources and hardware related elements of the application . In accordance with an embodiment of the appliance the kernel space also includes a number of network services or processes working in conjunction with a cache manager sometimes also referred to as the integrated cache the benefits of which are described in detail further herein. Additionally the embodiment of the kernel will depend on the embodiment of the operating system installed configured or otherwise used by the device .

In one embodiment the device comprises one network stack such as a TCP IP based stack for communicating with the client and or the server . In one embodiment the network stack is used to communicate with a first network such as network and a second network . In some embodiments the device terminates a first transport layer connection such as a TCP connection of a client and establishes a second transport layer connection to a server for use by the client e.g. the second transport layer connection is terminated at the appliance and the server . The first and second transport layer connections may be established via a single network stack . In other embodiments the device may comprise multiple network stacks for example and and the first transport layer connection may be established or terminated at one network stack and the second transport layer connection on the second network stack . For example one network stack may be for receiving and transmitting network packet on a first network and another network stack for receiving and transmitting network packets on a second network. In one embodiment the network stack comprises a buffer for queuing one or more network packets for transmission by the appliance .

As shown in the kernel space includes the cache manager a high speed layer 2 7 integrated packet engine an encryption engine a policy engine and multi protocol compression logic . Running these components or processes and in kernel space or kernel mode instead of the user space improves the performance of each of these components alone and in combination. Kernel operation means that these components or processes and run in the core address space of the operating system of the device . For example running the encryption engine in kernel mode improves encryption performance by moving encryption and decryption operations to the kernel thereby reducing the number of transitions between the memory space or a kernel thread in kernel mode and the memory space or a thread in user mode. For example data obtained in kernel mode may not need to be passed or copied to a process or thread running in user mode such as from a kernel level data structure to a user level data structure. In another aspect the number of context switches between kernel mode and user mode are also reduced. Additionally synchronization of and communications between any of the components or processes and can be performed more efficiently in the kernel space .

In some embodiments any portion of the components and may run or operate in the kernel space while other portions of these components and may run or operate in user space . In one embodiment the appliance uses a kernel level data structure providing access to any portion of one or more network packets for example a network packet comprising a request from a client or a response from a server . In some embodiments the kernel level data structure may be obtained by the packet engine via a transport layer driver interface or filter to the network stack . The kernel level data structure may comprise any interface and or data accessible via the kernel space related to the network stack network traffic or packets received or transmitted by the network stack . In other embodiments the kernel level data structure may be used by any of the components or processes and to perform the desired operation of the component or process. In one embodiment a component and is running in kernel mode when using the kernel level data structure while in another embodiment the component and is running in user mode when using the kernel level data structure. In some embodiments the kernel level data structure may be copied or passed to a second kernel level data structure or any desired user level data structure.

The cache manager may comprise software hardware or any combination of software and hardware to provide cache access control and management of any type and form of content such as objects or dynamically generated objects served by the originating servers . The data objects or content processed and stored by the cache manager may comprise data in any format such as a markup language or communicated via any protocol. In some embodiments the cache manager duplicates original data stored elsewhere or data previously computed generated or transmitted in which the original data may require longer access time to fetch compute or otherwise obtain relative to reading a cache memory element. Once the data is stored in the cache memory element future use can be made by accessing the cached copy rather than refetching or recomputing the original data thereby reducing the access time. In some embodiments the cache memory element may comprise a data object in memory of device . In other embodiments the cache memory element may comprise memory having a faster access time than memory . In another embodiment the cache memory element may comprise any type and form of storage element of the device such as a portion of a hard disk. In some embodiments the processing unit may provide cache memory for use by the cache manager . In yet further embodiments the cache manager may use any portion and combination of memory storage or the processing unit for caching data objects and other content.

Furthermore the cache manager includes any logic functions rules or operations to perform any embodiments of the techniques of the appliance described herein. For example the cache manager includes logic or functionality to invalidate objects based on the expiration of an invalidation time period or upon receipt of an invalidation command from a client or server . In some embodiments the cache manager may operate as a program service process or task executing in the kernel space and in other embodiments in the user space . In one embodiment a first portion of the cache manager executes in the user space while a second portion executes in the kernel space . In some embodiments the cache manager can comprise any type of general purpose processor GPP or any other type of integrated circuit such as a Field Programmable Gate Array FPGA Programmable Logic Device PLD or Application Specific Integrated Circuit ASIC .

The policy engine may include for example an intelligent statistical engine or other programmable application s . In one embodiment the policy engine provides a configuration mechanism to allow a user to identify specify define or configure a caching policy. Policy engine in some embodiments also has access to memory to support data structures such as lookup tables or hash tables to enable user selected caching policy decisions. In other embodiments the policy engine may comprise any logic rules functions or operations to determine and provide access control and management of objects data or content being cached by the appliance in addition to access control and management of security network traffic network access compression or any other function or operation performed by the appliance . Further examples of specific caching policies are further described herein.

The encryption engine comprises any logic business rules functions or operations for handling the processing of any security related protocol such as SSL or TLS or any function related thereto. For example the encryption engine encrypts and decrypts network packets or any portion thereof communicated via the appliance . The encryption engine may also setup or establish SSL or TLS connections on behalf of the client server or appliance . As such the encryption engine provides offloading and acceleration of SSL processing. In one embodiment the encryption engine uses a tunneling protocol to provide a virtual private network between a client and a server . In some embodiments the encryption engine is in communication with the Encryption processor . In other embodiments the encryption engine comprises executable instructions running on the Encryption processor .

The multi protocol compression engine comprises any logic business rules function or operations for compressing one or more protocols of a network packet such as any of the protocols used by the network stack of the device . In one embodiment multi protocol compression engine compresses bi directionally between clients and servers any TCP IP based protocol including Messaging Application Programming Interface MAPI email File Transfer Protocol FTP HyperText Transfer Protocol HTTP Common Internet File System CIFS protocol file transfer Independent Computing Architecture ICA protocol Remote Desktop Protocol RDP Wireless Application Protocol WAP Mobile IP protocol and Voice Over IP VoIP protocol. In other embodiments multi protocol compression engine provides compression of Hypertext Markup Language HTML based protocols and in some embodiments provides compression of any markup languages such as the Extensible Markup Language XML . In one embodiment the multi protocol compression engine provides compression of any high performance protocol such as any protocol designed for appliance to appliance communications. In another embodiment the multi protocol compression engine compresses any payload of or any communication using a modified transport control protocol such as Transaction TCP T TCP TCP with selection acknowledgements TCP SACK TCP with large windows TCP LW a congestion prediction protocol such as the TCP Vegas protocol and a TCP spoofing protocol.

As such the multi protocol compression engine accelerates performance for users accessing applications via desktop clients e.g. Microsoft Outlook and non Web thin clients such as any client launched by popular enterprise applications like Oracle SAP and Siebel and even mobile clients such as the Pocket PC. In some embodiments the multi protocol compression engine by executing in the kernel mode and integrating with packet processing engine accessing the network stack is able to compress any of the protocols carried by the TCP IP protocol such as any application layer protocol.

High speed layer 2 7 integrated packet engine also generally referred to as a packet processing engine or packet engine is responsible for managing the kernel level processing of packets received and transmitted by appliance via network ports . The high speed layer 2 7 integrated packet engine may comprise a buffer for queuing one or more network packets during processing such as for receipt of a network packet or transmission of a network packet. Additionally the high speed layer 2 7 integrated packet engine is in communication with one or more network stacks to send and receive network packets via network ports . The high speed layer 2 7 integrated packet engine works in conjunction with encryption engine cache manager policy engine and multi protocol compression logic . In particular encryption engine is configured to perform SSL processing of packets policy engine is configured to perform functions related to traffic management such as request level content switching and request level cache redirection and multi protocol compression logic is configured to perform functions related to compression and decompression of data.

The high speed layer 2 7 integrated packet engine includes a packet processing timer . In one embodiment the packet processing timer provides one or more time intervals to trigger the processing of incoming i.e. received or outgoing i.e. transmitted network packets. In some embodiments the high speed layer 2 7 integrated packet engine processes network packets responsive to the timer . The packet processing timer provides any type and form of signal to the packet engine to notify trigger or communicate a time related event interval or occurrence. In many embodiments the packet processing timer operates in the order of milliseconds such as for example 100 ms 50 ms or 25 ms. For example in some embodiments the packet processing timer provides time intervals or otherwise causes a network packet to be processed by the high speed layer 2 7 integrated packet engine at a 10 ms time interval while in other embodiments at a 5 ms time interval and still yet in further embodiments as short as a 3 2 or 1 ms time interval. The high speed layer 2 7 integrated packet engine may be interfaced integrated or in communication with the encryption engine cache manager policy engine and multi protocol compression engine during operation. As such any of the logic functions or operations of the encryption engine cache manager policy engine and multi protocol compression logic may be performed responsive to the packet processing timer and or the packet engine . Therefore any of the logic functions or operations of the encryption engine cache manager policy engine and multi protocol compression logic may be performed at the granularity of time intervals provided via the packet processing timer for example at a time interval of less than or equal to 10 ms. For example in one embodiment the cache manager may perform invalidation of any cached objects responsive to the high speed layer 2 7 integrated packet engine and or the packet processing timer . In another embodiment the expiry or invalidation time of a cached object can be set to the same order of granularity as the time interval of the packet processing timer such as at every 10 ms.

In contrast to kernel space user space is the memory area or portion of the operating system used by user mode applications or programs otherwise running in user mode. A user mode application may not access kernel space directly and uses service calls in order to access kernel services. As shown in user space of appliance includes a graphical user interface GUI a command line interface CLI shell services health monitoring program and daemon services . GUI and CLI provide a means by which a system administrator or other user can interact with and control the operation of appliance such as via the operating system of the appliance . The GUI or CLI can comprise code running in user space or kernel space . The GUI may be any type and form of graphical user interface and may be presented via text graphical or otherwise by any type of program or application such as a browser. The CLI may be any type and form of command line or text based interface such as a command line provided by the operating system. For example the CLI may comprise a shell which is a tool to enable users to interact with the operating system. In some embodiments the CLI may be provided via a bash csh tcsh or ksh type shell. The shell services comprises the programs services tasks processes or executable instructions to support interaction with the appliance or operating system by a user via the GUI and or CLI .

Health monitoring program is used to monitor check report and ensure that network systems are functioning properly and that users are receiving requested content over a network. Health monitoring program comprises one or more programs services tasks processes or executable instructions to provide logic rules functions or operations for monitoring any activity of the appliance . In some embodiments the health monitoring program intercepts and inspects any network traffic passed via the appliance . In other embodiments the health monitoring program interfaces by any suitable means and or mechanisms with one or more of the following the encryption engine cache manager policy engine multi protocol compression logic packet engine daemon services and shell services . As such the health monitoring program may call any application programming interface API to determine a state status or health of any portion of the appliance . For example the health monitoring program may ping or send a status inquiry on a periodic basis to check if a program process service or task is active and currently running. In another example the health monitoring program may check any status error or history logs provided by any program process service or task to determine any condition status or error with any portion of the appliance .

Daemon services are programs that run continuously or in the background and handle periodic service requests received by appliance . In some embodiments a daemon service may forward the requests to other programs or processes such as another daemon service as appropriate. As known to those skilled in the art a daemon service may run unattended to perform continuous or periodic system wide functions such as network control or to perform any desired task. In some embodiments one or more daemon services run in the user space while in other embodiments one or more daemon services run in the kernel space.

Referring now to another embodiment of the appliance is depicted. In brief overview the appliance provides one or more of the following services functionality or operations SSL VPN connectivity switching load balancing Domain Name Service resolution acceleration and an application firewall for communications between one or more clients and one or more servers . Each of the servers may provide one or more network related services referred to as services . For example a server may provide an http service . The appliance comprises one or more virtual servers or virtual internet protocol servers referred to as a vServer VIP server or just VIP also referred herein as vServer . The vServer receives intercepts or otherwise processes communications between a client and a server in accordance with the configuration and operations of the appliance .

The vServer may comprise software hardware or any combination of software and hardware. The vServer may comprise any type and form of program service task process or executable instructions operating in user mode kernel mode or any combination thereof in the appliance . The vServer includes any logic functions rules or operations to perform any embodiments of the techniques described herein such as SSL VPN switching load balancing Domain Name Service resolution acceleration and an application firewall . In some embodiments the vServer establishes a connection to a service of a server . The service may comprise any program application process task or set of executable instructions capable of connecting to and communicating to the appliance client or vServer . For example the service may comprise a web server http server ftp email or database server. In some embodiments the service is a daemon process or network driver for listening receiving and or sending communications for an application such as email database or an enterprise application. In some embodiments the service may communicate on a specific IP address or IP address and port.

In some embodiments the vServer applies one or more policies of the policy engine to network communications between the client and server . In one embodiment the policies are associated with a VServer . In another embodiment the policies are based on a user or a group of users. In yet another embodiment a policy is global and applies to one or more vServers and any user or group of users communicating via the appliance . In some embodiments the policies of the policy engine have conditions upon which the policy is applied based on any content of the communication such as internet protocol address port protocol type header or fields in a packet or the context of the communication such as user group of the user vServer transport layer connection and or identification or attributes of the client or server .

In other embodiments the appliance communicates or interfaces with the policy engine to determine authentication and or authorization of a remote user or a remote client to access the computing environment application and or data file from a server . In another embodiment the appliance communicates or interfaces with the policy engine to determine authentication and or authorization of a remote user or a remote client to have the application delivery system deliver one or more of the computing environment application and or data file. In yet another embodiment the appliance establishes a VPN or SSL VPN connection based on the policy engine s authentication and or authorization of a remote user or a remote client In one embodiment the appliance controls the flow of network traffic and communication sessions based on policies of the policy engine . For example the appliance may control the access to a computing environment application or data file based on the policy engine .

In some embodiments the vServer establishes a transport layer connection such as a TCP or UDP connection with a client via the client agent . In one embodiment the vServer listens for and receives communications from the client . In other embodiments the vServer establishes a transport layer connection such as a TCP or UDP connection with a client server . In one embodiment the vServer establishes the transport layer connection to an internet protocol address and port of a server running on the server . In another embodiment the vServer associates a first transport layer connection to a client with a second transport layer connection to the server . In some embodiments a vServer establishes a pool of transport layer connections to a server and multiplexes client requests via the pooled transport layer connections.

In some embodiments the appliance provides a SSL VPN connection between a client and a server . For example a client on a first network requests to establish a connection to a server on a second network . In some embodiments the second network is not routable from the first network . In other embodiments the client is on a public network and the server is on a private network such as a corporate network. In one embodiment the client agent intercepts communications of the client on the first network encrypts the communications and transmits the communications via a first transport layer connection to the appliance . The appliance associates the first transport layer connection on the first network to a second transport layer connection to the server on the second network . The appliance receives the intercepted communication from the client agent decrypts the communications and transmits the communication to the server on the second network via the second transport layer connection. The second transport layer connection may be a pooled transport layer connection. As such the appliance provides an end to end secure transport layer connection for the client between the two networks .

In one embodiment the appliance hosts an intranet internet protocol or intranetIP address of the client on the virtual private network . The client has a local network identifier such as an internet protocol IP address and or host name on the first network . When connected to the second network via the appliance the appliance establishes assigns or otherwise provides an IntranetIP which is network identifier such as IP address and or host name for the client on the second network . The appliance listens for and receives on the second or private network for any communications directed towards the client using the client s established IntranetIP . In one embodiment the appliance acts as or on behalf of the client on the second private network . For example in another embodiment a vServer listens for and responds to communications to the IntranetIP of the client . In some embodiments if a computing device on the second network transmits a request the appliance processes the request as if it were the client . For example the appliance may respond to a ping to the client s IntranetIP . In another example the appliance may establish a connection such as a TCP or UDP connection with computing device on the second network requesting a connection with the client s IntranetIP .

In some embodiments the appliance provides one or more of the following acceleration techniques to communications between the client and server 1 compression 2 decompression 3 Transmission Control Protocol pooling 4 Transmission Control Protocol multiplexing 5 Transmission Control Protocol buffering and 6 caching. In one embodiment the appliance relieves servers of much of the processing load caused by repeatedly opening and closing transport layers connections to clients by opening one or more transport layer connections with each server and maintaining these connections to allow repeated data accesses by clients via the Internet. This technique is referred to herein as connection pooling .

In some embodiments in order to seamlessly splice communications from a client to a server via a pooled transport layer connection the appliance translates or multiplexes communications by modifying sequence number and acknowledgment numbers at the transport layer protocol level. This is referred to as connection multiplexing . In some embodiments no application layer protocol interaction is required. For example in the case of an in bound packet that is a packet received from a client the source network address of the packet is changed to that of an output port of appliance and the destination network address is changed to that of the intended server. In the case of an outbound packet that is one received from a server the source network address is changed from that of the server to that of an output port of appliance and the destination address is changed from that of appliance to that of the requesting client . The sequence numbers and acknowledgment numbers of the packet are also translated to sequence numbers and acknowledgement expected by the client on the appliance s transport layer connection to the client . In some embodiments the packet checksum of the transport layer protocol is recalculated to account for these translations.

In another embodiment the appliance provides switching or load balancing functionality for communications between the client and server . In some embodiments the appliance distributes traffic and directs client requests to a server based on layer or application layer request data. In one embodiment although the network layer or layer of the network packet identifies a destination server the appliance determines the server to distribute the network packet by application information and data carried as payload of the transport layer packet. In one embodiment the health monitoring programs of the appliance monitor the health of servers to determine the server for which to distribute a client s request. In some embodiments if the appliance detects a server is not available or has a load over a predetermined threshold the appliance can direct or distribute client requests to another server .

In some embodiments the appliance acts as a Domain Name Service DNS resolver or otherwise provides resolution of a DNS request from clients . In some embodiments the appliance intercepts a DNS request transmitted by the client . In one embodiment the appliance responds to a client s DNS request with an IP address of or hosted by the appliance . In this embodiment the client transmits network communication for the domain name to the appliance . In another embodiment the appliance responds to a client s DNS request with an IP address of or hosted by a second appliance . In some embodiments the appliance responds to a client s DNS request with an IP address of a server determined by the appliance .

In yet another embodiment the appliance provides application firewall functionality for communications between the client and server . In one embodiment the policy engine provides rules for detecting and blocking illegitimate requests. In some embodiments the application firewall protects against denial of service DoS attacks. In other embodiments the appliance inspects the content of intercepted requests to identify and block application based attacks. In some embodiments the rules policy engine comprises one or more application firewall or security control policies for providing protections against various classes and types of web or Internet based vulnerabilities such as one or more of the following 1 buffer overflow 2 CGI BIN parameter manipulation 3 form hidden field manipulation 4 forceful browsing 5 cookie or session poisoning 6 broken access control list ACLs or weak passwords 7 cross site scripting XSS 8 command injection 9 SQL injection 10 error triggering sensitive information leak 11 insecure use of cryptography 12 server misconfiguration 13 back doors and debug options 14 website defacement 15 platform or operating systems vulnerabilities and 16 zero day exploits. In an embodiment the application firewall provides HTML form field protection in the form of inspecting or analyzing the network communication for one or more of the following 1 required fields are returned 2 no added field allowed 3 read only and hidden field enforcement 4 drop down list and radio button field conformance and 5 form field max length enforcement. In some embodiments the application firewall ensures cookies are not modified. In other embodiments the application firewall protects against forceful browsing by enforcing legal URLs.

In still yet other embodiments the application firewall protects any confidential information contained in the network communication. The application firewall may inspect or analyze any network communication in accordance with the rules or polices of the engine to identify any confidential information in any field of the network packet. In some embodiments the application firewall identifies in the network communication one or more occurrences of a credit card number password social security number name patient code contact information and age. The encoded portion of the network communication may comprise these occurrences or the confidential information. Based on these occurrences in one embodiment the application firewall may take a policy action on the network communication such as prevent transmission of the network communication. In another embodiment the application firewall may rewrite remove or otherwise mask such identified occurrence or confidential information.

Still referring to the appliance may include a performance monitoring agent as discussed above in conjunction with . In one embodiment the appliance receives the monitoring agent from the monitoring service or monitoring server as depicted in . In some embodiments the appliance stores the monitoring agent in storage such as disk for delivery to any client or server in communication with the appliance . For example in one embodiment the appliance transmits the monitoring agent to a client upon receiving a request to establish a transport layer connection. In other embodiments the appliance transmits the monitoring agent upon establishing the transport layer connection with the client . In another embodiment the appliance transmits the monitoring agent to the client upon intercepting or detecting a request for a web page. In yet another embodiment the appliance transmits the monitoring agent to a client or a server in response to a request from the monitoring server . In one embodiment the appliance transmits the monitoring agent to a second appliance or appliance .

In other embodiments the appliance executes the monitoring agent . In one embodiment the monitoring agent measures and monitors the performance of any application program process service task or thread executing on the appliance . For example the monitoring agent may monitor and measure performance and operation of vServers A N. In another embodiment the monitoring agent measures and monitors the performance of any transport layer connections of the appliance . In some embodiments the monitoring agent measures and monitors the performance of any user sessions traversing the appliance . In one embodiment the monitoring agent measures and monitors the performance of any virtual private network connections and or sessions traversing the appliance such an SSL VPN session. In still further embodiments the monitoring agent measures and monitors the memory CPU and disk usage and performance of the appliance . In yet another embodiment the monitoring agent measures and monitors the performance of any acceleration technique performed by the appliance such as SSL offloading connection pooling and multiplexing caching and compression. In some embodiments the monitoring agent measures and monitors the performance of any load balancing and or content switching performed by the appliance . In other embodiments the monitoring agent measures and monitors the performance of application firewall protection and processing performed by the appliance .

Referring now to an embodiment of the client agent is depicted. The client includes a client agent for establishing and exchanging communications with the appliance and or server via a network . In brief overview the client operates on computing device having an operating system with a kernel mode and a user mode and a network stack with one or more layers . The client may have installed and or execute one or more applications. In some embodiments one or more applications may communicate via the network stack to a network . One of the applications such as a web browser may also include a first program . For example the first program may be used in some embodiments to install and or execute the client agent or any portion thereof. The client agent includes an interception mechanism or interceptor for intercepting network communications from the network stack from the one or more applications.

The network stack of the client may comprise any type and form of software or hardware or any combinations thereof for providing connectivity to and communications with a network. In one embodiment the network stack comprises a software implementation for a network protocol suite. The network stack may comprise one or more network layers such as any networks layers of the Open Systems Interconnection OSI communications model as those skilled in the art recognize and appreciate. As such the network stack may comprise any type and form of protocols for any of the following layers of the OSI model 1 physical link layer 2 data link layer 3 network layer 4 transport layer 5 session layer 6 presentation layer and 7 application layer. In one embodiment the network stack may comprise a transport control protocol TCP over the network layer protocol of the internet protocol IP generally referred to as TCP IP. In some embodiments the TCP IP protocol may be carried over the Ethernet protocol which may comprise any of the family of IEEE wide area network WAN or local area network LAN protocols such as those protocols covered by the IEEE 802.3. In some embodiments the network stack comprises any type and form of a wireless protocol such as IEEE 802.11 and or mobile internet protocol.

In view of a TCP IP based network any TCP IP based protocol may be used including Messaging Application Programming Interface MAPI email File Transfer Protocol FTP HyperText Transfer Protocol HTTP Common Internet File System CIFS protocol file transfer Independent Computing Architecture ICA protocol Remote Desktop Protocol RDP Wireless Application Protocol WAP Mobile IP protocol and Voice Over IP VoIP protocol. In another embodiment the network stack comprises any type and form of transport control protocol such as a modified transport control protocol for example a Transaction TCP T TCP TCP with selection acknowledgements TCP SACK TCP with large windows TCP LW a congestion prediction protocol such as the TCP Vegas protocol and a TCP spoofing protocol. In other embodiments any type and form of user datagram protocol UDP such as UDP over IP may be used by the network stack such as for voice communications or real time data communications.

Furthermore the network stack may include one or more network drivers supporting the one or more layers such as a TCP driver or a network layer driver. The network drivers may be included as part of the operating system of the computing device or as part of any network interface cards or other network access components of the computing device . In some embodiments any of the network drivers of the network stack may be customized modified or adapted to provide a custom or modified portion of the network stack in support of any of the techniques described herein. In other embodiments the acceleration program is designed and constructed to operate with or work in conjunction with the network stack installed or otherwise provided by the operating system of the client .

The network stack comprises any type and form of interfaces for receiving obtaining providing or otherwise accessing any information and data related to network communications of the client . In one embodiment an interface to the network stack comprises an application programming interface API . The interface may also comprise any function call hooking or filtering mechanism event or call back mechanism or any type of interfacing technique. The network stack via the interface may receive or provide any type and form of data structure such as an object related to functionality or operation of the network stack . For example the data structure may comprise information and data related to a network packet or one or more network packets. In some embodiments the data structure comprises a portion of the network packet processed at a protocol layer of the network stack such as a network packet of the transport layer. In some embodiments the data structure comprises a kernel level data structure while in other embodiments the data structure comprises a user mode data structure. A kernel level data structure may comprise a data structure obtained or related to a portion of the network stack operating in kernel mode or a network driver or other software running in kernel mode or any data structure obtained or received by a service process task thread or other executable instructions running or operating in kernel mode of the operating system.

Additionally some portions of the network stack may execute or operate in kernel mode for example the data link or network layer while other portions execute or operate in user mode such as an application layer of the network stack . For example a first portion of the network stack may provide user mode access to the network stack to an application while a second portion of the network stack provides access to a network. In some embodiments a first portion of the network stack may comprise one or more upper layers of the network stack such as any of layers 5 7. In other embodiments a second portion of the network stack comprises one or more lower layers such as any of layers 1 4. Each of the first portion and second portion of the network stack may comprise any portion of the network stack at any one or more network layers in user mode kernel mode or combinations thereof or at any portion of a network layer or interface point to a network layer or any portion of or interface point to the user mode and kernel mode .

The interceptor may comprise software hardware or any combination of software and hardware. In one embodiment the interceptor intercept a network communication at any point in the network stack and redirects or transmits the network communication to a destination desired managed or controlled by the interceptor or client agent . For example the interceptor may intercept a network communication of a network stack of a first network and transmit the network communication to the appliance for transmission on a second network . In some embodiments the interceptor comprises any type interceptor comprises a driver such as a network driver constructed and designed to interface and work with the network stack . In some embodiments the client agent and or interceptor operates at one or more layers of the network stack such as at the transport layer. In one embodiment the interceptor comprises a filter driver hooking mechanism or any form and type of suitable network driver interface that interfaces to the transport layer of the network stack such as via the transport driver interface TDI . In some embodiments the interceptor interfaces to a first protocol layer such as the transport layer and another protocol layer such as any layer above the transport protocol layer for example an application protocol layer. In one embodiment the interceptor may comprise a driver complying with the Network Driver Interface Specification NDIS or a NDIS driver. In another embodiment the interceptor may comprise a min filter or a mini port driver. In one embodiment the interceptor or portion thereof operates in kernel mode . In another embodiment the interceptor or portion thereof operates in user mode . In some embodiments a portion of the interceptor operates in kernel mode while another portion of the interceptor operates in user mode . In other embodiments the client agent operates in user mode but interfaces via the interceptor to a kernel mode driver process service task or portion of the operating system such as to obtain a kernel level data structure . In further embodiments the interceptor is a user mode application or program such as application.

In one embodiment the interceptor intercepts any transport layer connection requests. In these embodiments the interceptor execute transport layer application programming interface API calls to set the destination information such as destination IP address and or port to a desired location for the location. In this manner the interceptor intercepts and redirects the transport layer connection to a IP address and port controlled or managed by the interceptor or client agent . In one embodiment the interceptor sets the destination information for the connection to a local IP address and port of the client on which the client agent is listening. For example the client agent may comprise a proxy service listening on a local IP address and port for redirected transport layer communications. In some embodiments the client agent then communicates the redirected transport layer communication to the appliance .

In some embodiments the interceptor intercepts a Domain Name Service DNS request. In one embodiment the client agent and or interceptor resolves the DNS request. In another embodiment the interceptor transmits the intercepted DNS request to the appliance for DNS resolution. In one embodiment the appliance resolves the DNS request and communicates the DNS response to the client agent . In some embodiments the appliance resolves the DNS request via another appliance or a DNS server .

In yet another embodiment the client agent may comprise two agents and . In one embodiment a first agent may comprise an interceptor operating at the network layer of the network stack . In some embodiments the first agent intercepts network layer requests such as Internet Control Message Protocol ICMP requests e.g. ping and traceroute . In other embodiments the second agent may operate at the transport layer and intercept transport layer communications. In some embodiments the first agent intercepts communications at one layer of the network stack and interfaces with or communicates the intercepted communication to the second agent .

The client agent and or interceptor may operate at or interface with a protocol layer in a manner transparent to any other protocol layer of the network stack . For example in one embodiment the interceptor operates or interfaces with the transport layer of the network stack transparently to any protocol layer below the transport layer such as the network layer and any protocol layer above the transport layer such as the session presentation or application layer protocols. This allows the other protocol layers of the network stack to operate as desired and without modification for using the interceptor . As such the client agent and or interceptor can interface with the transport layer to secure optimize accelerate route or load balance any communications provided via any protocol carried by the transport layer such as any application layer protocol over TCP IP.

Furthermore the client agent and or interceptor may operate at or interface with the network stack in a manner transparent to any application a user of the client and any other computing device such as a server in communications with the client . The client agent and or interceptor may be installed and or executed on the client in a manner without modification of an application. In some embodiments the user of the client or a computing device in communications with the client are not aware of the existence execution or operation of the client agent and or interceptor . As such in some embodiments the client agent and or interceptor is installed executed and or operated transparently to an application user of the client another computing device such as a server or any of the protocol layers above and or below the protocol layer interfaced to by the interceptor .

The client agent includes an acceleration program a streaming client a collection agent and or monitoring agent . In one embodiment the client agent comprises an Independent Computing Architecture ICA client or any portion thereof developed by Citrix Systems Inc. of Fort Lauderdale Fla. and is also referred to as an ICA client. In some embodiments the client comprises an application streaming client for streaming an application from a server to a client . In some embodiments the client agent comprises an acceleration program for accelerating communications between client and server . In another embodiment the client agent includes a collection agent for performing end point detection scanning and collecting end point information for the appliance and or server .

In some embodiments the acceleration program comprises a client side acceleration program for performing one or more acceleration techniques to accelerate enhance or otherwise improve a client s communications with and or access to a server such as accessing an application provided by a server . The logic functions and or operations of the executable instructions of the acceleration program may perform one or more of the following acceleration techniques 1 multi protocol compression 2 transport control protocol pooling 3 transport control protocol multiplexing 4 transport control protocol buffering and 5 caching via a cache manager. Additionally the acceleration program may perform encryption and or decryption of any communications received and or transmitted by the client . In some embodiments the acceleration program performs one or more of the acceleration techniques in an integrated manner or fashion. Additionally the acceleration program can perform compression on any of the protocols or multiple protocols carried as a payload of a network packet of the transport layer protocol.

The streaming client comprises an application program process service task or executable instructions for receiving and executing a streamed application from a server . A server may stream one or more application data files to the streaming client for playing executing or otherwise causing to be executed the application on the client . In some embodiments the server transmits a set of compressed or packaged application data files to the streaming client . In some embodiments the plurality of application files are compressed and stored on a file server within an archive file such as a CAB ZIP SIT TAR JAR or other archive. In one embodiment the server decompresses unpackages or unarchives the application files and transmits the files to the client . In another embodiment the client decompresses unpackages or unarchives the application files. The streaming client dynamically installs the application or portion thereof and executes the application. In one embodiment the streaming client may be an executable program. In some embodiments the streaming client may be able to launch another executable program.

The collection agent comprises an application program process service task or executable instructions for identifying obtaining and or collecting information about the client . In some embodiments the appliance transmits the collection agent to the client or client agent . The collection agent may be configured according to one or more policies of the policy engine of the appliance. In other embodiments the collection agent transmits collected information on the client to the appliance . In one embodiment the policy engine of the appliance uses the collected information to determine and provide access authentication and authorization control of the client s connection to a network .

In one embodiment the collection agent comprises an end point detection and scanning mechanism which identifies and determines one or more attributes or characteristics of the client. For example the collection agent may identify and determine any one or more of the following client side attributes 1 the operating system an or a version of an operating system 2 a service pack of the operating system 3 a running service 4 a running process and 5 a file. The collection agent may also identify and determine the presence or versions of any one or more of the following on the client 1 antivirus software 2 personal firewall software 3 anti spam software and 4 internet security software. The policy engine may have one or more policies based on any one or more of the attributes or characteristics of the client or client side attributes.

In some embodiments the client agent includes a monitoring agent as discussed in conjunction with . The monitoring agent may be any type and form of script such as Visual Basic or Java script. In one embodiment the monitoring agent monitors and measures performance of any portion of the client agent . For example in some embodiments the monitoring agent monitors and measures performance of the acceleration program . In another embodiment the monitoring agent monitors and measures performance of the streaming client . In other embodiments the monitoring agent monitors and measures performance of the collection agent . In still another embodiment the monitoring agent monitors and measures performance of the interceptor . In some embodiments the monitoring agent monitors and measures any resource of the client such as memory CPU and disk.

The monitoring agent may monitor and measure performance of any application of the client. In one embodiment the monitoring agent monitors and measures performance of a browser on the client . In some embodiments the monitoring agent monitors and measures performance of any application delivered via the client agent . In other embodiments the monitoring agent measures and monitors end user response times for an application such as web based or HTTP response times. The monitoring agent may monitor and measure performance of an ICA or RDP client. In another embodiment the monitoring agent measures and monitors metrics for a user session or application session. In some embodiments monitoring agent measures and monitors an ICA or RDP session. In one embodiment the monitoring agent measures and monitors the performance of the appliance in accelerating delivery of an application and or data to the client .

In some embodiments and still referring to a first program may be used to install and or execute the client agent or portion thereof such as the interceptor automatically silently transparently or otherwise. In one embodiment the first program comprises a plugin component such an ActiveX control or Java control or script that is loaded into and executed by an application. For example the first program comprises an ActiveX control loaded and run by a web browser application such as in the memory space or context of the application. In another embodiment the first program comprises a set of executable instructions loaded into and run by the application such as a browser. In one embodiment the first program comprises a designed and constructed program to install the client agent . In some embodiments the first program obtains downloads or receives the client agent via the network from another computing device. In another embodiment the first program is an installer program or a plug and play manager for installing programs such as network drivers on the operating system of the client .

Referring now to a block diagram depicts one embodiment of a virtualization environment . In brief overview a computing device includes a hypervisor layer a virtualization layer and a hardware layer. The hypervisor layer includes a hypervisor also referred to as a virtualization manager that allocates and manages access to a number of physical resources in the hardware layer e.g. the processor s and disk s by at least one virtual machine executing in the virtualization layer. The virtualization layer includes at least one operating system and a plurality of virtual resources allocated to the at least one operating system . Virtual resources may include without limitation a plurality of virtual processors generally and virtual disks generally as well as virtual resources such as virtual memory and virtual network interfaces. The plurality of virtual resources and the operating system may be referred to as a virtual machine . A virtual machine may include a control operating system in communication with the hypervisor and used to execute applications for managing and configuring other virtual machines on the computing device .

In greater detail a hypervisor may provide virtual resources to an operating system in any manner which simulates the operating system having access to a physical device. A hypervisor may provide virtual resources to any number of guest operating systems generally . In some embodiments a computing device executes one or more types of hypervisors. In these embodiments hypervisors may be used to emulate virtual hardware partition physical hardware virtualize physical hardware and execute virtual machines that provide access to computing environments. Hypervisors may include those manufactured by VMWare Inc. of Palo Alto Calif. the XEN hypervisor an open source product whose development is overseen by the open source Xen.org community HyperV VirtualServer or virtual PC hypervisors provided by Microsoft or others. In some embodiments a computing device executing a hypervisor that creates a virtual machine platform on which guest operating systems may execute is referred to as a host server. In one of these embodiments for example the computing device is a XEN SERVER provided by Citrix Systems Inc. of Fort Lauderdale Fla.

In some embodiments a hypervisor executes within an operating system executing on a computing device. In one of these embodiments a computing device executing an operating system and a hypervisor may be said to have a host operating system the operating system executing on the computing device and a guest operating system an operating system executing within a computing resource partition provided by the hypervisor . In other embodiments a hypervisor interacts directly with hardware on a computing device instead of executing on a host operating system. In one of these embodiments the hypervisor may be said to be executing on bare metal referring to the hardware comprising the computing device.

In some embodiments a hypervisor may create a virtual machine generally in which an operating system executes. In one of these embodiments for example the hypervisor loads a virtual machine image to create a virtual machine . In another of these embodiments the hypervisor executes an operating system within the virtual machine . In still another of these embodiments the virtual machine executes an operating system .

In some embodiments the hypervisor controls processor scheduling and memory partitioning for a virtual machine executing on the computing device . In one of these embodiments the hypervisor controls the execution of at least one virtual machine . In another of these embodiments the hypervisor presents at least one virtual machine with an abstraction of at least one hardware resource provided by the computing device . In other embodiments the hypervisor controls whether and how physical processor capabilities are presented to the virtual machine .

A control operating system may execute at least one application for managing and configuring the guest operating systems. In one embodiment the control operating system may execute an administrative application such as an application including a user interface providing administrators with access to functionality for managing the execution of a virtual machine including functionality for executing a virtual machine terminating an execution of a virtual machine or identifying a type of physical resource for allocation to the virtual machine. In another embodiment the hypervisor executes the control operating system within a virtual machine created by the hypervisor . In still another embodiment the control operating system executes in a virtual machine that is authorized to directly access physical resources on the computing device . In some embodiments a control operating system on a computing device may exchange data with a control operating system on a computing device via communications between a hypervisor and a hypervisor . In this way one or more computing devices may exchange data with one or more of the other computing devices regarding processors and other physical resources available in a pool of resources. In one of these embodiments this functionality allows a hypervisor to manage a pool of resources distributed across a plurality of physical computing devices. In another of these embodiments multiple hypervisors manage one or more of the guest operating systems executed on one of the computing devices .

In one embodiment the control operating system executes in a virtual machine that is authorized to interact with at least one guest operating system . In another embodiment a guest operating system communicates with the control operating system via the hypervisor in order to request access to a disk or a network. In still another embodiment the guest operating system and the control operating system may communicate via a communication channel established by the hypervisor such as for example via a plurality of shared memory pages made available by the hypervisor .

In some embodiments the control operating system includes a network back end driver for communicating directly with networking hardware provided by the computing device . In one of these embodiments the network back end driver processes at least one virtual machine request from at least one guest operating system . In other embodiments the control operating system includes a block back end driver for communicating with a storage element on the computing device . In one of these embodiments the block back end driver reads and writes data from the storage element based upon at least one request received from a guest operating system .

In one embodiment the control operating system includes a tools stack . In another embodiment a tools stack provides functionality for interacting with the hypervisor communicating with other control operating systems for example on a second computing device or managing virtual machines on the computing device . In another embodiment the tools stack includes customized applications for providing improved management functionality to an administrator of a virtual machine farm. In some embodiments at least one of the tools stack and the control operating system include a management API that provides an interface for remotely configuring and controlling virtual machines running on a computing device . In other embodiments the control operating system communicates with the hypervisor through the tools stack .

In one embodiment the hypervisor executes a guest operating system within a virtual machine created by the hypervisor . In another embodiment the guest operating system provides a user of the computing device with access to resources within a computing environment. In still another embodiment a resource includes a program an application a document a file a plurality of applications a plurality of files an executable program file a desktop environment a computing environment or other resource made available to a user of the computing device . In yet another embodiment the resource may be delivered to the computing device via a plurality of access methods including but not limited to conventional installation directly on the computing device delivery to the computing device via a method for application streaming delivery to the computing device of output data generated by an execution of the resource on a second computing device and communicated to the computing device via a presentation layer protocol delivery to the computing device of output data generated by an execution of the resource via a virtual machine executing on a second computing device or execution from a removable storage device connected to the computing device such as a USB device or via a virtual machine executing on the computing device and generating output data. In some embodiments the computing device transmits output data generated by the execution of the resource to another computing device .

In one embodiment the guest operating system in conjunction with the virtual machine on which it executes forms a fully virtualized virtual machine which is not aware that it is a virtual machine such a machine may be referred to as a Domain U HVM Hardware Virtual Machine virtual machine . In another embodiment a fully virtualized machine includes software emulating a Basic Input Output System BIOS in order to execute an operating system within the fully virtualized machine. In still another embodiment a fully virtualized machine may include a driver that provides functionality by communicating with the hypervisor . In such an embodiment the driver may be aware that it executes within a virtualized environment. In another embodiment the guest operating system in conjunction with the virtual machine on which it executes forms a paravirtualized virtual machine which is aware that it is a virtual machine such a machine may be referred to as a Domain U PV virtual machine . In another embodiment a paravirtualized machine includes additional drivers that a fully virtualized machine does not include. In still another embodiment the paravirtualized machine includes the network back end driver and the block back end driver included in a control operating system as described above.

Referring now to a block diagram depicts one embodiment of a plurality of networked computing devices in a system in which at least one physical host executes a virtual machine. In brief overview the system includes a management component and a hypervisor . The system includes a plurality of computing devices a plurality of virtual machines a plurality of hypervisors a plurality of management components referred to as tools stacks and a physical resource . The plurality of physical machines may each be provided as computing devices described above in connection with and A.

In greater detail a physical disk is provided by a computing device and stores at least a portion of a virtual disk . In some embodiments a virtual disk is associated with a plurality of physical disks . In one of these embodiments one or more computing devices may exchange data with one or more of the other computing devices regarding processors and other physical resources available in a pool of resources allowing a hypervisor to manage a pool of resources distributed across a plurality of physical computing devices. In some embodiments a computing device on which a virtual machine executes is referred to as a physical host or as a host machine .

The hypervisor executes on a processor on the computing device . The hypervisor allocates to a virtual disk an amount of access to the physical disk. In one embodiment the hypervisor allocates an amount of space on the physical disk. In another embodiment the hypervisor allocates a plurality of pages on the physical disk. In some embodiments the hypervisor provisions the virtual disk as part of a process of initializing and executing a virtual machine .

In one embodiment the management component is referred to as a pool management component . In another embodiment a management operating system which may be referred to as a control operating system includes the management component. In some embodiments the management component is referred to as a tools stack. In one of these embodiments the management component is the tools stack described above in connection with . In other embodiments the management component provides a user interface for receiving from a user such as an administrator an identification of a virtual machine to provision and or execute. In still other embodiments the management component provides a user interface for receiving from a user such as an administrator the request for migration of a virtual machine from one physical machine to another. In further embodiments the management component identifies a computing device on which to execute a requested virtual machine and instructs the hypervisor on the identified computing device to execute the identified virtual machine such a management component may be referred to as a pool management component.

Referring now to embodiments of a virtual application delivery controller or virtual appliance are depicted. In brief overview any of the functionality and or embodiments of the appliance e.g. an application delivery controller described above in connection with may be deployed in any embodiment of the virtualized environment described above in connection with . Instead of the functionality of the application delivery controller being deployed in the form of an appliance such functionality may be deployed in a virtualized environment on any computing device such as a client server or appliance .

Referring now to a diagram of an embodiment of a virtual appliance operating on a hypervisor of a server is depicted. As with the appliance of the virtual appliance may provide functionality for availability performance offload and security. For availability the virtual appliance may perform load balancing between layers and of the network and may also perform intelligent service health monitoring. For performance increases via network traffic acceleration the virtual appliance may perform caching and compression. To offload processing of any servers the virtual appliance may perform connection multiplexing and pooling and or SSL processing. For security the virtual appliance may perform any of the application firewall functionality and SSL VPN function of appliance .

Any of the modules of the appliance as described in connection with may be packaged combined designed or constructed in a form of the virtualized appliance delivery controller deployable as one or more software modules or components executable in a virtualized environment or non virtualized environment on any server such as an off the shelf server. For example the virtual appliance may be provided in the form of an installation package to install on a computing device. With reference to any of the cache manager policy engine compression encryption engine packet engine GUI CLI shell services and health monitoring programs may be designed and constructed as a software component or module to run on any operating system of a computing device and or of a virtualized environment . Instead of using the encryption processor processor memory and network stack of the appliance the virtualized appliance may use any of these resources as provided by the virtualized environment or as otherwise available on the server .

Still referring to and in brief overview any one or more vServers A N may be in operation or executed in a virtualized environment of any type of computing device such as any server . Any of the modules or functionality of the appliance described in connection with may be designed and constructed to operate in either a virtualized or non virtualized environment of a server. Any of the vServer SSL VPN Intranet UP Switching DNS acceleration App FW and monitoring agent may be packaged combined designed or constructed in a form of application delivery controller deployable as one or more software modules or components executable on a device and or virtualized environment .

In some embodiments a server may execute multiple virtual machines in the virtualization environment with each virtual machine running the same or different embodiments of the virtual application delivery controller . In some embodiments the server may execute one or more virtual appliances on one or more virtual machines on a core of a multi core processing system. In some embodiments the server may execute one or more virtual appliances on one or more virtual machines on each processor of a multiple processor device.

In accordance with Moore s Law the number of transistors that may be placed on an integrated circuit may double approximately every two years. However CPU speed increases may reach plateaus for example CPU speed has been around 3.5 4 GHz range since 2005. In some cases CPU manufacturers may not rely on CPU speed increases to gain additional performance. Some CPU manufacturers may add additional cores to their processors to provide additional performance. Products such as those of software and networking vendors that rely on CPUs for performance gains may improve their performance by leveraging these multi core CPUs. The software designed and constructed for a single CPU may be redesigned and or rewritten to take advantage of a multi threaded parallel architecture or otherwise a multi core architecture.

A multi core architecture of the appliance referred to as nCore or multi core technology allows the appliance in some embodiments to break the single core performance barrier and to leverage the power of multi core CPUs. In the previous architecture described in connection with a single network or packet engine is run. The multiple cores of the nCore technology and architecture allow multiple packet engines to run concurrently and or in parallel. With a packet engine running on each core the appliance architecture leverages the processing capacity of additional cores. In some embodiments this provides up to a 7 increase in performance and scalability.

Illustrated in are some embodiments of work task load or network traffic distribution across one or more processor cores according to a type of parallelism or parallel computing scheme such as functional parallelism data parallelism or flow based data parallelism. In brief overview illustrates embodiments of a multi core system such as an appliance with n cores a total of cores numbers 1 through N. In one embodiment work load or network traffic can be distributed among a first core A a second core B a third core C a fourth core D a fifth core E a sixth core F a seventh core G and so on such that distribution is across all or two or more of the n cores N hereinafter referred to collectively as cores . There may be multiple VIPs each running on a respective core of the plurality of cores. There may be multiple packet engines each running on a respective core of the plurality of cores. Any of the approaches used may lead to different varying or similar work load or performance level across any of the cores. For a functional parallelism approach each core may run a different function of the functionalities provided by the packet engine a VIP or appliance . In a data parallelism approach data may be paralleled or distributed across the cores based on the Network Interface Card NIC or VIP receiving the data. In another data parallelism approach processing may be distributed across the cores by distributing data flows to each core.

In further detail to in some embodiments load work or network traffic can be distributed among cores according to functional parallelism . Functional parallelism may be based on each core performing one or more respective functions. In some embodiments a first core may perform a first function while a second core performs a second function. In functional parallelism approach the functions to be performed by the multi core system are divided and distributed to each core according to functionality. In some embodiments functional parallelism may be referred to as task parallelism and may be achieved when each processor or core executes a different process or function on the same or different data. The core or processor may execute the same or different code. In some cases different execution threads or code may communicate with one another as they work. Communication may take place to pass data from one thread to the next as part of a workflow.

In some embodiments distributing work across the cores according to functional parallelism can comprise distributing network traffic according to a particular function such as network input output management NW I O A secure sockets layer SSL encryption and decryption B and transmission control protocol TCP functions C. This may lead to a work performance or computing load based on a volume or level of functionality being used. In some embodiments distributing work across the cores according to data parallelism can comprise distributing an amount of work based on distributing data associated with a particular hardware or software component. In some embodiments distributing work across the cores according to flow based data parallelism can comprise distributing data based on a context or flow such that the amount of work A N on each core may be similar substantially equal or relatively evenly distributed.

In the case of the functional parallelism approach each core may be configured to run one or more functionalities of the plurality of functionalities provided by the packet engine or VIP of the appliance. For example core 1 may perform network I O processing for the appliance while core 2 performs TCP connection management for the appliance. Likewise core 3 may perform SSL offloading while core 4 may perform layer 7 or application layer processing and traffic management. Each of the cores may perform the same function or different functions. Each of the cores may perform more than one function. Any of the cores may run any of the functionality or portions thereof identified and or described in conjunction with . In this the approach the work across the cores may be divided by function in either a coarse grained or fine grained manner. In some cases as illustrated in division by function may lead to different cores running at different levels of performance or load .

In the case of the functional parallelism approach each core may be configured to run one or more functionalities of the plurality of functionalities provided by the packet engine of the appliance. For example core 1 may perform network I O processing for the appliance while core 2 performs TCP connection management for the appliance. Likewise core 3 may perform SSL offloading while core 4 may perform layer 7 or application layer processing and traffic management. Each of the cores may perform the same function or different functions. Each of the cores may perform more than one function. Any of the cores may run any of the functionality or portions thereof identified and or described in conjunction with . In this the approach the work across the cores may be divided by function in either a coarse grained or fine grained manner. In some cases as illustrated in division by function may lead to different cores running at different levels of load or performance.

The functionality or tasks may be distributed in any arrangement and scheme. For example illustrates a first core Core 1 A processing applications and processes associated with network I O functionality A. Network traffic associated with network I O in some embodiments can be associated with a particular port number. Thus outgoing and incoming packets having a port destination associated with NW I O A will be directed towards Core 1 A which is dedicated to handling all network traffic associated with the NW I O port. Similarly Core 2 B is dedicated to handling functionality associated with SSL processing and Core 4 D may be dedicated handling all TCP level processing and functionality.

While illustrates functions such as network I O SSL and TCP other functions can be assigned to cores. These other functions can include any one or more of the functions or operations described herein. For example any of the functions described in conjunction with may be distributed across the cores on a functionality basis. In some cases a first VIP A may run on a first core while a second VIP B with a different configuration may run on a second core. In some embodiments each core can handle a particular functionality such that each core can handle the processing associated with that particular function. For example Core 2 B may handle SSL offloading while Core 4 D may handle application layer processing and traffic management.

In other embodiments work load or network traffic may be distributed among cores according to any type and form of data parallelism . In some embodiments data parallelism may be achieved in a multi core system by each core performing the same task or functionally on different pieces of distributed data. In some embodiments a single execution thread or code controls operations on all pieces of data. In other embodiments different threads or instructions control the operation but may execute the same code. In some embodiments data parallelism is achieved from the perspective of a packet engine vServers VIPs A C network interface cards NIC D E and or any other networking hardware or software included on or associated with an appliance . For example each core may run the same packet engine or VIP code or configuration but operate on different sets of distributed data. Each networking hardware or software construct can receive different varying or substantially the same amount of data and as a result may have varying different or relatively the same amount of load

In the case of a data parallelism approach the work may be divided up and distributed based on VIPs NICs and or data flows of the VIPs or NICs. In one of these approaches the work of the multi core system may be divided or distributed among the VIPs by having each VIP work on a distributed set of data. For example each core may be configured to run one or more VIPs. Network traffic may be distributed to the core for each VIP handling that traffic. In another of these approaches the work of the appliance may be divided or distributed among the cores based on which NIC receives the network traffic. For example network traffic of a first NIC may be distributed to a first core while network traffic of a second NIC may be distributed to a second core. In some cases a core may process data from multiple NICs.

While illustrates a single vServer associated with a single core as is the case for VIP1 A VIP2 B and VIP3 C. In some embodiments a single vServer can be associated with one or more cores . In contrast one or more vServers can be associated with a single core . Associating a vServer with a core may include that core to process all functions associated with that particular vServer. In some embodiments each core executes a VIP having the same code and configuration. In other embodiments each core executes a VIP having the same code but different configuration. In some embodiments each core executes a VIP having different code and the same or different configuration.

Like vServers NICs can also be associated with particular cores . In many embodiments NICs can be connected to one or more cores such that when a NIC receives or transmits data packets a particular core handles the processing involved with receiving and transmitting the data packets. In one embodiment a single NIC can be associated with a single core as is the case with NIC1 D and NIC2 E. In other embodiments one or more NICs can be associated with a single core . In other embodiments a single NIC can be associated with one or more cores . In these embodiments load could be distributed amongst the one or more cores such that each core processes a substantially similar amount of load. A core associated with a NIC may process all functions and or data associated with that particular NIC.

While distributing work across cores based on data of VIPs or NICs may have a level of independency in some embodiments this may lead to unbalanced use of cores as illustrated by the varying loads of .

In some embodiments load work or network traffic can be distributed among cores based on any type and form of data flow. In another of these approaches the work may be divided or distributed among cores based on data flows. For example network traffic between a client and a server traversing the appliance may be distributed to and processed by one core of the plurality of cores. In some cases the core initially establishing the session or connection may be the core for which network traffic for that session or connection is distributed. In some embodiments the data flow is based on any unit or portion of network traffic such as a transaction a request response communication or traffic originating from an application on a client. In this manner and in some embodiments data flows between clients and servers traversing the appliance may be distributed in a more balanced manner than the other approaches.

In flow based data parallelism distribution of data is related to any type of flow of data such as request response pairings transactions sessions connections or application communications. For example network traffic between a client and a server traversing the appliance may be distributed to and processed by one core of the plurality of cores. In some cases the core initially establishing the session or connection may be the core for which network traffic for that session or connection is distributed. The distribution of data flow may be such that each core carries a substantially equal or relatively evenly distributed amount of load data or network traffic.

In some embodiments the data flow is based on any unit or portion of network traffic such as a transaction a request response communication or traffic originating from an application on a client. In this manner and in some embodiments data flows between clients and servers traversing the appliance may be distributed in a more balanced manner than the other approached. In one embodiment data flow can be distributed based on a transaction or a series of transactions. This transaction in some embodiments can be between a client and a server and can be characterized by an IP address or other packet identifier. For example Core 1 A can be dedicated to transactions between a particular client and a particular server therefore the load A on Core 1 A may be comprised of the network traffic associated with the transactions between the particular client and server. Allocating the network traffic to Core 1 A can be accomplished by routing all data packets originating from either the particular client or server to Core 1 A.

While work or load can be distributed to the cores based in part on transactions in other embodiments load or work can be allocated on a per packet basis. In these embodiments the appliance can intercept data packets and allocate them to a core having the least amount of load. For example the appliance could allocate a first incoming data packet to Core 1 A because the load A on Core 1 is less than the load B N on the rest of the cores B N. Once the first data packet is allocated to Core 1 A the amount of load A on Core 1 A is increased proportional to the amount of processing resources needed to process the first data packet. When the appliance intercepts a second data packet the appliance will allocate the load to Core 4 D because Core 4 D has the second least amount of load. Allocating data packets to the core with the least amount of load can in some embodiments ensure that the load A N distributed to each core remains substantially equal.

In other embodiments load can be allocated on a per unit basis where a section of network traffic is allocated to a particular core . The above mentioned example illustrates load balancing on a per packet basis. In other embodiments load can be allocated based on a number of packets such that every 10 100 or 1000 packets are allocated to the core having the least amount of load. The number of packets allocated to a core can be a number determined by an application user or administrator and can be any number greater than zero. In still other embodiments load can be allocated based on a time metric such that packets are distributed to a particular core for a predetermined amount of time. In these embodiments packets can be distributed to a particular core for five milliseconds or for any period of time determined by a user program system administrator or otherwise. After the predetermined time period elapses data packets are transmitted to a different core for the predetermined period of time.

Flow based data parallelism methods for distributing work load or network traffic among the one or more cores can comprise any combination of the above mentioned embodiments. These methods can be carried out by any part of the appliance by an application or set of executable instructions executing on one of the cores such as the packet engine or by any application program or agent executing on a computing device in communication with the appliance .

The functional and data parallelism computing schemes illustrated in can be combined in any manner to generate a hybrid parallelism or distributed processing scheme that encompasses function parallelism data parallelism flow based data parallelism or any portions thereof. In some cases the multi core system may use any type and form of load balancing schemes to distribute load among the one or more cores . The load balancing scheme may be used in any combination with any of the functional and data parallelism schemes or combinations thereof.

Illustrated in is an embodiment of a multi core system which may be any type and form of one or more systems appliances devices or components. This system in some embodiments can be included within an appliance having one or more processing cores A N. The system can further include one or more packet engines PE or packet processing engines PPE A N communicating with a memory bus . The memory bus may be used to communicate with the one or more processing cores A N. Also included within the system can be one or more network interface cards NIC and a flow distributor which can further communicate with the one or more processing cores A N. The flow distributor can comprise a Receive Side Scaler RSS or Receive Side Scaling RSS module .

Further referring to and in more detail in one embodiment the packet engine s A N can comprise any portion of the appliance described herein such as any portion of the appliance described in . The packet engine s A N can in some embodiments comprise any of the following elements the packet engine a network stack a cache manager a policy engine a compression engine an encryption engine a GUI a CLI shell services monitoring programs and any other software or hardware element able to receive data packets from one of either the memory bus or the one of more cores A N. In some embodiments the packet engine s A N can comprise one or more vServers A N or any portion thereof. In other embodiments the packet engine s A N can provide any combination of the following functionalities SSL VPN Intranet UP switching DNS packet acceleration App FW monitoring such as the monitoring provided by a monitoring agent functionalities associated with functioning as a TCP stack load balancing SSL offloading and processing content switching policy evaluation caching compression encoding decompression decoding application firewall functionalities XML processing and acceleration and SSL VPN connectivity.

The packet engine s A N can in some embodiments be associated with a particular server user client or network. When a packet engine becomes associated with a particular entity that packet engine can process data packets associated with that entity. For example should a packet engine be associated with a first user that packet engine will process and operate on packets generated by the first user or packets having a destination address associated with the first user. Similarly the packet engine may choose not to be associated with a particular entity such that the packet engine can process and otherwise operate on any data packets not generated by that entity or destined for that entity.

In some instances the packet engine s A N can be configured to carry out the any of the functional and or data parallelism schemes illustrated in . In these instances the packet engine s A N can distribute functions or data among the processing cores A N so that the distribution is according to the parallelism or distribution scheme. In some embodiments a single packet engine s A N carries out a load balancing scheme while in other embodiments one or more packet engine s A N carry out a load balancing scheme. Each core A N in one embodiment can be associated with a particular packet engine such that load balancing can be carried out by the packet engine . Load balancing may in this embodiment require that each packet engine associated with a core communicate with the other packet engines associated with cores so that the packet engines can collectively determine where to distribute load. One embodiment of this process can include an arbiter that receives votes from each packet engine for load. The arbiter can distribute load to each packet engine based in part on the age of the engine s vote and in some cases a priority value associated with the current amount of load on an engine s associated core .

Any of the packet engines running on the cores may run in user mode kernel or any combination thereof. In some embodiments the packet engine operates as an application or program running is user or application space. In these embodiments the packet engine may use any type and form of interface to access any functionality provided by the kernel. In some embodiments the packet engine operates in kernel mode or as part of the kernel. In some embodiments a first portion of the packet engine operates in user mode while a second portion of the packet engine operates in kernel mode. In some embodiments a first packet engine on a first core executes in kernel mode while a second packet engine on a second core executes in user mode. In some embodiments the packet engine or any portions thereof operates on or in conjunction with the NIC or any drivers thereof.

In some embodiments the memory bus can be any type and form of memory or computer bus. While a single memory bus is depicted in the system can comprise any number of memory buses . In one embodiment each packet engine can be associated with one or more individual memory buses .

The NIC can in some embodiments be any of the network interface cards or mechanisms described herein. The NIC can have any number of ports. The NIC can be designed and constructed to connect to any type and form of network . While a single NIC is illustrated the system can comprise any number of NICs . In some embodiments each core A N can be associated with one or more single NICs . Thus each core can be associated with a single NIC dedicated to a particular core . The cores A N can comprise any of the processors described herein. Further the cores A N can be configured according to any of the core configurations described herein. Still further the cores A N can have any of the core functionalities described herein. While illustrates seven cores A G any number of cores can be included within the system . In particular the system can comprise N cores where N is a whole number greater than zero.

A core may have or use memory that is allocated or assigned for use to that core. The memory may be considered private or local memory of that core and only accessible by that core. A core may have or use memory that is shared or assigned to multiple cores. The memory may be considered public or shared memory that is accessible by more than one core. A core may use any combination of private and public memory. With separate address spaces for each core some level of coordination is eliminated from the case of using the same address space. With a separate address space a core can perform work on information and data in the core s own address space without worrying about conflicts with other cores. Each packet engine may have a separate memory pool for TCP and or SSL connections.

Further referring to any of the functionality and or embodiments of the cores described above in connection with can be deployed in any embodiment of the virtualized environment described above in connection with . Instead of the functionality of the cores being deployed in the form of a physical processor such functionality may be deployed in a virtualized environment on any computing device such as a client server or appliance . In other embodiments instead of the functionality of the cores being deployed in the form of an appliance or a single device the functionality may be deployed across multiple devices in any arrangement. For example one device may comprise two or more cores and another device may comprise two or more cores. For example a multi core system may include a cluster of computing devices a server farm or network of computing devices. In some embodiments instead of the functionality of the cores being deployed in the form of cores the functionality may be deployed on a plurality of processors such as a plurality of single core processors.

In one embodiment the cores may be any type and form of processor. In some embodiments a core can function substantially similar to any processor or central processing unit described herein. In some embodiment the cores may comprise any portion of any processor described herein. While illustrates seven cores there can exist any N number of cores within an appliance where N is any whole number greater than one. In some embodiments the cores can be installed within a common appliance while in other embodiments the cores can be installed within one or more appliance s communicatively connected to one another. The cores can in some embodiments comprise graphics processing software while in other embodiments the cores provide general processing capabilities. The cores can be installed physically near each other and or can be communicatively connected to each other. The cores may be connected by any type and form of bus or subsystem physically and or communicatively coupled to the cores for transferring data between to from and or between the cores.

While each core can comprise software for communicating with other cores in some embodiments a core manager Not Shown can facilitate communication between each core . In some embodiments the kernel may provide core management. The cores may interface or communicate with each other using a variety of interface mechanisms. In some embodiments core to core messaging may be used to communicate between cores such as a first core sending a message or data to a second core via a bus or subsystem connecting the cores. In some embodiments cores may communicate via any type and form of shared memory interface. In one embodiment there may be one or more memory locations shared among all the cores. In some embodiments each core may have separate memory locations shared with each other core. For example a first core may have a first shared memory with a second core and a second share memory with a third core. In some embodiments cores may communicate via any type of programming or API such as function calls via the kernel. In some embodiments the operating system may recognize and support multiple core devices and provide interfaces and API for inter core communications.

The flow distributor can be any application program library script task service process or any type and form of executable instructions executing on any type and form of hardware. In some embodiments the flow distributor may any design and construction of circuitry to perform any of the operations and functions described herein. In some embodiments the flow distributor distribute forwards routes controls and ors manage the distribution of data packets among the cores and or packet engine or VIPs running on the cores. The flow distributor in some embodiments can be referred to as an interface master. In one embodiment the flow distributor comprises a set of executable instructions executing on a core or processor of the appliance . In another embodiment the flow distributor comprises a set of executable instructions executing on a computing machine in communication with the appliance . In some embodiments the flow distributor comprises a set of executable instructions executing on a NIC such as firmware. In still other embodiments the flow distributor comprises any combination of software and hardware to distribute data packets among cores or processors. In one embodiment the flow distributor executes on at least one of the cores A N while in other embodiments a separate flow distributor assigned to each core A N executes on an associated core A N. The flow distributor may use any type and form of statistical or probabilistic algorithms or decision making to balance the flows across the cores. The hardware of the appliance such as a NIC or the kernel may be designed and constructed to support sequential operations across the NICs and or cores.

In embodiments where the system comprises one or more flow distributors each flow distributor can be associated with a processor or a packet engine . The flow distributors can comprise an interface mechanism that allows each flow distributor to communicate with the other flow distributors executing within the system . In one instance the one or more flow distributors can determine how to balance load by communicating with each other. This process can operate substantially similarly to the process described above for submitting votes to an arbiter which then determines which flow distributor should receive the load. In other embodiments a first flow distributor can identify the load on an associated core and determine whether to forward a first data packet to the associated core based on any of the following criteria the load on the associated core is above a predetermined threshold the load on the associated core is below a predetermined threshold the load on the associated core is less than the load on the other cores or any other metric that can be used to determine where to forward data packets based in part on the amount of load on a processor.

The flow distributor can distribute network traffic among the cores according to a distribution computing or load balancing scheme such as those described herein. In one embodiment the flow distributor can distribute network traffic or pad according to any one of a functional parallelism distribution scheme a data parallelism load distribution scheme a flow based data parallelism distribution scheme or any combination of these distribution scheme or any load balancing scheme for distributing load among multiple processors. The flow distributor can therefore act as a load distributor by taking in data packets and distributing them across the processors according to an operative load balancing or distribution scheme. In one embodiment the flow distributor can comprise one or more operations functions or logic to determine how to distribute packers work or load accordingly. In still other embodiments the flow distributor can comprise one or more sub operations functions or logic that can identify a source address and a destination address associated with a data packet and distribute packets accordingly.

In some embodiments the flow distributor can comprise a receive side scaling RSS network driver module or any type and form of executable instructions which distribute data packets among the one or more cores . The RSS module can comprise any combination of hardware and software In some embodiments the RSS module works in conjunction with the flow distributor to distribute data packets across the cores A N or among multiple processors in a multi processor network. The RSS module can execute within the NIC in some embodiments and in other embodiments can execute on any one of the cores .

In some embodiments the RSS module uses the MICROSOFT receive side scaling RSS scheme. In one embodiment RSS is a Microsoft Scalable Networking initiative technology that enables receive processing to be balanced across multiple processors in the system while maintaining in order delivery of the data. The RSS may use any type and form of hashing scheme to determine a core or processor for processing a network packet.

The RSS module can apply any type and form hash function such as the Toeplitz hash function. The hash function may be applied to the hash type or any the sequence of values. The hash function may be a secure hash of any security level or is otherwise cryptographically secure. The has function may use a hash key. The size of the key is dependent upon the hash function. For the Toeplitz hash the size may be 40 bytes for IPv6 and 16 bytes for IPv4.

The hash function may be designed and constructed based on any one or more criteria or design goals. In some embodiments a hash function may be used that provides an even distribution of hash result for different hash inputs and different hash types including TCP IPv4 TCP IPv6 IPv4 and IPv6 headers. In some embodiments a hash function may be used that provides a hash result that is evenly distributed when a small number of buckets are present for example two or four . In some embodiments hash function may be used that provides a hash result that is randomly distributed when a large number of buckets were present for example 64 buckets . In some embodiments the hash function is determined based on a level of computational or resource usage. In some embodiments the hash function is determined based on ease or difficulty of implementing the hash in hardware. In some embodiments the hash function is determined bases on the ease or difficulty of a malicious remote host to send packets that would all hash to the same bucket.

The RSS may generate hashes from any type and form of input such as a sequence of values. This sequence of values can include any portion of the network packet such as any header field or payload of network packet or portions thereof. In some embodiments the input to the hash may be referred to as a hash type and include any tuples of information associated with a network packet or data flow such as any of the following a four tuple comprising at least two IP addresses and two ports a four tuple comprising any four sets of values a six tuple a two tuple and or any other sequence of numbers or values. The following are example of hash types that may be used by RSS 

The hash result or any portion thereof may used to identify a core or entity such as a packet engine or VIP for distributing a network packet. In some embodiments one or more hash bits or mask are applied to the hash result. The hash bit or mask may be any number of bits or bytes. A NIC may support any number of bits such as seven bits. The network stack may set the actual number of bits to be used during initialization. The number will be between 1 and 7 inclusive.

The hash result may be used to identify the core or entity via any type and form of table such as a bucket table or indirection table. In some embodiments the number of hash result bits are used to index into the table. The range of the hash mask may effectively define the size of the indirection table. Any portion of the hash result or the hast result itself may be used to index the indirection table. The values in the table may identify any of the cores or processor such as by a core or processor identifier. In some embodiments all of the cores of the multi core system are identified in the table. In other embodiments a port of the cores of the multi core system are identified in the table. The indirection table may comprise any number of buckets for example 2 to 128 buckets that may be indexed by a hash mask. Each bucket may comprise a range of index values that identify a core or processor. In some embodiments the flow controller and or RSS module may rebalance the network rebalance the network load by changing the indirection table.

In some embodiments the multi core system does not include a RSS driver or RSS module . In some of these embodiments a software steering module Not Shown or a software embodiment of the RSS module within the system can operate in conjunction with or as part of the flow distributor to steer packets to cores within the multi core system .

The flow distributor in some embodiments executes within any module or program on the appliance on any one of the cores and on any one of the devices or components included within the multi core system . In some embodiments the flow distributor can execute on the first core A while in other embodiments the flow distributor can execute on the NIC . In still other embodiments an instance of the flow distributor can execute on each core included in the multi core system . In this embodiment each instance of the flow distributor can communicate with other instances of the flow distributor to forward packets back and forth across the cores . There exist situations where a response to a request packet may not be processed by the same core i.e. the first core processes the request while the second core processes the response. In these situations the instances of the flow distributor can intercept the packet and forward it to the desired or correct core i.e. a flow distributor instance can forward the response to the first core. Multiple instances of the flow distributor can execute on any number of cores and any combination of cores .

The flow distributor may operate responsive to any one or more rules or policies. The rules may identify a core or packet processing engine to receive a network packet data or data flow. The rules may identify any type and form of tuple information related to a network packet such as a 4 tuple of source and destination IP address and source and destination ports. Based on a received packet matching the tuple specified by the rule the flow distributor may forward the packet to a core or packet engine. In some embodiments the packet is forwarded to a core via shared memory and or core to core messaging.

Although illustrates the flow distributor as executing within the multi core system in some embodiments the flow distributor can execute on a computing device or appliance remotely located from the multi core system . In such an embodiment the flow distributor can communicate with the multi core system to take in data packets and distribute the packets across the one or more cores . The flow distributor can in one embodiment receive data packets destined for the appliance apply a distribution scheme to the received data packets and distribute the data packets to the one or more cores of the multi core system . In one embodiment the flow distributor can be included in a router or other appliance such that the router can target particular cores by altering meta data associated with each packet so that each packet is targeted towards a sub node of the multi core system . In such an embodiment CISCO s vn tag mechanism can be used to alter or tag each packet with the appropriate meta data.

Illustrated in is an embodiment of a multi core system comprising one or more processing cores A N. In brief overview one of the cores can be designated as a control core A and can be used as a control plane for the other cores . The other cores may be secondary cores which operate in a data plane while the control core provides the control plane. The cores A N may share a global cache . While the control core provides a control plane the other cores in the multi core system form or provide a data plane. These cores perform data processing functionality on network traffic while the control provides initialization configuration and control of the multi core system.

Further referring to and in more detail the cores A N as well as the control core A can be any processor described herein. Furthermore the cores A N and the control core A can be any processor able to function within the system described in . Still further the cores A N and the control core A can be any core or group of cores described herein. The control core may be a different type of core or processor than the other cores. In some embodiments the control may operate a different packet engine or have a packet engine configured differently than the packet engines of the other cores.

Any portion of the memory of each of the cores may be allocated to or used for a global cache that is shared by the cores. In brief overview a predetermined percentage or predetermined amount of each of the memory of each core may be used for the global cache. For example 50 of each memory of each code may be dedicated or allocated to the shared global cache. That is in the illustrated embodiment 2 GB of each core excluding the control plane core or core 1 may be used to form a 28 GB shared global cache. The configuration of the control plane such as via the configuration services may determine the amount of memory used for the shared global cache. In some embodiments each core may provide a different amount of memory for use by the global cache. In other embodiments any one core may not provide any memory or use the global cache. In some embodiments any of the cores may also have a local cache in memory not allocated to the global shared memory. Each of the cores may store any portion of network traffic to the global shared cache. Each of the cores may check the cache for any content to use in a request or response. Any of the cores may obtain content from the global shared cache to use in a data flow request or response.

The global cache can be any type and form of memory or storage element such as any memory or storage element described herein. In some embodiments the cores may have access to a predetermined amount of memory i.e. 32 GB or any other memory amount commensurate with the system . The global cache can be allocated from that predetermined amount of memory while the rest of the available memory can be allocated among the cores . In other embodiments each core can have a predetermined amount of memory. The global cache can comprise an amount of the memory allocated to each core . This memory amount can be measured in bytes or can be measured as a percentage of the memory allocated to each core . Thus the global cache can comprise 1 GB of memory from the memory associated with each core or can comprise 20 percent or one half of the memory associated with each core . In some embodiments only a portion of the cores provide memory to the global cache while in other embodiments the global cache can comprise memory not allocated to the cores .

Each core can use the global cache to store network traffic or cache data. In some embodiments the packet engines of the core use the global cache to cache and use data stored by the plurality of packet engines. For example the cache manager of and cache functionality of may use the global cache to share data for acceleration. For example each of the packet engines may store responses such as HTML data to the global cache. Any of the cache managers operating on a core may access the global cache to server caches responses to client requests.

In some embodiments the cores can use the global cache to store a port allocation table which can be used to determine data flow based in part on ports. In other embodiments the cores can use the global cache to store an address lookup table or any other table or list that can be used by the flow distributor to determine where to direct incoming and outgoing data packets. The cores can in some embodiments read from and write to cache while in other embodiments the cores can only read from or write to cache . The cores may use the global cache to perform core to core communications.

The global cache may be sectioned into individual memory sections where each section can be dedicated to a particular core . In one embodiment the control core A can receive a greater amount of available cache while the other cores can receiving varying amounts or access to the global cache .

In some embodiments the system can comprise a control core A. While illustrates core 1 A as the control core the control core can be any core within the appliance or multi core system. Further while only a single control core is depicted the system can comprise one or more control cores each having a level of control over the system. In some embodiments one or more control cores can each control a particular aspect of the system . For example one core can control deciding which distribution scheme to use while another core can determine the size of the global cache .

The control plane of the multi core system may be the designation and configuration of a core as the dedicated management core or as a master core. This control plane core may provide control management and coordination of operation and functionality the plurality of cores in the multi core system. This control plane core may provide control management and coordination of allocation and use of memory of the system among the plurality of cores in the multi core system including initialization and configuration of the same. In some embodiments the control plane includes the flow distributor for controlling the assignment of data flows to cores and the distribution of network packets to cores based on data flows. In some embodiments the control plane core runs a packet engine and in other embodiments the control plane core is dedicated to management and control of the other cores of the system.

The control core A can exercise a level of control over the other cores such as determining how much memory should be allocated to each core or determining which core should be assigned to handle a particular function or hardware software entity. The control core A in some embodiments can exercise control over those cores within the control plan . Thus there can exist processors outside of the control plane which are not controlled by the control core A. Determining the boundaries of the control plane can include maintaining by the control core A or agent executing within the system a list of those cores controlled by the control core A. The control core A can control any of the following initialization of a core determining when a core is unavailable re distributing load to other cores when one core fails determining which distribution scheme to implement determining which core should receive network traffic determining how much cache should be allocated to each core determining whether to assign a particular function or element to a particular core determining whether to permit cores to communicate with one another determining the size of the global cache and any other determination of a function configuration or operation of the cores within the system .

F. Systems and Methods for Authentication Authorization and Auditing for Application Traffic in a Multi Core Environment

In some embodiments of a traffic management system a client transmits a request to access a service provided by one or more servers . The request may be intercepted and processed by an intermediary such as an appliance that provides traffic management functions. By way of example and in view of various traffic management and load balancing products the appliance can be any of the product embodiments referred to as NetScaler manufactured by Citrix Systems Inc. BigIP device manufactured by F5 Networks Inc. AppDirector appliance manufactured by Radware LTD or appliances manufactured by Cisco Systems Inc. or Nortel Networks Inc. The appliance may have one or more virtual servers A N configured constructed or designed to provide various network communications functionality as described above in connection with .

The appliance may include or communicate with one or more traffic management vServers providing traffic management TM functionality between the client and the one or more servers over one or more networks . In some embodiments the appliance includes or communicates with one or more authentication AuthN vServers that provide authentication services for controlling client access to the service . To provide AAA support for traffic management features traffic management vServers and authentication vServers may communicate to process any aspect of client server access and traffic. Any of the traffic management vServers and authentication vServers may also reside in one or more appliances or servers and communicate over one or more networks . In addition any number of traffic management vServers and authentication vServers can be hierarchically connected or arranged either structurally through their respective host servers or logically to provide traffic management and authentication services. vServer

A traffic management vServer may be any type of virtual server for performing traffic management activities including load balancing LB content switching CS and cache redirection CR . For example cache redirection vServers in some embodiments identifies cacheable and non cacheable messages for redirection to another server that may be a vServer such as a LB vServer a cache server or an origin server. By selectively redirecting traffic some requested content such as frequently accessed content may be retrieved from caches. In one of these embodiments cache redirection identifies cacheable and non cacheable requests for HTTP transactions. Cache redirection may identify cacheable and non cacheable requests for HTTP transactions by parsing the URL and the HTTP header of each request. Content switching on the other hand may include a variety of manipulation techniques for getting data from one or more sources to an endpoint in a way that may optimize use of a network.

A traffic management vServer may include any embodiment of the vServer described above in connection with and provide any type of functionality and feature. The traffic management vServer may operate according to a set of one or more TM policies. Moreover the TM vServer can include or operate with a policy engine such as any embodiment of the policy engine described above in connection with . In some embodiments one or more traffic management features may be combined from one or more TM vServers and one or more sets of TM policies. In one embodiment the one or more features may combine to the extent that they do not conflict with each other. By way of illustration and in one embodiment features supported by a TM vServer and or traffic management policies can include but are not limited to 

A traffic management vServer may include and or operate a network engine . The network engine can be a combination of hardware and software. The network engine may incorporate one or more features from any embodiment of the integrated packet engine described above in connection with . The network engine may include a transceiver for receiving and transmitting network traffic. In some embodiments the network engine may also incorporate a hardware interface from the appliance for example to connect with the network and other network components. In one embodiment the network engine interfaces with the client and or the authentication vServer . The network engine can perform any type or form of data processing such as compression encryption acceleration buffering retrieval translation redirection and protocol processing. In addition the network engine may access and or update a stored session table such as a AAA TM session table. The network engine can include or communicate with a policy engine and access one or more policies. In one embodiment the network engine can provide and or apply the one or more policies accessed. In some embodiments the network engine may provide some or all of the functions of the traffic management vServer

An authentication vServer may be a virtual server performing any combination of authorization authentication and auditing accounting features of an AAA service. In some embodiments an authentication vServer may comprise any embodiment of the vServer described above in connection with and provide any number and type of functionality and feature. Further the authentication vServer can include and or operate with any embodiment of the policy engine described above in connection with . In some embodiments the authentication vServer may include any embodiment and or feature of a virtual private network VPN vServer for authenticating a user accessing a TM vServer and or a service . In one of these embodiments the VPN vServer may be a light weight vServer.

In some embodiments an authentication vServer may reside in or communicate with one or more authentication servers such as Remote Access Remote Authentication Dial In User Service RADIUS servers firewalls access control servers and Authentication Authorization and Auditing Accounting AAA servers clustered or distributed over one or more networks .

The authentication vServer can support flexible policy based rules. The authentication vServer can also provide any of the AAA services accordingly to various access request scenarios. The authentication vServer may operate according to a set of one or more authentication policies . The authentication policies may also include at least one authorization policy and or at least one auditing accounting hereafter generally referred to as auditing policy. In some embodiments authorization may be performed by authorization policies configured on the traffic management vServer . In some of these embodiments the authentication vServer only provides authentication related services. Further the authentication policies may include at least one VPN policy. In some embodiments authentication support for traffic management may be implemented by combining existing VPN features such as VPN policies and data structures with other authentication features. In some embodiments VPN features that may be incorporated into the AAA support for traffic management include but are not limited to 

An authentication vServer may support any number type and form of authentication and or authorization servers such as Active Directory AD Lightweight Directory Access Protocol LDAP RADIUS RSA SecureID Terminal Access Controller Access Control TACACS and TACACS WINDOWS NT LAN Manager NTLM and Smart Card sign on. In some embodiments a plurality of authentication vServers may support two or more different types of authentication. In one of these embodiments an authentication vServer can be selected for the type of authentication e.g. TACACS the authentication vServer supports. A type of authentication available through an authentication vServer may be supported by one or more authentication and or authorization servers. For example two RADIUS servers may support a RADIUS vServer. One or both RADIUS servers may be bound or assigned to the authentication vServer e.g. statically or dynamically based on one or more factors such as geographical proximity network traffic and processing load on each server. In some embodiments one or more authentication servers are associated with or assigned or bound to an authentication vServer based on application of one or more policies. The one or more authentication servers may be structurally or logically arranged in cascading form for example.

Various authentication configurations such as Two Factor Authentication T FA or dual password authentication can be supported and customized based on context dynamically or otherwise. The authentication vServer may also support certificate based authentication. In some embodiments AAA features may be combined from one or more authentication vServers possibly in conjunction with one or more sets of AAA or authentication policies. An authentication vServer may be associated with or assigned or bound to one or more TM vServers in a number of different configurations to be discussed below. An authentication server may be associated with a TM vServer statically through pre defined bindings or dynamically based on one or more policies.

Referring now to an embodiment of a system for associating an authentication vServer to one or more TM vServers is depicted. The authentication vServer may be statically bound to one TM vServer or shared by multiple TM vServers including static and or non static bindings.

Referring now to two embodiments of a system for associating an authentication vServer to one or more TM vServers are depicted. In one embodiment a first authentication vServer may be associated to a plurality of TM vServers while a second authentication vServer may be associated to one TM vServer . Such groupings or assignments may be created depending on factors such as traffic management domain size load and geographical considerations such as grouping proximity.

In some embodiments where a plurality of authentication vServers are configured together with a TM vServer a tracking and or verification process may ensure that a client request is processed consistently between the TM vServer and a selected authentication vServer . For example the TM vServer may verify that a redirect message is received from the same authentication vServer selected when the TM vServer received the initial client request.

Referring now to an embodiment of a system for associating one or more authentication vServers to a TM vServers is depicted. In brief overview the system includes one or more policies a plurality of authentication vServers N and a TM vServer . An authentication vServer can be dynamically assigned to a TM vServers based on one or more policies. The one or more policies may be bound to a TM vServer during runtime. Moreover any of the one or more authentication vServers can be assigned to the TM vServer via the one or more policies during runtime to establish an authentication session.

In some embodiments the one or more policies may include an AppFW policy. An AppFW policy operates in conjunction with an AppFW module sometimes referred to as an AppSecure module in the context of an appliance manufactured by Citrix Systems Inc. The AppSecure module may include logic functions or operations for performing any type and form of content rewriting such as URL rewriting. In some embodiments the AppSecure module can perform any type or form of content injection into a request and or response between a client and a server. The AppSecure module may inject scripts into a response to the client such as a JavaScript to perform any type and form of desired functionality. In one embodiment the AppFw policy may be designed and constructed to rewrite URLs of requests and responses to redirect to or otherwise associate with a particular authentication vServer . For example links e.g. URLs in messages received during an authentication session can be modified by a TM vServer in such a way that the links point to a particular authentication vServer

Authentication vServers can be associated to any form or type of TM vServers including any combination and hierarchical arrangement of CR CS and LB vServers. A unit of traffic such as a message or packet may be redirected from a first TM vServer to another TM vServer in the hierarchy. This process may occur over several levels of the hierarchy until a final TM vServer is assigned to manage the traffic. In some embodiments where a plurality of authentication vServers is associated to a hierarchy of TM vServers. The authentication vServer associated with the most specific TM vServer takes precedence in providing AAA functions. In some other embodiments however an authentication vServer associated with a TM vServer at the top of the hierarchy takes precedence. A TM vServer managing the overall traffic responsive to a client request may be assigned to the top of the hierarchy. In still other embodiments the precedence of any authentication vServer may be determined by one or more policies such as a policy associated with the TM vServer at the top of the hierarchy.

Referring now to an embodiment of a system for providing AAA support to traffic management is depicted. In brief overview the system includes a plurality of CR CS and LB TM vServers associated with a plurality of authentication vServers and arranged in a hierarchical configuration. The system may include any combination and embodiment of configurations described above in connection with . In some embodiments the hierarchical configuration supports content aware traffic management and authentication. For example in one embodiment the traffic received at CR vServer can be divided into cacheable and non cacheable traffic. The traffic can include any type and form of messages between one or more clients servers and intermediaries including requests and responses. In some embodiments cacheable traffic is directed to CS vServer and non cacheable traffic to CS vServer . The CS vServer may distribute the non cacheable traffic across LB vServers while CS vServer may distribute the cacheable traffic between LB vServers .

In further details of and by way of illustration of one embodiment of an hierarchical configuration the configuration includes dynamically associated authentication vServers at LB vServers and CS vServer statically associated authentication vServers at LB vServer CS vServer and CR vServer and no authentication vServer associated to LB vServer . For example if LB vServer is selected to perform traffic management the authentication vServer associated to the LB vServer may provide the AAA features. In another embodiment if a TM vServer not associated to any authentication vServer is selected to perform traffic management AAA features can be provided by an authentication vServer associated with a parent of the TM vServer. For example if LB vServer is selected an authentication vServer associated to CS vServer can provide the AAA features. If a TM vServer has a plurality of parents at a same or different level in the hierarchy one of the plurality of parents may provide an associated authentication vServer for example according to authentication vServer availability geographical or logical proximity and or one or more policies.

Referring now to another embodiment of a system for AAA support to traffic management is depicted. In further details illustrates an embodiment in which one authentication vServer may be shared by a plurality of TM vServers. In some embodiments a single authentication vServer is configured for a system so that tracking and or verification processes and or policies that bind the authentication vServer to a TM vServer may not be required. In some embodiments a parent TM vServer may direct all traffic management responsibilities to a child TM vServer so that an authentication vServer is associated. For example CS vServer may direct all traffic management responsibilities to LB vServer rather than LB vServer . In some other embodiments traffic management responsibilities directed to a TM vServer not associated with any authentication vServer may be managed without AAA support or may be redirected to another TM vServer associated with an authentication vServer

Referring now to an embodiment of a system for providing AAA support for traffic management is depicted. In brief overview the system includes one or more TM vServers hereafter generally referred to as a TM vServer associated with one or more authentication vServers hereafter generally referred to as an authentication vServer . These vServers may be arranged in any manner such as in accordance to any embodiment of the configurations described above in connection with . The TM vServer provides traffic management services between a client and one or more servers in a server farm according to one or more traffic management policies . AAA services for any client server traffic may be provided by the authentication vServer according to one or more authentication policies . In addition a collection agent may obtain information from the client for one or both of the TM vServer and the authentication vServer. Although only one client collection agent application server farm and storage are depicted in the embodiment shown in it should be understood that the system may provide multiple ones of any or each of those components.

The collection agent may include any of the embodiments or components of the collection agent described above in connection with and or monitoring agent described above in connection with . The collection agent may be generated from any script or program residing in the appliance storage and or any other machine or storage device in the network . In some embodiments a script and or program is transmitted to the client and generates the collection agent . In some other embodiments the collection agent executes in the appliance or any other machine in the network and remotely polls requests or collects information from the client . The collection agent script and or program may be part of an endpoint auditing EPA system or solution for collecting attributes of an endpoint device such as the client .

EPA may incorporate one or more of endpoint analysis endpoint scanning and endpoint detection. An EPA solution can perform a range of security identity and device integrity checks on a client prior to making an AAA and or traffic management decision. An EPA solution may for example scan a client for file and registry settings and check that no unauthorized illegal or unlicensed executable code including spy ware mal ware and trojans is introduced. An EPA solution when used in an embodiment of the system may also incorporate all or part of any embodiment of the endpoint detection and scanning techniques and or components described above in connection with . One embodiment of an EPA solution is the CITRIX Access Gateway Advanced Endpoint Analysis Software Development Kit Endpoint Analysis SDK . Other embodiments of EPA solutions includes solutions from EPA FACTORY and EXTENTRIX.

In further details of the appliance may operate or execute one both or none of the TM vServer and the authentication vServer. In some embodiments the authentication vServers executes on a first appliance or a first group of appliances and the TM vServers executes on a second appliance or a second group of appliances . In one embodiment the appliance is configured designed and constructed to use a proprietary or custom protocol and or communication model. In another embodiment the appliance may support one or more protocol and or communication models. The appliance can include or communicate with one or more policy engines . In some embodiments the traffic management and or authentication services each operates or executes on one or a combination of the user space and kernel space of one or more appliances . The TM vServer and the authentication vServer may reside in one or more servers and or intermediaries over a network as discussed in connection with . The TM vServer and or the authentication vServer may include or communicate with the one or more policy engines .

The one or more policy engines may each reside on any component of the system . Each of the one or more policy engines can be any embodiment of the policy engine described above in connection with . Further each policy engine can be statically or dynamically bound to one or more policies or sets of policies such as the traffic management policies and the authentication policies . In addition the one or more policy engines may identify one or more policies for the TM vServer and the authentication vServer. In some embodiments the one or more policy engines applies the one or more policies for the TM vServer or the authentication vServer and sends one or more results from the application to the TM vServer or the authentication vServer. In other embodiments the one or more policy engines sends the one or more identified policies to the TM vServer and or the authentication vServer.

The appliance may include a storage device . The storage device may be any embodiment of the storage device described above in connection with the main memory or cache described above in connection with and the memory described above in connection with . The storage device can store any type or form of information including persistent information e.g. client information persistent over an authentication session and temporary information intermediate data generated during runtime . In some embodiments the storage may store one or more URLs such as URL associated with client requests. The storage device may also store a domain address locator index or other identifier of a machine or vServer such as the domain of the TM vServer. The storage device may also store one or more policies such as traffic management policies and authentication policies . Further the storage device may store a AAA TM session table tracking or logging AAA and traffic management transactions.

The traffic management policies the authentication policies and the one or more policy engines hereafter generally referred to as policy or policy engine may include any form and type of policies rules procedures requirements instructions guidelines and recommendations applied and or output in response to a set of inputs and or conditions. Some of the traffic management policies and or the authentication policies may be persistent for example over a connection session or an authentication session indefinitely or over a fixed period of time. Some of the traffic management policies and or the authentication policies may be persistent until an occurrence of an event. Some of the traffic management policies and the authentication policies may be static predefined by an administrator or generated by machine. Some of the traffic management policies and the authentication policies may be dynamic for example adapting or adjusting according to conditions including any combination of conditions of the network traffic patterns server loads access frequency and access history. Moreover some of these policies may be modified and or generated by other policies.

The traffic management policies and the authentication policies may reside in one or more storage devices any where in the network . Such a storage device may be any embodiment of the type of storage described in connection with the main memory or cache described in connection with the memory described in connection with and the storage device described in connection with . In some embodiments the traffic management policies and the authentication policies reside together such as in the appliance and or the storage device . In other embodiments these policies can include groups of policies separated geographically or logically such as policies distributed accordingly to the configurations described above in connection with .

The traffic management policies may include any policy that directly or indirectly affects traffic management activities and or decisions. For example the traffic management policies may include policies applied in conjunction with non traffic management policies e.g. authentication policies to make traffic management decisions. Further traffic management policies can include any policy relating to 1 traffic routing redirection addressing distribution 2 selection or assignment of server server farm gateway client vServer appliance or other network components 3 traffic data encryption compression acceleration buffering and other types of processing 4 traffic overflow support 5 network or network component failure support 6 traffic data collection analysis reporting and 7 management of service level.

The authentication policies may include any policy that directly or indirectly affects AAA activities and or decisions. For example the authentication policies may include policies applied in conjunction with non AAA policies e.g. traffic management policies to make an AAA decision. In some embodiments the authentication policies may include any policy associated with security and access control features such as secure sockets layer SSL virtual private network VPN firewalls encryption watermarking security keys user or client registration contextual access level and EPA. The authentication policies can support all or any subset of the features supported by the authentication vServer and the associated authentication servers .

In some embodiments authorization and or auditing accounting policies are grouped apart from authentication policies either logically partitioned or physically stored in different storage devices. One or more of the authentication authorization and or auditing accounting policies may be applied before after or in conjunction with another of these policies. Any one of these AAA policies may be applied upon certain occurrences satisfaction of conditions or invoked by another policy. Moreover any one of these AAA policies may be associated with or bound to an AAA or authentication vServer. Further any of these AAA policies may be associated with or bound to a TM vServer via the AAA or authentication vServer for example according to any embodiment of the configurations described above in connection with .

An authorization policy associated with or bound to the TM vServer may be applied in response to a request from a client . In some embodiments an authorization policy may be applied after the client has been authenticated. In one of these embodiments authorization policies bound to the TM vServer is applied to associated traffic after the client has been authenticated. An authorization policy may be associated with or bound to a user group vServer or global level. In some embodiments authorization policies bound to certain levels may be supported or preferred. For example in one embodiment support for authorization policies at the TM vServer level may be readily supported since all traffic is directed to the TM vServer. A presence or absence of a first level of authorization policies may also affect support for a second level because of conflicts redundancy synergy or otherwise. For example if policies at a group level such as content filter policies are already supported this may conflict with or be preferred over policies at the vServer level. For example in some embodiments a decision to support group level policies such as a default authorization group for VPN features may be evaluated in view of existing or alternative global authorization policies on various traffic management features.

In some embodiments authentication authorization and auditing features are segregated and or provided by different vServers. For example and in one embodiment authentication policies may be bound to the authentication vServer and applied during authentication session establishment to validate user credentials. After the session is established the session may become disassociated with the authentication policies while authorization policies bound to a given user or group may be introduced. These authorization policies may then be evaluated at runtime to make a determination against each given request. Therefore in some embodiments there may be no overlap between authentication an authorization policies.

An auditing policy may have properties or characteristics substantially similar to an authentication or authorization policy. An auditing policy may be bound to one or more of a TM vServer an authentication session and a traffic management session. Features provided by any form or type of AAA or authentication vServers and servers may be supported by auditing policies. Auditing features supported may include support for the following although not limited by 

Policies can be set at a user group vServer global or other level or set for multiple levels. Certain levels or groups of levels may be supported in various embodiments of the invention. In some embodiments any existing framework for policy levels e.g. of authentication policies may be extended to a different set of policies e.g. traffic management policies . For example in one embodiment new authentication policies for supporting traffic management can leverage on the existing user or group framework for auditing policies by inheriting the associated user or group definitions and databases. Priority amongst policies may be specified in a hierarchical order or flat. In some embodiments there is a flat priority space for policies. The order of policies to be evaluated for certain policies such as traffic management policies may be determined at configuration time. An ordered list of such policies may be maintained after determination and applied across a plurality of authentication sessions for example. Priority ordering of some other policies may be determined at runtime. The policy level in which an policy falls into may determine whether priority ordering is determined at runtime or during configuration.

In further details of the policies and vServers discussed above can operate to process a client request for access to a server . This request is processed over a plurality of transactions involving a plurality of requests and responses between the client the TM vServer and the authentication vServer. The requests and responses can be any type or form of message in any communication protocol proprietary or otherwise. In some embodiments the message may be in HTTP HTTPS or a similar protocol. These messages can include any type or form of information such as information associated with the client a requested resource the appliance and the authentication session .

In some embodiments the client initiates a request that is intercepted or routed to the TM vServer. This request may include a URL . The URL may be a pointer to a resource or an identifier for a server to connect to. In some embodiments the request may not include the URL . The request can also include information such as the address of the intermediary or appliance and information that identifies policies and or authentication servers to use. Further the request can include information indicating whether the client is authenticated and or whether authenticated access is needed. For example in some embodiments the request may include a domain session cookie. If the domain session cookie is valid this can indicate that the client and or user sending the request has been authenticated. Authentication or re authentication may be performed if the domain session cookie is invalid or if the associated authentication session associated with the domain session cookie has expired.

The domain session cookie can provide authentication session information such as an index or identifier to a valid authentication session. The domain session cookie can be used to keep track of state information of authenticated traffic going through the traffic management vServer. In one embodiment if a request received at the traffic management vServer includes a valid domain session cookie an associated authentication session will be refreshed or stay active for another predetermined period of time. In one embodiment a domain session cookie includes one or more of the following information 

In some embodiments the authentication session may be created before authentication. In one of these embodiments exposure of the domain session cookie may cause certain security issues and traffic received by the traffic management vServer may have to be securely protected. In another of these embodiments exposure of the domain session cookie raises no security issues. In other embodiments the authentication session is created upon or after authentication. For example in one of these embodiments the authentication session is created responsive to authentication.

Referring again to and in further details the TM vServer can initiate a response responsive to the request . In some embodiments the response is a 200 OK HTTP response. The response may include a page or form for display at the client . The response may also include any number type and form of fields buttons and other widgets for display and or user interaction. The response may include the URL . In some embodiments where the request does not include any URLs the response can include a URL that may be generated by the TM vServer. This URL may be generated at least in part from information included in the request and or application of one or more traffic management policies . The URL may be included in the response in a hidden form or hidden field. In some embodiments the input type of such a hidden field or form is specified as HIDDEN . A document such as a html document associated with a hidden form or field may not show the hidden form or field nor the value or content of the hidden form or field when displayed in a browser. In some embodiments a user presented with the document may not interact with the hidden form or field. The response may also include a submit on load event handler. The submit on load event handler may include any collection of commands or any form or type of script or program that initiates or triggers a message upon a predetermined event. For example a message to submit the hidden form or field may be triggered when a user clicks on a submit button.

The response may include instructions to redirect the request to an authentication server. The instructions may be generated by the TM vServer generated at least in part from information included in the request and or application of one or more traffic management policies . The instructions can include any type or form of commands such as HTTP commands or any type or form of program code. Further the instructions may be customized to the type or capabilities of the client . In some embodiments the instructions may include or be included in a script . The script may be executed by the client or may be self executing when received at the client . The script may be an event handler. In other embodiments the script may be independent from the instructions and or serve a different purpose. The script may trigger generate or otherwise initiate a second or additional request by the client .

In some embodiments the request is used for passing or redirecting the URL and or other information to a destination such as the authentication vServer. In other embodiments a response may replace the response in passing the URL and or other information to the destination. The request may include a redirect location header. The redirect location header may include any type or form of information such as information for retrieving a login page. In one embodiment the redirect location header can have the following format 

In some embodiments the request is triggered by a user action such as a mouse click on a submit button associated with the response received at the client . In other embodiments the request automatically triggers when the response is received at the client . In one embodiment the script may generate a request as a POST message. In some embodiments a POST message is able to include more content such as a longer URL than a redirection message can include in its HTTP header for example. The POST message may include a URL . The URL of the request may be a pointer to any type or form of a script executable file program or resource. In some embodiments the URL may point to a directory directory tree or location of a script or executable file. In one of these embodiments the URL is a pointer to a CGI executable file. The URL may point to a CGI binary directory or directory tree containing a CGI executable file. The URL may include a string such as cgi tm . This string may indicate that the response is a redirection message from the TM vServer. In some embodiments the URL string such as cgi tm may be hard coded pre determined or dynamically generated. The URL may also be some other type or form of pointer or indicator other than a URL.

The request may include any type or form of information such as information associated with the client any requested resource the appliance the authentication session and the request . The request may also include the URL . In some embodiments the request may include the URL in the body of the request . The request may also include client and or user credentials . In some embodiments the credentials are used for authenticating the client and or user. In various embodiments one or more of the credentials the URL and the URL may be optional or required. One or more of these may reside in the body of the request in a POST request line of the request in a header or other section of the request . In one embodiment the request includes but is not limited by any one or more of the following attributes 

The request may include any type or form of marker or cookie such as an AAA cookie. An AAA cookie may be generated by the TM vServer the client or any other module of system and or in accordance with one or more policies . The AAA cookie may be used to perform any type and form of state and or data tracking during the authentication process. The AAA cookie can include one or more attributes and each attribute may include any type or form of information such as information about the authentication vServer and an associated authentication session . An AAA cookie may be reused during the period of authentication. An AAA cookie may expire when an authentication session expires. In some embodiments the AAA cookie is only valid for the domain of the authentication vServer and may not be available in requests sent to the TM vServer. In one embodiment an AAA cookie includes but is not limited to the following attributes 

In some embodiments an authentication session may be created in response to the request . The authentication vServer may establish an authentication session to authenticate a client and or user when a connection or resource request is made and in some embodiments after an authentication session has expired. The authentication session may represent any type or form of connection channel session collection or unit of transactions. Further the authentication session can support any session layer services and protocols. An authentication session may also be substantially similar to or incorporates features of any existing type of secure authenticated and or encrypted session channel or connection.

In some embodiments an authentication session is a VPN session. An authentication session may be a VPN session if created by a VPN vServer or server. In some embodiments an authentication session is substantially similar to and or incorporates features of a VPN session. As an example in one embodiment authentication may be provided by integrating a light weight VPN framework so that future VPN enhancements such as security assurance markup language SAML and active directory federation services ADFS can be incorporated. In another embodiment the authentication session includes additional fields such as fields to store the domain of an associated TM vServer and the URL .

An authentication session may be created right after an authentication vServer receives a first client request redirected from the TM vServer. In some embodiments this session creation may occur before authentication. A VPN vServer however may create a VPN session after authentication is completed. A reason for the difference may be that the authentication session is created before authentication to store one or both of the domain of the TM vServer and the URL of the initial request made by the client to the TM vServer. In some embodiments protection of the authentication session against Denial of Service DOS attack may be needed or provided for example against a hacker that sends a message to fill up a AAA TM session table denying access to legitimate users.

In some embodiments an authentication session can be refreshed or made active for another specified period of time. In one of these embodiments if a valid domain session cookie is found in the request received at the traffic management vServer the authentication session can stay active for another specified period of time. If not refreshed the authentication session can time out and the client may have to be re authenticated e.g. re login . Session time out may sometimes be referred to as passive time out. An authentication session can terminate either by a user s explicit logout e.g. clicking the logout button link or when the session times out. In some embodiments once a user logs out the authentication session e.g. on the appliance such as a CITIRX Netscaler appliance becomes invalid. The user may have to be re authenticated to enter into a valid authentication session. In one embodiment CGI support for user logout may be supported. For example an executable file that processes the logout may be found in a cgi logout path and linked to a logout button for example. In another embodiment a full session management page may be supported and displayed at the client including logout functions. The full session management page may also be customized. This full session management page may be retrieved from storage and or included in a message to the client .

In some embodiments AAA support for traffic management may increase the authentication login rate and or number of concurrent sessions. For example these may be higher than typical VPN applications. This may also increase memory consumption. To offset such increases an administrator may set smaller session timeout values such as a smaller default timeout value for authentication sessions .

An authentication session may or may not co exist and or interoperate with a traffic management session not shown . In one embodiment a traffic management session starts after an authentication session. In another embodiment a traffic management session initiates and or interacts with one or more authentication sessions. A traffic management session may also interoperate with an authentication session for example for auditing accounting purposes during the traffic flow access AAA feedback and or make or update traffic management decisions. In some embodiments a security model for authentication and or VPN supporting traffic management may have session establishment and authentication token collection occurring over a secure channel SSL but may not require traffic management content to be secured. The authentication and or VPN support can protect a traffic management vServer over traffic passing through it.

A second response to the client may be generated if authentication of the client is successful for example such that the authentication session is available. The second response may identify the authentication session to the client . The authentication vServer may generate the second response and may transmit the response to the client . The second response may include the authentication session identifier or information in the body of the second response in a POST message structure of the second response in a domain session cookie a header or any other section of the second response . In some embodiments an authentication session identifier may be referred as an authentication session index . An authentication index may be used to identify a valid authentication session.

In some embodiments the second response may be a HTTP 302 message or any other type or form of redirection message. In some embodiments the second response may redirect the client request back to the TM vServer after authentication. In one embodiment the second response includes but is not limited to any one or more of the following information and or constructs 

A request may be sent by the client to the TM vServer. In one embodiment the request may be a redirected second response with or without any changes to the second response . In another embodiment the request is substantially similar to the request . For example the request may include information from the request as well as authentication information. The request may identify the authentication session . In some embodiments the request identifies the valid authentication session . The request may include the authentication session identifier or information in the body of the request in a POST message structure of the request or in a header or other section of the request .

Any of the responses and requests subsequent to a preceding message request or response may include any of the information included in any of the preceding message. For example the response may include all or some of the information included in the request . In some embodiments any of the subsequent messages may be a modification or update of any preceding message. For example the response may be generated by putting a wrapper over the request making header or address modifications in the request and or adding new information into the request . Moreover each of these messages may be generated and or modified from another message according to one or more traffic management authentication or other policy.

An interface such as a web interface may be provided by system . The interface may include features from any embodiment of the GUI CLI shell services described above in connection with . An administrator of the traffic management system may leverage on a plurality of commands to setup and configure the systems and methods discussed in the disclosure. Commands may be entered via a command line interface such as the CLI as described above in connection with . By way of illustration and in some embodiments some or all of the following commands may be available for a variety of functions 

Referring now to a flow diagram depicting an embodiment of steps of a method of authentication of network traffic management by a traffic management virtual vServer is shown. In brief overview at step a traffic management vServer receives a request from a client to establish a connection with a server . The request includes a first uniform resource locator URL . At step the traffic management virtual server determines whether the client has been authenticated. At step the traffic management virtual server identifies a policy for selecting one authentication virtual server from a plurality of authentication virtual servers to provide authentication of the client . At step the traffic management virtual server selects an authentication virtual server of the plurality of authentication virtual servers via the policy. At step the traffic management virtual server transmits to the client a response to the request . The response includes the URL and instructions to redirect to an authentication virtual server . At step the response triggers a request from the client to the authentication virtual server . At step the authentication virtual server receives the request from the client . The second request identifies the URL and indicates a redirection from the traffic management virtual server. At step the authentication virtual server establishes an authentication session for the client . The authentication session identifies one or more policies . At step the authentication virtual server stores the URL and domain of the traffic management virtual server with the authentication session . At step the authentication virtual server authenticates credentials received from the client . At step the traffic management virtual server applies one or more policies of an authentication session to the request . At step the authentication virtual server transmits a response to the client to redirect the client to the traffic management virtual server. The response identifies the authentication session . At step the traffic management virtual server receives a request from the client . The request includes an identifier of the authentication session . At step the traffic management virtual server validates the authentication session identified by the identifier . At step the traffic management virtual server applies the one or more policies of the authentication session to the request . At step the traffic management virtual server forwards traffic authorized by the one or more policies from the client to the server .

In further details of step a traffic management vServer receives a request from a client to establish a connection with a server . The request may include a uniform resource locator URL . In some embodiments the request is a request for access to a resource. The request may be an initial request from the client from a plurality of requests and may or may not include the URL . The traffic management vServer may receive the request via another intermediary between the client and a server or server farm such as the appliance . The request may be intercepted and or redirected to the traffic management vServer. The request may also be redirected and or addressed to the appliance or server executing the traffic management vServer. In some embodiments the request may be addressed to the traffic management vServer. The request may be directed to the traffic management vServer according to one or more policies such as policies from the traffic management policies . In addition the request may be channeled routed redirected or delegated from one or more traffic management vServers to the traffic management vServer via any embodiment of the configurations described above in connection with .

In further details of step the traffic management virtual server determines whether the client has been authenticated. The traffic management vServer may determine whether client and or user has been authenticated by applying one or more policies such as policies from the traffic management policies and or authentication policies associated with the traffic management virtual server. In some embodiments the request may include information that indicates whether the client and or user are authenticated. The absence of certain information may also indicate whether the client and or user are authenticated. The traffic management vServer may determine that the request does not include a session cookie such as a domain session cookie. In some embodiments the traffic management vServer may determine that the request does not include an identifier or index to a valid authentication session. In one embodiment the traffic management vServer may determine that the client and or user is not authenticated because the request does not include a domain session cookie and or an index to a valid authentication session. A valid domain session cookie and or an index to a valid authentication session in the request may indicate that the client and or user is authenticated. In one embodiment the traffic management vServer checks that an authentication session either identified in the request or by the session domain cookie is valid or has not expired. In some embodiments the traffic management vServer determines that the client and or user is authenticated if the request includes a valid domain session cookie and the associated authentication session is valid and has not expired.

The traffic management vServer may also request the client for information. The requested information can be used to determine whether the client and or user is authenticated. For example the traffic management vServer may initiate an endpoint analysis scan of the client . In some embodiments the traffic management vServer may transmit a script and or program to the client to collect the information or may execute a script and or program to poll or request the client for the information. In some embodiments the traffic management vServer may transmit and or activate a collection agent in the client to collect the information for the traffic management vServer. The information collected may be any type or form of information described above in connection with the collection agent and . The traffic management vServer may then determine whether the client has been authenticated in response to receiving and or analyzing the collected information.

In some embodiments the traffic management vServer may not be able to determine whether the client has been authenticated. In one of these embodiments the traffic management vServer may treat the client as authenticated. In another of these embodiments the traffic management vServer may treat the client as not authenticated. The traffic management vServer may treat the client as authenticated or not by applying one or more policies such as the traffic management policies and the authentication policies . Depending on whether the client has been authenticated or not the traffic management vServer may perform a same action or different actions. The actions may be determined by applying one or more policies. In one embodiment if the client is authenticated the method may proceed to step for application of one or more authentication policies prior to traffic management operations. In another embodiment if the client is not authenticated the method may proceed to step to initiate authentication.

At step the traffic management virtual server identifies a policy for selecting one authentication virtual server from a plurality of authentication virtual servers to perform authentication on the client . One or more policies for example traffic management policies may be selected and applied in selecting the authentication vServer. In some embodiments only one authentication virtual server may be available or supported and a policy may not be required to identify this authentication virtual server. In one embodiment the request includes information for identifying the policy for selecting the authentication virtual server. In another embodiment the request provides the policy for selecting the authentication virtual server. In yet another embodiment traffic management virtual server identifies the policy based at least in part on the collected information from the client . Further the policy may be identified from the traffic management policies the authentication policies or any other policies. Any policy may be applied through a policy engine such as any embodiment of the policy engine discussed above in connection with .

In one embodiment the traffic management virtual server identifies the policy to select the authentication vServer based on a user associated with the request. In another embodiment the traffic management virtual server identifies the policy to select the authentication vServer based on information collected from the client . The traffic management virtual server can identify the policy based on any type or form of information collected from the client . The traffic management virtual server may initiate EPA to collect information from the client for identifying the policy. The traffic management virtual server may receive information from the client for identifying the policy by sending a collection agent to the client or communicating with a collection agent at the client . In one embodiment the traffic management virtual server identifies the policy for selecting the authentication vServer based on information collected about software installed on the client . In another embodiment the traffic management virtual server identifies the policy for selecting the authentication vServer based on information collected about an operating system on the client .

In some embodiments the traffic management vServer may operate via an associated policy engine for any action relating to a policy. For example a policy engine in traffic management vServer or in communication with the traffic management vServer may identify the policy for selecting the authentication vServer on behalf of the traffic management vServer.

In further details of step the traffic management vServer selects an authentication vServer of the plurality of authentication vServers via the policy to authenticate the client. Responsive to identification of the policy the traffic management vServer selects an authentication vServer. In one embodiment the traffic management vServer selects an authentication vServer from a plurality of vServers associated with the traffic management vServer. In another embodiment the traffic management vServer selects an authentication vServer as a first type of authentication vServer from a plurality of vServers. The traffic management vServer may select the authentication vServer based on a type of authentication supported by the authentication vServer. For example the type of authentication may include Active Directory AD Lightweight Directory Access Protocol LDAP RADIUS and RSA SecureID. The traffic management vServer may also select the authentication vServer based on a feature e.g. SSO and or option supported by a type of authentication provided by the authentication vServer. The authentication vServer may be selected for a particular type of authentication identified by the policy. The traffic management vServer can also select the authentication vServer based on negotiation of any type of requirement and or options with the client . In one embodiment the traffic management vServer selects an authentication vServer based on negotiating with the client a type of authentication. The type of authentication may be negotiated from a plurality of types of authentication. In some embodiments the traffic management vServer selects an authentication vServer based a type of authentication supported by the client.

In some embodiments the traffic management vServer may select the authentication virtual server without applying any policies. For example the traffic management vServer may be statically associated with the authentication vServer as described above in connection with . In one embodiment the request provides information that identifies or selects the authentication vServer. In another embodiment the traffic management vServer uses information collected from the client to identify or select the authentication virtual server. The traffic management vServer selects the one or more authentication vServers to authenticate the client and or the user. In addition one or more authentication servers may be statically or dynamically associated with each selected authentication vServer to authenticate the client and or the user. In some embodiments the dynamic association may be made by applying one or more policies from the authentication policies for example.

In further details of step the traffic management virtual server transmits to the client a response to the request . The traffic management virtual server may transmit the response including the URL and or instructions to the client to redirect to the authentication virtual server. In some embodiments the traffic management vServer transmits a response identifying the URL via a hidden form or field. The traffic management vServer may also transmit the response including a submit on load event handler and or a page or form for display and or user interaction on the client . The traffic management vServer may transmit the response if the client and or the user is not authenticated or if it cannot be determined if the client and or the user is authenticated.

In some embodiments the traffic management vServer converts the request into the response via any type or form of modification transformation and or translation. In other embodiments the traffic management vServer generates the response based at least in part on the contents of the request . The response may also be generated and or modified by a module other than the traffic management vServer such as a component of the appliance . Further the response may be generated and or modified upon application of one or more policies such as policies from the traffic management policies and or the authentication policies . In some embodiments the response includes a script to trigger transmission of a request from the client to the authentication virtual server.

In some embodiments the traffic management vServer may operate or perform any actions via the network engine . The traffic management vServer may direct the network engine on any such actions. For example the network engine may generate and or transmit the response to the client to redirect to the selected authentication vServer. The network engine can generate the response on behalf of the traffic management vServer to include an instruction for the client to redirect to the selected authentication vServer.

At step the response triggers a request from the client to the authentication virtual server responsive to receiving the response . In one embodiment the request is triggered responsive to receiving the response . In another embodiment the request is triggered by a user action such as a click on a submit button displayed on the client . The client may receive one or more commands scripts and or programs included in the response that triggers the request . The client may also have one or more scripts and or programs that triggers a request responsive to receipt of the response . In some embodiments the one or more scripts and or programs either received by the client or available at the client triggers transmission of a POST request to the authentication virtual server. The client and or the one or more scripts and or programs may generate a pointer or URL for inclusion in the request . For example where the request is a POST request the pointer or URL may be included in the POST field of the request . In some embodiments the pointer or URL indicates a path to a CGI executable file. The client and or the one or more scripts and or programs may generate one or more inputs or values to the CGI executable script for inclusion in the request . The request may also include one or more commands scripts and or programs. In some embodiments the client transmits the request to the authentication vServer. The request may also be routed or redirected to the authentication vServer for example via the appliance and or traffic management vServer.

In further details of step the authentication virtual server receives the request from the client the request identifying the URL and indicating a redirection from the traffic management vServer. In some embodiments the authentication vServer receives a request comprising a POST message to a predetermined URL and or the URL . The authentication vServer may extract the pointer or URL from the request in response to receiving the request . The authentication vServer may retrieve or request for an executable file according to the extracted pointer or URL . Further the authentication vServer may execute the executable file with or without inputs or values included in the request . In another embodiment the authentication vServer may execute one or more commands scripts and or programs. The one or more commands scripts and or programs may be included in the request or in the authentication vServer retrieved from storage or generated according to one or more authentication policies . Furthermore the authentication vServer may select the one or more commands scripts programs and or executable file for execution according to one or more authentication policies .

In some embodiments the authentication vServer looks for an AAA cookie in the request . If an AAA cookie is available and valid the authentication vServer may proceed to step or any other authentication steps. If an AAA cookie is not available or invalid the authentication vServer may determine if the request is of a certain type of message and valid. In some embodiments the authentication vServer may determine if the request is a POST message. If the message is valid the authentication vServer may proceed according to step . In some embodiments the message is valid if it is a POST message. In one of these embodiments the message is valid if the authentication vServer determines that the POST message includes a predetermined URL such as cgi tm . Otherwise if the message is determined to be invalid and or not a POST message the authentication vServer may reject the client request. The authentication vServer may reject the client request by sending a message of any type and form. In some embodiments the authentication vServer rejects the client request by a HTTP 403 Forbidden or 503 Service Unavailable message. In various embodiments the authentication vServer may do one or more of generating the message to reject the client request send the message to the client and close the connection to the client .

In further details of step the authentication virtual server establishes an authentication session for the client . The authentication session may identify one or more policies . The authentication session established by the authentication vServer may be a VPN session. In some embodiments the authentication vServer establishes the authentication session prior to authenticating the client and or the user. In other embodiments the authentication vServer establishes the authentication session upon authentication or after authenticating the client and or the user. The authentication vServer may create or establish the authentication session using any type or form of data structure objects or applications processing interfaces APIs . For example the authentication vServer may establish or create a session table such as a AAA TM session table in the storage device . The authentication vServer may also create and or store a session cookie such as a AAA session cookie and or other information associated with the authentication session . In some embodiments the authentication vServer communicates or performs handshaking with a server or other machine to establish the authentication session . The server or other machine may be identified by the traffic management vServer based on the client request. In some other embodiments the authentication vServer establishes the authentication session in preparation to connect to a server or other machine yet to be identified by the traffic management vServer. The authentication vServer may also establish the authentication session in preparation to authenticate the client and or user.

In some embodiments the authentication session may be established by executing the executable file indicated by the pointer or URL . The request may pass information such as inputs and values to the authentication vServer to establish the authentication session . The authentication session may also be established by executing one or more commands scripts and or programs received in the request residing in the authentication vServer retrieved from storage or generated according to one or more authentication policies .

At step the authentication virtual server stores the URL and domain of the traffic management virtual server with the authentication session . The authentication vServer may store one or both of the URL and domain of the traffic management virtual server in association with the authentication session . In addition the authentication vServer can store any type or form of information from the request or otherwise in association with the authentication session . The authentication vServer may store any of these information responsive to receiving the request . The authentication vServer may store any of these information responsive to applying one or more policies such as policies from the authentication policies . Further the authentication vServer may store any of these information by executing the executable file indicated by the pointer or URL . The authentication session may also store any of these information by executing the one or more commands scripts and or programs included in the request residing in the authentication vServer retrieved from the storage device or generated according to one or more authentication policies .

The authentication vServer may store any of this information in association with the client request the client the user and or any other component of the system described above in connection with . Any of this information may be stored in the storage or between one or more storage devices in the network . In some embodiments the authentication session stores some or all of these information in a session table such as a AAA TM session table. The authentication vServer may transmit or communicate any of this information to any of the storage devices for storage.

In further details of step the authentication virtual server authenticates credentials received from the client . The authentication vServer may perform authentication in accordance with a type of authentication e.g. LDAP RADIUS used by or configured by the authentication vServer. The authentication vServer may also communicate with any type or form of server or system to perform the type of authentication. For example and in some embodiments the authentication vServer performs a type of authentication supported by one or more authentication and or authorization servers bound or assigned to the authentication vServer. Further the authentication vServer may perform authentication in accordance with a type of authentication identified by the traffic management vServer and or one or more policies. The authentication vServer may also perform authentication of the client and or the user using any conventional proprietary and or customized authentication techniques and processes. The authentication vServer may perform authentication responsive to receiving the request . The authentication vServer may also perform authentication responsive to applying one or more policies such as policies from the authentication policies . Further the authentication vServer may perform authentication by executing an executable file identified by the pointer or URL . The authentication session may also perform authentication by executing the one or more commands scripts and or programs included in the request in the authentication vServer retrieved from storage or generated according to one or more authentication policies .

The authentication vServer may identify or extract client credentials and or any type or form of information from the request . Further the authentication vServer may request for and or collect any type or form of authentication and or authorization information from the client and or the user. This information may include one or more of a user identification password answer to a challenge question authentication key session table index and session cookie. The information may be collected in communication with one or more of a password manager on the client a session table and or database maintained in the storage device and or a RADIUS server for example and user input. The authentication vServer may initiate an endpoint analysis or scan of the client . In some embodiments the authentication vServer may transmit a script and or program to the client to collect the information or may execute a script and or program to poll or request the client for the information. In one embodiment a collection agent collects the information for the authentication vServer. Any type or form of pre authentication actions may also be performed by the authentication vServer. In some embodiments the pre authentication actions are applied according to one or more authentication policies .

In some embodiments the authentication vServer redirects the client or the client request to a login page or other webpage. The authentication vServer may initiate the redirection using a HTTP 302 message or any other type of message. In some embodiments the authentication vServer generates the redirection message and transmits it to the client . In one embodiment the authentication vServer redirects the client or the client request to the page via a pointer or URL for example vpn index.html . In some embodiments some or all pre authorization actions may be performed by accessing the page. This page may reside in or be provided by the authentication vServer the storage device or any other component of the system described above in connection with . In other embodiments the authentication vServer sends or provides a page or a message to the client to initiate authentication.

The client may send a redirected request to the authentication server responsive to receiving the redirection message. In one embodiment the client sends a redirected request including a GET vpn index.html command. The authentication server may send a response including a page such as login page to the client responsive to the redirected request. The client may enter credentials and or other information into the page and send a login request via the page to the authentication server. The authentication vServer can receive and process the login request. In some embodiments the authentication vServer attempts to authenticate the client and or user either locally or remotely. For example and in one embodiment the authentication vServer performs authentication locally by applying one or more authentication policies and or using authentication information stored in the storage device . In another embodiment the authentication vServer performs authentication by transmitting client and or user information to one or more remote authentication servers . The selection of remote and or local authentication may be based in part on the type or form of authentication configuration and or application of one or more authentication policies .

If the authentication is unsuccessful for example if any of the authentication steps and is unsuccessful the client request may be rejected ignored or authentication re performed with or without additional steps. The authentication vServer may reject the client request by sending the client a message of any type and form. In some embodiments the authentication vServer rejects the client request by a HTTP 403 message. In some embodiments if the authentication is unsuccessful in any of the authentication steps such as steps and the authentication vServer may perform one or more of generating the message to reject the client request sending the message to the client and closing the connection to the client . The authentication vServer can terminate the authentication session if available. Further the authentication vServer may remove the stored domain of the traffic management vServer and or the URL from storage.

If the authentication is successful the authentication vServer may set the domain session cookie for the traffic management session. In some embodiments upon successful authentication the method may proceed to step or .

In further details of step the traffic management virtual server or the authentication virtual server applies one or more policies of an authentication session to the request. In some embodiments this step comes after the traffic management vServer has determined that the client and or user has been authenticated. The step may also proceed upon successful authentication of the client and or user by the authentication vServer. In some embodiments the traffic management vServer transmits or redirects the client request to the authentication vServer. The traffic management vServer or the authentication virtual server can apply one or more policies such as policies from the authentication policies to the client request. The traffic management vServer or the authentication virtual server may apply the one or more policies on a client message such as request or on stored information associated with the client request e.g. from storage device . The traffic management vServer or the authentication virtual server may identify an authentication session associated with the authenticated client and or user. In addition the authentication session and or the one or more policies may be identified by an authentication vServer associated with the traffic management vServer.

At step the authentication virtual server transmits a response to the client to redirect the client to the traffic management virtual server. In some embodiments the authentication vServer generates and transmits a response with the response described above in connection with . The authentication vServer can insert the session cookie for the traffic management session in the response . Moreover the authentication vServer can insert an identifier or information about the authentication session into the response . The authentication vServer can insert an identifier or information about the authentication session into a session cookie e.g. domain session cookie included in the response. The authentication vServer may send the response to identify the authentication session to the client . In some embodiments the authentication vServer transmits the response as a redirection message e.g. HTTP 302 message to the client to redirect the client request to the traffic management vServer. Further the authentication vServer may terminate its connection with the client after sending the response .

In further details of step the traffic management virtual server receives another request from the client . The request may include an identifier or index of the authentication session . The client may generate the request responsive to receiving the response . The client may extract the identifier or information about the authentication session from the response and insert the identifier or information about the authentication session into the request . In some embodiments the client modifies or otherwise processes the response into the request . The client may transmit the request directly to the traffic management vServer or to the appliance for redirection to the traffic management vServer. In some embodiments the client may perform any action such as processing responses and generating requests via one or more applications executing on or on behalf of the client . Performance of any of the actions may be automated and or include user interaction. The requests sent by the client may be any type of request for access to server such as via the use of an application.

In further details of step the traffic management virtual server validates the authentication session identified by the index or identifier . The traffic management vServer may extract or identify the index or information about the authentication session from the request . In some embodiments the traffic management vServer uses the index or information to identify the authentication session . Further the traffic management vServer may validate the authentication session identifier or information. In some embodiments the traffic management vServer identifies one or more policies of the authentication session using the identifier or information. The traffic management vServer may perform the validation by using information stored in the storage device information collected from the client and or applying one or more policies from the associated traffic management policies and or authentication policies . The traffic management vServer may validate that the authentication session is still active and or is authenticated with respect to the client and or user.

In some embodiments the traffic management vServer does not validate the authentication session . Responsive to a failure to validate the authentication session the traffic management or authentication vServer may reject the client request by sending the client a message of any type and form. In some embodiments the traffic management or authentication vServer rejects the client request by a HTTP 403 message. The traffic management or authentication vServer may perform one or more of generating the message to reject the client request sending the message to the client and closing the connection to the client . The traffic management or authentication vServer may terminate the authentication session . Further the traffic management or authentication vServer may remove the stored domain of the traffic management vServer and or the URL from storage . The traffic management or authentication vServer may also update and or remove one or more session tables e.g. from storage device such as the AAA TM session table.

In some embodiments the traffic management vServer may use a validated authentication session to perform EPA and or obtain client and or user information. For example upon authentication the traffic management vServer can use the authentication session to automatically and or securely collect client and or user information. In some embodiments the traffic management vServer uses the authentication session to identify one or more policies . For any communication traversing the traffic management vServer the traffic management vServer may use any information about a client or a session available from the authentication vServer such as any collected end point information. In some embodiments the values of any portion of a policy expression may be obtained or derived from any data values or information available via the authentication vServer such as via an authenticated session. In some embodiments the input to a condition action or rule of a policy may be a value from end point collected information stored by the authentication vServer.

In this manner a traffic management vServer may use end point or authenticate session information to direct traffic for any request. For example during the communication of application traffic traversing the traffic management vServer the traffic management vServer can use end point or authenticated session information to make traffic control decisions on a request basis. For example if the client has the presence or absence of software then the traffic management vServer may make certain traffic management decisions. If the client was authenticated by a certain type of authenticated versus another type of authentication the traffic management vServer may also make certain traffic management decisions

At step the traffic management virtual server applies the one or more policies of the authentication session to the request . The traffic management vServer may apply one or more policies for example to validate the URL to associate the URL with the authentication session or to determine a resource or server for the client . In some embodiments the traffic management vServer may apply an authorization policy of the one or more policies of the authentication session to the request . The traffic management vServer may apply the authorization policy to identify authorized traffic from the authenticated client . In some other embodiments the traffic management vServer may apply a traffic management policy of the one or more policies of the authentication session to the request . The traffic management policy may determine that traffic associated with the authorized client is encrypted and or compressed.

The traffic management vServer may apply one or more policies to validate the URL as a pointer to a resource or server for the client . The traffic management vServer may also apply one or more policies to at least some of subsequent requests from the authenticated client and or user to validate these requests. Once validated by the one or more policies these requests become part of the authorized traffic.

At step the traffic management virtual server forwards traffic authorized by the one or more policies from the client to a server . The server may be identified by the URL by the traffic management vServer or by applying one or more policies . In some embodiments the traffic management vServer forwards requests validated by the one or more policies from the client to the server . In one embodiments the traffic management vServer may forward the authorized traffic or validated requests to a service or server . In another embodiment the traffic management vServer may forward the authorized traffic or validated requests via one or more traffic management sessions. In some embodiments an authentication session may persist until a traffic management session is terminated. In other embodiments a plurality of authentication sessions may be created and or terminated during a traffic management session for example to validate or authorize portions of traffic.

In various embodiments one or more steps may be optional required and or re sequenced without limitation in the methods described.

In one embodiment the method includes a traffic management virtual server determining from a request of a client to access a server that the client has not been authenticated the request comprising a URL step transmitting to the client a response to the request the response comprising the URL and instructions to redirect to an authentication virtual server step receiving by the authentication virtual server a request from the client the second request identifying the URL step authenticating credentials received from the client establishing an authentication session for the client the authentication session identifying one or more policies step transmitting to the client a response to redirect the client to the traffic management virtual server via the URL the response identifying the authentication session step and receiving by the traffic management virtual server a request from the client the request comprising an identifier of the authentication session step .

In another embodiment the method includes determining by a traffic management virtual server from a request received from a client to access content of a server that the client has not been authenticated step identifying a policy for selecting one authentication virtual server from a plurality of authentication virtual servers to provide authentication of the client step selecting via the policy an authentication virtual server of the plurality of authentication virtual servers to authenticate the client step and transmitting to the client a response to the request the response comprising an instruction to redirect to the selected authentication virtual server av step .

In still another embodiment the method includes a traffic management virtual server receiving a request from a client to establish a connection with a server step determining that the client has been authenticated step forwarding the request to an authentication vServer to apply one or more policies of an authentication session to the request step the authentication vServer transmitting a response to the client to redirect the client to the traffic management virtual server step the traffic management virtual server receiving a request from the client step validating the authentication session identified by the identifier step applying the one or more policies of the authentication session to the request step and forwarding traffic authorized by the one or more policies from the client to the server identified by the URL via the authentication session step .

Referring now to yet another embodiment of a method of providing AAA support to traffic management is depicted. In further details illustrates an embodiment in which traffic is processed at a traffic management vServer in communication with one or more authentication vServers. The steps of may represent a portion of the steps of method . Briefly a traffic management virtual server receives a request from a client to establish a connection with a server step looks for a session cookie in the request to determine if the client has been authenticated step forwards the request to an authentication vServer to apply authentication policies if the cookie and an authentication session it identifies are both valid step redirecting by the authentication vServer back to the traffic management virtual server step . If the cookie and or a authentication session it identifies are not valid the traffic management vServer identifies an authentication vServer to authenticate the client and redirects the client request to the authentication vServer step The details of each step are described above in connection with .

Referring now to still even another embodiment of a method of providing AAA support to traffic management is depicted. In further details illustrates an embodiment in which a client request is processed at an authentication vServer associated with a traffic management vServer. The steps of may represent a portion of the steps of method . The details of each step are described above in connection with . Briefly an authentication vServer receives the request from the client and looks for an AAA cookie in the request step . If the cookie is available and valid the authentication vServer performs authentication on the client steps . If the authentication succeeds the authentication vServer redirects the client request back to the traffic management virtual server step . If the authentication fails the client request is rejected. On the other hand if the cookie if not available or not valid the authentication vServer determines whether the request is a valid POST message step . If the request is a valid POST message an authentication session is established and authentication performed steps . If the request is a valid POST message the client request is rejected. The details of each step are described above in connection with .

Referring now to a flow diagram depicting an embodiment of steps of a method for using endpoint auditing for traffic management is shown. In brief overview at step an authentication virtual server of an intermediary determines a result of an end point analysis scan of a client . At step the traffic management virtual server obtains the result from the authentication virtual server. At step the traffic management virtual server applies the result in one or more traffic management policies to manage network traffic of a connection of the client traversing the intermediary .

In further details of step an authentication virtual server of an intermediary determines a result of an end point analysis scan of a client . One or more authentication and or authorization servers assigned or bound to the authentication vServer may determine the result of an end point analysis scan on behalf of the authentication vServer. In some embodiments the authentication vServer initiates an endpoint analysis scan of the client responsive to an event. The event may be any type and form of event such as a receipt of a client request or client traffic a change in an attribute of the client a service level change or a network disruption. The event may also be a request from a traffic management vServer or a different AAA vServer such as an auditing vServer. In some other embodiments the authentication vServer initiates an endpoint analysis scan based on a predetermined frequency. The predetermined frequency for initiating the endpoint analysis may operate according to a schedule. The frequency may be predetermined based on past history such as past history of network traffic and or client requests. The frequency may also be predetermined by applying one or more policies and or formulas for example on the past history. Further the frequency may be predetermined based on auditing accounting needs. In some embodiments the frequency is stored and or maintained in a database and or session table. The database and or session table reside in one or more storage devices e.g. storage device in the network .

In some embodiments the authentication vServer may transmit a script and or program to the client to perform the end point analysis scan or may execute a script and or program to poll or request the client for information. In one embodiment a collection agent collects the information for the authentication vServer. The authentication vServer and or the traffic management vServer may send the collection agent to the client to perform the endpoint analysis scan. The endpoint analysis scan may be initiated as part of one or more AAA actions e.g. pre authentication actions by the authentication vServer. This endpoint analysis scan may also be initiated as part of one or more traffic management actions by the traffic management vServer. Further the traffic management vServer or the authentication vServer can initiate the endpoint analysis scan in response to an application of one or more policies .

The authentication vServer receives the results of the endpoint analysis scan which may include any type or form of client information. In some embodiments the results include an expression which may include any type or form of string equation list or command. The authentication vServer may receive one or more expressions evaluated by the client . The one or more expressions received may identify one or more attributes of the client . The results may identify a presence on the client of one or more of a version of an operating system a service pack of the operating system a running service a running process and a file. The results may also identify a presence on the client of one or more of a presence or a version of an antivirus software personal firewall software anti spam software and internet security software.

In some embodiments the collection agent may transmit the results to the authentication vServer and or the traffic management vServer. In some other embodiments the script and or program transmitted to the client may execute on the client and transmit the results to the authentication vServer and or the traffic management vServer. The client the received script or the received program may transmit the collection agent including the collected results back to the authentication vServer. In other embodiments the client transmits the results to the authentication vServer and or the traffic management vServer. The client may send the results to the appliance or intermediary to be redirected to the authentication vServer and or the traffic management vServer. The results may be encrypted compressed formatted and or otherwise processed according to a communications protocol by the client or otherwise before sending out from the client . These results may be processed upon receipt at the authentication vServer and or the traffic management vServer to extract any required information. Further the authentication vServer may process and or evaluate these results according to one or more AAA or authentication policies .

In further details of step the traffic management virtual server obtains the result from the authentication virtual server. The traffic management vServer may receive the result according to another predetermined frequency. This frequency may be substantially similar to or include any embodiments of the frequency described above in connection with step . In some embodiments the frequency is predetermined by the authentication vServer and or one or more authentication policies. In some embodiments the authentication vServer forwards all or part of the results to the traffic management vServer. The authentication vServer may process all or part of the results before forwarding to the traffic management vServer. In one embodiment the authentication vServer provides an evaluation of one or more expressions identifying one or more attributes of the client to the traffic management vServer. The authentication vServer may forward all or part of the results according to one or more AAA or authentication policies . The authentication vServer may also provide all or part of the results as input to the one or more traffic management policies of the traffic management vServer.

In further details of step the traffic management virtual server applies the result in one or more traffic management policies to manage network traffic of a connection of the client traversing the intermediary . The traffic management vServer may apply the result according to yet another predetermined frequency. This frequency may be substantially similar to or include any embodiments of the frequency described above in connection with step . The traffic management vServer may apply all or part of the results from the authentication vServer to the one or more traffic management policies . The traffic management vServer may further process all or part of the results from the authentication vServer prior to applying the policies .

The traffic management vServer may determine a type of compression for the connection based on applying the one or more traffic management policies using the results. Moreover the traffic management vServer may determine a type of encryption for the connection based on applying the one or more traffic management policies using the results. The traffic management vServer may also determine one or more file type associations for the connection based on applying the one or more traffic management policies using the results. Further the traffic management vServer may determine whether or not to use a single sign on for the connection based on applying the results via one or more traffic management policies. Based on the determination the traffic management vServer can make one or more traffic management and or AAA decisions to manage the traffic from the client traversing the intermediary .

In some embodiments method may be applied in conjunction with method of . For example embodiments of method may be implemented as part of steps or of method . In various embodiments any one or more of the components features and or steps described above in connection with may be applied to a multi core system without limitation.

Referring to one embodiment of a multi core system is depicted. The multi core system can include one or more cores A N generally that can execute one or more packet engines A N generally . In some embodiments each core can access a stored session table A N generally that stores session data for sessions executing on or otherwise assigned to each core . Each core may also access one or more session buffers A N generally . At least one core can execute or provide an authentication vServer . Each core may communicate with a shared memory . In some embodiments the core executing the authentication vServer may execute and or provide an authentication authorization and auditing AAA daemon and or a SSL module or SSL engine.

Further referring to and in more detail in some embodiments the multi core system can be implemented on an appliance such as any appliance or device. In certain embodiments the multi core system can be implemented on any appliance described herein for example described in connection with A C and A. In other embodiments the multi core system can be implemented on any computing device such as embodiments of computing device described herein for example described in connection with A B and A C.

The multi core system can communicate with one or more clients or client machines not Shown . These clients can be a client machine a server or any computing device that can communicate with the multi core system e.g. across one or more networks. In some embodiments one or more users can access the client machine. A user may generate a login request via a user interface for example displayed on and or provided by the client. For example when a user logs into a network the client may receive this command and issue the login request to the multi core system .

In some embodiments the multi core system can include one or more processing cores . The processing core can be any type or form of processor. In other embodiments the processing core can be any processor or processing core described herein. While illustrates a multi core system including seven or more processing cores in other embodiments the multi core system can include any number of processing cores e.g. one processing core two processing cores and more than two processing cores.

In some embodiments each processing core can communicate with execute and or provide a packet engine . In certain embodiments the packet engine can be referred to as a vServer VIP server or just VIP. In some embodiments the packet engine can be any packet engine described herein.

In some embodiments a core can be an owner core or a control core A. The owner core or control core A can be any core in the multi core system . The owner core or control core A may be a default or a pre assigned core of the plurality of cores e.g. PE 0. The owner core or control core A may be designed built configured and or adapted for one or more functions for example that may differ from the other cores. In other embodiments the owner core or control core A can be the owner or controller of a session. An owner core may have established the session. An owner core may have assumed management and or use of a session. In some embodiments making the core an owner of a session can include issuing the following command session id 0 session id 1 core id. In some embodiments other cores can determine identify and or access the owner core or control core A of a session by issuing the following command session id 0 session id 1 num ppes . Such commands may assist in the implementation or support of Sega Saturn emulator SSF across e.g. heterogeneous multi core systems e.g. 8 cores vs 4 cores .

The plurality of cores in some embodiments can communicate with one another using core to core messaging and or other custom proprietary and or standard protocol. In one embodiment core to core messaging may be carried out via a messaging protocol employed by a messaging application not shown . In some embodiments the messaging application can execute on one core while in other embodiments each core can execute an instance of the messaging application. Core to core messages can include any of the following messages 

In some embodiments there can be a number of errors that may occur for example as a result of the core to core messaging network stability memory availability the synchronization of encryption decryption keys and or the marking of sessions active or timed out. In some cases these errors can be due to the asynchronous messaging framework used in the multi core system . To mitigate these potential issues in some embodiments when the multi core system blocks using the asynchronous mode data coming from a connection to the multi core system or a core can be held until a core to core message response is received. In some embodiments when a core blocks using the asynchronous mode data going to that core can be held until a core to core message response is received.

In situations where there is a TCP timeout the asynchronous framework may relinquish some or all resources that are associated with a particular connection and or core. When an owner core fails to obtain or access shared memory for transferring session information the owner core can send an error message to a requesting core. The requesting core may send an error message to or on a connection blocked e.g. by the requesting core . The system can support or provide a retry mechanism to address handle prevent and or mitigate memory allocation failures. The error message may be sent after a specific number of timeouts. In some embodiments when a core to core message error occur an error message may be generated. The error message may be sent to the requesting core and or the receiving core for example.

At least one core may execute an authentication vServer . An authentication vServer may be a separate and or dedicated vServer used to authenticate authorize or audit network traffic across the multi core system . In some embodiments the authentication vServer can execute on a control core that is designated to control communication such as communication amongst the cores of the multi core system . The authentication vServer may control allocation of resources packets and or information across the one or more cores . In some embodiments this core can be a first core A. In other embodiments this core can be any core in the multi core system or a core configured for controlling configuration. Thus in some embodiments a core within the multi core system may execute provide and or establish the authentication vServer . In some embodiments a remote computing machine appliance or device communicating with the multi core system can execute and or provide the authentication vServer .

The authentication vServer in some embodiments can be any type or form of application or vServer that handles authentication of a user or session. In other embodiments the authentication vServer can authenticate authorize and or audit users prior to establishing a session between a client machine and a packet engine of the appliance . The authentication vServer can use execute or generate any authentication authorization or auditing methods or techniques to authenticate authorize and or audit a request user session client machine or user prior to establishing a session. In one embodiment the authentication vServer may authenticate a user establish a session between a client accessed by the user and the appliance and set a cookie e.g. a domain session cookie. Setting a domain session cookie in some embodiments can include sending the client machine a cookie that includes session session connection user authentication and or other information.

In some embodiments the authentication vServer can generate manage and or synchronize the encryption and or decryption keys used to encrypt decrypt the session cookies. These keys can be stored in a storage repository accessible by the authentication vServer . In other embodiments the authentication vServer can manage the encryption decryption keys in conjunction with a packet engine A executing on the control core A with the authentication vServer . The multi core system may synchronize some or all keys used for encryption decryption of cookies. In doing so all the cores or at least the participating cores may identify or receive the same session ID for a given cookie. In some embodiments the authentication vServer or the packet engine A can broadcast the stored e.g. synchronized encryption decryption keys to each core of the multi core system e.g. via core to core messaging. Some or all of the cores may receive the keys or otherwise copy the keys from the broadcast message. Each core may use the keys to encrypt decrypt session cookies to identify the session ID for each session managed by that core .

Sessions in some embodiments can be deleted or killed by the authentication vServer by a packet engine or by any application or module of the multi core system . A user including for example an administrator may terminate a session. In some embodiments each core can delete sessions in its local memory by removing the session from the session table and or the session buffer . A session may have some outstanding requests e.g. read requests from one or more requesting cores. The control core A can send a message to the requesting cores about the session termination and or to remove their outstanding requests. The control core A may send a message to the other cores indicating that they too should delete the session from their session table and or session buffer . In some embodiments this message can be sent after the other cores acknowledge an initial response issued by the control core A. In some embodiments the control core A may terminate the session after receiving acknowledgements from other cores e.g. requesting cores and or cores using the same session or an instance of the session .

In certain embodiments a session may be terminated due to a timeout. The timeout may be a preconfigured parameter of the multi core system or may be set on a per core or per session basis. In some embodiments a core that owns a session can create store and or maintain a reference mask of the cores where a particular session is present and on which cores the session has timed out. When all cores indicate e.g. via a core to core message that their respective copy or instance of the session has timed out the owner core may delete the original or main session. A non owner core with a timed out session may send a message to the owner core regarding the time out. The non owner core may also mark its copy instance of the session as timed out . The non owner core may wait for the owner core s confirmation before deleting its copy instance of the session. If a request to access the session comes in before the owner core can delete the session the owner core may receive a request to mark the session active and will not delete the session.

Upon deleting a session e.g. due to time out the owner core may send a message to the non owner cores to mark their respective sessions as time out. The owner core can send each of the non owner cores a message telling the cores to delete their respective sessions for example in response to recognizing that the non owner cores sessions have timed out. If the owner core fails to send a request to each of the non owner cores to delete the session the owner core can set the session state of the session to expired. This session state may be reflected to a request for the session and the request may be rejected. In some embodiments responsive to the request the owner core may change the session state to active. In certain embodiments when a session is expired the owner may treat the session as though it is absent and may subsequently delete the session. In some embodiments the owner core can delete the session at certain e.g. preconfigured time intervals.

An authentication authorization and auditing AAA daemon can execute on at least one core in the multi core system . The AAA daemon in some embodiments can be a program script process application or set of executable instructions executing on at least one core. In some embodiments the AAA daemon can execute on a control core A such as the core A on which the authentication vServer executes. In still other embodiments the AAA daemon can execute within the context of the authentication vServer . The AAA daemon in some embodiments can receive login information from one or more cores and can authenticate the login information for those cores. Authenticating login information can include authenticating a user and generating an authentication certificate. The AAA daemon in some embodiments can be accessed by each packet engine executing on each of the cores of the multi core system . While illustrates an AAA daemon executing on a single core in some embodiments an instance of the AAA daemon may execute on each core in the multi core system .

In some embodiments the AAA daemon and or the authentication vServer can communicate with a secure sockets layer SSL module or engine that can process a SSL certificate. In one embodiment the SSL module can be a program application script process or executable set of instructions executing on at least one core or processor of the appliance or device. The SSL module in one embodiment can extract parameters from a SSL certificate to authenticate one or more users client machines. In one embodiment the SSL module can retrieve or extract from a SSL certificate an authentication cookie a certification cookie an authentication certificate a certification entry an authentication key user information user client device information or any other authentication component that could be used by the SSL module the AAA daemon or the authentication vServer to authenticate the user and or the client. In some embodiments the SSL module receives the SSL certificate from a client that wishes to access a network. While illustrates a SSL module executing on a single core in some embodiments each core can execute an instance of the SSL module .

In one embodiment the cores can each access a session table stored in a memory repository assigned to or otherwise associated with a particular core . Embodiments of the session table may include any data construct such as a list database hash table etc. The memory repository can be referred to as a core s local memory. A session table may store any type or form of data such as user and or session information about communication sessions managed executed and or facilitated by a core . Session information in some embodiments can include a session identifier ID a session state authentication credentials including an authentication certificate information about a user communicating over one or more networks via the session resources accessible via the session and any other session information. The session table may be accessed by any program core or application executing within the multi core system . In one embodiment the session table can be accessed by a packet engine an AAA daemon and or a SSL module . In some embodiments a session table of a core may be accessed only by that core. For example a session table may be located in the local memory of a core.

In some embodiments each core can include a session buffer . Session buffers in some embodiments can be storage repositories accessible to a core to store session information. A session buffer may reside in local memory of a core . In some embodiments the session buffer can be part of a larger shared memory . In other embodiments the session buffer can be part of memory allocated to each core . The session buffer in some embodiments can be of at least a minimum size so as to minimize the amount of session data that needs to be copied from one core to another.

The multi core system in some embodiments can include a shared memory . The shared memory can be accessed by substantially all the cores and or the applications executing on those cores . The shared memory may be maintained and or used for session propagation between an owner core and one or more other cores. The owner core may provide store or maintain session replication information in the shared memory. The owner core or the multi core system may pass an address of the shared memory to various cores e.g. using core to core messaging. The owner core may maintain the information regarding which cores have a copy or instance of the session i.e. replicated. In the shared memory the owner core may maintain information about pending session replication requests and status. The shared memory may be reclaimed when there are no outstanding requests and or user cores remaining for a particular session.

In some embodiments the shared memory can include one or more buffers e.g. buffers of 2K 4K 8K etc. In other embodiments the buffers may have a maximum size such that a maximum sized buffer may not be maintained in the memory pool but can be freed substantially immediately after acknowledgement is received from a requesting core . In some embodiments the system may maintain two lists a free memory list and a cached session list. The free list in some embodiments lists buffers that can be used substantially immediately. The cached session list in other embodiments can include pointers to existing session for which the control core A has received a request so that a request for an existing session can be served substantially immediately. This list in some embodiments can be a least recently used LRU list that tracks the least recently used sessions. In some embodiments the list can be used when no buffers are available from the free list. In some embodiments there may be a global maximum shared memory limit for each core e.g. 256K . When the global maximum is reached a memory recovery program can be triggered that commences reclaiming memory and reallocating the memory to other cores .

In some embodiments a local buffer of an owner core such as a session buffer may be used to propagate session data e.g. session replication data . Session data may be stored or maintained in the local buffer. In some embodiments session data is serialized into the local buffer. The session data may be passed to a messaging API of the owner core or the multi core system. The API may then send the session data to each of the requesting cores e.g. via core to core messaging.

Session data may be maintained in a session data structure of any type of form. In some embodiments a session buffer provide the data structure. The session structure may be of any size e.g. 2.3 KB. To minimize the amount of data that needs to be copied the structure may be organized to copy from an offset X to an offset Y of a reference location in a session buffer or local memory. In some embodiments the session data which can contain dynamic data may be replicated for each successful request from a requesting core. The session data may include one or more of the following without limitation 

In some embodiments each of the cores in a multi core system includes a traffic management vserver. To allow traffic and authentication processing on the cores the system can allow propagation of an AAA session to a non owner core receiving a request with a valid session cookie. When unauthenticated traffic received by a traffic management vserver of a core the traffic may be redirected to the Authentication vserver. After authentication is complete the traffic may be further processed by respective traffic management vserver that received the traffic. The authentication vserver may steer received traffic to a particular core e.g. to PE 0. In some embodiments the authentication vserver processes the traffic on the core executing the authentication vserver. In various embodiments the authentication vserver may perform one or more of the following as part of the authentication process without limitation 

Illustrated in is one embodiment of a method for authenticating a client and or a user of a client. An authentication vServer can receive a login request issued by a client and or a user of the client Step . Upon receiving the login request the authentication vServer can authenticate the user and or the client accessed by the user e.g. based in part on the login information included in the login request Step . The authentication vServer can issue a challenge handshake to the client and or the user of the client Step . Based on a received response from the challenge handshake Step the authentication vServer can determine whether to authenticate the client and or the user of the client Step .

Further referring to and in more detail in one embodiment the method can be carried out by an authentication vServer . This embodiment may incorporate what is referred to as dialogue mode authentication. In another embodiment the method can be carried out by a packet engine executing on a control core A. In still another embodiment the method can be carried out by an AAA daemon . The method in some embodiments can be carried out by any combination of the authentication vServer the packet engine the AAA daemon and the SSL module .

In some embodiments a multi core system receives a login request issued by a client and generated by a user of a client Step . Upon receiving the login request the request can be forwarded to an authentication vServer executing on a core . In another embodiment a packet engine executing on one of the cores can receive a login request and either process the request or forward the request to an authentication vServer .

In one embodiment the request is received by a traffic management vServer not shown . The traffic management vServer receives the request and determines whether the login request is authenticated or unauthenticated traffic. This determination can be made by analyzing an encoding encryption and or payload of the login request. Upon determining that the login request is unauthenticated network traffic the traffic management vServer may forward the login request to the authentication vServer . In some embodiments the traffic management vServer may be a packet engine executing on a control core of the multi core system .

Upon receiving the login request the authentication vServer may authenticate the client and or user of the client Step . The authentication methods used by the authentication vServer can be any authentication method or protocol. In some embodiments the authentication vServer can search for the user name and password provided in the login information in an authentication table or database. In other embodiments the authentication vServer can apply a hash algorithm to a user identifier ID and password. The authentication vServer may then identify the resulting hash in a hash table of user authentication information. In some embodiments the authentication vServer may request a user to confirm the user s identify e.g. by providing a passcode word or key. In many embodiments the authentication vServer can authenticate a user of the client by verifying that a provided user name or user ID and provided password match a user name ID and password combination stored in an authentication table or database. The authentication process may occur over a single connection with the user.

In some embodiments the core receives a response from an AAA daemon indicating that the authentication is in dialogue mode. The authentication vserver upon entering dialogue mode may create a dialogue cookie on the core receiving the response. The multi core system may also send the dialogue response to the user client requesting login. The response may include a challenge handshake request to the user.

In some embodiments the authentication vServer can verify the user by issuing a challenge handshake to the client Step . The challenge handshake can be any challenge handshake. In some embodiments the challenge handshake can include the authentication vServer issuing the client a challenge message. The client responds to the challenge message with a value Step e.g. a hash value or other value. In some embodiments the authentication vServer verifies this value against an expected value. In certain embodiments the challenge response may be sent to another core. That other core may complete the authentication e.g. via an authentication vserver of this core or in communication with an AAA daemon . In some embodiments the receiving core may pass the client response to the core that owns the dialogue cookie which may then forward to an AAA daemon or authentication vserver. When the received challenge response matches the expected value the corresponding authentication vServer and or AAA daemon may authenticate the client and therefore the user of the client. When the received challenge response does not match the expected value the authentication vServer and or AAA daemon may not authenticate the client or the user of the client.

Upon receiving the challenge handshake response Step the authentication vServer can determine whether to authenticate the client user of the client. In many embodiments the client and therefore the user are not authenticated unless the challenge handshake response matches an expected value Step . In embodiments where the response does not match the expected value the client and therefore the user are not authenticated. A response from the authentication vserver or AAA daemon regarding the result of the authentication may be passed back to the core receiving the client response. Some or all of the communications may be provided via core to core messaging. Additional features of the method provided above may incorporate steps and features from the methods discussed below in connection with .

In some embodiments the method can further include establishing a user session. When in some embodiments the authentication vServer authenticates a user the authentication vServer can then generate a user session. In some embodiments the packet engine generates the user session in response to authentication of the user. In still other embodiments generating the session can include assigning a session identifier ID to the session and generating a domain session cookie for the session.

While in one embodiment the authentication vServer generates the session in other embodiments the authentication vServer transmits the authenticated login request to a packet engine executing on one of the cores . Upon receiving the authenticated login request the packet engine of the receiving core can generate the session the session ID and the domain session cookie. In some embodiments the receiving core can be referred to as the owner core . This owner core in some embodiments can manage session states across all cores of the multi core system .

Illustrated in is on embodiment of a method for managing sessions amongst cores in the multi core system . In one embodiment a packet engine or other application executing on a core receives a request from an authenticated client and or user of the client Step . The receiving core upon receiving the request parses or otherwise searches through a session table of the core to determine whether the session of the request is stored in the session table Step . Upon identifying the session within the session table of the core the packet engine or other application can identify a state of the session Step . When in some embodiments the session is TIMED OUT the application or packet engine can modify or otherwise mark the session entry in the session table to indicate that the session is ACTIVE Step .

Further referring to and in more detail in one embodiment the method can be carried out by a packet engine of the core . In other embodiments the method can be carried out by the core an authentication vServer executing on the core any other application or program executing on the core .

The packet engine in some embodiments receives a request issued by a client Step . The request can be any type of request including a request to connect to a machine on a network a request for information or a request to connect to a particular network or access a particular application on a network. In some embodiments this request can include one or more session identifiers such as a session ID a user ID an authentication certificate or any other session identifier. These session identifiers in some embodiments can be used by the packet engine or other programs to determine whether the receiving core owns the session including the client that issued the request.

In some embodiments the packet engine can use a session ID included within the request to determine whether the session ID is stored in a session table of the core Step . Determining whether the session ID is stored in a session table can include parsing looking or searching through the session table to identify the session ID within the session table . When in some embodiments the session ID is not found within the session table the packet engine can execute a process substantially similar to the one described in to re establish the session. In embodiments where the session ID is found within the session table the packet engine can review the entry in the session table corresponding to the session ID to determine the attributes of the session.

The packet engine in some embodiments can determine a state of the session Step upon determining that the session ID is present in the session table . A session state can be any of the following states ACTIVE EXPIRED TIMED OUT or any other session state. In embodiments where the session state is determined to be EXPIRED the packet engine can redirect the client to a login page. In embodiments where the session state is determined to be ACTIVE the packet engine may do nothing and process the request normally. In embodiments where the session state is determined to be TIMED OUT the packet engine can mark the session as ACTIVE in the session table Step .

In some embodiments the receiving core may not be the owner core however the session table may include an entry for the session indicating that the session is TIMED OUT. In these embodiments the packet engine can mark the session as active in the core s session table and send a message to the owner core to mark the session as active. The packet engine in this embodiment can wait for a reply from the owner core and when a reply is received the packet engine can continue to process the request. When no reply is received the packet engine can redirect the client to a login page. In some embodiments no reply can indicate that the session was killed by the owner core .

Illustrated in is one embodiment of a method for propagating authentication session information to a plurality of cores of a multi core device. The method may include steps for handling a session lookup. The method may include establishing by an authentication virtual server executing on a first core of a plurality of cores of a device intermediary to a plurality of clients and one or more servers a session for a user. The authentication virtual server may authenticate the session. A traffic management virtual server may execute on another core of the plurality of cores. The traffic management virtual server may receive a request via the session to access a server of the one or more servers. The traffic management virtual server may identify responsive to a determination that the session is not stored by the second core from an identifier of the session that the first core established the session. The packet engine of the receiving core may fail to identify a received session ID in the session table on that packet engine s core . Step . The second core may send to the first core a second request for data for the session identified by the identifier. The packet engine may transmit this request to a control core indicating that the session ID was not found and further specifying the session ID Step . A program or application executing on the control core can determine whether the session ID is valid. The second core may receive from the owner core a response to the second request. The response may identify whether the session is valid. Step . When the session ID is valid the application can send the packet engine of the initial core session data that can be used by the packet engine to recreate the session Step .

Further referring to and in more detail in one embodiment an authentication virtual server may execute on a core of a plurality of cores of a device. The device may be intermediary to a plurality of clients and one or more servers. The authentication virtual server may authenticate the session such as using any embodiment of the methods describe herein including that described in connection with . In some embodiments the authentication virtual server sets a cookie for the session. The cookie may include a domain session cookie. The core executing the authentication virtual server can be referred to as the owner core of the cookie. The authentication virtual server may establish a session for a user. e.g. responsive to the authentication. The core can be referred to as the owner core of the session. The owner core may create maintain and or provide a session buffer and or session table to include information regarding the session.

A traffic management virtual server may execute on another core i.e. non owner core of the plurality of cores. The traffic management virtual server may receive a request via the session to access a resource such as a server of the one or more servers. A user may send this request to the device. The device may forward the request to the present core i.e. receiving core via a distributor module for example based on load and or power balancing policies. In various situations the receiving core may be the owner core or another core. In some embodiments more than one core may receive the request. The request may include an identifier of a session session identifier requested by the user or user client.

A core receiving the request may perform a lookup of the session identifier in the core s local memory e.g. in the session buffer or session table. If the lookup for the session identifier succeeds the core may determine whether it is the owner core also referred to as the control core of the session. The control core A in some embodiments can be any core in the multi core system . In other embodiments the control core A can be the core executing any one of an authentication vServer an AAA daemon and or a SSL module .

If the core is the owner and session state is EXPIRED the core may redirect the request to a login page e.g. for re authentication and or establishment of a new session. If session state of the session is TIMED OUT the core may mark the session to be active again. Responsive to marking the session as active the owner core may grant the user access to the session.

A traffic management virtual server and or packet engine on a receiving core may fail to identify a session identifier in a session table of the receiving core Step . In some cases the core may determine that it is not the owner of the session. The core receiving the request determine that it is not the owner of the session based on a lookup of the session identifier in the core s local memory i.e. in a session buffer and or session table. In certain cases the core may determine that it is not the owner of the requested session but has access to the session e.g. via a copy or instance of the session. The core may determine that it has access to the session by checking the session identifier against a respective session buffer and or session table.

In certain embodiments the traffic management virtual server may determine that the session is not stored in memory local to the second core. In some embodiments the traffic management virtual server of the receiving core may determine that the requested session is not stored or identified by the receiving core based on a lookup of the requested session identifier in a session buffer and or session table. The traffic management virtual server may determine that the session is not owned by the receiving core based on the session identifier in the local memory lookup. The traffic management virtual server may identify responsive to a determination that the session is not stored by the second core from an identifier of the session that the first core established the session. The receiving core may decode a core identifier of the owner core encoded in the identifier of the session. Based on the core identifier the receiving core can determine whether the receiving core is the owner core. The receiving core may decode the session identifier using any of the decryption keys described above in connection with . Furthermore any of the communications described herein between cores may be encrypted decrypted using the keys described above in connection with .

If the core is not the owner of the session the receiving core may send a message as a requesting core to the owner core. The traffic management vserver of the receiving core may send the message for example via a packet engine of the core. By way of illustration we refer to the packet engine as transmitting messages on behalf of the core and or traffic management vserver.

Upon failing to identify the session ID the packet engine can send a message to a control core A indicating that the session ID was not found and specifying the session ID Step . In some embodiments the packet engine can transmit the message to the control core A via core to core messaging. In other embodiments the packet engine can transmit the message to the control core A via any inter core communication protocol. The packet engine in some embodiments can transmit the session ID to the control core A. In other embodiments the packet engine can transmit any session information. In still other embodiments the packet engine can transmit the session ID and or the session information along with one or more error codes indicating the failure to identify the session ID. In some embodiments the receiving core can block until the receiving core receives a response from the control core A. Blocking in some embodiments can be carried out using a ASYNC framework.

If the core is not the owner of the session and session state is TIMED OUT the receiving core may send a message as a requesting core to the owner core to mark the session as active. The requesting core may wait for owner core s reply for marking the session as active. If owner replies with success regarding the marking the requesting core may continue to proceed this request. If the owner core replies a failure with regards to the marking e.g. the session might already be terminated on the owner the receiving core may redirect the user to the login page.

In some embodiments the requesting core may send to the owner core a request for data for the session identified by the identifier. The requesting core may generate a core to core message specifying the identifier of the session. The requesting core may direct the request to a default core or a plurality of cores e.g. so that the owner core may respond and or be identified. The requesting core may be able to identify the owner core from the session identifier or using a lookup of the session identifier in the requesting core s local memory.

The control core A can receive the request from the receiving core and may search for the session identifier to determine whether the session identifier ID is valid Step . In some embodiments a traffic management vserver or packet engine executing on the control core A can search for the session ID. In other embodiments any of the following programs can search for or lookup the session ID authentication vServer AAA daemon and or SSL module .

In embodiments where the session ID is found the control core A can obtain session information and send the information to the receiving core Step . The requesting core may receive from the control core a response to the request for session data. In some embodiments the control core A can send the session information using core to core messaging. The requesting core may receive from the owner core a response comprising data to create the session on the requesting core. Upon receiving the session information the receiving core can access or recreate the session using the information. The receiving core may access the session by establishing a copy or instance of the session locally or otherwise using the session data. In some embodiments the requesting core may create the session in memory local to the second core.

In other embodiments upon receiving the information the receiving core can determine whether a domain authentication cookie included within the session information is valid. The receiving core may determine that the cookie for the session received from the first core is invalid. Upon determining that the domain authentication cookie is not valid the receiving core may redirect the domain authentication cookie to the authentication vServer . The receiving core may redirect the user to a login page. In some cases a receiving core can send the control core A multiple requests for the same session e.g. multiple requests for session information. Thus before a receiving core processes session information from a control core A the receiving core may perform an additional session lookup using the session ID included in the session information.

In some embodiments the requesting core may receive from the owner core a response comprising a successful message. Responsive to the successful message the requesting core may perform a local session lookup using the identifier of the session or based on the successful message. The requesting core may update its local memory with the session identifier. The requesting core may update its session buffer and or session table using the session identifier or based on the successful message.

In some embodiments one core can send multiple requests to the control core A for each connection for the same session. Thus the control core A may want to track the number of requests received for a particular session. When responses are transmitted to and or received by the requesting core the count can be decremented accordingly. In some embodiments where this count is a non zero value the session in question may not time out.

In other embodiments a control core A can send a response to a requesting core before the requesting core can read the response. In these embodiments a kill command may be issued by an administrator or a user. Responsive to this kill command the control core A may remove the session. When an acknowledgment for this session arrives to the control core A from the requesting core the control core A may send the requesting core a message to delete the session.

In various embodiments the response from the control core may identify whether the session is valid. In some embodiments the method includes a determination that a session or the session ID is invalid. Upon determining this the control core A may transmit to the requesting core a message indicating the session or session ID is invalid. This message in some embodiments can be a failure message. The requesting core may receive from the control core a response comprising a failure message identifying that the control core determined the identifier of the session to be invalid. In other embodiments the message can be an error message. The control core A in some embodiments can send this message using core to core messaging. Upon receiving the message identifying the session as invalid the requesting core may redirect the user to a login page. In some embodiments if the user has been authenticated the requesting core may establish a new session responsive to the user s request. In certain embodiments the requesting core may provide the user access to an existing session.

Illustrated in is one embodiment of a method for propagating sessions to other cores of a multi core system . In some embodiments session data is serialized in a session buffer Step . The serialized session data is passed to a messaging application program interface API that transmits messages amongst the cores of the multi core system Step . The messaging API then forwards the serialized session data to the requesting core Step .

Further referring to and in more detail in one embodiment a packet engine authentication vServer or other application executing on a core serializes the session data in a session buffer Step . In some embodiments serializing session data includes reorganizing the session data to copy from an offset X to offset Y of a reference location such as some identified relevant data. This relevant data can be username password SSO username domain of the authentication vServer groups to which the user belongs and a default deny policy name evaluated as part of session policy evaluation on owner. In some embodiments this data can be specific to an AAA system.

Passing the session to the messaging API Step can include passing the session to an application that carries out core to core messaging. In some embodiments the messaging API can execute within the context of a control packet engine . In other embodiments an instance of the messaging API can execute in each core . In still other embodiments the messaging API can execute on a control core A.

Illustrated in is another embodiment of a method for propagating sessions to other cores of a multi core system . This method makes use of a shared memory buffer accessible by substantially every core in the multi core system . A control core A writes session information into the shared memory Step and passes the address of the shared memory buffer to the receiving core Step . The control core A can further maintain a list of which cores have replicated the session information Step . When no additional receiving cores need to copy the session information the control core A can reclaim the shared memory Step .

Further referring to and in more detail in one embodiment a control core can write session information into shared memory Step . In some embodiments the shared memory can be used for session propagation. In other embodiments writing the session information into the shared memory buffer can include writing the session replication information into shared memory.

In some embodiments the control core A can pass the address of the shared memory buffer to a receiving core Step . Passing the address of the shared memory buffer can include passing the address of the shared memory buffer using core to core messaging. The control core A in some embodiments can maintain information about which cores have accessed the session information and replicated the session Step . In some embodiments the control core A can also maintain a list of which cores have a session replication response pending. When no outstanding readers for a session are left the shared memory can be reclaimed Step .

Illustrated in are embodiments of methods where authentication is handled on a core by core basis. Thus in these methods authentication is handled each core independently rather than solely by an authentication vServer . In some embodiments each core can open a connection to an AAA daemon executing on a core in the multi core system . Opening a connection to the AAA daemon in some embodiments can include instantiating an instance of the AAA daemon on the core . When an AAA traffic management login occurs each core that receives the login request can send the login request to the AA daemon and or an instance of the AAA daemon . In some embodiments the AAA daemon can authenticate the user based in part on the authentication method and the login information. The method illustrated in can be referred to as a dialogue mode of authentication while the method illustrated in can be referred to as a certificate based mode of authentication.

Further referring to and in more detail in one embodiment the method can include one or more cores forwarding a received login request to an AAA daemon for authentication Step . In some embodiments each core that receives the login request can forward the login request to the AAA daemon . In other embodiments the login request can be forwarded to an AAA daemon or an instance of an AAA daemon . In still other embodiments a control core or owner core receiving the login request can forward the request to an AAA daemon .

In some embodiments the authentication vServer indicates that the authentication mode is in a dialogue authentication mode. A dialogue cookie can be generated and stored on a receiving core Step . In one embodiment the dialogue cookie can be created by the core that received the dialogue response from the authentication vServer indicating that the authentication mode will be a dialogue authentication mode. In other embodiments the authentication vServer can forward an AAA daemon a message indicating that the authentication mode is a dialogue authentication mode. Upon receiving the notification from the authentication vServer the AAA daemon can transmit the login request to one of the cores of the multi core system . The core that receives the login request can generate a dialogue cookie and store the dialogue cookie in a memory element of that core .

The AAA daemon or an instance of the AAA daemon can then transmit to the client that issued the login request a challenge question and can receive the response issued by the client Step . In some embodiments the challenge question may be a question that asks a user of the client to confirm their identity by entering in any one of a passcode password key or other authentication information. Upon receiving the challenge question a use of the client can enter in an answer to the challenge questions and the client can generate a response that includes the user s answer. The client can send the challenge question response to the multi core system where any core can receive the response. In some embodiments when a core other than the core that has the stored dialogue cookie receives the client response that core can forward the response to the owner core.

In some embodiments any core of the multi core system can receive the challenge answer response generated by the client. When a core other than the core having the dialogue cookie receives the response that core can forward the response to the owner core having the dialogue cookie. Upon receiving the response the owner core can forward the response to the AAA daemon for authentication Step . In some embodiments the non owner core can forward the response to the owner core via core to core messaging. When the owner core forwards the challenge answer response to the AAA daemon the owner core can forward the challenge answer response to the AAA daemon or an instance of the AAA daemon .

The AAA daemon or AAA daemon instance can authenticate the challenge answer response. Upon authentication and upon determining that the challenge answer response is correct the response can be passed back to the owner core having the dialogue cookie Step . In some embodiments the AAA daemon can authenticate the challenge answer response by checking the response against an expected response. When the challenge answer response matches the expected response the AAA daemon can issue an accept. When the challenge answer response does not match the expected response the AAA daemon can issue a reject. In some embodiments the response can be forwarded to the owner core along with an indication of whether the AAA daemon accepted or rejected the response. When the owner core receives a rejected response the owner core can reissue the login page to the client. In other embodiments when the AAA daemon determines a rejected response the AAA daemon or another application can reissue the login page to the client.

In some embodiments the dialogue authentication method can be iterative such that it can continue or repeat until a correct challenge answer response is provided. In other embodiments the dialogue authentication method can be carried out until a maximum number of responses is reached. Communication between the client and the authentication server in some embodiments can occur over a single connection throughout the authentication method .

Now referring to and in more detail in one embodiment the method can include a process for receiving a SSL certificate from a client and using the SSL certificate to authenticate a user of the client. In some embodiments a SSL module can extract one or more parameters from a SSL certificate and using the extracted parameters can perform one or more authentication methods. In some embodiments the authentication method can be combined with one or more other authentication methods. For example in one embodiment the method can be combined with the dialogue authentication method illustrated in . In this embodiment the user can be authenticated based on other authentication policies after the SSL certificate is validated. In multi core systems the method may require an additional step of propagating the SSL certificate to each of the cores in the multi core system so that each core can extract the attributes from the SSL certificate.

In one embodiment a SSL module or other application can generate a certificate entry Step . The SSL module in some embodiments can generate the certificate entry when certificate authentication is enabled and on the initial connection to an AAA traffic management vServer. In other embodiments the SSL module can generate the certificate entry when a user login request is received.

The SSL module in some embodiments can enter the certificate entry in a hash table of the multi core system and can send a certificate cookie to the client Step . In some embodiments the hash table can a hash table of a control core A of the multi core system . In other embodiments the hash table can be a hash table in a shared memory buffer The certificate cookie in some embodiments can be a SSL certificate. In other embodiments the certificate entry can include attributes of the certificate cookie issued to the client. The client in some embodiments can be the client used by the user to issue the initial login request.

A subsequent client request that includes the certificate cookie can be received by the multi core system Step . The SSL module upon receiving the certificate cookie can identify a certificate entry in the hash table using the received certificate cookie Step . In some embodiments the certificate cookie can be a SSL certificate. In these embodiments the SSL module can extract attributes of the SSL certificate and use those attributes to identify the certificate entry in the hash table. Identifying the certificate entry in the hash table in some embodiments can include applying a hash function to the SSL certificate attributes.

Based in part on the certificate cookie and or the certificate entry a decision can be made as to what authentication method should be used Step . In some embodiments the authentication method can include one or more certification policies. These policies in some embodiments can be included in the hash table. Thus when the cert entry is obtained the certification policies can be obtained. Authentication of the user request in some embodiments can be carried out in accordance with the certification policies.

In some embodiments new client requests can be routed to different cores other than the core where the certificate entry was created and stored. In these embodiments a SSL module or other application can send the certificate entry to other cores for storage in a hash table. Sending the certificate entry to other cores can include sending the certificate entry using a core to core messaging system.

The certificate mode of authentication may be used with the dialogue mode of authentication. For example after validating the certificate the appliance can authenticate the user based on other authentication policies which were configured. This authentication process may triggered a dialogue mode. In accordance with the dialogue mode method a Dialogue Cookie may be set to identify the core on which dialogue connection is present.

It should be understood that the systems described above may provide multiple ones of any or each of those components and these components may be provided on either a standalone machine or in some embodiments on multiple machines in a distributed system. In addition the systems and methods described above may be provided as one or more computer readable programs or executable instructions embodied on or in one or more articles of manufacture. The article of manufacture may be a floppy disk a hard disk a CD ROM a flash memory card a PROM a RAM a ROM or a magnetic tape. In general the computer readable programs may be implemented in any programming language such as LISP PERL C C C PROLOG or in any byte code language such as JAVA. The software programs or executable instructions may be stored on or in one or more articles of manufacture as object code.

While the invention has been particularly shown and described with reference to specific embodiments it should be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention as defined by the following claims.

