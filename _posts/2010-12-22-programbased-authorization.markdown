---

title: Program-based authorization
abstract: Techniques which allow definition and enforcement of program-based action authorization policies. On a computer, an action or execution attempt is intercepted in real-time. The subject process, the program file of the subject process, the attempted action and the object of the attempted action are determined. An authorization policy considering the program file indicates whether the attempted action is authorized or not. In a tracking mode, the attempted action and its authorization are logged and the attempted action is allowed to proceed. In an enforcement mode, unauthorized attempts are blocked and logged, thereby enforcing the authorization policy.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08321932&OS=08321932&RS=08321932
owner: McAfee, Inc.
number: 08321932
owner_city: Santa Clara
owner_country: US
publication_date: 20101222
---
This application is a continuation and claims the benefit of priority under 35 U.S.C. 120 of U.S. application Ser. No. 11 400 085 filed Apr. 7 2006 now U.S. Pat. No. 7 870 387 entitled PROGRAM BASED AUTHORIZATION Inventor s Rishi Bhargava et al. The disclosure of the prior application is considered part of and is incorporated by reference in the disclosure of this application.

This application is related to the following all of which are incorporated herein by reference in their entirety 

co pending U.S. patent application Ser. No. 10 651 591 entitled Method And System For Containment of Networked Application Client Software By Explicit Human Input and filed on Aug. 29 2003 

co pending U.S. patent application Ser. No. 10 651 588 entitled Damage Containment By Translation and filed on Aug. 29 2003 issued as U.S. Pat. No. 7 464 408 on Dec. 9 2008 

co pending U.S. patent application Ser. No. 10 806 578 entitled Containment Of Network Communication and filed on Mar. 22 2004 issued as U.S. Pat. No. 7 783 735 on Aug. 24 2010 

co pending U.S. patent application Ser. No. 10 739 230 entitled Method And System For Containment Of Usage Of Language Interfaces and filed on Dec. 17 2003 issued as U.S. Pat. No. 7 840 968 on Nov. 23 2010 

co pending U.S. patent application Ser. No. 10 935 772 entitled Solidifying the Executable Software Set of a Computer and filed on Sep. 7 2004 issued as U.S. Pat. No. 7 873 955 on Jan. 18 2011 

co pending U.S. patent application Ser. No. 11 060 683 entitled Distribution and Installation of Solidified Software on a Computer and filed on Feb. 16 2005 

co pending U.S. patent application Ser. No. 11 122 872 entitled Piracy Prevention Using Unique Module Translation and filed on May 4 2005 issued as U.S. Pat. No. 7 603 552 on Oct. 13 2009 

co pending U.S. patent application Ser. No. 11 182 320 entitled Classification of Software on Networked Systems and filed on Jul. 14 2005 issued as U.S. Pat. No. 7 856 661 on Dec. 21 2010 

co pending U.S. patent application Ser. No. 11 346 741 entitled Enforcing Alignment of Approved Changes and Deployed Changes in the Software Change Life Cycle by Rahul Roy Chowdhury E. John Sebes and Jay Vaishnav filed on Feb. 2 2006 issued as U.S. Pat. No. 7 757 269 on Jul. 13 2010 and

co pending U.S. patent application Ser. No. 11 277 596 entitled Execution Environment File Inventory by Rishi Bhargava and E. John Sebes filed on Mar. 27 2006 issued as U.S. Pat. No. 7 895 573 on Feb. 22 2011.

Invention relates generally to authorization of actions on computer systems and in particular to authorization based on the program initiating the action.

Access control is a useful and practical concept in the field of information technology. The definition monitoring and enforcement of access control policies contribute to the predictable and manageable operation and maintenance of business assets and processes.

An abstraction central to access control is that of subjects performing actions on objects. A familiar example of this is a user subject attempting to delete action a file object on a computer. The usefulness of this abstraction stems from the fact that policies can be defined based on an identification of the subject and the object as well as an authorization for the particular action attempted by the subject on the object. Once defined such policies can be monitored and enforced affording visibility into and control over the access and action patterns.

While actions attempted by human subjects are ultimately performed by one or more processes running on the computer in traditional access control the authorization policies are generally defined for human subjects such as users and system administrators and tied to credentials such as logins and passwords and file ownerships. As a result while in theory it is possible to define authorization policies based non human subjects such as programs and processes running on a computer today such definitions simply defer to the particular user context within which the subject program or process is executing using that context as an input into the authorization policy instead of relying on an identification of the process or program itself.

There are a number of reasons why program based authorization is increasingly needed today including a rise in the software based automation of tasks and decisions such as system provisioning and anti malware protection a prevalence of exploits attempted by programs and processes running with minimal human interaction or supervision such as software worms the frequent practice of privilege escalation by both programs and humans attempting to gain a privileged user status in order to run a program with broader permissions than are allowed under the lower privilege and often resulting in malicious or accidental system breakage and so forth.

Therefore a need exists for techniques that allow program based authorization allowing authorization decisions to take into account not only the action the object and the user context of the subject process but also a range of other attributes of the subject process such as the program being executed by the subject process.

We disclose techniques which allow definition and enforcement of program based action authorization policies. On a computer an action or execution attempt is intercepted in real time. The subject process the program file of the subject process the attempted action and the object of the attempted action are determined. An authorization policy considering the program file indicates whether the attempted action is authorized or not. In a tracking mode the attempted action and its authorization are logged and the attempted action is allowed to proceed. In an enforcement mode unauthorized attempts are blocked and logged thereby enforcing the authorization policy.

In the program based authorization techniques described herein a process attempt to perform an action on an object is intercepted. A program file representing code or instructions being executed by the process is then determined along with the action and the object. By way of example the interception and subsequent determinations can be performed by a software agent running on the computer. Referring to an authorization policy which considers the program file action and object a decision is made to either allow or block the attempted action. In both cases it may be desirable to generate a log or alert indicative of the decision.

At some point during its execution subject process may attempt to perform an action on an object . For example object may be a file and the action attempt may comprise an attempt to write to the file. Other examples of objects and actions are described below.

The action attempt is intercepted and an authorization policy is consulted. The authorization policy takes into account the subject program file and optionally may also consider one or more other attributes of the subject process or of the program file one or more attributes of the object and or one or more attributes of the action being attempted by subject process . The authorization policy indicates whether the attempted action is authorized or not.

There are two broad modes of operation for the program based authorizations of the present invention a tracking mode and an enforcement mode . Both modes allow authorized attempts to proceed but the modes differ in how they handle unauthorized attempts. In an enforcement mode unauthorized attempts are blocked. In a tracking mode unauthorized attempts are allowed to proceed but they are logged. Tracking mode is useful for examining what effects an authorization policy would have on a system were the policy to be enforced. Tracking mode allows experimentation with and fine tuning of authorization policies on a live computer as well as real time feedback based thereon without disturbing the operation or behavior of the computer . Once an authorization policy is deemed acceptable it can be enforced by switching from tracking mode to enforcement mode.

A typical example of an object is a file managed by a file system of computer . In that case the action attempt is a file system action attempt such as a read write or delete operation on the file or it may be an attempt to execute the file. Another example of an object is a registry entry such as one managed by a Windows operating system. In that case the action attempt may be a retrieve create or delete a registry entry. Other examples of objects include containers or resources managed by a service oriented architecture SOA data structures or other objects stored in memory or any other objects that are accessible to subject process . In general the actions that can be attempted by the subject process depend on the object and how the object is being managed. While the following description is illustrated mainly with reference to file system action attempts this is by way of example and is not intended to limit the scope of the disclosed techniques. It should be obvious to one of ordinary skill in the art that the disclosed techniques can be applied to program based authorization of any action attempted by a subject process on a computer. Further example actions for files and registry entries are enumerated below.

Step consults an authorization policy to determine whether the attempted action is authorized or not. The authorization policy takes into account the subject program file of the subject process and may optionally also consider any other attributes that were determined in step . The authorization policy preferably also takes into account the attempted action and one or more attributes of the file object determined in step example attributes are described below . Optionally the authorization policy may disregard some of the supplied information. For example the authorization policy may disregard some or all of the file object attributes and consider only the attempted action and subject program file of the subject process . Authorization policies may be stored using any appropriate data structure for example in a computer readable medium comprising a matrix with a plurality of entries with an entry associating a program file subject with one or more allowed actions and objects on the computer.

If the action is authorized step allows the action to proceed and optional step generates one or more log entries and or alerts indicating that the authorized action was allowed to proceed. If the action is not authorized step blocks the action from proceeding and optional step generates one or more log entries and or alerts indicating that the unauthorized action was blocked. A log entry or alert may include information about the subject process subject program action object relevant authorization policy date and time and or any other information available at the time of logging. Steps and are for an enforcement mode embodiment of the present invention. In a tracking mode embodiment as described above step is skipped allowing the unauthorized action to proceed and recording logs and or alerts at step .

By way of example and not limitation attributes of the subject process action and object may include the following 

We now turn to describing the steps of in more detail. For the interception step OS provisions can be used to intercept file system action requests and registry action requests as well as to determine whether a file system action request is a an attempt to read a file write to a file delete a file rename a file move a file append a file truncate a file get or set permissions on a file or get or set any other attribute of a file. For example in a Microsoft Windows OS environment a filter driver can be used to intercept file system requests and determine their type.

In other operating systems such as Linux or other Unix derived operating systems a shim module or wrapper mechanism can be used for that purpose. A wrapper mechanism would redirect action attempts e.g. system calls to a wrapper library that represents an entry point for the interception code and which may eventually call into the original library or code that implements the intended action attempt. One way of indicating redirection to the wrapper library comprises setting one or more environment variables indicating library load paths and sequences.

A shim module redirects system calls to custom interception code within the kernel and the interception code decides whether or not to redirect execution to the kernel code that implements the system call. For example in a Unix derived OS one or more virtual file system VFS methods may be patched to facilitate redirection to interception code. These and other Techniques for the interception of file system requests should be obvious to one of ordinary skill in the art and are also briefly described in the above referenced co pending U.S. patent application Ser. No. 11 346 741. Similarly OS provisions can be used to intercept registry action requests and determine whether the request is an attempt to read or retrieve an entry delete an entry write to an entry create an entry or perform any other actions on the entry. We continue to illustrate the steps with exemplary references to file system requests.

Once a file system request is intercepted the request indicates the file object as well as the action that the subject process is attempting to perform on the file object . It then remains to determine the subject process that initiated the file system request step . One technique for doing this is to start with a unique identifier for the process context of the currently executing subject process . This identifier need not necessarily comprise the traditional process identification number PID assigned to processes by many operating systems though it may. For example in a Microsoft Windows OS an EPROCESS block or a process handle can be used to uniquely identify the subject process .

Once an identifier for the subject process is determined it remains to infer the subject program file and optionally one or more other attributes of the subject process step . For some operating systems such as a Microsoft Windows OS this information may not be available via a published application programming interface API . In such cases one technique for inferring the subject program file associated with the subject process is to explicitly keep track of the process program associations so that they can be referred to when needed. One way to do this is by implementing a Process Tracking Framework abstraction which upon receiving an identifier of a subject process context indicates the subject program file associated with the subject process . The Process Tracking Framework is described separately below.

The authorization rules can be arbitrarily complex and may represent any function or Boolean predicate which effectively takes as input a subject program file of a subject process and optionally one or more further attributes of the subject process the requested action and an object or one or more file object attributes and outputs an authorization decision. We will now present some specific use cases enabled by the program based authorization techniques and authorization policies described herein.

One particular example of using program based action authorization is to implement file read restrictions on a computer. As one example of a read restriction policy a set of authorization rules can be defined to only allow a specified set of files R to be read by authorized subject processes . For example we may only allow a specific program file P to read any file in the set R. Consequently whenever a process is created for the execution of some program the enforcement mode program based authorization mechanism described herein only allows a file in R to be read by that process when the process represents the execution of program P.

As a concrete example if P is a specific word processor such as Microsoft Word and R is defined as files whose names have the extension of .doc or .rtf or .txt then no program other than Microsoft Word is authorized to read such files. In particular this means that file transfer programs and file copy utilities will not be able read such files and are thereby prevented from exfiltrating or duplicating such files unless of course those programs are explicitly authorized to do so by the authorization policy or we are operating in tracking mode .

The authorization rules can be extended or amended to allow useful exceptions. For example the set of programs authorized to read R may be extended to include further word processing programs. As another example the authorization policies may be amended to authorize one or more backup and restore programs whose purpose it is to read files for the purpose of archiving them to read files in R.

Another example of using program based action authorization is to implement file write restrictions on a computer. As one example of a write restriction policy a set of authorization rules can be defined to allow a given program to only write to a specified set of files W. For example we may specify that a specific program P may only write to files in W. Consequently given a process created for the execution of some program the enforcement mode program based authorization mechanism described herein only allows the process to write to files in W when the process represents the execution of the program P.

As a concrete example if P is a specific hypertext markup language HTML browser such as Microsoft Internet Explorer and W is defined as files whose names have the extension of .html or .htm then Microsoft Internet Explorer will be allowed to only write to .html and .htm files. In particular Microsoft Internet Explorer will be blocked from writing any executable files scripts batch files dynamic libraries etc. to disk thereby reducing the risk of browser written malware.

Other examples of grouping objects for the purpose of defining authorization policies are grouping objects by ownership grouping objects that were created in a given time window or grouping objects by their position in an object hierarchy. Corresponding example authorization policies here include allowing only a predefined set of programs to modify files which a are owned by a specified owner b were originally created before a threshold date or c reside in a given directory within the file system.

Other examples of using program based action authorization comprise extending the concepts disclosed in above referenced co pending U.S. patent applications with the program based authorization techniques disclosed herein. In particular U.S. patent application Ser. Nos. 11 346 741 and 11 277 596 describe techniques involving authorization of updates and changes to and execution of objects resident on a computer system such as software and configuration files registry entries executables etc. . The present to program based authorization techniques extend the authorization of updates and changes and executions described in said patents to also take into account one or more attributes of the subject process and by extension of the subject program attempting the action.

The process for execution authorization is similar to that for action authorization except that in some operating systems execution requests may follow a different code path that other file system action requests and therefore the interception of execution requests may differ in implementation from the interception of other file system action requests.

Step consults an execution authorization policy to determine whether the attempted execution is authorized or not. The authorization takes into account the subject program file of the subject process and may optionally also consider any other attributes of the subject process that were determined in step . The authorization policy preferably also takes into account one or more attributes of the executable file object determined in step example attributes were described above . Optionally the authorization policy may disregard some of the supplied information. For example the authorization policy may disregard the attributes of the executable file object and consider only the subject program file of the subject process .

If the execution is authorized step allows the execution to proceed and optional step generates one or more log entries and or alerts indicating that the authorized execution was allowed to proceed. If the execution is not authorized step blocks the action from proceeding and optional step generates one or more log entries and or alerts indicating that an unauthorized execution was blocked. Analogous to the above description steps and are for an enforcement mode embodiment of the present invention. In a tracking mode embodiment step is skipped allowing the unauthorized execution to proceed and recoding logs and or alerts at step .

We now turn to describing the steps of in more detail. One technique for implementing the interception step comprises placing hooks within the process creation and process termination code paths of the OS. Since an execution request submitted to the OS generally includes an indication of the executable file object as an argument e.g. name or handle of a binary file script file batch file interpreted program file byte code file etc. what remains is to determine the subject process and its subject program file and optionally one or more other determined attributes step . Determination of the subject process step can be done as described above for example by starting with a unique identifier for the process context of the currently executing subject process . Determination of subject process attributes step such as the actual program file comprising the code for the subject process can be done by using the Process Tracking Framework.

By way of example and not limitation we now describe an exemplary implementation of the Process Tracking Framework. When the OS boots up hooks are placed in the process creation and process termination code paths. As processes are created one or more data structures are maintained which keep track of associations between processes identified by a unique identifier and programs i.e. executable files such as binaries scripts batch files interpreted code etc. wherein a program associated with a process represents the code that the process started out executing when the process was launched. Conversely as processes terminate their corresponding entries are removed from the Process Tracking Framework data structures in order to keep the structures up to date and properly maintained.

Before turning to example implementations of the Process Tracking Framework we clarify what is meant by the program associated with a subject process in cases where the process is launched to execute non native code such as a script that requires an interpreter program for its execution. In such cases for our purposes of program based authorization we associate the launched process subject process with the script subject program not with the program representing the interpreter of the script. This is true in general for programs that are read in by another program for execution such as scripts interpreted code byte code etc. For example when a PERL script is executed we associate the launched subject process with the script file not with the PERL interpreter program launched to interpret the script even though the interpreter program is actually what the subject process starts out executing. Throughout the present description this is what is meant by the subject program associated with a subject process with the Process Tracking Framework maintaining the appropriate association.

We now turn to an example implementation of the Process Tracking Framework. On a Microsoft Windows OS a request to create a new process may involve calling a user mode process creation function with an indication of the desired executable file as an argument. This function in turn may a call a function in kernel mode to open the executable file and get a file handle for it b call a function in kernel mode to create a new section passing in the file handle and receiving a new section handle and c call a kernel mode process creation function passing in the section handle and a handle for the subject process parent process and receiving back a handle for the new process that is being created child process .

Step b provides a correspondence between the section handle and the file handle and we can obtain the file name from the file handle. Hence we can keep track of the correspondence between section handles and executable file names in the Process Tracking Framework data structures. Step c provides a correspondence between the section handle and the child process handle and we can obtain the child process context from the child process handle. Hence we can also keep track of the correspondence between process contexts and section handles in the Process Tracking Framework data structures. Combining the two correspondences the Process Tracking Framework allows us to obtain executable file names from process contexts. Similar techniques can be used to create and maintain a Process Tracking Framework on other operating systems such as Linux Solaris HP UX AIX other Unix flavored operating systems etc. For example in a Unix derived OS exec and exit calls or variations thereof may be patched for example by patching the appropriate system call tables in order to provide entry points for the creation maintenance and cleanup of the Process Tracking Framework data structures associating processes with one or more attributes as described above.

Optionally the Process Tracking Framework may also fulfill the task of providing one or more attributes for the subject process and or of the executable file object in order to make the abstraction more convenient for the components that use the Process Tracking Framework. But this is an implementation choice and such tasks may just as well be performed by the components themselves or by any other pieces of code.

Optionally should deeper visibility into the execution chain be of interest the history of process creation and termination can be tracked in order to establish and maintain up to date process creation trees. This enables the definition implementation and enforcement of dynamic authorization policies. For example we may define an authorization policy according to which a newly created executable file such as a newly created binary executable file can only be executed by its creator process. This means that when a subject process attempts to execute an executable file object the authorization policy allows the execution only when the subject process is the creator of the executable file object . This concept can be extended to consider the program file of the creator process as the creator of the executable file object instead of limiting the creator concept to the specific instance of the creator process. In this extended case the authorization policy allows a subject process to execute an executable file object whenever the subject program file of the subject process is considered the creator of the executable file object . The benefit is that this manner of authorization survives the termination of the specific creator process in a meaningful and useful way.

In another example of using the concept of a program file P being considered the creator of an executable file object the program file P may be run in learning mode for a period of time. During the learning period we allow the action and execution attempts by P i.e. by any subject processes executing the code in P to proceed without blocking. The intent is to consider such actions and executions as normal activities of P which ought to be considered authorized in the future. At the end of the learning period one or more authorization policies are generated for program P authorizing the actions and executions observed during the learning period. The authorizations may be subsequently tweaked narrowed or broadened in accordance with relevant business or operational concerns. Note that during the learning period P should preferably be configured to run in a manner that excludes unintended or unsafe or unwanted behaviors as much as possible and practical since otherwise the generated authorization policy will authorize such unwanted behavior. For example P should preferably not be allowed to run scripts or macros of unknown authorship or to be operated or accessed by untrusted parties.

The disclosed program based authorization techniques generalize to any other objects and actions which are accessible to running processes. Examples of such other objects include synchronization objects such as semaphores and locks inter process communication IPC objects such as shared memory segments communication objects such as network sockets local communication abstractions such as pipes file access objects such as symbolic links on a Unix flavored OS and shortcuts on a Windows OS running processes etc. Actions applicable to such objects depend on the specific abstractions implementations and semantics of the systems managing the objects with examples including killing suspending unsuspending or sending signals to processes acquiring or releasing locks reading from or writing to shared memory segments opening reading from writing to or closing network sockets or pipes etc. The adaptation of the program based authorization steps disclosed herein to such objects and actions such as interception of action attempts determination of object attributes etc. should be obvious to one of ordinary skill in the art.

Foregoing described embodiments of the invention are provided as illustrations and descriptions. They are not intended to limit the invention to precise form described. In particular it is contemplated that functional implementation of invention described herein may be implemented equivalently in hardware software firmware and or other available functional components or building blocks and that networks may be wired wireless or a combination of wired and wireless. Other variations and embodiments are possible in light of above teachings and it is thus intended that the scope of invention not be limited by this Detailed Description but rather by Claims following.

