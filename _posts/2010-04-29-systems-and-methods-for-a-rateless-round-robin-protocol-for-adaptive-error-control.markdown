---

title: Systems and methods for a rateless round robin protocol for adaptive error control
abstract: Systems and methods implementing a protocol that provides reliable transport over a point-to-point link characterized by deep and sustained fades. Such a communications link may be a free space optical channel or may be a radio frequency point-to-point channel. Data frames are processed through a circular data buffer that operates in a round robin fashion at a transmission node. The coding and forward error correction processes allow for continued operation in spite of possible signal fades due to atmospheric turbulence or other causes. At a receive node, incoming data is also saved in a circular buffer. A re-acknowledgment list is maintained at the receive node for tracking recently received and decoded data. This allows for a new acknowledgment to be sent in the event that a previously sent acknowledgment failed to reach the transmission node.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08671332&OS=08671332&RS=08671332
owner: The Johns Hopkins University
number: 08671332
owner_city: Baltimore
owner_country: US
publication_date: 20100429
---
This application is related to prior filed U.S. Provisional Application No. 61 174 098 filed on Apr. 30 2009 which is incorporated herein by reference in its entirety.

This invention was made with U.S. Government support under the U.S. Air Force under contract number FA8650 04 D2413. The U.S. Government has certain rights in the invention.

The invention described herein relates to communications systems and in particular relates to communications protocols.

Free space optical or radio frequency communications systems may be viewed as networks of high capacity point to point links providing a transport capability that may be comparable to a fiber optic backbone network. Due to the backbone nature of such a network there is a requirement for reliable transport over long distances. Such a communications system must cope with atmospheric turbulence however. Atmospheric phenomena may cause signal fades whose durations are often orders of magnitude greater than a symbol interval. Moreover high signaling rates require protocols that are efficient and are of relatively low complexity.

There is a need therefore for a communications protocol that allows for high capacity reliable transport where the protocol allows for continued operation in spite of atmospheric conditions.

The systems and methods described herein implement a protocol that provides reliable transport over a point to point link characterized by deep and sustained fades. Such a communications link may be a free space optical channel or may be a radio frequency channel. Data frames are processed through a circular data buffer that operates in a round robin fashion at a transmit node. The coding and forward error correction processes allow for continued operation in spite of possible signal fades due to atmospheric turbulence or other causes. At a receive node incoming data is also saved in a circular buffer. A reacknowledgment list is maintained at the receive node for tracking recently received and decoded data. This allows for a new acknowledgment to be sent in the event that a previously sent acknowledgment failed to reach the transmission node.

A preferred embodiment of the present invention is now described with reference to the figures where like reference numbers indicate identical or functionally similar elements. Also in the figures the leftmost digit of each reference number corresponds to the figure in which the reference number is first used. While specific configurations and arrangements are discussed it should be understood that this is done for illustrative purposes only. A person skilled in the relevant art will recognize that other configurations and arrangements can be used without departing from the spirit and scope of the invention. It will be apparent to a person skilled in the relevant art that this invention can also be employed in a variety of other systems and applications.

In an embodiment of the invention the operation of the transmitter comprises three stages that are executed continuously while data remain to be sent 1 Manage flow of data segments into and out of a transmission buffer 2 Select a frame in the transmission buffer for transmission processing and 3 Prepare and transmit a new packet for a selected frame in the circular buffer. Data segments are accepted into the circular buffer whenever it has room to accommodate a new data segment. Data segments are deleted from the circular buffer whenever acknowledgements are received indicating that they have been successfully delivered to the receiving node. Frames are selected from the transmission buffer in a circular or round robin fashion. New packets are prepared by encoding portions of the data segment associated with the selected frame using a combination of incremental redundancy and error control coding techniques. Details regarding these operations are provided in subsequent paragraphs including those discussing and .

In an embodiment of the invention the operation of the receiver comprises the following stages performed in a continuous fashion while data is being received 1 Receive a packet and determine its correctness 2 Update the receiver s circular buffer with data correctly received 3 Decode a corresponding data segment if sufficient data regarding the segment have been collected from the packets received 4 Send an acknowledgement and release buffer space for decoded data segments. The received packet is decoded based on error control coding which determines whether or not the contents are correctly received. If correctly received the packet includes an identifier for the data segment to which the data pertains. The data is aggregated in the receiver s circular buffer in the frame associated with the corresponding data segment. If the aggregated data is sufficient to allow the data segment to be decoded the data segment is decoded and delivered to the end user. An acknowledgement is sent back to the transmit node and the data associated with the decoded data segment are removed from the receiver s circular buffer. Details regarding these operations are provided in subsequent paragraphs including those describing and .

The overall processing of a transmission node is illustrated in according to an embodiment of the invention. At data is stored in a circular data buffer. The data may be organized as frames in the buffer the data stored in a given frame is referred to herein as a data segment. Each frame consists of a data segment S a data segment identifier I S and a seed value dependent on the data segment S . In an embodiment the identifier I S is a sequential counter for segments received from the source with I S 1 for the first segment I S 2 for the second segment and so forth. The identifier may be allocated a fixed number of bytes to represent the counter value. In this case the length of the counter should be sufficient to ensure with high probability that the identifiers associated with distinct segments in the circular buffer are unique that is the counter should not wrap around back to the value 1 until the previous segment labeled 1 has been successfully transmitted to the destination and is therefore no longer being processed by the transmit node.

At one or more packets are encoded according to a process to be described below. The payload of the packet represents at least a portion of the data segment S along with the segment identifier I S and S . In an embodiment of the invention whenever the transmit node sends a packet it first forms a pseudorandom linear combination of the rows of S the coefficients from the finite field GF 2 being determined by the seed S and then produces a labeled encoded vector v L I S S d where the function L denotes the labeling operation. In an embodiment the labeling operation consists of concatenating the bits associated with the identifier I S seed S and linearly combined data d.

In an embodiment the seed S may be the actual seed of a conventional pseudorandom number generator PRNG and would be used and updated in accordance with the PRNG algorithms. In another embodiment the seed S may be the index into a suitable look up table whose rows contain the coefficient vectors to be used in creating the linear combinations from the data segments. In this case the seed is updated by incrementing the index to look at the next row of the coefficients table. The role of the seed value is described in greater detail below. The data segment consists of gN source symbols logically organized as a g N matrix with rows . . . . Each source symbol comprises m bits and represents an element in the finite Galois field GF 2 .

At a hash value h v is calculated as a function of the labeled encoded vector v. In an embodiment of the invention this hash value may be a cyclic redundancy code CRC . In another embodiment of the invention the hash value may be produced by a cryptographic hash function. The hash value is used for error detection purposes and is included with the packet for transmission to the receive node. The receive node will compute its own hash of the packet and compare this computed hash to the received hash. If the two agree the receive node concludes that the packet has been correctly received otherwise the receive node concludes that the packet has been received in error and drops the packet.

At forward error correction FEC is applied to the vector and its hash collectively according to an embodiment to produce the code word c g v h v . The FEC may be based on any channel coding technology known to persons of ordinary skill in the art such as BCH codes Reed Solomon codes convolutional codes Turbo codes low density parity check LDPC codes or combinations and variations thereof. In an embodiment the channel coding may be trivial meaning that the encoder g is the identity mapping. In such an embodiment the vector c v h v is sent uncoded so this processing stage may be omitted. The primary purpose of the FEC is to remove random errors introduced by noise on the channel. In an embodiment of the invention the channel interleaving at is used to randomize the error bursts induced by a fading channel to make the channel coding more effective. Since typical error bursts could easily overwhelm the error correction capability of a channel code if it were contained in a single codeword channel interleaving can be used to attempt to break the error bursts into multiple pieces and spread them across multiple codewords such that each piece will be individually correctable. At according to an embodiment the channel interleaving acts on one or more code words c c . . . cto produce interleaved vectors u u . . . uof the same bits but in possibly different order. Each of the interleaved vectors are processed into packets and transmitted in turn. Let u P c c . . . c denote a particular interleaved output vector for which a packet is to be formed at a given transmit opportunity. Here P denotes the permutation and selection function implemented by interleaver logic for this output vector. In certain embodiments the channel interleaving may be trivial meaning that d 1 and P is the identity function so that u c. In other embodiments non trivial channel interleaving i.e. with d 1 and P not the identity function could be advantageous and would be included as a specific processing step.

At the interleaved vector u is formatted into a packet p f u which is modulated and transmitted to the receive node. In an embodiment the formatting function f includes the addition of any overhead symbols that might be needed by the modem such as for frame synchronization or channel estimation. For convenience of notation the packet will also be denoted p F I S k S d where the function F encompasses the composite action of the hash calculation FEC calculation interleaving and packet formatting. Typically a number of packets will need to be used to transmit the data segment completely and successfully. Each packet will be sent in its own transmission.

At a determination is made as to whether an acknowledgment ACK has been received for a data segment. If so then in the space in the circular buffer that had been used to store the data segment is released in an embodiment of the invention.

If at a determination is made that no acknowledgment has yet been received then a new packet will be prepared for the data segment when it is processed again in the circular buffer. In this case encoding of a new packet at will be performed with an updated seed S and a new pseudorandom coefficient vector determined by the new seed.

The process of storing a frame in the circular data buffer at the transmit node is illustrated in according to an embodiment of the invention. At a new data segment is received for addition to the circular frame buffer. The circular nature of the buffer is maintained by use of indirect addressing since the physical memory associated with the buffer will be utilized in a random fashion. This is due to the intermittent nature of the channel. Since channel outages occur as a random process frames in the circular buffer will be released in arbitrary manner as data segments are successfully delivered and acknowledged. In an embodiment of the invention the circular frame buffer is implemented as a linked list in which pointers are used to implement the indirect addressing. In such an implementation each entry in the list includes a frame plus a pointer to the next entry of the linked list. The nominal beginning of the linked list is indicated by a head pointer. The nominal end of the linked list is indicated by a tail pointer. At an open frame is located in the circular buffer. At the linked list pointers are updated to include the new frame so that the tail pointer now points to the said new frame. At the new data segment is stored in the circular buffer at the frame indicated by the tail pointer.

The addition of a new frame to the circular buffer is illustrated further in according to an embodiment of the invention. The first circular buffer is shown as linked list . In the diagram the memory addresses associated with the start of frames in the circular buffer are shown in the first column as addresses A A A . . . A. As shown in the second column there are four occupied frames F F F Fin the buffer corresponding to data segments S S S S which are not necessarily consecutive. The buffer frame starting at address Ais empty as indicated by the NULL entries. The third column shows the linked list pointers associated with the occupied frames these pointers provide the address of the next frame following the current frame. The annotations head and tail denote respectively the frames at the logical start of the buffer to be processed next and logical end of the buffer after which new frames can be added . The circular nature of the buffer may be understood by following the pointers The first frame is Fat address A the next frame is Fat address A the next frame is Fat address A the next frame is Fat address A the next frame is back to Fat address A and so forth.

If a new frame is added the result is shown as linked list . Since in the linked list there is an empty frame location at address A the new frame Fcan be stored at this location. Note that the tail pointer now points to address A the next frame pointer at Apoints to the head at address A and the next frame pointer at address A the former tail now points to address Ainstead of A. There are different mechanisms that might be used to determine if there are open frames available and to identify a particular open frame to accommodate an incoming data segment. In an embodiment the addresses of open frames are stored in a stack. When frames become available their addresses are pushed on the stack. When an open frame is needed an address of such a frame if available is popped off the stack. In an alternative embodiment the buffer uses flags to indicate for each frame address in the buffer whether it is available or not. These flags are scanned to determine the next available open frame if any. In an embodiment the flags can be special bits in each frame that are set and reset depending on its availability. In another embodiment a certain data segment identifier such as the all zero identifier might be singled out to flag an invalid segment and thus also indicate an available open frame in the buffer.

Note that if there is no new data segment added to the circular buffer because either there is no new data presented or the circular buffer is full then in an embodiment of the invention the pointers in the linked list are rotated to cycle through the frames in the buffer in a circular fashion. Pointer rotation is illustrated in . Here in the linked list the head pointer has changed so that it now points to the frame at address A the successor indicated by the frame at address A the former head . The tail pointer now points to the frame at address A the former head . In an embodiment the frame pointed to by the head pointer is the one processed during the current packet transmission opportunity. Such pointer rotation provides for steady state round robin processing of the circular buffer.

The indirect addressing required to create and maintain the circular buffer may be implemented by other techniques as well. In an alternative embodiment the frames in the buffer may be assigned a key S that serves as a time stamp for each processing of the data segment. The key S is similar to the identifier I S in that it could be implemented as a sequentially updating global counter and should be unique among the data segments in the circular buffer. It is different in that while the identifier is assigned once and does not change for the lifetime of the data segment the key is updated every time a new packet is generated for the data segment. In this embodiment the data segment in the circular buffer with the oldest time stamp is identified and processed whenever a new packet is to be created and transmitted. The oldest time stamp thus serves the same role as the head pointer in the linked list implementation. Similarly assigning the most recent time stamp to a newly arriving packet effectively assigns it to the end of the circular buffer similar to the use of the tail pointer in the linked list implementation.

In another embodiment of the invention the indirect addressing could be accomplished through the use of individual timers assigned to each frame. In an embodiment a countdown timer is set to a maximum value when a new data segment enters the circular buffer. The timers for all frames in the circular buffer count down in a synchronous fashion. When the timer expires i.e. reaches a minimum value the corresponding frame is processed by preparing a new packet for transmission from the corresponding data segment. Once the new packet is transmitted the timer from that frame is reset to the maximum value. Timer expiry therefore serves to identify the proper frame to process in the same way that finding the oldest time stamp does in the previously described alternate embodiment.

The process of encoding a packet for network transmission is shown in greater detail in according to an embodiment of the invention. As discussed above data is processed in blocks of g words each word consisting of N symbols from the finite field GF 2 . The data segment therefore consists of the vectors . . . where each is an N tuple of elements from the finite field GF 2 . At a pseudorandom vector . . . of coefficients from GF 2 is chosen based on the seed S . At a payload vector is created where i 1 . . . g. At a coded packet is formed F I S . Preferably the pseudorandom generation produces a set of g vectors that are linearly independent with a high probability.

In an embodiment of the invention the pseudorandom generation of coefficient vectors is performed in real time by using a PRNG to select elements from the finite field. There are many PRNGs available as would be understood to a person of ordinary skill in the art including PRNGs used in cryptography and in Monte Carlo simulations. PRNGs usually implement a mathematical recursion to determine a pseudo random number from a given input called the seed and to update the seed so that a different pseudo random number will be produced each time the PRNG is executed. Preferably the period of the recursion should be large enough that new coefficient vectors will be selected for each transmission associated with a given data segment. In this embodiment each data segment is assigned an initial seed value when the segment is first accepted into the circular buffer. The initial seed value may be the same for all data segments. After each data segment is processed for transmission of a new packet the seed is updated in accordance with the PRNG algorithm and the new seed is stored with the data segment in the circular buffer for use in the generation of the next coefficient vector for the data segment.

In an alternative embodiment of the invention the coefficient vectors may be generated off line and made available through a suitable lookup table. In this embodiment the seed S is the index used to look up the coefficient vector in the table. As each segment S is accepted into the circular buffer the associated seed S is initialized to the first index in the table and is stored with the data segment in the circular buffer. After each linear combination d is formed from data segment S the corresponding seed S is incremented to the next table location and the new value is stored with the data segment in the circular buffer. The seed wraps around to the first location in the table after the last table location has been used.

At a determination is made as to whether enough packets have been received to reconstitute the data segment. If not then processing returns to for reception of another packet. If enough packets have been received to reconstitute the data segment then processing continues to where the segment is decoded as will be described in greater detail below. At the identifier I S for the data segment is added to a reacknowledgment list whose purpose will be described below. At an acknowledgment is issued to the transmit node. At the decoded data segment is sent to a user and at the buffer space for the data segment is released.

Given that the receive node will release the buffer space used to store the decoded data segment when the acknowledgment is sent a problem arises if the transmit node does not receive the acknowledgment message due to a loss of the return acknowledgment packet. In this case the transmit node will send a new packet for the data segment. Having decoded and acknowledged the original data segment the receive node no longer tracks the status of this segment. As a result the receive node will interpret the newly sent packet as the start of a new session. This would then lead to the complete re transmission of the data segment with duplicate data being delivered to the end user.

To preempt this event in an embodiment of the invention the receive node maintains a list of the identification numbers of data segments recently decoded. This is the reacknowledgment reACK list. Unlike the buffer the reacknowledgement list contains only the identifiers not the data of data segments. Whenever a packet is received with data segment identifier I S the receive node checks to see if its circular buffer already contains data for that data segment. If so the new data from the packet is added to the buffer. If the new data is sufficient to allow decoding of the associated data segment the segment is decoded and an ordinary acknowledgment is sent. If no data for I S is in the buffer however the receive node next checks the reacknowledgment list. If found in the list the identifier is sent for inclusion in the acknowledgement field of the next available outgoing packet from the receive node to the transmit node. If the identifier is found in neither the buffer nor the reacknowledgement list the packet is accepted as the start of transmissions for a new data segment.

Generally the reacknowledgment list need not be complete in an embodiment of the invention. In this list each identifier I S is assigned a persistence value. When a new identifier is added to the reacknowledgement list it is given a maximum persistence value. Every time a packet is received the persistence values in the reacknowledgment list are decremented. An identifier is removed from the list when its persistence value reaches a minimum value. Whenever a packet is received whose identifier is in the reacknowledgment list the corresponding persistence value is incremented. In an embodiment the persistence value in this case is incrementing by restoring it to the maximum value. If the list is full when a new identifier needs to be added the new identifier overwrites the entry with the lowest persistence value. This allows the receive node to remember those data segments that are most likely to be in need of a future reacknowledgment.

If at it is determined that the circular buffer contains no data for this data segment then at a determination is made as to whether the identifier I S is found in the reacknowledgment list. If not then at the packet is treated as the start of transmissions associated with a new data segment A new frame is allocated in the circular buffer and the data for the new data segment is added to that frame. If at the identifier is found in the reacknowledgment list then an acknowledgment for the corresponding data segment is sent at . At the re acknowledgment list entry for I S is assigned a maximum persistence value.

Management of the reacknowledgment list is illustrated in greater detail in . At the persistence value of each previously received identifier I is decremented. At a determination is made as to whether any of the persistence values in the reacknowledgment list has reached a minimum value. If so then at those identifiers are deleted. At a determination is made as to whether a valid packet has been received for I S . If so the maximum persistence value is assigned to I S at . At a determination is made as to whether the reacknowledgment list is full. If not then at the identifier is added to the reacknowledgment list. If the list is full then at the identifier is added to the reacknowledgment list by overwriting the entry in the list having the lowest persistence value.

For the decoding of a data segment the receive node will have received a set of l packets . . . associated with data segment identifier I S . If D denotes the l N matrix whose i th row is and A denotes the l g matrix whose i th row is then D AS. If A has full rank g meaning that the matrix has g rows that are linearly independent over the finite field GF 2 then it contains a g g submatrix that is invertible over the finite field. This property allows the receive node to decode the data segment through the equation S D where is the inverse of and D is the corresponding submatrix of D i.e. the row numbers used to extract D from D are the same as the row numbers used to extract from A . The determination of the rank of the matrix A the identification of its full rank submatrix and the computation of the inverse matrix are performed using well known techniques from linear algebra such as Gaussian elimination over the finite field GF 2 .

This decoding of a data segment in is illustrated in . At the receive node reads each packet F I S . At the data segment S is recovered by calculating S D.

Note that in order to save memory the receive node need only keep track of contributing packets i.e. any packet whose coefficient vector when added to the current version of A increases the rank of this matrix. The receiving node can perform this check as part of the circular buffer updating and thus only store the data in the circular buffer when it has been verified that the data is from a contributing packet.

The processing described above for the transmit and receive nodes may be implemented using digital logic in the form of software firmware or hardware or some combination thereof. A hardware implementation may take the form of one or more field programmable gate arrays FPGAs for example. Alternatively a hardware implementation may take the form of one or more application specific integrated circuits ASICs or other forms of hardware logic as would be understood by a person of ordinary skill in the art.

The term software as used herein refers to a computer program product including a computer readable medium having computer program logic stored therein to cause a computer system to perform one or more features and or combinations of features disclosed herein. A software embodiment is illustrated in the context of a computing system in . System may include a processor and a body of memory that may include one or more computer readable media that may store computer program logic . Memory may be implemented as random access memory RAM read only memory ROM or some combination thereof for example. Processor and memory may be in communication using any of several technologies known to one of ordinary skill in the art such as a bus. Computer program logic is contained in memory and may be read and executed by processor . One or more I O ports and or I O devices shown collectively as I O may also be connected to processor and memory . Computing system may be incorporated in one or both of a transmission node or a receive node.

Computer program logic includes buffer logic . In an embodiment of the invention this function is responsible for managing the circular buffer. It accepts data segments from the source finds appropriate storage for the data segments in the circular buffer assigns the data segment identifiers assigns and updates seed values associated with the data segments determines the data segments to be processed for each transmission opportunity and serves as the interface for the encode decode logic to the data segment s data.

Computer program logic also includes encode decode logic . In an embodiment of the invention this body of logic is responsible for the encoding of packets and decoding of data as described above. While this is shown as a single body of logic in the illustrated embodiment separate encode and decode logic may be used in alternative embodiments.

Computer program logic also includes hash logic . Hash logic is responsible for generating a hash value as described above in the context of a transmit node. In a receive node hash logic is responsible for generating a hash value and comparing that value to the received hash in a given received packet.

Computer program logic also includes forward error correction logic . This logic is responsible for applying the error correction coding process at a transmit node which includes the channel coding and channel interleaving. In a receive node forward error correction logic is responsible for performing the analogous inverse operations channel de interleaving and channel decoding. While this is shown as a single module in the illustrated embodiment the channel encoding decoding and the channel interleaving de interleaving may be implemented as separate modules in alternative embodiments.

Computer program logic also includes acknowledgement logic . In an embodiment of the invention this body of logic is responsible for processing related to acknowledgement messages sent or received as described above. At the receive node for example this body of logic is responsible for the acknowledgment processing illustrated in the embodiment of and for the management of a reacknowledgment list as shown in the embodiment of .

Computer program logic may be implemented using any of a variety of computer programming languages known to persons or ordinary skill in the art. Such languages include for example and without limitation C C or assembly language or some combination thereof.

The structure of the invention in the context of a transmit node is illustrated in according to an embodiment. Buffer manager is responsible for operations associated with maintenance of the circular buffer . Data segments from the source are presented to the buffer manager which allocates storage in the circular buffer and performs various associated bookkeeping functions such as assignment of segment identifiers and initial seed values. The buffer manager also determines the data segment to be processed at each transmission opportunity and provides the data segment data to encoder . The encoding of data segments is performed by encoder . The buffer manager is also in communication with an acknowledgment processing module . An acknowledgment is received by acknowledgment processing module . As discussed above receipt of an acknowledgment by the acknowledgment processing module prompts the buffer manager to delete the corresponding data segment and associated parameters from the circular buffer since that data segment has been successfully delivered to the destination.

The calculation of a hash value on the basis of an encoded packet is performed by hash module . A forward error correction module performs error correction coding and channel interleaving. The remaining transmission infrastructure is shown generically as transmission logic . This latter component may include for example additional protocol processing related to other protocol layers including but not limited to physical layer processing.

At a receive node the invention may be structured as shown in according to an embodiment. A packet is received by logic which may include logic for processing additional protocol layers for example. A forward error correction module is responsible for performing channel de interleaving and channel decoding. A hash verification module is responsible for calculating a hash value for the received packet and comparing this hash value to the received hash. If the two hash values are in agreement the packet is considered to have been correctly received and decoded. Data from the decoded packet is delivered to the buffer manager which determines the frame in circular buffer to which the data belongs based on the decoded data segment identifier. In the event that no frame is currently assigned to that identifier the buffer manager allocates new storage in the circular buffer . The buffer manager then provides the corresponding frame and its data to the data segment decoder . Decoding of a data segment is performed by module according to the logic described above. This includes determination of whether or not there is sufficient data received to reconstitute the data segment. An acknowledgment processing module is responsible for performing acknowledgment processing at the receive node. Successful reconstitution of the data segment by the data segment decoder results in acknowledgment processing module generating an acknowledgment for the corresponding data segment. The acknowledgment processing module also uses and maintains a reacknowledgment list as described above.

Note that in order to achieve reliable transport over a channel that is subject to significant outages it is desirable to continue to transmit the data segments in the buffer until delivery is positively acknowledged and if consistent with system and user requirements to throttle back the flow of data segments from the source to avoid overwriting the circular buffer when the buffer is full. In an embodiment of the invention the flow of source data into the circular buffer at the transmit node is controlled using an external first in first out FIFO memory. The FIFO holds data awaiting release of buffer space in the circular buffer. This allows data segments to be delivered reliably but in a randomized order determined by the channel outages.

At the receive node the end user may however require data segments be presented in their proper order. This can be accomplished by using an external memory to hold data output from the receiver s circular buffer this memory being writable by segment identifier and readable in sequential order.

With respect to the circular data buffers and an embodiment of the invention the circular buffers are sized in accordance with the two way propagation delay of the channel between the transmit and receive nodes. It is generally inefficient for a transmit node to have to reprocess a given data segment before any potential acknowledgment for that data segment can be received. If the timing is poor the transmission node will send the new packet for a data segment that has already been decoded by the receive node. This would be avoided if the transmission node had waited for the acknowledgement to be received. To avoid idling the transmission node ideally transmits packets from enough different frames to fill the air with independent data segments. Thus in an embodiment of the invention the circular buffers consist of M frames where M is substantially equal to or greater than 2D c R N where D is the physical distance between the transmission and receive nodes c is the speed of light and R is the symbol transmission rate. Note that this formula is an approximation given that packet overhead e.g. hash values FEC codes data segment identifiers is not considered for purposes of this calculation.

The systems shown in may be implemented in a communications component such as a modem. As noted above an implementation may take the form of software firmware or hardware or any combination thereof as would be understood by a person of ordinary skill in the art. Moreover alternative arrangements of these modules other than the arrangements shown may be used in other embodiments of the invention.

It is to be appreciated that the Detailed Description section and not the Summary and Abstract sections is intended to be used to interpret the claims. The Summary and Abstract sections may set forth one or more but not all exemplary embodiments of the present invention as contemplated by the inventor s and thus are not intended to limit the present invention and the appended claims in any way.

The present invention has been described above with the aid of functional building blocks illustrating the implementation of specified functions and relationships thereof. The boundaries of these functional building blocks have been arbitrarily defined herein for the convenience of the description. Alternate boundaries can be defined so long as the specified functions and relationships thereof are appropriately performed.

While various embodiments are disclosed herein it should be understood that they have been presented by way of example only and not limitation. It will be apparent to persons skilled in the relevant art that various changes in form and detail may be made therein without departing from the spirit and scope of the methods and systems disclosed herein. Thus the breadth and scope of the claims should not be limited by any of the exemplary embodiments disclosed herein.

