---

title: System for downloading and executing a virtual application
abstract: A virtual process manager for use with a client application. Both the process manager and the client application are installed on a client computing device. In response to a user command to execute a virtual application at least partially implemented by a virtualized application file stored on a remote computing device, the client application sends a high priority command to the process manager to execute the virtual application. Before receiving the user command, the client application sends a low priority command to the process manager to download at least a portion of the virtualized application file. In response to the high priority command, and without additional user input, the process manager downloads any portion of the file not downloaded in response to the low priority command, and executes the virtual application on the client computing device. The client application may comprise a conventional web browser or operating system shell process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08959183&OS=08959183&RS=08959183
owner: Code Systems Corporation
number: 08959183
owner_city: Seattle
owner_country: US
publication_date: 20100212
---
This application is a continuation in part of U.S. application Ser. No. 12 695 107 filed on Jan. 27 2010 and incorporated herein by reference in its entirety.

The present invention is directed generally to a virtual process manager and more particularly to a virtual process manager configured to download a virtualized application file from a remote server and execute the downloaded file.

A virtual application is a virtual machine image pre configured with all of the files registry data settings components runtimes and other dependencies required for a specific application to execute immediately and without installation on a host computing device. The virtual application is partially isolated from other applications implemented on a host computing device and partially isolated from an underlying host operating system installed and executing on the host computing device. The virtual application is encapsulated from the host operating system by a virtual runtime environment which includes a virtual operating system that receives operations performed by the virtualized application and redirects them to one or more virtualized locations e.g. a virtual filesystem virtual registry and the like .

Thus the virtual application may be conceptualized as including two components a virtualization runtime and a virtual application configuration. The virtualization runtime implements the virtual runtime environment which implements various operating system application programming interfaces APIs in such a way that allows the executing virtual application to access and interact with items that may not be present on the host computer. The virtual application configuration includes data necessary to implement the virtual application within the virtualization runtime.

The virtual application is stored in and implemented by one or more data files and or executable files. Depending upon the implementation details the one or more data files and or executable files storing and implementing the virtual application may include blocks of data corresponding to each application file of a natively installed version of the application. Herein these blocks of data will be referred to as virtual application files. The one or more data files and or executable files storing and implementing the virtual application also include configuration information. When the virtual application is executed the configuration information is used to configure the virtual operating system to execute the virtual application. For example the configuration information may contain information related to the virtual application files virtual registry entries environment variables services and the like. The virtual operating system is configured to communicate with the host operating system as required to execute the virtual application on the host computing device.

A download manager is a computer program that downloads files from a web server over the Internet. The download manager is separate from a web browser which is used to navigate to a web page displaying a link to a file stored on the server. When the user clicks on the link to the file the download manager is launched and manages the download.

Conventional download managers require user interaction and an application installation process. For example download managers typically require a user to select a storage location on the user s computer into which the file will be downloaded. Then after the file is downloaded the download manager typically launches the installation process or the user executes the file separately. Alternatively a dialog box may ask the user if the user wants to install an application implemented by the downloaded file and or execute the file. Often when the user indicates the user wants to execute the application an installer is launched that installs the application. The installation process often requires additional user interactions and may be very time consuming require special permissions to perform the installation and perform potentially undesirable modifications to the user s computing device. When the installer is finished the installer may execute the downloaded and installed file. However the user is typically queried a second time as to whether the user would like to execute the file.

Thus prior art download managers require user interaction after a file is selected for download. Therefore using conventional download managers is time consuming and requires substantial user interaction. Further because the user must respond to the questions presented by the download manager the user must monitor at least a portion of the file transfer.

A need exists for a virtual process manager configured to download and execute a virtual application while requiring less user interaction than prior art download managers. A further need exists for a virtual process manager that more quickly executes virtualized application files stored on a remote server particularly in view of the fact that a virtualized application file need not be installed on the user s computer to execute thereon. A method of launching applications stored on a remote server is also desirable. The present application provides these and other advantages as will be apparent from the following detailed description and accompanying figures.

The present application describes a virtual process manager referred to as a Sandbox Manager configured to download a virtualized application file from a server computing device to a client computing device operated by a user. The Sandbox Manager does not query the user for any information during the download or execution of the virtualized application file. The user simply selects the virtualized application file for download using a Client Application such as a web browser or operating system shell and together the Client Application and the Sandbox Manager effect the transfer of the virtualized application file to the client computing device and the execution of the virtualized application file on the client computing device. Thus the user need not select a location in which to store the virtualized application file on the client computing device or indicate whether the user would like to execute the virtualized application file. In this manner the Sandbox Manager may be used to download and execute the virtualized application file in less time than is required using a conventional download manager.

As explained above a virtualized application file is transferred to the client computing device from the server computing device . The virtualized application file is illustrated in dashed lines to indicate that the virtualized application file is stored in the cache during and after the download. However before the download begins the virtualized application file is not stored in the cache . As will be explained below the virtualized application file may be an executable file or a file configured to execute within a virtualized environment provided by a virtual machine.

The system memory A stores one or more files implementing one or more virtual machines. By way of a non limiting example the system memory A may include a plurality of virtual machine executable files that when executed each implement a different virtual machine. For example each of the virtual machine executable files may implement a different version of the same virtual machine. The virtual machine executable files may be executed individually. When executed a virtual machine executable file implements a virtualized environment. Execution of a virtual machine executable file may be initiated by the Sandbox Manager using a command including a parameter e.g. a file path identifying a virtualized application file to execute. In response to receiving the parameter the virtual machine executable file executes the identified virtualized application file inside the virtualized environment implemented by the virtual machine executable file. The virtual machine may execute within an operating system shell process. Optionally the virtual machine executable files may be stored in the cache .

The virtualized application file includes a version identifier that may be used by the Sandbox Manager to select which of the virtual machine executable files is configured to execute the virtualized application file .

In the embodiment illustrated the system memory B stores web server components configured to implement a web server. The web server components may be configured to provide a web page having one or more links to virtualized application files using standard http protocol. By way of non limiting examples the web server components may include Internet Information Services IIS provided by Microsoft Corporation Apache and the like. While illustrated as being outside the filesystem B those of ordinary skill in the art appreciate that the virtualized application file and web server components may be conceptualized as being within the filesystem B.

The virtualized application file may include components necessary to implement a virtual runtime environment including a virtual operating system configured to execute in the operating system A see of the client computing device illustrated in . Alternatively the virtual runtime environment may be implemented by one of the virtual machine executable files see . The virtualized application file includes components necessary to implement a virtual application configured to execute in the virtual runtime environment. In particular embodiments a single virtualized application file is used to implement both the virtual operating system and the virtual application . However those of ordinary skill in the art appreciate that more than one virtualized application file may be used to implement the virtual operating system and the virtual application . For example the components implementing the virtual runtime environment may be stored in one of the virtual machine executable files see and the components implementing the virtual application may be stored in the virtualized application file . Further one or more of the files used to implement the virtual application may be other than an executable file having the exe file extension.

U.S. patent application Ser. No. 12 697 029 filed on Jan. 29 2010 describes a file format that may be used by the virtualized application file and an xlayer file. U.S. patent application Ser. No. 12 697 029 is incorporated by reference herein in its entirety. The virtual application may be implemented using the virtualized application file and or one or more xlayer files as described in U.S. patent application Ser. No. 12 697 029. The xlayer file cannot be executed directly from the operating system A and instead requires the virtual runtime environment supplied at least in part by the virtual operating system . The virtual operating system may be supplied by one of the virtual machine executable files . Thus the xlayer file may be executed by one of the virtual machine executable files .

The virtual operating system includes a virtual filesystem a virtual registry and a virtual process environment and threading subsystems component . When executing the virtual application interacts with the virtual filesystem virtual registry and virtual process environment and threading subsystems component instead of interacting directly with the filesystem A the registry A and the process environment and threading subsystems component A of the operating system A illustrated in . The virtual operating system is configured to communicate with the operating system A illustrated in as required to execute the virtual application .

The virtual application executes inside a virtual runtime environment provided at least in part by the virtual operating system . Some virtual applications require one or more additional runtime environments to execute. For example to execute a Flash application the Flash runtime engine must also be installed. Therefore to virtualize a Flash application both the Flash application and Flash runtime engine must be included in the virtualized application file and configured to execute in the portions of the virtual runtime environment provided by the virtual operating system . Collectively all runtime components necessary to execute the virtual application will be referred to as a virtual runtime engine. However those of ordinary skill in the art appreciate that the virtual runtime engine may include only the virtual operating system and components of other additional runtime engines e.g. the Flash runtime engine required to execute the virtual application may be loaded separately by the virtual operating system . When executed the virtual runtime engine generates at least in part the virtual runtime environment in which the virtual application executes.

The virtualized application file includes a configuration data block . The configuration data block may include virtual application files A C corresponding to each of the application files of a natively installed version of the same application. The virtualized application file identifies one or more of the virtual application files A C as a startup executable that executes when the virtual application is first executed. The startup executable may be identified in the configuration data block .

When the virtualized application file is executed the configuration data block configures the virtual operating system to execute the virtual application . For example the configuration data block may contain configuration information related to files and directories in the virtual filesystem keys and values in the virtual registry environment variables services and the like.

The configuration data block may also include basic application metadata and settings such as the application name application version and sandbox location. Further the configuration data block may provide isolation information to the virtual operating system . This information indicates which directories virtual application files A C virtual registry entries environment variables and services are to be isolated from the operating system A see of the client computing device see . While illustrated as being outside the virtual filesystem those of ordinary skill in the art appreciate that the application files A C may be conceptualized as being within the virtual filesystem when the virtual application is executing.

To execute the virtual application an initialization process is first performed. During this process the virtual operation system is launched and configured by the configuration data block . After the initialization process has completed the appropriate startup executable s is are launched inside the virtual operating system . The virtual operating system intercepts calls to the operating system A and routes them to corresponding components of the virtual operating system . For example when the virtual application requests access an application file that corresponds to the virtual application file A using a path of a natively installed version of the application the virtual operating system intercepts the request and routes the request to one of the virtual application file A. The virtual operating system may also route some requests and actions to the operating system A see of the client computing device see for processing.

U.S. patent application Ser. No. 12 188 155 filed on Aug. 7 2008 U.S. patent application Ser. No. 12 188 161 filed on Aug. 7 2008 and U.S. patent application Ser. No. 12 685 576 filed on Jan. 11 2010 all of which are incorporated herein by reference in their entireties disclose systems that may be used to create and configure the virtualized application file . As described in greater detail in U.S. patent application Ser. Nos. 12 188 155 12 188 161 and 12 685 576 the virtualized application file may be created by a virtual application executable constructor or authoring tool using an application template that includes copies of files such as a configuration file application files A C and the like used to configure the virtualized application file . However the template is not a requirement. Instead to build the virtualized application file the authoring tool needs only the configuration file and copies of any applications files A C necessary for a natively installed version of the application to execute. The applications files A C and the configuration file are referred to collectively as an application configuration . In some embodiments the authoring tool combines the application configuration and the components of the virtual runtime engine e.g. the virtual operating system into an executable virtualized application file. However in other embodiments the authoring tool omits the components of the virtual runtime engine from the virtualized application file to create a virtualized application file for execution by a virtual machine implemented by a virtual machine executable file such as one of the virtual machine executable files .

For ease of illustration the authoring tool and the application configuration have been illustrated as being stored in the system memory B of the server computing device see . However this is not a requirement. As is apparent to those of ordinary skill in the art the virtualized application file may be created on a computing device other than the server computing device such as the computing device illustrated in and transferred to the server computing device illustrated in for storage thereon.

Returning to as mentioned above the system memory A of the client computing device see stores the Client Application and the Sandbox Manager .

The Client Application translates user commands button clicks etc into requests for operations that the Sandbox Manager performs. In embodiments in which the Client Application is implemented as a web browser the browser plug in or other type of translation application may be installed on the client computing device see . Together the browser and browser plug in perform the functions of the Client Application .

By way of a non limiting example the browser plug in may be installed on the client computing device see by placing a dynamic link library dll implementing the plug in in a predetermined installation directory and registering the dll i.e. an assembly in the registry A e.g. a Windows registry of the client computing device see . An Assembly Registration tool e.g. Regasm.exe may be used to register the dll in the registry A.

Once the plug in has been installed the plug in can be used by a website implemented by the web server components see of the server computing device illustrated in via client scripting technologies such as client side javascript code executing in the Client Application . To access the plug in from the server computing device illustrated in a plug in object reference is created and sent to the Client Application . In response to receiving the reference to the plug in the Client Application loads the plug in by mime type ProgID class GUID and the like depending on the implementation details of the Client Application which in this embodiment is implemented as a web browser . The plug in exposes methods which can be used to send requests to the Sandbox Manager .

The requests include commands and optionally one or more parameters. The requests may be implemented as strings each including a command. If the request also includes parameters the parameters may be separated from one another and the command by a predetermined character such as a semi colon comma and the like. In other words the request may be implemented as a semi colon delimitated string or a string delimited in another manner. The following Table A provides a list of commands that my be included in a request.

As mentioned above the Client Application communicates with the Sandbox Manager over the communication link which may be implemented as a TCP connection. By way of a non limiting example the Client Application may send the requests as text messages using TCP protocol to the Sandbox Manager over the TCP connection. As described above each of the requests includes a command and may include one or more parameters e.g. a parameter list . These commands may be characterized as a communication protocol between the Client Application and the Sandbox Manager .

In block the Client Application receives a command from the user via a conventional user interface e.g. a mouse keyboard and the like . The user command instructs the Client Application to download the virtualized application file and or execute the virtualized application file .

The plug in is configured to request a different session for each virtualized application file being transferred and or executed. Thus each virtualized application file being transferred and or executed may be identified by a unique session identifier.

In decision block the plug in determines whether a session identifier is associated with the virtualized application file . The decision in decision block is YES when a session identifier is associated with the virtualized application file . The decision in decision block is NO when a session identifier is not associated with the virtualized application file .

When the decision in decision block is NO in block the plug in requests a new communication session having a unique session identifier with the Sandbox Manager over the communication link . Then the Client Application advances to block .

In block the Client Application translates the user command received in block into a request to be sent to the Sandbox Manager over the communication link . For example in embodiments in which the Client Application is a web browser in which the plug in is loaded in block the web browser receives the user command e.g. the user clicks on a hyperlink presses a button and the like and in block the plug in translates the user command into a request including a command e.g. one of the commands listed in Table A above and optionally one or more parameters e.g. the session identifier associated with the virtualized application file . The user command may be an instruction to download the virtualized application file see an instruction to execute the virtualized application file and the like. As mentioned above the request may be a string including the command and parameters if any.

Returning to in block the Client Application transmits the request to the Sandbox Manager over the communication link e.g. a TCP connection illustrated in . Optionally in block the Client Application may receive information from the Sandbox Manager . The information received may be a response to the command e.g. a response to a ping command a result of performing the command status and or progress information related to performing a command an error message and the like. Then the method terminates.

Returning to the Sandbox Manager receives requests from the Client Application and performs the command included in the requests. The Sandbox Manager manages the transfer of the virtualized application file see from the server computing device to the client computing device illustrated in . The Sandbox Manager also manages execution of the virtual application see on the client computing device see . Turning to the Sandbox Manager includes a communications server e.g. a TCP server one or more predefined Client Request object types a Client Request Manager a Downloader and an Executer .

Returning to as mentioned above in block the plug in requests a different communication session having a unique session identifier for each virtualized application file being transferred and or executed. Referring to in response to each request for a new communication session the communications server establishes a communication session between the Client Application and the Sandbox Manager and generates a unique session identifier for the new communication session. In this manner each virtualized application file being transferred and or executed may be identified by a unique session identifier.

Each of the predefined Client Request object types is associated with a particular type of virtualized application file. For example the Client Request object types include a Client Request object type associated with the virtualized application file . The types are used to create a Client Request object for each virtualized application file to be downloaded and or executed by the Sandbox Manager . An object of the Client Request object type associated with the virtualized application file is responsible for managing transfer and execution of the virtualized application file including determining status managing the cache see stored on the filesystem A etc.

The Client Request Manager determines whether a Client Request object has been created for a particular virtualized application file associated with a session identifier. If a Client Request object has not been created for a virtualized application file the Client Request Manager see identifies which of the predefined Client Request object type is configured to manage details about the virtualized application file creates a Client Request object of the type identified and associates the Client Request object with the session identifier associated with the virtualized application file. By way of a non limiting example a Client Request object may need to be created when the Sandbox Manager receives a start command for the first time to start downloading the virtualized application file . The Client Request Manager may include a dictionary configured to store Client Request objects for use in performing commands included in requests. The dictionary may be stored in the cache see of the filesystem A see .

Each of the Client Request objects includes a status field indicating a status related to the transfer and or execution of the virtualized application file. Table B below provides non limiting examples of status values or codes that may be stored in the status field.

The status field may be set to Canceled when user exits the web page e.g. browses to another page closes the browser window and the like on which the link to the virtualized application file being downloaded is displayed. By way of a non limiting example when the user exits the web page a cancel call may be created automatically e.g. by script code executing in the Client Application and sent to the plug in . In response the plug in sends a cancel message including the session identifier e.g. cancel to the Sandbox Manager over the communication link . If the status value of the status field of the Client Request object including the session identifier in the cancel message is In Progress the transfer is cancelled by the Sandbox Manager .

By way of a non limiting example the status value of the status field may be determine in the following manner. If the transfer of the virtualized application file has not yet started the current status is Not Started. If the transfer has started and is in progress the current status is In Progress. If the transfer has started is not in progress and has completed the current status is Complete. If the transfer has started is not in progress has not completed and has been canceled the current status is Canceled. If the transfer has started is not in progress has not completed has not been canceled and has encountered an error the current status is Error. Table C below provides a non limiting example of error codes that may used by the Sandbox Manager .

Each of the Client Request objects includes a progress field indicating an amount e.g. a percentage from 0 to 100 of the virtualized application file stored in the cache see of the filesystem A see .

Each of the Client Request objects may include a path to the transferred virtualized application file stored on the cache see of the filesystem A see .

The Downloader downloads a particular virtualized application file identified by a session identifier.

Next in decision block the parameters are validated. By way of a non limiting example the parameters may be validated by determining whether the number of parameters matches the number that were expected. The decision in decision block is YES when the parameter are valid e.g. the number of parameters matches the number that were expected . Thus if a particular command does not include parameters e.g. the ping command the decision in decision block is YES if the request does not include any parameters. The decision in decision block is NO when the parameter are invalid e.g. the number of parameters does not match the number that were expected .

When the decision in decision block is NO in block an error message is sent to the Client Application . Then the method terminates.

When the decision in decision block is YES the Sandbox Manager advances to decision block . In decision block the Sandbox Manager determines whether the request includes a session identifier. The decision in decision block is YES when the request includes a session identifier. The decision in decision block is NO when the request does not include a session identifier.

When the decision in decision block is YES in block the session identifier is used to identify or locate a Client Request object associated with the session identifier and responsible for downloading and or executing the virtualized application file identified by the session identifier. The dictionary of the Client Request Manager may be used to lookup the Client Request object associated with the session identifier.

In decision block the Sandbox Manager determines whether a Client Request object associated with the session identifier has been identified. The decision in decision block is YES when a Client Request object associated with the session identifier has been identified. The decision in decision block is NO when a Client Request object associated with the session identifier has not been identified in block .

When the decision in decision block is NO in block the Sandbox Manager sends an error message to the Client Application . The error message may include the error indicator Invalid Session Id see Table C above . Then the method terminates. Thus if a command is sent to the Sandbox Manager with a session identifier that is not in the dictionary an error is returned to the Client Application and a new request must be sent to the Sandbox Manager . For example if a status progress or exec command was received in block including a session identifier not associated with a Client Request object for the Sandbox Manager to perform the command the transfer must be started again with a new request including the start command.

When the decision in decision block is NO the Sandbox Manager advances to decision block to determine whether the Sandbox Manager should create a new Client Request object. Referring to Table A above only two commands listed do not include the session identifier the start command and the ping command. The decision in decision block is YES when the command in the request is the start command. Otherwise the decision in decision block is NO. Thus the decision in decision block is NO when the request includes the ping command.

When the decision in decision block is YES in block the Sandbox Manager creates a new Client Request object and associates the new Client Request object with a session identifier. By way of a non limiting example a method call may be made to the Client Request Manager see to create the new Client Request object. In response to the method call the Client Request Manager identifies the Client Request object type that manages details about the particular virtualized application file being transferred to and or executed on the client computing device see . Then a new Client Request object having the type identified by the Client Request Manager is created.

The Client Request Manager includes a Client Request object for each virtualized application file the Sandbox Manager is transferring and or executing. The Client Request object may be cached in the dictionary of the Client Request Manager which may be configured to provide fast lookup of the Client Request object in response to subsequent requests including the session identifier involving the cached Client Request object. The Client Request object is responsible for managing the transfer of the virtualized application file status of the transfer progress of the transfer execution of the virtualized application file management of the cache see etc. Thus when a transfer is started a unique session identifier is generated a Client Request object is created the Client Request object is associated with the unique session identifier and the Client Request object is stored in the dictionary for future lookups. The status field of the new Client Request object is set to Not Started and the progress field is set to 0 . 

Then the Sandbox Manager advances to block from block . When the decision in decision block is NO the Sandbox Manager also advances to block .

In block Sandbox Manager performs the command. If applicable the command is executed on the Client Request object identified in block or created in block . Then in optional block Sandbox Manager sends information back to the Client Application . For example as discussed below with respect to the method see some commands instruct the Sandbox Manager to perform operations that return values to the Client Application . Then the method terminates.

If the command is a ping command in blocks and the Sandbox Manager sends a response to the Client Application . If the command is a start command in block the Downloader downloads the virtualized application file . If the command is a status command in blocks and the Sandbox Manager obtains the status value from the status field of the Client Request object identified in block or created in block and sends the status value to the Client Application . If the command is a progress command in blocks and the Sandbox Manager obtains the progress value from the progress field of the Client Request object identified in block or created in block and sends the progress value to the Client Application . If the command is a exec command in block the Executer executes the virtualized application file .

In first block the Client Application receives a new user command to download and execute the virtualized application file . In block the Client Application sends a request including the ping command to the Sandbox Manager . The ping command is sent by the Client Application to determine whether the Sandbox Manager is in a state to service commands e.g. available and functioning and capable of responding to requests. If the Sandbox Manager is running and in a state to service commands the Sandbox Manager will send a response to the Client Application .

In decision block the Client Application determines whether it has received a response from the Sandbox Manager to the request sent in block . The decision in the decision block is YES when the Client Application has received a response from the Sandbox Manager indicating that the Sandbox Manager is in a state to service commands and is capable of responding to requests. The decision in the decision block is NO when the Client Application has not received a response from the Sandbox Manager or receives a response indicating the Sandbox Manager is not in a state to service commands e.g. available and functioning or is incapable of responding to requests.

When the decision in the decision block is NO the Client Application returns to block . Alternatively when the decision in the decision block is NO the method may terminate. Optionally the Client Application may display a message to the user indicating the virtualized application file is not available to download.

When the decision in the decision block is YES in block the Client Application establishes a new communication session with the Sandbox Manager and sends a request including a start command to the Sandbox Manager . As mentioned above when the communications server see of the Sandbox Manager initiates a new session the communications server generates a new and unique session identifier. The start command commands the Sandbox Manager to begin transferring the virtualized application file .

In block when the Sandbox Manager receives the start command the Client Request Manager identifies a Client Request object type for the virtualized application file creates a Client Request object of the type identified and associates the session identifier with the new Client Request object. Then the Sandbox Manager determines whether at least a portion of the virtualized application file is stored in the cache see of the filesystem A see . The decision in the decision block is YES when at least a portion of the virtualized application file is stored in the cache see . Otherwise the decision in the decision block is NO. 

When the decision in decision block is YES in decision block the Sandbox Manager determines whether the virtualized application file is stored in its entirety in the cache see of the filesystem A see . The decision in the decision block is YES when the virtualized application file is stored in its entirety in the cache see of the filesystem A see . The decision in the decision block is NO when less than the entire virtualized application file is stored in the cache see .

When the decision in decision block is YES the virtualized application file need not be transferred to the client computing device because the virtualized application file is already stored in the cache see of the filesystem A see . In block the Sandbox Manager updates the status field of the Client Request object to Complete and the progress field to 100 . Then the Sandbox Manager advances to block .

When the decision in decision block or decision block is NO the Sandbox Manager begins transferring the virtualized application file. If the decision block was NO in block the Sandbox Manager adds the virtualized application file to the cache see of the filesystem A see . The Sandbox Manager sets the status field of the Client Request object to Not Started and the progress field to 0 . Then in block the Sandbox Manager begins transferring the virtualized application file from its beginning.

If the decision block was YES but the decision block was NO in block the Sandbox Manager sets the status field of the Client Request object to In Progress calculates the progress value and sets the progress field to the calculated progress value. Then the Sandbox Manager begins transferring the virtualized application file from wherever the previous transfer activities left off. The transfer may be started in a new thread using http protocol. In block the progress field of the Client Request object is updated occasionally e.g. periodically to indicate the percentage of the virtualized application file transferred. Then the Sandbox Manager advances to block .

In block the Sandbox Manager returns the session identifier associated with the virtualized application file to the Client Application .

In block the Client Application sends a request to the Sandbox Manager including the status command. In response to the status command in block the Sandbox Manager sends the status value e.g. in progress or complete of the status field of the Client Request object to the Client Application . In block the Client Application receives the status value sent by the Sandbox Manager . Optionally the Client Application may display the status value of the transfer to the user. In decision block the Client Application determines whether the entire virtualized application file has been downloaded. The decision in decision block is YES if the status field of the Client Request object indicates the entire virtualized application file has been downloaded e.g. the status field has the value Complete . The decision in decision block is NO if the status field of the Client Request object indicates the virtualized application file has not been completely downloaded e.g. status field has the value In Progress .

If the decision in decision block is NO in block the Client Application sends a request to the Sandbox Manager including the progress command to determine the progress value of the transfer of the virtualized application file . In response to the progress command in block the Sandbox Manager sends the progress value in the progress field of the Client Request object e.g. 10 25 etc. to the Client Application . In block the Client Application receives the progress value sent by the Sandbox Manager . Optionally the Client Application may display the progress value to the user. Then the Client Application returns to block .

If the decision in decision block is YES in block the Client Application sends a request to the Sandbox Manager including an exec command. In response to the exec command in block the Executer see of the Sandbox Manager executes the virtual application at least partially implemented by the virtualized application file that the Sandbox Manager has just transferred. Then the method terminates.

As mentioned above the parameters of the exec command includes the session identifier identifying the virtualized application file transferred and optional command line arguments. The session identifier is used to identify the Client Request Object storing the path to the transferred virtualized application file stored on the cache see of the filesystem A see . The path is then used to execute the transferred virtualized application file. The transferred virtualized application file may be executed via an operating system programming interface function call e.g. ShellExecute CreateProcess and the like .

In block if the virtualized application file is configured to be executed inside a virtualized environment provided a virtual machine executable file e.g. the virtualized application file is not an executable file having the .exe extension the Sandbox Manager executes the virtual machine executable file and instructs the executing virtual machine to execute the virtualized application file . The Sandbox Manager may send a command to the operating system A to execute the virtual machine inside an operating system shell process. The command may include the path to the virtualized application file as a parameter that the virtual machine uses to locate and execute the virtualized application file .

If more than one virtual machine executable file e.g. virtual machine executable files are stored in the system memory A the Sandbox Manager identifies which of the virtual machine executable files is configured to execute the virtualized application file . As explained above the virtualized application file may include a version identifier that may be used by the Sandbox Manager to select which of the virtual machine executable files is configured to execute the virtualized application file . Each of the virtual machine executable files may also include a version identifier that may be matched to the version identifier of a particular virtualized application file to determine whether the virtual machine executable file is configured to execute the particular virtualized application file.

By way of a non limiting example blocks and of the method may be implemented in accordance with the following block of pseudo code.

By way of a non limiting example the function named StartDownload used in the above block of pseudo code may be implemented as follows 

By way of a non limiting example the function named FindFullSize used in the first block of pseudo code may be implemented as follows 

Referring to during a pre fetching operation the Sandbox Manager automatically begins transferring one or more virtualized application files e.g. the virtualized application file from the server computing device see before the user has instructed the Client Application to download and or execute the file or files being automatically transferred. Virtualized application files being transferred in this manner are referred to as being pre fetched. A portion of the pre fetching operation may be performed by the Client Application and a portion of the pre fetching operation may be performed by the Sandbox Manager .

Referring to in embodiments in which the server computing device includes the web server components that implement a website and the Client Application is a web browser in which the plug in is installed in block the Client Application connects to the server computing device over the network and downloads a webpage from the website.

In block the Client Application receives information from the server computing device see with respect to one or more virtualized application files e.g. the virtualized application file . The information received in block includes an application identifier e.g. a path to the virtualized application file and a pre fetch indicator for each virtualized application file available for execution by the client computing device . Alternatively the information may include a single pre fetch indicator for all virtualized application files available for execution. The application identifier identifies a particular virtualized application file and the pre fetch indicator indicates whether the pre fetch operation is to be performed with respect to the particular virtualized application file.

As discussed above in embodiments in which the client computing device see receives a webpage from the server computing device see the webpage includes a reference to the plug in . When the Client Application receives the reference to the plug in the Client Application loads the plug in . The webpage also includes the application identifier and the pre fetch indicator for each virtualized application file available on the webpage for execution by the client computing device . Alternatively the webpage may include a single pre fetch indicator for all virtualized application files available for download from the webpage.

In decision block for each virtualized application file available for execution the Client Application determines whether the pre fetch indicator associated with the virtualized application file indicates the pre fetch operation should be performed with respect to the virtualized application file. As explained above in particular embodiments the plug in communicates with the Sandbox Manager . Thus in some embodiments after the webpage loads the plug in determines whether the pre fetch operation has been enabled for the virtualized application file s available for execution on the webpage.

As explained above the plug in is configured to request a different session for each virtualized application file being transferred and or executed. This includes a different session for each virtualized application file being transferred by a pre fetch operation. Thus each virtualized application file being transferred and or executed may be identified by the Client Application and the Sandbox Manager using the unique session identifier. However for ease of illustration sending a request for the creation of a session by the Sandbox Manager and receiving of the session identifier from the Sandbox Manager have been omitted from .

For each virtualized application file for which the pre fetch indicator indicates the pre fetch operation should be performed the decision in decision block is YES and the Client Application sends a request including the start command and two parameters to the Sandbox Manager in block . The first parameter is the application identifier e.g. the session identifier associated with the virtualized application file to be transferred and the second parameter is the priority value for the transfer. In block the priority value indicates the transfer has a low priority.

In block while the virtualized application file is downloading the Client Application may send requests including Status and Progress commands as described above with respect to blocks and respectively of the method illustrated in . In response to these requests the Client Application may receive responses from the Sandbox Manager as described above with respect to blocks and of the method illustrated in . However even if the virtualized application file is fully downloaded the Client Application does not send a request including the exec command to the Sandbox Manager .

Then in block the Client Application waits for a user command to download and or execute a particular virtualized application file e.g. the virtualized application file . By way of an example the user command may be received in any manner described above with respect to block of the method see 

For each virtualized application file for which the pre fetch indicator indicates the pre fetch operation is not to be performed the decision in decision block is NO. When the decision in decision block is NO the Client Application does not send a request to the Sandbox Manager and instead waits for a user command in block . Pre fetching may be disabled for many reasons. For example there may be too many virtualized application files available for download and or execution. Alternatively pre fetching may be disabled when a particular virtualized application file is too large and or too infrequently downloaded and or executed.

In decision block the Client Application determines whether it has received a user command to download and or execute a particular virtualized application file e.g. the virtualized application file . The decision in decision block is YES when the Client Application has received a user command. The decision in decision block is NO if the Client Application does not receive a user command.

When the decision in decision block is YES in block the Client Application sends a request including the start command and two parameters to the Sandbox Manager . The first parameter is the application identifier e.g. the session identifier associated with the virtualized application file to be transferred. The second parameter is the priority value for the transfer. In block the priority value indicates the transfer has a high priority.

In block while the virtualized application file is downloading the Client Application may send requests including Status and Progress commands as described above with respect to blocks and respectively of the method illustrated in . In response to these requests the Sandbox Manager may send responses as described above with respect to blocks and of the method illustrated in .

Then optionally after the virtualized application file is fully downloaded the Client Application may send a request including the exec command to the Sandbox Manager . Then the Client Application advances to decision block .

In decision block the Client Application determines whether it has disconnected from the server computing device see or in embodiments in which the Client Application is a web browser the Client Application determines whether it has navigated to a different webpage. The decision in decision block is YES when the Client Application determines it has disconnected from the server computing device see or navigated to a different webpage. For example in embodiments in which the server computing device includes the web server components that implement a website and the Client Application is a web browser in which the plug in is installed the decision in decision block is YES when the Client Application determines it has exited the webpage e.g. navigated to a different webpage even though the Client Application may remain connected to the server computing device . The decision in decision block is NO when the Client Application determines it has not disconnected from the server computing device or navigated to a different webpage.

When the decision in decision block is YES the method terminates. Alternatively in embodiments in which the Client Application is a web browser and has navigated to a different webpage provided by the server computing device the web server components may provide a different webpage to the Client Application identifying one or more virtualized application files for download. When this occurs the Client Application returns to block to receive information related to those virtualized application files.

When the decision in decision block is NO the Client Application returns to block to wait for a user command.

As explained above the Client Application is configured to send a request to the Sandbox Manager requesting a different session for each virtualized application file being transferred and or executed. This includes a different session for each virtualized application file being transferred by a pre fetch operation. Thus each virtualized application file being transferred and or executed may be identified by the Client Application and the Sandbox Manager using the unique session identifier. However for ease of illustration receiving a request for the creation of a session from the Client Application creating the session and sending the session identifier to the Client Application have been omitted from .

In first block the Sandbox Manager receives a request from the Client Application including the start command the application identifier e.g. the session identifier and the priority value. As explained above a Client Request object is created for each virtualized application file to be downloaded and or executed. For example when the Sandbox Manager receives a start command for the first time to start downloading the virtualized application file a new Client Request object may be created for the virtualized application file . As explained above the Client Request object associated with the virtualized application file is responsible for managing transfer and execution of the virtualized application file including determining status managing the cache see stored on the filesystem A etc.

In decision block the Sandbox Manager determines whether the priority value in the request indicates the transfer has a high priority i.e. the request is for a high priority transfer . The decision in decision block is YES when the request is for a high priority transfer. On the other hand the decision in decision block is NO when the priority value in the request indicates the transfer has a low priority i.e. the request is for a low priority transfer .

When the decision in decision block is NO in block the request is added to a pre fetch stack or similar data structure . Then in decision block the Sandbox Manager determines whether a high priority request is presently being processed. The decision in decision block is YES when a high priority request is presently being processed. On the other hand the decision in decision block is NO when a high priority request is not presently being processed.

When the decision in decision block is YES in block the Sandbox Manager waits to process low priority requests e.g. low priority requests in the pre fetch stack until after the high priority request has finished processing. Then the Sandbox Manager advances to block .

When the decision in decision block is NO the Sandbox Manager advances to block . In block the Sandbox Manager selects a low priority request for processing. In embodiments in which the requests are stored in a pre fetch stack in block the last low priority request added to the pre fetch stack may be popped from the pre fetch stack.

Then in block the Sandbox Manager processes the low priority request selected in block . In block if no portion of the virtualized application file identified by the application identifier has been downloaded the Downloader see downloads at least a portion of the virtualized application file. For example the Downloader may download only a predetermined portion e.g. 5 10 25 30 50 etc. of the virtualized application file. In particular embodiments the portion to be downloaded may be between about 5 and about 20 . By way of a non limiting example the predetermined portion may have a predetermined size e.g. 10 MB 15 MB etc. By way of another non limiting example the portion to be downloaded may be specified by the user e.g. as a configuration setting . Further the Sandbox Manager may determine different portion sizes for different types of virtual applications. In other words one or more properties or characteristics of a virtual application may be used to determine the size of the portion to be downloaded during a pre fetch operation.

In embodiments configured to download only a portion of the virtualized application file after the portion has been downloaded the Downloader see stops downloading the virtualized application file.

If the low priority request is a request to download and or execute a virtualized application file that has already been at least partially downloaded any portion of the virtualized application file that was not downloaded by the pre fetch operation may be downloaded by the Downloader see in block . For example if less than the predetermined portion is downloaded the Downloader may download more of the virtualized application file until the Downloader has downloaded the predetermined portion of the virtualized application file.

If the high priority request is a request to download and or execute a virtualized application file that has already been downloaded by the Downloader see e.g. by a pre fetch operation in block the Downloader see need not download any portion of the virtualized application file. For example if the predetermined portion has been downloaded the Downloader see need not download more of the virtualized application file. In embodiments in which the predetermined portion is one hundred percent the Downloader see need not download more of the virtualized application file when the virtualized application file has been fully downloaded and is stored in the in the cache see of the filesystem A see .

However as mentioned above with respect to the method illustrated in the Client Application see does not send a request including the exec command to the Sandbox Manager after sending a low priority request in block . Therefore in block the Executer see does not execute the virtualized application file after it is partially or fully downloaded.

While downloading the virtualized application file the Client Application may send requests including Status and Progress commands as described above with respect to blocks and respectively of the method illustrated in . In response to these requests in block the Sandbox Manager may send responses as described above with respect to blocks and of the method illustrated in . Further the Sandbox Manager may update the status and progress fields of the Client Request objects as described above with respect to blocks and of the method illustrated in .

Next in decision block the Sandbox Manager determines whether there are any remaining low priority requests to process. In embodiments in which the low priority requests are stored in a pre fetch stack in decision block the Sandbox Manager determines whether there are any low priority requests stored in the pre fetch stack. The decision in decision block is YES when the Sandbox Manager determines there are no low priority requests left to be processed e.g. the pre fetch stack is empty . On the other hand the decision in decision block is NO when the Sandbox Manager determines there are low priority requests left to be processed e.g. the pre fetch stack is not empty .

When the decision in decision block is YES the method terminates. When the decision in decision block is NO the Sandbox Manager returns to decision block .

When the decision in decision block is YES in decision block the Sandbox Manager determines whether it is currently pre fetching one or more virtualized application files. The decision in decision block is YES when the Sandbox Manager is currently pre fetching one or more virtualized application files. Otherwise the decision in decision block is NO. 

When the decision in decision block is NO in block the Sandbox Manager processes the high priority request. In block if no portion of the virtualized application file identified by the application identifier has been downloaded the Downloader see downloads the virtualized application file. Then optionally the Sandbox Manager may receive a request including the exec command from the Client Application sent in block of the method illustrated in . In response in block the Executer see executes the virtualized application file.

If the high priority request is a request to download and or execute a virtualized application file that has already been at least partially pre fetched any portion of the virtualized application file that was not downloaded by the pre fetch operation may be downloaded by the Downloader see as a high priority request in block . Then optionally the Sandbox Manager may receive a request including the exec command from the Client Application sent in block of the method illustrated in . In response in block the Executer see executes the virtualized application file.

If the high priority request is a request to download and or execute a virtualized application file that has already been fully downloaded by the Downloader see e.g. by a pre fetch operation in block the Downloader see need not download any portion of the file. Then optionally the Sandbox Manager may receive a request including the exec command from the Client Application sent in block of the method illustrated in . In response in block the Executer see executes the virtualized application file.

In block the Executer see may execute the virtualized application file in a manner substantially similar to that described above with respect to block of the method illustrated in .

Returning to when the decision in decision block is YES in block the Sandbox Manager pauses any pre fetching operations that the Sandbox Manager is currently performing. Then in block the Sandbox Manager processes the high priority request. In block if none of the virtualized application file identified by the application identifier has been downloaded the Downloader see downloads the virtualized application file. Then optionally the Sandbox Manager may receive a request including the exec command from the Client Application sent in block of the method illustrated in . In response in block the Executer see executes the virtualized application file.

If the high priority request is a request to download and or execute a virtualized application file that has already been at least partially pre fetched the priority value for the low priority request may be updated in block to high priority. Then any portion of the virtualized application file not downloaded by the pre fetch operation may be downloaded by the Downloader see as a high priority request in block . Then optionally the Sandbox Manager may receive a request including the exec command from the Client Application sent in block of the method illustrated in . In response in block the Executer see executes the virtualized application file.

If the high priority request is a request to download and or execute a virtualized application file that has already been fully downloaded by the Downloader see e.g. by a pre fetch operation in block the Downloader see need not download any portion of the file. Then optionally the Sandbox Manager may receive a request including the exec command from the Client Application sent in block of the method illustrated in . In response in block the Executer see executes the virtualized application file.

In block the Executer see may execute the virtualized application file in a manner substantially similar to that described above with respect to block of the method illustrated in .

After the high priority request has been processed in block the Sandbox Manager resumes any pre fetching operations paused in block . Then the Sandbox Manager advances to decision block .

While in the description of method provided above the pre fetch stack has been described as storing requests in alternative embodiments the pre fetch stack may store Client Request objects instead. Further while the requests have been described as being stored in a stack other data structures such as a queue array linked list and the like may be used to store the requests or Client Request objects.

When performing the method the Sandbox Manager treats low priority requests which are automatically initiated the Client Application differently than high priority requests which are initiated by a user command provided to the Client Application . If no high priority requests are being processed by the Sandbox Manager low priority requests are processed. However if during the processing of low priority requests a high priority request is received by the Sandbox Manager processing of the low priority requests is paused.

However during the processing of high and low priority requests the user may decide to execute a virtual application on the webpage. As explained above to do so the user enters a user command e.g. clicks on a hyperlink presses a button etc. into the Client Application . In response the Client Application sends a request including the start command the application identifier and the priority value to the Sandbox Manager . Under these circumstances the priority value will have the high priority value. As explained above when the Sandbox Manager receives the high priority request the Sandbox Manager will pause any pre fetching operations the Sandbox Manager was performing when it received the high priority request.

The pseudo code above includes a function named HandleRequest that receives a request sent by the Client Application and extracts the command. If the command is a start command the HandleRequest function extracts the application identifier sSource and the priority value iPriority from the parameters. Then the HandleRequest function calls a function named StartTransfer configured to receive the application identifier sSource and the priority value iPriority .

The StartTransfer function configured to receive the application identifier sSource and the priority value iPriority pushes the request to the pre fetch stack if the priority value has a low value. If instead the priority value of the request has a high value the StartTransfer function calls a function named StartTransfer configured to receive the application identifier sSource and a download amount IMaxTransfer . The download amount is specified as being the entire virtualized application file e.g. the constant FULL DOWNLOAD indicates the entire virtualized application file is be downloaded .

Then the StartTransfer function configured to receive the application identifier sSource and the priority value iPriority calls a function named PrioritizeTransfers. 

The PrioritizeTransfers function determines the highest priority value of the requests including the start command received by the Sandbox Manager . If the highest priority value is the high value the PrioritizeTransfers function calls a function named PauseLowPriorityTransfers that pauses download operations being performed in response to low priority requests i.e. requests including the start command and having low value priority values . Thus the PrioritizeTransfers function pauses any pre fetch operations being performed. If on the other hand the highest priority value is the low value the PrioritizeTransfers function calls a function named StartLowPriorityTransfers that starts download operations with respect to low priority requests. Thus the PrioritizeTransfers function initiates pre fetch operations.

The StartLowPriorityTransfers function pops a low priority request from pre fetch stack. Then the StartLowPriorityTransfers function calls the StartTransfer function configured to receive the application identifier sSource and the download amount IMaxTransfer . The StartLowPriorityTransfers function passes the popped low priority request as the application identifier and specifies the download amount e.g. the product of 10 1024 1024 .

The StartTransfer function configured to receive the application identifier sSource and the download amount IMaxTransfer downloads the portion of the virtualized application file associated with the application identifier from the server computing device and stores the downloaded portion in the cache see of the filesystem A see . Then the StartTransfer function configured to receive the application identifier sSource and the download amount IMaxTransfer calls the PrioritizeTransfers function.

The methods and may be used with limited bandwidth connections like those that are commonly used from user s homes or businesses to help reduce the amount of time required to download and or execute a virtual application such as the virtual application .

Together the methods and preemptively transfer at least a portion of a particular virtualized application file to reduce an amount of time required to transfer the particular virtualized application file after the user has entered a user command into the Client Application requesting the download and or execution of the particular virtualized application file. Thus the methods and gives the user the impression that the download has taken less time.

Because users typically spend at least some time reviewing a web page before selecting a virtual application to execute e.g. by clicking on a hyperlink the methods and may be used to pre fetch one or more virtualized application files while the user reviews the web page and is not otherwise downloading data over the network see . In other words referring to when the connection between the client computing device and the server computing device is idle or otherwise has capacity the client computing device may pre fetch all or a portion of one or more virtualized application files. Thus the methods and may be characterized as simulating a faster connection without requiring or using additional bandwidth.

For example a user typically spends 30 seconds or more reading information provided on the web page before selecting a virtual application to execute. During this time e.g. 30 seconds or more the Sandbox Manager may be transferring the virtualized application file of the virtual application. Therefore by the time the user instructs the Client Application to execute the virtual application the virtualized application file may already be fully downloaded.

Moreover those skilled in the art will appreciate that implementations may be practiced with other computer system configurations including hand held devices multiprocessor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. Implementations may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

The exemplary hardware and operating environment of includes a general purpose computing device in the form of a computing device . Each of the client computing device and the server computing device may be implemented in accordance with the computing device . By way of non limiting example the Client Application the Sandbox Manager the virtual machine executable files and the transferred virtualized application file may be implemented on a first computing device like the computing device . The web server components and the authoring tool may be implemented on a second computing device like the computing device configured to storing the virtualized application file and generate a web page displaying a link e.g. a hyperlink to the virtualized application file and providing a reference to the plug in .

The computing device includes the system memory . Each of the system memory A see and the system memory B see may be constructed in accordance with the system memory .

The computing device also includes a processing unit and a system bus that operatively couples various system components including the system memory to the processing unit . There may be only one or there may be more than one processing unit such that the processor of computing device comprises a single central processing unit CPU or a plurality of processing units commonly referred to as a parallel processing environment. The computing device may be a conventional computer a distributed computer or any other type of computer.

The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory may also be referred to as simply the memory and includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computing device such as during start up is stored in ROM . The computing device further includes a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM DVD or other optical media.

The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical disk drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of computer readable instructions data structures program modules and other data for the computing device . It should be appreciated by those skilled in the art that any type of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards USB drives digital video disks Bernoulli cartridges random access memories RAMs read only memories ROMs and the like may be used in the exemplary operating environment. As is apparent to those of ordinary skill in the art the hard disk drive and other forms of computer readable media e.g. the removable magnetic disk the removable optical disk flash memory cards USB drives and the like accessible by the processing unit may be considered components of the system memory .

A number of program modules may be stored on the hard disk drive magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computing device through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor computers typically include other peripheral output devices not shown such as speakers and printers.

The computing device may operate in a networked environment using logical connections to one or more remote computers such as remote computer . These logical connections are achieved by a communication device coupled to or a part of the computing device as the local computer . Implementations are not limited to a particular type of communications device. The remote computer may be another computer a server a router a network PC a client a memory storage device a peer device or other common network node and typically includes many or all of the elements described above relative to the computing device . The remote computer may be connected to a memory storage device . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet. The network may include any of the aforementioned networking environments.

When used in a LAN networking environment the computing device is connected to the local area network through a network interface or adapter which is one type of communications device. When used in a WAN networking environment the computing device typically includes a modem a type of communications device or any other type of communications device for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the personal computing device or portions thereof may be stored in the remote computer and or the remote memory storage device . It is appreciated that the network connections shown are exemplary and other means of and communications devices for establishing a communications link between the computers may be used.

The computing device and related components have been presented herein by way of particular example and also by abstraction in order to facilitate a high level view of the concepts disclosed. The actual technical design and implementation may vary based on particular implementation while maintaining the overall nature of the concepts disclosed.

Returning to the operating system A the Client Application the Sandbox Manager the virtual machine executable files and the transferred virtualized application file may be stored as computer executable components on the system memory A. Each of the operating system A the Client Application the Sandbox Manager the virtual machine executable files and the transferred virtualized application file may be implemented using software components that are executable by the processing unit and when executed perform the functions described above.

Returning to the virtualized application file the web server components and the authoring tool may be stored as computer executable components on the system memory B. Each of the virtualized application file the web server components and the authoring tool may be implemented using software components that are executable by the processing unit and when executed perform the functions described above.

Returning to the method implemented by the Client Application may be stored as computer executable components on the system memory A. Returning to the method implemented by the Sandbox Manager may be stored as computer executable components on the system memory A. Each of the methods and may be implemented using software components that are executable by the processing unit .

The foregoing described embodiments depict different components contained within or connected with different other components. It is to be understood that such depicted architectures are merely exemplary and that in fact many other architectures can be implemented which achieve the same functionality. In a conceptual sense any arrangement of components to achieve the same functionality is effectively associated such that the desired functionality is achieved. Hence any two components herein combined to achieve a particular functionality can be seen as associated with each other such that the desired functionality is achieved irrespective of architectures or intermedial components. Likewise any two components so associated can also be viewed as being operably connected or operably coupled to each other to achieve the desired functionality.

While particular embodiments of the present invention have been shown and described it will be obvious to those skilled in the art that based upon the teachings herein changes and modifications may be made without departing from this invention and its broader aspects and therefore the appended claims are to encompass within their scope all such changes and modifications as are within the true spirit and scope of this invention. Furthermore it is to be understood that the invention is solely defined by the appended claims. It will be understood by those within the art that in general terms used herein and especially in the appended claims e.g. bodies of the appended claims are generally intended as open terms e.g. the term including should be interpreted as including but not limited to the term having should be interpreted as having at least the term includes should be interpreted as includes but is not limited to etc. . It will be further understood by those within the art that if a specific number of an introduced claim recitation is intended such an intent will be explicitly recited in the claim and in the absence of such recitation no such intent is present. For example as an aid to understanding the following appended claims may contain usage of the introductory phrases at least one and one or more to introduce claim recitations. However the use of such phrases should not be construed to imply that the introduction of a claim recitation by the indefinite articles a or an limits any particular claim containing such introduced claim recitation to inventions containing only one such recitation even when the same claim includes the introductory phrases one or more or at least one and indefinite articles such as a or an e.g. a and or an should typically be interpreted to mean at least one or one or more the same holds true for the use of definite articles used to introduce claim recitations. In addition even if a specific number of an introduced claim recitation is explicitly recited those skilled in the art will recognize that such recitation should typically be interpreted to mean at least the recited number e.g. the bare recitation of two recitations without other modifiers typically means at least two recitations or two or more recitations .

