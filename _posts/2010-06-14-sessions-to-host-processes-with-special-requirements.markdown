---

title: Sessions to host processes with special requirements
abstract: Techniques are disclosed for enabling a system service executing in an isolated session to access system resources (such as a graphics processing unit) that it is isolated from. In an embodiment, the system service creates a “worker” session that is not isolated, and a “worker” process inside that worker session. Then, the system service is able to access the system resource that it is directly isolated from accessing by passing a request to the worker process to access the system resource on the system service's behalf. The worker process does so, and passes a result to the system service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08539020&OS=08539020&RS=08539020
owner: Microsoft Corporation
number: 08539020
owner_city: Redmond
owner_country: US
publication_date: 20100614
---
Computers interact with a wide variety of other computers through Local Area Networks LANs Wide Area Networks WANs dial up connections and the like. With the wide spread growth of the Internet connectivity between computers has become more important and has opened up many new applications and technologies. The growth of large scale networks and the wide spread availability of low cost personal computers has fundamentally changed the way that many people work interact communicate and play.

An increasingly important form of networking may generally be referred to as remote presentation which can use protocols such as Remote Desktop Protocol RDP Independent Computing Architecture ICA and others similar protocols to share a desktop and other applications with a remote client. Such computing systems typically transmit the keyboard presses and mouse clicks or selections from the client to a server and relay the screen updates back in the other direction over a network connection e.g. the Internet . As such the user experience is a local computing environment with centralized server control over the processing and applications.

Some systems that serve remote presentation sessions do so through the use of one or more services such as a process that runs regardless of whether a user session is active . Such a service may receive image data from a client or user session on the system that is serving a remote presentation session to a client encode it and transmit it to the client via a remote presentation session protocol.

Difficulties arise where this remote presentation session service executes in a session each user logged into the operating system is given a separate session or memory and execution space in which to execute his processes that does not have access to system resources that the service needs to effectuate its purpose. Some operating systems like MICROSOFT WINDOWS 7 separate the services of the operating system into their own session in the MICROSOFT WINDOWS 7 operating system this session is known as session 0 and herein such a session that contains services separated into its own session will be referred to as such . Session 0 is frequently isolated and is subject to security constraints for instance session 0 may not be able to access a graphics processing unit GPU of the computer on which it executes. Lack of access to a GPU prevents a service from leveraging the power of the GPU to perform complex graphics operations like compression and rendering.

Furthermore there may be a problem with using a standard user session to enable session 0 to utilize the GPU. For instance a standard user session is an interactive session where the user may be logged off and if that user initiates log off all processes in that session will terminate including any processes used to enable session 0 to utilize the GPU. Furthermore even if these processes used to enable session 0 to utilize the GPU are recreated when they terminate there is still the issue of time lost to this recreation process which negatively impacts user experience.

Thus this isolation of session 0 poses a problem for services that attempt to utilize the GPU such as a remote presentation session service that attempts to utilize the GPU to compress an image rapidly or while minimizing CPU resources consumed in performing this compression.

A remote presentation session server that serves remote presentation sessions in virtual machines VMs enables a service executing in an isolated session 0 to access a GPU of the computer upon which the service executes. Consequently a client logs into a VM of the server for a remote presentation session and to serve that session a broker service creates a process responsible for rendering graphics in the VM host partition that instantiates a graphics stack for the VM and any other VM that hosts a remote presentation session . The broker service hosts the process in a session that persists until the server shuts down or restarts to keep the process running and provide uninterrupted service to the client. This session is referred to as the worker session. 

Preferably a special purpose session that is independent of a user session insomuch as the user account for the special purpose session is managed by the service that invokes it and does not belong to an actual user of the system is created. The worker session hosts processes that have access to a computer s video card and GPU. A service executing in session 0 may then create a process in the worker session this process is herein referred to as a worker process . The service will communicate a command to be executed by the GPU to the worker process which will have the GPU perform the command and then return the result to the service.

According to an aspect of the invention a remote desktop virtualization server hosts a plurality of virtual machines VMs that client computers can connect to and conduct remote presentation sessions with. Each client connected to the server has a corresponding remote presentation session process that executes within the client s session space. These remote presentation session processes make calls to a remote presentation session service executing in session 0 to perform tasks such as encode and transmit an image of the desktop of the client session associated with the remote presentation session process. The remote presentation session service creates a worker session and a worker process within that worker session. That worker process has access to the GPU of the server. When the remote presentation session service has received an indication from a remote presentation session process to perform a task that involves use of the GPU the remote presentation session service requests that the worker process contact the GPU to perform the GPU operations. The worker process does so receives from the GPU a result of the GPU processing those GPU operations and passes that result back to the remote presentation session. The remote presentation session then uses that result to transmit to the client remote presentation session data.

It can be appreciated by one of skill in the art that one or more various aspects of the disclosure may include but are not limited to circuitry and or programming for effecting the herein referenced aspects of the present disclosure the circuitry and or programming can be virtually any combination of hardware software and or firmware configured to effect the herein referenced aspects depending upon the design choices of the system designer.

The foregoing is a summary and thus contains by necessity simplifications generalizations and omissions of detail. Those skilled in the art will appreciate that the summary is illustrative only and is not intended to be in any way limiting.

The term circuitry used throughout the disclosure can include hardware components such as hardware interrupt controllers hard drives network adaptors graphics processors hardware based video audio codecs and the firmware used to operate such hardware. The term circuitry can also include microprocessors application specific integrated circuits and or one or more logical processors e.g. one or more cores of a multi core general processing unit configured by firmware and or software. Logical processor s can be configured by instructions embodying logic operable to perform function s that are loaded from memory e.g. RAM herein referred to as system memory ROM firmware and or mass storage. In an example embodiment where circuitry includes a combination of hardware and software an implementer may write source code embodying logic that is subsequently compiled into machine readable code that can be executed by a logical processor. Since one skilled in the art can appreciate that the state of the art has evolved to a point where there is little difference between hardware implemented functions or software implemented functions the selection of hardware versus software to effectuate herein described functions is merely a design choice. Put another way since one of skill in the art can appreciate that a software process can be transformed into an equivalent hardware structure and a hardware structure can itself be transformed into an equivalent software process the selection of a hardware implementation versus a software implementation is left to an implementer.

Referring now to an exemplary computing system is depicted. Computer system can include a logical processor e.g. an execution core. While one logical processor is illustrated in other embodiments computer system may have multiple logical processors e.g. multiple execution cores per processor substrate and or multiple processor substrates that could each have multiple execution cores. As shown by the figure various computer readable storage media can be interconnected by one or more system busses which couples various system components to the logical processor . The system buses may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. In example embodiments the computer readable storage media can include for example random access memory RAM storage device e.g. electromechanical hard drive solid state hard drive etc. firmware e.g. FLASH RAM or ROM and removable storage devices such as for example CD ROMs floppy disks DVDs FLASH drives external storage devices etc. It should be appreciated by those skilled in the art that other types of computer readable storage media can be used such as magnetic cassettes flash memory cards digital video disks and Bernoulli cartridges.

The computer readable storage media can provide non volatile and volatile storage of processor executable instructions data structures program modules and other data for the computer such executable instructions that effectuate manager described in the following figures. A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computer system such as during start up can be stored in firmware . A number of programs may be stored on firmware storage device RAM and or removable storage devices and executed by logical processor including an operating system and or application programs.

Commands and information may be received by computer through input devices which can include but are not limited to a keyboard and pointing device. Other input devices may include a microphone joystick game pad scanner or the like. These and other input devices are often connected to the logical processor through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or universal serial bus USB . A display or other type of display device can also be connected to the system bus via an interface such as a video adapter which can be part of or connected to a graphics processing unit GPU having access to video memory. In addition to the display computers typically include other peripheral output devices not shown such as speakers and printers. The exemplary system of can also include a host adapter Small Computer System Interface SCSI bus and an external storage device connected to the SCSI bus.

Computer system may operate in a networked environment using logical connections to one or more remote computers such as a remote computer. The remote computer may be another computer a server a router a network PC a peer device or other common network node and typically can include many or all of the elements described above relative to computer system .

When used in a LAN or WAN networking environment computer system can be connected to the LAN or WAN through a network interface card NIC . The NIC which may be internal or external can be connected to the system bus. In a networked environment program modules depicted relative to the computer system or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections described here are exemplary and other means of establishing a communications link between the computers may be used. Moreover while it is envisioned that numerous embodiments of the present disclosure are particularly well suited for computerized systems nothing in this document is intended to limit the disclosure to such embodiments.

Referring now to it generally illustrates an example environment wherein aspects of the present disclosure can be implemented. One skilled in the art can appreciate that the example elements depicted by are illustrated to provide an operational framework for describing the present disclosure. Accordingly in some embodiments the physical layout of each environment may be different depending on different implementation schemes. Thus the example operational framework is to be treated as illustrative only and in no way limit the scope of the claims. One skilled in the art can also appreciate that the following discussion is introductory and the elements depicted by are described in more detail within the discussion of the operational procedures depicted by .

Generally depicts a high level overview of a server environment that can be configured to include aspects of the present disclosure. In reference to the figure depicted is a server that can include circuitry configured to effectuate a remote presentation session server or in other embodiments the server can include circuitry configured to support remote desktop connections. In the depicted example the server can be configured to generate one or more sessions for connecting clients such as sessions 1 through N where N is an integer greater than 2 . Briefly a session in example embodiments of the present disclosure can generally include an operational environment that is effectuated by a plurality of subsystems e.g. software code that are configured to interact with a kernel of server . For example a session can include a process that instantiates a user interface such as a desktop window the subsystems that track mouse movement within the window the subsystems that translate a mouse click on an icon into commands that effectuate an instance of a program etc. A session can be generated by the server on a user by user basis by the server when for example the server receives a connection request over a network connection from a client . Generally a connection request can first be handled by the transport logic that can for example be effectuated by circuitry of the server . The transport logic can in some embodiments include a network adaptor firmware and software that can be configured to receive connection messages and forward them to the engine . As illustrated by the transport logic can in some embodiments include protocol stack instances for each session. Generally each protocol stack instance can be configured to route user interface output to a client and route user input received from the client to the session core associated with its session.

Continuing with the general description of the engine in some example embodiments of the present disclosure can be configured to process requests for sessions determine the functionality for each session generate sessions by allocating a set of physical resources for the session and instantiating a protocol stack instance for the session. In some embodiments the engine can be effectuated by specialized circuitry components that can implement some of the above mentioned operational procedures. For example the circuitry in some example embodiments can include memory and a processor that is configured to execute code that effectuates the engine . As depicted by in some instances the engine can receive connection requests and determine that for example a license is available and a session can be generated for the request. In the situation where the server is a remote computer that includes remote desktop capabilities the engine can be configured to generate a session in response to a connection request without checking for a license. As illustrated by a session manager can be configured to receive a message from an engine and in response to the message the session manager can add a session identifier to a table assign memory to the session identifier and generate system environment variables and instances of subsystem processes in memory assigned to the session identifier.

As illustrated by the session manager can instantiate environment subsystems such as a runtime subsystem that can include a kernel mode part such as the session core . For example the environment subsystems in an embodiment are configured to expose some subset of services to application programs and provide an access point to the kernel of the operating system . In example embodiments the runtime subsystem can control the execution of processes and threads and the session core can send requests to the executive of the kernel to allocate memory for the threads and schedule time for them to be executed. In an embodiment the session core can include a graphics display interface GDI a security subsystem and an input subsystem . The input subsystem can in these embodiments be configured to receive user input from a client via the protocol stack instance associated with the session and transmit the input to the session core for the appropriate session. The user input can in some embodiments include signals indicative of absolute and or relative mouse movement commands mouse coordinates mouse clicks keyboard signals joystick movement signals etc. User input for example a mouse double click on an icon can be received by the session core and the input subsystem can be configured to determine that an icon is located at the coordinates associated with the double click. The input subsystem can then be configured to send a notification to the runtime subsystem that can execute a process for the application associated with the icon.

In addition to receiving input from a client draw commands can be received from applications and or a desktop and be processed by the GDI . The GDI in general can include a process that can generate graphical object draw commands. The GDI in this example embodiment can be configured to pass its output to the remote display subsystem where the commands are formatted for the display driver that is attached to the session. In certain example embodiments one or more physical displays can be attached to the server e.g. in a remote desktop situation. In these example embodiments the remote display subsystem can be configured to mirror the draw commands that are rendered by the display driver s of the remote computer system and transmit the mirrored information to the client via a stack instance associated with the session. In another example embodiment where the server is a remote presentation session server the remote display subsystem can be configured to include virtual display driver s that may not be associated with displays physically attacked to the server e.g. the server could be running headless. The remote display subsystem in this embodiment can be configured to receive draw commands for one or more virtual displays and transmit them to the client via a stack instance associated with the session. In an embodiment of the present disclosure the remote display subsystem can be configured to determine the display resolution for each display driver e.g. determine the display resolution of the virtual display driver s associated with virtual displays or the display resolution of the display drivers associated with physical displays and route the packets to the client via the associated protocol stack instance.

In some example embodiments the session manager can additionally instantiate an instance of a logon process associated with the session identifier of the session that can be configured to handle logon and logoff for the session. In these example embodiments drawing commands indicative of the graphical user interface associated with the logon process can be transmitted to the client where a user of the client can input an account identifier e.g. a username password combination a smart card identifier and or biometric information into a logon screen. The information can be transmitted to server and routed to the engine and the security subsystem of the session core . For example in certain example embodiments the engine can be configured to determine whether the user account is associated with a license and the security subsystem can be configured to generate a security token for the session.

The primary embodiment described in is of a MICROSOFT WINDOWS operating system architecture. It may be appreciated there are many versions of the MICROSOFT WINDOWS operating system and not all versions contain all the characteristics described herein. However the use of a MICROSOFT WINDOWS operating system as the primary embodiment discussed has the advantage aiding in clarity by making reference to components and a system architecture that many are generally familiar with. It may be appreciated that the techniques described herein may be applied in operating systems that have user sessions and where services execute in an isolated session.

Thus a service in session may access a system resource that it is otherwise isolated from by communicating with a worker process in worker session worker session not being isolated in that it can access system resources that session cannot access . The worker process then accesses the system resource on behalf of the service and communicates the result of accessing the system resource back to the service .

Worker session may be created upon the system booting up when service is started. Worker session may be disconnected shortly after user logon is complete. In normal operation once worker session is disconnected it may remain disconnected until system shutdown is initiated unless its shell or a system process running in that session e.g. in WINDOWS 7 this is referred to as Client Server Runtime Subsystem csrss.exe or winlogon.exe terminates abnormally or is terminated accidentally such as through the use of administrator tools. If service which creates the worker session stops or terminates abnormally worker session and processes in that session keep running. As a consequence when service is restarted after termination or intentional stop service is informed that a worker session already exists such as by providing service with an identifier of worker session if service attempts to create a worker session.

Worker session is created in response to a remote connection request for a dedicated local user account. Unlike typical user accounts the user account for the worker session does not represent a user. Rather it is an account that is created and used by a worker session provider such as worker session provider of to log a user on to the worker session automatically. Worker session may be non interactive while it exists.

Worker session may contain general system processes e.g. WINDOWS s csrss.exe winlogon.exe and logonui.exe and may contain some other processes that are started by logon scripts. The shell running in this session may be explorer.exe similar to the regular remote desktops. Apart from these processes worker session may processes created by service after the session is up and running and disconnected . The termination or abnormal behavior of processes created by service need not affect the functionality or state of the worker session in any way.

According to an aspect of the invention or Preferably only the worker user account and system have permissions to operate on worker session . Consequently worker session does not show up in the list of sessions displayed by administrator tools. Worker session is not reported in a call to an API application programming interface that enumerates sessions on the system unless the process making the API call is running at system level. In an embodiment worker session can not be reconnected to shadowed or logged off unless the process attempting to do so is running at a system level. However worker session and the user account name may be visible when processes are enumerated.

In an embodiment worker session is always running Terminating worker session will cause the termination of any processes executing within the session such as a worker process. In turn termination of a worker process will likely negatively affect a user s experience. The user s experience will likely be negatively affected because the user s processes cannot utilize services that use the worker process while the worker process is terminated.

To enable worker session to be always running worker session may be a non interactive session so that it is not accidentally logged off. Furthermore the permissions of worker session may be set to prevent an administrator account from using administrative tools to query and logoff worker session

In some operating systems there is a limit to the number of simultaneous active remote sessions that run on a computer for administrative mode. In some versions of the MICROSOFT WINDOWS operating system this limit is two. However there may be multiple disconnected sessions in addition to these two active sessions. By disconnecting the worker session worker session does not consume one of these two active sessions allowing two other active sessions on the computer.

To enable this disconnected worker session an entity that creates the worker session such as worker session provider of may launch a remote presentation session connection to the local host a loopback connection while running in session . Since the connection is launched in session which is not an interactive session and since the user logging on to the worker session is not a real user the remote presentation session connection launch may be performed silently without any user interaction.

If there are already two administrators active when the worker session is created and there is a limit of two active administrators worker session may run into session contention a disconnect request . Session contention will result in a warning in the temporary worker session that other users are logged on and gives it a option to send a disconnect request. However the warning requires user intervention to resolve this contention and since there is no real user to attend to this message the connection will finally terminate without success.

The worker session is active for a very brief amount of time before it is disconnected. However if another administrator connects remotely while worker user logon is in progress a period of time measured in seconds the administrator may be warmed that there are other users logged on one of these users being the worker user which may be confusing to the administrator.

The creation of worker session may be relatively transparent so administrators should not get confused to see a strange user name in the session contention dialog. In order to avoid session contention scenario and facilitate smooth remote logon without interfering with session arbitration the worker session provider such as worker session provider of may 1 disconnect existing remote connections in order to create a free administrator session that it can use for worker session logon and 2 prevent new remote connections until the worker session creation is complete.

There are other ways to avoid session arbitration. For instance the session arbitration interference and hence the impact on existing connections may be avoided if worker session is created using a separate license pool. This separate license pool may be implemented by introducing a new license type for worker session and keeping the session limit to 1 such that this separate license pool may be used for the loopback connection and the other license pool may be used for the non loopback connections .

However this approach may provide an administrator an ability to create a separate listener himself and have an active regular desktop session in addition to two active sessions supported. This ability of the administrator to create a separate listener may be avoided by having Remote Connection Manager RCM monitoring the state of this session to ensure that it remains disconnected.

Worker session comprises a display driver such as a framebuffer display driver like tsddd.dll. This display driver is registered. Worker session may be associated with a worker display driver. Local session manager may pass this information to a Client Server Run Time Subsystem CSRSS in some MICROSOFT WINDOWS operating systems this comprises the user mode portion of the Win32 subsystem and is responsible for console windows creating and or deleting threads and implementing some portions of the 16 bit virtual MS DOS environment so that win32k loads a worker display driver in worker session . The worker session may always remain active. It may be reported as remote session to other components. However the worker terminal may not have a stack of drivers associated with it.

To overcome this inability to access GPU the following occurs. Process communicates with service to perform a function for process the function involving access of a system resource . Service cannot access GPU directly so service communicates with worker process so that worker process will perform at least the portion of the function that requires GPU access on behalf of service . Worker process communicates with GPU to perform that portion of the function that requires GPU . Upon receiving the result from GPU such as where an image is compressed by GPU that compressed image worker process communicates the result to service which communicates it to process

In this described remote presentation session scenario process may then take this result of a compressed image and send it to the user client via the remote presentation session connection.

The following operations may be performed by worker session provider in creating a worker session and worker process 1 Check a local security authority LSA store to see if the SID for the worker user account exists. If the account does not exist create a local user account with a known name one that other components will be aware of before creation of the account 2 Create a random password and set it for the worker user account. This may be done regardless of whether user account existed before or not. Enable the worker user account if it was disabled before and 3 Look up the user account to get the SID and save it in LSA store if the user account is newly created. Return the SID to the caller.

In addition on every request for creating worker session the worker session provider such as worker session provider of may reset the password for the worker user account. The password may be reset to a new value such as by performing the following 1 Create a Crypto provider to generate a random number. This password creation can be effected through the WINDOWS API CryptAcquireContext 2 Use five character arrays one array contains all numerical digits second array contains all special characters e.g. etc third array contains all uppercase characters fourth array contains all lower case characters and fifth array includes all the above characters. These character arrays are used to ensure that the password contains all the special characters to satisfy the password policy. 3 Generate random numbers. The API CryptGetRandom is used for this purpose. Use these random numbers to shuffle the fifth character array and then in loop to fill up the password for a given size using fifth array and 4 Shuffle the rest of the four arrays using more random numbers and shuffle the position numbers character indices within the password and set those values using the rest of the four arrays.

Worker user credentials may be cached. This function uses credential manager to cache worker user credentials. Caching user credentials is one of the steps required to facilitate silent logon without user intervention. This function may be invoked by a coordinator thread when it is ready to launch remote connection. This function uses CredWrite API to cache the credentials. It saves the credentials as generic credentials CRED TYPE GENERIC and they persist only in current session CRED PERSIST SESSION . That means these saved credentials can not be read by any component application running outside of session . The cached credentials are deleted as soon as the worker session creation is complete.

The worker session may be created for a remote connection request. The worker session should remain in a disconnected state so as not to consume a limited active administrator space on the computer . A disconnected session that was created in response to user logon at a physical console as a disconnected display driver TSDDD associated with it. In an embodiment the worker process needs to use DIRECTX graphics APIs and some versions of TSDDD do not support DIRECTX APIs so attempting to use such APIs will fail n this case. If the session is however created for a remote connection request when connected it has RDPDD Remote Display Protocol Device Driver associated with it which allows the worker process to use DIRECTX APIs.

If such a session already exists local session manager provides to system service an identifier session ID for the session. If such a session does not exist local session manager creates worker session . In doing so local session manager may also reset the worker user account s password to a random string of characters to make it difficult for a party to log on to this session which is designed to not be logged on to and enables the worker user account.

Where TermService is not already started TermService is started. This may be done where some RPC APIs are implemented in RCM to facilitate user logon.

Local session manager then binds TermService to a local session manager RPC remote procedure call endpoint and calls its RPC API to create worker session with an encrypted password. After worker session is created its password is reset the worker user account is disabled so it cannot be used to logon to worker session TermService s state is restored and an identifier of worker session is sent to system service .

Having the identifier of worker session system service may now create a worker process within worker session . System service may then use worker process to gain access to a system resource that system service does not directly have access to.

Local session manager may tell other system components that the worker terminal is remote when it is not remote. This is because if the terminal is not remote other system components e.g. LogonUI will not ask RDS components for user credentials and the session will eventually go away.

Although the worker session provider component is shown in a separate box in the above diagram for convenience it may be statically linked in service . The coordinator component is a main thread that binds the functions of all the various components in the worker session provider.

Worker user account manager creates and manages a dedicated worker user account for logon to worker session . Worker user account manager performs functions including 1 finding out if the worker user account is created or not. If it is not created worker user account manager creates a user account. If an account has already been created worker user account manager enables that user account 2 resetting worker user account s password on each create worker session request 3 allowing the worker user access to the special listener and administrator connections. Worker user account manager removes this access after the worker session creation is completed 4 caching worker user credentials using credential manager for remote desktop to local host without user intervention. Removing them when the worker session creation is completed 4 Denying local logon to the worker user account and 5 hiding the worker user account so that it does not show up in the control panel.

The worker session needs to disconnect existing remote users and prevent new remote connections while the worker session creation is in progress. This is required to prevent worker session from running into session arbitration.

Special listener manager creates a dedicated listener with special permissions in order to initiate a remote connection for the worker session . Special listener manager performs functions including 1 creating a separate listener with a distinct port number for worker connection 2 assigning a security descriptor to the listener so that only the worker user account has logon permissions and the system has full permissions and 3 deleting the listener after worker session creation is complete.

The special listener manager creates and manages a special listener which can be used by worker session provider to request a remote connection and create a session with special permissions.

The operation to create a listener manager is invoked by the coordinator thread. This function takes the user SID associated with the worker user as input and returns port number if succeeded. It uses the input SID to tight the access permissions for the listener. The port number returned by this method is used by the coordinator thread later to invoke remote connection to correct port.

Remote presentation connection manager configures settings and generates resources to ensure the silent and non interactive launch of the remote connection for creating worker session . Remote presentation connection manager performs functions including 1 writing configuration settings in order to facilitate the silent remote connections 2 creating a process on a remote presentation client such as mstsc.exe on the disconnected desktop of session and 3 waiting for the shell to start in the worker session and then terminating the remote presentation client process.

In initiating a remote presentation connection first a process is created on a remote presentation client.

For creating a worker session the worker session provider may initiate remote connection. It does so by creating remote desktop client process such as CreateProcess on mstsc.exe . This process runs in system context on the disconnected desktop of session . The worker session provider creates a .RDP file that contains the information required to make the connection and passes that file name as input parameter to the process.

To know whether the connection succeeded or not the worker session provider may register for session notifications from the local server and wait for a period of time e.g. one minute for successful shell start for the worker session . If the shell start notification is not received it assumes that the remote connection failed and it returns error to the caller.

After receiving a shell start notification or timeout worker session provider may terminate the remote desktop client process which results in disconnection of the worker session

If remote desktop server role is installed on the host partition where worker session needs to be created remote connections consume remote desktop CALs device or user licenses except for the administrative connections. It may not be desirable to consume CAL for the worker session so the worker session provider may use an administrative flag such as admin for making a remote connection to local host.

Remote presentation service state manager manages the state of the remote presentation service in order to ensure smooth and silent completion of remote presentation connection for worker session without interfering with the session arbitration and existing sessions. Remote presentation service state manager performs functions including 1 stopping the remote presentation session service to disconnect existing remote users and disabling existing listeners to prevent new connections for avoiding worker session creation from running into session arbitration handling 2 saving states of the remote presentation service connection handlers and listeners before creating worker session and restoring states after worker session creation is complete and 3 synchronizing the service with the other entities that may also start the remote presentation service since the service and remote presentation service may start at almost the same time during boot.

Worker session provider may verify that the worker session is not running prior to creating one. Also after the worker session is created it may verify that the user logon is complete before disconnecting the worker session . Session notification handler waits for dedicated user logon to complete on the worker session after the worker session is completed. It also helps in ensuring that there are no other remote connection requests in progress when the remote connection for worker session is initiated. It also helps with enumerating existing sessions and finding out whether the worker session already exists.

The following functions may occur to prepare for a silent remote presentation connection. First worker user credentials may be stored to a credential manager such as WINDOWS Vault for automatic logon.

For creating a worker session the worker session provider creates or enables the dedicated user account for the remote connection and resets its password. Then it uses credential manager to store the worker user credentials in the vault for termsrv localhost resource. This enables worker session provider to automatically logon the dedicated user account when a loopback connection remote connection to localhost is initiated. This step suppresses the dialog asking for user credentials.

Second the server authentication warning may be suppressed. When the remote connection is initiated it attempts to verify the server identity and displays warning if the identity can not be verified. Since worker session provider is attempting a loopback connection it does not need to worry about verifying the identity and it needs to suppress this warning without user intervention. For that purpose while preparing the RDP file it writes authentication level i 0 to indicate the remote desktop client not to warn about verification error.

The worker session provider may use a separate listener to initiate a remote connection in order to create a worker session for the following reasons 1 prevent accidental logoff this may be done by having a special security descriptor on a listener 2 suppress warning other users are logged on during shutdown this may be done by specifying a separate terminal type and session source for all the connections received on the listener and 3 over ride logoff on disconnect policy this may be done by specifying a separate terminal type for all connections received on the listener .

With regard to 1 preventing accidental logoff the worker session is a non interactive session. And it may need to stay until server shutdown if it is to deliver uninterrupted experience to the end user. In order to achieve that the logoff of the session or any such operation on the session through administrative means may be prevented.

Each session has a security descriptor indicating which users have permissions to perform what operations e.g. to query information list the session in the enumerated list disconnect logoff send message etc on that session. Whenever the LSM is requested to perform an operation on any session through RPC call it impersonates the caller and checks against session s security descriptor if the caller has permission to perform that operation.

The session with the remote connection inherits the security descriptor from the listener where the connection was initiated. So if the worker session was created for a remote connection received on the default listener administrators can see that session in the admininstator tools and may intentionally or accidentally logoff that session. In order to prevent logoff or any such operation on worker session the remote connection should be requested on a listener which has a special security descriptor that allows only the worker user and the local system to perform operations on the resulting session. The worker session provider creates this listener with a special security descriptor prior to requesting the worker session connection. Worker session provider may delete the listener after worker session is created.

With regard to 2 suppressing a warning other users are logged on during shutdown when the administrator initiates the shutdown if there are other users logged on those users may receive a warning message stating that other users are logged on. With worker session running and worker user logged on to it an administrator will see this warning. However if administrator uses administrator tools there will not be any sessions reported and this will result in confusion about why the warning message is shown.

The reason for the discrepancy in the user session not being reported to the administrator tool but being reported during shutdown is because of the check on permissions on a specific session. When an administrator uses administrator tools the permission on the session may not allow a query so the worker session is not reported. However the warning message during shutdown is shown by the user32.d11 component which actually asks remote desktop about total number of users logged on to the session. This query does not include query permission on a particular session. So worker session is counted towards other user sessions currently logged on.

With regard to 3 overriding the logoff on disconnect policy if an administrator has set the group policy for session timeout limit this will impact the life time of worker session . For example if the policy says logoff session if disconnected for x minutes the worker session will be logged off after x minutes. Although this logoff is initiated by RCM running at network service privilege this logoff may not be initiated through a RPC call where permissions checks are made. However it invokes logoff method of session object directly which will successfully logoff the worker session

A special terminal type helps with these issues. The Remote Connection Manager RCM has an infrastructure to define the type of the remote terminal. The examples of the terminal types are regular desktop Remote App MCE etc. The RCM has a limited ability to over ride session specific policies on the sessions with different terminals. For example the initial program policy is over ridden for remote app terminal type. The worker session provider could choose a special terminal type for the worker session for which the session timeouts are not applied. However this requires changes in the RCM.

Each terminal type can define a source of the session a value that indicates who initiated the remote connection. The two known values for the source are user e.g. for regular desktop terminals and device e.g. for MCE terminals . The worker session provider can use a special value here e.g. source service because the remote connection is actually initiated by a service. When the machine is shutdown the user32 component queries about the number of regular desktop and devices sessions and either of them is non zero it reports the warning. If the worker session source is neither of them then it will get rid of the warning.

Worker session may have a special terminal type in order to solve the issues with the warning message during shutdown and the session time limit policy over rides. In order to use the special terminal type when the worker connection is made RCM may need to know that this connection is requested for worker session . This special terminal type may be effected for instance by having RCM treat all the connections received on the special listener as a special terminal type based on listener registration. A new registry value e.g. TerminalType is added to listener registration that tells RCM to assign that terminal type to all the connections received on that listener.

The RCM may have a limited support for over riding the policies for a different terminal type than regular desktop but it may not be adequate to over ride some of the policies for the worker session . A way to over ride the policies for worker terminal type is to have hard coded checks for the terminal type and not apply the policies.

First worker session provider enumerates sessions from local session manager and checks if a worker session already exists . Then worker session provider registers for session notifications from local session manager. Worker session provider creates and enables a worker user account and adds the worker user account credentials to a vault . Worker session provider saves remote presentation service state and other settings . Worker session provider disables existing listeners . Worker session provider creates worker listener and starts remote presentation service if required . Worker session provider creates a process mstsc.exe which launches a loopback connection with remote connection manager which creates a session with local session manager. Worker session provider waists for worker session logon and eventually local session manager informs worker session provider that logon is complete and a shell was started . Worker session provider terminates the process . Worker session provider unregisters session notifications from local session manager. Worker session provider restores remote presentation service state and other settings . Worker session provider performs cleanup operations including deleting the listener cleaning up the value and deleting the user account. The service ends upon computer shutdown and logoff such as winlogon logoff .

Here two processes process of session 1 and process of session 2 access a service service to make a call to GPUs. Worker process is instantiated to provide access to a GPU to service to do work on behalf of process and worker process is instantiated to provide access to a GPU to service to do work on behalf of process

Similar as to described in process communicates with service to perform a function for process the function involving access of a system resource . Service cannot access GPU directly so service communicates with worker process so that worker process will perform at least the portion of the function that requires GPU access on behalf of service . Worker process communicates with GPU to perform that portion of the function that requires GPU . Upon receiving the result from GPU such as where an image is compressed by GPU that compressed image worker process communicates the result to service which communicates it to process

Likewise process communicates with service to perform a function for process the function involving access of a system resource . Service cannot access GPU directly so service communicates with worker process so that worker process will perform at least the portion of the function that requires GPU access on behalf of service . Worker process communicates with GPU to perform that portion of the function that requires GPU . Upon receiving the result from GPU such as where an image is compressed by GPU that compressed image worker process communicates the result to service which communicates it to process

It may be appreciated that in an embodiment the image encoding on behalf of both processes and could be performed on a single GPU or that there are various ways to distribute the loads using an arbitrary number of processes executing in user sessions that attempt to encode images using service and an arbitrary number of GPUs. For instance a static load balancing algorithm may be used where a new process is assigned to the GPU with the least number of such processes using that GPU. Where all GPUs have the same number of processes the new process may be assigned to the GPU with the lowest VRAM usage. Where all GPUs have the same amount of VRAM usage the process may be assigned to the first GPU in an enumeration of the GPUs.

Service may allocate processes among GPUs by determining characteristics of the GPUs such as their number and their respective available load. Service may determine the identity of GPU and by instantiating a process enumeration process within worker session . Enumeration process may be configured to communicate with GPU and to determine the number of GPUs available as well as other pertinent information such as their respective load or VRAM usage. Enumeration process may return such information to service upon being queried for it and service may use this information to determine which GPU a process in a user session such as processes and will be associated with such that that GPU does work on that process behalf .

In an embodiment this system depicted by may comprise a remote presentation session server that hosts multiple remote presentation sessions and uses the system s GPUs to perform some steps of hosting those remote presentation sessions. For instance process and process may be instances of a remote presentation session process that respectively conduct a remote presentation session with a separate client. In the course of conducting those remote presentation sessions process and process may attempt to compress an image or frame to send to a client and use service to do so. Service may attempt to leverage the use of the GPUs of the system to perform this compression. Further to balance the load of this compression service may communicate with two processes worker processes and which in turn are able to communicate with separate GPUs GPUs and respectively.

While the present disclosure has been described in connection with the preferred aspects as illustrated in the various figures it is understood that other similar aspects may be used or modifications and additions may be made to the described aspects for performing the same function of the present disclosure without deviating therefrom. Therefore the present disclosure should not be limited to any single aspect but rather construed in breadth and scope in accordance with the appended claims. For example the various procedures described herein may be implemented with hardware or software or a combination of both. Thus the methods and apparatus of the disclosed embodiments or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium. When the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus configured for practicing the disclosed embodiments. In addition to the specific implementations explicitly set forth herein other aspects and implementations will be apparent to those skilled in the art from consideration of the specification disclosed herein. It is intended that the specification and illustrated implementations be considered as examples only.

