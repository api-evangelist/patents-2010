---

title: Method and system for storing binary large objects (BLObs) in a distributed key-value storage system
abstract: A technique for storing binary large objects (BLObs) in a distributed key-value storage system is disclosed. In an embodiment, the storage of BLObs involves dividing the BLObs into smaller “BLOb chunks” and storing the BLOb chunks in storage nodes of the distributed key-value storage system. A BLOb is first associated with a key, referred to as a “BLOb key,” and each subsequent BLOb chunk is associated with a different unique key, referred to as a “BLOb chunk key.” A list of the BLOb chunks keys is maintained and all of the BLOb chunks of the BLOb can be retrieved from the distributed key-value storage system using the BLOb chunks key list.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09002907&OS=09002907&RS=09002907
owner: Unwired Planet, LLC
number: 09002907
owner_city: Reno
owner_country: US
publication_date: 20101224
---
This application is entitled to the benefit of provisional U.S. Patent Application Ser. No. 61 378 370 filed Aug. 30 2010 which is incorporated by reference herein.

Distributed key value storage systems are database management systems that have recently been developed to handle the storage of massive amounts of data. These distributed key value storage systems use commodity hardware and are easily and massively scalable.

Some types of digital data consist of large objects that need to be stored in a database management system as a single entity. For example digital media such as images music and videos are typically managed as single entities in a database management system. These entities are often referred to as binary large objects or BLObs or BLOBs or Blobs . Distributed key value storage systems are increasingly being used to store digital media such as BLObs. With the growing use of distributed key value storage systems to store large amounts of digital media there is a need to adapt distributed key value storage systems to efficiently manage BLOb storage.

In accordance with an embodiment of the invention the storage of BLObs in a distributed key value storage system involves dividing the BLObs into smaller BLOb chunks and storing the BLOb chunks in storage nodes of the distributed key value storage system. In order to ensure that a BLOb can be managed as a single entity even though the BLOb is divided into BLOb chunks a BLOb is first associated with a key referred to as a BLOb key and each subsequent BLOb chunk is associated with a different unique key referred to as a BLOb chunk key. A list of the BLOb chunk keys is maintained so that the BLOb can continue to be managed as a single entity. In particular a BLOb chunks key list is maintained within the first BLOb chunk so that all of the BLOb chunks of the BLOb can be easily retrieved from the distributed key value storage system.

An embodiment a method for storing BLObs in a distributed key value storage system is disclosed. The method involves receiving a stream of a BLOb associating a key with the BLOb dividing the BLOb into BLOb chunks as the stream of the BLOb is received wherein a BLOb chunk comprises a subset of the BLOb associating a unique BLOb chunk key with each BLOb chunk storing the BLOb chunks in the distributed key value storage system according to the BLOb chunk keys and maintaining a BLOb chunks key list that includes the BLOb chunk keys of the BLOb chunks.

In an embodiment the distributed key value storage system comprises multiple storage nodes and the BLOb chunk keys are used to determine the storage node at which a BLOb chunk is stored. For example the BLOb chunk key of a particular BLOb chunk is hashed to determine the storage node at which the particular BLOb chunk is stored.

In an embodiment the BLOb is retrieved from the distributed key value storage system using the BLOb chunks key list.

In an embodiment a non transitory storage media that stores computer executable instructions is disclosed. When the instructions are executed by a computer the instructions implement a method for storing BLObs that involves receiving a stream of a BLOb associating a key with the BLOb dividing the BLOb into BLOb chunks as the stream of the BLOb is received wherein a BLOb chunk comprises a subset of the BLOb associating a unique BLOb chunk key with each BLOb chunk storing the BLOb chunks in the distributed key value storage system according to the BLOb chunk keys and maintaining a BLOb chunks key list that includes the BLOb chunk keys of the BLOb chunks.

In an embodiment a method for retrieving BLObs from a distributed key value storage system is disclosed. The method involves obtaining a BLOb key indexing a table according to the BLOb key to find a value obtaining a BLOb chunks key list from the value wherein the BLOb chunks key list contains BLOb chunks keys that are related to BLOb chunks of the BLOb using the BLOb chunk keys to index the table and streaming BLOb chunks of the BLOb according to the BLOb chunk keys.

Other aspects and advantages of embodiments of the present invention will become apparent from the following detailed description taken in conjunction with the accompanying drawings illustrated by way of example of the principles of the invention.

It will be readily understood that the components of the embodiments as generally described herein and illustrated in the appended figures could be arranged and designed in a wide variety of different configurations. Thus the following more detailed description of various embodiments as represented in the figures is not intended to limit the scope of the present disclosure but is merely representative of various embodiments. While the various aspects of the embodiments are presented in drawings the drawings are not necessarily drawn to scale unless specifically indicated.

The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is therefore indicated by the appended claims rather than by this detailed description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

Reference throughout this specification to features advantages or similar language does not imply that all of the features and advantages that may be realized with the present invention should be or are in any single embodiment. Rather language referring to the features and advantages is understood to mean that a specific feature advantage or characteristic described in connection with an embodiment is included in at least one embodiment. Thus discussions of the features and advantages and similar language throughout this specification may but do not necessarily refer to the same embodiment.

Furthermore the described features advantages and characteristics of the invention may be combined in any suitable manner in one or more embodiments. One skilled in the relevant art will recognize in light of the description herein that the invention can be practiced without one or more of the specific features or advantages of a particular embodiment. In other instances additional features and advantages may be recognized in certain embodiments that may not be present in all embodiments of the invention.

Reference throughout this specification to one embodiment an embodiment or similar language means that a particular feature structure or characteristic described in connection with the indicated embodiment is included in at least one embodiment. Thus the phrases in one embodiment in an embodiment and similar language throughout this specification may but do not necessarily all refer to the same embodiment.

In the embodiment of the client is an entity that is a source of a BLOb. For example the client may include a mobile device a desktop computer a laptop computer a server a workstation or a digital camera video or still . The client may be embodied as software that runs on a hardware device such as a mobile device a desktop computer a laptop computer a server a workstation or a digital camera video or still . For example the client may be embodied as an application such as a Web Browser that enables interaction with the service engine. Although only one client is shown in multiple clients may have access to the service engine. Additionally access to the service engine may be for example wired wireless or a combination of wired and wireless.

The storage nodes are storage systems that provide storage for digital data. In an embodiment the storage nodes are individual machines such as storage servers that communicate with the service engine via data networking protocols such as Ethernet and or the Internet Protocol IP . All of the storage nodes that provide storage for the service engine are considered to be in the same cluster of storage nodes even though the storage nodes may be located remote from the service engine and remote from each other. Each storage node in the cluster operates independently of the other storage nodes in the cluster. The independence of the storage nodes ensures that the distributed key value storage system is not dependent on any one storage node and allows additional storage nodes to be easily added to the cluster. Although four storage nodes are depicted in the cluster of storage nodes may include more than four storage nodes. In particular the cluster of storage nodes may include a number of storage nodes greater than two.

The service engine provides a service to the client for example an email service a video streaming service or a social networking service. In the embodiment of the service engine includes an application and a data store client . The application may be for example an email application a video streaming application or a social networking application. The application provides an interface to the client that allows the client to upload digital media from the client to the application and or download digital media from the application to the client . For example the client can upload and download BLObs such as digital images and digital video.

The data store client implements a distributed key value storage system to manage the storage of data in and the retrieval of data from the cluster of storage nodes . In an embodiment BLObs are streamed between the application the data store client and the storage nodes. That is BLObs and BLOb chunks are streamed in the sense that the data is processed at the application and the data store client without ever having to store an entire BLOb or BLOb chunk at one time. For example BLOb data is received at an input side of the data store client and sent from an output side of the data store client without ever simultaneously storing an entire BLOb or BLOb chunk.

In an embodiment the application and the data store client communicate data between each other using an application programming interface API that uses defined stream calls. In a BLOb storage operation the API provides an input stream object and the application writes data buffers to the stream. The application does not need to declare the total length of the stream e.g. the BLOb stream to the data store client ahead of time rather the length of the stream e.g. the BLOb stream is discovered only when the application closes the input stream. In a BLOb retrieval operation the API provides an output stream object from which the application reads until an end of the file call is returned.

In an embodiment the distributed key value storage system uses a data model that includes a table which is a distributed multi dimensional map indexed by a key. The key is a binary string with no size restriction and the value is a binary object that is highly structured. Keys can map to multiple values which are grouped into column families. The column families are typically fixed when the distributed key value storage system is configured however columns can be added to a family at any time. Additionally columns can be added only to specified keys and different keys can have different numbers of columns in any given family.

In an embodiment a row key in a table is a string with no size restrictions although typically the row keys are 16 32 bytes long. Every operation under a single row key is atomic per replica no matter how many columns are being read from or written into. In an embodiment the top dimension in the table is called the keyspace and the distributed key value storage system exposes two kinds of column families simple column families and super column families. In an embodiment the distributed key value storage system can handle tables with four or five dimensions. A table with four dimensions is defined as follows 

In an embodiment the first dimension of the table Keyspace Column Family or Keyspace Super Column Family is limited to a small set of schema predefined keys. Applications can specify the sort order of columns within a Column Family or a Super Column Family. Columns can be sorted by either time or name.

In an embodiment the distributed key value storage system that is implemented by the data store client distributes data across the cluster of storage nodes using consistent hashing. For example the output range of a hash function is treated as a fixed circular space or ring and each storage node in the cluster is assigned a random value within this space to represent the storage node s position in the ring. Each data entity that is identified by a key is assigned to a storage node by hashing the key associated with the data entity. The result of the hashing determines a position on the ring and a storage node is selected by traversing the ring e.g. clockwise to find the first node with a position larger than the data entity s position. A more detailed description of distributed key value storage systems is found in the following papers Avinash Lakshman and Prashant Malik 2009 Giuseppe DeCandia Deniz Hastorun Madan Jampani Gunavardhan Kakulapati Avinash Lakshman Alex Pilchin Swaminathan Sivasubramanian Peter Vosshall and Werner Vogels SOSP 07 Oct. 14 17 2008 and Fay Chang Jeffrey Dean Sanjay Ghemawat Wilson C. Hsieh Deporah A. Wallach Mike Burrows Tushar Chandra Andrew Fikes and Robert E. Gruber Operating Systems Design and Implementation OSDI 2006 all of which are incorporated by reference herein.

In accordance with an embodiment of the invention BLObs that are uploaded from the client to the service engine are divided into smaller BLOb chunks which are stored in the cluster of storage nodes using a distributed key value storage system. In order to ensure that a BLOb can be managed as a single entity even though the BLOb is divided into BLOb chunks a BLOb is first associated with a row key referred to as a BLOb key and each subsequent BLOb chunk is associated with a unique row key referred to as a BLOb chunk key. A list of the BLOb chunk keys is maintained so that the BLOb can continue to be managed as a single entity. In particular a BLOb chunks key list is maintained within the first BLOb chunk so that all of the BLOb chunks of the BLOb can be easily retrieved from the distributed key value storage system.

In an embodiment the descriptor headers include metadata for the corresponding BLOb or BLOb chunk. For example the metadata may include the length of the BLOb or BLOb chunk the owner of the BLOb or BLOb chunk and the creation time of the BLOb or BLOb chunk. The BLOb chunks key list includes an ordered list of all of the BLOb chunks that make up the BLOb.

As illustrated in the BLObs rows are indexed by a BLOb key and the Chunks rows are indexed by a BLOb chunk key . In an embodiment the BLOb key includes a name and an arbitrary value and the Blob chunk keys include the corresponding BLOb key and another unique value such as an ordinal suffix. In an embodiment the keys are generated by the data store client.

As a BLOb is streamed from the application to the data store client the amount of data that has been streamed is tracked. Once the amount of streamed data reaches a pre established size limit the BLOb chunk is closed and the BLOb chunk is stored in the distributed key value storage system according to the corresponding BLOb key. For example the BLOb key is hashed to determine the location within the cluster at which the BLOb chunk is to be stored.

Immediately upon the closing of the initial BLOb chunk a new BLOb chunk is created and the BLOb stream fills the new BLOb chunk from the point at which the initial BLOb chunk was closed. All of the BLOb chunks that are created after the initial BLOb chunk are indexed at the Chunks row level. In an embodiment the subsequent BLOb chunks are associated with BLOb chunk keys that include the initial BLOb chunk key and an ordinal suffix. For example the next BLOb chunk BLObChunk is associated with the BLOb chunk key MyBLObKey 0001 . illustrates the next BLOb chunk and its associated BLOb chunk key . Once the BLOb chunk reaches its pre established size limit the BLOb chunk is closed and the BLOb chunk is stored in the distributed key value storage system according to the BLOb key. For example the BLOb chunk key is hashed to determine the storage node at which the BLOb chunk will be stored. Additionally the BLOb chunk key is added to the BLOb chunks key list as illustrated in the expanded view of the BLOb chunks key list. In an embodiment an updated BLOb chunks key list is sent to the storage node that stores the initial BLOb chunk and the BLOb chunks key list is replaced with or updated according to the updated BLOb chunks key list.

Immediately upon the closing of BLObChunk a new BLOb chunk is created and the BLOb stream fills the new BLOb chunk from the point at which BLObChunk was closed. The next BLOb chunk BLObChunk is associated with the BLOb chunk key MyBLObKey 0002 . illustrates the next BLOb chunk and its associated BLOb chunk key. Once the BLOb chunk reaches its pre established size limit the BLOb chunk is closed and the BLOb chunk is stored in the distributed key value storage system according to the BLOb key . For example the BLOb chunk key is hashed to determine the storage node at which the BLOb chunk will be stored. Additionally the BLOb chunk key is added to the BLOb chunks key list as illustrated in the expanded view of the BLOb chunks key list. In an embodiment an updated BLOb chunks key list is sent to the storage node that stores the initial BLOb chunk and the BLOb chunks key list is replaced with or updated according to the updated BLOb chunks key list.

Immediately upon the closing of BLObChunk a new BLOb chunk is created and the BLOb stream fills the new BLOb chunk from the point at which BLObChunk was closed. This process continues until the end of the BLOb is reached at which point the last BLOb chunk is generated. The last BLOb chunk BLObChunkN is associated with the BLOb chunk key MyBLObKey nnnn illustrates the last BLOb chunk and its associated BLOb chunk key . Although the previous BLOb chunks are fixed at the pre established size limit the last BLOb chunk may not reach the pre established size limit before the end of the BLOb is reached. Regardless once the end of the BLOb is reached the BLOb chunk is closed and the BLOb chunk is stored in the distributed key value storage system according to the BLOb key. For example the BLOb chunk key is hashed to determine the storage node at which the BLOb chunk will be stored. Additionally the BLOb chunk key is added to the BLOb chunks key list as illustrated in the expanded view of the BLOb chunks key list. In an embodiment an updated BLOb chunks key list is sent to the storage node that stores the initial BLOb chunk and the BLOb chunks key list is replaced with or updated according to the updated BLOb chunks key list.

In an embodiment the size of BLOb chunks is programmable. That is the pre established size limit can be set to a value that best suits the specific use case. In an embodiment the pre established size limit of a BLOb chunk can be programmed in response to various criteria including characteristics of the BLOb application type network conditions service level security characteristics compression characteristics etc. Additionally the pre established size limit can be adapted to adjust to changing conditions. Further different pre established size limits can be set for different combinations of the application type BLOb type network conditions services levels security characteristics compression characteristics etc.

BLOb chunks are retrieved from the distributed key value storage system by obtaining a key for the BLOb and indexing the key value storage system table to find the initial BLOb chunk. The initial BLOb chunk includes the BLOb chunks key list and may include some data of the BLOb. The rest of the BLOb data is located in the distributed key value storage system using the BLOb chunk keys that are found in the BLOb chunks key list. In an embodiment a method for retrieving BLObs from a distributed key value storage system involves obtaining a BLOb key indexing a table according to the BLOb key to find a value obtaining a BLOb chunks key list from the value wherein the BLOb chunks key list contains BLOb chunks keys that are related to BLOb chunks of the BLOb using the BLOb chunk keys to index the table and streaming BLOb chunks of the BLOb according to the BLOb chunk keys.

Because a BLOb is divided into BLOb chunks that are indexed by the BLOb chunks keys each BLOb can be individually identified and retrieved from the storage nodes. This enables seek or skip functionality to be implemented. For example various points in the BLOb can be directly accessed to retrieve a BLOb from the BLOb chunk that corresponds to the desired point in the BLOb. In an embodiment if a BLOb of video data is divided into 20 BLOb chunks the midway point in the video can be immediately retrieved from the distributed key value storage system by jumping to the tenth BLOb chunk and retrieving BLOb chunks ten through twenty.

Although the operations of the method s herein are shown and described in a particular order the order of the operations of each method may be altered so that certain operations may be performed in an inverse order or so that certain operations may be performed at least in part concurrently with other operations. In another embodiment instructions or sub operations of distinct operations may be implemented in an intermittent and or alternating manner.

It should also be noted that at least some of the operations for the methods may be implemented using software instructions stored on a computer useable storage medium for execution by a computer. As an example an embodiment of a computer program product includes a computer useable storage medium to store a computer readable program that when executed on a computer causes the computer to perform operations as described herein.

Furthermore embodiments of at least portions of the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing computer executable instructions or program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The computer useable or computer readable medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device . Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include a compact disk with read only memory CD ROM a compact disk with read write CD R W and a digital video disk DVD .

In an embodiment the functionality of the data store client of is performed by a computer such as a server which executes computer readable instructions. depicts a computer that includes a processor memory and a communications interface . The processor may include a multifunction processor and or an application specific processor. Examples of processors include the PowerPC family of processors by IBM and the x86 family of processors by Intel. The memory within the computer may include for example storage medium such as read only memory ROM flash memory RAM and a large capacity permanent storage device such as a hard disk drive. The communications interface enables communications with other computers via for example the Internet Protocol IP . The computer executes computer readable instructions stored in the storage medium to implement various tasks as described above.

In the above description specific details of various embodiments are provided. However some embodiments may be practiced with less than all of these specific details. In other instances certain methods procedures components structures and or functions are described in no more detail than to enable the various embodiments of the invention for the sake of brevity and clarity.

Although specific embodiments of the invention have been described and illustrated the invention is not to be limited to the specific forms or arrangements of parts so described and illustrated. The scope of the invention is to be defined by the claims appended hereto and their equivalents.

