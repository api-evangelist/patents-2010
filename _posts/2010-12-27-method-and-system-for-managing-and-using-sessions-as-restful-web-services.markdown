---

title: Method and system for managing and using sessions as RESTful web services
abstract: Disclosed herein are systems, methods, and non-transitory computer-readable storage media for managing and using sessions as RESTful web services. A session is exposed as a resource having an associated Uniform Resource Identifier (URI), and the session is composed with other services. For example, a client sends an HTTP POST request to a web server to create a session, an HTTP GET request to retrieve a representation of the session, an HTTP PUT request to update the representation of the session, and an HTTP DELETE request to delete the session so that resources within the session are reclaimed. Since the sessions are resources, the resources can be shared among clients, and the web servers knows the client states while still being stateless, making them robust and scalable. Composing web services with the common RESTful session service reduces complexity and enhances interoperability.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09509776&OS=09509776&RS=09509776
owner: Avaya Inc.
number: 09509776
owner_city: Basking Ridge
owner_country: US
publication_date: 20101227
---
This application claims the benefit of U.S. Provisional Application Ser. 61 350 602 filed Jun. 2 2010 by Wu Chou and Li Li the contents of which are herein incorporated herein by reference.

The present disclosure relates generally to clients and servers in a data processing network and more particularly to a data processing network using the Representational State Transfer REST architecture style. The disclosure more specifically relates to managing and using sessions in a data processing network providing RESTful web services.

Representational State Transfer REST is an acronym coined in Roy Fielding s doctoral dissertation to characterize the architecture style of the World Wide Web. RESTful web services refer to distributed processes that provide services functions to the client software following the REST principles. See chapter 5 of Fielding R. Architectural Styles and the Design of Network based Software Architectures Ph.D. Dissertation University of California Irvine Calif. 2000. The World Wide Web WWW commonly known as the Web is a system of interlinked hypertext documents accessed via the Internet. REST includes an abstraction of the architectural elements within the WWW and a set of constraints applied to these architectural elements. The REST architectural elements include data elements connectors and components.

The REST data elements include resources Uniform Resource Identifiers representations representation metadata resource metadata and control data. A resource is the intended conceptual target of a hypertext reference. Thus a resource is a conceptual mapping to a set of entities not the entity that corresponds to the mapping at any particular point in time. A Uniform Resource Identifier URI is a generic term for all types of names and addresses that refer to objects on the WWW. A URL Uniform Resource Locator is one kind of URI. A URL provides a means for locating the resource by describing its primary access mechanism e.g. its network location . REST components perform actions on a resource by using a representation to capture the current or intended state of that resource and transferring that representation between components. A representation is a sequence of bytes plus representation metadata to describe those bytes. For example an HTML document or a JPEG image is a representation.

The REST connectors provide a generic interface for accessing and manipulating the value set of a resource regardless of how the membership function is defined or the type of software that is handling the request. REST connectors include clients servers caches resolvers and tunnels. A dynamic name service DNS is an example of a resolver. A Secure Socket Layer SSL is an example of a tunnel.

The REST components include origin servers gateways proxies and user agents. A user agent uses a client connector to initiate a request and becomes the ultimate recipient of the response. The most common example is a Web browser which provides access to information services and renders service responses according to the application needs. An origin server uses a server connector to govern the namespace for a requested resource. It is the definitive source for representations of its resources and must be the ultimate recipient of any request that intends to modify the value of its resources. Intermediary components act as both a client and a server in order to forward with possible translation requests and responses. A proxy component is an intermediary selected by a client to provide interface encapsulation of other services data translation performance enhancement or security protection. A gateway a.k.a. reverse proxy component is an intermediary imposed by the network or origin server to provide an interface encapsulation of other services for data translation performance enhancement or security enforcement.

The first REST constraint is separation of the user interface concerns from the data storage concerns in a client server relationship. Separation of the user interface concerns from the data storage concerns improves the portability of the user interface across multiple platforms and improves scalability by simplifying the server components.

The second REST constraint is that the client server communication must be stateless. In particular each request from client to server must contain all of the information necessary to understand the request and cannot take advantage of any stored context on the server. Application state is therefore kept entirely on the client. This constraint induces the properties of visibility reliability and scalability. Visibility is improved because a monitoring system does not have to look beyond a single request datum in order to determine the full nature of the request. Reliability is improved because it eases the task of recovering from partial failures. Scalability is improved because not having to store state between requests allows the server component to quickly free resources and further simplifies implementation because the server doesn t have to manage resource usage across requests.

The third REST constraint is a cache constraint that the data within a response to a request be implicitly or explicitly labeled as cacheable or non cacheable. If a response is cacheable then a client cache is given the right to reuse that response data for later equivalent requests.

The fourth REST constraint is a uniform interface between the client server and intermediate components. The software engineering principle of generality is applied to the component interface so that the overall system architecture is simplified and the visibility of interactions is improved. Implementations are decoupled from the services they provide which encourages independent evolvability.

The fifth REST constraint is a layered system constraint. The layered system style allows an architecture to be composed of hierarchical layers by constraining component behavior such that each component cannot see beyond the immediate layer with which they are interacting. By restricting knowledge of the system to a single layer a bound is placed on the overall system complexity and substrate independence is promoted. Layers can be used to encapsulate legacy services and to protect new services from legacy clients simplifying components by moving infrequently used functionality to a shared intermediary. Intermediaries can also be used to improve system scalability by enabling load balancing of services across multiple networks and processors.

REST also provides an option of client functionality to be extended by downloading and executing code in the form of applets or scripts. This simplifies clients by reducing the number of features required to be pre implemented. Allowing features to be downloaded after deployment improves system extensibility. However it also reduces visibility and thus is only an optional feature within REST.

In general a session is an exchange of data between an association of participants. In a distributed system a client typically invokes a service to establish the association of the participants and the service provides a mechanism to maintain client state across subsequent client invocations of the service during the session. For example there are many applications of the Internet that require the creation and management of such a session. It is particularly useful in communication protocols and services because many of them such as Session Initiation Protocol SIP Jingle Parlay X and Computer Supported Telecommunications Applications CSTA require that a client establishes a session with the services or peers first before data is exchanged between clients. To move communication systems into a web centric architecture communication web services often have to integrate with various session based protocols to connect them into the web infrastructure. Because these session based protocols have different session formats it is important for the integrated web services to present a uniform session interface to hide the variations and complexities from the web service clients. Without such a uniform session service the integrated web services would be more complex and more difficult to interoperate.

Despite its importance however there is no standard way to establish sessions for web services. Over the years various techniques including the Hypertext Transfer Protocol HTTP cookie URI rewrite hidden form field etc. have been developed to address the session issue on the Web. The lack of a common session mechanism has created confusions among web service development and has limited interoperability among web services.

The HTTP cookie is defined in Kristol et al. HTTP State Management Mechanism Request for Comments 2965 October 2000 Network Working Group. The HTTP cookie is a mechanism for managing HTTP states. A HTTP cookie is a piece of data structure that associates an arbitrary name value pair with a set of HTTP server data including domain path and ports. A cookie can be discarded when the user agent exits or expires after a certain specified duration. The cookie is set by the HTTP response when the user interacts with a web server and the set cookie is sent by the web browser back to the server when the target URL matches the domain path and ports in the cookie. A user can also delete the remembered cookies from the web browser to prevent them from being sent.

The cookie mechanism has several problems as pointed out by a Wikipedia article on the HTTP cookie. From the REST point of view a HTTP cookie is not an addressable resource that can be controlled by the web service clients. As the result there is no standard way for a client to decide or access the content of a cookie delete a cookie from the server at will or change its expiry duration. Because of this lack of control cookies also break the statelessness principle of REST when a client revisits URLs prior to cookie. Further details of this problem can be found at page 252 of Leonard Richardson Sam Ruby RESTful Web Services 2007 O Reilly Media Inc. Sebastopol Calif.

Additional features and advantages of the disclosure will be set forth in the description which follows and in part will be obvious from the description or can be learned by practice of the herein disclosed principles. The features and advantages of the disclosure can be realized and obtained by means of the instruments and combinations particularly pointed out in the appended claims. These and other features of the disclosure will become more fully apparent from the following description and appended claims or can be learned by the practice of the principles set forth herein.

In one aspect the disclosure includes a method of managing and using a session as a web service. The method includes a data processor of an origin server on the Internet executing computer instructions stored on a non transitory computer readable storage medium to perform the steps of a responding to a user agent request to create a session by allocating data storage of the origin server with a representation of the session for storing session state information of the session the representation of the session having an associated Uniform Resource Identifier URI b responding to a user agent request to update session state information by finding that the user agent request to update a session includes the associated URI and upon finding that the user agent request to update session state information includes the associated URI updating session state information in the data storage allocated to the representation of the session created in step a c responding to a user agent request to retrieve session state information by finding that the user agent request to retrieve session state information includes the associated URI and upon finding that the user agent request to retrieve session state information includes the associated URI retrieving session state information from the data storage allocated to the representation of the session created in step a and d terminating the session by de allocating the data storage having been allocated to the representation of the session in step a .

In another aspect the disclosure includes a system for managing and using a session as a web service. The system includes an origin server on the Internet the origin server having a data processor and non transitory computer readable storage medium coupled to the data processor and storing computer instructions that when executed by the data processor perform the steps of a responding to a user agent request to create a session by allocating data storage of the origin server to a representation of the session for storing session state information of the session the representation of the session having an associated Uniform Resource Identifier URI b responding to a user agent request to update session state information by finding that the user agent request to update a session includes the associated URI and upon finding that the user agent request to update session state information includes the associated URI updating session state information in the data storage allocated to the representation of the session created in step a c responding to a user agent request to retrieve session state information by finding that the user agent request to retrieve session state information includes the associated URI and upon finding that the user agent request to retrieve session state information includes the associated URI retrieving session state information from the data storage allocated to the representation of the session created in step a and d terminating the session by de allocating the data storage having been allocated to the representation of the session in step a .

In a final aspect the disclosure includes a non transitory computer readable storage medium storing computer instructions that when executed by a data processor of an origin server on the Internet perform management of a session as a web service by the steps of a responding to a user agent request to create a session by allocating data storage of the origin server to a representation of the session for storing session state information of the session the representation of the session having an associated Uniform Resource Identifier URI b responding to a user agent request to update session state information by finding that the user agent request to update a session includes the associated URI and upon finding that the user agent request to update session state information includes the associated URI updating session state information in the data storage allocated to the representation of the session created in step a c responding to a user agent request to retrieve session state information by finding that the user agent request to retrieve session state information includes the associated URI and upon finding that the user agent request to retrieve session state information includes the associated URI retrieving session state information from the data storage allocated to the representation of the session created in step a and d terminating the session by de allocating the data storage having been allocated to the representation of the session in step a .

Various embodiments of the disclosure are discussed in detail below. While specific implementations are discussed it should be understood that this is done for illustration purposes only. A person skilled in the relevant art will recognize that other components and configurations may be used without parting from the spirit and scope of the disclosure.

The present disclosure addresses a need in the art for a standard way to establish sessions for web services. As will be further described below a client agent and a web server can be used to establish a session in a standard way so that sessions compose with other web services following the REST principles.

First will be described a basic general purpose system or computing device in which can be used as a client agent or a web server to practice the concepts disclosed herein. A more detailed description of the method and system for managing and using sessions as RESTful web services will then follow.

With reference to an exemplary system includes a general purpose computing device including a processing unit CPU or processor and a system bus that couples various system components including the system memory such as read only memory ROM and random access memory RAM to the processor . The system can include a cache of high speed memory connected directly with in close proximity to or integrated as part of the processor . The system copies data from the memory and or the storage device to the cache for quick access by the processor . In this way the cache provides a performance boost that avoids processor delays while waiting for data. These and other modules can control or be configured to control the processor to perform various actions. Other system memory may be available for use as well. The memory can include multiple different types of memory with different performance characteristics. It can be appreciated that the disclosure may operate on a computing device with more than one processor or on a group or cluster of computing devices networked together to provide greater processing capability. The processor can include any general purpose processor and a hardware module or software module such as module module and module stored in storage device configured to control the processor as well as a special purpose processor where software instructions are incorporated into the actual processor design. The processor may essentially be a completely self contained computing system containing multiple cores or processors a bus memory controller cache etc. A multi core processor may be symmetric or asymmetric.

The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. A basic input output BIOS stored in ROM or the like may provide the basic routine that helps to transfer information between elements within the computing device such as during start up. The computing device further includes storage devices such as a hard disk drive a magnetic disk drive an optical disk drive tape drive or the like. The storage device can include software modules for controlling the processor . Other hardware or software modules are contemplated. The storage device is connected to the system bus by a drive interface. The drives and the associated computer readable storage media provide nonvolatile storage of computer readable instructions data structures program modules and other data for the computing device . In one aspect a hardware module that performs a particular function includes the software component stored in a non transitory computer readable medium in connection with the necessary hardware components such as the processor bus display and so forth to carry out the function. The basic components are known to those of skill in the art and appropriate variations are contemplated depending on the type of device such as whether the device is a small handheld computing device a desktop computer or a computer server.

Although the exemplary embodiment described herein employs the hard disk it should be appreciated by those skilled in the art that other types of computer readable media which can store data that are accessible by a computer such as magnetic cassettes flash memory cards digital versatile disks cartridges random access memories RAMs read only memory ROM a cable or wireless signal containing a bit stream and the like may also be used in the exemplary operating environment. Non transitory computer readable storage media expressly exclude media such as energy carrier signals electromagnetic waves and signals per se.

To enable user interaction with the computing device an input device represents any number of input mechanisms such as a microphone for speech a touch sensitive screen for gesture or graphical input keyboard mouse motion input speech and so forth. An output device can also be one or more of a number of output mechanisms known to those of skill in the art. In some instances multimodal systems enable a user to provide multiple types of input to communicate with the computing device . The communications interface generally governs and manages the user input and system output. There is no restriction on operating on any particular hardware arrangement and therefore the basic features here may easily be substituted for improved hardware or firmware arrangements as they are developed.

For clarity of explanation the illustrative system embodiment is presented as including individual functional blocks including functional blocks labeled as a processor or processor . The functions these blocks represent may be provided through the use of either shared or dedicated hardware including but not limited to hardware capable of executing software and hardware such as a processor that is purpose built to operate as an equivalent to software executing on a general purpose processor. For example the functions of one or more processors presented in may be provided by a single shared processor or multiple processors. Use of the term processor should not be construed to refer exclusively to hardware capable of executing software. Illustrative embodiments may include microprocessor and or digital signal processor DSP hardware read only memory ROM for storing software performing the operations discussed below and random access memory RAM for storing results. Very large scale integration VLSI hardware embodiments as well as custom VLSI circuitry in combination with a general purpose DSP circuit may also be provided.

The logical operations of the various embodiments are implemented as 1 a sequence of computer implemented steps operations or procedures running on a programmable circuit within a general use computer 2 a sequence of computer implemented steps operations or procedures running on a specific use programmable circuit and or 3 interconnected machine modules or program engines within the programmable circuits. The system shown in can practice all or part of the recited methods can be a part of the recited systems and or can operate according to instructions in the recited non transitory computer readable storage media. Such logical operations can be implemented as modules configured to control the processor to perform particular functions according to the programming of the module. For example illustrates three modules Mod Mod and Mod which are modules configured to control the processor . These modules may be stored on the storage device and loaded into RAM or memory at runtime or may be stored as would be known in the art in other computer readable memory locations.

Having disclosed some components of a computing system the disclosure now turns to which illustrates the Internet linking a first user agent and a second user agent to an origin server . In a preferred implementation each of the user agents and the origin server is a programmed computing system as shown in . The Internet may include network components such as routers not shown and Web components such as proxy servers and gateways not show interposed between the user agents and the origin server . Each of the network components and Web components of the Internet may also be a programmed computing system as shown in .

The present disclosure addresses the need in the art for a standard way to establish sessions for web services. The various techniques that have been developed to address the session issue on the Web such as HTTP cookie URI rewrite hidden form field etc. were designed for human to machine interactions and were not designed for machine to machine interactions such as communication services. In communication services for example both client and server should be able to control access and monitor the sessions. Moreover the sessions can contain arbitrary data defined by the services. Furthermore the sessions should be able to compose with other web services following the REST principles.

In the system of for communicating data over the Internet between the first user agent and the second user agent the first user agent has a first instance of a client application and the second user agent has a second instance of the client application. The client application for example is a web conference application for enabling a first human user of the user agent to communicate with a second human user of the second user agent by exchanging voice data video text and documents over the Internet in real time.

In order to establish a session for communication of data between the user agents the client application in one of the user agents invokes a RESTful session service of an origin server . The RESTful session service is exposed as a resource by having an associated URI and the RESTful session service is composed with other RESTful web services such as the POST GET PUT and DELETE web services.

The RESTful session service and the other RESTful web services are implemented as programs of computer instructions stored in program memory of the origin server . The origin server has a data processor for executing the programs in the program memory to provide the web services to the user agents .

Once the session is established the RESTful session service is subsequently invoked by the client application in the first user agent or in the second user agent during the exchange of the data between the first instance of client application and the second instance of the client application . For the case of a web conference application the establishment of the session permits session state information to be preserved in data storage of the origin server for access by the user agents and possibly by other user agents not shown in the Internet during the session.

The session state information for example includes a session timer for each session such as a timer for a first session and a timer for a second session. The timer for each session is initially set when a session is created and upon expiration of the session timer the origin server deletes the session by de allocating the data storage allocated for storing the session state information. In other words deletion of a session includes recovery of resources that were allocated to the session when the session was created.

The session state information permits the session to be continued when the user agents crash and are rebooted and when additional user agents not shown are added to the web conference and the original user agents are dropped from the web conference. For example the user agents are mobile wireless computers or smart phones having Internet Protocol IP addresses that may change when the user agents crash and are rebooted or when the user agents move to different geographic locations.

The HTTP standard POST GET PUT and DELETE methods are defined in Fielding et al. Request for Comments 2161. In general the POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request URI in the Request Line. The GET method is used to retrieve whatever information in the form of an entity is identified by the Request URI. The PUT method requests that the enclosed entity be stored under the supplied Request URI. If the PUT method creates a new resource then the origin server must inform the user agent via the Created response. If the PUT method modifies an existing resource then either the OK or No Content response codes should be sent to indicate successful completion of the request. The DELETE method requests that the origin server delete the resource identified by the Request URI.

In the session factory the POST method is used to create a session and the GET method is used to return a list of the existing session resources.

For an individual session the GET method is used to retrieve the session and the DELETE method is used to delete the session. For an individual session the PUT method is overloaded to support three different services suspend resume and renew as they merely change the state of a session resource. For example the suspend service stops a session timer for the session the resume service restarts the session timer for the session and renew resets the session timer for the session.

For example for any resource r with relative URI u within a session its relative URI becomes session session u . If the session does not exist then the URI would be invalid. The server can also match the URI with a client s credentials to determine if the client is authorized to access a session. Depending on the service each subordinate resource in a session can be interpreted as either a copy or a reference to some resource. When the session is terminated the service can reclaim the resources within the session accordingly. By using a timeout a server can also release dangling sessions in case the client dies. In the case of CSTA for example the monitors and registrations within a session should be deleted when a session terminates whereas the devices within a session should not as they are shared by different sessions.

In step the origin server responds to a user agent request to update session state information by finding that the user agent request to update a session includes the associated URI and upon finding that the user agent request to update session state information includes the associated URI updating session state information in the data storage allocated to the representation of the session.

In step the origin server responds to a user agent request to retrieve session state information by finding that the user agent request to retrieve session state information includes the associated URI and upon finding that the user agent request to retrieve session state information includes the associated URI retrieving session state information from the data storage allocated to the representation of the session.

Finally in step the origin server terminates the session by de allocating the data storage having been allocated to the representation of the session. For example the origin server terminates the session in response to a user agent delete session request including the URI of the session or the origin server terminates the session in response to expiration of a timer for the session. Upon termination of the session the origin server sends session termination notifications to any user agents having registered to receive termination notifications for the session.

In a preferred implementation the session factory POST method has a request body containing the following XML template where . . . indicate extension points 

The session termination event is generated when the session terminates prematurely. It has the following XML template 

If the POST operation succeeds the response returns HTTP status code and the URI to the newly created session resource in the HTTP Location Header. The HTTP response body contains 

On failure of the POST operation proper HTTP client error code 4xx or server error code 5xx is returned.

On success of the session factory GET method the response has HTTP status code . The returned representation has the following XML template 

In a preferred implementation the session resource GET request has a body that is empty. On success f the GET operation the response body contains the same XML template as described above in the response to the POST request. If the session was moved a proper HTTP 3xx status code is returned. On failure of the GET operation a proper HTTP error code is returned.

In a preferred implementation the session resource PUT request has a body that contains the same XML template as described above for the POST method. On success the status code is returned and the response body is the same as the response body for the response to the POST request. If the session was moved a proper HTTP 3xx status code is returned. On failure a proper HTTP error code is returned.

In a preferred implementation the session resource DELETE request has a request body that is empty. On success a status code is returned. The server is responsible to release any client states associated with the deleted session. If the session was moved a proper HTTP 3xx status code is returned. On failure a proper HTTP error code is returned.

In the preferred implementation XML is used to describe resource representations. However other representations that maintain the XML Infoset of these XML templates can also be used such as JSON X HTML or key value pairs. The clients can use HTTP content negotiation to retrieve the desired format.

In the preferred implementation the returned URI may not be in the same domain as the . Combined with HTTP redirection this would allow some services to delegate their session management to a shared session factory.

To receive the session terminated event a client can subscribe to the session observer resource. One way to achieve this is to use W3C Server Sent Events.

The session services described above can be composed with other RESTful web services to maintain the client states for those other services. A typical sequence of operations to achieve this composition is shown in . In a first step a client obtains the URI to the resource for the web resource for the web service X it needs to invoke. Next in step the client uses the URI to the resource to create a session with URI . For example the session factory server is at and a POST request is sent to the session factory server to create a session SN126546 stored at . In step the client sets an event listener to URI to receive the event. For example the client sends a PUT request to to turn the event listener on in the session state. In step the client accesses a resource in a target service X by passing the URI in one or more requests. For example the target service X is a conference service at and the client sends a GET request to to pass the URI . Finally in step either the client deletes the session by sending a DELETE request to the URI or the session server terminates the session upon expiration of a session timer.

There are at least three ways to pass the URI to the target service. One way as shown in step is to pass the URI as an HTTP extension header. For example to GET a resource at URI myresource the request would look like 

A second way as shown in step is to pass the URI as a URI query parameter. For example to GET a resource at URI myresource the request would look like 

A third way as shown in step is to pass the URI as a parent resource where the session resource is modeled as the parent of the target resource. For example to GET a resource at URI myresource the request would look like 

Nested sessions can also be created with the RESTful session service in . For example the Computer Supported Telecommunications Applications CSTA as defined in EMCA 269 8edition Services for Computer Supported Telecommunication Applications June 2009 has various message and behavior patterns that include session message exchange patterns and can be composed with sessions provided by the RESTful session service in .

Session is used in CSTA for two purposes 1 to discriminate concurrent interactions of the same type and 2 to manage the lifetime of certain resources. Many services can be classified as session according to these two criteria including registrations Routing I O Call Detail Report and Location Services. There is also a top level session association for all interactions between the client and server. Once this top level session is terminated the monitors and registrations created in that session will be removed as well. In this sense many CSTA interactions happen within nested sessions. A session hierarchy may simplify the CSTA services by replacing many of its ad hoc sessions. Another benefit of this session hierarchy is that events from the subordinate resources can bubble up to the parent session so that one event listener can be registered for all events within the top level session.

Since the RESTful sessions are resources servers knows the client states while still being stateless making them robust and scalable. This approach thus avoids the pitfalls of the HTTP cookie which is not a resource and cannot be controlled by the client in a standard way. Because a session can be persisted a server can restore the sessions after reboot. Composing with a common session service removes the need for each service to develop its own ad hoc session mechanisms which will complicate the service and decrease the interoperability of the services.

Composition in REST can be more efficient than in Simple Object Access Protocol SOAP . In SOAP services since one message carries payloads of all composed services every time a new service is composed the message has to be changed accordingly and examined by all service modules. In contrast service compositions in REST can be achieved in the resource level instead of the message level. As a result REST compositions need not modify the messages at all and different messages can be handled by different resources. For instance the messages to and from the resource r can be the same regardless if r is composed with the session service or not.

For example as shown in there are subsidiary resources for the system handling the call monitoring of the call routing of the call input output I O of data exchanged during the call collection of data about the call exchange of data representing voice during the call a call detail report about the call location of the human participants of the call and an extension of the call.

For example if the session state information about the top level session is accessed at a URL of and the relative URI for the call detail report is then the session state information for the call detail report would be accessed at a URL of .

In view of the above there has been described a method and system for RESTful session management that offers clients with the ability to control monitor and access the sessions in a standard way. The sessions can be shared among applications clients and servers. The shared ownership is important to many applications especially in communication protocols and systems. The method and system for RESTful session management exposes sessions as resources that support uniform interface. As resources addressable by URI sessions can be connected easily with other applications and resources. This connectedness promotes reusability discoverability and ability to create new services. For example a session URI can be passed around in a message to invite other parties to join the session. The RESTful sessions can be composed with other services in flexible ways to unify the current approaches to session management as RESTful web services.

Embodiments within the scope of the present disclosure may also include tangible and or non transitory computer readable storage media for carrying or having computer executable instructions or data structures stored thereon. Such non transitory computer readable storage media can be any available media that can be accessed by a general purpose or special purpose computer including the functional design of any special purpose processor as discussed above. By way of example and not limitation such non transitory computer readable media can include RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium which can be used to carry or store desired program code means in the form of computer executable instructions data structures or processor chip design. When information is transferred or provided over a network or another communications connection either hardwired wireless or combination thereof to a computer the computer properly views the connection as a computer readable medium. Thus any such connection is properly termed a computer readable medium. Combinations of the above should also be included within the scope of the computer readable media.

Computer executable instructions include for example instructions and data which cause a general purpose computer special purpose computer or special purpose processing device to perform a certain function or group of functions. Computer executable instructions also include program modules that are executed by computers in stand alone or network environments. Generally program modules include routines programs components data structures objects and the functions inherent in the design of special purpose processors etc. that perform particular tasks or implement particular abstract data types. Computer executable instructions associated data structures and program modules represent examples of the program code means for executing steps of the methods disclosed herein. The particular sequence of such executable instructions or associated data structures represents examples of corresponding acts for implementing the functions described in such steps.

Those of skill in the art will appreciate that other embodiments of the disclosure may be practiced in network computing environments with many types of computer system configurations including personal computers hand held devices multi processor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. Embodiments may also be practiced in distributed computing environments where tasks are performed by local and remote processing devices that are linked either by hardwired links wireless links or by a combination thereof through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

The various embodiments described above are provided by way of illustration only and should not be construed to limit the scope of the disclosure. Those skilled in the art will readily recognize various modifications and changes that may be made to the principles described herein without following the example embodiments and applications illustrated and described herein and without departing from the spirit and scope of the disclosure.

