---

title: Controlling database trigger execution with trigger return data
abstract: A database trigger generates a return code having the effect of inhibiting further executions of the trigger within a pre-defined scope of execution. Preferably, the pre-defined scope is a task or process executing on behalf of a particular user. Upon first encountering the applicable trigger condition, the corresponding trigger is fired normally. Internal logic within the trigger determines whether it is necessary to call the same trigger again within the same scope, and if not, generates corresponding return data. A database management system which manages the trigger and causes it to automatically fire intercepts the return data and disables further firing of the trigger for the pre-defined scope.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08898124&OS=08898124&RS=08898124
owner: International Business Machines Corporation
number: 08898124
owner_city: Armonk
owner_country: US
publication_date: 20101216
---
The present invention relates to digital data processing and in particular to the operation of databases which support triggers and similar user defined functions.

In the latter half of the twentieth century there began a phenomenon known as the information revolution. While the information revolution is a historical development broader in scope than any one event or machine no single device has come to represent the information revolution more than the digital electronic computer. The development of computer systems has surely been a revolution. Each year computer systems grow faster store more data and provide more applications to their users.

A modern computer system has the capability to store mountains of data and using readily available networks can access even more data. Unfortunately the capability of digital systems to store and access data has generally outpaced the ability of users to organize or understand the data. Considerable effort has been and continues to be devoted to developing improved techniques for organizing searching collating and presenting meaningful information to users from the voluminous data potentially available.

Computer systems may be used to support a variety of applications but one common use is the maintenance of large databases from which information may be obtained. Conceptually a database may be viewed as one or more tables of information each table having multiple entries analogous to rows of a table each entry having multiple respective data fields analogous to columns of the table . In the case of some tables the number of entries may be very large. A database management application typically includes capabilities for maintaining the data in the database in a consistent and coherent fashion for executing queries against the data to obtain information of interest and for generating and maintaining metadata which can be useful in executing queries analyzing database performance and so forth. For example the database management application will often enforce constraints on particular data fields data must be of a certain type within a certain range or bear a specified relationship with other data in the database will automatically generate search strategies for executing queries against the data or will automatically generate and maintain one or more indexes keyed by selective database fields whereby records can be conveniently located according to the value of the key field.

A database management application may be custom written for managing a particular database but it is often a generic application intended to support different databases having widely varying parameters. The database management application will therefore support a variety of customization options to customize the application for a particular database. For example the database management application will typically enable a privileged user such as a system administrator to define the number of tables in the database the number of fields in each table and the type of data in each field. The database management application will further provide an interface whereby other applications executing on behalf of users may invoke its functions to access data in the database.

Among the database customization capabilities offered by some database management applications is support for pre defined customization functions involving the database sometimes known as database triggers or simply triggers. A database trigger is a procedure defined according to some syntax supported by the database management application which is executed whenever the corresponding trigger conditions are met. The trigger conditions are defined as part of the trigger. The trigger conditions must be chosen from among a limited range of conditions supported by the database management application. The database management application therefore monitors the trigger conditions and if the conditions of any defined trigger are satisfied executes fires the trigger. Triggers may be used for example to enforce data integrity constraints to enforce business policies to enforce security constraints to back up data or for various other purposes.

Triggers have the advantage of offering a flexible easily maintainable centralized control mechanism for customizing the database. Because the trigger executes automatically whenever the pre defined trigger conditions are met it is not necessary for user applications which access the database to explicitly invoke the trigger or perform any of the trigger s functions. The trigger itself may contain any required conditional logic to perform the corresponding operation s only when required by the circumstances so that all maintenance of conditions associated with performing an operation is handled in a single place.

Unfortunately triggers can also impose a significant burden on system performance. There is considerable overhead involved in executing a trigger i.e. in calling and initializing the trigger procedure. This overhead is incurred whenever the trigger is fired whether it actually does anything or not. Many triggers are written to address circumstances which rarely arise or arise only with certain users and not others. It is not uncommon for a trigger to fire many times on behalf of a single executing application. In the majority of times these triggers are called statements near the beginning of the trigger procedure determine that the trigger is inapplicable and simply return without doing anything. In this case the overhead burden has already been incurred.

It is possible to provide data structures and or conditional logic for selectively enabling and disabling a trigger in order to reduce the instances of unnecessary trigger execution but such mechanisms involve additional complexity and must be maintained consistent with any changes to the trigger or to the needs of the database to apply the trigger s function. Maintaining logic affecting the trigger s function in code or data structures external to the trigger defeats one of the major advantages of the trigger and increases the likelihood of unforeseen errors.

A need exists not necessarily recognized for improved techniques for managing database triggers and in particular for techniques for reducing the instances of unnecessary trigger execution without incurring undue maintenance burdens.

Upon the first execution of a trigger within a pre defined scope the trigger generates return data. At least one of the potential return data generatable by the trigger has the effect of inhibiting further executions of the trigger within the pre defined scope.

In the preferred embodiment the pre defined scope is a task or process executing on behalf of a particular user. Upon first encountering the applicable trigger condition the corresponding trigger will be fired in the normal fashion. The trigger contains internal logic i.e. one or more code statements for determining whether it is necessary to call the same trigger again within the scope of the task or process which invoked it. If the logic determines that it is not necessary to call the trigger again the trigger generates return data such as an SQL return code which so indicates. A database management application which manages the trigger and causes it to automatically fire intercepts the return data and disables further firing of the trigger for the scope of the executing task or process.

In many instances a trigger will be able to determine based on the nature of the invoking application user or other parameter that further firing of the same trigger is unnecessary for the scope of the executing task or process. A mechanism for selectively disabling the firing of a trigger in accordance with the preferred embodiment therefore reduces unnecessary firing of the trigger. Furthermore since the trigger itself is responsible for generating the applicable return data the conditions upon which further firing of the trigger is disabled are entirely within the control of the trigger itself and require no maintenance of code or data structures outside the trigger.

The details of the present invention both as to its structure and operation can best be understood in reference to the accompanying drawings in which like reference numerals refer to like parts and in which 

Referring to the Drawing wherein like numbers denote like parts throughout the several views is a high level representation of the major hardware components of a computer system for use in managing a database having triggers and managing database trigger execution according to the preferred embodiment of the present invention. Computer system includes at least one general purpose programmable processor CPU which executes instructions and processes data from main memory . Main memory is preferably a random access memory using any of various memory technologies in which data is loaded from storage or otherwise for processing by CPU .

One or more communications buses provide a data communication path for transferring data among CPU main memory and various I O interface units which may also be known as I O processors IOPs or I O adapters IOAs . The I O interface units support communication with a variety of storage and I O devices. For example terminal interface unit supports the attachment of one or more user terminals . Storage interface unit supports the attachment of one or more direct access storage devices DASD which are typically rotating magnetic disk drive storage devices although they could alternatively be other devices including arrays of disk drives configured to appear as a single large storage device to a host . I O device interface unit supports the attachment of any of various other types of I O devices such as printer and fax machine it being understood that other or additional types of I O devices could be used. Network interface supports a connection to one or more external networks of which one is shown for communication with one or more other digital devices. Network may be any of various local or wide area networks as are known in the art and in particular may be the Internet.

It should be understood that is intended to depict the representative major components of computer system at a high level that individual components may have greater complexity than represented in that components other than or in addition to those shown in may be present and that the number type and configuration of such components may vary and that a large computer system such as a server for providing database services to multiple clients communicating over a network will typically have more components than represented in . Several particular examples of such additional complexity or additional variations are disclosed herein it being understood that these are by way of example only and are not necessarily the only such variations.

Although only a single CPU is shown for illustrative purposes in computer system may contain multiple CPUs as is known in the art. Although main memory is shown in as a single monolithic entity memory may in fact be distributed and or hierarchical as is known in the art. E.g. memory may exist in multiple levels of caches and these caches may be further divided by function so that one cache holds instructions while another holds non instruction data which is used by the processor or processors. Memory may further be distributed and associated with different CPUs or sets of CPUs as is known in any of various so called non uniform memory access NUMA computer architectures. Although communications buses are shown in as a single entity in fact communications among various system components is typically accomplished through a complex hierarchy of buses interfaces and so forth in which higher speed paths are used for communications between CPU and memory and lower speed paths are used for communications with I O interface units . Buses may be arranged in any of various forms such as point to point links in hierarchical star or web configurations multiple hierarchical buses parallel and redundant paths etc. For example as is known in a NUMA architecture communications paths are arranged on a nodal basis. Buses may use e.g. an industry standard PCI bus or any other appropriate bus technology. While multiple I O interface units are shown which separate buses from various communications paths running to the various I O devices it would alternatively be possible to connect some or all of the I O devices directly to one or more system buses.

Computer system depicted in has multiple attached terminals such as might be typical of a multi user mainframe computer system. Typically in such a case the actual number of attached devices is greater than those shown in although the present invention is not limited to systems of any particular size. User workstations or terminals which access computer system might be used to provide a user interface to users executing applications which access a database similar to client applications which invoke a server to access a database over a network but which execute directly on computer system without the need to communicate through a network. System may alternatively be a single user system typically containing only a single user display and keyboard input. Furthermore while the invention herein is described for illustrative purposes as embodied in a single computer system the present invention could alternatively be implemented using a distributed network of computer systems in communication with one another in which different functions or steps described herein are performed on different computer systems.

While various system components have been described and shown at a high level it should be understood that a typical computer system contains many other components not shown which are not essential to an understanding of the present invention. In the preferred embodiment computer system is a multi user computer system such as a computer system based on the IBM i Series architecture it being understood that the present invention could be implemented on other computer systems.

Database contains one or more tables of which three are shown in each having a plurality of entries or records each entry containing at least one and usually many fields as is well known in the art. Database tables might contain almost any type of data which is provided to users by a computer system. Associated with the database tables are one or more auxiliary data structures also sometimes referred to as metadata. Auxiliary data structures characterize the structure of the database and data therein and are useful in various tasks involved in database management particularly in executing queries against the database. Examples of auxiliary data structures include database index materialized query table MQT and histogram it being understood that other types of metadata may exist.

Database management application is one or more computer programs containing executable code and associated state data providing basic functions for the management of database . Database management application may theoretically support an arbitrary number of database tables which may or may not have related information although only three tables are shown in . Database management application preferably allows users to perform basic database operations such as defining a database altering the definition of the database creating editing and removing records in the database viewing records in the database defining database auxiliary data structures such as indexes and materialized query tables and so forth. Database management application further supports the making of queries against data in database tables . Preferably query support functions in database management application include query optimizer and query engine . Database management application further automatically maintains defined auxiliary database structures e.g. index MQT and or histogram concurrently with changes made to records in database tables . Database management application may further contain any of various more advanced database functions. In the preferred embodiment database management application implements a structured query language SQL query protocol it being understood that a database management application might alternatively query and structure data according to some other protocol. Although database management application is represented in as an entity separate from operating system kernel it will be understood that in some computer architectures various database management functions are integrated with the operating system.

In accordance with the preferred embodiment database management application further includes a trigger engine which executes one or more triggers of which three are illustrated in it being understood that the number of triggers may vary. Each trigger comprises a respective defined sequence of instructions to be performed upon the occurrence of one or more respective defined triggering events. The instructions within the trigger conform to some pre defined syntax for trigger instructions. These instructions could be processor executable code instructions produced by a compiler which conform to an instruction code set for the corresponding processor . But more frequently the trigger instructions are instructions in a high level language which are not directly executable by the processor but which are interpreted or compiled by trigger engine into processor executable instructions.

Database management application supports multiple possible triggering events. At a low functional level this means that the executable computer program code which forms database management application contains instructions which cause trigger conditions to be checked at various code locations any of which may cause execution of a trigger. The checks performed at these code locations support a set of possible triggering events which can be used to fire a trigger i.e. cause the instructions contained in the trigger to be performed. For each trigger one or more respective triggering events is defined. If any of the triggering events is encountered during execution the trigger is fired by invoking the trigger engine to perform the set of instructions contained in the trigger. Triggers may support a wide variety of database related functions limited only by the syntax of the trigger instruction set and the trigger conditions supported by database management application .

OS Kernel supports concurrent execution of multiple processes as is well known in the art. For each concurrently executing process a respective process state data area A B C herein generically referred to as feature is maintained each process state data area containing state data particular to the executing process. depicts three process state data areas A B C it being understood that this number may vary and is typically much larger. Process state data may include e.g. a process stack a process heap and or other data structures. In the preferred embodiment among the state data which may be maintained in process a state data area is a respective trigger condition table A B C herein generically referred to as feature for controlling the firing of triggers as explained in greater detail herein.

Although a certain number and type of database components one database having three database tables one index one MQT one histogram and three triggers are shown in the number of such entities may vary and could be much larger. The computer system may contain multiple databases each database may contain multiple tables and each database may have associated with it multiple indexes MQTs histograms or other auxiliary data structures not illustrated. Alternatively some entities represented in might not be present in all databases for example some databases might not contain materialized query tables or the like. Additionally database may be logically part of a larger distributed database which is stored on multiple computer systems. Although database management application is represented in as part of database the database management application being one or more computer programs comprising executable code is sometimes considered an entity separate from the database i.e. the data tables and associated metadata.

Various software entities are represented in as being separate entities or contained within other entities. However it will be understood that this representation is for illustrative purposes only and that particular modules or data entities could be separate entities or part of a common module or package of modules. Furthermore although a certain number and type of software entities are shown in the conceptual representation of it will be understood that the actual number of such entities may vary and in particular that in a complex server environment the number and complexity of such entities is typically much larger. Additionally although software components and are depicted in on a single computer system for completeness of the representation it is not necessarily true that all programs functions and data will be present on a single computer system or will be performed on a single computer system. In particular user applications which access a database are often stored and executed on remote or distributed systems the requests to access the database being transmitted via one or more networks to computer .

While the software components of are shown conceptually as residing in memory it will be understood that in general the memory of a computer system will be too small to hold all programs and data simultaneously and that information is typically stored in data storage devices comprising one or more mass storage devices such as rotating magnetic disk drives and that the information is paged into memory by the operating system as required. In particular database tables are typically much too large to be loaded entirely into memory and typically only a small portion of the total number of records is loaded into memory at any one time. Furthermore it will be understood that the conceptual representation of is not meant to imply any particular memory organizational model and that system might employ a single address space virtual memory or might employ multiple virtual address spaces which overlap.

In the preferred embodiment database management application maintains a respective trigger condition table for each executing process which invokes it. The trigger condition table is used to identify active triggers and fire the triggers when appropriate. The trigger condition table is maintained with other process data in the corresponding process state data area . It will be understood that not necessarily all executing processes utilize the functions of database management application and processes which do not would not contain trigger condition tables.

Each pre defined trigger condition corresponding to a row of table is one of a set of conditions which can be specified to fire a trigger. I.e. database management application as written and compiled by its developer s is one or more generic database computer programs which supports a pre defined set of potential trigger conditions. A trigger is typically written by a system administrator or other user i.e. a person or persons other than the original developer s of database management application to customize a database from the generic database management application program s . The developer of a trigger can specify any of the pre defined potential trigger conditions as a condition for the firing of the trigger being developed. Depending on the design of database management application the trigger developer may be able to specify only a single one of the pre defined conditions for each trigger or may be able to specify multiple alternative conditions for each trigger. In either case the trigger developer is limited to this set of pre defined trigger conditions for if the trigger developer were able to specify any arbitrary condition then the trigger developer would have to be able to modify the database management application itself for example by having access to the source code. This is generally undesirable from a code maintenance standpoint and in many cases would violate code licensing restrictions.

A pre defined trigger condition typically involves some specific code path. The trigger condition might be so simple as a particular code path being taken meaning that the condition is met whenever the code path is taken. Alternatively the trigger condition might be a logical conjunction of the code path and the state of specific state data i.e. the condition is met whenever the code path is taken AND state data meets some pre defined logical condition.

The executable code which forms database management application contains one or more instructions in each code path associated with a pre defined trigger condition to cause any triggers associated with the pre defined trigger condition to fire. These instructions will reference the cell in table at the row corresponding to the pre defined trigger condition and the column corresponding to all triggers. The cell at column is simply a logical OR of the data in all other cells of the same row i.e. it indicates whether there is any trigger which is specified to fire on the corresponding pre defined trigger condition. Thus by referencing a single bit in table the executable code which forms database management application can quickly determine whether there is any trigger which should be fired. Depending on the condition it may be necessary to examine other state data as well although pre defined conditions are usually fairly simple. This test can be performed very rapidly by in line code with little overhead so that if there is no such trigger the effect on performance is negligible even if the code path is taken many times. However if a trigger is found then trigger engine is invoked to determine which trigger or triggers need to be executed fired and to execute each such trigger. Trigger engine can determine which triggers to fire by examining the corresponding row of table each cell having its bit set indicating a corresponding trigger the column which should be fired. There is substantial overhead associated with invoking the trigger engine and firing each such trigger.

Preferably master trigger condition table is automatically updated by an appropriate function within database management application whenever a trigger is created modified or deleted to reflect the current state of all triggers defined for database . For example when a new trigger is created a new column is added to master trigger condition table for the newly created trigger. Any of the pre defined conditions specified for invoking the trigger will have flag bits set in the corresponding row s at the new column. The column for all triggers will be updated to reflect the new flag bits as required. Analogous changes will be made when a trigger is modified or deleted.

Although trigger condition table is shown conceptually in as a table containing rows and columns of flag bits it will be appreciated by those of skill in the art that the data in trigger condition table could be maintained in alternative formats.

Because database management application supports only a limited pre defined set of trigger conditions and these must be customizable to support a wide variety of different database functions for different databases the pre defined trigger conditions are generally defined broadly so as to encompass any circumstance which might be of interest. Trigger developers typically have to include additional conditional logic within the trigger which further qualifies the circumstances under which the trigger is to perform its intended function. When the trigger is fired this conditional logic is usually the first thing that gets executed within the trigger. For many triggers the conditional logic causes the trigger to return without doing anything most of the time. However by this point the overhead of firing the trigger has already been incurred.

In accordance with the preferred embodiment this overhead of firing the trigger can be avoided in certain circumstances by including logic within the trigger itself which determines whether subsequent firings of the same trigger should be disabled within the context of the process which caused the trigger to be fired. If the trigger s internal logic determines that it is no longer necessary to fire the trigger for the executing process it generates return data which so indicates when returning to trigger engine . The return data is preferably a specially defined SQL return code or one of several such specially defined return codes although it could be any data returned by the trigger. The trigger engine detects this return data and responsive thereto resets the flag bit or bits in trigger condition table corresponding to the trigger just fired. If resetting the flag bit in a particular row of table causes all trigger columns of the row to contain zero values then the cell of the same row at column corresponding to all triggers is also reset to zero. As a result when the corresponding trigger condition e.g. a code path is again encountered during execution the in line executable code of database management system will check table find a zero in the flag bit corresponding to the trigger condition and will continue execution ignoring the trigger. It will be observed that each executing process has its own trigger condition table and therefore resetting a flag bit in one table has no effect on trigger execution in a different executing process. In other words a trigger is only disabled within a particular defined scope. Preferably this scope is the context of an executing process although alternatives are disclosed herein.

It should be understood that this technique does not necessarily prevent all unnecessary firings of a trigger but is intended to reduce the instances of unnecessary trigger firing and thereby improve performance without imposing any substantial overhead burden. A simple example will illustrate both the effectiveness and limitations of this technique. Suppose for a given database it is desirable to restrict editing of one or more specially protected fields of a table to a privileged class of users. Typically a database management application will not support such a specific pre defined condition for firing a trigger and the developer of the trigger must therefore use as a firing condition some generic code path which alters a field in a database table. This means that a sometimes the trigger will be fired when data other than the specially protected field is being altered in which case the trigger does nothing and b sometimes the trigger will be fired when the specially protected field is being altered by a user of the privileged class in which case again the trigger does nothing. Only if a protected field is being altered by someone not of the privileged class will the trigger take some action as by generating an error message and preventing alteration of the field.

The exemplary trigger can be improved to reduce its execution overhead in accordance with the preferred embodiment by returning a special return code if the trigger determines that the user which invoked it is of the privileged class. The effect of returning the special return code is that the trigger having been fired once and determined that the user has the required authority to alter the protected database field need no longer fire again for that particular process since the user and the user s authority will be the same. Thus the same process can invoke many different database functions and alter many records and many fields both protected and not protected of the database without the need to fire the trigger each time. This can significantly reduce the instances of trigger firing.

On the other hand if the trigger determines that the user lacks authority to alter the specially protected field but that the field being altered is other than a specially protected field the trigger still will not prevent alteration but typically will not return a special return code. In this case it may still be necessary to fire the trigger each time because the user may later attempt to alter one of the protected fields. However there could be other things the trigger could examine to determine whether it is necessary to fire again. For example depending on the execution environment if the trigger can determine that the application or the interface being used is unable to access the specially protected field it may be safe to return a special return code and disable further firing of the trigger.

After initiation the process executes represented as block . Block represents at a high level any arbitrary degree of process complexity and could involve a single or multiple threads of execution multiple called procedures to an arbitrary stack depth and so forth. Process execution may involve a user application such as user applications or may be a server process in communication with a client over a network which responds to client requests or some other process. Process execution at block could also involve comparatively little processing and the database management application could be the first application invoked by the process.

At some point the executing process invokes a function of database management application block . The database management application may be invoked through an application programming interface API intended to allow other applications to access the database or may be invoked as a stand alone application program itself. When a database management application function is invoked database management application determines whether a trigger condition table has been generated for the executing process. If not the N branch from block the database management application creates a trigger condition table in the state data area of the executing process and initializes it with initial flag bit values block . This newly created trigger condition table is initially a copy of master trigger condition table although it may later be modified.

The database management function that was invoked then continues to execute to completion. This is represented in as block and is shown and described in greater detail in .

Referring to the database function is performed by executing code within database management system and or external procedures called by it represented as blocks and . Any of blocks and could represent any arbitrary degree of process complexity and could involve a single or multiple threads of execution multiple called procedures to an arbitrary stack depth and so forth.

At some point a code path is taken which causes a trigger check to be encountered represented as blocks and . A trigger check is preferably one or more in line instructions which access a corresponding flag bit of the trigger condition table for the executing process and branch to invoke the trigger engine if the flag is set the Y branch from blocks and . Each trigger check within the code maps to a corresponding row of the trigger condition table the flag bit in the all triggers column of the corresponding row being checked. Depending on the instruction set architecture it may be possible to accomplish the trigger check in a single instruction although more typically several instructions will be required. However since the instructions are preferably in line the check itself requires very little resource so long as the N branch is taken from blocks or .

The invoked database function continues execution until done represented by block . Trigger checks may be performed an arbitrary number of times although three trigger checks are depicted in for illustrative purposes many execution instances of database functions incur a far greater number of trigger checks.

If any trigger check is performed and the corresponding flag bit is set the Y branch from block or the executing database function invokes the database trigger engine to fire one or more triggers. This is represented at a high level as blocks and of and shown in greater detail in .

Referring to the trigger engine is called block at least one of the call parameters being the condition which caused the trigger engine to be invoked. Invoking the trigger engine generally involves some overhead. The trigger engine will generally be contained in a module separate from the function which called it although this is not necessarily the case. Upon being called the trigger engine accesses the row of trigger condition table corresponding to the condition which caused it to be invoked block . An index variable N is initialized to 1.

The trigger engine then examines each flag bit of the row in turn. If flag bit N i.e. the flag bit for the Nth column of the row is set the Y branch from block then the trigger corresponding to the Nth column Trigger N is fired block . Firing the trigger means that the trigger engine accesses the set of instructions of Trigger N and causes them to be performed. As explained previously these could be previously compiled processor executable instructions which are executed as a called procedure but are often a set of higher level language instructions which are interpreted or compiled at run time. In any case there is substantial overhead involved in firing the trigger even if very few instructions within the trigger need to be executed. Block represents firing and execution of the trigger according to any conventional technique or technique hereafter developed. Upon completion of execution of the trigger it returns with a return code to indicate status.

Upon completion of execution of the trigger trigger engine examines the return code block . If the return code indicates that subsequent firings of the trigger are to be disabled the Y branch from block the trigger engine resets all flag bits in column N of the trigger condition table to zero block . For each flag bit which is reset trigger engine also re determines the corresponding flag bit in the all triggers column . If the return code does not indicate that subsequent firings should be disabled the N branch from block then block is by passed and trigger condition table is left unchanged.

Resetting the flag bits in column N of trigger condition table at block has the effect of disabling further firing of the trigger in the context of the currently executing process. In the preferred embodiment all flag bits within column N are reset which means that Trigger N is not only prevented from firing again for the same condition but also for any other condition if multiple conditions have been specified for causing Trigger N to fire . It would alternatively be possible to disable only firing from the same condition i.e. the same code path but to enable firing from a different code path by resetting only the flag bit for the corresponding row and column. It would further be possible to provide multiple return codes in which one or more indicate that further firings of Trigger N are to be prevented for all code paths and one or more different return codes indicate that further firing of Trigger N is to be prevented only from the code path which caused it to fire.

The index variable is then incremented block and if more columns remain to be examined the Y branch from block the next flag bit of the same row is examined at block . When all flag bits in the row have been examined the N branch is taken from block and the trigger engine returns.

It will be observed that since a separate flag bit is maintained independently in the row for each trigger a single code path could cause multiple triggers to fire. Each trigger fires independently and provides its own return code and therefore one trigger can be disabled without affecting any of the other triggers.

Returning again to after completion of execution of the database function at block the process may continue executing represented as block e.g. by executing code outside database management application such as code within a user application . The process may invoke a database function again and may do so an arbitrary number of times as shown by the dashed line path back to block . If a database function is invoked multiple times it may be the same database function or a different database function.

At some point the process ends represented as block . When the process ends the corresponding process state data including its trigger condition table if any is de allocated and eventually overwritten with other data. Thus any changes made to the trigger condition table do not survive process termination and do not affect any other executing process.

Although a specific sequence of operations is illustrated in the flow diagrams and described in the accompanying text it will be appreciated that some operations could be performed in a different order that some operations need not be performed and that other operations may be performed instead consistent with the present invention.

In the preferred embodiment a trigger may be disabled in the scope of an executing process. However it would alternatively be possible to disable triggers in some other context. For example the scope of disabling a trigger could be the context of a single invocation of a database function represented in by blocks . In this case if the same process were to invoke the same or a different database function after the first function completed execution then a new trigger condition table would be allocated as a copy of master trigger condition table and any previously disabled trigger would again be enabled. A database trigger might also be disabled only within the scope of a single called procedure within database management application or within some other context. As will be appreciated by those of skill in the art any suitable scope could be implemented by placing the database trigger table in an appropriate location in the process stack or using other conventional devices.

As an additional alternative it would be possible to maintain multiple database trigger tables corresponding to different contexts. For example a process context trigger condition table as well as a trigger condition table limited to some called procedure could be maintained. A return code received from a trigger could indicate whether the trigger is to be disabled only within the scope of the executing procedure or in the scope of the executing process or not at all.

In the preferred embodiment database management application includes all necessary code to automatically maintain the master trigger condition table allocate trigger condition tables to executing processes fire triggers according to the data in the trigger condition tables and dynamically modify the trigger condition tables responsive to special return codes received from executed triggers. However trigger engine can only disable further trigger firing responsive to return codes generated by the triggers. The trigger developer must therefore include logic within the trigger which causes the appropriate return code to be generated. Typically the logic for detecting the underlying condition must be included in the trigger anyway e.g. to prevent the trigger from performing an action. The developer must include one or more instructions in the trigger which will cause the appropriate return code to be generated if this underlying condition is detected. Development of a trigger as with development of any computer instructions is generally a manual process although certain editing tools not shown may be provided for that purpose.

In general the routines executed to implement the illustrated embodiments of the invention whether implemented as part of an operating system or a specific application program object module or sequence of instructions including a module within a special device such as a service processor are referred to herein as programs or control programs . The programs typically comprise instructions which when read and executed by one or more processors in the devices or systems in a computer system consistent with the invention cause those devices or systems to perform the steps necessary to execute steps or generate elements embodying the various aspects of the present invention. Moreover while the invention has and hereinafter will be described in the context of fully functioning computer systems the various embodiments of the invention are capable of being distributed as a program product embodied in non transitory computer readable media and the invention applies equally regardless of the form of distribution. Examples of non transitory computer readable media include but are not limited to volatile and non volatile memory devices floppy disks hard disk drives compact disk read only memories CD ROM s digital versatile disks DVD s and magnetic tape it being understood that these examples are not exhaustive. Examples of non transitory computer readable media are illustrated in as system memory and data storage devices .

Unless inconsistent with the invention or otherwise qualified herein computer program code for carrying out operations of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as the JAVA programming language SMALLTALK programming language C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

The present invention is described herein with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a non transitory computer readable medium that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the non transitory computer readable medium produce an article of manufacture including instruction means which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowcharts and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

Although a specific embodiment of the invention has been disclosed along with certain alternatives it will be recognized by those skilled in the art that additional variations in form and detail may be made within the scope of the following claims 

