---

title: Shared data collections
abstract: A data sharing mechanism may allow programs to share access to data collections. The mechanisms that implement the sharing may allow programs written in any language to read and write a shared collection. The mechanisms may make the shared nature of the collection relatively transparent to the program and to the programmer, by allowing a program to operate on the data more or less as if it were purely local data. The sharing of collections may be managed by a shared object runtime on each machine on which a collection is used, and by a shared object server. The shared object server maintains the true state of the collection, and deterministically resolves collections when programs operate on the same collection without knowledge of each other's operations. The mechanisms by which collections are shared may be implemented so as to be agnostic as to the kind of data in the collection.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09104715&OS=09104715&RS=09104715
owner: Microsoft Technology Licensing, LLC
number: 09104715
owner_city: Redmond
owner_country: US
publication_date: 20100623
---
A collection is a group of data items that are to be operated on together. Some examples of collections include lists arrays sets bags and various other groupings of data. In the early days of programming programs were typically monolithic entities that did not interoperate with each other. Thus programs were able to manage collections internally in whatever manner the programmer chose. In modern programming however it has become a more prevalent practice for different instances of the same program or different programs to interoperate with each other by manipulating a shared set of data.

While it is possible for programs to implement their own mechanisms for sharing data doing so is generally cumbersome for the programmer. The programmer may have to implement the sharing mechanism as a tightly integrated part of the program. Even if the programmer can obtain the code for an existing sharing mechanism the mechanism is often specific to the nature of the program and to the type of data that is being shared. And when other programs want to share data with an existing program those programs have to be implemented in such a way such that the same sharing mechanism is used.

While allowing programs to share data presents various issues the sharing of collections presents additional issues. For many types of collections the current state of the collection is defined not only by the contents of the collection but also by the order in which those contents appear. For example the array 1 2 3 4 5 is different from the array 2 3 1 5 4. Even though those two arrays contain the same underlying elements the numbers one through five the order is different and thus these two arrays have different states. Maintaining the state of a collection particularly the ordering presents certain challenges when the state of a collection may be changed by several programs.

The notion of a shared collection may be implemented in a way that makes the sharing mechanism transparent to the programmer. Moreover the mechanism that implements shared collection may provide data convergence for a collection when the collection is being operated on by several different entities.

In one example a shared object server manages the sharing of collections by maintaining the true state of the collection at any given time. A program that obtains access to a collection may connect to a shared object runtime on the machine on which the program is running. The program that accesses the shared collection registers the collection as a shared collection and this registration may be communicated by the runtime to the shared object server. Other programs that want access to the collection also register the collection as a shared collection. The registrations likewise are communicated by the runtime to the shared object server. Additionally programs can subscribe for change notifications on the collection where subscription requests are handled by the runtime. Each program maintains a local copy of the collection. When the state of a collection is changed in any way the runtime on the machine on which the change occurs communicates the change to the shared object server. The shared object server updates the true state of the collection and communicates the change to all programs that have registered that collection through the shared object runtimes on the machines on which the subscribing programs are running. Each of these programs then updates its local copy of the collection in accordance with state changes communicated by the server. In the event that concurrent changes have occurred on the collection the shared object server resolves any collisions among changes and deterministically arrives at the true state of the collection.

In another example shared objects are managed in a peer to peer fashion rather than in a client server fashion. In a peer to peer implementation each subscriber to the shared collection may communicate changes to other subscribers. Then the runtimes on the machines on which the subscribers run may change their local copies while deterministically resolving any collisions.

Collections may be implemented in nearly any programming language e.g. C C Java Visual Basic etc. . Since the notion of a shared collection can be implemented in a wide variety of programming models programs written in different language may operate on the same shared collection. Moreover a programmer may write a program that operates on a shared collection in the same manner as the program would operate on a purely local collection. Thus programs may be able to operate on shared collections without having to recognize the shared nature of the collection in any manner other than by issuing instructions to register a new collection or to subscribe for changes to an existing collection. In this way the sharing of collections effectively is made transparent to the program and to the programmer. Additionally the sharing mechanism may be agnostic to the type of data in the collection thereby allowing collections of any type of data to be shared.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In modern computing programs often interoperate with each other by sharing access to the same underlying data. When programs share data the programs are often implemented in a way that is cognizant of the fact that data is being shared. That is the program generally has to contain implementations of the mechanisms that share data with other programs or with other instances of the same program. Mechanisms for sharing are often specific to both the nature of the data being shared and to the programmer s design choices. Thus when two programs want to share data their respective programmers normally have to agree upon and implement a particular sharing mechanism. There are certain generalized mechanisms that allow a limited form of data sharing but are not well suited for certain situations.

While sharing of any kind of data presents various implementation issues additional issues are presented when the data to be shared is a collection. A collection is a group of data items that may be operated on together. Some examples of collections include lists arrays sets bags and various other groupings of data. Some types of collections are ordered. That is the current state of an order collection is defined not merely by the contents of the collection but also by the order in which those contents appear. E.g. 1 2 3 4 5 is a collection of data that contains the integers one through five inclusive. If the collection is ordered then 1 2 3 4 5 is a different state from 2 3 1 5 4 because these two states have different orders even though they both contain the same items.

When any type of data is shared among programs that are running at the same time it is possible that two modifications of the data will collide e.g. one program might try to modify the data at the same time that another program is trying to delete that data. However an additional complication arises when such a collision occurs and the data that is being shared is part of a collection. One program might request to insert an item after the second item in the collection. Another program might request to delete the second item thereby making the inserted item the second item. In order to process these changes and to arrive at a true state for the collection one has to determine which item in the original collection is now second. Since each program may not be aware that the other program is operating on the same collection both programs may refer to the second item in a collection while having different understandings of which item in the collection is actually second in order.

The field of operational transformation is concerned with mechanisms to allow deterministic ordering of data in computing. Some of these mechanisms may be used to resolve collisions among files that are being operated on at the same time e.g. how to determine what edits have occurred in a text file that is being edited concurrently by two users. However these types of techniques generally have not been applied to the type of generalized sharing of collections that is described herein.

The subject matter described herein provides mechanisms to share data collections. The techniques described herein may be used to provide a generalized collection sharing mechanism that allows several programs and or several instances of the same program to share access to collections. These techniques may allow the programs to be implemented in different programming languages. The techniques may allow a collection of ordered data to be operated on concurrently by plural programs and or program instances in such a way that the collection deterministically arrives at a particular state that can be propagated to all programs that are using the collection. Moreover the techniques described herein may allow programmers to write programs that operate on shared collections in more or less the same way that programs would operate on purely local collections. Additionally the sharing mechanism may be made agnostic to the underlying type of data in the collection thereby allowing the same generalized sharing mechanism to be used for any appropriate kind of data. In other words the various acts described herein may be performed without regard to the contents of the data items in a collection and without regard to the structure of the contents of those items.

Programs that share data may run on a single machine or may run on several machines connected through a network. In order to facilitate the sharing of data each machine on which a program runs may have a shared object runtime. The shared object runtime may help to manage the sharing and synchronization of shared data objects including shared collections. In one example a shared object server maintains the true state of a shared collection. When a change is made to a shared collection on a machine the runtime on that machine notifies the shared object server that of the change. The server may change the true state of the collection in response to the local change. If two programs make concurrent changes to the collection the shared object server may resolve the changes in order to arrive at a true state which to the extent possible may reflect the state of the collection that both of the programs intended to effect. Thus if two different programs each change the same collection without knowledge of the other s change the server may execute one of these changes to create a new state of the collection and then may transform the other change to reflect to the extent possible the change that the other program would have made if it had known the new state of the collection at the time that it made the change. The server notifies the runtimes on the various machines of the change or the transformed change if applicable and programs that have subscribed to the collection update their local copies of the collection in accordance with the change propagated by the server. In another example collection sharing is implemented in a peer to peer architecture in which each program that subscribes to a shared collection notifies others of changes that the program has made and the other subscribers or runtime components on the machines on which those subscribers are running synchronize their local copies to the changes without the aid of a server.

When a program creates a collection the program may issue an instruction to register the collection as a shared collection. This instruction may be received by the runtime on the machine on which the program is running and the runtime may report the registration to the shared object server. The shared object server then receives a copy of the collection which represents the initial state of the collection. From that point the program that created the collection may operate on the collection in much the same manner as it would if the collection were purely local since the runtime manages the reporting of changes to the shared object server or to other subscribers in a peer to peer implementation and the synchronization of state changes received from the shared object server.

If a program wants to use a shared collection that has been created by another program the program issues an instruction to register the collection. That instruction may be received by the runtime and may be transmitted to the shared object server. The shared object server then knows to notify the runtime on the machine on which the subscribing program is running of any changes to the state of the collection. When a program subscribes to a collection it may receive a copy of the current true state of the collection which it may then store as a local collection. The subscribing program may then operate on the shared collection in much the same manner as if the collection were local. In this way the sharing of collections effectively is made transparent to both the program that creates and registers the collection and to programs that subscribe to the collection. As noted above the system may be agnostic as to the nature of the data in the collection so the sharing mechanism may work with collections that contain any kind of underlying data.

Shared collection may have a name that allows shared collection to be identified by programs that share a common namespace. As an alternative to name or in addition to name shared collection may also have an identifier which distinguishes shared collection from other shared collections. Identifier may be applied for example to collections to which a name has not yet been assigned so that these collections can be identified by a system before a friendly name has been assigned to the collection.

Shared collection may have a plurality of data items. In the example of four data items and are shown although a collection could have any number of data items. Each data item may contain any type of data. Some examples of data that may be stored in a shared collection are more particularly described below in connection with . However as a general example some types of data that could be stored in a collection are elemental data types such as numbers or words or more complex programmer defined data types such as structures that represent tasks on a to do list or elements of a user interface. The mechanisms described herein may be agnostic as to the type of data so that the individual data items in a collection may be anything ranging from elemental data types to complex user defined data types with elaborate schemata.

In the example of shared collection is an ordered collection. As described above an ordered collection is one in which the state of the collection is defined not only by the data items in the collection but also by an order on those data items. Insertion or removal of a data item changes the state of an ordered collection but so does a change in position among two existing data items. Thus each data item in shared collection has an ordinal position. Ordinal positions and correspond to data items and respectively. Thus data item is in the first position data item is in the second position and so on. If one were to change any of the items ordinal numbers this change would result in a change in the state of shared collection even if there were no change to the items themselves.

Example operations that may be performed on shared collection include switch operation and delete operation . Switch operation exchanges the ordinal position of two or more items in a collection and delete operation removes one of the items in a collection. Also one could modify a collection by performing an insert operation to add a new data item to the collection. We shall later refer to these operations in the discussion below.

Machine may store data and one type of data that is stored on machine is local copy of shared collection . In the example of shared collection is created by program . At the time that the collection is created the collection may be local and private to program . However program may want to register the collection for sharing in order to allow other programs including possibly programs that run on other machines to share access to collection . Thus program issues registration instruction . Registration instruction may be issued through whatever programming language program is written in and may be received by shared object runtime . For example shared object runtime may provide an Application Programming Interface API that allows program to issue registration instructions and subscription requests and other types of instructions to shared object runtime .

Upon receiving registration instruction shared object runtime may register shared collection with shared object server . Shared object server is a server that maintains the true state of shared data objects such as shared collection and also acts as a clearinghouse for changes to shared objects. That is shared object server receives notice when shared data changes on a machine and also propagates to other machines changes to the state of that shared data. When shared collection is registered with shared object server shared object runtime may provide a copy of shared collection . Once collection has been registered for sharing shared object server maintains the true state of collection as shown in the box marked true state inside box that represents shared object server in . It is noted that throughout the description herein we may refer to a program or subscriber sending as sending registration or subscription requests to a server or to other subscribers. The act of a program sending these types of requests includes the case where the program communicates the request to a runtime and the runtime communicates the request to the server or to the other subscribers or runtimes. Likewise as will be described below subscribers may communicate state changes to a server or to other subscribers the act of a subscriber s communicating state changes includes the case where the runtime on the subscriber s machine performs the communication. 

When shared collection is registered for sharing programs other than program may access that collection by subscribing to the collection. In order to subscribe to a collection the program may submit a subscription request . Some collections may be subject to access control restrictions specified by their creators. Such access control restrictions may limit the set of programs and or users and or machines that may access a shared collection. However assuming that there are no access restrictions on shared collection or that there are access restrictions but that those seeking access to shared collection have permission to access the collection then subscribing to shared collection allows the subscriber to read and or modify that collection.

Subscription requests may come from any program on any machine. For example program may subscribe to shared collection by submitting a subscription request through shared object runtime . It is noted that program is on the same machine as is the creator i.e. program of shared collection . However a subscribing program could be on a different machine. For example program on machine also subscribes to shared collection by submitting a subscription request . The subscription request from program is submitted through shared object runtime which is the runtime for machine . Each machine may have its own instance of the shared object runtime. Additionally subscription requests for shared collection may come from programs executing on machine or on any other machine.

When a program has subscribed to shared collection that program may receive a copy of the current true state of shared collection . For example program on machine receives a copy of shared collection which it may store on machine as indicated by instance of shared collection labeled local copy within the box of that represents machine . The subscribing program may then read and write the local copy as if it were a purely local collection. The instance of the shared object runtime on the machine on which the program runs e.g. shared object runtime in the case of program may monitor the local copy of shared collection to determine whether the program has made changes to the shared collection that are to be reported to the shared object server .

When any subscriber to shared collection performs an operation that makes a change to its local copy of shared collection the shared object runtime on that subscriber s machine reports the operation to shared object server . Shared object server then updates the current true state of shared collection and notifies subscribers to the object including the creator of the object of the state change.

Shared object server may contain a synchronization component which facilitates the collection and propagation of state information among subscribers to shared collection . The way in which synchronization component operates may be implementation dependent. In one example synchronization component maintains a master copy of shared collection in its true state and simply propagates a new copy of shared collection whenever the state of that collection changes. In another example synchronization component maintains a list of changes to shared collection relative to the current version and propagates those changes to the various clients. The runtime on each client is then able to calculate the true state of shared collection based on its local state and on the changes received from shared object server . Even if shared object server does not propagates a full copy of shared collection in response to every state change shared object server may determine how to resolve concurrent changes to shared collection so when a client side runtime receives notice of the change it can calculate the new state of shared collection from the old state. As described below synchronization component may transform changes as appropriate so that changes that a first subscriber made without knowledge of a second subscriber s concurrent changes can be sent to the first subscriber and can be applied in a way that makes sense and that results in all subscribers converging on the same state of shared collection .

One function performed by synchronization component may be to determine how to apply changes that were made to a collection by two clients where neither client had knowledge of the other s changes. This situation may arise if two clients make changes that involve the same item in a collection at about the same time so that each client makes changes before receiving notice of the other s changes. For example suppose that the first two items in a collection are alpha and beta. Two clients call them A and B both make changes to the collection at about the same time. A wants to add a new item gamma in the position after alpha and B wants to delete beta. So A performs the operation of adding a new item at ordinal position two and B performs the operation of deleting the item at ordinal position two. If A s operation is executed first then the final state after both operations is that alpha and beta occupy positions one and two respectively. If B s operation is executed first then the final state after both operations is that alpha and gamma occupy ordinal positions one and two respectively. Synchronization component may resolve this apparent conflict in the following way.

For the purpose of this example call the server S and the clients A and B. S A and B all start at state 0. A executes operation X and B executes operation Y. Since neither A nor B has any knowledge that another operation has been performed A and B each report the operation to S with state 0 that is A and B each report that they have performed an operation on the collection as that collection exists in state 0. Having performed one operation A and B now each increment their state to 1. One of these operations however will arrive first at S. Suppose for this example that X arrives first. Since operation X was executed at state 0 which matches the current state of S it is executed on S and sent to B without being transformed. Additionally an acknowledgement is sent to A. S is now at state 1. At this point B receives operation X from S. Since operation Y has not yet been acknowledged by S operation X is transformed against Y and then applied to the collection. B is now at state 2. When operation Y arrives at S that operation indicates that it was performed at state 0. Since 0 is no longer the current state of S S determines that B was unaware of operation X when it executed Y. Therefore operation Y is transformed against operation X and then sent to A. An acknowledgement is sent to B. S is now at state 2. At this point A receives the transformed version of operation Y. Since A has no outstanding operations it applies the transformed Y without transforming it further. I.e. the transformed Y indicates that it is being performed against state 1. Since A is already at state 1 there is no basis to transform Y any further. A is now at state 2. Additionally the copies of the collection at both A and B now show the same data in the same order.

In the example of machines and participate in the sharing of collection as they do in . For example each machine may have one or more programs that are subscribers to shared collection where the creator of the shared collection is included in the concept of a subscriber . Each machine has an instance of a shared object runtime i.e. shared object runtimes and operate on machines and respectively. In the peer to peer implementation the shared object runtimes may communicate with each other directly rather than communicating with a server. Moreover the shared object runtimes may be responsible for transforming incoming changes rather than having those changes performed by the server. Thus the current state of collection can be known deterministically as long as the different runtimes implement the same algorithm for resolving conflicting changes to a collection.

If shared collection is changed for example on machine then the shared object runtime on machine sends out a notice of state change to the shared object runtimes and on machines and . Each of the shared object runtimes applies state change to the current state of shared collection in order to arrive at the new state of collection . In the event that two different state changes come from two different machines concurrently the shared object runtimes may apply a conflict resolution algorithm e.g. the algorithm described above in connection with synchronization component to determine what state changes are to be applied. As noted above the algorithm may be made deterministic so that any two runtimes that receive the same set of conflicting changes can resolve the conflict in the same way thereby leading the collection to be changed to the same state on the various different machines.

It is noted that in the examples of the collections shown may involve complex data types. For example the data items in are tasks which may contain fields for a summary a long description a due date a reminder date etc. . And the data items in may be application handles which may contain fields such as the name of the application its location on disk runtime parameters etc. . In other words these examples show that any type of data may be used in a shared collection and the collection sharing mechanisms can handle various types of data in the same manner without regard to the nature or structure of the data.

At a collection is created. For example a program may create the collection which it may do by using mechanisms that would normally be used to create a local collection. The collection may be any type of collection e.g. list array etc. At the collection may be registered for sharing. For example the program that creates the collection may issue an instruction which may be received by the shared object runtime on the machine on which the program is running. In one example the runtime exposes an API that allows the program to issue a registration instruction although the registration instruction could be issued in other ways.

After the collection is registered for sharing subscription requests for the collection may be received at . For example other programs that share the same name space as the program that created the collection may issue subscription requests for that collection. These subscription requests may be issued to the shared object runtime on the machine on which the subscribing program is running. In one example subscription requests may be issued through an API that the runtime exposes. For the purposes of the subject matter herein the creator is considered to be one of the subscribers. Even though the creator issues a registration request rather than a subscription request the creator of the shared object is a subscriber in the sense that the subscribers are those programs that can access the collection. Subscribers may receive the current state of the collection at and they may store local copies of the collection.

At some point a subscriber makes a change to the collection at . Example changes include insertion deletion and move . Insertion adds a new item to the collection at a particular place in the collection s order. Deletion removes an existing item from the collection. Move reorders changes the order among two or more items in the collection.

When the change is detected by the shared object runtime on the subscriber s machine the shared object runtime notifies the applicable entity ies of the change at and these changes are received by those entity ies at . Which entities are the applicable entities may depend on implementation. As noted above there are for example both client server and peer to peer implementations of the subject matter described herein. In the client server implementation the runtime that detects the change may notify the shared object server that manages the true state of the collection. In a peer to peer implementation each runtime notifies the other runtimes directly.

When the changes to the collection are received any conflicting changes e.g. changes that indicate that two clients have performed operations on the same state of the collection may be resolved in a deterministic manner at . For example if two subscribers have made changes that affect the second item in the collection e.g. one entity switches the positions of the first and second entities and another entity concurrently deletes the second entity these conflicting changes may be resolved in order to arrive at the true state of the collection e.g. using the algorithm described above in connection with synchronization component shown in . The way in which the conflicts are resolved may or may not effectuate the intent of the subscribers that made the changes but the resulting state can be determined unambiguously.

In a client server implementation the resolved changes may be sent to the subscribers at . In a peer to peer implementation the subscribers and or the runtimes on the subscribers machines receive the change information from the other subscribers and or runtimes and resolve conflicts themselves without the aid of a server. A deterministic conflict resolution process allows each client to resolve the change in the same manner so that the various subscribers may converge on the same result for the true state of the collection. Again the resulting state can be resolved unambiguously but the resulting state may or may not effectuate the intent of the subscribers that made the changes. 

When any existing conflicts to changes have been resolved and when the result of that conflict resolution has been communicated from the server to the subscribers in the case of a client server implementation changes to the local copies of the collection may be made at in order to keep those local copies in line with the true state. The subscribers may then continue to read and write the collection.

Computer includes one or more processors and one or more data remembrance components . Processor s are typically microprocessors such as those found in a personal desktop or laptop computer a server a handheld computer or another kind of computing device. Data remembrance component s are components that are capable of storing data for either the short or long term. Examples of data remembrance component s include hard disks removable disks including optical and magnetic disks volatile and non volatile random access memory RAM read only memory ROM flash memory magnetic tape etc. Data remembrance component s are examples of computer readable storage media. Computer may comprise or be associated with display which may be a cathode ray tube CRT monitor a liquid crystal display LCD monitor or any other type of monitor.

Software may be stored in the data remembrance component s and may execute on the one or more processor s . An example of such software is collection sharing software which may implement some or all of the functionality described above in connection with although any type of software could be used. Software may be implemented for example through one or more components which may be components in a distributed system separate files separate functions separate objects separate lines of code etc. A computer e.g. personal computer server computer handheld computer etc. in which a program is stored on hard disk loaded into RAM and executed on the computer s processor s typifies the scenario depicted in although the subject matter described herein is not limited to this example.

The subject matter described herein can be implemented as software that is stored in one or more of the data remembrance component s and that executes on one or more of the processor s . As another example the subject matter can be implemented as instructions that are stored on one or more computer readable storage media. Tangible media such as an optical disks or magnetic disks are examples of storage media. The instructions may exist on non transitory media. Such instructions when executed by a computer or other machine may cause the computer or other machine to perform one or more acts of a method. The instructions to perform the acts could be stored on one medium or could be spread out across plural media so that the instructions might appear collectively on the one or more computer readable storage media regardless of whether all of the instructions happen to be on the same medium.

Additionally any acts described herein whether or not shown in a diagram may be performed by a processor e.g. one or more of processors as part of a method. Thus if the acts A B and C are described herein then a method may be performed that comprises the acts of A B and C. Moreover if the acts of A B and C are described herein then a method may be performed that comprises using a processor to perform the acts of A B and C.

In one example environment computer may be communicatively connected to one or more other devices through network . Computer which may be similar in structure to computer is an example of a device that can be connected to computer although other types of devices may also be so connected.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

