---

title: Software extensions to a high level description language simulator to provide infrastructure for analog, mixed-signal, RF modeling and verification
abstract: An extension to a simulator () that allows the user to specify real numbers, voltages, and currents () on ports of an electrical net is presented. The computer using the analog wire functionality routines (), the routines for determining nets (), the net manager (), and the pin manager () resolves unspecified values on said electrical nets. The user may specify at least one value on said port and may specify whether said port is driven. The extension includes additional math functions ().
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08666720&OS=08666720&RS=08666720
owner: 
number: 08666720
owner_city: 
owner_country: 
publication_date: 20100802
---
This application claims the priority of U.S. Provisional Patent Application No. 61 231 281 filed on Aug. 4 2009 by the present inventors which is incorporated by reference herein.

This invention extends a high level description language so that single or multi channeled real values electrical signals or a combination can be passed on model ports. It also adds other capabilities to facilitate analog mixed signal RF modeling such as extending the language to provide math functions suitable for writing these models.

This invention extends a high level description language so that single or multi channeled real values electrical signals or a combination may be passed on model ports. In this patent application this capability is referred to as analog wires. The term dgWires is synonymous with analog wires. The invention also adds other capabilities to facilitate analog mixed signal radio frequency RF modeling such as extending the language to provide math functions suitable for writing these models. The invention will typically be used by an engineer to assist in the design of an electrical system such as an integrated circuit or system of integrated circuits and electrical components on a printed circuit board.

At the core of an analog mixed signal or RF design are blocks or subcomponents of the design that communicate by transmitting information on wires from one block to another. Many languages are available for modeling and writing regression tests. The two languages most suited to modeling analog are Verilog AMS and VHDL AMS. Simulators that can handle these languages require both a digital event driven simulation engine and an analog or circuit ordinary differential equation solver engine. The latter is generally known as a SPICE engine or analog simulator. A SPICE engine requires solving a network of simultaneous equations. Simulators that have both an event driven simulation engine and SPICE engine or generally known as AMS simulators. There are two primary disadvantages when using an AMS simulator over only a pure digital event driven simulator. The first disadvantage is simulation speed. A SPICE engine typically runs slower than a digital event driven simulator. As a result when simulating a design the combination of the two simulators runs slower than the digital event driven simulator. The second disadvantage is cost. Because both simulation technologies are required for an AMS simulator vendors of simulators charge a premium for the AMS simulator. Because of these disadvantages analog design and verification engineers have attempted to only apply digital event driven simulators to model analog mixed signal and RF designs. However because the digital event driven simulators were not intended to model analog designs there are limitations to what may be done. Specifically one of the most prevalent modeling languages for digital design is Verilog. A key stumbling block to Verilog is that continuous valued signals e.g. real numbers cannot be passed from a design block module to another. U.S. Pat. No. 7 260 792 to Chandrashekar L. Chetput Ramesh S. Mayiladuthurai and Prasenjit Biswas 2007 and U.S. Pat. No. 7 251 795 to Prasenjit Biswas Ramesh S. Mayiladuthurai Chandrashekar L. Chetput and Abhijeet Kolpekwar 2007 describe methods for passing signals in a mixed language mixed signal design where both a digital event driven simulation engine and a SPICE engine is required.

To work around this problem in Verilog engineers have attempted to develop methods by which to pass real numbers between blocks. Initial attempts focused on staying within the Verilog language. They include converting a real number to a 64 bit bus using the realtobits and bitstoreal command. This has the disadvantage that it changes the interface of the block from 1 wire to 64 wires. This is usually unacceptable. Another method is to use out of module references to real variables inside the block. This has the disadvantage that one has to know the name of the sender block in order to be able to access the information that is being transmitted. The name of the block is usually not known by adjacent blocks and thus this is also not workable as a solution. Another method is to convert the 64 bits into a serial stream of data transmitted across the port. This has the disadvantage in that it may slow down the simulation and there is coding overhead to set up the transmitters and receivers to code and decode the data. Similar to this is to use pulse width modulation techniques to indicate the value of the real variable. This again has a disadvantage of requiring a coder and decoder. None of these solutions have been satisfactory as designers and verification engineers sought other solutions. The next set of solutions look toward different languages. VHDL allows the passing of real variables between blocks. The disadvantage of using VHDL is that Verilog is a much more popular language. As a result it is difficult to find engineers who have the knowledge to program in VHDL and companies are reluctant to convert all of their models to VHDL fearing that their models will be forever incompatible with the more popular Verilog language. Another choice is to use Verilog AMS but not write models in such a way that use the SPICE simulator but take advantage of a wreal port type which is a wire which carries a real value. This still has the cost disadvantage. The wreal port type also does not have all of the capabilities required for analog modeling. Finally a newer language is SystemVerilog which allows for real valued ports. The disadvantage here is that it is a newer language and so fewer engineers know how to use it but more significantly at present it is not compatible with either of the AMS languages as there are no AMS extensions to SystemVerilog. The significance of this limitation is apparent when it comes time to verify that an analog model which is generally manually generated matches the corresponding circuit. The model has to be validated by a regression test that may simulate and compare against the transistor level implementation. Thus the language used by the regression test has to be compatible with the modeling language. The SystemVerilog also does not have all of the capabilities required for analog modeling.

Besides passing a single real value between one block to another there are other capabilities required for analog modeling. These requirements include the need to pass more than one real number across a signal a wire. Another capability is the need to turn on and off the pin or port on the block to support analog buses. There is a need to show the state of the connecting wire whether or not there is contention or whether or not there is a signal driving the wire. Finally there is the need to represent some electrical sources such as voltage and current sources. It is very common to need to sum current sources or check voltage source values. Seeing the loading effects are also important. There are efficiency concerns in implementing any solution that provides this capability as simulation speed is one of the reasons for using a digital event driven language. Finally when adding this capability they have to be added in such a way that they are compatible with the key commercial simulators that designers and verification engineers are using. Often a company will use more than one. Thus models that are created must work in all of them and behave the same. It may also be the case that these event driven models need to be connected to a model written in Verilog AMS. One feature of the Verilog AMS language is that connect modules may be written to connect electrical signals from the Verilog AMS languages to logic signals in Verilog. For these analog wires a requirement is that real values may be connected to Verilog AMS using a connect module so that analog signals may pass from an event driven model to an analog simulator.

To support analog modeling other capabilities are required the Verilog language is limited in the math function it provides. Extensions need to be provided for these and any capability added to the language needs to include some debugging aids to help debug issues as the designers and verification engineers write the models.

Having exhausted all of the standard languages an alternative is to extend the language to provide the capabilities required. In US Patent Application Publication 2002 0049576 by Steven J. Meyer published 2002 a system is described to extend the capabilities of an event driven simulator however an analog simulator is still required. Functional Verification in the Presence of Linear Analog Circuits by Thomas J. Sheffler presented at the Design and Verification Conference in 2008 and Design of a Switch Level Analog Model for Verilog by Thomas J. Sheffler presented at the IEEE International Behavioral Modeling and Simulation Conference in 2008 also describe extensions to an event driven simulator to facilitate analog modeling. These extensions also require that a simultaneous set of equations be solved. Finally Sending Analog Values Along Digital Wires by Chris S Jones Jeff McNeal and Ross Segelken presented at the Design and Verification Conference in 2007 describes a Verilog extension to pass analog values between Verilog models but in this solution important capabilities such as the ability to indicate whether or not a port is driven are not provided.

This invention gives the capabilities required to model analog mixed signal and RF designs while simulating a design at the higher speeds and lower cost of an event driven simulator when compared to an AMS simulator. This invention also eliminates the disadvantages when staying within the Verilog language while allowing the user to continue to use the more widely known Verilog language. Finally additional user knowledge is typically required when using the SPICE simulator within the AMS simulator. Since the SPICE simulator is not present this knowledge is not required and thus makes analog circuit modeling accessible to a greater number of engineers.

In accordance with one embodiment this invention provides a method for simulating a design of specifying at least one real value on at least one port of a network in at least one model of a design specifying whether the port is driven resolving at least one unspecified value in at least one model and utilizing an extension to an event driven simulator to enable this capability. The ports may be configured to be electrical. The electrical ports may be either current or voltage sources. On any port there may be a plurality of channels. Each channel can be individually configured to take a real number to be a voltage source or be a current source.

The software extensions to a high level description language simulator to provide the infrastructure for analog mixed signal RF modeling and verification are implemented by extending an event driven simulator. The components of one embodiment that make up this extension is shown in . The components are pin manager routines net manager routines routines for determining nets routines to provide the analog wire functionality general math routines routines for real variable assignments analog wire specific interface to the simulator and the general interface to the simulator . In this embodiment the extension is in the form of a library that is linked into a simulator at run time utilizing the VPI and PLI 1.0 application programming interfaces to a Verilog simulator.

The pin manager shown in manages all pin specific information. The pin manager has data specific to the pin data specific to each of the channels pin creation routines pin deletion routines routines to set and get the value of pins and channels and routines to query information about the pins and channels . The pin data includes the name of the pin the list of channels on the pin the drive state of the pin the net to which the pin is attached to what the digital port has been forced and some housekeeping data. The drive state refers to whether or not the pin is driving or not. The force state may be a binary value of 1 0 X or Z . The channel data includes the value to which that pin and channel are set the drive state for that particular channel the drive strength of the channel and a list of properties associated with that channel. The value of the pin and channel include a numeric value a voltage value and an electrical current value. The numeric value may be an integer real number or equivalent representation that can be translated into an integer or real number. The drive state includes whether or not the channel is off or on. The strength setting includes a value of resistance for a voltage source and a conductance for a current source. The list of properties includes the channel type. The available channel types includes driving a numeric value modeling a voltage source and modeling a current source.

The net manager shown in manages all net specific information. The net manager has data specific to the net state data specific to the channel on the net net creation routines net deletion routines routines to add and remove pins from a net and routines to access the channel state . The net data includes the name of the net a list of pins on the net a flag indicating whether or not the net is associated with a port on a connect module a list of channel states to what the digital net has been forced and some housekeeping data. The channel state data includes specific state information for that channel information on the number of drivers driving the channel the resolved value of the channel and electrical information. The state information includes topological data on the net such as whether or not all of the pins on the net are electrical and whether or not the net is under contention. The resolved value may include being a numeric value or a voltage. The electrical information may include the number of ideal voltage sources on the net the number of ideal current sources on the net the total conductance on the net the sum of the voltages sources divided by resistance the sum of the current sources and the sum of the Thevinin equivalent current sources.

The routines for real variable assignments shown in handle the situation where the user of the library wants to assign a real variable to track one of the values that may be set or get on the analog wire. These routines for real variable assignments include routines to create the assignment routines to call the get and set routines found in the analog functionality routines routines to register callbacks to the simulator and routines to update the real variables tracking the values .

The routines for determining the nets shown in are used to discern what the complete net of the ports given a port on that net. The main routine is the traverse net routine . Components used by the traverse net routine include the traverse net up routine the traverse net down routines the net top finder and the net name handlers . A utility routine found within the routines for determining nets is the environment variable handlers . The environment variable handlers allow the user to this extension to specify different options when handling net traversal and certain behavior of the analog wires.

The main analog wire functionality routines shown in handle the core functionality of the analog wires. These routines include user input parsers routines to set and get data in the pin and net managers connect module handlers port forcing routines current and voltage calculators and pin checking routines .

The analog wire specific interface routines shown in handle analog specific commands from the extensions within the high level description language written by the user and interfaces to the event driven simulator. The user interfaces include the interface to set port and channel values the interface to get port and channel values the interface to set properties on a port and channel the interface to get a port and channel current the interface to get a port and channel voltage the interface to set the strength of a port and channel the ability to assign real variables to a particular analog wire value the interfaces to get a Norton equivalent of the network connected to a port and channel and interfaces to get diagnostic information about the analog wires . The simulator interfaces include routines to register the user functions or commands with the simulator routines to initialize the extension to the simulator and routines to terminate the extension to the simulator .

Finally there are general interface routines to the simulator shown in . These include error handling routines software licensing routines string formatting utilities simulator host query routines general simulator interface utilities and data container utilities . The simulator host query routines include routines to determine the name of the event driven simulator. The general simulator interface utilities contain general purpose routines that may be used in applications beyond handling analog wires. Included in the data container utilities are access routines to lists and hash tables.

The math commands also have a set of math specific interface routines . They comprise of a set of math command interfaces a set of math computational routines and routines to register the math commands or functions with the simulator .

Finally simulator specific code has be implemented in various components of the extension so that the user employing the library sees a result that is as simulator independent as possible.

To enable the analog wire capability we extend the language with new commands. The first set of commands is to enable the ability to send single or multi channeled real values in a point to point fashion or on an analog bus. The ability to send multi channeled real values is necessary when doing a style of modeling known as baseband equivalent modeling or phase domain modeling. In this style multiple pieces of information need to be sent on a single wire simultaneously. Each piece of information is sent along a channel. With the analog wires there may be any number of channels on a wire.

In this implementation for the analog wires the language is extended with commands that begin with dgw. These first set of commands are the dgw set dgw get and dgw drive set commands. The dgw set command sets a value onto a wire. The value is an input into the dgw set command. The dgw get command retrieves the resolved value on that wire. The dgw drive set command sets a port to on or off to support an analog bus. Whether the port is on or off is an input to the dgw drive set command.

The dgw set commands takes three arguments a port on the module a name for the channel and the value to be set on that channel. The port may be an input output or bidirectional.

The channel may be any name that the engineer chooses. The value may be an integer real number or equivalent representation that can be translated into an integer or real number. The sender module in shows an example of how to use the dgw set command. In this example the output port is called out . Three uses of the dgw set command show how three different channel names are used frequency out high and out low . Each of these port and channel combinations are set to different values . The channels used are often application dependent. In RF typical other channels include phase and amplitude. 

To receive a signal an engineer would use the dgw get command. The dgw get command takes two arguments the name of the port and the name of the channel that is to be accessed. shows the module receiver example of how the engineer might use the dgw get command. In this example the input port is called in . The dgw get command is used in a display statement which receives the value on the wire connected to in and on channel frequency . To determine when the value on the port and channel have been changed the in port is monitored for changes. The dgw set command when executed changes the value on the four valued binary wire to indicate that a change was made. For example in the block configuration the out port binary value is changed. This change is propagated on wire and is received on the input port in . This change is seen by the model representation of in and the module will react accordingly.

Another common configuration of blocks is where the wire connecting blocks acts as an analog bus. This is shown . In this block topology there are two sending blocks sender one and sender two . Sender one has an output port out . Sender two also has an output port out . In this example there is one receiver which has one input port in . The two output ports and input port are connected by a wire . A Verilog representation of this topology shows the wire which connects the three blocks.

There are four possible configurations for the driving blocks both blocks could be driving values neither block could be driving values only block one could be driving or only block two could be driving. To enable all four configurations the dgw drive set command is provided. The dgw drive set command takes two arguments the name of the port and a value of 1 or 0 to indicate on and off respectively. An example of using the dgw drive set command is shown in . A description of sender one and sender two are shown. In this situation the example shows how sender one may be configured to send while sender two is configured not to send. The dgw drive set command example shows how the port out for module is set to 0 indicating that the out port of module is not to drive the wire w . The four valued binary number of the wire representing the bus provides an indication of the configuration. In the general case where there are many driving blocks on the wire if more than one wire is driving a binary x value is placed on the wire to indicate that there is contention on the bus. If no blocks are driving a binary z value is placed on the wire to indicate that the bus is undriven. If a 0 or 1 is placed on the wire this indicates normal operation or that only one block is driving the wire. As the analog wire value changes in normal operation the 0 and 1 values are toggled to 1 and 0 respectively.

Besides passing a value along a wire it is often necessary that an analog wire have electrical characteristics. This is shown in . Again this is an example where there is one sender connected to one receiver by a wire . In this example the sender has a voltage source and an output resistance in series with the voltage source connected to the output port. The receiver has a current source and conductance in parallel to the current source on the input. In general regardless of port direction the module may have either a voltage source or a current source. The resistance and conductance may take on any value including zero positive and negative numbers. The voltage and current source may also take on any value include zero positive and negative numbers. As with passing real values there may be any number of electrical channels on a port. The ports may also be turned on and off using the dgw drive set command. Any number of voltage and current sources may be placed on a port and channel.

To allow this functionality a dgw property set dgw strength set dgw get v and dgw get i are added in addition to the previous extensions described. When a port and channel is configured to be driven by a voltage or current source the value on the dgw set command indicates the voltage and current respectively. The value may be an integer real number or equivalent representation that can be translated into an integer or real number. The dgw property set command is used to indicate whether or not the port and channel is driven by a voltage source current source or to pass by numeric value. The dgw strength set command is used to set the value of the resistance or conductance of a voltage or current source respectively. The dgw get v command is used to get the port voltage. The dgw get i command is used to get the port current.

A receiver module example sets up a 0 amp current source with an output conductance of 0.01 mhos or 100 ohms in terms of resistance. The dgw property set example sets the port in and channel main to be a current. The value of the current source is set to 0 with the dgw set example . The conductance is set to 0.01 in the dgw strength set example . The port voltage and port current is retrieved in the dgw get v example and dgw get i example respectively.

In addition to these extensions a set of convenience commands are added for assigning real variables to many of the values that may be set or get. The commands are dgw assign dgw assign strength dgw assign i and dgw assign v. dgw assign takes 3 arguments a port a channel and a real variable. This command assigns the value on that port and channel to the real variable specified so that if the value of the port and channel changes the real variable will also change. It is also the case that if the real variable is changed the value on the port and channel will also change. The real variable may be the value on the port and channel or the voltage of a voltage source or the current of a current source. The dgw assign strength command takes three arguments a port a channel and a real variable. In this case the real variable is tied to the resistance or conductance value of the voltage or current source respectively on that port and channel. If the resistance or conductance value changes the real variable will also change. If the real variable is changed the resistance or conductance value will be changed. The dgw assign i and dgw assign v commands take three arguments as well a port a channel and a real variable. In this case for dgw assign i the real variable changes to the value of the port current as the port current changes and for dgw assign v the real variable changes to the value of the port voltage as the port voltage changes.

Another set of extensions aid in determining the equivalent circuit to which a port is connected. For example suppose there is an electrical network on a wire. On a particular port the engineer is interested in understanding what the equivalent circuit is connected to that port that is the electrical network external to the port on a particular block. Three commands extend the high level description language to aid in this effort dgw ext norton exists dgw ext norton i and dgw ext norton g. The dgw ext norton exists command takes two arguments a port and channel and returns whether or not a Norton equivalent exists for the connecting network. If the network is comprised of voltage and current sources a situation where the Norton equivalent will not exist is if there are only ideal voltage sources on the network. If it is a valid network then to get the value of the voltage source the engineer may use the dgw get v command. Where there is a Norton equivalent to get the current for the Norton equivalent the engineer uses the dgw ext norton i command which takes two arguments the port and channel. To get the Norton equivalent conductance the engineer uses the dgw ext norton g command which takes two arguments the port and channel. There are a variety of situations where these extensions may be used the most common being in the writing of a connect module between an event driven and circuit simulator where the equivalent circuit of a port needs to be created for the circuit simulator.

Finally the extensions include a command to determine whether or not a port is being driven. This command is called dgw driven and takes a port as an argument. It turns a 1 if it is being driven by an analog wire and a 0 if it is not. The dgw display info command takes one or two arguments either just a port or a port and channel. Upon execution it will display information related to that port or that port and channel. For example it will list the network for the port. It will also list the resolved values on the port and channel combinations. The dgw display info is mostly useful for debugging purposes.

In addition to the analog wire commands a set of math command extensions have also been added. These extensions begin with dg and are listed in in the math extensions column . Each has a description in column .

To use the extension once the models have been written with any of the extension commands the engineer needs to tell the simulator to include the library extension . The engineer may use any number of simulators including the event driven simulators provided by Cadence Design Systems Inc. Mentor Graphics Corp. and Synopsys Inc. Each has its own way of linking in library extensions and the engineer should follow the instructions provided with the simulator. In general the name of the library needs to be provided by the name of the registration function in the library initialization routines .

As long as the commands have been entered correctly the engineer need not do anything else in using the library extension. With the specification of library extension in place the library initialization routines are automatically called by the simulator. This calls the routines to register all of the extension functions to the simulator . When a command in the library extension is encountered by the simulator the appropriate interface in the analog wire specific interface routines is called. For example if the dgw set command is invoked the set port interfaces is called. The execution flow for the set commands is shown in . The flow begins with the user invoking the command on the port . The interface extracts and checks to see if the command is valid using the user input parsers . If it is not an error message is returned to the user. If it is a check is made to see if the port is an analog wire using the pin checking routines and the routines to set and get data in pin and net manager . If it is not an analog port is created and attached to the network . This is done using the routines found in the analog wire functionality routines . The command request is then executed to set the appropriate drive value voltage current property or the strength on the port or channel . In the case of the dgw set command the value voltage or current is set. Based on the properties the value of the wire is resolved using the value or electrical rules . The value of the digital port is set to the one of four binary values using the port forcing routines . A check is then made to see if any of the real variable assignments are affected . If so the real variables are updated using the routines in the real variable assignments . Upon the completion of the flow control is returned to the simulator execute other commands.

The execution flow for a get command is shown in . The execution flow begins with the invocation one of the get commands. The command is extracted and checked . A check is made to see if the port is an analog wire . If not an analog wire is created . If it is a query on the resolved value of the net or pin is returned depending on the command request . The command is then completed and control is returned to the simulator.

At simulation startup the routines to register the math functions with the simulator are called . As the simulation proceeds the math commands are handled though the math command interface . Upon receiving the math command the appropriate computational routine is called.

There are alternative embodiments to this invention. For example the extension to the simulator need not be in a library linked to the simulator. This invention may be implemented as part of the simulator and not an extension. There are also many interfaces to an event driven simulator. Any of these interfaces may be used. These include PLI 1.0 VPI and proprietary interfaces specific to a particular simulator.

The method by which the software is organized need not be the same. For example the routines need not be subdivided as shown in . They may be all put into one set of routines or split in any manner. This is also true for the pin manager the net manager the routines for real variable assignments the routines for determining nets the analog wire functionality routines the math routines the analog wire specific interface routines and the general interface to the simulator .

The embodiment described was written in the c and c languages and extends the Verilog SystemVerilog and Verilog AMS high level description languages. An alternative embodiment is to implement using a different programming language including such languages as just c just c Tcl Python Ruby Perl or any combination. There are also any number of ways the code may be written to implement the same results. This include the ordering of flow and flow . Another embodiment is to extend a different high level description language. This include VHDL and VHDL AMS.

Both the analog wire command and the math commands need not use the command names beginning with dgw and dg as described. For example any of the commands such as dgw set may be changed to another name. Also the number of arguments may be varied. For example if there is only one channel on a port the channel name need not be specified. The order of the arguments may also be changed.

A value that is passed to the set commands are described as an integer real number or equivalent representation that can be translated into an integer or real number. This value may also be a string. This is especially helpful if additional information is to be sent along a wire such as current source of 10 uA with an accuracy of 1 . The entire string may be passed to convey the information from one block to another.

A library extension need not contain all of the commands provided here. A subset may be adequate for certain applications. The library extension may also contain additional commands to add additional functionality that might be required.

The examples provided in this patent application are for illustrative purposes. The intention of this invention is that this library extension may be used for very complex designs. There will be many blocks in the analog mixed signal and RF section of the design. Each of these blocks may have one or more analog wire. The analog wires may contain any number of analog channels. Further many blocks may be connected to the same wire. This invention places no restriction on the number of blocks in a design the number of analog wires in a block the number of channels on a wire the number of ports of blocks connected to a wire or net.

Thus the reader will see that at least one embodiment of this invention can extend an event driven simulator to facilitate analog modeling without the need for an analog simulator. While the above description contains many specificities these should not be construed as limitations on the scope but rather as an exemplification of one preferred and alternative embodiments thereof. Many other variations are possible. Accordingly the scope should be determined not by the embodiments illustrated but by the appended claims and their legal equivalents.

