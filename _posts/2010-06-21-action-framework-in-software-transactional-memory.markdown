---

title: Action framework in software transactional memory
abstract: A software transactional memory system implements a lightweight key-based action framework. The framework includes a set of unified application programming interfaces (APIs) exposed by an STM library that allow clients to implement actions that can be registered, queried, and updated using specific keys by transactions or transaction nests in STM code. Each action includes a key, state information, and a set of one or more callbacks that can be hooked to the validation, commit, abort, and/or re-execution phases of transaction execution. The actions extend the built-in concurrency controls of the STM system with customized control logics, support transaction nesting semantics, and enable integration with garbage collection systems.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09411634&OS=09411634&RS=09411634
owner: Microsoft Technology Licensing, LLC
number: 09411634
owner_city: Redmond
owner_country: US
publication_date: 20100621
---
This application is related to co owned and co pending U.S. patent application Ser. No. 12 819 499 which is entitled COMPOSITION OF LOCKS IN SOFTWARE TRANSACTIONAL MEMORY filed Jun. 21 2010 and is incorporated by reference in its entirety.

Computer programs may be written to allow different portions of the program to be executed concurrently using threads or another suitable concurrent execution mechanism. In order to execute different portions of the program concurrently the computer system or the program typically includes some mechanism to manage the memory accesses of the different portions to ensure that the parts access common memory locations in the desired order.

Transactional memory systems allow programmers to designate transactions in a program that may be executed as if the transactions are executing in isolation i.e. independently of other transactions and other non transactional sequences of instructions in the program . Transactional memory systems manage the memory accesses of transactions by executing the transactions in such a way that the effects of the transaction may be rolled back or undone if two or more transactions attempt to access the same memory location in a conflicting manner. Transactional memory systems may be implemented using hardware and or software components.

Transactional memory systems such as software transactional memory STM systems often have limitations on the types of programming scenarios that are supported. For example STM systems do not typically support the use of thread local memory in transactions the interoperation between transactional and traditional locks the use of static class initializers and modular initializers the use of software lock elision inside transactions and the use of a customized abstract concurrency control. While developers of STM systems may be able to implement separate solutions for each of the above scenarios as well as other scenarios separate solutions may be costly and may result in an undesirable architecture of an STM system. An STM system with a unified and efficient solution that allows a wide range of programming scenarios to be supported would be desirable.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

A software transactional memory STM system implements a lightweight key based action framework. The framework includes a set of unified application programming interfaces APIs exposed by an STM library that allow clients e.g. programmers and or compilers to implement actions that can be registered queried and updated using specific keys by transactions or transaction nests in STM code. Each action includes a key state information and a set of one or more callbacks that can be hooked to the validation commit abort and or re execution phases of transaction execution. The actions extend the built in concurrency controls of the STM system with customized control logics support transaction nesting semantics and enable integration with garbage collection systems. The STM system may use the action framework to solve one or more of STM programming scenarios with uniformity and efficiency.

In the following Detailed Description reference is made to the accompanying drawings which form a part hereof and in which is shown by way of illustration specific embodiments in which the invention may be practiced. In this regard directional terminology such as top bottom front back leading trailing etc. is used with reference to the orientation of the Figure s being described. Because components of embodiments can be positioned in a number of different orientations the directional terminology is used for purposes of illustration and is in no way limiting. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description therefore is not to be taken in a limiting sense and the scope of the present invention is defined by the appended claims. It is to be understood that the features of the various exemplary embodiments described herein may be combined with each other unless specifically noted otherwise.

STM system includes an STM library and a runtime environment for executing STM code . STM system is configured to manage the execution of STM transactions that form atomic blocks in STM code to allow transactions to be executed atomically and if desired rollback or undo changes made by transactions . To do so STM system tracks memory accesses by transactions to objects using a log for each executing transaction as indicated by an arrow .

Runtime environment may be any suitable combination of runtime libraries a virtual machine VM operating system OS functions such as functions provided by an OS shown in and described in additional detail below and or compiler functions such as functions provided by compiler shown in and described in additional detail below.

STM code includes a set of one or more transactions and any suitable non transactional code. Each transaction includes a sequence of instructions that is designed to execute atomically i.e. as if the sequence is executing in isolation from other transactional and non transactional code in STM code . Each transaction includes an atomic block designator or other suitable syntax that indicates that a corresponding portion of STM code is a transaction . Transactions also include invocations of STM primitives which may be added by a compiler such as a compiler shown in and described in additional detail below that call functions in STM library . The STM primitives of STM library return results to transactions as indicated by function calls and returns . In addition each transaction includes zero or more memory accesses that read from and or write to one or more objects as indicated by arrows and or one or more statics not shown .

STM code may include one or more nested transactions in the set of transactions . A nested transaction is a transaction that is invoked by another transaction i.e. a parent transaction. The parent transaction and any transactions that are invoked by the parent transaction or stem from an invocation from the parent transaction form a transaction nest.

STM library includes STM primitives and instructions executable by the computer system in conjunction with runtime environment to implement STM system . The STM primitives of STM library that are callable by transactions may include management primitives that implement start commit abort and retry functions in STM library . A transaction calls the start function to initiate the management of the transaction by STM library . A transaction calls the commit function to finalize the results of the transaction in memory system if successful. A transaction calls the abort function to roll back or undo the results of the transaction in memory system . A transaction calls the retry function to retry the transaction . In other embodiments some or all of the functions performed by STM library may be included in runtime environment or added to transactions by a compiler such as compiler shown in .

The STM primitives of STM library that are callable by transactions also include memory access primitives that manage accesses to objects that are written and or read by a transaction . The memory access primitives access a set of one or more transactional locks for each object . In one embodiment STM system uses the object header of objects to store the corresponding transactional locks . Each transactional lock indicates whether a corresponding object or portion of a corresponding object is locked or unlocked for writing and or reading by transactions . When an object is locked for writing the corresponding transactional lock includes an address or other reference that locates an entry for the object in a write log W in one embodiment. When an object is not locked for writing the corresponding transactional lock includes a version number of the object .

For each non array object the memory access primitives may access a single transactional lock that locks or unlocks the non array object for writing and or reading by a transaction . For each array object the memory access primitives may access a set of one or more transactional lock where each transactional lock in the set locks or unlocks a corresponding portion of the array object for writing and or reading. Runtime environment creates and manages the transactional lock s for each object .

The memory access primitives of STM library generate and manage a set of one or more STM logs for each transaction currently being executed. Each set of STM logs includes a write log W and a read log R in one embodiment. Each write log W includes an entry for each object that is written by a transaction where each entry includes an address of a corresponding object the version number from the transactional lock of the corresponding object and an address or other reference that locates a shadow copy of the corresponding object . Each read log R includes an entry for each object that is read by a transaction where each entry includes a reference that locates the transactional lock of a corresponding object .

STM library performs the following algorithm or variations thereof to execute each transaction . Each time a transaction is started by a thread of execution STM library creates and initializes variables used to manage the transaction. STM library then allows the transaction to execute and perform any write and or read memory accesses to objects as follows.

To access an object for writing the transaction invokes a memory access primitive that opens the object for writing. STM library acquires a transactional lock corresponding to the object for the transaction if the lock is available. If the object is not available i.e. the object is locked by another transaction then STM library detects a memory access conflict between the current transaction and the other transaction and may initiate an abort phase of transaction execution to rollback and re execute the current transaction . If the object is locked by the current transaction then STM library has already acquired the transactional lock corresponding to the object for the transaction . Once a corresponding transactional lock is acquired STM library causes each write access to be made to either the object itself or a shadow copy of a corresponding object not shown and causes an entry corresponding to the write access to be stored in log W. For non array objects the shadow copy if used may be stored in log W. For array objects a shared shadow copy if used may be stored separately from log W.

To access an object for reading the transaction invokes a memory access primitive that opens the object for reading. If the object is not write locked for an optimistic read access STM library causes an entry corresponding to the read access to be stored in read log R. If the object is not write locked and does not exceed a maximum number of pessimistic reads for a pessimistic read access STM library acquires a transactional lock for the object if it has not been acquired increments a pessimistic reader count for the lock and causes an entry corresponding to the read access to be stored in read log R. If the object is locked by another transaction then STM library detects a memory access conflict between the current transaction and the other transaction and may initiate the abort phase of transaction execution to rollback and re execute the current transaction . If the object is locked by the current transaction then STM library may cause an entry corresponding to the read access to be stored in read log R or set a flag corresponding to the object in write log W to indicate that the object was also read. STM library causes a read access that occurs before a designated object has been opened from writing by the transaction to be made directly from the corresponding object . STM library causes each read access that occurs after a designated object has been opened for writing by a transaction to be made from either the corresponding object directly or the corresponding shadow copy.

After a transaction finishes executing or re executing STM library performs validation and commit phases of transaction execution to ensure that the memory accesses by the transaction did not conflict with the memory accesses by any other transaction . STM library performs the validation phase by validating the read accesses of the transaction to confirm that no other transaction wrote a memory location corresponding to a read access of the transaction subsequent to the read access being performed. If STM library detects any memory access conflicts between the current transaction and another transaction during the validation phase STM library may initiate the rollback phase of transaction execution to rollback and re execute the current transaction .

STM library performs the commit phase by updating any objects that were modified by the transaction with the shadow copies used to store the modifications releasing any transactional locks and or storing an updated version number in the transactional locks of any objects that were modified by the transaction .

After successfully performing the validation and the commit phases of transaction execution STM library allows the transaction to complete and allows the thread that caused the transaction to be executed to execute additional transactional or non transactional code in STM code .

STM system implements a lightweight key based action framework. The framework includes a set of unified application programming interfaces APIs exposed by STM library that allow clients e.g. programmers and or compilers to implement actions that can be registered queried and updated using specific keys by transactions or transaction nests in STM code . Each action includes a key state information and a set of one or more callbacks that can be hooked to the validation commit abort and or rollback phases of transaction execution. Actions extend the built in concurrency controls of STM system with customized control logics support transaction nesting semantics of STM system and enable integration with embodiments of STM system that operate with garbage collection systems. STM system may use the action framework to solve one or more of the STM programming scenarios described below with uniformity and efficiency.

For each transaction that registers an action STM library generates an action map as indicated by an arrow . Each action map includes references to the actions registered by STM library in response to action operations from the corresponding transaction . STM library registers each action with an associated key that is provided by a transaction as a parameter with an action operation into a corresponding action map for the transaction . For transactions that do not provide a key for an action e.g. transactions that will not query or update the action STM library may register the action with a global shared key to mimic a simple callback add and remove functionality. State information and callbacks in each action may be based on a type of the action operation and or one or more parameters provided by the transaction with the action operation . Action operations may be added to transactions by a programmer or a compiler such as compiler shown in .

STM library manages actions in each action map using keys instead of simply queuing actions in a list. By doing so STM library allows a transaction to query and update the corresponding actions throughout the execution of the transaction . Accordingly state information and callbacks may be modified by the transaction . The combination of keys state information and callbacks contained by actions may overcome the limitations of a stateless callback infrastructure that prevent certain STM programming scenarios from being solved. In addition the use of a single action for each key may allow a transaction to execute with increased efficiency by avoiding adding multiple callback invocations for the same purpose.

In addition to associating per instances state with transactions STM library may also generate keys that combine instance identifier information with facility identifier information. By doing so STM library allows registration of multiple actions with the same facility or across different facilities and provides for disambiguation between actions that use object addresses as keys for different purposes e.g. shadow copy management and monitor lock management . In addition STM library prevents one facility from accessing the state i.e. the action maintained by a different facility. As a result the action framework of STM library may be exposed to users in a secure manner.

STM system accesses the action map for a transaction at each phase of transaction execution of the transaction to identify actions with callbacks associated with the transaction execution phases. is a flow chart illustrating an embodiment of a method for invoking a callback implemented by an action at a transaction execution phase. In response to reaching a transaction execution phase for a transaction as indicated in a block STM library identifies each action in the action map of the transaction with callbacks associated with the transaction execution phase as indicated in a block . STM library invokes the callbacks for the transaction execution phase if any for each action in the action map as indicated in a block .

The action framework APIs of STM library provide three types of callbacks that allow transactions to hook into STM system . The callbacks include transaction stage callbacks nesting integration callbacks and resource management and garbage collection integration callbacks. Each action provides a customized implementation of these callbacks if specific behaviors are desired.

In one embodiment the transaction stage callbacks include OnPrepareForCommit OnCommit and OnRollback. The OnPrepareForCommit callback occurs during the validation phase of a transaction . During the validation phase STM library detects any actions that implement the OnPrepareForCommit callback and invokes any such callbacks . The OnPrepareForCommit callback allows a transaction to participate in the validation process that determines whether a transaction commits or rolls back and re executes. The OnCommit callback occurs during the commit phase. During the commit phase STM library detects any actions that implement the OnCommit callback and invokes any such callbacks . The OnRollback callback occurs during the rollback phase when a transaction aborts or rolls back for re execution. When a transaction reaches an abort or roll back point STM library detects any actions that implement the OnRollback callback and invokes any such callbacks . In other embodiments the transaction stage callbacks may include other callbacks related to different phases of execution of transactions .

The action framework of STM library includes built in support of nesting semantics of actions . Transactions may provide a SearchParent parameter with an action operation to specify whether the current action is to be associated with the innermost nested transaction that is currently active or with the whole transaction nest. The close integration with the transaction nesting hierarchy may provide greater flexibility and expressiveness to transactions that implement actions . Accordingly transactions may choose either flat or nesting semantics for their actions .

In one embodiment the nesting integration callbacks include DeferToParentOnCommit DeferToParentOnAbort MergeToParent and SurviveOnRollback callbacks . The DeferToParentOnCommit and DeferToParentOnAbort callbacks allow nested transactions to specify whether an action is to be deferred to a parent transaction when committing DeferToParentOnCommit or aborting DeferToParentOnAbort the nested transactions . For actions that are deferred to a parent transaction STM library registers or updates a corresponding action in the action map of the parent transaction . The MergeToParent callback allows a nested transaction to specify how to merge the state of an action into an action with the same key if any in the action map of the parent transaction . The SurviveOnRollback callback causes an action to be maintained rather than deleted in action map when a transaction rolls back. In other embodiments the nesting integration callbacks may include other callbacks related to nested transactions .

For embodiments of STM system that work with languages powered by garbage collection such as C or Java garbage collection integration with STM library ensures correctness. If STM system holds a reference to a memory location that is managed by the garbage collector STM system reports the reference to the garbage collector so that the reference can be updated correctly during garbage collections. Because actions may hold managed references STM library provides garbage collection hooks to let actions report any references to the garbage collector.

In one embodiment the resource management and garbage collection integration callbacks include Release and OnGCScan callbacks . The Release callback occurs during the commit phase where STM library to allow a transaction to release a resource. The OnGCScan callback occurs during garbage collection to allow STM library to report references in actions to the garbage collector. In other embodiments the resource management and garbage collection integration callbacks may include other callbacks related to resource management and garbage collection.

STM library uses the action framework to solve one or more STM programming scenarios such as supporting the use of thread local memory in transactions providing interoperation between transactional and traditional locks supporting static class initializers and modular initializers in transactions allowing for software lock elision inside transactions and providing a customized abstract concurrency control.

By definition thread local memory i.e. local variables thread static fields etc. will only be accessed by an owning thread. Accordingly thread local memory may be managed without using the standard STM memory concurrency control logics of STM library e.g. logs . To support failure atomicity however STM library backs up the initial values of any thread local memory used by a transaction so that the initial values can be recovered if the transaction does not succeed i.e. rolls back or is aborted . STM library handles pointer to locals including struct types across method boundaries by combining with byref analysis.

STM library may be configured to implement a memory undo action using the action framework to handle thread local memory accesses by transactions . For each thread local memory region the memory undo action caches the initial values of the thread local memory region if the region may be modified and recovers the initial values in case the transaction is rolled back or aborted. The memory undo action uses the base address of the thread local memory region as the key . By doing so STM library can register a single memory undo action per thread local memory region and perform a single undo action per thread local memory region if a transaction does not succeed. As a result STM library may handle thread local memory accesses without registering multiple actions for the same thread local memory region. STM library implements the memory undo action with a per transaction scope and does not merge memory undo actions into parent transactions . Each transaction registers a set of memory undo actions for accessed local memory regions before the transaction starts. This allows for partial rollback of thread local memory when a nested transaction rolls back or aborts.

STM library may be also configured to provide interoperation between transactional and traditional locks using the action framework. By doing so STM library may provide increased compatibility and composability between STM system and any non transactions code in STM code . To provide isolation between transactions and non transactional code in STM code STM library registers a lock interoperation action to cause a transaction to hold each lock taken by the transaction until the whole transaction nest that includes the transaction commits successfully. The lock interoperation action causes the locks to be held even if there are unlock operations inside the transaction or transaction nest. Because STM library uses a key to query each lock interoperation action and the lock releases are deferred until the whole transaction nest commits successfully the lock interoperation action allows a single physical lock operation to be performed for each lock in a transactional nest. STM library updates lock interoperation actions to maintain a lock and unlock recursion count to allow lock operations to be compensated when a transaction aborts or a transaction nest commits. STM library implements lock interoperation actions with a per transaction scope but merges lock interoperation actions to any parent transaction upon abort or commit.

When a transaction with one or more lock interoperation actions commits STM library performs the deferred lock operations based on the recursion count to correctly set the state of the locks . If a transaction with one or more lock interoperation actions aborts STM library compensates for any acquired locks by performing corresponding lock release operations for each acquired lock. Because lock releases are deferred until the transaction nest commits STM library ignores any lock releases when a transaction aborts.

Additional details of the use of lock interoperation actions may be found in U.S. patent application Ser. No. 12 819 499 which is entitled COMPOSITION OF LOCKS IN SOFTWARE TRANSACTIONAL MEMORY filed concurrently herewith and is incorporated by reference in its entirety.

In addition STM library may be configured to support static class initializers and modular initializers in transactions using the action framework. In systems such as Microsoft.NET or the Java Virtual Machine only one thread is allowed to perform the static class initialize of a particular class or the modular initialize of a module. To avoid potential data races in such initializations STM library registers an initializer action whenever an initializer is encountered in a transaction and immediately rolls back and re executes the transaction . The initializer action implements the OnRollback callback which is invoked when STM library rolls back the transaction. The OnRollback callback for the initializer action performs the intended initialization prior to the transaction being re executed. The initializer action has a transaction nest scope i.e. the whole transaction nest only has a single initializer action per initializer.

STM library may further use the action framework to allow software lock elision inside transactions . Software lock elision is an optimization technique that relies on the assumption that no contention will occur on lock operations e.g. read and write locks on objects most of the time. For each lock operation of a transaction STM library registers a lock elision action that captures the current state of the lock of an object and speculatively executes the transaction without actually locking the object . During the validation phase STM library invokes the OnPrepareForCommit callback for each lock elision action to determine whether the corresponding locks have changed. If any locks have changed STM library causes the transaction to roll back and re execute. STM library implements lock elision actions with a per transaction scope but merges lock elision actions to any parent transaction upon abort or commit.

STM library may also use the action framework to provide programmers with a customized abstract concurrency control. At times conflicts detected by STM library of low level reads and writes may be false conflicts. For example in a chain based hash table an insertion operation touches a bucket header and entries in a linked list along the way to the appropriate position in the hash table. The insertion operation will conflict with any transaction that updates the bucket or any of the entries even though semantically disjoint entries are actually being accessed. To avoid such false conflicts programmers can forgo the low level memory concurrency control offered by STM library e.g. by suppressing the concurrency controls or by using open nesting and manage their data structures using a high level abstract concurrency control provided by the action framework.

STM library implements one or more customized control actions to allow programmers to provide customized concurrency control algorithms with the callback information . The customized control actions may use the OnPrepareForCommit callback to influence the decision of whether a transaction can be committed or not the OnCommit callback to flush out any deferred effects that are held off in a transaction and the OnRollback callback to provide any compensating actions. If nesting semantics are desired the DeferToParentOnCommit DeferToParentOnAbort MergeToParent and SurviveOnRollback callback information may be used to express the desired behaviors.

Compiler system represents a compile mode of operation in a computer system such as computer system shown in and described in additional detail below where the computer system is executing instructions to compile code into STM code . In one embodiment compiler system includes a just in time JIT compiler system that operates in the computer system in conjunction with a runtime environment executed by an operating system OS such as OS shown in and described in additional detail below STM library and any additional runtime libraries not shown . In another embodiment compiler system includes a stand alone compiler system that produces STM code for execution on the same or a different computer system.

Code includes a set of one or more STM transactions . Each STM transaction includes an atomic block designator that indicates to compiler that a corresponding portion of code is an STM transaction . Each STM transaction may include zero or more memory accesses that read from and or write to an object . Each STM transaction may also include zero or more action operations not shown that generate query or update actions . Code may be any suitable source code written in a language such as Java or C or any suitable bytecode such as Common Intermediate Language CIL Microsoft Intermediate Language MSIL or Java bytecode.

Compiler accesses or otherwise receives code with transactions that include memory accesses . Compiler identifies memory accesses and compiles code into STM code with invocations of STM primitives in STM library for each memory access . Compiler may also identify instances where an action may be used and compiles code into STM code with action operations for each instance where an action may be used. Compiler performs any desired conversion of the set of instructions of code into a set of instructions that are executable by a designated computer system and includes the set of instructions in STM code .

Computer system includes one or more processor packages memory system zero or more input output devices zero or more display devices zero or more peripheral devices and zero or more network devices . Processor packages memory system input output devices display devices peripheral devices and network devices communicate using a set of interconnections that includes any suitable type number and configuration of controllers buses interfaces and or other wired or wireless connections.

Computer system represents any suitable processing device configured for a general purpose or a specific purpose. Examples of computer system include a server a personal computer a laptop computer a tablet computer a personal digital assistant PDA a mobile telephone and an audio video device. The components of computer system i.e. processor packages memory system input output devices display devices peripheral devices network devices and interconnections may be contained in a common housing not shown or in any suitable number of separate housings not shown .

Processor packages each include one or more execution cores. Each execution core is configured to access and execute instructions stored in memory system . The instructions may include a basic input output system BIOS or firmware not shown OS STM code STM library runtime environment compiler and code . Each execution core may execute the instructions in conjunction with or in response to information received from input output devices display devices peripheral devices and or network devices .

Computer system boots and executes OS . OS includes instructions executable by execution cores to manage the components of computer system and provide a set of functions that allow programs to access and use the components. OS executes runtime environment to allow STM code and STM library to be executed. In one embodiment OS is the Windows operating system. In other embodiments OS is another operating system suitable for use with computer system .

Computer system executes compiler to generate STM code from code . Compiler accesses or otherwise receives code and transforms code into STM code for execution by computer system . Compiler performs any desired conversion of the set of instructions of code into a set of instructions that are executable by computer system and includes the set of instructions in STM code . Compiler also identifies blocks in code from transaction designators and modifies blocks in STM code to include invocations of STM primitives .

In one embodiment compiler includes a just in time JIT compiler that operates in computer system in conjunction with OS runtime environment and STM library . In another embodiment compiler includes a stand alone compiler that produces STM code for execution on computer system or another computer system not shown .

Computer system executes runtime environment and STM library to allow STM code and transactions therein to be executed in computer system as described above.

Memory system includes any suitable type number and configuration of volatile or non volatile storage devices configured to store instructions and data. The storage devices of memory system represent computer readable storage media that store computer executable instructions including STM code STM library runtime environment OS compiler and code . The instructions are executable by computer system to perform the functions and methods of STM code STM library runtime environment OS compiler and code as described herein. Memory system stores instructions and data received from processor packages input output devices display devices peripheral devices and network devices . Memory system provides stored instructions and data to processor packages input output devices display devices peripheral devices and network devices . Examples of storage devices in memory system include hard disk drives random access memory RAM read only memory ROM flash memory drives and cards and magnetic and optical disks such as CDs and DVDs.

Input output devices include any suitable type number and configuration of input output devices configured to input instructions or data from a user to computer system and output instructions or data from computer system to the user. Examples of input output devices include a keyboard a mouse a touchpad a touchscreen buttons dials knobs and switches.

Display devices include any suitable type number and configuration of display devices configured to output textual and or graphical information to a user of computer system . Examples of display devices include a monitor a display screen and a projector.

Peripheral devices include any suitable type number and configuration of peripheral devices configured to operate with one or more other components in computer system to perform general or specific processing functions.

Network devices include any suitable type number and configuration of network devices configured to allow computer system to communicate across one or more networks not shown . Network devices may operate according to any suitable networking protocol and or configuration to allow information to be transmitted by computer system to a network or received by computer system from a network.

Although specific embodiments have been illustrated and described herein it will be appreciated by those of ordinary skill in the art that a variety of alternate and or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore it is intended that this invention be limited only by the claims and the equivalents thereof.

