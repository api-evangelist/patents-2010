---

title: Methods and apparatus for processing partitioned changes
abstract: In a storage area network, agents provide transactions of data sets containing updates to manageable entities in a SAN. A SAN server avoids intermittent dissemination of events pertaining to a single transaction by storing events in a cache until completion of all subtransactions in the transaction, and then disseminating all events pertaining to the transaction. Transactions are broken down into update sections, each containing one or more subtransactions collectively defining the entire transaction. Update sections corresponding to the transaction are tagged with a section ID. Events indicating completion of processing of the update section are identified by the section ID, and suppressed temporarily by storing them in the event cache pending completion of the transaction. Other events not matching a tagged section ID are allowed to disseminate. Upon completion of the transaction, events for all section IDs corresponding to the transaction are disseminated from the cache.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08285673&OS=08285673&RS=08285673
owner: EMC Corporation
number: 08285673
owner_city: Hopkinton
owner_country: US
publication_date: 20100204
---
This Application is a Divisional of U.S. patent application Ser. No. 11 476 523 filed on Jun. 28 2006 now U.S. Pat. No. 7 711 705 entitled METHODS AND APPARATUS FOR PROCESSING PARTITIONED CHANGES the contents and teachings of which are hereby incorporated by reference in their entirety.

In a storage area network SAN a SAN management application monitors and manages manageable entities in the SAN. The manageable entities include storage arrays connectivity devices and hosts. Typically software components known as agents execute on the hosts for gathering reporting and monitoring the manageable entities in the SAN. The manageable entities are responsive to the agents for reporting various status metrics back to the agents and receiving control information from the agents. A management server executes the SAN management application and oversees the agents. The management server is responsive to a console having a graphical user interface GUI for receiving and displaying operator parameters with a SAN operator.

The agents periodically transmit management information to the management application. The management information pertains to the manageable entities that the agent is monitoring and is employed to update and maintain a managed object database MODB . The managed object database stores collective information on the manageable entities across the SAN for responding to queries from the management application. Such queries include available storage used storage configured and in use devices and frequency of usage for example and is employed to generate reports on trending analysis current utilization usage projections and other reporting accounting and maintenance operations.

In a large SAN the management information transmitted from the agents can be substantial. For example a storage array has many individual storage devices such as disk drives each having corresponding management information. In particular information concerning a large storage array having many storage devices may be unwieldy and time consuming to process. Typically therefore the management application processes the management information from the agents at off peak hours such as overnight.

In the storage area network SAN agents monitor the storage arrays for management information concerning each of the storage devices e.g. disk drives on the storage array. Modern storage arrays can have as many as 64 000 64K storage devices. The agents transmit the management information to the management application as a data pull transaction or change set reflecting changes to each of the storage devices in the storage array. The resulting change set of management information can be substantial. Attempts to process a large data pull transaction transaction therefore can have a disproportionate effect on the management application and can result in bottlenecks and locking contention during processing degrading overall system performance. Accordingly large transactions may be partitioned into a series of smaller subtransactions data sets such as those disclosed in copending U.S. patent application Ser. No. 11 393 110 filed Mar. 30 2006 METHODS AND APPARATUS FOR PERSISTING MANAGEMENT INFORMATION CHANGES incorporated herein by reference.

The agents therefore transmit the transaction as a series of update sections partitions each including one or more subtransactions collectively defining the entire transaction. The management application employs one or more store processes to process each of the update sections by updating the corresponding records in the managed object database. Each of the subtransactions generates events attesting to the corresponding update performed in the managed object database. However the transaction corresponding to a particular storage array represents an atomic occurrence i.e. should happen as a single action . Other processes in the management application may be listening for events pertaining to the managed object database updates. It is beneficial if these processes do not receive only a portion of events attesting to updates in a transaction but rather that all events pertaining to a particular transaction are disseminated at the same time. Each update section in a transaction should be processed concurrently or nearly concurrently with the other update sections in the transaction and the resulting events disseminated as an atomic set of events.

Configurations disclosed herein are based in part on the observation that disseminated events corresponding to earlier processed update sections may present inconsistencies until later processed update sections disseminate corresponding complementary and or related events particularly if an intermittent disruption impedes timely processing of all update sections i.e. crash network failure etc. . For example events may pertain to the addition of a storage device to a storage array. A particular event pertains to the storage device and another event pertains to the storage array that received the storage device. Dissemination of only the storage device event may result in an ambiguity that a storage device was added but be unclear as to which storage array received it.

Accordingly configurations herein substantially overcome the shortcomings presented by intermittent dissemination of events pertaining to a single transaction by storing events in a cache until completion of all subtransactions in the transaction and then disseminating all events pertaining to the transaction. Transactions are broken down into update sections each containing one or more subtransactions collectively defining the entire transaction. Update sections corresponding to the transaction are tagged with a section ID collectively corresponding to a batch ID denoting the transaction. Events indicating completion of processing of the update section are identified by the section ID and suppressed temporarily by storing them in an event cache pending completion of the transaction. Other events not matching a tagged section ID are allowed to disseminate. Upon completion of the transaction events for all section IDs corresponding to the transaction are disseminated from the cache. An optimizer aggregates multiple events pertaining to the same storage device to avoid redundant and moot events. In this manner events pertaining to an atomic transaction are queued in the cache until the transaction processing is complete and then released as an atomic set of events.

In further detail the method of processing event data in a storage area network SAN as disclosed in an exemplary manner below includes receiving an update section in which the update section includes at least one subtransaction of a transaction and processing the update section in a managed object database the managed object database being operable to process a plurality of the update sections collectively defining the transaction. The method suppresses events indicative of the update section pending completion of each of the update sections corresponding to the transaction such that the suppressed events are operable to be released upon processing of all update section in the transaction.

Each of the update sections results in at least one change to the managed object database which generates an event for each such change in the managed object database. A database listener suppresses if the event corresponds to completion of processing an update section propagation of the event and propagates if the event does not correspond to an update section the event to registered processes adapted to receive the event. The DB listener receives a transaction completion indicating completion of each of the update sections in the transaction and then propagates each of the suppressed events corresponding to the transaction.

In the exemplary configuration the received update sections are indicative of updates to at least one storage device in a storage array in which the update sections include one or more subtransactions of a transaction. The update section therefore corresponds to a portion of a transaction such that the transaction is operable to be reported as an atomic occurrence.

For both transaction related update sections partitioned changes and other event driven processes the DB listener receives a registration request from a process. The registration request includes an event type or other indicator that the requesting process is listening for and detects occurrences of the listened for event matching the event type in the registration request. The DB listener selectively transmits the listened for event based on whether the event corresponds to an update section.

In the exemplary arrangement disclosed herein suppressing includes storing events in a queuing area or cache and waiting for an indication of completion of each subtransaction defining the transaction. The management application then releases suppressed events from the queuing area for dissemination upon receipt of the indication of completion.

The indication of completion of each subtransaction collectively aggregated for all subtransactions update sections may be the notification of transaction completion from an agent. Processing includes gathering from an agent in communication with a storage array each of the subtransactions occurring at the storage array and building a series of update sections comprising a transaction such that the series of update sections collectively include each of the gathered subtransactions. The agents send each of the update sections included in the transaction and after sending all update sections for a transaction send an indication of transmission completion of each of the update sections included in the transaction.

In the exemplary configuration each of the subtransactions corresponds to a unit of work performed by updating the managed object database in which each unit of work defines an atomic activity within the managed object database. An application programming interface API is employed for defining a batch ID corresponding to a transaction and associating each update section of the transaction with a section ID corresponding to the batch ID. The DB listener then suppresses events corresponding to the transaction based on the batch ID and releases events corresponding to the batch ID upon receiving the transaction completion indicative of completion of the transaction i.e. all update sections corresponding to the batch ID. A batch section mapper stores a unit of work i.e. section ID associated with each update section for each update section in the transaction and identifies suppressed events from the stored units of work associated with the batch ID.

Alternate configurations of the invention include a multiprogramming or multiprocessing computerized device such as a workstation handheld or laptop computer or dedicated computing device or the like configured with software and or circuitry e.g. a processor as summarized above to process any or all of the method operations disclosed herein as embodiments of the invention. Still other embodiments of the invention include software programs such as a Java Virtual Machine and or an operating system that can operate alone or in conjunction with each other with a multiprocessing computerized device to perform the method embodiment steps and operations summarized above and disclosed in detail below. One such embodiment comprises a computer program product that has a computer readable medium including computer program logic encoded thereon that when performed in a multiprocessing computerized device having a coupling of a memory and a processor programs the processor to perform the operations disclosed herein as embodiments of the invention to carry out data access requests. Such arrangements of the invention are typically provided as software code and or other data e.g. data structures arranged or encoded on a computer readable medium such as an optical medium e.g. CD ROM floppy or hard disk or other medium such as firmware or microcode in one or more ROM or RAM or PROM chips field programmable gate arrays FPGAs or as an Application Specific Integrated Circuit ASIC . The software or firmware or other such configurations can be installed onto the computerized device e.g. during operating system or execution environment installation to cause the computerized device to perform the techniques explained herein as embodiments of the invention.

In a storage area network the management application on the server receives event notifications attesting to changes made to various storage arrays. The set of changes events corresponding to a particular storage array are intended to be processed as an atomic occurrence. In a partitioned subdivided update disseminated events corresponding to earlier processed update sections may present inconsistencies until later processed update sections disseminate corresponding events. It would be beneficial to provide atomic notification of changes resulting from a single transaction of changes. Accordingly configurations herein substantially overcome the shortcomings presented by intermittent dissemination of events pertaining to a single transaction by storing events in a cache until completion of all subtransactions in the transaction and then disseminating all events pertaining to the transaction. Transactions are broken down into update sections each containing one or more subtransactions collectively defining the entire transaction. Update sections corresponding to the transaction are tagged with a section ID. Events indicating completion of processing of the update section are identified by the section ID and suppressed temporarily by storing them in an event cache pending completion of the transaction. Other events not matching a tagged section ID are allowed to disseminate. Upon completion of the transaction events for all section IDs corresponding to the transaction are disseminated from the cache. An optimizer aggregates multiple events pertaining to the same storage device to avoid redundant and moot events. In this manner events pertaining to an atomic transaction are queued in the cache until the transaction processing is complete and then released as an atomic set of events.

The management application also connects to a managed object database for maintaining operating statistics of the manageable entities . The management application employs the data pull transactions transactions hereinafter for updating the managed object database to maintain an accurate repository about the manageable entities in the SAN . The management application employs the managed object database for operations such as queries from the operator console report generation and other administrative details of the manageable entities . As indicated above the agents subdivide the data pull transactions into a series of update section messages . . . N generally or data service message each transmitted as a separate update section . . . N generally . Each update section includes one or more subtransactions . . . N generally collectively representing the entire data pull transaction .

Each update section triggers a resulting update event upon making changes to the database . A database listener receives the events triggered by the update sections via the database interface as shown by arrow . Various processes in the management application register with the DB listener to receive notification of the update events as well as other events occurring via the server . In accordance with configurations herein events triggered by update sections of a transaction are suppressed in an event cache repository until all update events for a particular transaction are received thus indicating that the managed object database has applied the entire transaction .

The DB listener identifies events corresponding to update sections by screening or filtering the captured events. A comparator identifies events which are listened for by comparing the type of event to the registered events being listened for. A discriminator discriminates the listened for events which correspond to update sections of a transaction . The discriminator stores the update section events in an event repository shown by arrow while other events are allowed to propagate to the registered recipient in the management application shown by arrow .

Each update section is identified by a unit of work and each transaction is identified by a batch ID . The database listener receives the unit of work UOW identifier of each update section via an application programming interface API from the management application . Alternatively other registration and notification schemes may be employed. In the exemplary configuration the database listener maintains a batch section mapper . The batch section mapper maintains a mapping of unit of work UOW entries of each update section to a batch entry corresponding to the transaction of which the update sections are a part of. The DB listener receives the UOWs of events to listen for via the API invoked from the management application shown by arrow and suppresses such events in the event repository . Upon completion DB processing of all events in a particular transaction the batch ID is employed to release all suppressed cached events corresponding to that transaction as will now be discussed in further detail with respect to .

Each transaction contains updates for a particular storage array . An agent responsible for the storage array is in communication with the storage array and gathers each of the subtransactions occurring at the storage array as depicted at step . At step the agent builds a series of update sections comprising a transaction such that the series of update sections collectively including each of the gathered subtransactions . Transactions may be of a substantial size particularly with a large storage array. For this reason transactions are broken into a series of subtransactions each in an update section to avoid overburdening the server with a single large update.

Periodically typically according to predetermined i.e. nightly intervals as described above the agent sends each of the update sections included in the transaction as depicted at step . The server receives each of the update sections N such that each update section includes at least one subtransaction of a transaction as shown at step . The server tracks and groups the update sections according to the transaction . Upon receipt of an update section the management application in the server checks to see if this is the first update section for this transaction as shown at step . In the exemplary configuration the actual checking that occurs is whether the transaction belongs to a batch. As discussed further below with respect to the API the batch is created before by startEventBatch method and each successive section is added by addBatchSection. The UOW is the identifier of the batch section entry . Accordingly in particular configurations employing the API the UOW can be checked on being a section in a batch. If so then the management application defines a batch ID corresponding to the transaction as depicted at step . In the exemplary configuration the management application invokes the API to begin a batch of update sections batch section corresponding to a transaction discussed further below.

The management application therefore receives the update section indicative of updates to at least one storage device in a storage array such that the update section includes one or more subtransactions of a transaction as disclosed at step . The update section corresponds to a portion of a transaction in which the transaction is operable to be reported as an atomic occurrence following completion of all update sections subtransactions of the transaction.

In the exemplary configuration each of the subtransactions corresponds to a unit of work UOW performed by updating the managed object database in which each unit of work defines an atomic activity within the managed object database as shown at step . The UOW is employed by the API in later disseminating events corresponding to the update section upon completion of processing the transaction . The management application associates each update section of the transaction with a batch ID identifying the transaction as shown at step . The batch ID in the exemplary configuration is returned by the API with the first update section of the transaction and is employed by successive update sections to group all update sections via the batch section mapper . The batch section mapper stores the unit of work associated with each update section for each update section in the transaction as depicted at step .

The management application processes the update section in the managed object database by applying the updates in the update section as shown at step . The managed object database is operable to process each of the plurality of the update sections collectively defining the transaction therefore maintaining the managed object DB in a state reflective of the manageable entities of the SAN . Upon processing the update section the management application invokes the DB listener to identify and receive events corresponding to a batch ID as disclosed at step . Changes to the managed object database resulting from each subtransaction generate events propagated to the server for receipt by the processes of the management application . Therefore each of the update sections results in at least one change to the managed object database in response the MODB generates an event for each change in the managed object database as shown at step .

The management application continues processing the incoming update sections . Concurrently events are generated for previous update sections . Accordingly a check is performed at step to determine if events have been generated. If not control reverts to step to continue receiving update sections in the transaction . If an event occurs the DB listener employs the comparator to detect occurrences of the listened for event matching the event type in the registration request for any previously registered event types above at step as depicted at step . The DB listener receives the event at step and suppresses events indicative of the update section pending completion of each of the update sections corresponding to the transaction such that the suppressed events are operable to be released upon processing of each update section in the transaction as depicted at step .

The DB listener selectively identifies events based on the batch ID as depicted at step . A check is performed at step to determine if the event matches a batch ID of a previously received update section . In the exemplary configuration the discriminator employs the batch section mapper to receive information mapping the UOW of the received event to the batch Ids corresponding to received update sections . Alternate configurations may employ other mechanisms for tagging events and determining corresponding update sections . If the event does not correspond to received transactions i.e. does not match any update sections then the DB listener selectively transmits the listened for event based on whether the event corresponds to an update section as shown at step . The DB listener propagates if the event does not correspond to an update section the event to registered processes adapted to receive the event shown by arrow as depicted at step .

If the received event does correspond to an update section then the DB listener caches the event by suppressing if the event corresponds to completion of processing an update section propagation of the event as disclosed at step . In the exemplary arrangement suppressing includes storing events in a queuing area as depicted at step shown by arrow . In the exemplary configuration the DB listener suppresses events corresponding to the transaction based on the batch ID as depicted at step .

For each transaction the management application receives the sequence of update sections . . . N that define the transaction . Accordingly the management application waits for an indication of completion of each subtransaction defining the transaction as depicted by the check at step . If no completion indication is received then control reverts to step to receive successive update sections . If all update sections including all subtransactions have been sent by the agent then the agent sends an indication of transmission of each of the update sections included in the transaction as depicted at step . The management application receives the transaction completion indicating completion of each of the update sections in the transaction . The transaction completion may be an indication of completion of each subtransaction in aggregate or may be a separate notification of transaction completion from an agent sent as a separate message after all update sections are sent.

It should be noted that the exemplary configuration depicted as a sequence of steps may include concurrent operations. For example in the exemplary arrangement events corresponding to the MODB updates are ongoing as additional update sections are received. The DB listener need not wait for a particular event before proceeding with the next update section but rather may process the update sections and events in a concurrent or real time manner as they arrive. Further multiple transactions may occur simultaneously each assigned a separate batch ID . The management application identifies the individual update sections according to the store process that receives them and the batch ID to UOW mapping maintained by the batch section mapper .

In the exemplary configuration a subtransaction optimization operation mitigates redundant and cumulative updates by examining each of the update sections in the transaction and consolidating multiple updates to the same database object such that a single event reflects the change to the object as shown at step . Therefore multiple similar updates to the same storage device storage object and updates that reverse a previous update moot to the same storage device are identified and removed.

The management application releases the suppressed events from the queuing area event repository for dissemination to other processes in the management application as shown at step . The batch section mapper identifies the suppressed events from the stored units of work associated with the batch ID as depicted at step . The event repository releases events corresponding to the batch ID upon receiving the transaction completion indicative of completion of the transaction corresponding to the batch ID as shown at step . Upon release the management application propagates each of the suppressed events corresponding to the transaction as shown by arrow as depicted at step .

In the exemplary configuration the API is invoked so that individual update sections may be retracted or backed out. Such an arrangement identifying an inconsistency with a particular update section and computes the unit of work UOW associated with the particular update section. The API is invoked using the UOW to perform a rollback based on the unit of work to reverse the stored section update.

As indicated above the exemplary operations for generating a batch ID to begin a series of update sections adding events corresponding to additional update sections to the event repository and releasing the suppressed events are performable via an API invoked from the management application and the DB listener . In an exemplary configuration the API may be as follows 

startEventBatch method registers a new batch to collect the events for. A unique butch id is created for the batch. The batch label given as the parameter is used for creating batch id. The unique batch id is returned in the CacheListenertResult.

removeBatchSection identifies the batch section by its UOW given as a parameter and cleans all accumulated cache events for the section. It also removes association of the section s UOW with the batch id.

commitBatch identifies the batch by batchId given as a parameter and sends all accumulated for the batch cache events.

rollbackEventBatch identifies the batch by batchId given as a parameter and cleans all cache events related to the batch. It also cleans all relations between the batch and its sections.

The aforementioned API invocations are exemplary other and additional calls may be apparent to those of skill in the art.

Those skilled in the art should readily appreciate that the programs and methods for atomic transaction and event processing as defined herein are deliverable to a processing device in many forms including but not limited to a information permanently stored on non writeable storage media such as ROM devices b information alterably stored on writeable storage media such as floppy disks magnetic tapes CDs RAM devices and other magnetic and optical media or c information conveyed to a computer through communication media for example using baseband signaling or broadband signaling techniques as in an electronic network such as the Internet or telephone modem lines. Such delivery may be in the form of a computer program product having a computer readable medium operable to store computer program logic embodied in computer program code encoded thereon for example. The operations and methods may be implemented in a software executable object or as a set of instructions embedded in a carrier wave. Alternatively the operations and methods disclosed herein may be embodied in whole or in part using hardware components such as Application Specific Integrated Circuits ASICs Field Programmable Gate Arrays FPGAs state machines controllers or other hardware components or devices or a combination of hardware software and firmware components.

While the system and method for atomic transaction and event processing has been particularly shown and described with references to embodiments thereof it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the scope of the invention encompassed by the appended claims.

