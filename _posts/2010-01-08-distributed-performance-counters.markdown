---

title: Distributed performance counters
abstract: A plurality of first performance counter modules is coupled to a plurality of processing cores. The plurality of first performance counter modules is operable to collect performance data associated with the plurality of processing cores respectively. A plurality of second performance counter modules are coupled to a plurality of L2 cache units, and the plurality of second performance counter modules are operable to collect performance data associated with the plurality of L2 cache units respectively. A central performance counter module may be operable to coordinate counter data from the plurality of first performance counter modules and the plurality of second performance modules, the a central performance counter module, the plurality of first performance counter modules, and the plurality of second performance counter modules connected by a daisy chain connection.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08595389&OS=08595389&RS=08595389
owner: International Business Machines Corporation
number: 08595389
owner_city: Armonk
owner_country: US
publication_date: 20100108
---
This invention was made with Government support under Contract No. B554331 awarded by Department of Energy. The Government has certain rights in this invention.

The present invention is related to the following commonly owned co pending United States patent Applications filed on even date herewith the entire contents and disclosure of each of which is expressly incorporated by reference herein as if fully set forth herein. U.S. patent application Ser. No. 12 684 367 for USING DMA FOR COPYING PERFORMANCE COUNTER DATA TO MEMORY U.S. patent application Ser. No. 12 684 172 filed Jan. 8 2010 for HARDWARE SUPPORT FOR COLLECTING PERFORMANCE COUNTERS DIRECTLY TO MEMORY U.S. patent application Ser. No. 12 684 190 filed Jan. 8 2010 for HARDWARE ENABLED PERFORMANCE COUNTERS WITH SUPPORT FOR OPERATING SYSTEM CONTEXT SWITCHING U.S. patent application Ser. No. 12 684 496 filed Jan. 8 2010 for HARDWARE SUPPORT FOR SOFTWARE CONTROLLED FAST RECONFIGURATION OF PERFORMANCE COUNTERS U.S. patent application Ser. No. 12 684 429 filed Jan. 8 2010 for HARDWARE SUPPORT FOR SOFTWARE CONTROLLED FAST MULTIPLEXING OF PERFORMANCE COUNTERS U.S. patent application Ser. No. 12 697 799 filed on Feb. 1 2010 for CONDITIONAL LOAD AND STORE IN A SHARED CACHE U.S. patent application Ser. No. 61 261 269 filed Nov. 13 2009 for LOCAL ROLLBACK FOR FAULT TOLERANCE IN PARALLEL COMPUTING SYSTEMS U.S. patent application Ser. No. 12 684 860 filed Jan. 8 2010 for PAUSE PROCESSOR HARDWARE THREAD UNTIL PIN U.S. patent application Ser. No. 12 684 174 filed Jan. 8 2010 for PRECAST THERMAL INTERFACE ADHESIVE FOR EASY AND REPEATED SEPARATION AND REMATING U.S. patent application Ser. No. 12 684 184 filed Jan. 8 2010 for ZONE ROUTING IN A TORUS NETWORK U.S. patent application Ser. No. 12 684 852 filed Jan. 8 2010 for PROCESSOR RESUME UNIT U.S. patent application Ser. No. 12 684 642 filed Jan. 8 2010 for TLB EXCLUSION RANGE U.S. patent application Ser. No. 12 684 804 filed Jan. 8 2010 for DISTRIBUTED TRACE USING CENTRAL PERFORMANCE COUNTER MEMORY U.S. patent application Ser. No. 13 008 602 filed Jan. 18 2011 for CACHE DIRECTORY LOOKUP READER SET ENCODING FOR PARTIAL CACHE LINE SPECULATION SUPPORT U.S. patent application Ser. No. 61 293 237 filed Jan. 8 2010 for ORDERING OF GUARDED AND UNGUARDED STORES FOR NO SYNC I O U.S. patent application Ser. No. 12 693 972 filed Jan. 26 2010 for DISTRIBUTED PARALLEL MESSAGING FOR MULTIPROCESSOR SYSTEMS U.S. patent application Ser. No. 12 688 747 filed Jan. 15 2010 for SUPPORT FOR NON LOCKING PARALLEL RECEPTION OF PACKETS BELONGING TO A SINGLE MEMORY RECEPTION FIFO U.S. patent application Ser. No. 12 688 773 filed Jan. 15 2010 for OPCODE COUNTING FOR PERFORMANCE MEASUREMENT U.S. patent application Ser. No. 12 684 776 filed Jan. 8 2010 for MULTI INPUT AND BINARY REPRODUCIBLE HIGH BANDWIDTH FLOATING POINT ADDER IN A COLLECTIVE NETWORK U.S. patent application Ser. No. 13 004 007 filed Jan. 10 2011 for MULTI PETASCALE HIGHLY EFFICIENT PARALLEL SUPERCOMPUTER U.S. patent application Ser. No. 12 984 252 filed Jan. 4 2011 for CACHE WITHIN A CACHE U.S. patent application Ser. No. 13 008 502 filed Jan. 18 2011 for MULTIPROCESSOR SYSTEM WITH MULTIPLE CONCURRENT MODES OF EXECUTION U.S. patent application Ser. No. 13 008 583 filed Jan. 18 2011 for READER SET ENCODING FOR DIRECTORY OF SHARED CACHE MEMORY IN MULTIPROCESSOR SYSTEM U.S. patent application Ser. No. 12 984 308 filed on Jan. 4 2011 for EVICT ON WRITE A MANAGEMENT STRATEGY FOR A PREFETCH UNIT AND OR FIRST LEVEL CACHE IN A MULTIPROCESSOR SYSTEM WITH SPECULATIVE EXECUTION U.S. patent application Ser. No. 12 984 329 filed Jan. 4 2011 for PHYSICAL ALIASING FOR THREAD LEVEL SPECULATION WITH A SPECULATION BLIND CACHE 61 293 552 filed Jan. 8 2010 for LIST BASED PREFETCH U.S. patent application Ser. No. 12 684 693 filed Jan. 8 2010 for PROGRAMMABLE STREAM PREFETCH WITH RESOURCE OPTIMIZATION U.S. patent application Ser. No. 13 004 005 filed Jan. 10 2011 for NON VOLATILE MEMORY FOR CHECKPOINT STORAGE U.S. patent application Ser. No. 61 293 476 filed Jan. 8 2010 for NETWORK SUPPORT FOR SYSTEM INITIATED CHECKPOINTS U.S. patent application Ser. No. 12 696 746 filed on Jan. 29 2010 for TWO DIFFERENT PREFETCH COMPLEMENTARY ENGINES OPERATING SIMULTANEOUSLY U.S. patent application Ser. No. 12 697 015 filed on Jan. 29 2010 for DEADLOCK FREE CLASS ROUTES FOR COLLECTIVE COMMUNICATIONS EMBEDDED IN A MULTI DIMENSIONAL TORUS NETWORK U.S. patent application Ser. No. 61 293 559 filed Jan. 8 2010 for RELIABILITY AND PERFORMANCE OF A SYSTEM ON A CHIP BY PREDICTIVE WEAR OUT BASED ACTIVATION OF FUNCTIONAL COMPONENTS U.S. patent application Ser. No. 12 727 984 filed Mar. 19 2010 for EFFICIENCY OF STATIC CORE TURN OFF IN A SYSTEM ON A CHIP WITH VARIATION U.S. patent application Ser. No. 12 697 043 Jan. 29 2010 for IMPLEMENTING ASYNCHRONOUS COLLECTIVE OPERATIONS IN A MULTI NODE PROCESSING SYSTEM U.S. patent application Ser. No. 13 008 546 filed Jan. 18 2011 for ATOMICITY A MULTI PRONGED APPROACH U.S. patent application Ser. No. 12 697 175 filed Jan. 29 2010 for I O ROUTING IN A MULTIDIMENSIONAL TORUS NETWORK U.S. patent application Ser. No. 12 684 287 filed Jan. 8 2010 for ARBITRATION IN CROSSBAR FOR LOW LATENCY U.S. patent application Ser. No. 12 684 630 filed Jan. 8 2010 for EAGER PROTOCOL ON A CACHE PIPELINE DATAFLOW U.S. patent application Ser. No. 12 723 277 filed Mar. 12 2010 for EMBEDDED GLOBAL BARRIER AND COLLECTIVE IN A TORUS NETWORK U.S. patent application Ser. No. 12 696 764 filed Jan. 29 2010 for GLOBAL SYNCHRONIZATION OF PARALLEL PROCESSORS USING CLOCK PULSE WIDTH MODULATION U.S. patent application Ser. No. 12 796 411 filed Jun. 8 2010 for GENERATION BASED MEMORY SYNCHRONIZATION IN A MULTIPROCESSOR SYSTEM WITH WEAKLY CONSISTENT MEMORY ACCESSES U.S. patent application Ser. No. 12 796 389 filed Jun. 8 2010 for BALANCING WORKLOAD IN A MULTIPROCESSOR SYSTEM RESPONSIVE TO PROGRAMMABLE ADJUSTMENTS IN A SYNCRONIZATION INSTRUCTION U.S. patent application Ser. No. 12 696 817 filed Jan. 29 2010 for HEAP STACK GUARD PAGES USING A WAKEUP UNIT U.S. patent application Ser. No. 61 293 603 filed Jan. 8 2010 for MECHANISM OF SUPPORTING SUB COMMUNICATOR COLLECTIVES WITH O 64 COUNTERS AS OPPOSED TO ONE COUNTER FOR EACH SUB COMMUNICATOR and U.S. patent application Ser. No. 12 774 475 filed May 5 2010 for REPRODUCIBILITY IN A MULTIPROCESSOR SYSTEM .

Generally hardware performance counters are extra logic added to the central processing unit CPU to track low level operations or events within the processor. For example there are counter events that are associated with the cache hierarchy that indicate how many misses have occurred at L1 L2 and the like. Other counter events indicate the number of instructions completed number of floating point instructions executed translation lookaside buffer TLB misses and others. A typical computing system provides a small number of counters dedicated to collecting and or recording performance events for each processor in the system. These counters consume significant logic area and cause high power dissipation. As such only a few counters are typically provided. Current computer architecture allows many processors or cores to be incorporated into a single chip. Having only a handful of performance counters per processor does not provide the ability to count many events simultaneously from each processor.

A distributed performance counter device in one aspect may include a plurality of first performance counter modules coupled to a plurality of processing cores the plurality of first performance counter modules operable to collect performance data associated with the plurality of processing cores respectively. A plurality of second performance counter modules may be coupled to a plurality of L2 cache units the plurality of second performance counter modules operable to collect performance data associated with the plurality of L2 cache units respectively. A central performance counter module may be operable to coordinate counter data from the plurality of first performance counter modules and the plurality of second performance modules. The central performance counter module the plurality of first performance counter modules and the plurality of second performance counter modules are connected by a daisy chain connection and the plurality of first performance counter modules and the plurality of second performance counter modules place respective count data on the daisy chain connection every predetermined cycle for transferring the count data to the central performance counter module for central storage.

A method for distributed performance counters in one aspect may include collecting local counter data information by a plurality of performance counters residing locally with respective plurality of processing units and L2 cache units. The method also may include placing on lower bits of a daisy chain bus the collected local counter data information by the plurality of performance counters at a predetermined interval of time specified on upper bits of the daisy chain bus. The method further may include storing by a central performance counter module the local counter data information placed on the lower bits of the daisy chain bus.

A computer readable storage medium storing a program of instructions executable by a machine to perform one or more methods described herein also may be provided.

Further features as well as the structure and operation of various embodiments are described in detail below with reference to the accompanying drawings. In the drawings like reference numbers indicate identical or functionally similar elements.

In one aspect the storage needed for majority of performance count data is centralized thereby achieving an area reduction. For instance only a small number of least significant bits are kept in the local units thus saving area. This allows each processor to keep a large number of performance counters e.g. 24 local counters per processor at low resolution e.g. 14 bits . To attain higher resolution counts the local counter unit periodically transfer its counter values counts to a central unit. The central unit aggregates the counts into a higher resolution count e.g. 64 bits . The local counters count a number of events e.g. up to the local counter capacity. Before the local counter overflow occurs it transfers its count to the central unit. Thus no counts are lost in the local counters. The count values may be stored in a memory device such as a single central Static Random Access Memory SRAM which provides high bit density. Using this approach it becomes possible to have multiples of performance counters supported per processor while still providing for very large e.g. 64 bit counter values.

In another aspect the memory or central SRAM may be used in multiple modes a distributed mode where each core or processor on a chip provides a relatively small number of counts e.g. 24 per processor as well as a detailed mode where a single core or processor can provide a much larger number of counts e.g. 116 .

In yet another aspect multiple performance counter data counts from multiple performance counters residing in multiple processing modules e.g. cores and cache modules may be collected via a single daisy chain bus in a predetermined number of cycles. The predetermined number of cycles depends on the number of performance counters per processing module the number of processing modules residing on the daisy chain bus and the number of bits that can be transferred at one time on the daisy chain. In the description herein the example configuration of the chip supports 24 local counters in each of its 17 cores 16 local counters in each of its 16 L2 cache units or modules. The daisy chain bus supports 96 bits of data. Other configurations are possible and the present invention is not limited only to that configuration.

In still yet another aspect the performance counter modules and monitoring of performance data may be programmed by user software. Counters of the present disclosure may be configured through memory access bus. The hardware modules of the present disclosure are configured as not privileged such that user program may access the counter data and configure the modules. Thus with the methodology and hardware set up of the present disclosure it is not necessary to perform kernel level operations such as system calls when configuring and gathering performance counts which can be costly Rather the counters are under direct user control.

Still yet in another aspect the performance counters and associated modules are physically placed near the cores or processing units to minimize overhead and data travel distance and to provide low latency control and configuration of the counters by the unit to which the counters are associated.

A processing node may have multiple processors or cores and associated L1 cache units L2 cache units a messaging or network unit and I O interfaces such as PCI Express. The performance counters of the present disclosure allow the gathering of performance data from such functions of a processing node and may present the performance data to software. A processing node also referred to as a chip herein such as an application specific integrated circuit ASIC may include but not limited to a plurality of cores with associated L1 cache prefetchers L1P . The processing node may also include but not limited to a plurality of L2 cache units a messaging network unit PCIe and Devbus connecting to a centralized counter unit referred to herein as UPC C . A core e.g. also referred to herein as a PU processing unit may include a performance monitoring unit or a performance counter referred to herein as UPC P. UPC P resides in the PU complex and gathers performance data from the associated core e.g. . Similarly an L2 cache unit e.g. may include a performance monitoring unit or a performance counter e.g. referred to herein as UPC L2. UPC L2 resides in the L2 module and gathers performance data from it. The terminology UPC universal performance counter is used in this disclosure synonymously or interchangeable with general performance counter functions.

UPC C may be a single centralized unit within the processing node and may be responsible for coordinating and maintaining count data from the UPC P and UPC L2 units. The UPC C unit also referred to as the UPC C module may be connected to the UPC P and UPC L2 via a daisy chain bus with the start and end of the daisy chain beginning and terminating at the UPC C . The performance counter modules i.e. UPC P UPC L2 and UPC C of the present disclosure may operate in different modes and depending on the operating mode the UPC C may inject packet framing information at the start of the daisy chain enabling the UPC P and or UPC L2 modules or units to place data on the daisy chain bus at the correct time slot. In a similar manner messaging network unit PCIe and Devbus may be connected via another daisy chain bus to the UPC C .

The performance counter functionality of the present disclosure may be divided into two types of units a central unit UPC C and a group of local units. Each of the local units performs a similar function but may have slight differences to enable it to handle for example a different number of counters or different event multiplexing within the local unit. For gathering performance data from the core and associated L1 a processor local UPC unit UPC P is instantiated within each processor complex. That is a UPC P is added to the processing logic. Similarly there may be a UPC unit associated with each L2 slice UPC L2 . Each UPC L2 and UPC P unit may include a small number of counters. For example the UPC P may include 24 14 bit counters while the UPC L2 counters may instantiate 16 10 bit counters. The UPC ring shown as solid line from 116 to 118 may be connected such that each UPC P or UPC L2 unit may be connected to its nearest neighbor. In one aspect the daisy chain may be implemented using only registers in the UPC units without extra pipeline latches.

Although not shown or described a person of ordinary skill in the art will appreciate that a processing node may include other units and or elements. The processing node may be an application specific integrated circuit ASIC or a general purpose processing node.

The UPC of the present disclosure may operate in different modes as described below. However the UPC is not limited to only those modes of operation.

In this operating mode also referred to as distributed count mode counts from multiple performance counters residing in each core or processing unit and L2 unit may be captured. For example in an example implementation of a chip that includes 17 cores each with 24 performance counters and 16 L2 units each with 16 performance counters 24 counts from 17 UPC P units and 16 counts from 16 UPC L2 units may be simultaneously captured. Local UPC P and UPC L2 counters are periodically transferred to a corresponding 64 bit counter residing in the central UPC unit UPC C over a 96 bit daisy chain bus. Partitioning the performance counter logic into local and central units allows for logic reduction but still maintains 64 bit fidelity of event counts. Each UPC P or UPC L2 module places its local counter data on the daisy chain 4 counters at a time or passes 96 bit data from its neighbor. The design guarantees that all local counters will be transferred to the central unit before they can overflow locally by guaranteeing a slot on the daisy chain at regular intervals . With a 14 bit local UPC P counter each counter is transferred to the central unit at least every 1024 cycles to prevent overflow of the local counters. In order to cover corner cases and minimize the latency of updating the UPC C counters each counter is transferred to the central unit every 400 cycles. For Network DevBus and PCIe a local UPC unit similar to UPC L2 and UPC P may be used for these modules.

In this mode the UPC C assists a single UPC P or UPC L2 unit in capturing performance data. More events can be captured in the mode from a single processor or core or L2 than can be captured in distributed count mode. However only one UPC P or UPC L2 may be examined at a time.

The UPC P and UPC L2 modules may be connected to the UPC C unit via a 96 bit daisy chain using a packet based protocol. Each UPC operating mode may use a different protocol. For example in Mode 0 or distributed mode each UPC P and or UPC L2 places its data on the daisy chain bus at a specific time e.g. cycle or cycles . In this mode the UPC C transmits framing information on the upper bits bits of the daisy chain. Each UPC P and or UPC L2 module uses this information to place its data on the daisy chain at the correct time. The UPC P and UPC L2 send their counter data in a packet on bits of the performance daisy chain. Bits are generated by the UPC C module and passed unchanged by the UPC P and or UPC L2 module. Table 1 2 defines example packets sent by UPC P. Table 1 3 defines example packets sent by UPC L2. Table 1 4 shows framing information injected by the UPC C. The packet formats and framing information may be pre programmed or hard coded in the logic of the processing.

Table 1 2 defines example packets sent by an UPC P. Each UPC P may follow this format. Thus the next UPC P may send packets on the next 16 cycles i.e. 16 31. The next UPC P may send packets on the next 16 cycles i.e. 32 47 and so forth. Table 1 5 shows an example of cycle to performance counter unit mappings.

Similar to UPC P the UPC L2 may place data from its counters e.g. 16 counters on the daisy chain in an 8 flit packet on daisy chain bits . This is shown in Table 1 3.

In this example format of both the UPC P and UPC L2 packet formats every other flit contains no data. Flit refers to one cycle worth of information. The UPC C uses these dead cycles to service memory mapped MMIO requests to the Static Random Access Memory SRAM counters or the like.

The UPC L2 and UPC P modules monitor the framing information produced by the UPC C. The UPC C transmits a repeating cycle count ranging from 0 to 399 decimal. Each UPC P and UPC L2 compares this count to a value based on its logical unit number and injects its packet onto the daisy chain when the cycle count matches the value for the given unit. The values compared by each unit are shown in Table 1 5.

In Mode 0 also referred to as distributed count mode each UPC P and UPC L2 may contribute counter data. It may be desirable to have the local units start and stop counting on the same cycle. To accommodate this the UPC C sends a counter start stop bit on the daisy chain. Each unit can be programmed to use this signal to enable or disable their local counters. Since each unit is on a different position on the daisy chain each unit delays a different number of cycles depending on their position in the daisy chain before responding to the counter start stop command from the UPC C. This delay value may be hard coded into each UPC P UPC L2 instantiation.

As described above Mode 1 also referred to as detailed count mode may be used to allow more counters per processor or L2 than what the local counters provide. In this mode a given UPC P or UPC L2 is selected for ownership of the daisy chain. The selected UPC P or UPC L2 sends 92 bits of real time performance event data to the UPC C for counting. In addition the local counters are transferred to the UPC C as in Mode 0. One daisy chain wire can be used to transmit information from all the performance counters in the processor e.g. all 24 performance counters. The majority of the remaining wires can be used to transfer events to the UPC C for counting. The local counters may be used in this mode to count any event presented to it. Also all local counters may by used for instruction decoding. In Mode 1 92 events may be selected for counting by the UPC C unit. 1 bit of the daisy chain is used to periodically transfer the local counters to the UPC C while 92 bits are used to transfer events. The three remaining bits are used to send control information and power gating signals to the local units. The UPC C sends a rotating count from 0 399 on daisy chain bits identically to Mode 0. The UPC P or UPC L2 that is selected for Mode 1 places it s local counters on bits in a similar fashion as Mode 0 e.g. when the local unit decodes a certain value of the ring counter.

Examples of the data sent by the UPC P are shown in Table 1 6. UPC L2 may function similarly for example with 32 different types of events being supplied. The specified bits may be turned on to indicate the selected events for which the count is being transmitted. Daisy chain bus bits specify control information such as the packet start signal on a given cycle.

The UPC P module may use the x1 and x2 clocks. It may expect the x1 and x2 clocks to be phase aligned removing the need for synchronization of x1 signals into the x2 domain.

As described above the UPC P module may operate in distributed count mode or detailed count mode. In distributed count mode Mode 0 a UPC P module may monitor performance events for example 24 performance events from its 24 performance counters. The daisy chain bus is time multiplexed so that each UPC P module sends its information to the UPC C in turn. In this mode the user may count 24 events per core for example.

In Mode 1 detailed count mode one UPC P module may be selected for ownership of the daisy chain bus. Data may be combined from the various inputs core performance bus core trace bus L1P events formatted and sent to the UPC C unit each cycle. The UPC C unit may decode the information provided on the daisy chain bus into as many as 116 92 wires for raw events and 24 for local counters separate events to be counted from the selected core or processor complex. For the raw events the UPC C module manages the low order bits of the count data similar to the way that the UPC P module manages its local counts.

Edge Level Polarity module may convert level signals emanating from the core s Performance bus into single cycle pulses suitable for counting. Each performance bit has a configurable polarity invert and edge filter enable bit available via a configuration register.

Widen module converts signals from one clock domain into another. For example the core s Performance Trace and Trigger busses all may run at clkx1 rate and are transitioned to the clkx2 domain before being processed by the UPC P. Widen module performs that conversion translating each died clock domain signal into 2 clkx2 signals even and odd . This module is optional and may be used if the rate at which events are output are different e.g. faster or slower than the rate at which events are accumulated at the performance counters.

QPU Decode module and execution unit XU Decode module take the incoming opcode stream from the trace bus and decode it into groups of instructions. In one aspect this module resides in the clkx2 domain and there may be two opcodes even and odd of each type XU and QPU to be decoded per clkx2 cycle. To accomplish this two QPU and two XU decode units may be instantiated. This applies to implementations where the core operates at twice the speed i.e. outputs 2 events per operating cycle of the performance counters as explained above. The 2 events saved by the widen module may be processed at the two QPU and two XU decode units. The decoded instruction stream is then sent to the counter blocks for selection and counting.

Registers module implements the interface to the MMIO bus. This module may include the global MMIO configuration registers and provide the support logic readback muxes partial address decode for registers located in the UPC P Counter units. User software may program the performance counter functions of the present disclosure via the MMIO bus.

Thread Combine module may combine identical events from each thread counts them and present a value for accumulation by a single counter. Thread Combine module may conserve counters when aggregate information across all threads is needed. Rather than using four counters or number of counters for each thread and summing in software summing across all threads may be done in hardware using this module. Counters may be selected to support thread combining.

The Mode 1 Compress module may combine event inputs from the core s event bus the local counters . . . and the L1 cache prefetch UP event bus and place them on the appropriate daisy chain lines for transmission to the UPC C using a predetermined packet format for example shown in Table 1 6. This module may divide the 96 bit bus into 12 Event groups with Event Group 0 7 containing 8 events and Event Groups 8 11 containing 7 events for a total of 92 events. Some event group bits can be sourced by several events. Not all events may connect to all event groups. Each event group may have a single multiplexer mux control spanning the bits in the event group.

There may be 24 UPC P Counter units in each UPC P module. To minimize muxing not all counters are connected to all events. Similarly all counters may be used to count opcodes but this is not required. Counters may be used to capture a given core s performance event or L1P event.

Referring to a core or processor may provide performance and trace data via busses. Performance Event Bus may provide information about the internal operation of the core. The bus may be 24 bits wide. The data may include performance data from the core units such as execution unit XU instruction unit IU floating point unit FPU memory management unit MMU . The core unit may multiplex mux the performance events for each unit internally before presenting the data on the 24 bit performance interface. Software may specify the desired performance event to monitor i.e. program the multiplexing for example using a device control register DCR or the like. The core may output the appropriate data on the performance bus according to the software programmed multiplexing.

The UPC P may include two output interfaces. A UPC P daisy chain bus used for transfer of UPC P data to the UPC C and a MMIO bus used for reading writing of configuration and count information from the UPC P.

The UPC L2 module may operate in distributed count mode Mode 0 or detailed count mode Mode 1 . In Mode 0 each UPC L2 module may monitor 16 performance events on its 16 performance counters. The daisy chain bus is time multiplexed so that each UPC L2 module sends its information to the UPC C in turn. In this mode the user may count 16 events per L2 slice. In Mode 1 one UPC L2 module is selected for ownership of the daisy chain bus. In this mode all 32 events supported by the L2 slice may be counted.

Referring back to a UPC C module may gather information from the PU L2 and Network Units and maintain 64 bit counts for each performance event. The UPC C may contain for example a 256Dx264W SRAM used for storing count and trace information.

The UPC C module may operate in different modes. In Mode 0 each UPC P and UPC L2 contribute 24 and 16 performance events respectively. In this way a coarse view of the entire ASIC may be provided. In this mode the UPC C Module sends framing information to the UPC P and UPC L2 modules to the UPC C. This information is used by the UPC P and UPC L2 to globally synchronize counter starting stopping and to indicate when each UPC P or UPC L2 should place its data on the daisy chain.

In Mode 1 one UPC L2 module or UPC P unit is selected for ownership of the daisy chain bus. All 32 events supported by a selected L2 slice may be counted and up to 116 events can be counted from a selected PU. A set of 92 counters local to the UPC C and organized into Central Counter Groups is used to capture the additional data from the selected UPC P or UPC L2.

The UPC P L2 Counter unit gathers performance data from the UPC P and UPC L2 units while the Network DMA IO Counter unit gathers event data from the rest of the ASIC e.g. input output I O events network events direct memory access DMA events etc.

UPC P L2 Counter Unit is responsible for gathering data from each UPC P and UPC L2 unit and accumulating in it in the appropriate SRAM location. The SRAM is divided into 32 counter groups of 16 counters each. In Mode 0 each counter group is assigned to a particular UPC P or UPC L2 unit. The UPC P unit has 24 counters and uses two counter groups per UPC P unit. The last 8 entries in the second counter group is unused by the UPC P. The UPC L2 unit has 16 counters and fits within a single counter group. For every count data there may exist an associated location in SRAM for storing the count data.

Software may read or write any counter from SRAM at any time. In one aspect data is written in 64 bit quantities and addresses a single counter from a single counter group.

In addition to reading and writing counters software may cause selected counters of an arbitrary counter group to be added to a second counter group with the results stored in a third counter group. This may be accomplished by writing to special registers in the UPC P L2 Counter Unit .

Concurrently with writing the result to memory the result is checked for a near overflow. If this condition has occurred a packet is sent over the daisy chain bus indicating the SRAM address at which the event occurred as well as which of the 4 counters in the SRAM has reached near overflow each 256 bit SRAM location stores 4 64 bit counters . Note that any combination of the 4 counters in a single SRAM address can reach near overflow on a given cycle. Because of this the counter identifier is sent as separate bits one bit for each counter in a single SRAM address on the daisy chain. The UPC P monitors the daisy chain for overflow packets coming from the UPC C. If the UPC P detects a near overflow packet associated with one or more of its counters it sets an interrupt arming bit for the identified counters. This enables the UPC P to issue an interrupt to its local processor on the next overflow of the local counter. In this way interrupts can be delivered to the local processor very quickly after the actual event that caused overflow typically within a few cycles.

Upon startup the UPC C sends an enable signal along the daisy chain. A UPC P L2 unit may use this signal to synchronize the starting and stopping of their local counters. It may also optionally send a reset signal to the UPC P and UPC L2 directing them to reset their local counts upon being enabled. The 96 bit daisy chain provides adequate bandwidth to support both detailed count mode and distributed count mode operation.

For operating in detailed count mode the entire daisy chain bandwidth can be dedicated to a single processor or L2. This greatly increases the amount of information that can be sent from a single UPC P or UPC L2 allowing the counting of more events. The UPC P module receives information from three sources core unit opcodes received via the trace bus performance events from the core unit and events from the LIP. In Mode 1 the bandwidth of the daisy chain is allocated to a single UPC P or UPC L2 and used to send more information. Global resources in the UPC C The Mode 1 Counter unit assist in counting performance events providing a larger overall count capability.

The UPC P module may contain decode units that provide roughly 50 groups of instructions that can be counted. These decode units may operate on 4 16 bit instructions simultaneously. In one aspect instead of transferring raw opcode information which may consume available bandwidth the UPC P local counters may be used to collect opcode information. The local counters are periodically transmitted to the UPC C for aggregation with the SRAM counter as in Mode 0. However extra data may be sent to the UPC C in the Mode 1 daisy chain packet. This information may include event information from the core unit and associated L1 prefetcher. Multiplexers in the UPC P can select the events to be sent to the UPC C. This approach may use 1 bit on the daisy chain.

The UPC C may have 92 local counters each associated with an event in the Mode 1 daisy chain packet. These counters are combined in SRAM with the local counters in the UPC P or L2. They are organized into 8 counter central counter groups. In total there may be 116 counters in mode 1 24 counters for instruction decoding and 92 for event counting .

The daisy chain input feeds events from the UPC P or UPC L2 into the Mode 1 Counter Unit for accumulation while UPC P counter information is sent directly to SRAM for accumulation. The protocol for merging the low order bits into the SRAM may be similar to Mode 0.

Each counter in the Mode 1 Counter Unit may correspond to a given event transmitted in the Mode 1 daisy chain packet.

The UPC counters may be started and stopped with fairly low overhead. The UPC P modules map the controls to start and stop counters into MMIO user space for low latency access that does not require kernel intervention. In addition a method to globally start and stop counters synchronously with a single command via the UPC C may be provided. For local use each UPC P unit can act as a separate counter unit with lower resolution controlled via local MMIO transactions. For example the UPC P Counter Data Registers may provide MMIO access to the local counter values. The UPC P Counter Control Register may provide local configuration and control of each UPC P counter.

Software may communicate with the UPC C via local Devbus access. In addition UPC C Counter Data Registers may give software access to each counter on an individual basis. UPC C Counter Control Registers may allow software to enable each local counter independently. The UPC units provide the ability to count and report various events via MMIO operations to registers residing in the UPC units which software may utilize via Performance Application Programming Interface PAPI Application Program Interface API .

A UPC C Accumulate Control Register may allow software to add counter groups to each other and place the result in a third counter group. This register may be useful for temporarily storing the added counts for instance in case the added counts should not count toward the performance data. An example of such counts would be when a processor executes instructions based on anticipated future execution flow that is the execution is speculative. If the anticipated future execution flow results in incorrect or unnecessary execution the performance counts resulting from those executions should not be counted.

At the same time or substantially the same time the local performance counter module also monitors for near overflow interrupt from the UPC C at . If there is an interrupt the local performance counter module may retrieve the information associated with the interrupt from the daisy chain bus and determine whether the interrupt is for any one of its performance counters. For example the SRAM location specified on the daisy chain associated with the interrupt is checked to determine whether that location is where the data of its performance counters are stored. If the interrupt is for any one of its performance counters the local performance counter module arms the counter to handle the near overflow. If a subsequent overflow of the counter in UPC P or UPC L2 occurs the UPC P or UPC L2 may optionally freeze the bits in the specified performance counter as well as generate an interrupt.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The computer program product may comprise all the respective features enabling the implementation of the methodology described herein and which when loaded in a computer system is able to carry out the methods. Computer program software program program or software in the present context means any expression in any language code or notation of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following a conversion to another language code or notation and or b reproduction in a different material form.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements if any in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

Various aspects of the present disclosure may be embodied as a program software or computer instructions embodied in a computer or machine usable or readable medium which causes the computer or machine to perform the steps of the method when executed on the computer processor and or machine. A program storage device readable by a machine tangibly embodying a program of instructions executable by the machine to perform various functionalities and methods described in the present disclosure is also provided.

The system and method of the present disclosure may be implemented and run on a general purpose computer or special purpose computer system. The computer system may be any type of known or will be known systems and may typically include a processor memory device a storage device input output devices internal buses and or a communications interface for communicating with other computer systems in conjunction with communication hardware and software etc.

The terms computer system and computer network as may be used in the present application may include a variety of combinations of fixed and or portable computer hardware software peripherals and storage devices. The computer system may include a plurality of individual components that are networked or otherwise linked to perform collaboratively or may include one or more stand alone components. The hardware and software components of the computer system of the present application may include and may be included within fixed and portable devices such as desktop laptop server. A module may be a component of a device software program or system that implements some functionality which can be embodied as software hardware firmware electronic circuitry or etc.

The embodiments described above are illustrative examples and it should not be construed that the present invention is limited to these particular embodiments. Thus various changes and modifications may be effected by one skilled in the art without departing from the spirit or scope of the invention as defined in the appended claims.

