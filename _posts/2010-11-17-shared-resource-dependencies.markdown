---

title: Shared resource dependencies
abstract: Described herein are methods for sharing resource dependencies between applications stored on a system. For example, in at least certain embodiments, a computer-implemented method for sharing resource dependencies includes installing or initiating installation of multiple application bundles having one or more applications and respective resources on the system. Next, an installer determines identifiers (e.g., hash signatures) for first and second resources and determines whether the resources are identical if an identifier for the first resource matches an identifier for the second resource. Then, a link is created from the second application bundle to the first resource of the first application bundle if the first resource is identical to the second resource. The second resource may be removed from the system if it has been installed. Alternatively, installation of the second resource is terminated if it has not been installed on the system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08694981&OS=08694981&RS=08694981
owner: Apple Inc.
number: 08694981
owner_city: Cupertino
owner_country: US
publication_date: 20101117
---
Embodiments of the present invention relate to methods for sharing resource dependencies within a system.

Various devices such as electronic devices computing systems portable devices and handheld devices have applications suites with various software applications that share resources e.g. a framework of supporting libraries . A software framework is an abstraction in which common code providing generic functionality can be selectively overwritten or specialized by user code providing specific functionality. Frameworks are a special case of software libraries in that they are reusable codes wrapped in a well defined application programming interface API . A framework distinguishes from a library or normal user application in that the overall program s flow of control is not dictated by the caller but by the framework. Software applications that share a framework will have the same look and feel based on sharing the same framework.

If an entire application suite is purchased and installed together then space in non volatile storage of a system is saved by linking all of the applications in the suite to the same framework. However if the applications are purchased and installed separately then multiple copies of an identical framework may be installed. The multiple copies of the identical framework are loaded into volatile memory when the corresponding applications are executed. The multiple copies of the identical framework require additional storage space in the non volatile storage and the volatile memory.

Described herein are methods for sharing resource dependencies between applications stored on a system. For example in at least certain embodiments a computer implemented method for sharing resource dependencies includes installing multiple application bundles each having one or more applications and resources e.g. frameworks directory of files on the system. Next an installer determines identifiers e.g. hash signatures for first and second resources and determines whether the resources are identical if an identifier for the first resource matches an identifier for the second resource. The second resource can be removed from the system and a link is created from the second application bundle to the first resource if the first resource is identical to the second resource.

In an embodiment a computer implemented method for sharing resource dependencies includes initiating installation of one or more application s and respective resource s on the system. For example a first application and a first resource may be installed on the system. An identifier for the first resource may be stored on the system. Next an installer determines an identifier e.g. hash signatures for a second resource that may be installed and compares this identifier to the identifier for the previously installed first resource. Then if the identifiers match the installer determines whether the resources are identical. A link is created from the second resource to a link of the first resource if the first resource is identical to the second resource. The installation of the second resource which has been initiated is then terminated.

The present disclosure includes systems and devices that perform these methods including data processing systems which perform these methods and machine readable media which when executed on data processing systems cause the systems to perform these methods.

Described herein are methods for sharing resource dependencies between applications stored on a system. For example in at least certain embodiments a computer implemented method for sharing resource dependencies includes installing or initiating installation of multiple application bundles that include one or more applications respective resources embedded code and other resources on the system. Next an installer determines identifiers e.g. hash signatures for first and second resources and determines whether the resources are identical if an identifier for the first resource matches an identifier for the second resource. Then a link is created from the second application bundle to the first resource if the first resource is identical to the second resource. The second resource can be removed from the system if it has been installed. Alternatively installation of the second resource is terminated if it has not been installed on the system.

In one embodiment a system includes a storage unit e.g. non volatile storage disk drive flash memory etc. . At block the processing logic e.g. installer installs a first application bundle that includes one or more applications respective resources e.g. frameworks other resources etc. Resources may include frameworks any directory of files any file system sub tree of files. Examples of types of shared resources include sets of audio loops clip art photos reference libraries e.g. spelling check dictionary etc. etc. The first application bundle may include a first application e.g. documents spreadsheets presentations games music creation etc. a first resource other resources etc. onto the system. A link e.g. hard link symbolic link or symlink or soft link may exist between the first application and the associated or embedded first resource. A hard link is a directory entry that associates a name with a file on a file system. A directory is a special kind of file that contains a list of such entries. Hard links may not normally point to directories and may not link paths on different volumes or file systems. Symbolic links may point to any file or directory irrespective of the volumes on which the source and destination reside. The link is a feature of a file system that enables multiple links to be created for the same file while only having one copy of the file saved to the storage unit or other location. The first application and first resource may be stored in the storage unit. A link may exist between the first resource and memory e.g. RAM cache memory . At block the processing logic determines a first identifier e.g. hash signature of the first resource and stores the first identifier in memory e.g. cache memory . At block the processing logic e.g. installer can install a second application bundle that includes one more applications respective resources other resources etc. The second application bundle may include a second application e.g. documents spreadsheets presentations games music creation etc. and an associated or embedded second resource on the system. The second application and second resource may be stored in the storage unit. At block the processing logic of the system can determine a second identifier for the second resource and optionally store the second identifier in memory e.g. cache memory . At block the processing logic can determine whether the second identifier matches the first identifier by comparing the second identifier to the first identifier that is stored in memory. In one embodiment the identifiers are hash signatures of a respective resource. At block if the identifiers match then the processing logic can optionally determine whether the first resource is identical to the second resource by comparing additional signature files e.g. property list files of the first resource with additional signature files e.g. property list files of the second resource. The signature files may include permission sets pathnames filenames etc. The signature files may also be stored in the memory e.g. cache memory . An installation package may include installer metadata e.g length of data contained in a file timestamp etc. which may also be stored in the memory.

At block if the first and second identifiers match then processing logic can remove the second resource from the system. The second resource may be removed from the storage unit. Alternatively the second resource can be removed at a later time e.g. after block . If the first and second applications are launched then the first and second applications and the first resource will be loaded into memory e.g. RAM of the system.

At block if the first and second identifiers match then the processing logic can create a link from the second application bundle to the first resource. Alternatively if the first and second identifiers match and the signature files of the first and second resources are the same then the processing logic can create a link from the second application bundle to the first resource. In one embodiment a link is created from the second application bundle to the shared first resource which is pointed to by the link to first application bundle and the link to memory. In this case a reference count assigned by a reference counter in a file system is incremented for the first resource because of the new link to the second application bundle. The reference counter can count how many applications and what applications refer to and use a resource. If the first and second applications are launched then the first and second applications and the first resource will be loaded into memory e.g. RAM of the system.

For a conventional approach if the first and second applications are launched then the first and second applications and first and second resources will be loaded into memory e.g. RAM of the system.

Returning to block if the identifiers do not match then the processing logic determines that the first resource is different than the second resource at block . Thus the second application and second resource remain on the system. A link may exist between the second resource and memory e.g. RAM cache memory . In one embodiment the first resource is a first framework that is associated with the first application and the second resource is a second framework that is associated with the second application.

Returning to block if the resources are not identical then the processing logic can determine that the resources are different or at least represent different versions of the same resource at block . Thus the second application and second resource remain on the system. A link may exist between the second resource and memory e.g. RAM cache memory . In this manner if a third resource is installed then the method can be applied such that a third identifier associated with the third resource is compared to the first and second identifiers. The third resource may not be stored on the system if the third identifier matches the first or second identifier.

In one embodiment a system includes a storage unit e.g. non volatile storage disk drive flash memory etc. . At block the processing logic e.g. installer installs a first application bundle that includes one or more applications respective resources other resources etc. Resources may include frameworks any directory of files any file system sub tree of files etc. The first application bundle may include a first application e.g. documents spreadsheets presentations games music creation etc. a first resource other resources etc. onto the system. A link e.g. hard link symbolic link may exist between the first application and the associated or embedded first resource. The link is a feature of a file system that enables multiple links to be created for the same file while only having one copy of the file saved to the storage unit or other location. The first application and first resource may be stored in the storage unit. A link may exist between the first resource and memory e.g. RAM cache memory . At block the processing logic determines a first identifier e.g. hash signature of the first resource and stores the first identifier in memory e.g. cache memory . At block the processing logic e.g. installer can initiate installation of a second application bundle that includes one more applications respective resources other resources etc. The second application bundle may include a second application e.g. documents spreadsheets presentations games music creation etc. and an associated or embedded second resource on the system. The second application and second resource may not be stored in the storage unit at this time. At block the processing logic of the system can determine a second identifier for the second resource and optionally store the second identifier in memory e.g. cache memory . At block the processing logic can determine whether the second identifier matches the first identifier by comparing the second identifier to the first identifier that is stored in memory e.g. cache memory . In one embodiment the identifiers are hash signatures of a respective resource e.g. framework . At block if the identifiers match then the processing logic can optionally determine whether the first resource is identical to the second resource by comparing additional signature files e.g. property list files of the first resource with additional signature files e.g. property list files of the second resource. The signature files may include permission sets pathnames filenames etc. The signature files may also be stored in the memory e.g. cache memory . An installation package may include installer metadata e.g length of data contained in a file timestamp etc. which may also be stored in the memory.

At block if the first and second identifiers match then the processing logic can create a link from the second application bundle to the first resource. Alternatively if the first and second identifiers match and the signature files e.g. property list files of the first and second resources are the same then the processing logic can create a link from the second application bundle to the first resource. In one embodiment a link is created from the second application bundle to shared first resource which is pointed to by the link to first application bundle and the link to memory. In this case an initial or default reference count assigned by a reference counter of the file system is incremented for the first resource because of the new link to the second application bundle. At block the processing logic completes installation of the second application and terminates installation of the second resource onto the system. If the first and second applications are launched then the first and second applications and the first resource will be loaded into memory e.g. RAM of the system.

For a conventional approach if the first and second applications are launched then the first and second applications and first and second resources will be loaded into memory e.g. RAM of the system.

Returning to block if the identifiers do not match then the processing logic determines that the first resource is different than the second resource at block . In one embodiment the first resource is a first framework that is associated with the first application and the second resource is a second framework that is associated with the second application. Thus the processing logic completes installation of the second application and second resource onto the system at block . A link may exist between the second resource and memory e.g. RAM cache memory .

Returning to block if the resources are not identical then the processing logic can determine that the resources are different or at least represent different versions of the same resource at block . Thus the processing logic completes installation of the second application and second resource onto the system at block . A link may exist between the second resource and memory e.g. RAM cache memory . In this manner if installation for a third resource is initiated then the method can be applied such that a third identifier associated with the third resource is compared to the first and second identifiers. The installation of the third resource may not be completed if the third identifier matches the first or second identifier.

Memory e.g. cache memory memory in the storage unit includes installer metadata and identifiers of resources. In one embodiment an identifier of resource is saved in memory . The memory includes a folder that includes a resource identifier e.g. hash signature 1234.FW and additional signature files e.g. property list files such as 1234.plist for the resource e.g. 1234.meta . In an embodiment an installer can install the application and resource and then determine whether an identifier e.g. hash signature for the resource matches the identifier . The installer can also determine whether the signature files e.g. property list files for resource match signature files e.g. property list files for resource . If so then the resource is identical to the resource with both resources have the same version. In this case the installer can create a link from application bundle e.g. resource to resource . The reference count for the resource is incremented based on the link to application bundle . The installer also removes resource if it has been installed in accordance with computer implemented method or terminates the installation of resource if it has not been installed in accordance with computer implemented method . In one embodiment the resource is a framework that is associated with the application and the second resource is a framework that is associated with the application .

The matching of the identifiers may result in a false positive. For example the hash signature of resource may match the hash signature of resource . However these resources may not actually be identical. In this case the comparison of the signature files e.g. property list files can be used to determine that the resources and are actually different even though the hash signatures are the same. The signature files e.g property list files can have file or path names that are different indicating that the resources are different.

Resource e.g. framework signature s e.g. cryptographic hash function such as SHA 1 of data names permissions etc and sub signatures e.g. SHA 1 of data name permissions etc are stored in the memory e.g. cache memory to avoid the need to re compute all of the shared frameworks signatures for every run of the cache tool. Alternatively the data can be stored in cache memory and revalidated before creating a link. This implementation is more robust in case the framework is altered after the framework is added to the cache.

In an embodiment if the one of the applications is deleted then the reference count for resource is decremented. The reference count for resource may be one plus the number of installed applications using it. In this case the resource has a reference count of two based on the other application that refers to the resource and a link to a copy of the resource in cache. If both applications are deleted then the reference count is decremented to one for the resource and the cache s link. A cache tool may remove the final link i.e. the link to the copy of the resource in cache causing this resource to be removed from the system.

Memory e.g. cache memory memory in the storage unit includes installer metadata and identifiers of resources. In one embodiment an identifier of resource is saved in memory . The memory includes a folder that includes a resource identifier e.g. hash signature 1234.FW and signature files e.g. 1234.plist for the resource . The signature files e.g. property list files may store a user s settings information about bundles and applications filenames filepaths etc. The memory also includes a folder that includes a resource identifier e.g. hash signature 5678.FW and signature files e.g. 5678.plist for the resource .

In an embodiment an installer can install the application and resource and then determine whether an identifier e.g. hash signature for the resource matches the identifier for the resource . The installer can also determine whether metadata or signature files for resource matches metadata or signature files for resource . If so then the resource is identical to the resource with both resources having the same version. Alternatively the identifiers and are different indicating that the resources are different or have different versions. The resources and will remain in the storage unit if previously installed or installation will complete.

Attention is now directed towards embodiments of a system architecture that may be embodied within any portable or non portable device including but not limited to a communication device e.g. mobile phone smart phone a multi media device e.g. MP3 player TV radio a portable or handheld computer e.g. tablet netbook laptop a desktop computer an All In One desktop a peripheral device or any other system or device adaptable to the inclusion of system architecture including combinations of two or more of these types of devices. is a block diagram of one embodiment of system that generally includes one or more computer readable non transitory storage mediums processing system Input Output I O subsystem radio frequency RF circuitry and audio circuitry . These components may be coupled by one or more communication buses or signal lines .

It should be apparent that the architecture shown in is only one example architecture of system and that system could have more or fewer components than shown or a different configuration of components. The various components shown in can be implemented in hardware software firmware or any combination thereof including one or more signal processing and or application specific integrated circuits.

RF circuitry is used to send and receive information over a wireless link or network to one or more other devices and includes well known circuitry for performing this function. RF circuitry and audio circuitry are coupled to processing system via peripherals interface . Interface includes various known components for establishing and maintaining communication between peripherals and processing system . Audio circuitry is coupled to audio speaker and microphone and includes known circuitry for processing voice signals received from interface to enable a user to communicate in real time with other users. In some embodiments audio circuitry includes a headphone jack not shown .

Peripherals interface couples the input and output peripherals of the system to processor and computer readable medium . One or more processors communicate with one or more computer readable mediums via controller . Computer readable medium can be any device or medium e.g. storage unit storage device non transitory storage medium that can store code and or data for use by one or more processors . Medium can include a memory hierarchy including but not limited to cache main memory and secondary memory. The memory hierarchy can be implemented using any combination of RAM e.g. SRAM DRAM DDRAM ROM FLASH magnetic and or optical storage devices such as disk drives magnetic tape CDs compact disks and DVDs digital video discs . Medium may also include a transmission medium for carrying information bearing signals indicative of computer instructions or data with or without a carrier wave upon which the signals are modulated . For example the transmission medium may include a communications network including but not limited to the Internet also referred to as the World Wide Web intranet s Local Area Networks LANs Wide Local Area Networks WLANs Storage Area Networks SANs Metropolitan Area Networks MAN and the like.

One or more processors run various software components stored in medium to perform various functions for system . In some embodiments the software components include operating system communication module or set of instructions touch processing module or set of instructions graphics module or set of instructions one or more applications or set of instructions and installer module or set of instructions . In an embodiment an installer application is associated with a installer module . Each of these modules and above noted applications correspond to a set of instructions for performing one or more functions described above and the methods described in this application e.g. the computer implemented methods and other information processing methods described herein . These modules i.e. sets of instructions need not be implemented as separate software programs procedures or modules and thus various subsets of these modules may be combined or otherwise rearranged in various embodiments.

In some embodiments medium may store a subset of the modules and data structures identified above. Furthermore medium may store additional modules and data structures not described above.

Operating system includes various procedures sets of instructions software components and or drivers for controlling and managing general system tasks e.g. memory management storage device control power management etc. and facilitates communication between various hardware and software components.

Communication module facilitates communication with other devices over one or more external ports or via RF circuitry and includes various software components for handling data received from RF circuitry and or external port .

Graphics module includes various known software components for rendering animating and displaying graphical objects on a display surface. In embodiments in which touch I O device is a touch sensitive display e.g. touch screen graphics module includes components for rendering displaying and animating objects on the touch sensitive display.

One or more applications can include any applications installed on system including without limitation a collaborative application a browser address book contact list email instant messaging word processing keyboard emulation widgets JAVA enabled applications encryption digital rights management voice recognition voice replication location determination capability such as that provided by the global positioning system GPS a music player etc.

Touch processing module includes various software components for performing various tasks associated with touch I O device including but not limited to receiving and processing touch input received from I O device via touch I O device controller .

System may further include installer module e.g. installer for performing the method functions as described herein in connection with . In one embodiment the installer module may at least function to install applications bundles with applications and resources and share resource dependencies. For example the installer module may installing multiple applications and respective resources on the system. Next the installer module may determine identifiers e.g. hash signatures for first and second resources and may determine whether the resources are identical if an identifier for the first resource matches an identifier for the second resource. Then a link e.g. hard link symbolic link is created from the second application bundle to the first resource if the first resource is identical to the second resource. The second resource may be removed from the system if the second resource has been installed to the system. Alternatively if the second resource has not been installed then the installation is terminated.

In an embodiment cache memory stores one or more identifiers of the resources and signature files e.g property list files for the resources. The cache memory may be located in processing system or anywhere in the system such as within medium . The functions features of the present disclosure may be implemented with the installer module and cache memory as part of a file system cache or file system compression. The installer module may compare a signature file e.g property list file for the first resource to a signature file e.g property list file for the second resource in order to determine whether the resources are identical.

Module may also interact with an installer application to provide the methods and functionality described herein. Module may be embodied as hardware software firmware or any combination thereof. Although module is shown to reside within medium all or portions of module may be embodied within other components within system or may be wholly embodied as a separate component within system .

In one embodiment system includes a storage unit to store a first application and an associated first resource a processing system coupled to the storage unit a cache memory coupled to the processing system and an installer module with one or more programs. The one or more programs are configured to be executed by the processing system. The programs include instructions to install a second application and an associated second resource on the storage unit instructions to determine a second identifier for the second resource instructions to determine whether the second identifier matches a first identifier of the first resource and instructions to determine whether the first resource is identical to the second resource if the first identifier matches the second identifier.

The programs may further include instructions to create a link from the second application bundle to the first resource if the first resource is identical to the second resource and instructions to remove the second resource from the storage unit. The first identifier for the first resource may include a hash signature of the first resource and the second identifier for the second resource may include a hash signature of the second resource. The determining of whether the first resource is identical to the second resource if the first identifier matches the second identifier may be based on a comparison of signature files e.g property list files of the first resource and signature files e.g property list files of the second resource. The determining of whether the second identifier matches a first identifier of the first resource may include comparing the second identifier to the first identifier which is stored in the cache memory . In one embodiment the first resource includes a first framework or a first directory of files and the second resource includes a second framework or a second directory of files.

I O subsystem is coupled to touch I O device and one or more other I O devices for controlling or performing various functions. Touch I O device communicates with processing system via touch I O device controller which includes various components for processing user touch input e.g. scanning hardware . One or more other input controllers receives sends electrical signals from to other I O devices . Other I O devices may include physical buttons dials slider switches sticks keyboards touch pads additional display screens or any combination thereof.

If embodied as a touch screen touch I O device displays visual output to the user in a GUI. The visual output may include text graphics video and any combination thereof. Some or all of the visual output may correspond to user interface objects. Touch I O device forms a touch sensitive surface that accepts touch input from the user. Touch I O device and touch screen controller along with any associated modules and or sets of instructions in medium detects and tracks touches or near touches and any movement or release of the touch on touch I O device and converts the detected touch input into interaction with graphical objects such as one or more user interface objects. In the case in which device is embodied as a touch screen the user can directly interact with graphical objects that are displayed on the touch screen. Alternatively in the case in which device is embodied as a touch device other than a touch screen e.g. a touch pad the user may indirectly interact with graphical objects that are displayed on a separate display screen embodied as I O device .

Touch I O device may be analogous to the multi touch sensitive surface described in the following U.S. Pat. No. 6 323 846 Westerman et al. U.S. Pat. No. 6 570 557 Westerman et al. and or U.S. Pat. No. 6 677 932 Westerman and or U.S. Patent Publication 2002 0015024A1 each of which is hereby incorporated by reference in its entirety.

Embodiments in which touch I O device is a touch screen the touch screen may use LCD liquid crystal display technology LPD light emitting polymer display technology OLED organic LED or OEL organic electro luminescence although other display technologies may be used in other embodiments.

Feedback may be provided by touch I O device based on the user s touch input as well as a state or states of what is being displayed and or of the computing system. Feedback may be transmitted optically e.g. light signal or displayed image mechanically e.g. haptic feedback touch feedback force feedback or the like electrically e.g. electrical stimulation olfactory acoustically e.g. beep or the like or the like or any combination thereof and in a variable or non variable manner.

System also includes power system for powering the various hardware components and may include a power management system one or more power sources a recharging system a power failure detection circuit a power converter or inverter a power status indicator and any other components typically associated with the generation management and distribution of power in portable devices.

In some embodiments peripherals interface one or more processors and memory controller may be implemented on a single chip such as processing system . In some other embodiments they may be implemented on separate chips.

In certain embodiments of the present disclosure the system can be used to implement at least some of the methods discussed in the present disclosure.

Some portions of the detailed descriptions are presented in terms of algorithms which include operations on data stored within a computer memory. An algorithm is generally a self consistent sequence of operations leading to a desired result. The operations typically require or involve physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like can refer to the action and processes of a data processing system or similar electronic device that manipulates and transforms data represented as physical electronic quantities within the system s registers and memories into other data similarly represented as physical quantities within the system s memories or registers or other such information storage transmission or display devices.

The present disclosure can relate to an apparatus for performing one or more of the operations described herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a machine e.g. computer readable non transitory storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs erasable programmable ROMs EPROMs electrically erasable programmable ROMs EEPROMs flash memory magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a bus.

A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example machines store and communicate internally and with other devices over a network code and data using machine readable media such as machine storage media e.g. magnetic disks optical disks random access memory read only memory flash memory devices phase change memory .

One or more Application Programming Interfaces APIs may be used in some embodiments. An API is an interface implemented by a program code component or hardware component hereinafter API implementing component that allows a different program code component or hardware component hereinafter API calling component to access and use one or more functions methods procedures data structures classes and or other services provided by the API implementing component. An API can define one or more parameters that are passed between the API calling component and the API implementing component.

An API allows a developer of an API calling component which may be a third party developer to leverage specified features provided by an API implementing component. There may be one API calling component or there may be more than one such component. An API can be a source code interface that a computer system or program library provides in order to support requests for services from an application. An operating system OS can have multiple APIs to allow applications running on the OS to call one or more of those APIs and a service such as a program library can have multiple APIs to allow an application that uses the service to call one or more of those APIs. An API can be specified in terms of a programming language that can be interpreted or compiled when an application is built.

In some embodiments the API implementing component may provide more than one API each providing a different view of or with different aspects that access different aspects of the functionality implemented by the API implementing component. For example one API of an API implementing component can provide a first set of functions and can be exposed to third party developers and another API of the API implementing component can be hidden not exposed and provide a subset of the first set of functions and also provide another set of functions such as testing or debugging functions which are not in the first set of functions. In other embodiments the API implementing component may itself call one or more other components via an underlying API and thus be both an API calling component and an API implementing component.

An API defines the language and parameters that API calling components use when accessing and using specified features of the API implementing component. For example an API calling component accesses the specified features of the API implementing component through one or more API calls or invocations embodied for example by function or method calls exposed by the API and passes data and control information using parameters via the API calls or invocations. The API implementing component may return a value through the API in response to an API call from an API calling component. While the API defines the syntax and result of an API call e.g. how to invoke the API call and what the API call does the API may not reveal how the API call accomplishes the function specified by the API call. Various API calls are transferred via the one or more application programming interfaces between the calling API calling component and an API implementing component. Transferring the API calls may include issuing initiating invoking calling receiving returning or responding to the function calls or messages in other words transferring can describe actions by either of the API calling component or the API implementing component. The function calls or other invocations of the API may send or receive one or more parameters through a parameter list or other structure. A parameter can be a constant key data structure object object class variable data type pointer array list or a pointer to a function or method or another way to reference a data or other item to be passed via the API.

Furthermore data types or classes may be provided by the API and implemented by the API implementing component. Thus the API calling component may declare variables use pointers to use or instantiate constant values of such types or classes by using definitions provided in the API.

Generally an API can be used to access a service or data provided by the API implementing component or to initiate performance of an operation or computation provided by the API implementing component. By way of example the API implementing component and the API calling component may each be any one of an operating system a library a device driver an API an application program or other module it should be understood that the API implementing component and the API calling component may be the same or different type of module from each other . API implementing components may in some cases be embodied at least in part in firmware microcode or other hardware logic. In some embodiments an API may allow a client program e.g. game center application to use the services provided by a Software Development Kit SDK library. In other embodiments an application or other client program may use an API provided by an Application Resource. In these embodiments the application or client program may incorporate calls to functions or methods provided by the SDK and provided by the API or use data types or objects defined in the SDK and provided by the API. An Application Resource may in these embodiments provide a main event loop for a program that responds to various events defined by the Resource. The API allows the application to specify the events and the responses to the events using the Application Resource. In some implementations an API call can report to an application the capabilities or state of a hardware device including those related to aspects such as input capabilities and state output capabilities and state processing capability power state storage capacity and state communications capability etc. and the API may be implemented in part by firmware microcode or other low level logic that executes in part on the hardware component.

The API calling component may be a local component i.e. on the same data processing system as the API implementing component or a remote component i.e. on a different data processing system from the API implementing component that communicates with the API implementing component through the API over a network. It should be understood that an API implementing component may also act as an API calling component i.e. it may make API calls to an API exposed by a different API implementing component and an API calling component may also act as an API implementing component by implementing an API that is exposed to a different API calling component.

The API may allow multiple API calling components written in different programming languages to communicate with the API implementing component thus the API may include features for translating calls and returns between the API implementing component and the API calling component however the API may be implemented in terms of a specific programming language. An API calling component can in one embedment call APIs from different providers such as a set of APIs from an OS provider and another set of APIs from a plug in provider and another set of APIs from another provider e.g. the provider of a software library or creator of the another set of APIs.

It will be appreciated that the API implementing component may include additional functions methods classes data structures and or other features that are not specified through the API and are not available to the API calling component . It should be understood that the API calling component may be on the same system as the API implementing component or may be located remotely and accesses the API implementing component using the API over a network. While illustrates a single API calling component interacting with the API it should be understood that other API calling components which may be written in different languages or the same language than the API calling component may use the API .

The API implementing component the API and the API calling component may be stored in a machine readable medium e.g. computer readable medium which includes any mechanism for storing information in a form readable by a machine e.g. a computer or other data processing system . For example a machine readable medium includes magnetic disks optical disks random access memory read only memory flash memory devices etc.

In Software Stack in one embodiment of the present invention applications can make calls to Services A or B using several Service APIs and to Operating System OS using several OS APIs. Services A and B can make calls to OS using several OS APIs.

Note that the Service has two APIs one of which Service API receives calls from and returns values to Application and the other Service API receives calls from and returns values to Application . Service which can be for example a software library makes calls to and receives returned values from OS API and Service which can be for example a software library makes calls to and receives returned values from both OS API and OS API . Application makes calls to and receives returned values from OS API .

In the foregoing specification the disclosure has been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the disclosure as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

