---

title: Embedding dynamic information in electronic devices
abstract: Disclosure is directed to dynamically creating and embedding code and/or data in an electronic device. In one aspect, data objects are checked for conformance with a schema to prevent incorporation of incorrectly functioning data objects. A debugger may be provided to facilitate source level debugging. In another aspect, embedded interfaces are constructed to access the functionality of certain system components. Additionally, schemas may be complied into code header and files and automatically included in code libraries.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09342435&OS=09342435&RS=09342435
owner: EchoStar Technologies L.L.C.
number: 09342435
owner_city: Englewood
owner_country: US
publication_date: 20101027
---
This application claims priority to Patent Cooperation Treaty No. PCT IB2010 002864 filed Oct. 27 2010. This Patent Cooperation Treaty patent application claims priority to U.S. provisional application No. 61 255 376 filed Oct. 27 2009 and entitled EMBEDDING DYNAMIC INFORMATION IN ELECTRONIC DEVICES the contents of which are incorporated herein by reference in their entirety.

Embodiments discussed herein are directed to dynamically creating and embedding code and or data in an electronic device.

Programmers of embedded devices face a variety of design and implementation problems when using software development tools such as the JavaScript Object Notation JSON format. The complexity of these software tools may prevent programmers from rapidly constructing embedded interfaces that access the state and or behavior of a system component. These limitations may frustrate design goals such as for example interoperability stability scalability memory use and so. Accordingly improved code development tools may be desirable.

Embodiments discussed herein are directed to dynamically creating and embedding code and or data in an electronic device. In one aspect data objects are checked for conformance with a schema to prevent incorporation of incorrectly functioning data objects. A debugger may be provided to facilitate source level debugging. In another aspect embedded interfaces are constructed to access the functionality of certain system components. Additionally schemas may be complied into code header and files and automatically included in code libraries.

One embodiment is directed to an apparatus for embedding a library in a program comprising a compiler operative to receive one or more sources and output a library the compiler further operative to output a debugger based on the one or more sources the debugger operative to receive one or more schema and output one or more embedded program sources based on the one or more schema the compiler further operative to accept the one or more embedded program sources and output a binary object and a linker operative to accept the binary object and the library the linker further operative to output a program having a library embedded therein.

Another embodiment is directed to a method for embedding a library in a program comprising receiving one or more sources at a compiler outputting a library from the compiler the library based on the one or more sources outputting a debugger from the compiler based on the one or more sources receiving one or more schema at the debugger outputting one or more embedded program sources from the debugger based on the one or more schema accepting the one or more embedded program sources at the compiler outputting a binary object from the compiler based on the one or more embedded program sources and accepting the binary object and the library at a linker outputting a program having a library embedded therein from the linker.

Certain embodiments take the form of a software development kit SDK for JavaScript Object Notation JSON that includes among other elements to be discussed herein a Schema Application Programming Interface Schema API . This SDK and all associated functionality is typically resident on or in an electronic device such as a set top box cable box television audiovisual receiver or other television receiver. The SDK through the API generally provides a structured environment and front end for dynamically creating and manipulating JSON data during operation e.g. run time of an electronic device or certain operations on such a device This in turn permits the use and or implementation of various schemas. A schema essentially acts as a contract between two or more components or applications of the electronic device permitting or regulating data flow therebetween. It should be noted that alternative embodiments may take the form of a SDK or other front end for a platform independent package other than JavaScript or particularly other than JSON.

Examples of a JSON SDK design are object oriented and platform independent. As one non limiting example the SDK may be implemented and embedded in any environment that includes compiles or may otherwise execute ANSI C90. As another example the SDK may be implemented in Java. In short the design of the SDK is relatively platform independent. An SDK library may be embedded as part of any program as shown to best effect in .

A user interface permits a user to interact with the electronic device typically by issuing one or more commands to the processor . Such commands may relate to the operation of the device and or to objects accessed via the schema API. As one example the user interface may permit a user to initiate a command to an object which in turn may activate or deactivate a function or element of the device. Continuing the example the command may employ an object conforming to an LED schema to turn an LED on or off Example user interfaces include keyboards mice buttons touchscreens remote controls and other devices known to those skilled in the art. In addition the electronic device may include an input or other communication device that connects the device to other electronic devices or a network.

The processor may be any suitable processor such as a microprocessor microcontroller or similar control circuitry configured to execute software firmware and the like collectively referred to as software herein stored in the storage device to perform one or more functions or operations for which the device is designed. For example the processor may be configured to process instructions of the JSON SDK.

The storage device may be implemented in any suitable storage medium. For example the storage device may include volatile data storage such as dynamic random access memory DRAM or static random access memory SRAM nonvolatile data storage such as flash memory magnetic disk drives solid state drives and optical disk drives or combinations thereof. The storage device stores digital data including an operating system one or more software applications and associated software and static data for the processor to access and execute. The storage device may also store variable data pointer information and the like utilized by the processor to execute the software. In some embodiments the processor and the storage device as well as other components may be implemented as an application specific integrated circuit ASIC or as a system on chip SOC .

As noted above the electronic device may include the communication interface and the user interface of . The communication interface may be any suitable interface including a WAN interface LAN interface and or a wireless network adapter or other suitable interface to allow the device to communication with other devices via communication networks such as the Internet. For example the communication interface may include an Ethernet interface a cable or digital subscriber line DSL interface a Wi Fi interface or a cellular communication network interface. JSON strings may be transmitted via the communication device to one or more other electronic devices.

The user interface of the electronic device is configured to receive commands from a user to control the device . The user interface may include or be coupled with any number of input and or output components to allow the user to interact with the electronic device such as a keyboard keypad mouse joystick touchpad visual monitor video display and or audio speakers. In some cases the user interface may incorporate a remote control interface so that the user need not be positioned within reach of the device to provide input thereto. Virtually any type of processor driven electronic device including embedded special purpose devices may serve as the electronic device in specific embodiments. For example in one embodiment the electronic device is a media content or other television receiver such as a television set top box STB for satellite cable or terrestrial over the air transmissions. Typically set top boxes are configured to receive programming from at least one audio video source such as a satellite in geosynchronous orbit a coaxial cable head end or a terrestrial antenna. As such in set top box embodiments in addition to the components depicted in the device may also include circuitry typically associated with a set top box such as an antenna or cable input to receive the multiple channels of television programming one or more tuners for selecting one of the channels and decoding and or decrypting circuitry and output circuitry for presenting the audio and or visual aspects of the selected channel to the user. It should be appreciated that alternate embodiments may take the form of or be included within any suitable electronic device including televisions audiovisual equipment computing devices and so on.

The ANSI C compiler can compile the SDK to a library and or to a debugger . In other words the compiler may use the SDK to implement the debugger e.g. the debugger may be an output of the compiler . It should be noted that the JSON SDK may be compiled in different modes which may be activated or selected through the use of switches. A main switch permits switching between building of the debugger and building of an embeddable library . Further a lite switch may turn off functionality in the JSON library that is not necessary for operation of the electronic device. As one example certain electronic devices do not operate on floating point numbers and so the lite switch may deactivate floating point number operation when the lite switch is toggled. As another example the lite switch may deactivate particular error messages or certain C functionality not otherwise used by the electronic device. By implementing and activating the lite switch the memory footprint of the embedded library may be reduced. In the SDK the main switch may be called a JSON MAIN switch and the lite switch may be called a JSON LITE switch.

The debugger which is described below in more detail with respect to permits a user to analyze and debug JSON data. The debugger also accepts one or more schema sources as inputs to facilitate debugging. It should be noted that these the SDK sources are generally in a format compatible with the ultimately embedded library such as C or Java. Further the schema sources are generally in a JSON format.

The debugger outputs one or more ANSI C schema as defined statements that may be used in an embedded C program source. These C defined schema generally correspond to the JSON schema sources that act as inputs to the debugger but instead are implemented in the C programming language although in alternative embodiments different languages may be used . In this relationship is shown insofar as each numbered schema Schema Schema . . . SchemaN in the C program source block is the same as the schema in the JSON schema source block albeit with different file extensions.

Also included in the embedded C program sources are one or more JSON SDK headers . These headers are taken from the aforementioned JSON SDK sources that serve as input s for the ANSI C compiler. Along with a program written in ANSI C the schema and headers serve as an input to an ANSI C compiler .

The compiler in turn creates one or more binary object files from the various program sources. These binary object files are transmitted or passed to a linker the linker also accepts the binary SDK library from the ANSI C compiler. The linker acts to embed the binary SDK library in the binary program and link the object files resulting in a binary program with a custom embedded JSON SDK library.

Generally an object as used herein is a collection of data items possibly associated with functions or other methods capable of manipulating the data items. In the specific case of the JSON implementation discussed herein and electronic devices employing a JSON SDK the received definitions are embodied as one or more JSON schemas which are definitions of JSON data structures or objects based on the JSON standardized data format. As previously mentioned a JSON schema functions as a contract defining what types and forms of data are required for one of more of applications in what ways that data may be modified or manipulated and the like. In other words the schema defines a particular portion of an application programming interface API to be used by an application such as a browser application. A browser application may employ the resulting objects associated with the schemas received via communication software to initiate commands and other communications with a set top box applications via the API.

Implementation of the JSON SDK within a sample electronic device may be derived from various levels of abstraction. These levels of abstraction may be implemented as components within an API illustrates the levels of abstraction for the JSON SDK with a Schema API. Starting at the highest level of abstraction and moving toward the lowest the levels include name space information Schema API Abstract Syntax Tree AST Token String Char and JSON code . As such JSON code is the lowest level of abstraction. The schema is created from the AST. The name space information relates to names given to particular objects in the schema that allow for data to be identified by name.

These various abstraction levels may interact with a scanner parser and or checker implemented in the electronic device and executed by the processor. Generally and as shown in the string serves as an input to the scanner which tokenizes JSON code in the string and provides one or more corresponding tokens to the parser. The parser parses the tokens into objects and outputs the AST . The checker compares the parsed objects with a schema to determine compliance with the schema which is discussed in greater detail below.

The schema API is the component or abstraction that must be instantiated by the compiler to allow a user to employ the SDK. The schema API is instantiated in an application with an embedded JSON SDK. JSON strings are parsed to objects represented as ASTs. The objects are manipulated through the Schema API and transformed back into JSON strings before being offered to another component. New JSON objects can be instanced through the Schema API where optional objects and optional default fields are omitted. Additionally required defaults objects and arrays may also be added. Additionally objects can be checked against their schema to ensure an object conforms to the schema and does not break the contract between components. Moreover objects can be sorted to the ordering of the schema for data presentation where a client application users the JSON schema as a view for the object.

Thus the checker verifies that that a created or manipulated object conforms to its schema. The schema component in turn ensures conformance by preventing any addition to any object that does not conform to the particular schema. In particular the Schema API provides a means for dynamically creating and manipulating JSON data at run time with respect to JSON schemas i.e. inter component contracts via the schema restricted JavaScript name space .

The JSON SDK is a platform independent multi pass compiler which may be implemented from zero in a programming standard such as ANSI C90 and as such does not rely on any other libraries. The JSON SDK has an object oriented design and is thus platform independent while the particular ANSI C90 implementation may be embeddable.

A contextual analyzer is provided with the JSON SDK to check if objects conform to their respective JSON schemas i.e. do not break the contract and thus may prevent bad JSON data structures. The schemas can be compiled to C headers to be included into the code instead of conventional transposing of the schema to a C header by hand.

Additionally the JSON SDK provides source level JSON debugging that may speed up product development. The SDK allows users to rapidly construct embedded JSON APIs which may be used to expose selected aspects of the state and behavior of a system component. Thus by exposing the state and or behavior of a system data may be transmitted between JSON SDKs on different electronic devices. This transmission may occur through the communication device and may take the form of strings for example.

Returning to the parsed schema string and object string are provided to a checker for contextual analysis . It should be noted that both the schema and object strings are themselves ASTs. The checker compares the object against the schema to determine compliance of the object with the schema. This check is performed by simultaneously traversing both the schema and the object ASTs and comparing the resulting outputs. If the object does not comply with the schema the object fails the contextual analysis and details of the error are provided to a programmer i.e. via an output display to allow for the programmer to correct the errors.

In one embodiment if there is an undefined field in the object which the schema indicates should be defined an error message may be provided indicating the there is an error in the object code that should be addressed. In some cases for example an undefined field in the object code may cause the checker to detect that the contract is broken and the object does not conform to the schema. The checker API may flag a missing field in one of the schema and corresponding object thereby allowing the field to be properly defined.

In the event the object complies with the schema e.g. includes the appropriate fields etc. the object passes the contextual analysis. Objects passing the contextual analysis along with their corresponding schema may be provided to the Schema API for abstraction and interfacing with the API. Alternately the Schema API object output may serve as an input to the contextual checker to ensure the object passes analysis. In such a case the Schema API object may operate prior to the contextual analysis and the object is not passed back to the Schema API. Instead the object is considered finished and may be used as necessary for example it may be passed to another component as a string as described above . illustrates a static structure diagram of the schema abstraction decomposition. The schema abstraction includes an object root and a schema root which are pointers to the abstract syntax trees that represent the object and the schema strings. Additionally an object cursor and schema cursor are provided that are pointers to AST nodes. As the object cursor and the schema cursor traverse the AST they should be synchronized to allow retrieval of information from both object and schema as well as to disallow storing in the schema any information that is not defined by the schema.

In certain embodiments a mis synchronization may be overcome by reliance on the schema. Specifically objects in the schema may be defined as a particular type and as optional or non optional. Type and optional are key words in the schema. If the field is optional the schema may be searched independent from the object. Schema AST nodes may be traversed or searched by the schema cursor. Generally the cursor is moved from a parent node to a child node. Each parent node includes a list of or reference to child nodes. The schema API may traverse a name space by traversing the AST nodes listed therein AST nodes may be included in the name space in a dot separated name format or other appropriate format. The name space for any node sets out all child nodes including objects arrays and so forth.

It should be noted that the embodiment may operate in an asynchronous mode in which the schema API allows the retrieval of default fields that are otherwise declared as optional. Nonetheless this does not allow the embodiment to store information when the object and schema cursors operate in an asynchronous mode. Data storage is disallowed since the schema cursor defines a part of the schema that cannot be added at the object cursor.

A default may be set in the schema for certain fields. The default may be provided to the object field if left undefined. For example a calculator function may have a defined default operator such as an addition operator. Continuing the example if an object is provided with two values and no operator the two values may automatically be added. Typically object fields having a corresponding optional default defined in the schema are not defined in the object. In this manner the value or entry in the undefined object field may be instead retrieved from the corresponding schema. In other words the schema fields may be treated as default fields.

Alternatively certain non optional defaults may be automatically added to an object field and be replaced by another value later. Further the embodiment operates recursively. When an object is instantiated from a schema the schema name is added to the object. Values for non optional fields in the object may be added from the schema. Optional fields are typically undefined when the object is instantiated and are later defined by a user. Upon definition of an optional field the embodiment checks the schema again with the checker to see if any sub fields of the newly defined optional field are non optional. If so these values may be copied from the schema as described herein.

Once all transformations to the object via the schema API are complete the AST is transformed into a JSON string. That is the AST may be made into a string through an appropriate API function. In one embodiment JSON code may be provided on a single line i.e. without line returns while in another JSON code may be formatted.

Additionally the schema is transposed into a C header as each schema needs to be in C code in order to be embedded with a C based embedded device. The transposing of the code into C is automated and performed by the device during compilation.

A debugger may be called from a command line to analyze relevant data such as JSON data. The debugger may permit a user to generate C definitions from a schema to parse a JSON file to check an object against its schema and or to interactively edit objects from a command line and via the schema API. The debugger may access various classes of the AST to allow a programmer to troubleshoot and debug code from a command line. As the debugger is accessible at the command line the debugger may not be enabled for post compiled embodiments such as the STB example described above. However the debugger may be enabled for all testing programming and computing environments such as those that may be implemented on a personal computer for example.

The JSON debugger can be called from the command line to analyze JSON data. Users can manually call the parser and or the checker and can interactively edit objects through the schema API to perform JSON source level debugging.

While example embodiments have been discussed herein other implementations are possible and fall within the scope of the present disclosure. For example while the above embodiments focus on implementations involving a television set top box virtually any electronic device employing a processor and software exhibiting an application programming interface may benefit from the principles discussed herein. Further while the web application discussed above provides functionality for a user interface any other type of functionality useful in the operation of the electronic device may be programmed in the web application as described earlier. Thus while the present invention has been described in the context of specific embodiments such descriptions are provided for illustration and not limitation.

