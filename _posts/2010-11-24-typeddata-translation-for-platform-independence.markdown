---

title: Typed-data translation for platform independence
abstract: A method, computer program and device for the translation of typed data objects in a heterogeneous computational environment is described. The operating system (or installed shared code libraries) translates typed data objects from a first format (e.g., big-endian) to a second format (e.g., little-endian) if the application sending the object and the application receiving the object utilize different formats. By placing data object format translation capabilities into the operating system, the software development effort required to permit an application (e.g., a user-level application) to execute in a heterogeneous environment is significantly reduced.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08230403&OS=08230403&RS=08230403
owner: Apple Inc.
number: 08230403
owner_city: Cupertino
owner_country: US
publication_date: 20101124
---
This is a continuation of and claims priority to U.S. patent application Ser. No. 11 144 877 now U.S. Pat. No. 7 865 884 entitled Typed Data Translation for Platform Independence filed 3 Jun. 2005 by Eric Albert Alexei Kosut Matt Watson and Steve Zellers which is hereby incorporated by reference in its entirety.

When data are represented by multiple bytes there is no unique way to order them. Accordingly any order used is subject to arbitrary convention called endianness. The two main types of endianness are known as big endian and little endian. In big endian format the order of bytes in a word is such that the most significant byte is placed left most in the word structure the way humans deal with normal arithmetic left to right . In contrast little endian format places the least significant byte leftmost in the word structure. Little endian format is organized for the required processing order since numbers are calculated by a processor starting with the least significant left most digits. Most RISC based processors use big endian byte order while most processors manufactured by the Intel Corporation use little endian byte order.

In a computational environment that permits both big endian and little endian formats to coexist any time typed data objects are written to a file transferred between different platforms or shared between different applications within a single system the byte order or endianness of the data comprising the object must be taken into account. Otherwise the same binary data residing on disk or in memory looks different to each type of program little endian programs look to the last byte for the most significant bit big endian programs look to the first byte for the most significant bit. As used herein a typed data object is a multi byte data structure having one or more fields wherein each field is defined by type e.g. floating point line polygon or widget . Illustrative typed data objects include but are not limited to files multi byte records within a file multi byte operating system data structures and multi byte user and application defined data structures. It will be recognized that a typed data object cannot be converted from one byte ordering convention to another simply by swapping all the object s bytes.

To change byte ordering programs are typically recompiled. Recompiling a program permits the resulting executable code to be run or executed on different endian based platforms. Recompiling a program does not however address the problem of how to translate typed data objects from a first byte ordering to a second byte ordering. In the past to compensate for system or program specific typed data object formats between different endian based platforms application developers expended significant amounts of time and effort to recode their applications and or to encode within each object an explicit description of the object so it could be converted by another application or function.

Accordingly it would be beneficial to provide methods devices and systems to translate typed data objects from one format to a second format in an application independent and developer transparent manner.

In one embodiment the invention provides an method to translate typed data objects from a first format to a second format. The method includes receiving a typed data object in a first format selecting a routine based on a characteristic of the typed data object and translating the typed data object into a second format using the selected routine. For example routine selection may be made in response to interrogating the received typed data object or it may be made based on a message requesting the typed data object. Typed data object translation in accordance with the invention may be provided by an operating system component or a shared library or libraries installed and accessible to applications executing within an operating system e.g. a software developers kit SDK .

In another embodiment the invention provides an operating system method to translate typed data objects from a first format to a second format in the context of a point to point communication. The method includes receiving by an operating system component e.g. an event manager component a typed data object having a first format e.g. big endian from a first application and identifying a second application the second application associated with a second format e.g. little endian translating the typed data object from the first format to the second format and sending the translated typed data object to the second application.

In yet another embodiment the invention provides an operating centric method to translate typed data objects in the context of inter application communication using generic message passing techniques e.g. message or pasteboard components of an operating system . The method includes receiving a typed data object having a first format e.g. big endian from a first application storing a token in an operating system defined memory location identifying the received typed data object e.g. a pasteboard memory receiving a request for the typed data object in a second format e.g. little endian translating the received typed data object into the second format updating the token to identify the translated typed data object so that the token identifies both the received typed data object and the translated typed data object and sending the translated typed data object to the second application.

In still another embodiment the invention provides a data structure for use by a software routine that has a field for identifying a plurality of versions of a typed data object one version for each format the typed data object can assume.

Methods in accordance with the various embodiments of the invention may be stored in any media that is readable and executable by a computer system.

The following embodiments of the invention described in terms of application programming interfaces APIs executing in a Mac OS operating system environment are presented to enable any person skilled in the art to make and use the invention as claimed and are provided in the context of the particular examples discussed below variations of which will be readily apparent to those skilled in the art. Accordingly the claims appended hereto are not intended to be limited by the disclosed embodiments but are to be accorded their widest scope consistent with the principles and features disclosed herein. MAC OS is a registered trademark of Apple Computer Inc. of Cupertino Calif. 

Referring to software architecture in accordance with one embodiment of the invention permits user level applications to communicate with operating system OS level Event Manager Pasteboard Manager and Resource Manager through public APIs and respectively. Illustrative user level applications include iCal Safari Pages and Address Book from Apple Computer. ICAL is a registered trademarks of Apple Computer Inc. of Cupertino Calif. It will be appreciated by software developers familiar with the Mac OS operating environment that Event Manager Pasteboard Manager and Resource Manager are OS components that provide services to applications. Event Manager and API for example provide facilities for applications to send and respond to programmatic and user initiated events or messages intra application and inter application messages events such as for example Apple events . Apple events in turn are a type of interprocess message that can specify complex operations and data. Applications typically use Apple events to request services and information from other applications or to provide services and information in response to such requests. Pasteboard Manager and API provides a standardized mechanism for the asynchronous exchange of data within or between applications using pasteboards. For example when a user selects data in a first application and chooses the Copy or Cut command the selected data is placed into a pasteboard. When the user subsequently chooses the Paste command the data in the pasteboard is copied to the currently active application. Resource Manager and API provides an established mechanism for applications to create delete open read modify and write resources. In the Apple OS environment a resource is data of any kind stored in a defined format and are usually contained in the files that make up the application distribution. Applications typically use resources to store descriptions of user interface elements such as menus windows controls dialog boxes icons as well as variable setting values such as the location of a window at the time a user closes the window.

When using Event Manager Pasteboard Manager or Resource Manager the data content or payload communicated within or between applications is typically one or more typed data objects some of which may be very complex some typed data objects may in fact not be representable by high level languages such as C . In a heterogeneous computing environment in which both big endian and little endian formats are permitted there must be a mechanism to ensure that the format of a typed data object supplied by a sending application is in a format acceptable to the receiving application even if the sending and receiving application are the same. In the prior art the responsibility for translating a typed data object from a first format to a second format belonged to the application. This approach has at least two major drawbacks. First it requires software developers whose applications are to execute in a heterogeneous environment to develop debug and update their applications so that they can translate all typed data objects those provided and defined by the underlying OS as well as those unique to the application. Second because the receiving application may not be initially known e.g. at the time application places a typed data object into a pasteboard via Pasteboard Manager and Pasteboard API it does not know which if any application will retrieve the object and therefore what the final format of the object need be all typed data objects would normally be transferred via a canonical or intermediate format and or translation promises. It will be recognized that the former approach may incur significant wasted overhead while the latter approach can involve significant security and or computational problems.

Referring again to in one embodiment of the invention endian specific translation routines are provided to Event Manager Pasteboard Manager and Resource Manager to translate as needed OS defined typed data objects. In the context of Mac OS X Table 1 provides an illustrative list of system defined typed data objects for which endian specific translation routines have been generated. Specifics of each type of data object may be obtained from the Developers web site provided free by Apple Computer Inc. See for example http developer.apple.com for more information. 

In the context of an event processed through Event Manager both the source and target application are known. That is events are point to point operations where both the application supplying a typed data object and the application receiving the typed data object are known. Referring to event object translation process in accordance with one embodiment of the invention begins when Event Manager receives a typed data object from a source application block . Next Event Manager interrogates the object to determine if the object needs to be translated to conform to the format required by the target application block . If the object requires translation the YES prong of block and an endian specific translation routine exists for the object the YES prong of block the object is translated block and sent to the target application block . If the object requires translation the YES prong of block and no endian specific translation routine exists the NO prong of block error processing is initiated block . Finally if the source and the target application utilize the same format the NO prong of block no translation is needed and the object is sent directly to the target application block .

A data flow diagram corresponding to the acts of is shown in . As in the goal is for source application to send a typed data object to target application . Initially source application sends typed data object to Event Manager via Event Manager API . Assuming source application and target application use different formats and a translation routine exists see blocks and of Event Manager employs one or more routines to generate translated object . Translated object is then sent to target application via Event Manager API .

In contrast to the point to point operations of Event Manager when a typed data object is placed into a pasteboard via Pasteboard Manager the target application is unknown. Accordingly in a heterogeneous environment the required format of a pasteboard object is unknown until such time as the object is retrieved by a second application. One way to address this ambiguity is to place all objects into a pasteboard in a canonical format requiring the target application to translate all objects from this predetermined canonical format to the particular format needed by the application. Another way to address this ambiguity is to translate objects into each of the specified formats e.g. big endian and little endian at the time the object is placed into the pasteboard. Yet another way to address this ambiguity is to modify an object s pasteboard token that entity retained in a pasteboard that represents the object to account for the different possible formats updating the token to reflect the available formats as they are generated. While potentially useful both of the first two approaches identified here can involve significant computational overhead in that multiple translations may be required even if the source and target applications use the same format. Thus while each of these methods may use routines in accordance with the invention the modified token approach will be described in more detail here.

As noted above in many modern operating system environments placing a typed data object into a pasteboard means storing a token representing the object in the pasteboard. Referring to for example prior art pasteboard token comprises object type identifier e.g. identifying the object as a polygon data pointer pointing to memory in which the data object is stored and size indicator indicating the size typically in bytes of the data object . In accordance with one embodiment of the invention pasteboard tokens comprise additional fields one for each type of format an object may assume. Referring to for example in a heterogeneous environment where an object may assume a big endian or little endian format token comprises object type identifier see discussion above regarding element size indicator see discussion above regarding element big endian data pointer and little endian data pointer . As described in more detail below each of big endian data pointer and little endian data pointer may point to memory containing a typed data object having the specified format big endian or little endian or they may contain a NOT IN USE value. A NOT IN USE value indicates that the object has not yet been translated that is there is no representation of the object in memory corresponding to the data pointer s associated format.

Referring to pasteboard input procedure in accordance with one embodiment of the invention begins when Pasteboard Manager via Pasteboard API receives a typed data object block . Next Pasteboard Manager determines the object s type and format block creates a pasteboard token representing the object block and updates the token s descriptive fields block . Specifically the token s data pointer corresponding to the object s determined format is set to point to the object e.g. BE DATA PTR field and the other token data pointer e.g. LE DATA PTR field is set to the NOT IN USE value.

A data flow diagram corresponding to the acts of is shown in . As in the goal is for source application to place object into a pasteboard so that at some arbitrary later time application may retrieve it . Initially source application places object into the pasteboard via Pasteboard API . As previously noted this results in token being placed into the pasteboard by Pasteboard Manager . Assuming object is a big endian formatted object token s big endian data pointer see in is set to point to the object and s little endian data pointer see in is set to a NOT IN USE value .

Referring to pasteboard output procedure in accordance with one embodiment of the invention begins when Pasteboard Manager via Pasteboard API receives a request for a previously input object block . Next Pasteboard Manager determines the format required by the requesting application block . If the data object in the required format exists the YES prong of block the object is supplied to the requesting application block . If the data object in the required format does not exist the NO prong of block the data object is translated to the required format using endian specific routines block and the appropriate pasteboard token data pointer field is updated to point to the newly translated object block . In one embodiment the existence of the data object is determined by looking to the pasteboard token s data pointer fields. For example if the target format is little endian and the pasteboard token s LE DATA PTR field value is NOT IN USE then a little endian version of the typed data object does not yet exist. On the other hand if the pasteboard token s LE DATA PTR field value is not NOT IN USE then a little endian version of the typed data object does exist and it can be found at the location specified by LE DATA PTR field .

A data flow diagram corresponding to the acts of is shown in . Initially arbitrary application makes a request for an object stored in the pasteboard . If the object exists in the format required by application it is simply delivered via Pasteboard API . If the object does not exist in the required format Pasteboard Manager uses endian specific routines to translate object into the required format object and token s data pointer is updated to point to object . The properly formatted object is then provided to arbitrary application via Pasteboard API . As shown in two copies of the object are now available through token .

In the context of resource management via Resource Manager typed data objects stored in a resource file or the resource fork of a file are generally in a known format. In addition the format required by the application accessing and or manipulating the resource is known. However in a heterogeneous environment in which a first application using a first format e.g. big endian must obtain or exchange resource information with a second application using a second format e.g. little endian or where a first application using a first format must interact with legacy or pre existing resources in a second format a need to convert between different formats exists. In the past the application s developer was responsible for redesigning their software to accommodate the differing resource formats. In accordance with the invention however Resource Manager and endian specific routines may be used to seamlessly translate between the various formats.

Referring to resource object translation process in accordance with one embodiment of the invention begins when Resource Manager receives a request to retrieve or write or modify a specified resource object block . In response Resource Manager obtains the resource from a specified file block . If the format of the retrieved object is different from the format required by the requesting application the YES prong of block Resource Manager uses routines to translate the object block . Resource Manager then returns the translated object to the requesting application via Resource Manager API block . If the format of the retrieved object s format is the same as that required by the requesting application the NO prong of block the object is simply passed back in accordance with the acts of block . One of ordinary skill in the art will recognize that resource object translation process is equally application to the acts of creating writing and modifying resources.

A data flow diagram corresponding to the acts of is shown in . Initially application issues a request to retrieve a specified resource object via Resource Manager API . In response Resource Manager acquires a copy of designated resource in the form of typed data object . If the format of retrieved object differs from that required by requesting application routines are used to translate the object into the proper format . Finally translated object is supplied to application .

As described so far routines have been used to translate OS defined typed data objects that is structures known defined or provided by the OS within which applications execute. In another embodiment applications may register their own translation routines. Referring to software architecture in accordance with this embodiment of the invention permits user level applications e.g. application to register translation routines with the OS. Once registered such routines are treated in the same manner as system defined translation routines as far as the registering application is concerned. That is in general if Application 1 registers a translation routine it will only be invoked by the OS e.g. Event Manager Pasteboard Manager or Resource Manager on behalf of that application. In another embodiment however an application could register a translation routine that could be accessed by other applications including operating system components. It will be recognized that application specific translation routines may be implemented in whatever language the application developer chooses as long as it conforms to the calling conventions required by the operating system within which the application is to run. In the Mac OS environment for example this could be the Apple Binary Interface ABI convention. It will also be recognized that routines may be delivered in any number of formats. For example as a dynamically linked library D10 or a script file.

In summary see typed data object translation operation in accordance with the invention first receives a typed data object block and then selects a translation routine based on the type of the typed data object block . The selected translation routine is used to translate the object from a first format such as big endian to a second format such as little endian block . The translated object is then delivered to the appropriate location block . Illustrative appropriate locations include a flat file a database or database record memory associated with an application requesting the object or memory associated with an operating system component such as the pasteboard manager.

It will be recognized that if an object cannot be translated because a suitable translation routine does not exist in accordance with blocks or the operating system e.g. Event Manager Pasteboard Manager or Resource Manager may elect to take one of the following actions 1 refuse to provide the requested data 2 provide the data in whatever format it has without concern or guarantee of the data s validity at the target application 3 generate an error condition 4 request the application that supplied the typed data object to translate it or 5 request the application that supplied the typed data object register a routine see discussion above to translate the routine.

One benefit of implementing typed data object translation services using OS components e.g. Event Manager Pasteboard Manager or Resource Manager in accordance with the invention is that it eliminates the need for individual developers to develop code and debug translation routines for those typed data objects covered by routines . As used herein an OS component could be an application or function module that is part of an operating system or a shared library or libraries installed and accessible to applications executing within an operating system e.g. a software developers kit SDK .

Another benefit is that it permits continued function of applications when the underlying operating system s defined typed data objects have been changed or are no longer used by the OS. Yet another benefit of the invention is that the computational cost of translating typed data objects during pasteboard operations is deferred until needed. For example if a little endian object is placed into a pasteboard it will only be translated if a big endian application requests it. And it will not be translated if only little endian applications request it. Another benefit of pasteboard operations in accordance with the invention is that an object is only translated once for each requested but non existent format. For example in an operating environment in which only two formats are defined e.g. big endian and little endian each object is subject to translation in accordance with the invention at most once. In general in an operating environment in which N formats are defined each object is subject to at most N 1 translations. Still another benefit of the invention is that it virtually eliminates the software development effort required to permit an application to manipulate system defined typed data objects in a heterogeneous operating environment. That is a software developer creates and manipulates system defined typed data objects in exactly the same way regardless of what format her application requires it is the OS in which the application executes via routines see that compensates for differently formatted objects. Still Another benefit of the invention is that it allows developers to port their applications from an environment based on a first format e.g. big endian to an environment based on a second format e.g. little endian by simply developing translation routines for those typed data objects unique to their application. As described with respect to application specific translation routines may be registered so that typed data objects used by a specific application may be translated for the benefit of other applications.

Various changes in the described system architectures and software elements as well as in the details of the illustrated operational methods are possible without departing from the scope of the following claims. For instance the principles and techniques described herein are applicable to operating systems other than the Mac OS for example the Windows operating system. WINDOWS is a registered trademark of the Microsoft Corporation of Redmond Wash. That is modern operating systems other than Mac OS provide functionality similar to Event Manager Pasteboard Manager and Resource Manager components described herein. In addition acts in accordance with and may be performed by a programmable control device executing instructions organized into one or more program modules. A programmable control device may be a single computer processor a special purpose processor e.g. a digital signal processor DSP a plurality of processors coupled by a communications link or a custom designed state machine. Custom designed state machines may be embodied in a hardware device such as an integrated circuit including but not limited to application specific integrated circuits ASICs or field programmable gate array FPGAs . Storage devices suitable for tangibly embodying program instructions include but are not limited to magnetic disks fixed floppy and removable and tape optical media such as CD ROMs and digital video disks DVDs and semiconductor memory devices such as Electrically Programmable Read Only Memory EPROM Electrically Erasable Programmable Read Only Memory EEPROM Programmable Gate Arrays and flash devices.

