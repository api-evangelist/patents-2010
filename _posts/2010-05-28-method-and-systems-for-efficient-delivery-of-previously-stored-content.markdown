---

title: Method and systems for efficient delivery of previously stored content
abstract: Systems and methods for reducing file sizes for files delivered over a network are disclosed. A method comprises receiving a first file comprising sequences of data; creating a hash table having entries corresponding to overlapping sequences of data; receiving a second file comprising sequences of data; comparing each of the sequences of data in the second file to the sequences of data in the hash table to determine sequences of data present in both the first and second files; and creating a third file comprising sequences of data from the second file and representations of locations and lengths of said sequences of data present in both the first and second files.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08838630&OS=08838630&RS=08838630
owner: Citrix Systems, Inc.
number: 08838630
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20100528
---
This present application claims priority to and is a continuation of U.S. Non Provisional application Ser. No. 11 428 058 entitled Method and Systems for Efficient Delivery of Previously Stored Content filed on Jun. 30 2006 which is incorporated herein by reference in its entirety.

The present invention is directed to Internet and computer network content delivery and more particularly to systems and methods for reducing file sizes for files delivered over a network.

In many network environments bandwidth is a scarce resource. Bandwidth may be limited by the connection infrastructure of the environment or the maximum transmission or reception speeds of devices on the network. Where bandwidth is scarce significant improvements in transmission time can be achieved by reducing the size of files transmitted over a network.

Another common feature of networks including the internet and the World Wide Web is the transmission of redundant data. For example often a client may request the same file on different days to observe any changes that have taken place. A large portion of the file data may be redundant in that it has already been transmitted to the user. For example if the file is the web page of a newspaper the headings and formatting information will remain constant. As another example a client may load a file several times within a single hour for example if the file is a web page listing updated sports scores. In this example the only data that changes from viewing to viewing may be the scores themselves and the team names logos and formatting will remain unchanged.

Several systems and methods already exist for taking advantage of this redundancy to reduce the size of transmitted files. Many web browsers store images from sites a user has already visited so that they do not need to be retransmitted if the user returns to the site. While this method is effective it is typically limited only to standard image files and cannot reduce file sizes for pages comprising large amounts of text scripts or formatting information. Many web sites utilize frames applets or scripts to control web pages so that only the portion of a page that has changed will be retransmitted. The drawback of this approach is that programming a site to use these techniques often requires substantial developer time and resources and may require recoding previously existing files. Thus there exists a need for means to leverage the redundancy found in many network transmissions to reduce the size of transmitted files that may be easily applied to both presently existing and future files.

The present invention provides an efficient mechanism by which the transmitted file sizes can be significantly reduced for files comprising data that has previously been transmitted. The invention may make this reduction possible without the need for file specific application specific or network specific solutions and thus may not require substantial developer investment.

In one aspect the invention is a method for creating efficient updates to a previously stored file. The method comprises receiving a first file comprising sequences of data creating a hash table having entries corresponding to overlapping sequences of data receiving a second file comprising sequences of data comparing each of the sequences of data in the second file to the sequences of data in the hash table to determine sequences of data present in both the first and second files storing representations of lengths and locations of said sequences of data present in both the first and second files and creating a third file comprising sequences of data from the second file and representations of locations and lengths of said sequences of data present in both the first and second files.

In another aspect the invention is a method of receiving efficient updates to previously stored files. The method comprises receiving a first file comprising sequences of data receiving a second file comprising sequences of data and representations of locations and lengths of sequences in the first file and executing a Javascript function to create a third file comprising sequences of data from the second file and sequences in the first file indicated by the second file.

In yet another aspect the invention is a computer system for creating efficient updates to a previously stored file. The system comprises a transceiver which receives a first and second file each file comprising a respective plurality of sequences of data a hash engine which communicates with said transceiver and computes hash values for sequences of data in the first and second file wherein at least two of said sequences overlap and determines sequences of data present in both the first and second files a storage element in communication with said hash engine which stores representations of the lengths and locations of said sequences present in both the first and second files and a processor in communication with said storage element which creates a third file comprising sequences of data from the second file and representations of lengths and locations of said sequences present in both files.

Servers and clients as described herein may comprise any device capable of processing information and sending and receiving information including without limitation a personal computer notebook computer personal digital assistant cellular telephone pager a standalone computer server a blade server a rack mounted server or a group of any types of said servers.

The central processing unit is any logic circuitry that responds to and processes instructions fetched from the main memory unit . In many embodiments the central processing unit is provided by a microprocessor unit such as those manufactured by Intel Corporation of Mountain View Calif. those manufactured by Motorola Corporation of Schaumburg Ill. the Crusoe and Efficeon lines of processors manufactured by Transmeta Corporation of Santa Clara Calif. the lines of processors manufactured by International Business Machines of White Plains N.Y. or the lines of processors manufactured by Advanced Micro Devices of Sunnyvale Calif.

Main memory unit may be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by the microprocessor such as Static random access memory SRAM Burst SRAM or SynchBurst SRAM BSRAM Dynamic random access memory DRAM Fast Page Mode DRAM FPM DRAM Enhanced DRAM EDRAM Extended Data Output RAM EDO RAM Extended Data Output DRAM EDO DRAM Burst Extended Data Output DRAM BEDO DRAM Enhanced DRAM EDRAM synchronous DRAM SDRAM JEDEC SRAM PC100 SDRAM Double Data Rate SDRAM DDR SDRAM Enhanced SDRAM ESDRAM SyncLink DRAM SLDRAM Direct Rambus DRAM DRDRAM or Ferroelectric RAM FRAM . In the embodiment shown in the processor communicates with main memory via a system bus described in more detail below . depicts an embodiment of a computer system in which the processor communicates directly with main memory via a memory port. For example in the main memory may be DRDRAM.

In the embodiment shown in the processor communicates with various I O devices via a local system bus . Various busses may be used to connect the central processing unit to the I O devices including a VESA VL bus an ISA bus an EISA bus a MicroChannel Architecture MCA bus a PCI bus a PCI X bus a PCI Express bus or a NuBus. For embodiments in which the I O device is an video display the processor may use an Advanced Graphics Port AGP to communicate with the display. depicts an embodiment of a computer system in which the main processor communicates directly with I O device via HyperTransport Rapid I O or InfiniBand. also depicts an embodiment in which local busses and direct communication are mixed the processor communicates with I O device using a local interconnect bus while communicating with I O device directly.

A wide variety of I O devices may be present in the computer system . Input devices include keyboards mice trackpads trackballs microphones and drawing tablets. Output devices include video displays speakers inkjet printers laser printers and dye sublimation printers. An I O device may also provide mass storage for the computer system 800 such as a hard disk drive a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive tape drives of various formats and USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry Inc. of Los Alamitos Calif.

In further embodiments an I O device may be a bridge between the system bus and an external communication bus such as a USB bus an Apple Desktop Bus an RS 132 serial connection a SCSI bus a FireWire bus a FireWire 800 bus an Ethernet bus an AppleTalk bus a Gigabit Ethernet bus an Asynchronous Transfer Mode bus a HIPPI bus a Super HIPPI bus a SerialPlus bus a SCI LAMP bus a FibreChannel bus or a Serial Attached small computer system interface bus.

General purpose computers of the sort depicted in and typically operate under the control of operating systems which control scheduling of tasks and access to system resources. Typical operating systems include MICROSOFT WINDOWS manufactured by Microsoft Corp. of Redmond Wash. MacOS manufactured by Apple Computer of Cupertino Calif. OS 2 manufactured by International Business Machines of Armonk N.Y. and Linux a freely available operating system distributed by Caldera Corp. of Salt Lake City Utah among others.

For embodiments comprising mobile devices the device may be a JAVA enabled cellular telephone such as the i55sr i58sr i85s or the i88s all of which are manufactured by Motorola Corp. of Schaumburg Ill. the 6035 or the 7135 manufactured by Kyocera of Kyoto Japan or the i300 or i330 manufactured by Samsung Electronics Co. Ltd. of Seoul Korea. In other embodiments comprising mobile devices a mobile device may be a personal digital assistant PDA operating under control of the PalmOS operating system such as the Tungsten W the VII the VIIx the i705 all of which are manufactured by palmOne Inc. of Milpitas Calif. In further embodiments the client may be a personal digital assistant PDA operating under control of the PocketPC operating system such as the iPAQ 4155 iPAQ 5555 iPAQ 1945 iPAQ 2215 and iPAQ 4255 all of which manufactured by Hewlett Packard Corporation of Palo Alto Calif. the ViewSonic V36 manufactured by ViewSonic of Walnut Calif. or the Toshiba PocketPC e405 manufactured by Toshiba America Inc. of New York N.Y. In still other embodiments the mobile device is a combination PDA telephone device such as the Treo 180 Treo 270 Treo 600 Treo 650 Treo 700 or the Treo 700w all of which are manufactured by palmOne Inc. of Milpitas Calif. In still further embodiments the mobile device is a cellular telephone that operates under control of the PocketPC operating system such as the MPx200 manufactured by Motorola Corp. A typical mobile device may comprise many of the elements described above in including the processor and the main memory .

Still referring to in greater detail a network appliance connected via a network to a number of servers is shown. In the embodiment shown the servers may comprise any device capable of processing information and sending and receiving information including a standalone computer server a blade server a rack mounted server or a group of any types of said servers. The servers may further comprise databases file servers web servers application servers or any other type of server. In embodiments involving multiple servers the servers may be identical servers or may differ in make model type content performance availability or any other aspect.

The network appliance may perform any function related to providing services to clients including without limitation firewall services SSL pooling and acceleration TCP pooling and acceleration data compression connection monitoring application logging application acceleration application delivery load balancing caching virtualization translation redirection connection pooling proxy services reverse proxy services authentication and session management. In some embodiments the network appliance may reside on the same physical machine as the servers . In some embodiments the network appliance may share processors disk space RAM or any other computing resource with the servers .

In the embodiment shown the network appliance is connected to networks . The networks may comprise the Internet local networks web servers file servers routers databases computers servers network appliances or any other computing devices capable of sending and receiving information. The networks may comprise computing devices connected via cables IR ports wireless signals or any other means of connecting multiple computing devices. The networks and any devices connected to the networks may communicate via any communication protocol used to communicate among or within computing devices including without limitation SSL HTML XML RDP ICA FTP HTTP TCP IP UDP IPX SPX NetBIOS NetBEUI SMB SMTP Ethernet ARCNET Fiber Distributed Data Interface FDDI RS232 IEEE 802.11 IEEE 802.11a IEE 802.11b IEEE 802.11g and direct asynchronous connections or any combination thereof. The networks may comprise mobile telephone networks utilizing any protocol or protocols used to communicate among mobile devices including AMPS TDMA CDMA GSM GPRS or UMTS. The networks may comprise physically distinct networks or the networks may comprise the same network and may be connected in any manner. In some embodiments the devices communicating via network may use a specialized or different protocol than devices communicating via network .

In embodiments comprising a TCP IP based communications among any of the above devices any TCP IP based protocol may be used including Messaging Application Programming Interface MAPI email File Transfer Protocol FTP HyperText Transfer Protocol HTTP Common Internet File System CIFS protocol file transfer Independent Computing Architecture ICA protocol Remote Desktop Protocol RDP Wireless Application Protocol WAP Mobile IP protocol and Voice Over IP VoIP protocol. Any type and form of transport control protocol may also be used such as a modified transport control protocol for example a Transaction TCP T TCP TCP with selection acknowledgements TCPSACK TCP with large windows TCP LW a congestion prediction protocol such as the TCP Vegas protocol and a TCP spoofing protocol. In other embodiments any type and form of user datagram protocol UDP such as UDP over IP may be used.

Referring now to one embodiment of a method for creating an efficient update to a previously stored file is shown. Although depicts the method in the context of being performed by a network appliance and a client the method may be performed by any of the computing devices discussed herein either alone or in any combination. In brief overview the method comprises receiving a first file comprising a first plurality of sequences of data step transmitting the first file to a client step receiving a second file comprising a second plurality of sequences of data step creating a hash table having a plurality of entries each of the plurality of entries corresponding to a respective one of the first plurality of sequences and wherein at least two of said entries correspond to overlapping sequences of data step computing hash values for said second plurality of sequences of data step comparing each of the second plurality of sequences of data with sequences from the first plurality of sequences having the same hash value to determine sequences of data present in both files step storing representations of lengths and locations of said sequences of data present in both the first and second files step creating a third file comprising sequences of data from the second file and representations of locations and lengths of said sequences of data present in both the first and second files step and transmitting the third file to a client step .

Still referring to and now in greater detail the network appliance receives a first file comprising a first plurality of sequences of data step . In some embodiments the first file may be received from a network from a server from a database or from any combination thereof. In some embodiments the first file may be read from a disk or other storage medium retrieved from a cache or accessed from RAM. In other embodiments the first file may be received from an application or process executing on the network appliance .

The first file may comprise sequences of data corresponding to sequences of bits or bytes comprising the file. The first file may comprise any file protocol including without limitation HTML XML WML SVG other document protocols image file protocols sound file protocols video file protocols and binary file protocols. In some embodiments the file comprises a web page or a portion of a web page. In some embodiments the file comprises any web page that is updated with some frequency including without limitation a news page a web application page a chat room a bulletin board a sports page an e mail page a directory listing a tracking page and a webcam page. After receiving the first file the network appliance may store or cache the first file to permit later retrieval. In some embodiments the network appliance may modify said first file in accordance with any of the network appliance functions described herein.

In some embodiments after receiving the first file step the network appliance transmits the first file to a client step . The network appliance may transmit the first file via any of the networks or protocols described herein and to any of the clients described herein. The network appliance may modify the first file in accordance with any of the functions performed by the network appliance including compression acceleration and encryption. Although depicts the network appliance transmitting the first file immediately after step in other embodiments said transmittal could occur after any of the steps steps occurring after the network appliance receives the first file step .

In some embodiments the network appliance may store a record of said transmission. Said record may be stored in any memory element including a data base or cache. In one embodiment the network appliance may access said cache to determine whether a given file has been previously transmitted to a client. In one embodiment said records may be set to expire after a set amount of time. For example if a network appliance has information indicating that a given client deletes all files from its cache at the end of each day the network appliance may set all records of files transmitted to the client to expire at the end of each day.

In the embodiment shown after the network appliance transmits the first file to the client step the client may then receive the first file step display the first file step and store the first file step . The client may perform these steps in accordance with any of the embodiments described herein.

In the embodiment shown after the network appliance transmits the first file to the client step the network appliance receives a second file comprising a second plurality of sequences of data step . In other embodiments the network appliance may receive the second file step before or during the transmission of the first file to the client step . The second file may comprise any of the file types protocols web pages and portions of web pages discussed herein. After receiving the second file the network appliance may store or cache the second file to permit later retrieval. In some embodiments the network appliance may modify said second file in accordance with any of the network appliance functions described herein.

After receiving the second file comprising a second plurality of sequences of data step the network appliance may create a hash table having a plurality of entries each of the plurality of entries corresponding to a respective one of the first plurality of sequences and wherein at least two of said entries correspond to overlapping sequences of data step . Said hash table may be created according to any known hash table algorithm which provides functionality to store sequences of data or references to sequences of data as entries and then efficiently search said table for entries matching a given sequence. In other embodiments the network appliance may create the hash table step before or during receiving the second file step .

In some embodiments the entries in the hash table may correspond to sequences of data from the first file comprising sequences of bytes. The sequences of bytes may be of any length. In one embodiment the sequences are four byte sequences.

In the embodiment shown at least two of the hash table entries correspond to overlapping sequences of data. Overlapping sequences may have any number of bytes in common. For example if the file comprised the sequence abcdefghijklmnop examples of overlapping four byte sequences include cdef and defg in addition to cdef and fghi. In one embodiment the hash table entries correspond to successive overlapping byte sequences. For example if the file comprised the sequence abcdefg a hash table comprising at least two successive overlapping four byte sequences may include entries corresponding to the sequences abed bcde cdef and defg .

In some embodiments the hash table entries at a given time may only correspond to sequences of data from a given portion or window of the first file. This allows the size of the hash table to be smaller than the hash table might be if the entire file was hashed at once. In some embodiments only the first X bytes of the first file are hashed and then upon occurrence of some conditions Y entries are removed from the table followed by Y more entries being added to the table. In one embodiment a window size of 64 kilobytes is used and upon occurrence of certain conditions the window is moved by 32 kilobytes. In this embodiment the sequences from the first 64 kilobytes of the first file are hashed and then upon occurrence of certain conditions the entries corresponding sequences from the first 32 kilobytes of the file are removed and entries corresponding to sequences from the next 32 kilobytes of the file are added.

The conditions upon which the hash window are moved may be any conditions which improve the execution time performance or compression of the hashing algorithm. In one embodiment the window is moved when matches have been found for more than 85 of the sequences in a given half of the window. In another embodiment the window is moved when a given percentage of the second file has been compared with the existing hash entries. In one embodiment the window is moved when hash values have been computed and compared for a proportionate portion of the second file compared to the first file. For example if the first file is 100 kilobytes and the second file is 80 kilobytes the hash window may be moved when 80 100 64 kilobytes of the second file has been compared to sequences in the hash table.

After the network appliance creates a hash table step the network appliance may then compute hash values for said second plurality of sequences of data step . Said hash values may be computed according to the same method used to compute hash values for the first plurality of sequences. The network appliance may choose sequences of data from the second file in the same manner in which the network appliance chose sequences of data from the first file. For example if the network appliance created hash table entries corresponding to successive overlapping four byte sequences from the first file the network appliance may choose to compute hash values for successive overlapping four byte sequences from the second file.

After computing hash values for some or all of the second plurality of sequences of data step the network appliance may compare each of the second plurality of sequences of data with sequences from the first plurality of sequences having the same hash value to determine sequences of data present in both files step . The network appliance may perform this step in accordance with any hashing algorithm presently available. Said comparisons may comprise a comparison of subsequent bytes of matched sequences to determine longer matches. For example the first file may comprise the sequence abcdefghijklmno and the second file may comprise the sequence zyxwvutcdefghituv. If the hashing is done on successive four byte sequences the network appliance may determine that the sequence cdef is present in both files. The network appliance may then compare subsequent bytes of the matched sequences to determine that the sequence cdefghi is present in both files. Thus in some embodiments the lengths of the sequences determined to be present in both files may vary from the lengths of the sequences for which hash values are computed. In some embodiments a minimum and maximum length on matching sequences may be set.

After determining sequences of data present in both files step the network appliance may store representations of lengths and locations of said sequences of data present in both the first and second files step . The network appliance may store said representations in any storage medium including a cache RAM a disk or tape. In some embodiments the network appliance may store said representations on the network appliance itself. In other embodiments the network appliance may store said representations on another computing device . In some embodiments lengths and locations of a sequences of data may be stored while the network appliance is comparing each of the second plurality of sequences of data with sequences from the first plurality of sequences having the same hash value step . In other embodiments a minimum length may be required for the length and location of a given sequence to be stored. In one embodiment the minimum length may be specified to be four bytes.

The representations of lengths and locations of said sequences present in both files may comprise any representation which identifies a length and location of a sequence. In some embodiments the locations of said sequences are stored as absolute locations within a file. In other embodiments the locations of said sequences are stored as locations relative to a given reference pointer within said first file. In one embodiment said reference pointer may be fixed in another embodiment said reference pointer may move according to a rule set.

In one embodiment the reference pointer may be initially set to point to the beginning of the first file. The pointer may then be incremented every time a matching sequence of longer than 5 bytes is found. The pointer may then be incremented to point to the last byte plus one of the matching sequence in the first file. In this embodiment locations of said sequences present in both files are stored as a given number bytes positive or negative from the position of the reference pointer.

In some embodiments the lengths and locations of the matched sequences are stored as fixed length integers. In one embodiment the length of a matched sequence is stored as a 1 byte integer wherein the integer represents a length of between 4 to 1027 bytes. In this embodiment byte lengths of matched sequences are restricted to multiples of 4. In other embodiments any other bit or byte length integers may be used to store said sequence lengths. In still other embodiments any other restrictions may be imposed on byte lengths of matched sequences including minimum and maximum lengths and limiting byte lengths to given multiples. In still other embodiments lengths of matched sequences may be stored as variable length integers. In some embodiments locations of matched sequences may be stored as variable length integers. In other embodiments locations of matched sequences are stored as fixed length integers of a given byte or bit length.

After the network appliance stores representations of lengths and locations of said sequences of data present in both the first and second files step the network appliance may create a third file comprising sequences of data from the second file and representations of locations and lengths of said sequences of data present in both the first and second files. Said creation step may occur after all the lengths and locations of matched sequences are stored or said creation may occur contemporaneously as matched sequences are found. The third file may contain representations of lengths and locations in any format discussed herein. In some embodiments lengths and locations of shared sequences may be preceded by special byte or bit sequences.

For example if a first file comprised the string abcdefghijklmnop and the second file comprised the string xxxxxxxdefghijkxxxxxxcdefxxx the third file may comprise the sequence xxxxxxx3 8xxxxxx2 4xxx . In this example 3 8 is used to indicate a representation indicating the sequence from the first file starting at byte 3 and 8 bytes long in some embodiments this representation could be two fixed length binary integers . Likewise 2 4 indicates that a representation indicating the sequence from the first file starting at byte 2 and 4 bytes long.

As another example if the first file comprised the string abcdefghijklmnop and the second file comprised the string xxxxxxxdefghijkxxxxxxcdefxxx the third file may comprise the sequence xxxxxxx3 8xxxxxx 9 4xxx . In this example locations of shared sequences are stored as relative distances from a reference pointer incremented according to the method described above. In this example the network appliance indicates the first matched sequence in the same manner as the previous example since the reference pointer initially points to the beginning of the first file. The reference pointer would then be incremented to point to location of the last byte plus one of the matching sequence in the first file. Thus the second matched sequence is indicated with 9 4 which indicates that the second matched sequence occurs nine bytes prior to the byte following the previous matched sequence in the first file.

In one embodiment the third file may be encoded in a byte protocol such as ASCII. In one embodiment each group of 7 bytes of binary data may be encoded as 8 bytes of ASCII characters. This conversion may be done by any known conversion method. The ASCII characters may correspond to any existing character set definition including 150 8859 1. In some embodiments the third file may comprise an HTML file. In one embodiment the third file may comprise a Javascript variable comprising said sequences of data from the second file and representations of locations and lengths of said sequences of data present in both the first and second files. In one embodiment the third file may also comprise a Javascript function comprising functionality for assembling said second file by processing said Javascript variable. In another embodiment the third file may contain a reference to a Javascript function comprising said functionality.

In the above example an HTML file comprises a Javascript variable named updateFile. Said variable may comprise sequences of data from the second file and representations of locations and lengths of said sequences of data present in both the first and second files. The example above also comprises a call to a Javascript function named createPage. Said function which may either be included with the HTML file or stored on the client may comprise functionality for assembling said second file using the data from the Javascript variable updateFile. In the example above a standard HTML browser would execute the createPage function upon loading the HTML page. The createPage function may also comprise functionality for altering the HTML page to display said second file once the second file is assembled.

After creating a third file comprising sequences of data from the second file and representations of locations and lengths of said sequences of data present in both the first and second files step and the network appliance may transmit the third file to a client step . Said transmission may occur via any of the networks and methods discussed herein. The network appliance may modify the third file in accordance with any function performed by the network appliance including compression acceleration and encryption.

After transmitting the third file to a client step the client may receive the third file step execute a Javascript function to recreate the second file comprising sequences of data from the second file and sequences in the first file indicated by the third file step and display the second file step . The client may perform these steps in accordance with any of the embodiments described herein.

Referring now to a flow diagram depicting another embodiment of a method for creating efficient updates to a previously stored file is shown. In brief overview the method comprises creating a hash table with entries corresponding to overlapping sequences of data in a first file step setting a reference pointer to the beginning of said first file step computing a hash value for a sequence of data in a second file step and determining whether said sequence is present in both files step . The method may then comprise either moving to the next sequence in the second file step or determining a total length for the matching sequence step and determining whether said length exceeds a minimum threshold step . The method may then comprise either moving to the next sequence in the second file step or storing the length and location of the matching sequence relative to reference pointer step . The method may then comprise setting the reference pointer to the last byte plus one of the matching sequence in the first file step and then moving to the next sequence in the second file step . In the embodiment shown the method may be performed by a network appliance .

Still referring to now in greater detail a network appliance creates a hash table with entries corresponding to overlapping sequences of data in a first file step . This step may be performed in accordance with any of the methods for creating a hash table described herein.

After creating a hash table with entries corresponding to overlapping sequences of data in a first file step the network appliance may set a reference pointer to the beginning of said first file step . The reference pointer may comprise any type of pointer.

After setting a reference pointer to the beginning of said first file step the network appliance may compute a hash value for a sequence of data in a second file step . This step may be performed in accordance with any of the methods for computing a hash value described herein.

After computing a hash value for a sequence of data in a second file step the network appliance may determine whether said sequence is present in both files step . This step may be performed in accordance with any of the methods described herein.

If a sequence is not present in both files the network appliance may move to the next sequence of the second file . Said next sequence may comprise any sequence occurring after the given sequence in the second file. In one embodiment the next sequence may be the sequence starting one byte after the previous sequence. In another embodiment the next sequence may be the sequence starting any other number of bytes after the previous sequence. In some embodiments moving to the next sequence of the second file step may be accompanied by moving a hash window as described previously herein. If no next sequence exists the method may terminate.

If a sequence is present in both files the network appliance may determine a total length of a matching sequence by comparing subsequent bytes of the matched sequences step . The total length may be determined in accordance with any of the methods described herein.

The network appliance may then determine if the total length of the matching sequence exceeds a given threshold step . This determination may be made in accordance with any of the methods described herein. If the length of the matching sequence does not exceed the minimum threshold the network appliance may move to the next sequence of the second file.

If the length does exceed the minimum threshold the network appliance may then store the length and location of the matching sequence relative to the given reference pointer in accordance with any of the methods discussed herein. The network appliance may then increment the reference pointer according to any of the methods described herein step . The network appliance may then move to the next sequence of the second file step .

Now referring to one embodiment of a method for efficiently receiving updates to previously stored files is depicted. In brief overview said method comprises receiving a assembly function step receiving a first file comprising sequences of data step displaying said first file storing said first file step receiving a third file comprising sequences of data and representations of locations and lengths of sequences in the first file step executing a Javascript function to create a second file comprising sequences of data from the second file and sequences in the first file indicated by the third file step and displaying said second file step .

Still referring to now in greater detail a network appliance may transmit a assembly function. Said assembly function may comprise any computer readable program means for assembling a second file using a file comprising sequences of data from a second file and representations of locations and lengths of said sequences of data present in both a first and second files. Said assembly function may comprise any programming or scripting language including Javascript or Java. In some embodiments the assembly function may be transmitted in accordance with any of the other network appliance functions described herein. In one embodiment the assembly function may be included in a program providing other client side acceleration functionality.

In the embodiment shown after the network appliance transmits a assembly function step a client receives the assembly function step . The client may receive said assembly function via any of the networks protocols or computing devices described herein. In some embodiments the client receives the assembly function from a network appliance . In one embodiment the assembly function may be included as part of a client side acceleration program. In other embodiments the assembly function may be installed on the client via any means of transferring software including via a disk or other portable storage device.

In the embodiment shown after receiving a assembly function step the client receives a first file comprising sequences of data. In the embodiment shown the client receives the first file from a network appliance . In other embodiments the client may receive the first file from any computing device. Said file may comprise any file type or protocol discussed herein.

After a client receives a first file comprising sequences of data step the client may display said first file step . The file may be displayed in any manner appropriate for the given file. In some embodiments the file may be displayed in a web browser. In other embodiments the file may be displayed in a business application such as a word processor or a spreadsheet. In still other embodiments the file may comprise a standalone application and be displayed as such. In some embodiments the file may correspond to an application running in a virtual computing environment. In one embodiment the file may correspond to a remotely executing application. In another embodiment the file may correspond to a streaming application.

After a client displays said first file step the client may store said first file step . The client may store the first file in any storage element including storing in a cache disk flash memory or RAM. In some embodiments the client may compress the file for storage. In other embodiments the client may store only portions of the file. In some embodiments the client may store said first file step before or during the display of said first file step .

After a client stores said first file step the client may receive a third file step . In the embodiment shown the client receives the third file from a network appliance . In other embodiments the client may receive the third file from any computing device. Said file may comprise any file type or protocol discussed herein. In some embodiments the file may comprise ASCII characters. In other embodiments the file may comprise binary data.

After a client receives said third file step the client may execute a Javascript function to assemble a second file step . In some embodiments the Javascript function may be included in said third file. In other embodiments the Javascript function may be already stored on the client . In some embodiments the Javascript function may be provided in a client side acceleration program. In some embodiments the third file may comprise a link to a location where the client may download the Javascript function.

The Javascript function may perform any technique or the reverse of any technique described herein to assemble said second file. In some embodiments the Javascript function may comprise the assembly function received in step . In other embodiments the Javascript function may comprise a reference to said assembly function. In still other embodiments said Javascript function may comprise means for downloading said assembly function.

After executing a Javascript function to assemble said second file step the client may display said second file step . The file may be displayed in accordance with any of the methods described herein for displaying a file.

Referring now to one embodiment of a method for assembling a second file from a previously stored first file and a third file comprising sequences of data from the second file and representations of locations and lengths of sequences of data present in both a first and second files is shown. In brief overview the method comprises reading a set of data from a third file step and determining whether said set of data corresponds to a locations and length of said sequences of data present in both the first and second files step . The method then may comprise reading the specified length of bytes at the specified location in said first file step adding said bytes to the second file step incrementing the reference pointer to the location of the last byte plus one of the bytes read from the first file step and moving to the next set of data from said third file step . In one embodiment said method may be performed by a client . In another embodiment said method may be performed by a assembly function as described in .

Still referring to now in greater detail a client may set a reference pointer to the beginning of the first file. This may be performed in accordance with any of the methods described herein.

After setting the reference pointer step a client may read a set of data from a third file step . Said set of data may comprise any number of bits or bytes of said third file. In one embodiment said set of data is then stored in a memory element or cache.

After reading said set of data step a client may determine whether said set of data corresponds to a length and location of a sequence in the first file. In one embodiment a client may determine whether said set of data comprises a special character or bit sequence.

If said set of data does not correspond to a length and location of a sequence in the first file the client may add said set of data to the second file step . Said addition may comprise appending said set of data to the end of the second file. The client may then move to the next set of data from the third file step .

If said data does correspond to a length and location of a sequence in the first file the client may then read the specified length of bytes at the specified location in the first file step . The client may determine the length and location specified by recognizing any of the representations of lengths and locations described herein. In one embodiment the client may then store said specified bytes in a memory element or cache.

After reading the specified length of bytes at the specified location in the first file step the client may then add said bytes to the second file step . Said addition may comprise appending said bytes to the end of the second file.

The client may then increment the reference pointer to the location of the last byte plus one of the bytes read from said first file step . This may be performed in accordance with any of the methods described herein. The client may then move to the next set of data from said third file. step .

Referring now to one embodiment of a method for determining a file transmission method is shown. Said method may be performed by any of the machines or combinations of machines described above although the embodiment below describes the method being performed by a network appliance . In brief overview the method comprises receiving a request from a client for a resource step sending a request for said client s capabilities step receiving information conveying said client s capabilities step and determining a file transmission method step .

Still referring to now in greater detail the network appliance receives a request from a client step . In one embodiment receiving a request from a client step comprises receiving a request directly from a client. In other embodiments the request from a client may be received from any of the networks connections and appliances previously discussed. Said request may comprise any of the protocols previously discussed. In some embodiments the request may comprise the request exactly as transmitted from the client . In other embodiments the request may comprise a modification of an original request from a client . Said modifications may comprise modifications in the course of providing any of the network appliance services discussed above and any other modifications to the content format protocol addressing headers or other portions of the request. request from a client or a new request. A request may comprise a resource directly requested by a client and it may comprise a resource requested in the course of performing any service for the client .

After receiving a request from a client step the network appliance sends a request for said client s capabilities step . In one embodiment said request may be sent to the client . In another embodiment request may be sent to a collection agent as described in U.S. patent application Ser. No. 10 956 832 A METHOD AND APPARATUS FOR ASSIGNING ACCESS CONTROL LEVELS IN PROVIDING ACCESS TO NETWORKED CONTENT FILES whose contents are expressly incorporated herein by reference. Said collection agent may reside on the same physical machine as the network appliance sending the request or they may reside on different physical machines. Said request may also be sent to a file a cache a database a server an executing application or any other source of information concerning the client .

After sending a request for the client s capabilities step the network appliance receives information conveying said clients capabilities step . Said information may be received from a client a collection agent a file a cache a database a server an executing application or any other source of information concerning the client . Said information may comprise without limitation machine ID of a client node operating system type existence of a patch to an operating system MAC addresses of installed network cards a digital watermark on the client device membership in an Active Directory existence of a virus scanner existence of a personal firewall an HTTP header browser type device type network connection information authorization credentials and any of the other capabilities or preferences discussed above. In some embodiments the network appliance may store or cache said information for later retrieval.

After receiving information conveying said clients capabilities step the network appliance may determine a file transmission method corresponding to said client step . Said determination may be made on the basis of any of the information received.

In some embodiments the network appliance may determine in response to information received in step to transmit files in accordance with the method for creating efficient updates to a previously stored file described in . In one embodiment said determination may be made in response to information corresponding to the client s memory size connection speed connection bandwidth processor speed or the prior existence of a stored file.

In some embodiments the network appliance may determine in response to information received in step to transmit a assembly function to the client . For example the network appliance may transmit a assembly function to a client if the network appliance receives information that the client does not possess the assembly function and the information indicates the client has the capability to execute a assembly function. In some embodiments said assembly function may be transmitted along with any other files including requested content files or other files transmitted in accordance with the functions of the network appliance . In some embodiments a network appliance may possess a plurality of assembly functions. For example a network appliance may possess a number of assembly functions optimized for different computing environments operating systems and hardware configurations. The network appliance may then determine in response to the information received in step which assembly function to transmit to a client .

While the invention has been particularly shown and described with reference to specific preferred embodiments it should be understood by those skilled in the art that various changes in form and detail may be made therein departing from the spirit and scope of the invention as defined by the appended claims.

