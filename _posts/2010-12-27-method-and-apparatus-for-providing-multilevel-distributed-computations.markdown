---

title: Method and apparatus for providing multi-level distributed computations
abstract: An approach is provided for providing multi-level distributed computations. A distributed computation manager receives at least one request to migrate at least one computation closure within a computational architecture, the computational architecture comprising a plurality of architectural levels including, at least in part, a device level, an infrastructure level, and a cloud computing level. The distributed computation manager also determines to select at least one of the architectural levels based, at least in part, on a determination of whether the network infrastructure level can support the at least one computation closure. The distributed computation manager further determines to migrate the at least one computation closure to the selected at least one of the architectural levels.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09396040&OS=09396040&RS=09396040
owner: Nokia Technologies Oy
number: 09396040
owner_city: Espoo
owner_country: FI
publication_date: 20101227
---
Mobile devices with various methods of connectivity are now for many people becoming the primary gateway to the internet and also a major storage point for personal information. This is in addition to the normal range of personal computers and furthermore sensor devices plus internet based providers. Combining these devices together and lately the applications and the information stored by those applications is a major challenge of interoperability. This can be achieved through numerous individual and personal information spaces in which persons groups of persons etc. can place share interact and manipulate webs of information with their own locally agreed semantics without necessarily conforming to an unobtainable global whole.

Furthermore in addition to information the information spaces may be combined with webs of shared and interactive computations or computation spaces consisting of a multitude of devices so that each device as parts of the computation spaces can have the information in the information space manipulated within the computation space environment which may include devices other than the device and the results delivered to the device rather than the whole process being performed locally in the device. These combined information spaces and computation spaces often referred to as computation clouds are extensions of the Giant Global Graph in which one can apply semantics and reasoning at a local level.

In one example clouds are working spaces respectively embedded with distributed information and computation infrastructures spanned around computers information appliances processing devices and sensors that allow people to work efficiently through access to information and computations from computers or other devices. An information space or a computation space can be rendered by the computation devices physically presented as heterogeneous networks wired and wireless . However despite the fact that information and computation presented by the respective spaces can be distributed with different granularity still in certain example implementations achieving scalable high context information processing within such heterogeneous environments is a challenging task. For example in various implementations due to distributed nature of the cloud exchange of data information and computation elements e.g. computation closures among distributed devices involved in a cloud infrastructure may require excessive amount of resources e.g. Process time process power storage space etc. . However different levels of proactive computational elements may be available to the device in various other components of various architectural levels wherein different distributed components may have different capabilities and support different processes. In various example circumstances to enhance the information processing power of a device and reduce the processing cost one might consider minimizing or at least significantly improving exchange of data information and computations among the distributed components.

In various example embodiments we can minimize or improve or significantly improve data migration within a computational architecture by providing multi level distributed computations such that the data can be migrated to the closest possible computation level with minimized or improved cost.

According to one embodiment a method comprises receiving a request to migrate at least one computation closure within a computational architecture the computational architecture comprising a plurality of architectural levels including at least in part a device level an infrastructure level and a cloud computing level. The method also comprises determining to select at least one of the architectural levels based at least in part on a determination of whether the network infrastructure level can support the at least one computation closure. The method further comprises determining to migrate the at least one computation closure to the selected at least one of the architectural levels.

According to another embodiment an apparatus comprises at least one processor and at least one memory including computer program code the at least one memory and the computer program code configured to with the at least one processor cause at least in part the apparatus to process and or facilitate a processing of at least one result of at least one request to migrate at least one computation closure within a computational architecture the computational architecture comprising a plurality of architectural levels including at least in part a device level an infrastructure level and a cloud computing level. The at least one result is also based at least in part on at least one selection of at least one of the architectural levels based at least in part on a determination of whether the network infrastructure level can support the at least one computation closure. The at least one result is further based at least in part on at least one migration of the at least one computation closure to the selected at least one of the architectural levels.

According to another embodiment a computer readable storage medium carries one or more sequences of one or more instructions which when executed by one or more processors cause at least in part an apparatus to process and or facilitate a processing of at least one result of at least one request to migrate at least one computation closure within a computational architecture the computational architecture comprising a plurality of architectural levels including at least in part a device level an infrastructure level and a cloud computing level. The at least one result is also based at least in part on at least one selection of at least one of the architectural levels based at least in part on a determination of whether the network infrastructure level can support the at least one computation closure. The at least one result is further based at least in part on at least one migration of the at least one computation closure to the selected at least one of the architectural levels.

According to another embodiment an apparatus comprises means for receiving at least one request to migrate at least one computation closure within a computational architecture the computational architecture comprising a plurality of architectural levels including at least in part a device level an infrastructure level and a cloud computing level. The apparatus also comprises means for determining to select at least one of the architectural levels based at least in part on a determination of whether the network infrastructure level can support the at least one computation closure. The apparatus further comprises means for determining to migrate the at least one computation closure to the selected at least one of the architectural levels.

In addition for various example embodiments of the invention the following is applicable a method comprising facilitating a processing of and or processing 1 data and or 2 information and or 3 at least one signal the 1 data and or 2 information and or 3 at least one signal based at least in part on or derived at least in part from any one or any combination of methods or processes disclosed in this application as relevant to any embodiment of the invention.

For various example embodiments of the invention the following is also applicable a method comprising facilitating access to at least one interface configured to allow access to at least one service the at least one service configured to perform any one or any combination of network or service provider methods or processes disclosed in this application.

For various example embodiments of the invention the following is also applicable a method comprising facilitating creating and or facilitating modifying 1 at least one device user interface element and or 2 at least one device user interface functionality the 1 at least one device user interface element and or 2 at least one device user interface functionality based at least in part on a data and or information resulting from one or any combination of methods or processes disclosed in this application as relevant to any embodiment of the invention and or b at least one signal resulting from one or any combination of methods or processes disclosed in this application as relevant to any embodiment of the invention.

For various example embodiments of the invention the following is also applicable a method comprising creating and or modifying 1 at least one device user interface element and or 2 at least one device user interface functionality the 1 at least one device user interface element and or 2 at least one device user interface functionality based at least in part on data and or information resulting from one or any combination of methods or processes disclosed in this application as relevant to any embodiment of the invention and or at least one signal resulting from one or any combination of methods or processes disclosed in this application as relevant to any embodiment of the invention.

In various example embodiments the methods or processes can be accomplished on the service provider side or on the mobile device side or in any shared way between service provider and mobile device with actions being performed on both sides.

For various example embodiments the following is applicable An apparatus comprising means for performing the method of any of originally filed claims and .

Still other aspects features and advantages of the invention are readily apparent from the following detailed description simply by illustrating a number of particular embodiments and implementations including the best mode contemplated for carrying out the invention. The invention is also capable of other and different embodiments and its several details can be modified in various obvious respects all without departing from the spirit and scope of the invention. Accordingly the drawings and description are to be regarded as illustrative in nature and not as restrictive.

Examples of a method apparatus and computer program for providing multi level distributed computations are disclosed. In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the embodiments of the invention. It is apparent however to one skilled in the art that the embodiments of the invention may be practiced without these specific details or with an equivalent arrangement. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the embodiments of the invention.

As used herein the term computation closure identifies a particular computation procedure together with relations and communications among various processes including passing arguments sharing process results flow of data and process results etc. The computation closures e.g. a granular reflective set of instructions data and or related execution context or state provide the capability of slicing of computations for processes associated with services applications device setups e.g. provided by manufacturer etc. and transmitting the computation slices between devices infrastructures clouds information sources etc.

As used herein the term cloud refers to an aggregated set of information and computation closures from different sources. This multi sourcing is very flexible since it accounts and relies on the observation that the same piece of information or computation can come from different sources. In one embodiment information and computations within the cloud are represented using Semantic Web standards such as Resource Description Framework RDF RDF Schema RDFS OWL Web Ontology Language FOAF Friend of a Friend ontology rule sets in RuleML Rule Markup Language etc. Furthermore as used herein RDF refers to a family of World Wide Web Consortium W3C specifications originally designed as a metadata data model. It has come to be used as a general method for conceptual description or modeling of information and computations that is implemented in web resources using a variety of syntax formats. Although various embodiments are described with respect to clouds it is contemplated that the approach described herein may be used with other structures and conceptual description methods used to create distributed models of information and computations.

The basic concept of cloud computing technology provides access to distributed computations for various devices within the scope of the cloud in such a way that the distributed nature of the computations is hidden from users and it appears to a user as if all the computations are performed on the same device. The cloud computing also enables a user to have control over computation distribution by transferring computations between devices that the user has access to. For example a user may want to transfer computations among work devices home devices and portable devices. Current technologies enable a user of a mobile device to manipulate contexts such as data and information via the elements of a user interface of their user equipment. However a user does not have control over the distribution of computations and processes related to or acting on the data and information within the cloud. In other words a cloud in general does not provide a user e.g. an owner of a collection of information distributed over the information space with the ability to control distribution of related computations and processes of for instance applications acting on the information. For example a contact management application that processes contact information distributed within one or more clouds generally executes on a single device e.g. with all processes and computations of the application also executing on the same device to operate on the distributed information. In some cases e.g. when computations are complex the data set is large etc. providing a means to also distribute the related computations in addition to the information is advantageous.

This goal is achieved by introduction of the capability to construct distribute and aggregate computations as well as their related data. More specifically to enable a user of a cloud who connects to the cloud via one or more user devices to distribute computations among the one or more user devices or other devices with access to the cloud each computation is deconstructed to its basic or primitive processes or computation closures. Once a computation is divided into its primitive computation closures the processes within or represented by each closure may be executed in a distributed fashion and the processing results can be collected and aggregated into the result of the execution of the initial overall computation.

In one embodiment a computational architecture consists of a plurality of architectural levels including a device level and infrastructure level and a cloud computing level. A device from the device level has connectivity to the cloud computing level via an infrastructure level wherein the infrastructure level may consist of layers and components such as backbones routers base stations etc. Typically the computation closures associated with a process related to a device from device level are typically defined constructed and executed within the cloud computing level which may have various levels of distribution as well. However the components of the infrastructure level may be equipped with various resources e.g. processing environments storage spaces etc. that can be utilized for the execution of computation closures associated with a process. Since the infrastructure level functions as an interface between the device level and the cloud computing level if the computation closures can be executed in the infrastructure level there will be no need for the computation closures to be migrated to the cloud computing level that may very well require excessive use of resources. Therefore execution of computation closures associated with a process related to a device at the infrastructure level can provide services to device users in a more efficient manner.

In order to achieve this goal a system of introduces the capability to provide multi level distributed computations. A computational architecture environment consists of different levels of proactive computational elements available for various levels of the architecture such as device level infrastructure level and cloud computing level. Since these computational elements provide various levels of functionality for each of the levels providing different levels of migration of the computational closures within the architecture enables the execution of the computational closures after the least required level of migration. This approach enables the device to utilize available processing power within the computational infrastructure by having certain functionalities migrated to the infrastructure level or further to the cloud level depending on the type of functionality needed by the device or offered by every level of the architecture.

In one embodiment each level of the computational architecture may consist of multiple layers such that if one layer does not have access to proper resources for executing received migrated computation closures the closures can be transfer to other layers within the same level of architecture before being migrated to the next level. Each layer of an architecture level may include multiple components. If all resources in the current layer of architectural level are exhausted the closures may be migrated to other layers other infrastructures the next level of architecture to the cloud or to other clouds.

In one embodiment if a component of an architecture level or a layer of the level lacks resources for executing received computations the component may request to gain access to resources from other components in the same or different levels or layers. The computation closures may be migrated between infrastructure layers and levels if components of the current layer or level cannot provide enough resources in response to the request.

As shown in the system comprises a set of user equipment UEs having connectivity to distributed computation manager via a communication network . By way of example the communication network of system includes one or more networks such as a data network not shown a wireless network not shown a telephony network not shown or any combination thereof. It is contemplated that the data network may be any local area network LAN metropolitan area network MAN wide area network WAN a public data network e.g. the Internet short range wireless network including wireless personal area networks ad hoc networks device to device networks etc. or any other suitable packet switched network such as a commercially owned proprietary packet switched network e.g. a proprietary cable or fiber optic network and the like or any combination thereof. In addition the wireless network may be for example a cellular network and may employ various technologies including enhanced data rates for global evolution EDGE general packet radio service GPRS global system for mobile communications GSM Internet protocol multimedia subsystem IMS universal mobile telecommunications system UMTS etc. as well as any other suitable wireless medium e.g. worldwide interoperability for microwave access WiMAX Long Term Evolution LTE networks code division multiple access CDMA wideband code division multiple access WCDMA wireless fidelity WiFi wireless LAN WLAN Bluetooth Internet Protocol IP data casting satellite mobile ad hoc network MANET and the like or any combination thereof.

The UEs are any type of mobile terminal fixed terminal or portable terminal including a mobile handset station unit device multimedia computer multimedia tablet Internet node communicator desktop computer laptop computer notebook computer netbook computer tablet computer Personal Digital Assistants PDAs audio video player digital camera camcorder positioning device television receiver radio broadcast receiver electronic book device game device or any combination thereof including the accessories and peripherals of these devices or any combination thereof. It is also contemplated that the UE can support any type of interface to the user such as wearable circuitry etc. .

In one embodiment the UEs are respectively equipped with one or more user interfaces UI . Each UI may consist of several UI elements not shown at any time depending on the service that is being used. UI elements may be icons representing user contexts such as information e.g. music information contact information video information etc. functions e.g. setup search etc. and or processes e.g. download play edit save etc. . Additionally each UI element may be bound to a context process by granular migration. In one embodiment granular migration enables processes to be implicitly or explicitly migrated between devices computation clouds and other infrastructure.

In one embodiment process migration can be initiated for example by means of unicast e.g. to just another device multicast e.g. to multiple other devices or broadcast e.g. within limited area to broadcast computation process migration initiation to get best results. This may be done by for example utilizing broadcast and select from one or all devices within that area. Additionally process migration may be triggered via gesture recognition wherein the user preselects a particular set of UI elements and makes a gesture to simulate pouring the selected UE elements from one device to another. In other embodiments process migration may be initiated automatically without direct user involvement and based on default setup by the manufacturer of the UE previous setup by the user of the UE default setup in an application activated on or associated with a UE or a combination thereof.

As seen in a user of UEs may own use or otherwise have access to various pieces of information and computations distributed over one or more computation clouds in information stores and computation stores where each of the one or more computation spaces include multiple sets of one or more computation closures.

In one embodiment the communication network consists of one or more infrastructures wherein each infrastructure is a designed communication system including multiple components . An infrastructure may be logical or physical wherein a logical infrastructure e.g. Virtual Private Network VPN can be composed of multiple physical infrastructures. The components include backbones routers switches wireless access points access methods protocols etc. used for communication within the communication network or between communication network and other networks.

In one embodiment the distributed computation manager manages and monitors the distribution of computations associated with UEs to other levels of the architecture including the infrastructure level within the environment of the communication network and the cloud level 

In another embodiment network components may provide different levels of functionality. For example some components may provide static computational closures while others may provide dynamic computational closures. As used herein static computational closures are closures with predetermined configurations while dynamic computational closures are closures that may function differently based on dynamic factors such as time traffic load type of available power resource etc. A dynamic computation closure may adjust itself based on the dynamic factor by modifying parameters such as the amount of reserved resources. Additionally each architecture level e.g. infrastructure may support different types of closures or may have certain sets of pre created entries for closures and relevant links.

In one embodiment the amount and type of available computational closures at a component of the infrastructure may or may not be aligned with the required computation closures by UE through a one to one mapping. This means that the component may need to locate request further computational elements from current or next layer or level of the architecture. In other words if the computation closures between a process and its processing environment are not directly aligned the processing environment may expand its computation closures for dynamic closures or request additional computational closures from other components for static closures or a combination thereof.

In one embodiment the computational closures available in multiple levels of device level infrastructure level and cloud level are either aligned meaning that all the computational closures are available in every level or a super set of all computational closures is available at cloud level while each lower level has access to a sub set of the computational closures from its higher level for example infrastructure level computational closures may be a sub set of the closures of cloud level and device level closures a sub set of the infrastructure level closures.

By way of example the UE and the distributed computation manager communicate with each other and other components of the communication network using well known new or still developing protocols. In this context a protocol includes a set of rules defining how the network nodes within the communication network interact with each other based on information sent over the communication links. The protocol may also include rules for determining when to transfer computations to another architecture level component etc. The protocols are effective at different layers of operation within each node from generating and receiving physical signals of various types to selecting a link for transferring those signals to the format of information indicated by those signals to identifying which software application executing on a computer system sends or receives the information. The conceptually different layers of protocols for exchanging information over a network are described in the Open Systems Interconnection OSI Reference Model.

Communications between the network nodes are typically effected by exchanging discrete packets of data. Each packet typically comprises 1 header information associated with a particular protocol and 2 payload information that follows the header information and contains information that may be processed independently of that particular protocol. In some protocols the packet includes 3 trailer information following the payload and indicating the end of the payload information. The header includes information such as the source of the packet its destination the length of the payload and other properties used by the protocol. Often the data in the payload for the particular protocol includes a header and payload for a different protocol associated with a different higher layer of the OSI Reference Model. The header for a particular protocol typically indicates a type for the next protocol contained in its payload. The higher layer protocol is said to be encapsulated in the lower layer protocol. The headers included in a packet traversing multiple heterogeneous networks such as the Internet typically include a physical layer 1 header a data link layer 2 header an internetwork layer 3 header and a transport layer 4 header and various application headers layer 5 layer 6 and layer 7 as defined by the OSI Reference Model.

The request analysis module may also analyze the received computation closures regarding the level of support and resources needed for the execution of the computation closures. The request analysis module may also evaluate the level of support needed for the request against the level of support available at every level of the architecture. The request analysis module may store the analysis results in storage .

In one embodiment the architectural level selector determining to select at least one of the architectural levels based at least in part on a determination of whether the network infrastructure level can support the at least one computation closure as seen in step of . The architectural level selector may use the analysis results stored in storage by the request analysis module . Typically the computation closures may be migrated to the computation cloud however in one embodiment the architectural level selector may select an available component in the infrastructure level for migrating the closures and select a component in the computation cloud level only if no support is available at the infrastructure level.

In another embodiment the architectural level selector may use previously calculated information at an architectural level or the components of the architectural levels for selecting the level or one or more components of the level for closure migration. For example an architectural level may have previously calculated results from various input alternatives e.g. static computational closures wherein input alternatives are known and computational results are calculated and stored in advance. In this embodiment the output results can be selected from pre created entry alternatives. It is noted that some components provide more static computational closures while other components may vary more for example based on time traffic load power resources etc. In one embodiment the distributed computation manager may reserve a larger or a smaller portion of the static or dynamic computational closures in components of the architectural levels.

In one embodiment the architectural level selector may use cost calculation methods or any other selection parameters for selecting a suitable level for computation migration. For example factors such as relative cost of power consumption for battery usage versus main supply usage or cost of changes in devices network etc. and their effect on computation closure alignment among devices can be calculated. Additionally priority levels may be assigned to selection methods and preferred sets of selection methods can be used based on their priority levels. For example sets of most used selection methods or sets of most recommended selection methods for each specific computation type may receive highest priority levels wherein the recommendation can be for example determined based on certain parameters defined by user application service provider etc. The architectural level selector may use the calculated cost or other parameters to compare and find the difference between available capabilities at an architectural level and the capabilities required by the migrating computation closures.

In one embodiment the migration module determining to migrate the at least one computation closure to the at least one of the architectural levels selected by the architectural level selector module as per step of . It is noted that migration of closures from UEs of the device level to the infrastructure level is a less costly process than the migration of closures from device level to the cloud level . This is because any communication between the device level and cloud level has to be through the infrastructure level . In other words the infrastructure level is halfway between the device level and the cloud level 

It is noted that computation closures are primitive building blocks of processes and various computation closures may have common or similar elements. If one or more computation closures are supposed to be migrated from a level of the architecture to another level of the architecture to be executed and other computation closures with the same functionalities as the migrating computation closures are found in the destination level the migrating closures will not have to be migrated because they can be substituted by the similar closures found and the similar closure found can be executed instead of the migrating closures at the destination level.

In one embodiment the mapping alignment module determines to map to verify and or to validate one or more elements one or more functions or a combination thereof associated with the at least one computation closure against one or more other elements one or more other functions or a combination thereof of one or more other computation closures associated with any one or more of the architectural levels or . In one embodiment the architectural level selector may use the results from the mapping verification and validation of computation closures by the mapping alignment module for determining to select the at least one architectural level. For example if elements of the migrating computation closures are mapped into the elements of computation closures associated with more than one components of an architectural level the architectural level selector may select the component with higher number of mapped elements which requires less closure migration for the execution. In other embodiments the architectural level selector may select the components with higher processing power for more complex mapped elements etc.

In another embodiment the mapping alignment module may determine one or more predetermined configurations for distributing the at least one computation closure. For example a predetermined configuration may state that computation closure with certain characteristics or certain complexity levels must be executed at certain pre assigned components of certain architectural levels. A predetermined configuration may also include logical conditions that the selection of the architectural level should be based on. In one embodiment the architectural level selector selects the at least one of the architectural levels based at least in part on the one or more predetermined configurations.

In one embodiment the predetermined configuration may override the map verify and or validate results from the mapping alignment module . In other embodiments the results may override the predetermined configuration. Yet in other embodiments a combined selection approach may be used based on the results and the configuration.

In one embodiment the mapping alignment module determines an alignment of the at least one computation closures among one or more of the architectural levels. It is noted that a one to one alignment between the computation closures associated with the process and the computation closures associated with an architectural level may not be found. It means that the architectural level selector may need to locate further components from current or next architectural levels for process migration. For example the computation closures associated with the process may be partly aligned with computational closures of one or more components of the infrastructure level and partly aligned with computational closures of one or more components of the cloud computing level wherein the total process is covered with the alignments. In this case the architectural level selector may determine to select the at least one of the architectural levels based at least in part on the alignment. In one embodiment if even multi level alignment does not cover the process completely the migration module may exchange computation closures between levels wherein the closure exchange may be modular system specific general or a combination thereof. It is noted that if the cloud level is involved in the alignment all the needed computation closures may be available via the cloud however migration of computation closures from for example device level to infrastructure level may be more cost effective than the migration of the closures from the cloud level to infrastructure level.

In one embodiment following the selection of at least one architectural level by the architectural level selector the recommendation module determines resource availability information associated with the selected architectural levels. The recommendation module may use components configuration data manufacturer data system logs or a combination thereof for determining the available resources. In this embodiment the recommendation module may provide at least one recommendation at least one instruction or a combination thereof for increasing resource availability at the selected at least one of the architectural levels. For example the recommendation module may instruct one or more current execution at the selected level to be temporarily or permanently terminated so that the resources utilized for the current process can be assigned to the migrating process. The recommendation module may select the terminating processes based on the process priorities. The priorities may be part of a predetermined configuration determined by the user determined by a component of the architectural level or a combination thereof. The recommendation module may also recommend resources from other components or other levels to be borrowed for the execution of the migrating process. The recommendation module may store the recommendations or instructions in storage to be used by the migration module for process migration.

It is noted that subsequent to the selection of one or more architectural levels by the architectural level selector one or more changes may occur in the selected at least one of the architectural levels. For example the resources may become unavailable the components may be invalidated new security privacy or other protocols may be applied etc. In one embodiment the migration module determines one or more changes at the selected at least one of the architectural levels and determines to reject to delay to withdraw and or to redistribute the migration of the at least one computation closure based at least in part on the one or more changes. The determination of what action to take when change occurs may be based on the status and type of the change e.g. temporary permanent intentional accidental etc. the priority or importance level of the migrating process e.g. system process application process user defined process etc. or a combination thereof. Furthermore the action may be taken immediately after a change is diagnosed or after a certain threshold.

In one embodiment the distributed computation manager performs the process of and is implemented in for instance a chip set including a processor and a memory as shown in .

In various embodiments a UE of device level is able to forward at least partially its computation closures to infrastructure from the infrastructure level in order to do proactive computing by assigning functionalities associated to the computation closures to the infrastructure . It is noted that an infrastructure consists of one or more components wherein each component may be equipped with resources that can be utilized for execution of computation closures. For example a router or a base station may have available storage processing power information and computation stores suitable for the execution of migrated processes.

In other embodiments a UE may prioritize computational forwarding to cloud against forwarding to an infrastructure based on various parameters related to security privacy local and or global recommendations cost etc. The UE may also prefer an infrastructure for migration of certain computations and lock those computations in that specific level so that the computations are always executed in that architectural level until the preference is modified or removed.

In arrows represent the direction and steps of process migration from device level to cloud level . In one exemplary embodiment following the receiving and analysis of a request for migration of one or more computation closures by the distributed computation manager as seen in step of the architectural level selector from the distributed computation manager may investigate existence of support for the migration starting from the lowest layer of the infrastructure e.g. modems . At every layer if support capability is found at the layer or by the combined resources of the current layer and the layers below the current layer the investigation may end and the migration of computation closures may start otherwise other layers of the architectural level is searched for support. For example if the architectural level selector determines that the resources available at the base station or combined resources from the base station router and modem can support the at least one computation closures that are being migrated the supporting layers can be selected and the migration module can start the migration process. In this example there will be no need for the architectural level selector to investigate neither the support capability of layers and from the infrastructure level nor the support capability of the cloud level . Additionally in this example any communication between the device level and selected architectural levels migration transfer of execution results etc. will be performed in three steps as seen by arrows compared to the typical approach wherein the migration destination is always the cloud level and the infrastructure level is used as interfaces only meaning that the migration math will include the complete path . It is noted that the approach described can benefit from the resources available at the infrastructure level and eliminate extra steps of migration to the cloud level which may save resources and increase the throughput of the whole system .

In one embodiment at every step of the migration process the distributed computation manager announces within the current architecture the current status of computation closures such as the device selected to be in charge of the computation whether the closures are being sent to the next level of the architecture etc. For example during the investigation process by the architectural level selector for finding a suitable component it may be concluded that changes in the initial UE or in device level in general may have enabled the UE or another UE to execute the process and there is no need for migration. In this case the component is just used as a bridge point for directing computation requirements back to the device level. For example a UE with a low battery power may have been plugged to the power supply and therefore able to execute the process it initially requested to be migrated.

In other embodiments any change in the component selected by architectural level selector for executing the computation may cause the computations to be redistributed to other components within the same or other architectural levels.

In one embodiment the architectural level selector enumerates and collects all available computation closures in the components of the infrastructure into a set and store the set in the infrastructure storage . In one embodiment the infrastructure map of available computation closures may be stored at the infrastructure dispatcher centrally stored . In other embodiments the architectural level selector may compare the migration request from UE individually with the functionalities with each component of the infrastructure to determine whether enough computation closures functionalities are supported distributed determination . The comparison among the computation closures and the available functionalities is depicted by arrow . In the embodiment of the functionalities that support computation closures of set are found in components and of infrastructure shown as set . Therefore the architectural level selector may select components and and the migration module may migrate the process of closures to the infrastructure shown by arrow .

In one embodiment the distributed computation manager provides the option for the architectural level to reject or delay and for the UE to delay or withdraw the computation closures migration activity if there are changes in configurations or the state of the selected components or the requesting UEs. For example changes such as power shortage malfunctioning or congestion at target component may trigger the rejection or delay of the migration. In this case the computation closures may be forced forwarded by the migration module to another component e.g. a component with similar computational closure capabilities selected by the architectural level selector . The forcing of the closures to another component may be done either immediately or after a certain threshold is crossed over.

In one embodiment the architectural level selector may determine and collect computational closures capabilities of various components of the infrastructure and store the determined information is storage for further use. For example the architectural level selector may collect the capability information at its first encounter with an infrastructure during each computational closure activity period etc. and create update and store a computational closure capability map for each architectural level at the storage .

In one embodiment UEs from set are informed about capabilities found in infrastructure components via a base station or other components of the infrastructure. The base station may periodically exchange updated information about available capabilities with the UEs or send the updated information to each UE upon request.

In one embodiment the distributed computation manager sets a computational granularity level among UEs and the components of infrastructure . The granularity level may be set individually or for a set of UEs and a set of components at a time. This setting provides initial information for the architectural level selector for narrowing or expanding the selection options for process migration.

As previously discussed the capabilities of either point of the migration e.g. UE or component may change. For example a component may lose its power supply the UE may be plugged to main power supply instead of being operated by a battery etc. In such cases the migration module determines the change and adjusts the migration accordingly by for example withdrawing delaying redistributing closures to other components etc.

In one embodiment the distributor may initiate a request for computation migration to device . The request may be in the form of a query a signal a message or any combination thereof. The request is received and processed by the request analysis module of the distributed computation manager . The architectural level selector selects the level for migration as previously discussed in .

In one embodiment following the selection of the architectural level the migration module starts process migration from device to component of infrastructure as shown by arrow . As seen the migration is performed by distributor . Subsequently the migrated closures are received at device by distributor . The migration module may verify whether any changes has occurred in any of the devices or and determine to reject delay withdraw or redistribute computation closures. If no changes occurred the distributor facilitates further process of the received computation closures. The closures may be stored in a storage processed by the data manipulation layer etc.

In one embodiment the backend device may be equipped with a closure recycling and marshaling component that monitors and manages any access to the computation closure store . In other embodiments the closure recycling and marshaling i.e. standardization for uniform use may be a function of the distributed computation manager .

In one embodiment the computation closures within environments and the computation closures store may be composed based on anonymous function objects and automatically created by a compiling system using methods for generating anonymous function objects such as lambda expressions.

In another embodiment the computation closure environment has a developer experience module that provides various tools for a developer for manipulating services offered by the UE . The tools may include standardized and or abstract data types and services allowing the developers to chain processes together across development platforms. In one embodiment the developer experience module provides cross platform support for abstract data types and services under the supervision of a distributed computation manager as discussed in . The agent Agent retrieves the computation closures required by the developer experience module from the computation closures store and stores the newly generated computation closures by the developer experience module into the computation closures store for migration purposes per arrow .

In yet another embodiment the computation closure environment has a scalable computing module that provides an abstract wrapper i.e. monadic wrapper for the migrating closures . This abstraction provides computation compatibility between the closures and the UE . The abstract wrapper may provide scheduling memory management system calls and other services for various processes associated with the closures . These services are provided under the supervision of the distributed computation manager as discussed in . The agent Agent retrieves the computation closures required by the scalable computing module from the computation closures store and stores the newly generated computation closures by the scalable computing module into the computation closures store for migration purposes per arrow . In one embodiment the backend environment may access the computation closure store and exchange migrate one or more computer closures between the computation closures store and the backend computation closures store .

In one embodiment migration of process by the migration module of the distributed computation manager includes migration of closures combinators and the process states as independent elements into for instance an infrastructure environment . The independent closures from infrastructure environment may be distributed into different components where they may be executed.

It is assumed in this example that component of an infrastructure level not shown is selected by the architectural level selector of the distributed computation manager as a destination for closure migration from UE . The extracted computation closure closure  is migrated to component by the migration module and executed on component

In one embodiment the component receives the computation closure closure  and extracts it from the computation closure store using the Get command . The extracted closure  is projected into a closure with the user device context process states and the object is produced. The block represents the reconstruction of the closure into the initial context by a component in charge of the execution. The aggregated context may then be executed in the run time environment of component by Agent.

In another embodiment the UE and component may exchange places and the migration is performed from the component to UE or both devices may be UEs. In this embodiment the decomposition and aggregation processes are similar to the above example.

In one embodiment the UE may include RDF store which holds computation closures for processes associated with the UE . Similarly the backend device may includes a RDF store which holds computation closures associated with processes related to device UEs or any other devices having connectivity to device or cloud .

In other embodiments the Uniform Resource Identifiers URIs in UE and in backend device may be used to identify names or resources accessible to their respective devices via the communication network . Furthermore the legacy codes associated with each device may be stored in legacy code memory areas and on UE and and on backend device

In one embodiment UE may be provided with a non volatile memory space as a closure store. The closure store may include a set of closure primitives shown as geometric objects similar to primitives of sets or of of . Similarly the backend device may be provided with a non volatile memory space as a closure store. The closure store may also include a set of closure primitives shown as geometric objects. In one embodiment the closure store is a subset of closure store determined at least in part based on one or more criteria such as time of access frequency of access a priority classification etc. Since non volatile memories are costly and require extensive resources e.g. power consumption compared with volatile memories such as and the capacity of non volatile memory on a UE is limited. However a backend device serving high numbers of users may be equipped with larger volumes of non volatile memory spaces. Because of the limited capacity of non volatile memory spaces on UEs a subset of the closure store is stored locally at the closure store for local use by the UE . In order to minimize the number of times a UE needs to retrieve one or more primitives from closure store of device the subset is determined based on one or more criteria. In one embodiment the closure store may be determined as a set of the most frequently accessed closure primitives of closure store by UE . In another embodiment the closure store may be determined as a set of the most recently accessed closure primitives of closure store by UE . In other embodiments various combined conditions and criteria may be used for determining subset from set as the content of closure store for UE . Furthermore the closure stores and may be periodically synchronized. The synchronization of closure stores ensures that any changes addition deletion modification etc. in closure primitives of closure store are reflected in the closure store .

In one embodiment for execution of a closure set a subset of closure store associated with a process on UE the set can be migrated by the migration module of the distributed computation manager to the backend device which is a component of the infrastructure the migration path shown as arrow . The distributed computation manager may then inform the processing components of the UE the backend device or a combination thereof the processing components are not shown that the closure primitives are ready for execution.

In one embodiment any changes on the closure store of the backend device e.g. addition deletion modification etc. may first enter the URIs via the communication network . The changes may then be applied from URIs on closure store shown by arrows . Similarly the closure store is updated based on the content of the closure store and the updates are shared with other components within UE e.g. with URIs as shown by arrows .

In one embodiment as seen in the commonly accessible memory address space is formed from the RDF stores and and the closure stores and . The commonly accessible memory address space can be accessed as a continuous memory space by each of the devices and

The processes described herein for providing multi level distributed computations may be advantageously implemented via software hardware firmware or a combination of software and or firmware and or hardware. For example the processes described herein may be advantageously implemented via processor s Digital Signal Processing DSP chip an Application Specific Integrated Circuit ASIC Field Programmable Gate Arrays FPGAs etc. Such exemplary hardware for performing the described functions is detailed below.

A bus includes one or more parallel conductors of information so that information is transferred quickly among devices coupled to the bus . One or more processors for processing information are coupled with the bus .

A processor or multiple processors performs a set of operations on information as specified by computer program code related to providing multi level distributed computations. The computer program code is a set of instructions or statements providing instructions for the operation of the processor and or the computer system to perform specified functions. The code for example may be written in a computer programming language that is compiled into a native instruction set of the processor. The code may also be written directly using the native instruction set e.g. machine language . The set of operations include bringing information in from the bus and placing information on the bus . The set of operations also typically include comparing two or more units of information shifting positions of units of information and combining two or more units of information such as by addition or multiplication or logical operations like OR exclusive OR XOR and AND. Each operation of the set of operations that can be performed by the processor is represented to the processor by information called instructions such as an operation code of one or more digits. A sequence of operations to be executed by the processor such as a sequence of operation codes constitute processor instructions also called computer system instructions or simply computer instructions. Processors may be implemented as mechanical electrical magnetic optical chemical or quantum components among others alone or in combination.

Computer system also includes a memory coupled to bus . The memory such as a random access memory RAM or other dynamic storage device stores information including processor instructions for providing multi level distributed computations. Dynamic memory allows information stored therein to be changed by the computer system . RAM allows a unit of information stored at a location called a memory address to be stored and retrieved independently of information at neighboring addresses. The memory is also used by the processor to store temporary values during execution of processor instructions. The computer system also includes a read only memory ROM or other static storage device coupled to the bus for storing static information including instructions that is not changed by the computer system . Some memory is composed of volatile storage that loses the information stored thereon when power is lost. Also coupled to bus is a non volatile persistent storage device such as a magnetic disk optical disk or flash card for storing information including instructions that persists even when the computer system is turned off or otherwise loses power.

Information including instructions for providing multi level distributed computations is provided to the bus for use by the processor from an external input device such as a keyboard containing alphanumeric keys operated by a human user or a sensor. A sensor detects conditions in its vicinity and transforms those detections into physical expression compatible with the measurable phenomenon used to represent information in computer system . Other external devices coupled to bus used primarily for interacting with humans include a display device such as a cathode ray tube CRT or a liquid crystal display LCD or plasma screen or printer for presenting text or images and a pointing device such as a mouse or a trackball or cursor direction keys or motion sensor for controlling a position of a small cursor image presented on the display and issuing commands associated with graphical elements presented on the display . In some embodiments for example in embodiments in which the computer system performs all functions automatically without human input one or more of external input device display device and pointing device is omitted.

In the illustrated embodiment special purpose hardware such as an application specific integrated circuit ASIC is coupled to bus . The special purpose hardware is configured to perform operations not performed by processor quickly enough for special purposes. Examples of application specific ICs include graphics accelerator cards for generating images for display cryptographic boards for encrypting and decrypting messages sent over a network speech recognition and interfaces to special external devices such as robotic arms and medical scanning equipment that repeatedly perform some complex sequence of operations that are more efficiently implemented in hardware.

Computer system also includes one or more instances of a communications interface coupled to bus . Communication interface provides a one way or two way communication coupling to a variety of external devices that operate with their own processors such as printers scanners and external disks. In general the coupling is with a network link that is connected to a local network to which a variety of external devices with their own processors are connected. For example communication interface may be a parallel port or a serial port or a universal serial bus USB port on a personal computer. In some embodiments communications interface is an integrated services digital network ISDN card or a digital subscriber line DSL card or a telephone modem that provides an information communication connection to a corresponding type of telephone line. In some embodiments a communication interface is a cable modem that converts signals on bus into signals for a communication connection over a coaxial cable or into optical signals for a communication connection over a fiber optic cable. As another example communications interface may be a local area network LAN card to provide a data communication connection to a compatible LAN such as Ethernet. Wireless links may also be implemented. For wireless links the communications interface sends or receives or both sends and receives electrical acoustic or electromagnetic signals including infrared and optical signals that carry information streams such as digital data. For example in wireless handheld devices such as mobile telephones like cell phones the communications interface includes a radio band electromagnetic transmitter and receiver called a radio transceiver. In certain embodiments the communications interface enables connection to the communication network for providing multi level distributed computations to the UE .

The term computer readable medium as used herein refers to any medium that participates in providing information to processor including instructions for execution. Such a medium may take many forms including but not limited to computer readable storage medium e.g. non volatile media volatile media and transmission media. Non transitory media such as non volatile media include for example optical or magnetic disks such as storage device . Volatile media include for example dynamic memory . Transmission media include for example coaxial cables copper wire fiber optic cables and carrier waves that travel through space without wires or cables such as acoustic waves and electromagnetic waves including radio optical and infrared waves. Signals include man made transient variations in amplitude frequency phase polarization or other physical properties transmitted through the transmission media. Common forms of computer readable media include for example a floppy disk a flexible disk hard disk magnetic tape any other magnetic medium a CD ROM CDRW DVD any other optical medium punch cards paper tape optical mark sheets any other physical medium with patterns of holes or other optically recognizable indicia a RAM a PROM an EPROM a FLASH EPROM any other memory chip or cartridge a carrier wave or any other medium from which a computer can read. The term computer readable storage medium is used herein to refer to any computer readable medium except transmission media.

Logic encoded in one or more tangible media includes one or both of processor instructions on a computer readable storage media and special purpose hardware such as ASIC .

Network link typically provides information communication using transmission media through one or more networks to other devices that use or process the information. For example network link may provide a connection through local network to a host computer or to equipment operated by an Internet Service Provider ISP . ISP equipment in turn provides data communication services through the public world wide packet switching communication network of networks now commonly referred to as the Internet .

A computer called a server host connected to the Internet hosts a process that provides a service in response to information received over the Internet. For example server host hosts a process that provides information representing video data for presentation at display . It is contemplated that the components of system can be deployed in various configurations within other computer systems e.g. host and server .

At least some embodiments of the invention are related to the use of computer system for implementing some or all of the techniques described herein. According to one embodiment of the invention those techniques are performed by computer system in response to processor executing one or more sequences of one or more processor instructions contained in memory . Such instructions also called computer instructions software and program code may be read into memory from another computer readable medium such as storage device or network link . Execution of the sequences of instructions contained in memory causes processor to perform one or more of the method steps described herein. In alternative embodiments hardware such as ASIC may be used in place of or in combination with software to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware and software unless otherwise explicitly stated herein.

The signals transmitted over network link and other networks through communications interface carry information to and from computer system . Computer system can send and receive information including program code through the networks among others through network link and communications interface . In an example using the Internet a server host transmits program code for a particular application requested by a message sent from computer through Internet ISP equipment local network and communications interface . The received code may be executed by processor as it is received or may be stored in memory or in storage device or other non volatile storage for later execution or both. In this manner computer system may obtain application program code in the form of signals on a carrier wave.

Various forms of computer readable media may be involved in carrying one or more sequence of instructions or data or both to processor for execution. For example instructions and data may initially be carried on a magnetic disk of a remote computer such as host . The remote computer loads the instructions and data into its dynamic memory and sends the instructions and data over a telephone line using a modem. A modem local to the computer system receives the instructions and data on a telephone line and uses an infra red transmitter to convert the instructions and data to a signal on an infra red carrier wave serving as the network link . An infrared detector serving as communications interface receives the instructions and data carried in the infrared signal and places information representing the instructions and data onto bus . Bus carries the information to memory from which processor retrieves and executes the instructions using some of the data sent with the instructions. The instructions and data received in memory may optionally be stored on storage device either before or after execution by the processor .

In one embodiment the chip set or chip includes a communication mechanism such as a bus for passing information among the components of the chip set . A processor has connectivity to the bus to execute instructions and process information stored in for example a memory . The processor may include one or more processing cores with each core configured to perform independently. A multi core processor enables multiprocessing within a single physical package. Examples of a multi core processor include two four eight or greater numbers of processing cores. Alternatively or in addition the processor may include one or more microprocessors configured in tandem via the bus to enable independent execution of instructions pipelining and multithreading. The processor may also be accompanied with one or more specialized components to perform certain processing functions and tasks such as one or more digital signal processors DSP or one or more application specific integrated circuits ASIC . A DSP typically is configured to process real world signals e.g. sound in real time independently of the processor . Similarly an ASIC can be configured to performed specialized functions not easily performed by a more general purpose processor. Other specialized components to aid in performing the inventive functions described herein may include one or more field programmable gate arrays FPGA not shown one or more controllers not shown or one or more other special purpose computer chips.

In one embodiment the chip set or chip includes merely one or more processors and some software and or firmware supporting and or relating to and or for the one or more processors.

The processor and accompanying components have connectivity to the memory via the bus . The memory includes both dynamic memory e.g. RAM magnetic disk writable optical disk etc. and static memory e.g. ROM CD ROM etc. for storing executable instructions that when executed perform the inventive steps described herein to provide multi level distributed computations. The memory also stores the data associated with or generated by the execution of the inventive steps.

Pertinent internal components of the telephone include a Main Control Unit MCU a Digital Signal Processor DSP and a receiver transmitter unit including a microphone gain control unit and a speaker gain control unit. A main display unit provides a display to the user in support of various applications and mobile terminal functions that perform or support the steps of providing multi level distributed computations. The display includes display circuitry configured to display at least a portion of a user interface of the mobile terminal e.g. mobile telephone . Additionally the display and display circuitry are configured to facilitate user control of at least some functions of the mobile terminal. An audio function circuitry includes a microphone and microphone amplifier that amplifies the speech signal output from the microphone . The amplified speech signal output from the microphone is fed to a coder decoder CODEC .

A radio section amplifies power and converts frequency in order to communicate with a base station which is included in a mobile communication system via antenna . The power amplifier PA and the transmitter modulation circuitry are operationally responsive to the MCU with an output from the PA coupled to the duplexer or circulator or antenna switch as known in the art. The PA also couples to a battery interface and power control unit .

In use a user of mobile terminal speaks into the microphone and his or her voice along with any detected background noise is converted into an analog voltage. The analog voltage is then converted into a digital signal through the Analog to Digital Converter ADC . The control unit routes the digital signal into the DSP for processing therein such as speech encoding channel encoding encrypting and interleaving. In one embodiment the processed voice signals are encoded by units not separately shown using a cellular transmission protocol such as global evolution EDGE general packet radio service GPRS global system for mobile communications GSM Internet protocol multimedia subsystem IMS universal mobile telecommunications system UMTS etc. as well as any other suitable wireless medium e.g. microwave access WiMAX Long Term Evolution LTE networks code division multiple access CDMA wideband code division multiple access WCDMA wireless fidelity WiFi satellite and the like.

The encoded signals are then routed to an equalizer for compensation of any frequency dependent impairments that occur during transmission though the air such as phase and amplitude distortion. After equalizing the bit stream the modulator combines the signal with a RF signal generated in the RF interface . The modulator generates a sine wave by way of frequency or phase modulation. In order to prepare the signal for transmission an up converter combines the sine wave output from the modulator with another sine wave generated by a synthesizer to achieve the desired frequency of transmission. The signal is then sent through a PA to increase the signal to an appropriate power level. In practical systems the PA acts as a variable gain amplifier whose gain is controlled by the DSP from information received from a network base station. The signal is then filtered within the duplexer and optionally sent to an antenna coupler to match impedances to provide maximum power transfer. Finally the signal is transmitted via antenna to a local base station. An automatic gain control AGC can be supplied to control the gain of the final stages of the receiver. The signals may be forwarded from there to a remote telephone which may be another cellular telephone other mobile phone or a land line connected to a Public Switched Telephone Network PSTN or other telephony networks.

Voice signals transmitted to the mobile terminal are received via antenna and immediately amplified by a low noise amplifier LNA . A down converter lowers the carrier frequency while the demodulator strips away the RF leaving only a digital bit stream. The signal then goes through the equalizer and is processed by the DSP . A Digital to Analog Converter DAC converts the signal and the resulting output is transmitted to the user through the speaker all under control of a Main Control Unit MCU which can be implemented as a Central Processing Unit CPU not shown .

The MCU receives various signals including input signals from the keyboard . The keyboard and or the MCU in combination with other user input components e.g. the microphone comprise a user interface circuitry for managing user input. The MCU runs a user interface software to facilitate user control of at least some functions of the mobile terminal to provide multi level distributed computations. The MCU also delivers a display command and a switch command to the display and to the speech output switching controller respectively. Further the MCU exchanges information with the DSP and can access an optionally incorporated SIM card and a memory . In addition the MCU executes various control functions required of the terminal. The DSP may depending upon the implementation perform any of a variety of conventional digital processing functions on the voice signals. Additionally DSP determines the background noise level of the local environment from the signals detected by microphone and sets the gain of microphone to a level selected to compensate for the natural tendency of the user of the mobile terminal .

The CODEC includes the ADC and DAC . The memory stores various data including call incoming tone data and is capable of storing other data including music data received via e.g. the global Internet. The software module could reside in RAM memory flash memory registers or any other form of writable storage medium known in the art. The memory device may be but not limited to a single memory CD DVD ROM RAM EEPROM optical storage or any other non volatile storage medium capable of storing digital data.

An optionally incorporated SIM card carries for instance important information such as the cellular phone number the carrier supplying service subscription details and security information. The SIM card serves primarily to identify the mobile terminal on a radio network. The card also contains a memory for storing a personal telephone number registry text messages and user specific mobile terminal settings.

While the invention has been described in connection with a number of embodiments and implementations the invention is not so limited but covers various obvious modifications and equivalent arrangements which fall within the purview of the appended claims. Although features of the invention are expressed in certain combinations among the claims it is contemplated that these features can be arranged in any combination and order.

