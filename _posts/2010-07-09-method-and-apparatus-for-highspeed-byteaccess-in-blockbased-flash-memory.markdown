---

title: Method and apparatus for high-speed byte-access in block-based flash memory
abstract: Techniques utilizing an erase-once, program-many progressive indexing structure manage data in a flash memory device which avoids the need to perform sector erase operations each time data stored in the flash memory device is updated. As a result, a large number of write operations can be performed before a sector erase operation is needed. Consequently, block-based flash memory can be used for high-speed byte access.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08239619&OS=08239619&RS=08239619
owner: Macronix International Co., Ltd.
number: 08239619
owner_city: Hsinchu
owner_country: TW
publication_date: 20100709
---
The present invention relates to flash memory technology and more particularly to techniques for managing data for high speed random access in flash memory devices.

Electrically Erasable Programmable Read Only Memory EEPROM and flash memory include memory cells that store charge between the channel and gate of a field effect transistor. The charge stored affects the threshold voltage of the transistor and the changes in threshold voltage due to the stored charge can be sensed to indicate data stored in the memory cell. Another type of charge data cell is referred to as a charge trapping memory cell which is used a dielectric layer in place of the floating gate.

The term write as used herein describes an operation which changes the threshold voltage of the transistor and is intended to encompass operations for increasing and for decreasing the threshold voltage of the transistor. In EEPROM and in flash write operations involve a first erase step to set all the cells in the memory segment to an erased state followed by a program step to set selected cells in the memory segment to the programmed state. The term program as used herein refers to an operation which can be carried out in flash memory on a bit by bit basis while the term erase as used herein refers to an operation which due to the configuration of the flash memory cells is carried out typically in flash memory on a sector or block basis. Therefore in flash memory to program a single byte the write operation must first erase a larger sector of the memory array and restore the data for the entire sector.

In an EEPROM device the memory cells can be erased on a byte by byte basis independent of the other data bytes. However to enable erasing on a byte by byte basis the memory density of EEPROM is relatively low.

EEPROM and flash memory devices are often used for different applications. Generally because of its higher density flash memory is more economical than EEPROM in mass data storage applications. EEPROM is commonly used in applications where programming and erasing small amounts of data is needed such as for storing status data configuration data that must be changed from time to time and the like.

A variety of electronic devices include both EEPROM and flash memory in order to fulfill different memory performance requirements required of various functions of the device. However using both of these types of memory increases the cost and complexity of the device.

A specific issue arising in flash memory is limited endurance the number of erase and program operations over which the cells in the device remain operative and reliable. Thus repeated and frequent writes to a single sector or a small number of sectors will result in some of the sectors becoming defective in a relatively short time.

Various wear leveling techniques have been proposed for extending the lifetime of flash memory. One wear leveling approach involves the use of counters to track the number of times each sector is erased. The counters are then used to alter the mapping of data into the various sectors to even out their wear. See for example U.S. Pat. Nos. 6 000 006 5 485 595 and 5 341 339.

Although the use of counters can extend the lifetime of flash memory devices the problem of limited endurance continues to preclude the use of flash memory in applications requiring a large number of write operations.

Another wear leveling approach is to write updated data to an unused physical location in the flash memory device rather than overwriting old data in the original location. This reduces the number of sector erase operations for a given number of write operations to the flash memory device. See for example U.S. Pat. Nos. 5 845 313 and 6 115 785.

In order to track the changes in the physical locations of the data a programmable mapping or address translation table can be used. The programming mapping table stores mapping information between the logical addresses specified by an external system and the actual physical addresses of the flash device containing the valid data. In order to accurately track the physical locations of valid data the programmable mapping table is updated during operation.

To ensure that valid data is preserved the mapping information must be preserved when power is no longer being supplied to the flash device. However since the programmable mapping table is continuously being updated storing the mapping information in the flash memory reduces the life of the device due to its limited endurance. This can also significantly impact the performance of a system utilizing flash memory due to the relatively slow erase cycle of the flash memory. The programmable mapping table may alternatively be stored in another non volatile memory circuit on the flash device. However this increases the cost and complexity of the flash device.

It is therefore desirable to provide flash memory devices for applications that often require performance characteristics of EEPROM like high speed byte access while also addressing the issue of endurance with reduced complexity and cost.

A method for operating a flash memory array suitable for high speed byte access is described. The method includes allocating a plurality of sectors of data cells having sector addresses in the flash memory array to store respective data structures where a data structure is arranged to store a byte of data or other N bit wide data set that is identified by a logical address and includes an index field and a data field. The data structure is initialized by erasing the index field and the data field. The logical address of the byte of data is mapped to the sector address of a sector storing a data structure for the data. To write a byte of data having a logical address matching a particular sector address the process programs a data cell in the index field in the data structure within the particular sector where the data cell corresponds with a particular byte wide segment in the data field and programs the corresponding byte wide segment of the data structure to store the byte of data. To read a byte of data in response to a logical address the index field in the data structure is used to identify the particular byte wide segment storing current data. The current data is provided in response to a read operation.

An embodiment of the data structure includes an index field comprising a pointer field having data cells storing M bits for example 28 bits having an address order in the sector and includes a data field that includes M byte wide segments for example 28 byte wide segments in address order. Each of the M bits in address order can correspond with one of the M byte wide segments in the same address order. A last one of the M bits in the pointer field to have been programmed corresponds with a most recently used one of the M byte wide segments in the data field.

An embodiment described herein provides an index field including a pointer field storing M bits in address order and the data field includes M byte wide segments in address order. When each data cell stores a single bit then the pointer field includes M data cells. When a first data cell storing a first bit in the pointer field is programmed and the rest of the data cells in the pointer field remain erased the pointer field points to a first one of the byte wide segments in address order. When the first bit and a second bit in the pointer field are programmed and the rest of the data cells in the pointer field remain erased the pointer field points to a second one of the byte wide segments in address order. When all of the M bits in the pointer field are programmed the pointer points to a last one of the byte wide segments in address order.

An embodiment described herein of the data structure provides an index field that includes a status field for the data structure which after initialization is set so that all of the data cells in the index field are in the erased state. The status field includes at least K 1 bits in address order and indicates a current one of K progressive states assumed during utilization of the data structure. According to an example described herein in an initial state all of the K 1 bits in the status field are erased. In a first progressive state a data cell for a first one of the bits in the status field is programmed and the rest of the data cells in the status field remain erased. In a second progressive state the first one and a second one of the bits in the status field are programmed and the rest of the data cells in the status field remain erased and so on. In a last progressive state all of the data cells for the K 1 bits are programmed.

For use in a data processing system an address translation table can be stored which maps logical addresses for bytes of data to sectors of memory cells in the flash array. A plurality of data structures as described above can be initialized in the respective sectors of memory cells and mapped to the corresponding logical addresses in the address translation table. The status field in the index field is utilized to manage the status of the data structures for use in maintaining the address translation table.

In the case in which all of the byte wide segments in a particular data structure have been utilized the current byte in the data structure can be copied to a new data structure and the address translation table can be updated to map the logical address of the old data structure to the new data structure. A process for managing the copying of the current byte to a new data structure includes updating the status field. For example a status field can include four bits and be used to reflect five states. An initial state indicated by the status field reflects that the data structure is initialized and no logical address is mapped to the data structure. A first state indicated by the status field indicates that the new data structure is selected for logical address mapping and suitable for replacing an old data structure. A second state indicated by the status field indicates that the writing of the current byte of data into the new data structure from the source data structure or other data source is completed. A third state indicated by the status field indicates that an erase process has begun to reinitialize the old data structure. A fourth state indicated by the status field indicates that the erase process in the old data structure has completed and the logical address mapping for the new data structure is valid.

One process for a flash memory array erasable on block boundaries includes allocating first and second blocks each block including a number L sectors in the flash memory array for L logical addresses. In this process initializing the data structure in a particular sector includes erasing the one of the first and second blocks of L sectors including the particular sector. The process for replacing full data structures can include initializing data structures in the second block by erasing the second block and when the M N bit data fields in a data structure in the first block have been subject of write operations i.e. the data structure is full moving the data stored in the data structures in sectors of the first block to data structures in the second block.

Also an apparatus is described including a flash memory array including a plurality of sectors of data cells having sector addresses with logic to store data structures according to the method described above for byte mode read and write operations in flash memory. The apparatus can include a data processor integrated on a single chip with the flash memory array or in a computer system having access to the flash memory array along with instructions executable by the processor for carrying out the method described above. The instructions executable by the processor can be stored in the flash memory array or elsewhere accessible to the data processor.

A machine readable data storage device is described comprising a machine readable data storage medium storing instructions executable by a processor having access to a memory array including a plurality of sectors of data cells having sector addresses where the instructions comprise logic for carrying out the processes described herein.

The technology is described herein with reference to byte wide operations throughout as an aid to clarity. The process may be generalized from writing a byte e.g. 8 bits at a time to writing any N bit wide data set e.g. 16 or 32 bits at a time with corresponding adjustments in the sizes of the data fields in the data structures as will be understood in the art.

Also the terms sector and block are used here to refer to sets of data cells. These terms do not refer necessarily to sets of data cells that correspond strictly with a physical segmentation of the flash memory array although it may be advantageous to consider any such physical segmentation in the allocation of blocks and sectors for the purposes described herein.

Techniques described herein utilize an erase once program many progressive indexing structure managing data in a flash memory device which avoids the need to perform sector erase operations each time a byte of data stored in the flash memory device is updated. A data structure is stored in an addressable sector of the array which includes indexing data status data and the byte of data for the logical address mapped to the sector which can be managed using erase once program many procedures. As a result a large number of write operations can be performed before a sector erase operation is needed for a given sector. Consequently flash memory can be used for high speed byte access.

Other aspects and advantages of the present invention can be seen on review of the drawings the detailed description and the claims which follow.

User interface input devices may include a keyboard pointing devices such as a mouse trackball touchpad or graphics tablet a scanner a touchscreen incorporated into the display audio input devices such as voice recognition systems microphones and other types of input devices. In general use of the term input device is intended to accommodate all possible types of devices and ways to input information into computer system or onto communication network .

User interface output devices may include a display subsystem a printer a fax machine or non visual displays such as audio output devices. The display subsystem may include a cathode ray tube CRT a flat panel device such as a liquid crystal display LCD a projection device or some other mechanism for creating a visual image. The display subsystem may also provide non visual display such as via audio output devices. In general use of the term output device is intended to include all possible types of devices and ways to output information from the computer system to the user or to another machine or computer system.

Memory subsystem can store the basic programming and data constructs that provide the functionality of certain embodiments described herein including the instructions for logical to physical address mapping and translation and instructions used for organization of data within a flash memory device discussed below . These software modules are generally executed by processor . The basic programming and data constructs may be stored in flash memory or other memory devices. Also the memory subsystem may include other storage devices including random access memory RAM for storage of instructions and data during program execution portable memory devices disk drive systems and so on.

The memory subsystem can comprise a machine readable data storage device comprising a machine readable data storage medium storing instructions executable by a processor having access to a memory array including a plurality of sectors of data cells having sector addresses where the instructions comprise logic for carrying out the processes described herein.

In the illustrated embodiment the data processor executing instructions to carry out the various operations described herein is external to the integrated circuit including flash memory. Alternatively the flash memory can be included on the same chip as the data processor or other type of controller to control the management of data and carry out the various operations described herein. For example the controller can be a state machine implemented using special purpose logic circuitry as known in the art. In alternative embodiments the controller comprises a general purpose processor which may be implemented on the same integrated circuit which executes a computer program to control the operations of the flash memory device . In yet other embodiments a combination of special purpose logic circuitry and a general purpose processor may be utilized for implementation of the controller.

Bus subsystem provides a mechanism for letting the various components and subsystems of computer system communicate with each other as intended. Although bus subsystem is shown schematically as a single bus alternative embodiments of the bus subsystem may use multiple buses. In some embodiments the data address and command signals between the flash memory in the memory subsystem and the bus subsystem are applied on shared lines in a serial fashion such as can be implemented using serial peripheral interfaces as known in the art.

As illustrated in a flash memory array can have a plurality of physical blocks including Block through Block K K for storing data organized using the techniques described herein. Each of the blocks Block through Block K K are separately erasable from the other blocks. The block size and number of blocks will vary from embodiment to embodiment. For example in some embodiments the size of each of the blocks can be 2 KB 4 KB 8 KB or 16 KB. Other block sizes may alternatively be used.

As noted above the flash memory array may also include additional blocks for storing the instructions for logical to physical address mapping and translation and the instructions for the organization of the data in the blocks Block through Block K K as described herein.

The instructions include the mapping between the logical addresses specified by the computer system and the physical addresses of sectors of the data cells in the flash memory device .

The blocks Block to Block K K can each include one or more sectors. For example a 4 KB block can include 128 32 byte sectors. Each of the 128 sectors can include one data structure for storing a byte of data. One hundred twenty eight logical addresses can be mapped to the 128 sectors in the block. As described below the sector addresses are mapped to particular logical addresses for bytes of data and are adapted to store a data structure for byte access.

The data structure in a given sector of data cells includes an index field and a data field in examples described here. The index field includes a pointer to a particular byte wide segment in the data field used to store the byte of data for the mapped logical address. In embodiments the index field of one of the sectors can also include a status flag field storing data which indicates status of the sector. In examples described here sector status is maintained on block boundaries and indicates status of sectors in the block such as whether a sector in the given block is currently active working inactive erased dirty or temporary. Thus all data structures in the block have the same status. In alternatives sector status can be maintained on sector boundaries. Also in some embodiments a single status flag may be implemented for each block and not included in the index field of the data structure in each sector.

In a write operation an erased data cell in the index field is programmed to update the pointer to an erased one of the byte wide segments in the data field and particular erased data cells in that erased one of the byte wide segments are programmed to store the byte of data for the mapped logical address.

For purposes of clarity in examples described below the term program is used to refer to an operation which changes the data value in the memory cell to logical 0. Erase refers to an operation which changes the data value in the memory cell to logical 1. The data values corresponding to the programmed and erased states can be 1 and 0 respectively as well. Also in multi level cells the programmed value can assume multiple values. However as described above the term program more generally refers to an operation which can be carried out in flash memory on a cell by cell basis while the term erase more generally refers to an operation which due to the configuration of the flash memory cells is carried out in flash memory on a larger basis on boundaries that are efficiently enforced for a given array structure. Thus depending upon the configuration of the flash memory cells in some embodiments programming and erasing consists of decreasing and increasing the threshold voltages respectively.

The size of the data field is a tradeoff between how often a block or sector erase operation will be performed and the number of logical addresses that can be mapped to a given block in the flash memory device discussed below and thus can vary from embodiment to embodiment.

The flash memory device also can include a plurality of inactive blocks or sectors that serve as transfer units to store updated data for from time to time such as when the data field in a current data structure is full.

The data structure in Sec. includes an index field which includes a pointer to a particular byte wide segment in the data field where the byte of data for the corresponding logical address are stored. The pointer is represented as a sequence of programmed and erased data cells in the index field .

In a write operation for a byte having the logical address mapped to the sector of data cells Sec. an erased data cell in the index field is programmed to update the pointer in the index field to point to an erased one of the byte wide segments in the data area which stores the data field and particular erased data cells in that erased one of the byte wide segments are programmed to store the byte of data for the logical address.

In the illustrated example in response to respective write commands the data cells in the index field are programmed in address order starting with the data cell for the bit in the index field for the first write operation the second bit for the second write operation etc. with data cells following the most recently programmed data cell remaining erased. Similarly the byte wide segments in the data field are written in an order such as address order starting with the first byte wide segment for the first write operation the second byte wide segment for the second write operation etc. with byte wide segments following the more recent byte wide segment remaining erased or empty .

In alternative embodiments in response to respective write commands the sequence of data cells programmed in the index field and the sequence of byte wide segments written to in the data field can be different than that illustrated in . For example the data cells in the index area can be programmed in order starting with the last data cell for the first write operation etc.

By writing updated data to erased byte wide segments in data field in the data field rather than directly overwriting data which would require an erase operation the data cell in the index field used to update the pointer and the data cells used to store the updated byte of data are programmed without an erase process. This results in a program many erase once procedure requiring a small number of sector or block erase operations compared to the number of write operations which effectively increases the endurance of the flash memory array.

Since the updated data is written to empty segments in the data field eventually the data field will become full. Thus from time to time the data structures stored in the sectors Sec. through Sec. M of Block are remapped to corresponding fresh data structures in sectors Sec. through Sec. M in Block either on a sector by sector or block by block basis. The term from time to time as used herein is intended to be construed generally to mean occasionally and is therefore not restricted to uniform cyclic or otherwise equal time intervals.

In addition to using the data stored in the status flag field of the index field to identify the active or inactive status of sectors in the Block the data in the status flag field is also used to ensure that the updated data sector is composed and properly stored in the new block. This is discussed in more detail below with respect to .

In this example each sector of data cells includes a 4 byte index field and a 32 byte data field and is used to store 8 bits 1 byte of data for the corresponding logical address. Thus in this example the data field in a given sector of data cells can support 32 single byte write operations for the corresponding logical address before the data field becomes full.

As illustrated in the data in bits used to form the pointer identifies the particular segment in the data field used to store the 8 bits of data of logical address 0000000 reference numeral . For example for a one bit per cell implementation if the data in bit in the index field is programmed and all the remaining cells for bits are erased the pointer points to segment d which is the first segment in address order in the data field . If the data cells for bits are programmed and all the remaining cells for bits are erased the pointer points to segment d which is the second segment in the data field . Alternative techniques for arranging the data for the pointer to identify the particular segment can also be used. Also in a multiple bit per cell embodiment a data cell can store two or more bits of the pointer.

The use of the pointer obviates the need to update the address translation table each time data in the flash memory device is updated while also enabling accurate tracking of the valid data. Since the address translation table need not be continuously updated it may be stored in the flash memory. During operation the address translation table may be loaded into higher access speed memory such as DRAM or SRAM accessible by the processor of .

In response to a write command to store a byte of data at a logical address at step the block and sector of data cells which corresponds to the particular logical address is determined using the address translation table discussed above.

At step the pointer stored in the index field of the corresponding data structure of data cells is read to determine an erased segment in the data field to store the byte of data.

At step if the data field does not include an erased segment then the data field is full. In such a case the operation continues to block where an updated data structure for the sector storing the data structure is composed. The composing operation is discussed below with reference to .

If an erased segment is found in the data field the operation continues to block . At step an erased data cell in the index field is programmed to update the pointer to that erased segment and the updated data is written to the erased segment. The write operation then ends at step .

As illustrated in in response to a first write operation the pointer is updated by programming the data cell of bit to logic 0 in a second write operation the data cell of bit is programmed to logic 0 and so on until all 28 bits in the pointer field are programmed to logic 0. No erase operation is executed during this programming in order. Even though a given byte in the pointer field is accessed multiple times for programming no erase is needed because a program process performs a byte read or other similar step to prevent a pre erase if no cells in the byte are being changed from the programmed to the erased state.

In alternative embodiments the sequence of data cells programmed in the index field can be different than that illustrated in . For example the data cells in the index field can be programmed in address order starting with the data cell of the last bit of the pointer in response to the first write operation and so on.

In response to a read command to read data for the particular logical address at step the block and sector of data cells which correspond to the particular logical address is determined using the address translation table discussed above.

At step the pointer stored in the index field of the corresponding data structure in a sector of data cells is read to determine the active latest segment in the data field which stores the data for the logical address. The data stored in the active segment is then read and output at step .

As was discussed above from time to time an updated data set for the block is composed and written to a previously inactive block.

For clarity purposes in the discussion below the block that is active before the operation begins is referred to as Block A while the block that is inactive before the operation begins is referred to as Block B. A block used in this process can be a minimum set of cells that can be erased in an erase operation for the flash memory being used. The number of sectors and data structures allocated to each block can be any number from 1 to many as designed to suit a given expected pattern of use.

At step the data stored in the active segments in the data fields of Block A are read to compose an updated data set for a group of logical addresses mapped to Block A. The updated data set contains the valid data for the group of logical addresses mapped to Block A.

At step the updated data set is written to the data fields for the sectors in Block B. At step the addresses translation table is updated to remap the group of logical addresses to Block B. At step Block A is erased. In some embodiments the erase operation of Block A at step is not carried out immediately following the remapping of step but instead is done when resources such as the processor are not needed to carry out other operations.

As described above the data in the status flag field can be used to ensure that the updated data set is composed and properly stored in the previously inactive block.

As shown in at the start of the composing operation the data cells of the bits used to store the status flag field of the active Block A are in a programmed state 0000 and the data cells of the bits used to store the status flag field of the inactive Block B are in an erased state 1111 .

Block B is selected and prior to writing the updated data set to the data fields of Block B at step the data cells of bit in the sectors in Block B are programmed to change the data in the status flag field of Block B from 1111 to 0111. By changing the data of the status flag field of Block B in this manner the data of the status flag field can be used to determine whether an interruption such as power down occurred prior to writing the updated data set to Block B.

Next the data in the data structures of Block A are written to initialized data structures in Block B at step . Next the process determines whether the write is complete at step . Following the writing of the updated data set to the data fields of Block B steps and at step the data cells of bit in the status flags in sectors of Block B are programmed to change the data in the status flag field of Block B from 0111 to 0011. The data in the status flag field can be used to ensure that Block B includes the updated data set for the group of logical addresses. Then it is safe to begin erase of the data structures in Block A and remap the logical addresses. Upon beginning the erase process either immediately or when the processor has available resources the data of the status flag area in the sectors of Block B is updated to 0001 at step . Then the erase operation for Block A is begun at step and the process waits for the erase to complete at step .

Since the status flag field of Block A is within the block the erase operation of Block A steps to also erases the data in the status flag field which changes the data in status flag field of Block A to 1111 inactive . Following the erase operation of Block A at step the data cell of bit in the status flag field is programmed to change the data in the status flag area of the sectors of Block B from 0001 to 0000 active .

In the transition flow diagram the transition of the status flag field from inactive 1111 to active 0000 of Block B involves the programming of erased data cells in the status flag field. This technique eliminates the need to erase data cells in the status flag field each time it needs to be changed. As a result the data for the status flag field can be stored in the Block B rather than stored separately.

In alternative embodiments the bits which are programmed to change the data in the status flag field can be different from those illustrated in .

As noted above in some embodiments the erase operation of Block A at step is not carried out immediately but instead is done when resources such as the processor are not needed to carry out other operations.

The Intelligent Flash Application Programming Interface API is a software module including logic to perform the logical to physical address mapping and translation and logic for the management of the data written to and read from the flash memory to carry out the various operations described herein. The Intelligent Flash API translates the commands from the user code to corresponding physical addresses which are then provided to the low level flash API software module.

The low level flash API is a software driver particularly adapted to function with the flash memory. The low level flash API includes logic to perform the actual reading and writing of data in the flash memory device in response to instructions and physical addresses provided by the Intelligent Flash API .

The flash memory device the low level flash API and the Intelligent Flash API together emulate the programming and erasing of the flash memory device on a byte by byte basis as described herein.

The flash memory and the low level flash API can be implemented using a variety of commercially available off the shelf flash devices such as the MX25L512 CMOS serial flash by Macronix International Corporation Ltd. As a result the Intelligent Flash API provides the ability to emulate the programming and erasing of the flash memory on a byte by byte basis as described herein without necessitating the rewriting of the low level drivers used by such devices.

In the Intelligent Flash API operates the byte write region of the flash memory device to emulate the programming and erasing on a byte by byte basis as described herein. In addition the low level flash API operates the page write region to program and erase data on a block by block basis in the flash memory device .

In such an embodiment the flash memory device can be used both for applications typically served by an EEPROM and applications requiring a flash memory. As a result a single high density flash memory device can be used to replace combinations of EEPROM and flash memory which reduces the system cost and complexity.

The techniques described herein enable the use of block based flash memory in a large number of information processing systems. As an example the techniques described herein emulate programming and erasing of single bytes of data. More generally the techniques described herein can be used to program and erase data of other sizes in block based flash memory where the size of the data to be programmed and erased is less than the size of the block.

Advantages of the techniques described herein include savings on system cost by allowing for the replacement of higher priced lower density EEPROM with block based flash memory. By implementing the techniques described herein the flash memory read write endurance can be increased by greater than 1000 over traditional block access algorithms.

While the present invention is disclosed by reference to the preferred embodiments and examples detailed above it is to be understood that these examples are intended in an illustrative rather than in a limiting sense. It is contemplated that modifications and combinations will readily occur to those skilled in the art which modifications and combinations will be within the spirit of the invention and the scope of the following claims.

