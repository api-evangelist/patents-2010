---

title: API supporting server and key based networking
abstract: An application programming interface (API) supporting server and key based networking is described. In an embodiment, the API receives either a key or a server address from a service running on a server in a direct-connect topology and returns data which identifies suitable next hops for transmission of a packet of data which has a destination of the received server address or of a server address which is encoded within the received key. In another embodiment, the key also encodes information specifying alternative server addresses for use in the event that the original server is unreachable. This information may also be used to define servers for replication of the key. A further embodiment describes a method of queuing packets for transmission against multiple links, where the packet is transmitted on the first available link and at this time is removed from the queues for the other links.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09015345&OS=09015345&RS=09015345
owner: Microsoft Corporation
number: 09015345
owner_city: Redmond
owner_country: US
publication_date: 20101215
---
A portion of the disclosure of this patent contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

Data centers supporting user facing applications such as email applications or other applications like large scale data processing usually run a set of internal services that provide basic functionality on which to build the higher level applications. The computer clusters used to run these services rely on general purpose network technology such as Ethernet switches and Internet protocols whose limitations and compromises in terms of design and implementation limit the performance and functionality of the services that run upon them. Examples of issues include bandwidth oversubscription and where TCP IP is used TCP throughput collapsing as the small buffers are overrun.

The embodiments described below are not limited to implementations which solve any or all of the disadvantages of known methods of communication within a computer cluster.

The following presents a simplified summary of the disclosure in order to provide a basic understanding to the reader. This summary is not an extensive overview of the disclosure and it does not identify key critical elements of the invention or delineate the scope of the invention. Its sole purpose is to present some concepts disclosed herein in a simplified form as a prelude to the more detailed description that is presented later.

An application programming interface API supporting server and key based networking is described. In an embodiment the API receives either a key or a server address from a service running on a server in a direct connect topology and returns data which identifies suitable next hops for transmission of a packet of data which has a destination of the received server address or of a server address which is encoded within the received key. In another embodiment the key also encodes information specifying alternative server addresses for use in the event that the original server is unreachable. This information may also be used to define servers for replication of the key. A further embodiment describes a method of queuing packets for transmission against multiple links where the packet is transmitted on the first available link and at this time is removed from the queues for the other links.

Many of the attendant features will be more readily appreciated as the same becomes better understood by reference to the following detailed description considered in connection with the accompanying drawings.

The detailed description provided below in connection with the appended drawings is intended as a description of the present examples and is not intended to represent the only forms in which the present example may be constructed or utilized. The description sets forth the functions of the example and the sequence of steps for constructing and operating the example. However the same or equivalent functions and sequences may be accomplished by different examples.

In an example implementation some of the servers within the cluster may also be connected to another network e.g. an IP based packet switched network in order to communicate with external clients and such servers may comprise an additional port not shown in for communication with that other network.

In the clusters shown the address of servers is fixed and a server is assigned its address using its location in the physical topology. A server address can be encoded in a variety of ways which may be used interchangeably using a node identifier structure that explicitly gives its coordinate in the 1D 2D 3D space e.g. an x y z coordinate in a 3D example such as example in a server index representing an offset into the ordered set of server addresses in the cluster or it can be encoded within a key which comprises an integer value from which the server address can be recovered and the use of a key is described in more detail below. In the following description references to server address refer to use of either a coordinate or server index and these may be used interchangeably.

Where a coordinate is used the 1D 2D 3D topology of the cluster is used to define a coordinate space and when the cluster is commissioned a bootstrap service assigns each server a coordinate an x y coordinate in the first example and an x y z coordinate in the second example representing its offset within the topology from an arbitrary origin. In the coordinates of a node are shown within the circle . A bootstrap service on each server exposes the coordinate and dimensions of the topology e.g. the 3D torus in example to local services and also provides a mapping between the one hop neighbors and their coordinates. The coordinates of one hop neighbors will each differ in only one axis and by 1 modulo the axis size. The assigned coordinate is the address of the server and once assigned a server s identifier is not changed.

As detailed above for a particular server its address in the form of a server coordinate and its address in the form of a server index are completely interchangeable. A server index may be generated by enumerating all servers from 0 to N 1 by applying a deterministic mapping between the coordinates e.g. x y z coordinates and 0 . . . N 1 . For example if a server has address in the form of a coordinate x y z then it also has server index x MaxX MaxY y MaxY z where MaxX and MaxY are the lengths of those axes.

The API provides a keyspace where while the key appears to a user as a flat address each key has structure such that a function exists which maps a key or a portion of a key e.g. n of m bits where the bits may be fractional bits onto a server address this may be referred to as the home server which is responsible for that key . In an example a key may be considered a 160 bit key but only the least significant 64 bits may be used when routing a message to a key. Of those 64 bits the highest bits of the 64 bit key generate the server address in the form of a server index or server coordinate e.g. an x y z coordinate in the 3D torus example .

In a very simple example a key may be 011 and the first two bits and may define the address of the home server which may also be referred to as the root or primary server . In another example if the keys are 64 bit integers the following constant may be computed KeysPerServer ceil 2 TotalServersInNetwork where ceil x returns the smallest integer which is greater than or equal to x e.g. ceil 2.7 3 . The address of the home server in the form of a server index can then be computed from a key using HomeServer floor key KeysPerServer where floor x returns the largest integer which is less than or equal to x e.g. floor 2.7 2 . This may be considered a scheme which uses a portion of the key n of m bits where m 64 as dividing the key by KeysPerServer is equivalent to selecting just the n most significant bits of the key. Since KeysPerServer is most likely not a power of 2 then n will be a fractional number of bits e.g. for 27 servers then n is approximately 4.75488 bits since 2 4.75488 27. In other examples alternative algorithms may be used to compute a server address from a key.

As described above the API exposes a number of functions to services and the API is configured such that all functions work consistently irrespective of whether they are supplied with a key or a server address. One such function which the API supports is multi hop routing to keys and server addresses and this uses a link state routing protocol and shortest paths algorithm. Each service implements its own queues and services query the API to determine the set of outbound links that can be used to forward a packet towards a key or server arrow . As shown in the schematic diagram of the set of one hop neighbors that can make progress towards the destination is returned in the form of a link vector arrow . The link vector comprises a vector of link indices e.g. 0 5 for the 3D torus example of where bits are set to identify candidate next hops to the specified destination each of which is an equally good next hop to the server key in terms of total path length i.e. the link vector identifies a subset of links e.g. which may be between one and six links in the 3D torus example of offering a shortest path to the specified destination. In this example the API is arranged to support only communication with one hop neighbors. If routing to a server which is not reachable an error is returned not shown in .

Using the link vector services can then select a link or a set of links as described below with reference to and forward packets recursively within the cluster from server to server e.g. on the one of the set of links which is available first until a packet reaches its destination. When a packet is received from the network at the destination the API may identify to the receiving services which link the packet arrived on using the index number of that link. Services take responsibility for packet forwarding at each intermediate hop towards the destination. Services running on servers on the path may be able to intercept and arbitrarily modify or manipulate a packet while it is being routed to a destination server or key. Such packet manipulation may be in order to satisfy requirements of the service e.g. to implement their own routing protocols and transport protocols which may be optimized to provide specific properties that a service requires. Multiple independent routing and transport protocols can therefore be used concurrently within the cluster. Packet manipulation may be used to perform on path data aggregation and to provide increased efficiency.

As part of the multi hop routing functionality which is exposed by the API the API is arranged to return an array of hop counts arrow one hop count for each link index e.g. link indices 0 . . . 5 where each element in the array is the minimum number of hops to get from this server to the destination server via the particular link index. As shown in the API code extract which is provided below by way of example only there are two error conditions one where the destination server is the current server which returns LoopbackRequired and the other where the server is unreachable by any of the next hop neighbors.

The use of a keyspace where the physical and virtual topologies are the same i.e. where one link in an overlay topology defined by the keys represents a single link in the underlying physical topology rather than representing multiple links in the physical network as is usually the case and the fact that the API is configured so that all functions work on both the key and the server address makes it easier to write key based applications e.g. applications in .

As described above the API provides a keyspace where each key has structure. In addition to a function which maps a key or a portion of the key to the server address of the home server which is responsible for that key the key may further comprise a portion which provides fail over information in the event that the home server e.g. as identified by the n of m bits has failed. When a home server is unreachable a portion of the key e.g. the remainder of the m bit e.g. 64 bit key may be used to determine the coordinate of the server which will be the replacement home and will be responsible for the key. Using this technique the key to server mapping is consistent across all servers and the system is able to handle cascading server failures.

Expanding the very simple example used above a key may be 011 and the first two bits and may define the address of the home server e.g. server The third bit then defines the responsible server if server is down e.g. server . This third bit or the remaining m n bits in the earlier terminology also defines how the whole address space is explored in a deterministic way in the event of failure e.g. which server becomes the responsible server if the replacement server is also down or subsequently fails.

In another example a number of probe orders may be defined where each probe order controls how the server coordinate space is explored in the event of failure. The keyspace is therefore further divided into a number of sectors where each sector has its own probe order which is different from all the other probe orders and hence the number of sectors is defined by the number of probe orders. The sectors may be defined such that they do not overlap and in an example the 2bit number space may be visualized as being the face of a clock with 0 at midnight and 2 1 just a fraction anticlockwise of midnight. This number space is divided into TotalServersInNetwork equal sized portions and each of those is further subdivided into NumSectors equal sized sectors.

The five other rotations of this basic list may then be used as five other probe orders where a rotation of a list is defined as being a new list which contains all the elements of the original list but shifted by a certain number of positions e.g. 

In another example 24 probe orders may be defined which distribute the load better when servers fail than the previous example. These probe orders may be defined as 

This gives 24 Probe Orders and therefore 24 sectors because there are 2 ways of picking the xd 2 for yd and 2 for zd 2 2 2 8 possible coordinate deltas plus the 3 rotations of each 8 3 24 distinct probe orders. Each probe order has 3 deltas in it.

A particular sector s probe order defines in which direction to try moving in the event of server failure to find a server which is reachable. For example the first of the 24 probe orders defined above e.g. for sector 0 is 

which means to try looking first in the negative x direction then in the negative y direction and finally in the negative z direction. If none of these work then the method tries again starting from the points just explored which may be referred to as the SeedQueue . Eventually if the probe order is properly constructed all coordinates will have been explored.

The structured key provided by the API may therefore be considered as a set of bits some of which are interpreted as an x y z coordinate for the home server and some of which are used to identify a sector. If in a particular example the keys are 64 bit integers two constants can be computed which are fixed for a particular topology 

where a b gives the integer remainder left over when an integer a is divided by integer b e.g. 12 10 2 . The sector which is computed using the algorithm above then defines the probe order used to identify a responsible server for a key when the home server fails i.e. the data which drives the fail over policy within the cluster is within the key itself.

The API exposes a function to the services which returns the address for the server which is currently responsible for a key arrow in response to an input of the key arrow as shown in the schematic diagram of . This function uses the fail over information in the structured key to identify the appropriate server e.g. as described above . The following API code extract provides an example implementation of this functionality 

As described above the fail over information defines how the whole address space is explored in the event of server failure so the API may expose a function which provides a list of k server addresses arrow which are currently responsible for a particular key provided as an input arrow as in the following example API code extract 

When using a random number as the key applications have no control over the home server or failover behavior of the key. Sometimes applications need more control for example to co locate related keys or to ensure related keys failover to the same backup server or in some particular pattern. To allow for this applications can generate new keys which are related to some existing key but with certain modifications as shown in the schematic diagram of . To generate a new key arrow the original key is passed to the API arrow along with the desired home server address for the key arrow . This is shown in the following example API code extract 

In some examples the sector will also be passed to the API arrow as shown in the following example API code extract 

By combining fail over information into the key as described above if a server fails the keys for which it was home server can be mapped onto different servers e.g. the keys can be distributed over the set of one hop neighbors rather than mapping all the keys for which a failed server was home onto a single other server selected from the one hop neighbors. This method therefore maintains locality and reduces load skew.

The information which is contained within a key that can be used in the event of server failure can also be used for purposes of replication. As described above a portion of the key specifies an ordered list of servers as defined by the probe order and this list can be enumerated to identify as many e.g. k replicas as are required. In some implementations the way in which the coordinate space is explored to identify a list of K server addresses to be used for replication where K 1 may be the same as for fail over and in other implementations a different probe order may be used for fail over and replication. An example code extract for generating a list of K servers for a key is provided above. The following API code extract returns information on the current k replicas for a key 

In order that a service can route packets to a replica the API also exposes a function which enables services to obtain the link vector of next hops towards a specific replica of a key as shown in the following code extract 

Depending upon the way that a probe order is defined a set of K replicas may have a particular property such as proximity to the home server and this may be beneficial because having replicas close to the home server increases throughput and reduces network traffic.

In addition to providing a keyspace and exposing functions for management and use of that keyspace the API exposes multi hop routing functionality to services. The multi hop routing functionality may be provided by another service on the same server or by the server platform itself. is a flow diagram of a multi hop routing method which may be referred to as a lazy multi queue method which enables a service to schedule a packet for transmission over multiple links. According to this method a packet or a descriptor for the packet is queued for transmission in queues for each link in a set of links and only at the point when the packet is transmitted over one of the set of links or committed for transmission over one of the set of links is the packet or associated descriptor removed from the other queues. It is this selection of a link at the last possible moment based on the observed network conditions which gives rise to the term lazy being used for this selection method.

As shown in a service specifies a set of outbound links for a packet and this data identifying this set of links is provided to the API block . In an example the service may provide a link vector to the API which identifies those links on which a packet may be transmitted. The link vector may comprise an arbitrary subset of all links from a particular server and at one extreme may comprise all the links e.g. 4 links in the first example in links in the second example and at the other extreme may comprise only a single link. In response to receiving this data identifying a set of links for transmission of a packet in block the packet or a descriptor for the packet is placed in the queue for each of the links in the set block . When one of the set of links is able to transmit the packet block the packet is committed for transmission over that link and the packets descriptors which were placed in queues for other links in the set in block are removed block . The packet is then transmitted over the link block .

Information may be provided to a service via the API to enable the service to select the set of links to be used for transmission of a packet. In an example a service may use the minimum hop count data which may be provided by the GetMinHopCountsForServer function in the API see code extract above . The API may also be arranged to provide a service with an indication of available capacity in a given link.

The API described herein may also allow a network service to select from its set of transmission queues in response to an indication of available capacity in a given network link a set of packets to be transmitted on that link and an example implementation is shown in the following API extract 

Another example of an API call is shown in the further extract provided below. A service may implement this routine in order to be informed by the API when a queue that was previously saturated is now below its maximum capacity.

The API may also expose link or server failures to applications in via services. In some implementations only local link failures may be exposed and in other implementations all link failures within the cluster may be exposed. The following three extracts from example API code can be used to expose this information 

Computing based device comprises one or more processors which may be microprocessors controllers or any other suitable type of processors for processing computing executable instructions to control the operation of the device in order to implement an API as described herein. In some examples for example where a system on a chip architecture is used the processors may include one or more fixed function blocks also referred to as accelerators which implement a part of the API or methods described herein in hardware rather than software or firmware . Platform software comprising an operating system or any other suitable platform software may be provided at the computing based device to enable the API services and application software to be executed on the device.

The computer executable instructions may be provided using any computer readable media that is accessible by computing based device . Computer readable media may include for example computer storage media such as memory and communications media. Computer storage media such as memory includes volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EPROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other non transmission medium that can be used to store information for access by a computing device. In contrast communication media may embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism. As defined herein computer storage media does not include communication media. Although the computer storage media memory is shown within the computing based device it will be appreciated that the storage may be distributed or located remotely and accessed via a network or other communication link e.g. using communication interface .

The communication interface may comprise a plurality of ports e.g. gigabit Ethernet ports in order to directly connect computing based device to one or more other computing based devices within a cluster of computing based devices. In some examples the communication interface may also comprise one or more ports for connecting the computing based device to other devices which do not form part of the cluster and this connection may be via a different network e.g. an IP packet switched based network .

In many embodiments the computing based device may run without display or keyboard however in some implementations the computing based device may also comprises an input output controller not shown in arranged to output display information e.g. a graphical user interface to a display device which may be separate from or integral to the computing based device . The input output controller may also be arranged to receive and process input from one or more devices such as a user input device e.g. a mouse or a keyboard .

Examples of the API described above allows packets to be queued for transmission against multiple physical network links until such time as one of those links signals that it has capacity available. At this time one or more packets are removed from the queue and committed for transmission on that link. In addition examples of the API include routing functionality supported for example by a link state routing protocol that determines which link or links should be used to send a packet towards a given destination coordinate or key given the prevalent state of the cluster of servers.

The keys described above may define things including the server address and these are all encoded in a single flat address space. In some examples the key may also define one or more of a fail over policy and a replication policy and these policies may be the same or different. Where fail over and or replication information is encoded within a key each server within a cluster can perform the same computations and achieve the same results. Consequently all servers agree on which server is the primary server for a key at a particular time and where replication is used each server knows where the replicas are held.

Although the present examples are described and illustrated herein as being implemented in a system as shown in the system described is provided as an example and not a limitation. As those skilled in the art will appreciate the present examples are suitable for application in a variety of different types of systems with a direct connect topology. The system may support arbitrary workload and applications.

It will be appreciated that the API code extracts provided above are by way of example only and alternative implementations may be used. In a simple example variation of the code shown above unsigned integers may be used instead of integers.

The term computer is used herein to refer to any device with processing capability such that it can execute instructions. Those skilled in the art will realize that such processing capabilities are incorporated into many different devices and therefore the term computer includes PCs servers mobile telephones personal digital assistants and many other devices.

The methods described herein may be performed by software in machine readable form on a tangible storage medium e.g. in the form of a computer program comprising computer program code means adapted to perform all the steps of any of the methods described herein when the program is run on a computer and where the computer program may be embodied on a computer readable medium. Examples of tangible or non transitory storage media include disks thumb drives memory etc and do not include propagated signals. The software can be suitable for execution on a parallel processor or a serial processor such that the method steps may be carried out in any suitable order or simultaneously.

This acknowledges that software can be a valuable separately tradable commodity. It is intended to encompass software which runs on or controls dumb or standard hardware to carry out the desired functions. It is also intended to encompass software which describes or defines the configuration of hardware such as HDL hardware description language software as is used for designing silicon chips or for configuring universal programmable chips to carry out desired functions.

Those skilled in the art will realize that storage devices utilized to store program instructions can be distributed across a network. For example a remote computer may store an example of the process described as software. A local or terminal computer may access the remote computer and download a part or all of the software to run the program. Alternatively the local computer may download pieces of the software as needed or execute some software instructions at the local terminal and some at the remote computer or computer network . Those skilled in the art will also realize that by utilizing conventional techniques known to those skilled in the art that all or a portion of the software instructions may be carried out by a dedicated circuit such as a DSP programmable logic array or the like.

Any range or device value given herein may be extended or altered without losing the effect sought as will be apparent to the skilled person.

It will be understood that the benefits and advantages described above may relate to one embodiment or may relate to several embodiments. The embodiments are not limited to those that solve any or all of the stated problems or those that have any or all of the stated benefits and advantages. It will further be understood that reference to an item refers to one or more of those items.

The steps of the methods described herein may be carried out in any suitable order or simultaneously where appropriate. Additionally individual blocks may be deleted from any of the methods without departing from the spirit and scope of the subject matter described herein. Aspects of any of the examples described above may be combined with aspects of any of the other examples described to form further examples without losing the effect sought.

The term comprising is used herein to mean including the method blocks or elements identified but that such blocks or elements do not comprise an exclusive list and a method or apparatus may contain additional blocks or elements.

It will be understood that the above description of a preferred embodiment is given by way of example only and that various modifications may be made by those skilled in the art. The above specification examples and data provide a complete description of the structure and use of exemplary embodiments of the invention. Although various embodiments of the invention have been described above with a certain degree of particularity or with reference to one or more individual embodiments those skilled in the art could make numerous alterations to the disclosed embodiments without departing from the spirit or scope of this invention.

