---

title: Postscript stream interpreter with integrated pagination
abstract: Systems and methods presented herein provide for the processing of PostScript print jobs that are not DSC compliant. A single stream of a PostScript data is processed and divided into multiple streams (e.g., page objects), each comprising data operable to render an individual page. In one embodiment, a method includes receiving the PostScript data stream and identifying object tokens in the PostScript data stream. An object token is operable to generate a PostScript object or execute a PostScript operation. A portion of the object tokens may be operable to define page boundaries in the PostScript data stream. The method also includes analyzing the object tokens to parse the object tokens into a plurality of page objects, separating the page objects into a plurality of data paths, and parallel processing the page objects through the data paths to rasterize the PostScript data stream on a page by page basis.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08665457&OS=08665457&RS=08665457
owner: Ricoh Company, Ltd.
number: 08665457
owner_city: Tokyo
owner_country: JP
publication_date: 20100310
---
The invention relates to the field of PostScript data stream processing wherein the PostScript data stream is not compliant with PostScript Document Structuring Conventions DSC .

PostScript is a page description language PDL that contains a set of commands that are used to describe pages in a print job. A principal difference between PostScript and other PDLs is that PostScript is a programming language. This provides power and flexibility in expressing page content although the pages are not easy to interpret. In order to correctly interpret pages or perform meaningful transformations on PostScript data a PostScript interpreter is needed. Adobe Configurable PostScript Interpreter CPSI is one example of a PostScript interpreter which processes a PostScript job and produces bitmaps. Adobe Distiller is another example of a PostScript interpreter which processes a PostScript job and produces a PDF file. However certain limitations exist within the PostScript language. For example speed limitations prevent PostScript print jobs to be executed at printer rated speeds. Also PostScript print jobs cannot be separated into independent pages as required for executing pages in parallel on multiple central processing units CPUs .

The processing of a PostScript job generally consists of two typically overlapping stages an interpretation stage and an output stage. During interpretation a PostScript job is parsed and the internal job structure is created. This internal job structure may be a linked list of high level and low level graphical objects a complex state that describes pages in the job etc. During the output stage the internal job structure is processed and the required output is created. In case of a printing system pages are rendered and rasterizes as for example a raw bitmap for printing.

Interpretation is considered as a light stage while rendering is considered as a heavy stage as far as the amount of data produced. For example typical source data for a PostScript page that contains text and graphics is about 100 KB. When rendered at 600 times 600 dpi CMYK a typical raw bitmap page is about 100 MB which is 1 000 times larger than the source data. Thus in order to skip rendering a technique of writing to null device has been used since the inception of the PostScript language.

With the null device technique rendering of pages may be skipped by setting a null device and then re establishing a real device to resume rendering. The null device approach is typically augmented by redefinition of multiple PostScript operators e.g. show image etc. to further reduce the interpretation overhead. The pages may then be rendered in parallel. For example four processors may be configured to receive an entire PostScript job with each processor skipping some pages and processing others. To illustrate a first processor may process pages 1 5 9 . . . while a second processor processes pages 2 6 10 . . . a third processor processes pages 3 7 11 . . . and a fourth processor processes pages 4 8 12 . . . .

The advantages of this approach are easily recognizable. For example assume that it takes a single CPU system seconds to process the entire job. Then further assume that interpreting is four times faster than rendering which is fairly reasonable. Based on these assumptions the interpretation takes 20 seconds while rendering takes 80 seconds. Each of the four processors then spends the same 20 seconds for interpreting each processor needs to interpret the entire job but only 20 seconds for rendering each processor needs to render only a quarter of the pages . In this case the entire job is processed in 40 seconds. This achieves 2.5 times performance gain 100 4 2.5 . However this centralized interpreter approach makes the interpreter the bottleneck in parallel processing because the interpreter processing time is constant. In other words the processing time of the interpreter does not decrease according to the number processors being used to render the print job. Thus removing the processing bottleneck associated with the interpreter would increase the overall speed of PostScript processing.

Realizing the issues related to unstructured nature of PostScript jobs Adobe published Adobe Document Structuring Conventions Specification Version 1 DSC Specifications around 1986. The DSC specification defines a set of tags that allows easy parsing of PostScript resources and rearranging of pages. Now one can successfully split a large set of PostScript jobs into independent pages by parsing for DSC comments and producer specific patterns. DSC also allows for the combination of multiple PostScript jobs produced by different applications into one PostScript job thus achieving an even higher level of page independence.

For example PostScript interpreters receive a single stream input and produce a single sequential rasterized output to be rendered into graphics on a display or printing hardware. The stream contains data for each page in sequence. But PostScript cannot be parsed using a fixed set of rules because the language itself is usually redefined by data streaming into the interpreter unless the document complies with the PostScript Document Structuring Convention DSC . If the PostScript document is DSC compliant then standardized comments may be used as delimiters to split and reassemble a document in a page wise manner. Pages described in a PostScript print job stream may have zero or more dependencies on any data presented by the stream before prior pages are rendered. PostScript interpreters populate dictionaries to track how procedures and parameters are defined. Subsequent pages may call and use these definitions. Every definition which a valid page rendering sequence uses may be located anywhere inside previous pages of the PostScript print job stream. In DSC compliant PostScript all the information needed to render each page is located in the prolog or after the last page was rendered. However several applications produce PostScript that is not DSC compliant and manipulation of individual pages is still desired to improve parallel processing.

The systems and method presented herein provide for the processing of PostScript print jobs that are not DSC compliant. More specifically a single stream of a PostScript data is processed and divided into multiple streams e.g. page objects each comprising data operable to render an individual page. The process employs a synchronous external PostScript interpreter to determine which object token contains a page object operation a.k.a. a showpage operation .

In one embodiment a method provides for rendering a PostScript data stream having PostScript parameters that are not Document Structure Conventions DSC compliant. The method includes receiving the PostScript data stream and identifying object tokens in the PostScript data stream wherein an object token is operable to generate a PostScript object or execute a PostScript operation. A portion of the object tokens may be operable to define page boundaries in the PostScript data stream. The method also includes analyzing the object tokens to parse the object tokens into a plurality of page objects separating the page objects into a plurality of data paths and parallel processing the page objects through the data paths to rasterize the PostScript data stream on a page by page basis.

Analyzing the object tokens to parse the object tokens into a plurality of page objects may include PostScript interpreting the object tokens to generate the page objects. The method may further include separating the page objects into a plurality of data paths dividing a total number of page objects in the PostScript data stream by a total number of the data paths buffering about a same number of page objects in each data path. For example once the page objects have been interpreted by a PostScript interpreter they may be directed along separate data paths for rasterization. In doing so roughly the same number of page objects may be processed along each data path. However other load balancing techniques may be used to account for page objects requiring further processing during rasterization. Additionally separating the page objects into the data paths may include buffering each of the page objects for rendering and generating a null page object for each page object that indicates a nonexistent page in the PostScript data stream after the page object has been buffered for rendering.

The method may further include synchronizing PostScript interpreting with identifying object tokens to correctly associate each object token with a PostScript page. The method may also include buffering each of the object tokens according to their respective page objects. Additionally once buffered the object tokens may be used in processing subsequent pages. For example certain object tokens may be the same within other pages. As such the information associated with the object tokens may be re used within subsequent pages. In this regard buffered object tokens may be used recreate the instructions of a subsequent PostScript data stream to perform the same set of operations and state changes in the PostScript interpreter.

In another embodiment a system is provided for rendering a PostScript data stream having PostScript parameters that are not Document Structure Conventions DSC compliant. The system includes a PostScript token processor operable to receive the PostScript data stream and identify object tokens in the PostScript data stream. An object token is operable to generate a PostScript object or execute a PostScript operation. The system also includes an assembler operable to parse the object tokens into a plurality of page objects and a PostScript interpreter or operable to interpret the page objects for rendering. The assembler is further operable to separate the interpreted page objects into a plurality of data paths for rasterization of the page objects through data paths on a page by page basis.

In another embodiment the printing system provides for interpreting rendering and printing a PostScript data stream. The printing system includes a print controller operable to render the PostScript data stream. The PostScript data stream comprises PostScript parameters that are not Document Structure Conventions DSC compliant. The print controller includes a PostScript token processor operable to receive the PostScript data stream and identify object tokens in the PostScript data stream. An object token is operable to generate a PostScript object or execute a PostScript operation. The print controller also includes an assembler operable to parse the object tokens into a plurality of page objects and a PostScript interpreter operable to interpret the page objects for rendering. The assembler is further operable to separate the interpreted page objects into a plurality of data paths for rasterization of the page objects through data paths on a page by page basis. The printing system also includes a printer operable to print the rendered page objects onto a tangible medium.

The figures and the following description illustrate specific exemplary embodiments of the invention. It will thus be appreciated that those skilled in the art will be able to devise various arrangements that although not explicitly described or shown herein embody the principles of the invention and are included within the scope of the invention. Furthermore any examples described herein are intended to aid in understanding the principles of the invention and are to be construed as being without limitation to such specifically recited examples and conditions. As a result the invention is not limited to the specific embodiments or examples described below but by the claims and their equivalents.

The PostScript token processor is any structure operable to convert the incoming PostScript data stream into object tokens . The object tokens are segments of the post data stream that cause the PostScript interpreter to create an object execute an operation or change a read state of the PostScript interpreter . The objects may include items as simple as numbers names strings or even composites of such objects including arrays and procedures. The objects can also include operators that cause non executable objects on an operand stack to be inserted into a dictionary yet another type of object . In all the objects are used to configure page objects that may be used to generate PostScript pages . . . N . . . N and . . . N. The PostScript token processor is also operable to store at least temporarily the object tokens within the object token buffer for purposes that are defined below.

The PostScript interpreter is any structure operable to interpret or otherwise convert images of a PostScript data stream into sheetside bitmaps. The sheetside bitmaps generated by the PostScript interpreter are each a 2 dimensional array of pixels representing an image of the print job also referred to as full sheetside bitmaps or PostScript pages . . . N . . . N and . . . N. The 2 dimensional pixel arrays are considered full sheetside bitmaps because the bitmaps include the entire set of pixels for the image. The PostScript interpreter is operable to interpret multiple raw sheetsides concurrently so that the rate of rendering substantially matches the rate of imaging of production print engines.

The assembler is any structure operable to initiate duplex communication with the PostScript interpreter send prepended PostScript procedures to the PostScript interpreter and receive feedback therefrom. The assembler may also be operable to specify operating parameters e.g. the prepended PostScript procedures to synchronize the PostScript interpreter and detect page objects i.e. showpages .

The buffers . . . N represent any structures capable of storing PostScript pages . . . N . . . N and . . . N e.g. computer memory as interpreted by the PostScript interpreter . In this regard the buffers may represent data paths for parallel processing via the rasterizers . . . N. The rasterizers . . . N represent any structures operable to convert or render the PostScript pages . . . N . . . N and . . . N into a raster images i.e. consisting of pixels or dots for output to a display a printer or a storage module e.g. computer memory in a bitmap file format.

The PostScript token processor analyzes the object tokens such that they may be parsed into a plurality of page objects in the process element . For example the PostScript token processor may ascertain information pertaining to the object tokens such that page boundaries may be determined and page objects generated. As mentioned the object tokens serve a variety of individual purposes including determining page boundaries. As the PostScript token processor reads the PostScript data stream the PostScript token processor changes state depending on whether it is reading simple text whitespace names strings hexadecimal data procedures or encoded binary data. The PostScript token processor accepts a list of object token patterns that causes it to switch read states so that it may successfully process encoded binary data such as base 85 encoded binary strings. The PostScript token processor buffers all of the object tokens that it segments out of the PostScript data stream into the token buffer . The raw output of the token buffer may be used recreate the instructions of a subsequent PostScript data stream to perform the same set of operations and state changes in the PostScript interpreter . This constitutes a positive acceptance test of the PostScript token processor .

The assembler may use the information from the PostScript token processor to generate page objects. From there the PostScript interpreter interprets the page objects and the assembler separates the interpreted page objects into a plurality of data paths in the process element such that the rasterizers . . . N may parallel process the interpreted page objects on a page by page basis in the process element .

Once each of the page objects has been constructed the PostScript token processor continues analyzing the PostScript data stream to determine whether all of the object tokens have been associated with their respective page objects in the process element . If not the process of analyzing the object tokens returns to the process element to continue processing the object tokens within the PostScript data stream . Otherwise the assembler may begin its process of interpreting the page objects. For example as the page objects are assembled by the assembler the assembler transfers the page objects to the PostScript interpreter for interpretation.

The assembler starts the PostScript interpreter in pipe to stdin mode and initiates a first in first out FIFO feed to send data to the PostScript interpreter s stdin. The object tokens and synchronization requests may be sent through this channel. The stdout channel of the PostScript interpreter is also connected to another FIFO that is read by a read thread of the assembler . Pipe to stdin FIFO stdin and stdout are terms known to those skilled in the art.

Generally page object generation and interpretation are operated as a loop with feedback to the assembler . For example although PostScript interpreters allow input through a console command line more trivial examples of PostScript generally only result in error free interaction. The PostScript processor uses a subset of PostScript that runs through an execute method. Such performs well for testing but is relatively ineffective when the PostScript data stream changes read state between command lines. Thus the PostScript interpreter may be configured to operate in pipe mode. Unlike a command line which issues a prompt pipe mode does not provide means to synchronize the PostScript interpreter with the assembler . Synchronization without any further effort is sustained by keeping the object token feed rate of the assembler slow enough so that there is little or no chance for it to race ahead of the PostScript interpreter . If the PostScript interpreter processes an object token that calls for a signal upon completion then the signal is received with a subsequent object token . If the assembler is ahead of the PostScript interpreter and a showpage hit signal occurs the assembler indicates the object token is incorrect.

Synchronization may be maintained by giving each signal request an identifier that is associated with a specific object token . The assembler tracks synchronization replies from the PostScript interpreter which indicates when the PostScript interpreter operations invoked by the object token are complete. The assembler then adjusts its timing to stay in sync with the PostScript interpreter . Although PostScript is a postfix language it is not entirely disciplined in this regard. Procedures may be written that change the read state. However this effectively places a value construct after an operation in the PostScript data stream and prohibits blocking of the PostScript data stream because the object token initiates the read state change and the PostScript interpreter does not respond until the following data is completely read. Waiting for a reply before sending a subsequent object token may deadlock the duplex communications loop. Accordingly synchronization signals are not used to block the sending of a subsequent object token while waiting for the PostScript interpreter to complete its previous task. Synchronization is used to optimize timing.

Another problem introduced by prefixing operations to values in PostScript is that synchronization requests are not allowed between the read state change operator and its following data. Such a request would be interpreted as part of the PostScript data stream and present an error. The PostScript token processor tracks which operators cause such changes in the read state. In this regard the PostScript token processor informs the assembler whether it is allowed to send a synchronization request after a specific object token .

Other issues that may affect synchronization include the PostScript interpreter itself. For example a variety of PostScript Interpreters may be used as the PostScript interpreter . A Ghostscript interpreter operating in an interactive mode can affect synchronization because the interpreter requires interaction from a user. To overcome such a configurable PostScript interpreter may be used to make multiple application programming interface API calls that allow archive equivalent synchronization.

The PostScript token processor however is not a full fledged interpreter. Instead the PostScript token processor follows a subset of PostScript language specifications. Accordingly the PostScript token processor does not detect read state operators solely by reading and parsing the PostScript data stream . In this regard heuristic rules are provided to the PostScript token processor to enable it to recognize the presence of known resources in the PostScript data stream that provide such operators. When the PostScript token processor detects one of these resources it creates a list of its read state change operators and uses that list to detect subsequent read state change operators.

Procedures are also provided to the assembler to prepend to the incoming PostScript data stream . These procedures provide utilities and can request a unique synchronization signal signal on loop entry track loop depth and signal on a showpage operator. In this regard the assembler receives the synchronization feedback from the PostScript interpreter via a reply thread. If the synchronization is consistently off then the object token feed rate may be reduced. A delay however would tend to slow the overall process. Accordingly a read thread may be used to detect when the PostScript interpreter has replied to a request and interrupt any delay. These interruptions may be tracked and used to optimize synchronization.

Long running loops can also effect synchronization so they are also set to notify the assembler . In turn the assembler allows for a loop to complete so as to not delay the loop e.g. being caused by a loop to linear timing of non looping object tokens . The assembler generally has enough information to know whether a showpage signal actually applies to the last object token sent to the PostScript interpreter . If showpage operations are inconsistent or out of sync the assembler can interrupt the process adjust the timing formula reinitialize the PostScript interpreter and read the token buffer until the point where it may resume reading from the input PostScript data stream . When timing is correct the assembler receives a signal for every showpage operator.

Upon receiving a showpage signal the assembler also calls a method in the PostScript token processor to write out the token buffer to a file. On the first page the PostScript token processor simply outputs the contents of the object token buffer . After outputting the object token buffer the assembler marks the showpage object token as a prior showpage. Subsequent page outs cause the PostScript token processor to replace prior showpage object tokens with an internally predefined erasepage initgraphics object token. For example merely replacing a showpage operator for non printing pages costs the PostScript interpreter CPU cycles in computing paths and rendering operations that are ultimately discarded. This problem is solved by prepending PostScript procedures that replace a valid display device with a null device. The PostScript interpreter then recognizes that every rendering operation in that state remains in place and skips computationally intensive parts of the operation. The rendering operations then pop their respective parameters off the operand stack and do nothing else.

For diagnostic purposes the PostScript token processor can also track its progress from the commencement of the input stream in bytes. The PostScript token processor may also count end of line EOL characters not found inside strings to provide a line based location utility. This data may be attached to the object tokens by the PostScript token processor .

Embodiments of the invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In one embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc. is a block diagram depicting a computer system operable to provide features and aspects hereof by executing programmed instructions and accessing data stored on a computer readable storage medium .

Furthermore embodiments of the invention can take the form of a computer program product accessible from the computer readable storage medium providing program code for use by the computer processing system . For the purposes of this description a computer readable medium can be any apparatus that can contain store communicate or transport the program for use by the processing system. The medium can be an electronic magnetic optical electromagnetic or infrared. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

The computer system being suitable for storing and or executing program code includes at least one processor coupled to memory elements through a system bus . The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code and or data in order to reduce the number of times code and or data must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc can be coupled to the system either directly or through intervening I O controllers. Network adapter interfaces may also be coupled to the system to enable the computer system to become coupled to other data processing systems or storage devices through intervening private or public networks. Modems cable modems IBM Channel attachments SCSI Fibre Channel and Ethernet cards are just a few of the currently available types of network or host interface adapters. The presentation device interface may be coupled to one or more presentation devices such as printing systems and displays for presentation of presentation data generated by the processor .

The printing system may accommodate relatively high speed printing e.g. greater than 100 pages per minute . The print medium may be continuous form paper cut sheet paper and or any other tangible medium suitable for printing. The printing system in one generalized form includes the printer that presents the bitmap onto the print medium e.g. via toner ink etc. based on the PostScript print job .

The print controller may be any system device software circuitry and or other suitable component operable to transform the PostScript print job for generating the bitmap in accordance with printing onto the print medium . In this regard the print controller may include processing and data storage capabilities. For example the print controller in its generalized form includes the PostScript processor . These components may represent hardware used to implement the PostScript data stream processing described above. Alternatively or additionally the separate components may represent logical blocks implemented by executing software instructions in a processor of the printer controller . Accordingly the invention is not intended to be limited to any particular implementation as such may be a matter of design choice.

The print controller may also include other elements that are not shown for the sake of brevity. One example of such an element includes a half toning module that is operable to represent the sheetside bitmaps as halftone patterns of toner. For example the half toning module may convert the pixels to halftone patterns of CMYK toner for application to the paper. Once computed the half toning module transfers the converted sheetside bitmaps to the printer to apply the toner to the print medium . Examples of other modules that a print controller is known to include are a print job storage system a raw data preprocessing system and a bitmap processing system.

Although specific embodiments have been described herein the scope of the invention is not limited to those specific embodiments. Accordingly the scope of the invention is only defined by the following claims and any equivalents thereof.

