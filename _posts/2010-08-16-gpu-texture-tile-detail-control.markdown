---

title: GPU texture tile detail control
abstract: Systems and associated methods for processing textures in a graphical processing unit (GPU) are disclosed. Textures may be managed on a per region (e.g., tile) basis, which allows efficient use of texture memory. Moreover, very large textures may be used. Techniques provide for both texture streaming, as well as sparse textures. A GPU texture unit may be used to intelligently clamp LOD based on a shader specified value. The texture unit may provide feedback to the shader to allow the shader to react conditionally based on whether clamping was used, etc. Per region (e.g., per-tile) independent mipmap stacks may be used to allow very large textures.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08587602&OS=08587602&RS=08587602
owner: Microsoft Corporation
number: 08587602
owner_city: Redmond
owner_country: US
publication_date: 20100816
---
Three dimensional 3D computer graphics systems which can render objects from a 3D world real or imaginary onto a two dimensional 2D display screen are currently used in a wide variety of applications. For example 3D computer graphics can be used for real time interactive applications such as video games virtual reality scientific research etc. as well as off line applications such as the creation of high resolution movies graphic art etc. Typically the graphics system includes a graphics processing units GPU . A GPU may be implemented as a co processor component to a central processing unit CPU of the computer and may be provided in the form of an add in card e.g. video card co processor or as functionality that is integrated directly into the motherboard of the computer or into other devices such as a gaming device.

Typically the GPU has a graphics pipeline which may accept as input some representation of a 3D scene and output a 2D image for display. OpenGL Application Programming Interface API and Direct3D Application Programming Interface are two example APIs that have graphic pipeline models. The graphics pipeline typically includes a number of stages one of which is texture mapping. Texture mapping allows detail surface texture or color to be added to fragments being rendered. In this process a texture map is applied to the surface of a shape. In some systems a texel texture element or texture pixel is the fundamental unit of texture space. When texturing a 3D surface the texture mapping process maps texels to appropriate pixels in the output 2D image.

Processing the texture maps to produce the output 2D image consumes valuable GPU time. Therefore techniques such a mipmapping have been developed. Mipmapping involves storing a texture map and several reduced level of detail LOD versions of the texture map. For example maps with the detail of the original 1 16 the detail etc. may be stored in the texture memory. Mipmaps increase the efficiency of rendering by decreasing the workload on graphics pipeline stages. For example if rendering the scene only requires a version of texture map that has little detail then one of the less detailed maps can be accessed from texture memory rather than taking the time to filter a detailed version.

Typically a limited amount of memory is used to store the texture map s . Therefore in some cases the desired LOD of the texture might not be available in the texture memory. For example the application e.g. video game might attempt to render with more detail than maps available in the texture memory. In this case one option is to render the scene with less detail than desired. Alternatively additional time might be consumed loading the desired LOD for the texture into texture memory. In some cases there might not be any maps of the desired texture stored in texture memory. Therefore the only practical option may be to take the time to load the texture into texture memory. Furthermore since the size of the texture memory is limited working with extremely large texture maps can be difficult.

Systems and associated methods for processing textures in a graphical processing unit GPU are disclosed. Textures may be managed on a per region e.g. tile basis which allows efficient use of texture memory. Moreover very large textures may be used. Techniques provide for both texture streaming as well as sparse textures. A GPU texture unit may be used to intelligently clamp LOD based on a shader specified value. The texture unit may provide feedback to the shader to allow the shader to react conditionally based on whether clamping was used etc. Per region e.g. per tile independent mipmap stacks may be used to allow very large textures.

One embodiment includes a machine implemented method comprising the following. A request for texels for a texture is received. The request includes a level of detail LOD threshold for one or more parts of the texture. A texture memory that stores tiles for the texture at different LODs is accessed. Texels are supplied based on tile LOD availability in the texture memory and the LOD threshold for the one or more parts of the texture. Supplying the texels includes clamping an LOD for a first of the tiles to an LOD that is no more than one level coarser than the requested LOD threshold for the part of the texture that corresponds to the first tile if the requested LOD for the first tile is not available in the texture memory.

One embodiment includes a system having a graphical processing unit GPU having circuitry configured to receive a request for texels for tiles that represent a texture. The request includes a per tile level of detail LOD threshold which specifies a requested LOD for each of the tiles. The circuitry is also configured to access a texture memory that stores the plurality of tiles at different levels of detail LOD and to supply texels for the plurality of tiles based on tile LOD availability in the texture memory and the per tile level of detail LOD threshold for each of the tiles.

One embodiment includes machine implemented method comprising accessing a clamp level of detail LOD for a plurality of tiles in a tile array that represents a texture where the plurality of tiles represent less than the entire texture storing in a texture memory a mipmap stack for each of the plurality of tiles where the mipmap stack for each of the tiles is governed by the clamp LOD for that tile and where less than the entire texture is actively stored in the texture memory and storing in the texture memory a mipmap stack for the entire texture for any LODs with less detail than covered by the mipmap stacks for the plurality of tiles.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Embodiments in accordance with the disclosed technology include systems and methods for processing textures when rendering computer generated images. Textures may be managed on a per region e.g. per tile basis which allows efficient use of texture memory. Moreover very large textures may be used. Techniques provide for both texture streaming e.g. dynamically loading a manageable amount of needed texture data in a given period of time as well as sparse textures e.g. allowing statically determined levels of detail for texture by region . A GPU texture unit may be used to intelligently clamp LOD based on a shader specified value. The texture unit may provide feedback to the shader to allow the shader to react conditionally based on whether clamping was used etc. Per region e.g. per tile independent mipmap stacks may be used to allow very large textures.

Thus the host may control the content that is to be rendered on the display . The storage on the host may store the original texture data. Therefore the host may stream texture data into the texture memory according to regions and LODs determined by the application. In one embodiment the texture memory serves as a tile cache that stores tiles that represent one or more textures to be used when rendering a frame or other element. A tile may be any region of a texture map. Texture memory may be a type of digital storage that makes texture data readily available. The texture memory may be implemented with specialized RAM that is designed for rapid reading and writing enabling the graphics hardware increased performance in rendering 3D imagery however specialized RAM is not a requirement.

To obtain a color when rendering a pixel on the display the host may send a request to the shader . The shader may be responsible for determining color for the pixel and returning the color value to the host . Thus the shader may be referred to as a pixel shader. The shader is not required to perform functions associated with vertex shaders or geometry shaders but is not precluded from such functions. For example the shader could be a unified shader that functions as a pixel shader and a vertex shader and or a geometry shader. The shader may be implemented as a set of software instructions that are executed on one or more processors.

The shader may send texture request to the texture unit . In some embodiments the shader specifies a texture and s t coordinates. In some embodiments the texture itself has s t coordinates. Therefore the request may be for for a color for some part of the texture which may be referred to as a texel. In some embodiments the texture is stored in the texture memory in units referred to as tiles. In some embodiments the shader sends a per tile LOD threshold value LODthresh to the texture unit to specify a requested LOD for each tile. For example LODthresh may be determined based on information about neighboring pixels in a triangle to be rendered. For example if the pixels represent a small region then there should be a high level of detail. On the other hand if the pixels represent a large region then there should be a low level of detail. Typically a highest level of detail may be specified by LOD with lower levels of detail being specified by increasing numbers e.g. LOD LOD etc. . Note that LODthresh is not required to be an integer. In some embodiments the host sends the LODthresh to the shader . In some embodiments the shader modifies LODthresh prior to sending to texture unit .

The tile map may specify what tiles and at what LOD are stored in the texture memory . In one embodiment the tile map may contain one or more tables that can be used to determine what LOD if any is available for each tile. Thus the tile map may reside in a memory unit. In some embodiments the tile map resides in the texture memory however this is not required. The texture unit may access the tile map to determine whether requested tiles are in the texture memory . The tile map responds by indicating whether there is valid data for the requested tiles at that LOD. The texture unit may access the texture memory and generate texels to respond to requests from the shader . The texture unit may send an address e.g. actual memory address to the texture memory and receive color values from the texture memory .

In some embodiments the texture unit clamps the LOD for tiles based on LODthresh and the tiles that are available in the texture memory . For example if the shader requests a LOD between LOD and LOD for a given tile but the most detailed LOD that is available for the tile is LOD then the texture unit may clamp the LOD to LOD and send a warning feedback to the shader to indicate that the LOD was clamped to a slightly lower LOD than requested. The shader might cause a more detailed LOD to be loaded into the texture memory for that tile. In some embodiments the texture unit could send other feedback such as OK or fail depending on the availability in the texture memory of the requested LOD. In some embodiments the texture unit is implemented in hardware to achieve fast processing. However software implementations are not precluded.

In step an LODthresh value is generated. In some embodiments the host generates LODthresh. When the host generates LODthresh it may be a single LODthresh for the entire texture although varying the LODthresh by the host for different parts of the texture is not precluded. For example different s t address ranges may have different values for LODthresh. In some embodiments the shader modifies LODthresh prior to sending to the texture unit . For example the shader may generate a per tile LODthresh. In other words different tiles may have a different value for LODthresh. Note that the shader is not required to specify tiles to provide a per tile LODthresh. Rather the shader may specify s t addresses that the texture unit converts to tile addresses. Therefore the net affect may be that different tiles have different values for LODthresh. Further details of generating the LODthresh are discussed below.

In step a request for texels is received by the texture unit . The request may include LODthresh and one or more s t space addresses. The texture unit may receive LODthresh from the shader or directly from the host . Note that LODthresh that is provided to the texture unit may actually specify an s t space address or some other address as opposed to a specific tile.

In step the texture unit supplies texels for the tiles based on the LOD availability in the texture memory and LODthresh for the tiles. In some embodiments the texture unit sends feedback to the shader based on its ability to supply the requested LOD for each tile. In one embodiment the texture unit clamps the LOD for a given tile under certain conditions. For example if the available LOD for a given tile is slightly below the requested LOD the texture unit may clamp to the available LOD. Further details of step are discussed below. For example describes one embodiment.

In some embodiments the content of the texture memory may be dynamically updated. In step a determination is made whether the texture memory should be updated. For example in response to receiving warning feedback the shader could suggest that the host load additional texels to increase the LOD that is stored in texture memory for a certain tile. If it is determined that the texture memory should be dynamically updated then one or more mipmap stacks for one or more tiles are changed in step . Process then continues with the host or shader sending additional requests for color values for texels. These requests may include the same or a different LODthresh. Therefore one option is to generate a new LODthresh in step although LODthresh may stay the same for the next request.

One embodiment includes per region e.g. per tile independent mipmap stacks. Each mipmap stack may correspond to one element of a tile array. shows an example used to illustrate one embodiment that may be used to implement independent mipmap stacks. The diagram is divided into levels that correspond to different levels of detail LOD and is used to illustrate a texture loaded into the texture memory . Virtual tile array represents the entire texture which may be divided into different regions referred to as tiles. As one example the texture may be a 20 20 array of tiles. Typically only portions of the entire virtual tile array are loaded into texture memory at one point in time which is why it is referred to as a virtual tile array. In this example a 6 6 resident tile array at LOD is loaded into texture memory . One tile in the resident tile array at LOD is highlighted for purpose of discussion. The 6 6 resident tile array is mipmapped down to LOD in a single mipmap stack in this example. Thus full detail and reduced detail versions of the 6 6 resident tile array are stored in texture memory . This is depicted in by the 6 6 resident tile array at LOD through LOD .

The coarsest LODs from LOD through LOD for the entire 20 20 virtual tile array are stored in the texture memory in this example. This is represented by mip tail array stack . Note that the using this technique allows very large textures to be stored in the texture memory as the amount of memory that is required for the mip tail array stack is not very much. Likewise since at LOD only a subset of tiles from the entire texture are stored e.g. resident tile array the amount of texture memory used is not excessive. However regardless what point in the texture is attempted to be accessed it is guaranteed in this embodiment that some value can be returned albeit at a coarser LOD in some cases.

For purposes of discussion the entire 20 20 virtual tile array might be a 5120 5120 byte texture. Thus a given tile might be 256 256 bytes. At LOD virtual tile array may only be 160 bytes 160 bytes. Therefore the top level of the mip tail array stack may require less storage than a resident tile e.g. the at LOD . Note that the level at which the mip tail array stack starts is for purposes of discussion. The mip tail array stack may start at a higher or lower level than LOD .

Note that it is not required that all tiles in the resident tile array be stored all the way up to LOD . In one embodiment each tile in the tile array may have its own clamp LOD. A clamp value refers to the most detailed LOD for a tile. depicts an example in which different tiles have different clamps. For example referring to tile is clamped at LOD . Therefore tile has a version stored in texture memory for LOD through LOD . On the other hand tile is clamped at LOD . Therefore there is a version of tile stored in texture memory for LOD through LOD but not at LOD . Having different clamp LODs for different tiles allows texture detail to be controlled statically. In some embodiments the clamp LOD for each tile may be adjusted dynamically. Therefore the texture detail may also be controlled dynamically.

Note that the resident tile array is not required to be a contiguous region in the texture. For example tile and tile may both be considered to be part of the resident tile array as some LOD version of these tiles are resident in the texture memory . However these tiles are not a part of the some contiguous region of the virtual array . Note that so as not to obscure the diagram other resident tiles of the resident tile array are not depicted in .

Moreover note that resident tile array could represent more than a single texture. Therefore although only a single virtual tile array is depicted in note that there could be more than one virtual tile array . In such a case the texture memory may store a mip tail array stack for each virtual tile array . For example show mip tail array stack starting at LOD for the virtual tile array . The texture memory could store more than one mip tail array stack each corresponding to a different texture or virtual tile array .

In step mipmap stacks for each tile in the subset are stored in the texture memory . In step a mipmap stack for the entire texture is stored in the texture memory . For example mipmap stacks such as those depicted in or B are stored in the texture memory . A shown in for example there is a mipmap stack for each of the resident tiles in 6 6 tile region and a mip tail array stack for the entire texture.

In step of process the texture unit accesses the tile map to determine what LOD is available in the tile memory for the requested tile. For example the texture unit converts an s t address that was received from the shader to an index in the virtual array and then to an index in the resident tile array . Referring to the example of the 20 20 virtual tile array the texture unit might first identify which virtual tile corresponds to the s t address. Next the texture unit may determine an index in the resident tile array that corresponds to the virtual tile array index. In some embodiments the texture unit determines a physical address in the texture memory based on the resident tile array index.

In step the texture unit compares the most detailed LOD available LODmax in the texture memory for the requested tile to LODthresh. If LODmax is greater more detailed than LODthresh step is yes then the texture unit accesses the texture memory in step . Then the texture unit generates and supplies texels for the tile in step . One way to generate the texel value for a given point is to determine the four nearest texels in the tile at LOD to the requested s t and form a first bilinear filtered value. A similar process can be performed for the tile at LOD to form a second filtered value. These two values may then be combined based on using LODthresh to produce an interpolated value between LOD and LOD . Other techniques can be used to form the final color value. The texture unit sends a feedback to the shader of OK in step .

Referring to for Tile Tile and Tile LOD through LOD are stored in the texture memory . Note that depicts an s axis below the tiles to indicate the relationship between the s coordinate of s t space and the tiles. The t coordinate is not explicitly depicted in . In this example the LOD threshold LODthresh between LOD and LOD . Thus the texture unit is able to provide values using the texture maps at LOD and LOD . This is represented in by the dashed line just below LODthresh labeled as LOD used. In actuality the LOD used may be at essentially the same level as LODthresh but is shown slightly below for purposes of illustration. Techniques that are known in the art for blending values from different texture maps may be used by the texture unit . Because the texture unit is able to provide values for all tiles that fully satisfy the requested LODthresh the texture unit sends feedback of OK to the shader for Tile Tile and Tile .

Returning again to the discussion of if the LODmax for the tile is not more detailed than the requested LODthresh step is no then the texture unit determines whether LODmax is within one level of LODthresh in step . If it is then the texture unit clamps the LOD for the tile to the integer level just below i.e. coarser than LODthresh in step . In other words the texture unit supplies texels that are slightly less detailed than requested. In step the texture unit send a feedback of warning to the shader to indicate that the texture memory does not currently have the LOD requested for the tile but that the LOD is close.

Referring to for Tile and Tile LOD through LOD are stored in the texture memory but LOD is not. Thus the texture unit is not able to provide values that would correspond to a LOD between LOD and LOD . However the texture unit is able to supply texels using the texture maps at LOD which is within one level of the requested LODthresh. This is represented in by the dashed line just below LOD for Tile and Tile . In actuality the LOD used may be at essentially the same LOD but is shown slightly below for purposes of illustration. Because the texture unit is able to provide values within one level of the requested LODthresh the texture unit sends feedback of warning to the shader for Tile and Tile . Therefore the shader may take steps to cause a greater LOD to be loaded into the texture memory for these tiles. Note that being within one level of LODthresh is used as one example and that a being within some other number possibly fractional value of levels of LODthresh could be used.

Returning again to the discussion of if the LODmax for the tile is not within one level of the requested LODthresh step is no then the texture unit sends feedback of Fail in step . Referring to for Tile LOD through LOD are stored in the texture memory but neither LOD nor LOD was requested. Thus the texture unit is not able to provide values within one level of the requested LODthresh based on the addresses provided. This is represented in by having no dashed line for Tile . also has the label Fail at LOD for Tile to indicate that LOD is not detailed enough to use for texel generation in this example.

Note that it is not required that the same LODthresh be used for all tiles. In one embodiment the shader sends a different LODthresh for different tiles. As noted above the shader may send LODthresh for s t addresses which the texture unit converts to tiles. The shader might send a single e.g. constant LODthresh for each tile or alternatively the shader might send multiple values e.g. a smooth value for each tile. The diagram in will be used to illustrate embodiments in which the shader sends a smoothed value. Those diagrams illustrate embodiments of step of of generating an LODthresh. In one embodiment the shader adjust the LODthresh based on the LOD that is actually available in the texture memory for each tile.

As depicted in the LOD threshold is a smooth curve that has different values for different tiles. Moreover for a single tile the LOD threshold may smoothly change. For example for Tile the LOD threshold is just below LOD for most of the tile however the LOD threshold smoothly drops down to LOD at the rightmost portion of Tile . As can be seen for Tile LOD is the greatest level of detail. Thus the smooth LOD threshold curve provides a smooth transition between LOD used for most of tile and LOD used for tile . As can be seen the LOD threshold smoothly transitions to LOD between Tile and Tile . Then the LOD threshold smoothly transitions from LOD to LOD between Tile and Tile where it remains.

In the embodiment depicted in the texture unit is not required to send back feedback such as OK and warning. The shader may select suitable values for the LOD threshold based on knowledge of the most detailed LOD that is stored in texture memory for each tile. Thus the texture unit may be able to always supply values that match the LOD threshold. In other words the actual retuned values for the texels may have a LOD that exactly matches the LOD threshold.

One embodiment uses a replacement addressing when loading new data in the texture memory . depicts one embodiment of replacement addressing. In particular the resident tile array depicted in has been shifted in . In this embodiment tiles that are no longer needed may be removed from texture memory and replaced by other tiles. That is the memory area formerly used can be re used by the new tiles. In this example at LOD the six leftmost tiles in the 6 6 resident tile array are removed from texture memory and replaced by tiles on the right side of the resident tile array . Tile is depicted as one of the six newly added tiles. Similar replacements may be made at lower LODs for the 6 6 resident tile array . Thus at LOD through LOD the resident tile array is depicted as shifted in as compared to . Because the entire 20 20 tile array may be stored at LOD through LOD there is no shift for those LODs.

Note that the tiles that are replaced as well as the tiles that are added could be entire mipmap stacks or particular LODs. For example referring to the entire mipmap stack for from LOD to LOD could be removed. As another example only LOD and LOD might be removed for tiles with LOD through LOD remaining. As still another example a tile for could be added at LOD .

Note that the resident tile array is depicted as a contiguous region of the virtual tile array as a matter of convenience. The actual new tiles that are added into the resident tile array may be any tiles of the virtual tile array . Moreover the tiles in the resident tile array are not required to all be part of the same texture. Therefore the new tiles in the resident tile array could correspond to a different texture than the removed tiles. Also the new tiles in the resident tile array could correspond to a different texture than the other remaining tiles in the resident tile array .

In some embodiments the texture unit maintains pointers between a virtual tile array and the resident tile array to track what portions of virtual tile array are stored in the resident tile array and where they are stored. In one embodiment addressing includes updating pointers for the virtual tiles that are removed and added to the resident tile array .

Some embodiments may include circuitry configured to instantiate specific aspects of the present disclosure. For example the term circuitry used in the disclosure can include specialized hardware components configured to perform function s by firmware or switches. In other embodiments the term circuitry can include a general purpose processing unit memory etc. configured by software instructions that embody logic operable to perform function s . In embodiments where circuitry includes a combination of hardware and software an implementer may write source code embodying logic and the source code can be compiled into machine readable code that can be processed by the general purpose processing unit. The selection of hardware versus software to effectuate specific functions may be a design choice left to an implementer. More specifically one of skill in the art can appreciate that a software process can be transformed into an equivalent hardware structure and a hardware structure can itself be transformed into an equivalent software process. Thus the selection of a hardware implementation versus a software implementation is one of design choice and left to the implementer. Herein the term machine implemented method includes a method that is performed by software hardware or a combination of software and hardware. For example some of the machine implemented method may be performed by executing instructions on a processor whereas some of the machine implemented method may be performed without executing instructions on a processor.

A graphics processing unit GPU and a video encoder video codec coder decoder form a video processing pipeline for high speed and high resolution graphics processing. Data is carried from the graphics processing unit to the video encoder video codec via a bus. The video processing pipeline outputs data to an AN audio video port for transmission to a television or other display. A memory controller is connected to the GPU to facilitate processor access to various types of memory such as RAM Random Access Memory . The GPU may be used to implement the shader and texture unit . Memory may serve as texture memory . Thus memory may store the texture mipmaps. Memory may also store the tile map .

The multimedia console includes an I O controller a system management controller an audio processing unit a network interface a first USB host controller a second USB controller and a front panel I O subassembly that may be implemented on a module . The USB controllers and serve as hosts for peripheral controllers a wireless adapter and an external memory device e.g. flash memory external CD DVD ROM drive removable media etc. . The network interface NW IF and or wireless adapter provide access to a network e.g. the Internet home network etc. and may be any of a wide variety of various wired or wireless adapter components including an Ethernet card a modem a Bluetooth module a cable modem and the like.

System memory is provided to store application data that is loaded during the boot process. A media drive is provided and may comprise a DVD CD drive hard drive or other removable media drive. The media drive may be internal or external to the multimedia console . Application data may be accessed via the media drive for execution playback etc. by the multimedia console . The media drive is connected to the I O controller via a bus such as a Serial ATA bus or other high speed connection.

The system management controller provides a variety of service functions related to assuring availability of the multimedia console . The audio processing unit and an audio codec form a corresponding audio processing pipeline with high fidelity and stereo processing. Audio data is carried between the audio processing unit and the audio codec via a communication link. The audio processing pipeline outputs data to the AN port for reproduction by an external audio player or device having audio capabilities.

The front panel I O subassembly supports the functionality of the power button and the eject button as well as any LEDs light emitting diodes or other indicators exposed on the outer surface of the multimedia console . A system power supply module provides power to the components of the multimedia console . A fan cools the circuitry within the multimedia console .

The CPU GPU memory controller and various other components within the multimedia console are interconnected via one or more buses including serial and parallel buses a memory bus a peripheral bus and a processor or local bus using any of a variety of bus architectures.

When the multimedia console is powered on application data may be loaded from the system memory into memory and or caches and executed on the CPU . The application may present a graphical user interface that provides a consistent user experience when navigating to different media types available on the multimedia console . In operation applications and or other media contained within the media drive may be launched or played from the media drive to provide additional functionalities to the multimedia console .

The multimedia console may be operated as a standalone system by connecting the system to a television or other display . In this standalone mode the multimedia console allows one or more users to interact with the system watch movies or listen to music. However with the integration of broadband connectivity made available through the network interface or the wireless adapter the multimedia console may further be operated as a participant in a larger network community.

When the multimedia console is powered on a specified amount of hardware resources are reserved for system use by the multimedia console operating system. These resources may include a reservation of memory e.g. 16 MB CPU and GPU cycles e.g. 5 networking bandwidth e.g. 8 kbs etc. Because these resources are reserved at system boot time the reserved resources do not exist from the application s view.

In particular the memory reservation may be large enough to contain the launch kernel concurrent system applications and drivers. The CPU reservation is may be constant such that if the reserved CPU usage is not used by the system applications an idle thread will consume any unused cycles.

With regard to the GPU reservation lightweight messages generated by the system applications e.g. popups are displayed by using a GPU interrupt to schedule code to render popup into an overlay. The amount of memory for an overlay may depend on the overlay area size and the overlay may scale with screen resolution. Where a full user interface is used by the concurrent system application it is preferable to use a resolution independent of application resolution. A scaler may be used to set this resolution such that the need to change frequency and cause a TV resynch is eliminated.

After the multimedia console boots and system resources are reserved concurrent system applications execute to provide system functionalities. The system functionalities are encapsulated in a set of system applications that execute within the reserved system resources described above. The operating system kernel identifies threads that are system application threads versus gaming application threads. The system applications may be scheduled to run on the CPU at predetermined times and intervals in order to provide a consistent system resource view to the application. The scheduling is to minimize cache disruption for the gaming application running on the console.

When a concurrent system application requires audio audio processing is scheduled asynchronously to the gaming application due to time sensitivity. A multimedia console application manager described below controls the gaming application audio level e.g. mute attenuate when system applications are active.

Input devices e.g. controllers and are shared by gaming applications and system applications. The input devices are not reserved resources but are to be switched between system applications and the gaming application such that each will have a focus of the device. The application manager may control the switching of input stream without knowledge the gaming application s knowledge and a driver maintains state information regarding focus switches.

With reference to an exemplary system for implementing the various components of the described system and method may include a general purpose computing device in the form of a computer . Computing device may be used to implement all or a portion of system for example. The computing device is only one example of a suitable computing system and is not intended to suggest any limitation as to the scope of use or functionality of the presently disclosed subject matter. Neither should the computing device be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating system.

In its most basic configuration the computer typically includes a processing unit and memory . In this example processing unit may serve as both a CPU to run a host application as well as a GPU to render images. The texture maps and tile maps may be stored in memory . Pending on the exact configuration and type of computing device memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. Additionally computer may also have mass storage removable and or non removable such as magnetic or optical disks or tape.

Similarly computer may also have input devices and or output devices such as a display . Other aspects of device may include communication connections to other devices computers networks servers etc. using either wired or wireless media.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims. It is intended that the scope of the invention be defined by the claims appended hereto.

