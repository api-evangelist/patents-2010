---

title: Pixel shader output map
abstract: One embodiment of the present invention sets forth a technique for storing only the enabled components for each enabled vector and writing only enabled components to one or more specified render targets. A shader program header (SPH) file provides per-component mask bits for each render target. Each enabled mask bit indicates that the pixel shader generates the corresponding component as an output to the raster operations unit. In the hardware, the per-component mask bits are combined with the applications programming interface (API)-level per-component write masks to determine the components that are updated by the shader program. The combined mask is used as the write enable bits for components in one or more render targets. One advantage of the combined mask is that the components that are not updated are not forwarded from the pixel shader to the ROP, thereby saving bandwidth between those processing units.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08922555&OS=08922555&RS=08922555
owner: NVIDIA Corporation
number: 08922555
owner_city: Santa Clara
owner_country: US
publication_date: 20101006
---
This application claims priority benefit to U.S. provisional patent application titled Pixel Shader Output Map filed on Oct. 7 2009 and having Ser. No. 61 249 516.

Embodiments of the invention relate generally to graphics processing and more specifically to selecting and transmitting components for output by a pixel shader.

Prior art pixel shaders in three dimensional 3D graphics application programming interfaces APIs store and output component vectors of multiple components to a raster operations unit for blending operations and storage in a frame buffer. Vectors may be enabled or disabled for output to each render target frame buffer and one or more of the components in each vector may be individually disabled. Conventional pixel shaders store and output all of the multiple components for each enabled vector potentially wasting storage resources and bandwidth when one or more of the components are disabled for a vector. Additionally disabled components that are output should not be written to a render target since the data for the component is undetermined.

To avoid this overhead implementations of 3D graphics APIs may recompile pixel shaders based on the vector and component enabled described above. However such an approach involves a substantial amount of central processing unit CPU overhead. Substantial computation is required to track the various combinations of pixel shader and graphics API state and to perform such recompilations whenever necessary.

Accordingly what is needed in the art is a technique for storing only the enabled components for each enabled vector without shader recompilation and ensuring that the render target is written with enabled components so that non enabled component data stored in the render target remains unchanged.

A system and method of storing only the enabled components for each enabled vector and writing only enabled components to one or more specified render targets. A shader program header SPH file provides per component mask bits for each render target. Each enabled mask bit indicates that the pixel shader generates the corresponding component as an output to the raster operations unit. In the hardware the per component mask bits are combined with the applications programming interface API level per component write masks to determine the components that are updated by the shader program. The combined mask is used as the write enable bits for components in one or more render targets. One advantage of the combined mask is that the components that are not updated are not forwarded from the pixel shader to the raster operations unit ROP thereby saving bandwidth between those processing units.

Various embodiments of a method of the invention for selecting and transmitting components for render targets includes generating only components of a vector that are enabled according to a shader program header and storing the components of the vector in a set of registers. A set of components is selected from the components of the vector based on a component update mask. The set of components is transmitted to a render target and written to the render target.

Various embodiments of the invention include a system for selecting and transmitting components for render targets includes a memory storing the render targets and a pixel shader. The pixel shader is configured to generate only components of a vector that are enabled according to a shader program header and store the components of the vector in a set of registers. The pixel shader also selects a set of components from the components of the vector based on a component update mask and transmits the set of components to a render target. A raster operations unit is configured to write the set of components to the render target.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances well known features have not been described in order to avoid obscuring the present invention.

In one embodiment the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry and constitutes a graphics processing unit GPU . In another embodiment the parallel processing subsystem incorporates circuitry optimized for general purpose processing while preserving the underlying computational architecture described in greater detail herein. In yet another embodiment the parallel processing subsystem may be integrated with one or more other system elements such as the memory bridge CPU and I O bridge to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of parallel processing subsystems may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip. Large embodiments may include two or more CPUs and two or more parallel processing systems . The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

Referring again to in some embodiments some or all of PPUs in parallel processing subsystem are graphics processors with rendering pipelines that can be configured to perform various tasks related to generating pixel data from graphics data supplied by CPU and or system memory via memory bridge and bus interacting with local parallel processing memory which can be used as graphics memory including e.g. a conventional frame buffer to store and update pixel data delivering pixel data to display device and the like. In some embodiments parallel processing subsystem may include one or more PPUs that operate as graphics processors and one or more other PPUs that are used for general purpose computations. The PPUs may be identical or different and each PPU may have its own dedicated parallel processing memory device s or no dedicated parallel processing memory device s . One or more PPUs may output data to display device or each PPU may output data to one or more display devices .

In operation CPU is the master processor of computer system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPUs . In some embodiments CPU writes a stream of commands for each PPU to a pushbuffer not explicitly shown in either or that may be located in system memory parallel processing memory or another storage location accessible to both CPU and PPU . PPU reads the command stream from the pushbuffer and then executes commands asynchronously relative to the operation of CPU .

Referring back now to each PPU includes an I O input output unit that communicates with the rest of computer system via communication path which connects to memory bridge or in one alternative embodiment directly to CPU . The connection of PPU to the rest of computer system may also be varied. In some embodiments parallel processing subsystem is implemented as an add in card that can be inserted into an expansion slot of computer system . In other embodiments a PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . In still other embodiments some or all elements of PPU may be integrated on a single chip with CPU .

In one embodiment communication path is a PCI EXPRESS link in which dedicated lanes are allocated to each PPU as is known in the art. Other communication paths may also be used. An I O unit generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path directing the incoming packets to appropriate components of PPU . For example commands related to processing tasks may be directed to a host interface while commands related to memory operations e.g. reading from or writing to parallel processing memory may be directed to a memory crossbar unit . Host interface reads each pushbuffer and outputs the work specified by the pushbuffer to a front end .

Each PPU advantageously implements a highly parallel processing architecture. As shown in detail PPU includes a processing cluster array that includes a number C of general processing clusters GPCs where C 1. Each GPC is capable of executing a large number e.g. hundreds or thousands of threads concurrently where each thread is an instance of a program. In various applications different GPCs may be allocated for processing different types of programs or for performing different types of computations. For example in a graphics application a first set of GPCs may be allocated to perform tessellation operations and to produce primitive topologies for patches and a second set of GPCs may be allocated to perform tessellation shading to evaluate patch parameters for the primitive topologies and to determine vertex positions and other per vertex attributes. The allocation of GPCs may vary dependent on the workload arising for each type of program or computation.

GPCs receive processing tasks to be executed via a work distribution unit which receives commands defining processing tasks from front end unit . Processing tasks include indices of data to be processed e.g. surface patch data primitive data vertex data and or pixel data as well as state parameters and commands defining how the data is to be processed e.g. what program is to be executed . Work distribution unit may be configured to fetch the indices corresponding to the tasks or work distribution unit may receive the indices from front end . Front end ensures that GPCs are configured to a valid state before the processing specified by the pushbuffers is initiated.

When PPU is used for graphics processing for example the processing workload for each patch is divided into approximately equal sized tasks to enable distribution of the tessellation processing to multiple GPCs . A work distribution unit may be configured to produce tasks at a frequency capable of providing tasks to multiple GPCs for processing. By contrast in conventional systems processing is typically performed by a single processing engine while the other processing engines remain idle waiting for the single processing engine to complete its tasks before beginning their processing tasks. In some embodiments of the present invention portions of GPCs are configured to perform different types of processing. For example a first portion may be configured to perform vertex shading and topology generation a second portion may be configured to perform tessellation and geometry shading and a third portion may be configured to perform pixel shading in screen space to produce a rendered image. Intermediate data produced by GPCs may be stored in buffers to allow the intermediate data to be transmitted between GPCs for further processing.

Memory interface includes a number D of partition units that are each directly coupled to a portion of parallel processing memory where D 1. As shown the number of partition units generally equals the number of DRAM . In other embodiments the number of partition units may not equal the number of memory devices. Persons skilled in the art will appreciate that DRAM may be replaced with other suitable storage devices and can be of generally conventional design. A detailed description is therefore omitted. Render targets such as frame buffers or texture maps may be stored across DRAMs allowing partition units to write portions of each render target in parallel to efficiently use the available bandwidth of parallel processing memory .

Any one of GPCs may process data to be written to any of the DRAMs within parallel processing memory . Crossbar unit is configured to route the output of each GPC to the input of any partition unit or to another GPC for further processing. GPCs communicate with memory interface through crossbar unit to read from or write to various external memory devices. In one embodiment crossbar unit has a connection to memory interface to communicate with I O unit as well as a connection to local parallel processing memory thereby enabling the processing cores within the different GPCs to communicate with system memory or other memory that is not local to PPU . In the embodiment shown in crossbar unit is directly connected with I O unit . Crossbar unit may use virtual channels to separate traffic streams between the GPCs and partition units .

Again GPCs can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. tessellation shader vertex shader geometry shader and or pixel shader programs and so on. PPUs may transfer data from system memory and or local parallel processing memories into internal on chip memory process the data and write result data back to system memory and or local parallel processing memories where such data can be accessed by other system components including CPU or another parallel processing subsystem .

A PPU may be provided with any amount of local parallel processing memory including no local memory and may use local memory and system memory in any combination. For instance a PPU can be a graphics processor in a unified memory architecture UMA embodiment. In such embodiments little or no dedicated graphics parallel processing memory would be provided and PPU would use system memory exclusively or almost exclusively. In UMA embodiments a PPU may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high speed link e.g. PCI EXPRESS connecting the PPU to system memory via a bridge chip or other communication means.

As noted above any number of PPUs can be included in a parallel processing subsystem . For instance multiple PPUs can be provided on a single add in card or multiple add in cards can be connected to communication path or one or more of PPUs can be integrated into a bridge chip. PPUs in a multi PPU system may be identical to or different from one another. For instance different PPUs might have different numbers of processing cores different amounts of local parallel processing memory and so on. Where multiple PPUs are present those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including desktop laptop or handheld personal computers servers workstations game consoles embedded systems and the like.

Operation of GPC is advantageously controlled via a pipeline manager that distributes processing tasks to streaming multiprocessors SPMs . Pipeline manager may also be configured to control a work distribution crossbar by specifying destinations for processed data output by SPMs .

In one embodiment each GPC includes a number M of SPMs where M 1 each SPM configured to process one or more thread groups. Also each SPM advantageously includes an identical set of functional execution units e.g. arithmetic logic units and load store units shown as Exec units and LSUs in that may be pipelined allowing a new instruction to be issued before a previous instruction has finished as is known in the art. Any combination of functional execution units may be provided. In one embodiment the functional units support a variety of operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation trigonometric exponential and logarithmic functions etc. and the same functional unit hardware can be leveraged to perform different operations.

The series of instructions transmitted to a particular GPC constitutes a thread as previously defined herein and the collection of a certain number of concurrently executing threads across the parallel processing engines not shown within an SPM is referred to herein as a warp or thread group. As used herein a thread group refers to a group of threads concurrently executing the same program on different input data with one thread of the group being assigned to a different processing engine within an SPM . A thread group may include fewer threads than the number of processing engines within the SPM in which case some processing engines will be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of processing engines within the SPM in which case processing will take place over consecutive clock cycles. Since each SPM can support up to G thread groups concurrently it follows that up to G M thread groups can be executing in GPC at any given time.

Additionally a plurality of related thread groups may be active in different phases of execution at the same time within an SPM . This collection of thread groups is referred to herein as a cooperative thread array CTA or thread array. The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group and is typically an integer multiple of the number of parallel processing engines within the SPM and m is the number of thread groups simultaneously active within the SPM . The size of a CTA is generally determined by the programmer and the amount of hardware resources such as memory or registers available to the CTA.

Each SPM contains an L1 cache not shown or uses space in a corresponding L1 cache outside of the SPM that is used to perform load and store operations. Each SPM also has access to L2 caches within the partition units that are shared among all GPCs and may be used to transfer data between threads. Finally SPMs also have access to off chip global memory which can include e.g. parallel processing memory and or system memory . It is to be understood that any memory external to PPU may be used as global memory. Additionally an L1.5 cache may be included within the GPC configured to receive and hold data fetched from memory via memory interface requested by SPM including instructions uniform data and constant data and provide the requested data to SPM . Embodiments having multiple SPMs in GPC beneficially share common instructions and data cached in L1.5 cache .

Each GPC may include a memory management unit MMU that is configured to map virtual addresses into physical addresses. In other embodiments MMU s may reside within the memory interface . The MMU includes a set of page table entries PTEs used to map a virtual address to a physical address of a tile and optionally a cache line index. The MMU may include address translation lookaside buffers TLB or caches which may reside within multiprocessor SPM or the L1 cache or GPC . The physical address is processed to distribute surface data access locality to allow efficient request interleaving among partition units. The cache line index may be used to determine whether of not a request for a cache line is a hit or miss.

In graphics and computing applications a GPC may be configured such that each SPM is coupled to a texture unit for performing texture mapping operations e.g. determining texture sample positions reading texture data and filtering the texture data. Texture data is read from an internal texture L1 cache not shown or in some embodiments from the L1 cache within SPM and is fetched from an L2 cache parallel processing memory or system memory as needed. Each SPM outputs processed tasks to work distribution crossbar in order to provide the processed task to another GPC for further processing or to store the processed task in an L2 cache parallel processing memory or system memory via crossbar unit . A preROP pre raster operations is configured to receive data from SPM direct data to ROP units within partition units and perform optimizations for color blending organize pixel color data and perform address translations.

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Any number of processing units e.g. SPMs or texture units preROPs may be included within a GPC . Further while only one GPC is shown a PPU may include any number of GPCs that are advantageously functionally similar to one another so that execution behavior does not depend on which GPC receives a particular processing task. Further each GPC advantageously operates independently of other GPCs using separate and distinct processing units L1 caches and so on.

In graphics applications ROP is a processing unit that performs raster operations such as stencil z test blending and the like and outputs pixel data as processed graphics data for storage in graphics memory. In some embodiments of the present invention ROP is included within each GPC instead of partition unit and pixel read and write requests are transmitted over crossbar unit instead of pixel fragment data.

The processed graphics data may be displayed on display device or routed for further processing by CPU or by one of the processing entities within parallel processing subsystem . Each partition unit includes a ROP in order to distribute processing of the raster operations. In some embodiments ROP may be configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.

Persons skilled in the art will understand that the architecture described in A and B in no way limits the scope of the present invention and that the techniques taught herein may be implemented on any properly configured processing unit including without limitation one or more CPUs one or more multi core CPUs one or more PPUs one or more GPCs one or more graphics or special purpose processing units or the like without departing the scope of the present invention.

In embodiments of the present invention it is desirable to use PPU or other processor s of a computing system to execute general purpose computations using thread arrays. Each thread in the thread array is assigned a unique thread identifier thread ID that is accessible to the thread during its execution. The thread ID which can be defined as a one dimensional or multi dimensional numerical value controls various aspects of the thread s processing behavior. For instance a thread ID may be used to determine which portion of the input data set a thread is to process and or to determine which portion of an output data set a thread is to produce or write.

A sequence of per thread instructions may include at least one instruction that defines a cooperative behavior between the representative thread and one or more other threads of the thread array. For example the sequence of per thread instructions might include an instruction to suspend execution of operations for the representative thread at a particular point in the sequence until such time as one or more of the other threads reach that particular point an instruction for the representative thread to store data in a shared memory to which one or more of the other threads have access an instruction for the representative thread to atomically read and update data stored in a shared memory to which one or more of the other threads have access based on their thread IDs or the like. The CTA program can also include an instruction to compute an address in the shared memory from which data is to be read with the address being a function of thread ID. By defining suitable functions and providing synchronization techniques data can be written to a given location in shared memory by one thread of a CTA and read from that location by a different thread of the same CTA in a predictable manner. Consequently any desired pattern of data sharing among threads can be supported and any thread in a CTA can share data with any other thread in the same CTA. The extent if any of data sharing among threads of a CTA is determined by the CTA program thus it is to be understood that in a particular application that uses CTAs the threads of a CTA might or might not actually share data with each other depending on the CTA program and the terms CTA and thread array are used synonymously herein.

SPM provides on chip internal data storage with different levels of accessibility. Special registers not shown are readable but not writeable by LSU and are used to store parameters defining each CTA thread s position. In one embodiment special registers include one register per CTA thread or per exec unit within SPM that stores a thread ID each thread ID register is accessible only by a respective one of the exec unit . Special registers may also include additional registers readable by all CTA threads or by all LSUs that store a CTA identifier the CTA dimensions the dimensions of a grid to which the CTA belongs and an identifier of a grid to which the CTA belongs. Special registers are written during initialization in response to commands received via front end from device driver and do not change during CTA execution.

A parameter memory not shown stores runtime parameters constants that can be read but not written by any CTA thread or any LSU . In one embodiment device driver provides parameters to the parameter memory before directing SPM to begin execution of a CTA that uses these parameters. Any CTA thread within any CTA or any exec unit within SPM can access global memory through a memory interface . Portions of global memory may be stored in the L1 cache .

Local register file is used by each CTA thread as scratch space each register is allocated for the exclusive use of one thread and data in any of local register file is accessible only to the CTA thread to which it is allocated. Local register file can be implemented as a register file that is physically or logically divided into P lanes each having some number of entries where each entry might store e.g. a 32 bit word . One lane is assigned to each of the N exec units and P load store units LSU and corresponding entries in different lanes can be populated with data for different threads executing the same program to facilitate SIMD execution. Different portions of the lanes can be allocated to different ones of the G concurrent thread groups so that a given entry in the local register file is accessible only to a particular thread. In one embodiment certain entries within the local register file are reserved for storing thread identifiers implementing one of the special registers.

Shared memory is accessible to all CTA threads within a single CTA any location in shared memory is accessible to any CTA thread within the same CTA or to any processing engine within SPM . Shared memory can be implemented as a shared register file or shared on chip cache memory with an interconnect that allows any processing engine to read from or write to any location in the shared memory. In other embodiments shared state space might map onto a per CTA region of off chip memory and be cached in L1 cache . The parameter memory can be implemented as a designated section within the same shared register file or shared cache memory that implements shared memory or as a separate shared register file or on chip cache memory to which the LSUs have read only access. In one embodiment the area that implements the parameter memory is also used to store the CTA ID and grid ID as well as CTA and grid dimensions implementing portions of the special registers. Each LSU in SPM is coupled to a unified address mapping unit that converts an address provided for load and store instructions that are specified in a unified memory space into an address in each distinct memory space. Consequently an instruction may be used to access any of the local shared or global memory spaces by specifying an address in the unified memory space.

The L1 Cache in each SPM can be used to cache private per thread local data and also per application global data. In some embodiments the per CTA shared data may be cached in the L1 cache . The LSUs are coupled to a uniform L1 cache the shared memory and the L1 cache via a memory and cache interconnect . The uniform L1 cache is configured to receive read only data and constants from memory via the L1.5 Cache .

Data assembler processing unit collects vertex data for high order surfaces primitives and the like and outputs the vertex data including the vertex attributes to vertex processing unit . Vertex processing unit is a programmable execution unit that is configured to execute vertex shader programs lighting and transforming vertex data as specified by the vertex shader programs. For example vertex processing unit may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. Vertex processing unit may read data that is stored in L1 cache parallel processing memory or system memory by data assembler for use in processing the vertex data.

Primitive assembler receives vertex attributes from vertex processing unit reading stored vertex attributes as needed and constructs graphics primitives for processing by geometry processing unit . Graphics primitives include triangles line segments points and the like. Geometry processing unit is a programmable execution unit that is configured to execute geometry shader programs transforming graphics primitives received from primitive assembler as specified by the geometry shader programs. For example geometry processing unit may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives.

In some embodiments geometry processing unit may also add or delete elements in the geometry stream. Geometry processing unit outputs the parameters and vertices specifying new graphics primitives to a viewport scale cull and clip unit . Geometry processing unit may read data that is stored in parallel processing memory or system memory for use in processing the geometry data. Viewport scale cull and clip unit performs clipping culling and viewport scaling and outputs processed graphics primitives to a rasterizer .

Rasterizer scan converts the new graphics primitives and outputs fragments and coverage data to fragment processing unit . Additionally rasterizer may be configured to perform z culling and other z based optimizations.

Fragment processing unit is a programmable execution unit that is configured to execute fragment shader programs transforming fragments received from rasterizer as specified by the fragment shader programs. For example fragment processing unit may be programmed to perform operations such as perspective correction texture mapping shading blending and the like to produce shaded fragments that are output to raster operations unit . Fragment processing unit may read data that is stored in parallel processing memory or system memory for use in processing the fragment data. Fragments may be shaded at pixel sample or other granularity depending on the programmed sampling rate.

Raster operations unit is a processing unit that performs raster operations such as stencil z test blending and the like and outputs pixel data as processed graphics data for storage in graphics memory. The processed graphics data may be stored in graphics memory e.g. parallel processing memory and or system memory for display on display device or for further processing by CPU or parallel processing subsystem . In some embodiments of the present invention raster operations unit is configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.

Although the method steps are described in conjunction with the systems of A B and C persons skilled in the art will understand that any system configured to perform the method steps in any order is within the scope of the inventions.

In order to support the various features and capabilities specified by different graphics APIs e.g. OpenGL Microsoft s DX10 and the like the processing units within the graphics processing pipeline are configurable to support these features and capabilities. More specifically a shader program may specify that one or more components of one or more output vectors are emitted by a fragment processing unit to a raster operations unit ROP . An application program may use several different fragment shader programs in its lifetime though only one at a time. The application program interfaces provide a method to specify one or more render targets that should be rendered to. Each of these render targets is generally stored in framebuffer memory and has one or more components of data per pixel. Additionally the application program interfaces provide a method to specify a per component write mask allowing writes to specified components of a render target to be disabled. Finally some application program interfaces provide a configurable mapping between output vectors emitted by the shader program and the render targets allowing each render target to receive data from any one of the output vectors. The processing units within the graphics processing pipeline determine the combination of components to generate and write to the different render targets based on the features and capabilities specified by the application program.

In one embodiment of this invention the device driver uses one SetPipeline PIXEL .Program command to bind the pixel shader program and to set the pixel shader program s compile time parameters that are needed by the processing units within the graphics processing pipeline . The SetPipeline PIXEL .Program command sets a pointer to a pixel shader program and the pixel shader program s SPH shader program header . When a shader program is compiled the compiler or related software not only generates the executable code but also computes additional parameters needed by the fragment processing unit and raster operations unit ROP within the graphics processing pipeline . These parameters are placed usually by the device driver into the SPH. Some SPH fields are used by the fragment processing unit to determine which components to send to the ROP unit and write to one or more render targets.

At the high level embodiments of the invention allow the compiler to indicate on a per component basis the output components that are generated by the fragment processing unit when the pixel shader is executed. The components enabled by the SPH may not match the components to be written according to a render target write enable mask since the write enable mask is defined at the application program level not at the pixel shader program level. Differences between the SPH mask and the target write enable mask are reconciled in the fragment processing unit and ROP so that the device driver does not need to override the per component write enables to ensure that components that are not enabled by the SPH are not written to a render target. The device driver advantageously only needs to bind render targets to the binding slots as specified by the application program.

Further complicating the generation and writing of the components the OpenGL API provides the command glDrawBuffers permitting applications to shuffle or remap the render target order so that a vector of components generated by the fragment processing unit may be dynamically remapped to an arbitrary render target. In the preferred embodiment of this invention software and hardware performance of the graphics processing pipeline is improved when a SetCtSelect command is used to remap the vectors to different render targets thereby allowing any vector to be sent to any render target. Without such a mechanism the device driver would be required incur overhead cross checking the render targets draw buffer remapping and the pixel shader program whenever any of these changes. The ROP is configured to perform the remapping of the vectors from one render target to another when the render target order is shuffled by the SetCtSelect command.

The ROP may also be configured to write a single vector of components to multiple render targets. A SetCtMrtEnable command allows the device driver to dynamically disable the multiple render target MRT behavior of the active pixel shader that writes a different vector to each render target. Disabling the MRT behavior is used to preserve OpenGL glDrawBuffer semantics with MRT enabled pixel shaders where a single output vector is written to all enabled render targets regardless of the number of outputs in the pixel shader.

The ROP may also be configured to perform dual source blending DSB for multiple render targets where a pair of outputs are sent to each render target for blending with the current contents of the render target as explained in conjunction with .

A component update mask is produced as a combination of the targetWE and the SPH by performing a bitwise AND operation between the two masks. The component update mask indicates that the R and A components are enabled for the first vector the R and B components are enabled for the second vector and no components are enabled for the third vector. The component update mask may be used by the fragment processing unit to only generate components that will be written to a render target. Since writing a render target component that is not generated should be avoided in order to comply with an API requirement the ROP is configured to write only components enabled by the targetWE . Components enabled for writes that are not generated by the fragment processing unit are written with a default value. A single targetWE may be specified by the application program and reconciled with different SPHs by the fragment processing unit and ROP without any intervention by the device driver .

When one or more components are not enabled according to the component update mask the enabled components output by fragment processing unit are preferably packed at the component granularity for output to the ROP thereby conserving bandwidth. Packed components includes the R and A components for the first vector R and A and the R and B components for the second vector R and B . No components are output for the third vector. The registers needed to store the components may be used more efficiently since only components generated according to the SPH are stored compared with storing all of the components for each vector allowing more shader programs to execute concurrently when the number of registers is limited.

A component update mask is produced as a combination of the independently specified targetWE the SPH and the format mask by performing a bitwise AND operation between the three masks. The component update mask indicates that the R component is enabled for the first vector the R and B components are enabled for the second vector and no components are enabled for the third vector. The component update mask may be used by the fragment processing unit to only transmit components from the pixel shader to the ROP that will be written to a render target. Since a component that is not generated should not be written to a render target in order to comply with an API requirement the ROP is configured to write only components enabled by the targetWE and that are enabled by the format mask . Components that are not generated by the fragment processing unit are written with a default value. A different targetWE and format mask may be specified by the application program for each one of the render targets and reconciled with different SPHs by the fragment processing unit and ROP without any intervention by the device driver .

When one or more components are not enabled according to the component update mask the enabled components output by fragment processing unit are packed at the component granularity for output to the ROP thereby conserving bandwidth. Packed components includes only the R component for the first vector R and the R and B components for the second vector R and B . No components are output for the third vector. The registers needed to store the components may be used more efficiently since only components generated according to the SPH are stored compared with storing all of the components for each vector allowing more shader programs to execute concurrently when the number of registers is limited.

A special case arises in some embodiments when blending is enabled and blending is performed in the ROP unit . Blending provides a set of well known configurable modes where the final values stored by the ROP are a function of the fragment shader outputs the current contents of framebuffer memory and various other pieces of state. Some blending configurations will allow the A component output by the fragment shader to affect the final results on the R G and B components. In such cases the A component generated by the fragment shader must be sent to ROP even if the corresponding A component bit in TargetWE is zero or the corresponding A component bit in FormatMask is zero. In the context of if blending is enabled for the first two render targets and the blend modes are programmed such that the alpha output affects R G B channels then the Component Update Mask is set to 1001 1011 0000. In some APIs blending can be enabled on targets individually. In some APIs some target formats are not blendable so continuing with the example if the first render target is blendable and the second target is not blendable then the Component Update Mask is set to 1001 1010 000. This special case involving also applies to and to subsequent examples.

A selection logic combines two or more component masks e.g. SPH specified by a pixel shader program the targetWE specified by the application program the format mask the blending state and the format blendability to produce the component update mask. The component update mask is used to select one or more components stored in the pixel shader registers for output to the ROP . The selected components are then packed at a component granularity and output to the ROP . The components may be output by the selection logic serially or in parallel. The ROP includes a component unpack unit a vector remap unit and a render target write unit . The component unpack unit unpacks the packed components based on the component masks used to produce the component update mask.

Format blendability is determined based on the blending enables and the component format. Some formats are not considered to be blendable and therefore have a false blendability. Blending is defined in graphics APIs as a floating point operation. As a result an API typically specifies that blending state is ignored and treated as disabled when addressing an integer framebuffer format. Only floating point framebuffer formats are considered blendable.

The unpacked components are output to the vector remap unit and remapped or shuffled according to a SetCtSelect specified by the application program. The SetCtSelect determines the one to one mapping between the vectors and the render targets. Without support for the remapping of the vectors that is required by the OpenGL API the OpenGL driver would need to shuffle the render target bindings potentially on every state change involving the pixel shader render targets or render target selection which is a significant overhead. Thus software and hardware performance is improved by providing the remapping function in the ROP . When the SetCtSelect specifies a mapping that reorders the render targets relative to the vectors i.e. vector is not output to render target vector is not output to render target and so on the SetCtSelect is used by the selection logic to combine the remapped targetWE and or format mask with the corresponding SPH for the vector.

The optionally remapped vectors are received by the render target write unit and output to one or more render targets based on a render target setup . The render target write unit can be configured to perform blending or a separate blending unit can perform blending. The render target setup may be specified by the SetCtMrtEnable method that allows the device driver to dynamically enable and disable the MRT behavior. In particular a single vector may be output to all of the enabled render targets to preserve OpenGL glDrawBuffer semantics. Finally the optionally remapped vectors are output and written to one or more render targets via the L2 cache see .

At step the packed components are unpacked by the component unpack unit according to the transmit order and component update mask to produce output vectors. In one embodiment when the SPH specifies that a component is not output but the component is enabled for writes the corresponding component is filled with a default value in the output vector. At step the output vectors are remapped by the vector remap unit according to the SetCtSelect to produce remapped output vectors for each enabled render target. At step the remapped output vectors are output and written to the render target s according to the render target setup by the render target write unit . In one embodiment the render target write unit only writes components that are enabled according to the targetWE. In other embodiments the render target write unit only writes components that are enabled according to the format mask. In still other embodiments the render target write unit only writes components that are enabled according to the format mask ANDed with the targetWE.

The pixel shader PS output vectors include 8 different vectors. The components that are included for each vector are shown in SPH and the PS registers specifies the pixel shader registers that are allocated for storing the components. The SetCtSelect shuffle specifies the remapping of pixel shader vectors to render targets. The targetWE is the write enable mask for each render target. In this example the format mask is not used to produce the component update mask. The register to RGBA indicates the PS register that is output for each component of the render target where a default value of d is used when the component is not generated by the pixel shader.

The first PS output vector is directed to target see 0 6 in SetCtSelect shuffle . The RGB components are generated and written using PS registers and . The targetWE for target is 1110 so RGB is written to target. The second PS output vector is directed to target and the RG components are generated and written using PS registers and . The targetWE for target is 1111 so R and G values from registers and plus B and A default values are written to target. The third PS output vector is directed to target but has no components generated or written to PS registers. The targetWE for target is irrelevant X don t care because of the empty output vector so nothing is output to target. The fourth PS vector is directed to target and only the A component is generated and written using PS register . The targetWE for target is 1011 so A from register and default values for R and B are written to target.

The fifth PS vector is directed to target and no components are generated or written to PS registers. The targetWE for target is irrelevant and nothing is output to target. The sixth PS vector is directed to target and the G component is generated and written using PS register . The targetWE for target is 0001. Because the combined mask is empty the G component in PS register is discarded and the default value for A is written to target. The seventh PS vector is directed to target and the G and A components are generated and written using PS registers and . In this example there is no color buffer bound to target and the empty format mask will ensure that nothing is output to target. The eighth PS vector is directed to target and the R G and A components are generated and written using PS registers and . The targetWE for target is 1000 so only the R component stored in register is output to target.

The pixel shader PS vectors includes 8 different vectors but in non MRT mode only the first vector vector is used. The components that are included for the first vector are shown in SPH and the PS registers specifies the pixel shader registers that are allocated for storing the components. The SetCtSelect shuffle specifies the remapping of the first pixel shader vector to one or more render targets. The format mask is the per component format enable mask for each render target. The targetWE is the write enable mask for each render target. The register to RGBA indicates the PS register that is output for each component of the render target where a default value of d is used when the component is not generated by the pixel shader.

The first PS vector is directed to all of the targets regardless of SetCtSelect shuffle . The RGB components are generated for vector and written using PS registers and . The format mask for target is 1111 and the targetWE for target is 1011 so R and B stored in registers and are written to the R and B components of target and the default value is written to the enabled A component of target. No buffer is attached to targets and so the corresponding format masks are disabled 0000 . The targetWE for targets and is irrelevant because no components will be written to those targets due to the format mask . The format mask for target is 1110 and the targetWE for target is 0001 so no components of target will be written. Note that only components enabled by both the targetWE and the format mask are written in this example.

The format mask for target is 0001 and the targetWE for target is 1111 so only the default value is written to the A component of target. The format mask for target is 1110 and the targetWE for target is 1000 so only the R component stored in register is written to the R component of target. The format mask for target is 1111 and the targetWE for target is 1110 so the R G and B components stored in registers and are written to the R G and B components of target.

A dual source blending mode may also be enabled that operates with the non MRT mode. The dual source mode is enabled when at least one dual source blended target is specified. The pixel shader vectors and specify two input sources that are blended with the current contents of each enabled target. The targetCount field of the SetCtSelect method sets the number of targets that potentially receive a copy of vectors and . Fields for each target 8 targets in the example indicate which targets potentially receive copies of PS vectors and . Each target that is not a dual source blending target receives only PS vector effectively operating in non MRT mode.

In one embodiment the source components are output by the pixel shader for each target. In other embodiments the source components for multiple render targets are packed and output by the pixel shader .

The pixel shader PS vectors could write up to 8 different vectors but in dual source blending mode only the first and second vectors are used. The components that are included for the first and second vectors are shown in SPH and the PS registers specifies the pixel shader registers that are allocated for storing the components. The SetCtSelect shuffle specifies the remapping of the first pixel shader vector to one or more render targets. The targetWE is the write enable mask for each render target. The register to RGBA indicates the PS register that is output for each component of the render target where a default value of d is used when the component is not generated by the pixel shader. In this example the format mask is not used.

The first and second PS vector are directed to all of the targets regardless of SetCtSelect shuffle since all of the targets are dual source. The RGB components are generated for vector and written using PS registers and . The RGBA components are generated for vector and written using PS registers and . Components of vector are selected packed and transmitted from the pixel shader to the ROP based on SPH and the targetWE for each one of the enabled targets. Components of vector are selected packed and transmitted from the pixel shader to the ROP based only on SPH.

The targetWE for target is 1011 so R and B stored in registers and are provided to the R and B components of the first source for target and the default value is provided to the A component of the first source for target. R B and A stored in registers and are provided to the R B and A components of the second source for target.

No buffer is attached to targets and so the format mask not depicted is 0000 the targetWE is irrelevant and no components are written to those targets for either the first or second source. The targetWE for target is 0001 so the default value is provided to the A component of the first source for target and the A stored in register is provided to the A component of the second source for target. The targetWE for target is 1111 so R G and B stored in registers and are provided to the R G and B components of the first source for target and the default value is provided to the A component of the first source for target. The R G B and A components stored in registers and are provided to the R G B and A components of the second source for target.

The targetWE for target is 1000 so the R component stored in register is provided to the R component of the first source for target and the R component stored in register is provided to the R component of the second source for target. The targetWE for target is 1110 so the R G and B components stored in registers and are written to the R G and B components of the first source for target. The R G and B components stored in registers and are written to the R G and B components of the second source for target.

The SPH is used to allocate registers and store only the enabled components for each vector. The SPH component mask for each vector and the targetWE mask for each render target are combined to select and pack the components that are transmitted for each one of the render targets. One advantage of the combined mask is that the number of components that are transmitted from the pixel shader to the ROP is reduced thereby saving bandwidth between those processing units. Additionally the pixel shader and ROP are configured to support the MRT non MRT and dual source blending modes. Another advantage is that the device driver overhead is reduced since CPU cycles are not needed to validate every combination of the pixel shader color target attachments SPH component mask and write masks targetWE mask .

One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored.

The invention has been described above with reference to specific embodiments. Persons skilled in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

