---

title: Composition of locks in software transactional memory
abstract: A software transactional memory (STM) system allows the composition of traditional lock based synchronization with transactions in STM code. The STM system acquires each traditional lock the first time that a corresponding traditional lock acquire is encountered inside a transaction and defers all traditional lock releases until a top level transaction in a transaction nest commits or aborts. The STM system maintains state information associated with traditional lock operations in transactions and uses the state information to eliminate deferred traditional lock operations that are redundant. The STM system integrates with systems that implement garbage collection.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08719515&OS=08719515&RS=08719515
owner: Microsoft Corporation
number: 08719515
owner_city: Redmond
owner_country: US
publication_date: 20100621
---
This application is related to co owned and co pending U.S. patent application Ser. No. 12 819 494 which is entitled ACTION FRAMEWORK IN SOFTWARE TRANSACTIONAL MEMORY filed May 10 2010 and is incorporated by reference in its entirety.

Computer programs may be written to allow different portions of the program to be executed concurrently using threads or another suitable concurrent execution mechanism. In order to execute different portions of the program concurrently the computer system or the program typically includes some mechanism to manage the memory accesses of the different portions to ensure that the parts access common memory locations in the desired order.

Transactional memory systems allow programmers to designate transactions in a program that may be executed as if the transactions are executing in isolation i.e. independently of other transactions and other non transactional sequences of instructions in the program . Transactional memory systems manage the memory accesses of transactions by executing the transactions in such a way that the effects of the transaction may be rolled back or undone if two or more transactions attempt to access the same memory location in a conflicting manner. Transactional memory systems may be implemented using hardware and or software components.

Transactional memory systems such as software transactional memory STM systems often have limitations on the types of programming scenarios that are supported. For example STM systems do not typically support the interoperation between transactional and traditional locks or the use of lock elision for traditional locks inside transactions. To do so an STM system would be obligated to allow the use of traditional locks inside transactions without precluding the possibility of the same lock protecting shared state inside and outside transactions.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

A software transactional memory STM system allows the composition of traditional lock based synchronization with transactions in STM code. The STM system acquires each traditional lock the first time that a corresponding traditional lock acquire is encountered inside a transaction and defers all traditional lock releases until a top level transaction in a transaction nest commits or aborts. The STM system maintains state information associated with traditional lock operations in transactions and uses the state information to eliminate deferred traditional lock operations that are redundant. The STM system integrates with systems that implement garbage collection.

In the following Detailed Description reference is made to the accompanying drawings which form a part hereof and in which is shown by way of illustration specific embodiments in which the invention may be practiced. In this regard directional terminology such as top bottom front back leading trailing etc. is used with reference to the orientation of the Figure s being described. Because components of embodiments can be positioned in a number of different orientations the directional terminology is used for purposes of illustration and is in no way limiting. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description therefore is not to be taken in a limiting sense and the scope of the present invention is defined by the appended claims. It is to be understood that the features of the various exemplary embodiments described herein may be combined with each other unless specifically noted otherwise.

STM system includes an STM library and a runtime environment for executing STM code . STM system is configured to manage the execution of STM transactions that form atomic blocks in STM code to allow transactions to be executed atomically and if desired rollback or undo changes made by transactions . To do so STM system tracks memory accesses by transactions to objects using a log for each executing transaction as indicated by an arrow .

STM code includes a set of one or more transactions and any suitable non transactional code. Each transaction includes a sequence of instructions that is designed to execute atomically i.e. as if the sequence is executing in isolation from other transactional and non transactional code in STM code . Each transaction includes an atomic block designator that indicates that a corresponding portion of STM code is a transaction . Transactions also include invocations of STM primitives which may be added by a compiler such as a compiler shown in and described in additional detail below that call functions in STM library . The STM primitives of STM library return results to transactions as indicated by function calls and returns . In addition each transaction includes zero or more memory accesses that read from and or write to one or more objects as indicated by arrows .

STM code may include one or more nested transactions in the set of transactions . A nested transaction is a transaction that is invoked by another transaction i.e. a parent transaction. The parent transaction and any transactions that are invoked by the parent transaction or stem from an invocation from the parent transaction form a transaction nest.

STM library includes STM primitives and instructions executable by the computer system in conjunction with runtime environment to implement STM system . The STM primitives of STM library that are callable by transactions may include management primitives that implement start commit abort and retry functions in STM library . A transaction calls the start function to initiate the management of the transaction by STM library . A transaction calls the commit function to finalize the results of the transaction in memory system if successful. A transaction calls the abort function to roll back or undo the results of the transaction in memory system . A transaction calls the retry function to retry the transaction . In other embodiments some or all of the functions performed by STM library may be included in runtime environment or added to transactions by a compiler such as compiler shown in .

The STM primitives of STM library that are callable by transactions also include memory access primitives that manage accesses to objects that are written and or read by a transaction . The memory access primitives access a set of one or more transactional locks A for each object . In one embodiment STM system uses the object header of objects to store the corresponding transactional locks A. Each transactional lock A indicates whether a corresponding object or portion of a corresponding object is locked or unlocked for writing and or reading by a transaction . When an object is locked for writing the corresponding transactional lock A includes an address or other reference that locates an entry for the object in a write log W in one embodiment. When an object is not locked for writing the corresponding transactional lock A includes a version number of the object .

For each non array object the memory access primitives may access a single transactional lock A that locks or unlocks the non array object for writing and or reading by a transaction . For each array object the memory access primitives may access a set of one or more transactional locks A where each transactional lock A in the set locks or unlocks a corresponding portion of the array object for writing and or reading. Runtime environment creates and manages the transactional lock s A for each object .

The memory access primitives of STM library generate and manage a set of one or more STM logs for each transaction currently being executed. Each set of STM logs includes a write log W and a read log R in one embodiment. Each write log W includes an entry for each object that is written by a transaction where each entry includes an address of a corresponding object the version number from the transactional lock A of the corresponding object and an address or other reference that locates a shadow copy of the corresponding object . Each read log R includes an entry for each object that is read by a transaction where each entry includes a reference that locates the transactional lock A of a corresponding object .

Runtime environment may be any suitable combination of runtime libraries a virtual machine VM operating system OS functions such as functions provided by an OS shown in and described in additional detail below and or compiler functions such as functions provided by compiler shown in and described in additional detail below.

STM library performs the following algorithm or variations thereof to execute each transaction . Each time a transaction is started by a thread of execution STM library creates and initializes variables used to manage the transaction. STM library then allows the transaction to execute and perform any write and or read memory accesses to objects as follows.

To access an object for writing the transaction invokes a memory access primitive that opens the object for writing. STM library acquires a transactional lock A corresponding to the object for the transaction if the lock A is available. If the object is not available i.e. the object is locked by another transaction then STM library detects a memory access conflict between the current transaction and the other transaction and may initiate an abort phase of transaction execution to rollback and re execute the current transaction . If the object is locked by the current transaction then STM library has already acquired the transactional lock A corresponding to the object for the transaction . Once a corresponding transactional lock A is acquired STM library causes each write access to be made to either the object itself or a shadow copy of a corresponding object not shown and causes an entry corresponding to the write access to be stored in log W. For non array objects the shadow copy if used may be stored in log W. For array objects a shared shadow copy if used may be stored separately from log W.

To access an object for reading the transaction invokes a memory access primitive that opens the object for reading. If the object is not write locked and does not exceed a maximum number of pessimistic readers supported by a pessimistic read lock STM library causes an entry corresponding to the read access to be stored in read log R. If the read access is a pessimistic read access STM library also acquires a transactional lock A for the object . If the object is locked for write access by another transaction then STM library detects a memory access conflict between the current transaction and the other transaction and may initiate the abort phase of transaction execution to rollback and re execute the current transaction . If the object is locked for write access by the current transaction then STM library may cause an entry corresponding to the read access to be stored in read log R or set a flag corresponding to the object in write log W to indicate that the object was also read. STM library causes a read access that occurs before a designated object has been opened for writing by the transaction to be made directly from the corresponding object . STM library causes each read access that occurs after a designated object has been opened for writing by a transaction to be made from either the corresponding object directly or the corresponding shadow copy.

After a transaction finishes executing or re executing STM library performs validation and commit phases of transaction execution to ensure that the memory accesses by the transaction did not conflict with the memory accesses by any other transaction . STM library performs the validation phase by validating the read accesses of the transaction to confirm that no other transaction wrote a memory location corresponding to a read access of the transaction subsequent to the read access being performed. If STM library detects any memory access conflicts between the current transaction and another transaction during the validation phase STM library may initiate the rollback phase of transaction execution to rollback and re execute the current transaction .

STM library performs the commit phase by updating any objects that were modified by the transaction with the shadow copies used to store the modifications releasing any transactional locks A and or storing an updated version number in the transactional locks A of any objects that were modified by the transaction .

After successfully performing the validation and the commit phases of transaction execution STM library allows the transaction to complete and allows the thread that caused the transaction to be executed to execute additional transactional or non transactional code in STM code .

STM system allows the composition of traditional lock based synchronization with transactions in STM code . Both transactions and non transactional code in STM code may acquire and release traditional locks B to objects in addition to the concurrency controls provided by STM library for transactions using transactional locks A. In particular STM library allows transactions to contain the same traditional lock acquires and releases of traditional locks B that are included in non transactional code in STM code .

To allow the composition of traditional locks B with transactions STM library physically acquires a traditional lock B for an object the first time that a traditional lock acquire is encountered inside a transaction . By doing so STM library ensures that the traditional lock B cannot be acquired by another thread regardless of whether the other thread is executing transactional code or non transactionsal code. When a traditional lock release is encountered inside a transaction for a traditional lock B however STM library continues executing the transaction without releasing the traditional lock B and defers the traditional lock release until the commit phase of transaction execution. The traditional lock B remains locked until the traditional lock B is released during the commit phase of transaction execution.

STM library maintains state information associated with traditional lock acquires and releases in transactions . The state information includes the number and type of operations on a traditional lock B encountered inside a transaction nest. By doing so STM library may elide traditional lock acquires for a traditional lock B of an object on the second and subsequent lock acquires for the traditional lock B from a transaction . STM library may also support unbalanced scenarios where a transaction contains only a traditional lock acquire or only a traditional lock release. STM library may further support complex scenarios where a transaction contains multiple traditional lock acquires multiple traditional lock releases or an unequal number of traditional lock acquires and lock releases.

In one embodiment shown in STM system uses a lightweight key based action framework to maintain state information associated with traditional lock acquires and releases in transactions . The framework includes a set of unified application programming interfaces APIs exposed by STM library that allow clients e.g. programmers and or compilers to implement actions that can be registered queried and updated using specific keys by transactions or transaction nests in STM code . Each action includes a key state information and a set of one or more callbacks that can be hooked to the validation commit abort and or rollback phases of transaction execution. Actions extend the built in concurrency controls of STM system with customized control logics support transaction nesting semantics of STM system and enable integration with embodiments of STM system that operate with garbage collection systems. Additional details of a lightweight key based action framework may be found in U.S. patent application Ser. No. 12 819 494 which is entitled ACTION FRAMEWORK IN SOFTWARE TRANSACTIONAL MEMORY filed concurrently herewith and is incorporated by reference in its entirety. In other embodiments STM system uses other suitable programming constructs to maintain state information associated with traditional lock acquires and releases in transactions .

With the action framework STM library generates an action map as indicated by an arrow for each transaction that registers an action . Each action map includes references to the actions registered by STM library in response to action instructions from the corresponding transaction . STM library inserts each action with an associated key that is provided by a transaction as a parameter with an action instruction into a corresponding action map for the transaction . State information and callbacks in each action may be based on a type of the action instruction and or one or more parameters provided by the transaction with the action instruction . Action instructions may be added to transactions by a programmer or a compiler such as compiler shown in .

STM library manages actions in each action map using keys instead of simply queuing actions in a list. By doing so STM library allows a transaction to query and update the corresponding actions throughout the execution of the transaction . Accordingly state information and callbacks may be modified by the transaction . The combination of keys state information and callbacks contained by actions may overcome the limitations of a stateless callback infrastructure that prevent certain STM programming scenarios from being solved. In addition the use of a single action for each key may allow a transaction to execute with increased efficiency by avoiding adding multiple callback invocations for the same purpose.

In addition to associating per instances state with transactions STM library may also generate keys that combine instance identifier information with facility identifier information. By doing so STM library allows registration of multiple actions with the same facility or across different facilities and provides for disambiguation between actions that use object addresses as keys for different purposes e.g. shadow copy management and traditional lock management . In addition STM library prevents one facility from accessing the state i.e. the action maintained by a different facility. As a result the action framework of STM library may be exposed to users in a secure manner.

The action framework APIs of STM library provide three types of callbacks that allow transactions to hook into STM system . The callbacks include transaction stage callbacks nesting integration callbacks and resource management and garbage collection integration callbacks. Each action provides a customized implemention of these callbacks if specific behaviors are desired.

In one embodiment the transaction stage callbacks include OnPrepareForCommit OnCommit and OnRollback. The OnPrepareForCommit callback occurs during the validation phase of a transaction . During the validation phase STM library detects any actions that implement the OnPrepareForCommit callback and invokes any such callbacks . The OnPrepareForCommit callback allows a transaction to participate in the validation process that determines whether a transaction commits or rolls back and re executes. The OnCommit callback occurs during the commit phase. During the commit phase STM library detects any actions that implement the OnCommit callback and invokes any such callbacks . The OnRollback callback occurs during the rollback phase when a transaction aborts or rolls back for re execution. When a transaction reaches an abort or roll back point STM library detects any actions that implement the OnRollback callback and invokes any such callbacks . In other embodiments the transaction stage callbacks may include other callbacks related to different phases of execution of transactions .

The action framework of STM library includes built in support of nesting semantics of actions . Transactions may provide a SearchParent parameter with an action instruction to specify whether the current action is to be associated with the innermost nested transaction that is currently active or with the whole transaction nest. The close integration with the transaction nesting hierarchy may provide greater flexibility and expressiveness to transactions that implement actions . Accordingly transactions may choose either flat or nesting semantics for their actions .

In one embodiment the nesting integration callbacks include DeferToParentOnCommit DeferToParentOnAbort MergeToParent and SurviveOnRollback callbacks . The DeferToParentOnCommit and DeferToParentOnAbort callbacks allow nested transactions to specify whether an action is to be deferred to a parent transaction when committing DeferToParentOnCommit or aborting DeferToParentOnAbort the nested transactions . For actions that are deferred to a parent transaction STM library inserts or updates a corresponding action in the action map of the parent transaction . The MergeToParent callback allows a nested transaction to specify how to merge the state of an action into an action with the same key if any in the action map of the parent transaction . The SurviveOnRollback causes an action to be maintained rather than deleted in action map when a transaction rolls back. In other embodiments the nesting integration callbacks may include other callbacks related to nested transactions .

For embodiments of STM system that work with languages powered by garbage collection such as C or Java garbage collection integration with STM library ensures correctness. If STM system holds a reference to a memory location that is managed by the garbage collector STM system reports the reference to the garbage collector so that the reference can be updated correctly during garbage collections. Because actions may hold managed references STM library provides garbage collection hooks to let actions report any references to the garbage collector.

In one embodiment the resource management and garbage collection integration callbacks include Release and OnGCScan callbacks . The Release callback occurs during the commit phase where STM library to allow a transaction to release a resource. The OnGCScan callback occurs during garbage collection to allow STM library to report references in actions to the garbage collector. In other embodiments the resource management and garbage collection integration callbacks may include other callbacks related to resource management and garbage collection.

STM library generally registers an action for the first traditional lock acquire or lock release of a lock of each object for each transaction unless an exception or contention on the traditional lock B occurs. are flow charts illustrating an embodiment of a method for processing traditional lock operations in STM system .

If the lock B is not successfully acquired as indicated in block then STM library may cause the transaction to rollback based on a conflict on the object between the transaction and another transaction or other non transactional code in STM code as indicated in a block .

If the traditional lock acquire operation is not the first traditional lock operation on the object from the transaction as indicated in block then STM library updates the state information in the lock interoperation action for the object as indicated in a block . In particular STM library increments the number of times the object was locked inside the current transaction and all nested transactions that have committed to reflect the present traditional lock acquire operation.

If the current thread owns the lock B STM library determines whether the lock acquire operation is the first traditional lock operation on the object from the transaction as indicated in a block . If so then STM library registers a lock interoperation action for the object in the action map of the transaction if the lock B is owned by the current thread as indicted in a block . STM library may use the reference to the object as the key indicate the lock B has been released for the first time in state information and register a callback corresponding to a commit phase of transaction execution for the transaction to cause the lock release to occur during commit processing of the transaction. STM library may also initialize the other information in state information described above with reference to .

If the lock acquire operation is not the first traditional lock operation on the object from the transaction as indicated in block then STM library updates the state information in the lock interoperation action for the object as indicated in a block . In particular STM library decrements the number of times the object was locked inside the current transaction and all nested transactions that have committed to reflect the present lock release operation. STM library determines whether the number of traditional lock releases for the lock B exceed the number of traditional the lock acquires for the lock B as indicated in a block . To do so STM library examines state information which identifies the number of times that the current thread recursively acquired the lock B before the current transaction began the number of times that the object was locked inside the current transaction and all nested transactions that have committed the number and type of lock operations that were deferred inside the transaction and the number of times that the object was physically locked in nested transactions that were aborted. If the lock releases exceed the lock acquires for the lock B then STM library throws an exception as indicated in block .

STM library performs the methods of to cause a transaction to hold each lock B taken by the transaction until the whole transaction nest that includes the transaction commits successfully or aborts. The use of the lock interoperation action causes release of the locks B to be deferred until the whole transaction nest commits successfully or aborts even if there are lock release operations inside the transaction or transaction nest. The lock interoperation action also allows a single physical lock operation to be performed for each lock B in a transactional nest.

STM system accesses the action map for a transaction at each phase of transaction execution of the transaction to identify actions with callbacks associated with the transaction execution phases. In response to reaching a transaction execution phase for a transaction STM library identifies each action in the action map of the transaction with callbacks associated with the transaction execution phase and invokes the identified callbacks for the transaction execution phase if any for each action in the action map .

STM library uses lock interoperation actions to allow traditional lock operations to be compensated when a transaction rolls back or a transaction nest i.e. the top level transaction of a transaction nest commits. If a transaction rolls back STM library accesses actions to identify locks B that were acquired by the transaction and invokes the callbacks to release the locks B. STM library leaves any locks B that were released by the rolled back transaction unchanged.

When a nested transaction commits i.e. a transaction in a transaction nest other than the top level transaction of the transaction nest STM library merges the actions associated with locks B in the action map of the nested transaction into corresponding actions in the action map of the parent transaction . STM library merges the actions by registering any actions from the nested transaction that are not present in the action map of the parent transaction and updating any actions from the nested transaction that are present in the action map of the parent transaction i.e. actions with the same keys in the parent and nested action maps . By doing so STM library updates the state of the actions of the parent transaction to reflect the lock operations performed by the nested transaction and defers any lock releases from the nested transaction until the top level transaction commits.

By merging actions from nested transactions as described above the actions in the action map of a top level transaction include information about the traditional lock operations that occurred in the transaction nest. These actions were also initialized to include information regarding relevant traditional lock operations that preceded the top level transaction as noted above. Accordingly STM library may optimize the performance of STM system by omitting redundant lock operations.

When a top level transaction of a transaction nest commits STM library executes the minimum number of deferred operations to correctly set the state of each lock B operated on by the transaction nest. For example if a transaction nest acquires a lock B three times STM library acquires the lock B one time and defers the other two lock acquires. If the transaction nest subsequently releases the lock B three times STM library defers these releases and at commit time determines that two lock acquires have been deferred and three lock releases have been deferred. Accordingly STM library performs one lock release to correctly set the state of the lock B without performing the additional lock acquires or lock releases.

In one embodiment STM system operates in a computer system with the .NET framework from Microsoft. The .NET framework allows programmers to use lexically scoped locks using the lock keyword and to specify acquire and releases individually via static methods on the Monitor class. Lock acquires can be done through the Monitor.Enter Monitor.TryEnter and Monitor.ReliableEnter methods and lock releases can be done through the Monitor.Exit methods. These methods can lead to unbalanced scenarios where a transaction contains only a traditional lock acquire or a traditional lock release. These methods can also lead to more complex scenarios where a transaction contains multiple traditional lock acquires multiple traditional lock releases or an unequal number of traditional lock acquires and releases. STM system supports these unbalanced and complex scenarios by maintaining the state information actions about the number and type of operations on a lock encountered inside a transaction nest as described above.

With the above embodiments STM library may also implement additional contention management algorithms to increase the performance of STM system . In particular calls to acquire a lock inside a transaction that may block the thread until the lock is acquired may be set to ensure that the thread does not block. For example the Monitor.TryEnter method of the .NET framework may be set with a zero timeout. In addition STM library may retry any lock acquires that do not succeed using various contention management techniques. is a flow chart illustrating an embodiment of a method for processing lock operations with contention management algorithms in STM system .

To initiate the acquisition of a traditional lock B in the embodiment of a transaction invokes an action instruction in STM library with parameters that include a reference to the object and an indication that the instruction is for an acquisition of a lock B. In response to the action instruction STM library determines whether the lock acquire operation is the first traditional lock operation on the object from the transaction as indicated in block and described above with reference to . If so STM library ensures that the lock acquire is non blocking as indicated in a block . In embodiments with the .NET framework for example STM library may set the timeout of a Monitor.TryEnter method to zero.

If the lock acquire operation is the first traditional lock operation on the object from the transaction STM library attempts to acquire the lock B as indicated in block . If the lock B is successfully acquired as indicated in block and described above with reference to then STM library registers a lock interoperation action for the object in the action map of the transaction if the lock B is acquired as indicted in block and described above with reference to .

If the lock B is not successfully acquired as indicated in block then STM library invokes a contention management algorithm to determine whether to reattempt to acquire the lock B as indicated in a block . In one embodiment the contention management algorithm reattempts the lock acquisition a designated number of times i.e. performs the functions of blocks and before rolling back the transaction if the reattempts are unsuccessful. In another embodiment the contention management algorithm reattempts the lock acquisition a designated number of times but introduces backoff delays with each subsequent reattempt before rolling back the transaction if the reattempts are unsuccessful. The backoff delays may be constant or grow linearly or exponentially with each successive reattempt.

By deferring traditional lock releases until transactions commit lock ordering deadlock problems may occur where multiple transactions contend for the same set of traditional locks B. Accordingly STM library may also provide deadlock detection and avoidance techniques in the contention management algorithm. For example the contention management algorithm may keep track of all of the locks B that the transaction acquires or attempts to acquire. If the conflicting transactions are re executed STM library may try to acquire all of the locks B of the conflicting transactions immediately and also introduce some artificial order in trying to acquire the locks B. By introducing an artificial order STM library may help prevent deadlocks if multiple transactions are trying to access the same set of locks B. In addition the contention management algorithm may define a universal way of generating the lock acquisition order such as ordering lock acquisitions based on the object hashcode. By doing so STM library may ensure that a transaction that acquired locks B when the transaction was re executed would not deadlock.

If the contention management algorithm decides not to reattempt to acquire the lock B in block then STM library causes the transaction to rollback as indicated in block and described above with reference to .

If the lock acquire operation is not the first lock operation on the object from the transaction as indicated in block then STM library updates the state information in the lock interoperation action for the object as indicated in block and described above with reference to .

STM library may be further configured to elide traditional lock acquisitions that occur only in transactions using the action framework. When a thread acquires a lock B outside a transaction other threads are prevented from acquiring that lock B either inside or outside a transaction. When all operations on shared objects are made within transactions however STM library may ignore the presence of traditional locks B because STM library inherently provides isolation between transactions using transactional locks A. Accordingly STM library tracks of whether a traditional lock B has been acquired outside a transaction or only inside transactions to allow lock acquisitions in transactions to be elided.

In one embodiment where STM library is configured to elide lock acquisitions objects have embodiments B of locks B as shown in . Rather than indicating only locked or unlocked states locks B include a state indicator that indicates whether a corresponding object is idle i.e. not in use by any thread owned i.e. exclusively acquired by one thread or transacted i.e. shared by one or more threads inside transactions .

When an idle lock B is acquired by non transactional code the state of the lock B is changed to owned. A thread cannot acquire a lock B owned by another thread with either transactional or non transactional code. The state reverts to idle when that thread releases the lock B . When an idle lock is acquired inside a transaction STM library changes state to transacted. When a lock B is transacted i.e. acquired or released in a transaction other threads can acquire the lock inside of a transaction but not outside of a transaction i.e. with non transactional code . When all transactions that acquired and released that lock B are committed or aborted STM library changes the state back to idle.

Using the embodiment of STM library sets the state of each lock B of objects that are locked or released by a transaction to transacted if the state is idle. STM library does so when registering an action for a lock operation by a transaction . For lock acquisitions STM library elides the actual lock acquisition and relies on the state to ensure that conflicts are detected. If the state of a lock B is owned STM library either rolls back the transaction or invokes a contention management algorithm as described above.

In addition to eliding lock acquisitions as just described STM library may be further configured to access reader writer locks in transactions using the action framework and the embodiment B of locks B shown in . As shown in locks B include a state indicator that extends the idle owned or transacted states as described above with reference to state indictor in to include shared i.e. shared by one or more threads inside or outside transactions . When state of a lock B is shared rather than exclusively owned multiple threads may concurrently acquire the lock B either transactionally or non transactionally.

In the above embodiments STM system preserves traditional lock acquire and lock release semantics including exception behavior and unbalanced scenarios when traditional lock operations are accessed inside transactions . STM system also maintains the semantics for nested transactions and for systems that implement garbage collection. In addition STM system may reduce the actual number of traditional lock operations that are performed by omitting redundant lock operations when a transaction commits or aborts. Further STM system may implement contention management algorithms that may increase the performance of system .

STM library may also use the action framework described above to solve one or more STM programming scenarios such as supporting the use of thread local memory in transactions supporting static class initializers and modular initializers in transactions and providing a customized abstract concurrency control in other embodiments.

Compiler system represents a compile mode of operation in a computer system such as computer system shown in and described in additional detail below where the computer system is executing instructions to compile code into STM code . In one embodiment compiler system includes a just in time JIT compiler system that operates in the computer system in conjunction with a runtime environment executed by an operating system OS such as OS shown in and described in additional detail below STM library and any additional runtime libraries not shown . In another embodiment compiler system includes a stand alone compiler system that produces STM code for execution on the same or a different computer system.

Code includes a set of one or more STM transactions . Each STM transaction includes an atomic block designator that indicates to compiler that a corresponding portion of code is an STM transaction . Each STM transaction may include zero or more memory accesses that read from and or write to an object . Each STM transaction may also include zero or more action instructions not shown that generate query or update actions . Code may be any suitable source code written in a language such as Java or C or any suitable bytecode such as Common Intermediate Language CIL Microsoft Intermediate Language MSIL or Java bytecode.

Compiler accesses or otherwise receives code with transactions that include memory accesses . Compiler identifies memory accesses and compiles code into STM code with invocations of STM primitives in STM library for each memory access . Compiler may also identify instances where an action may be used and compiles code into STM code with action instructions for each instance where an action may be used. Compiler performs any desired conversion of the set of instructions of code into a set of instructions that are executable by a designated computer system and includes the set of instructions in STM code .

Computer system includes one or more processor packages memory system zero or more input output devices zero or more display devices zero or more peripheral devices and zero or more network devices . Processor packages memory system input output devices display devices peripheral devices and network devices communicate using a set of interconnections that includes any suitable type number and configuration of controllers buses interfaces and or other wired or wireless connections.

Computer system represents any suitable processing device configured for a general purpose or a specific purpose. Examples of computer system include a server a personal computer a laptop computer a tablet computer a personal digital assistant PDA a mobile telephone and an audio video device. The components of computer system i.e. processor packages memory system input output devices display devices peripheral devices network devices and interconnections may be contained in a common housing not shown or in any suitable number of separate housings not shown .

Processor packages each include one or more execution cores. Each execution core is configured to access and execute instructions stored in memory system . The instructions may include a basic input output system BIOS or firmware not shown OS STM code STM library runtime environment compiler and code . Each execution core may execute the instructions in conjunction with or in response to information received from input output devices display devices peripheral devices and or network devices .

Computer system boots and executes OS . OS includes instructions executable by execution cores to manage the components of computer system and provide a set of functions that allow programs to access and use the components. OS executes runtime environment to allow STM code and STM library to be executed. In one embodiment OS is the Windows operating system. In other embodiments OS is another operating system suitable for use with computer system .

Computer system executes compiler to generate STM code from code . Compiler accesses or otherwise receives code and transforms code into STM code for execution by computer system . Compiler performs any desired conversion of the set of instructions of code into a set of instructions that are executable by computer system and includes the set of instructions in STM code . Compiler also identifies blocks in code from transaction designators and modifies blocks in STM code to include invocations of STM primitives .

In one embodiment compiler includes a just in time JIT compiler that operates in computer system in conjunction with OS runtime environment and STM library . In another embodiment compiler includes a stand alone compiler that produces STM code for execution on computer system or another computer system not shown .

Computer system executes runtime environment and STM library to allow STM code and transactions therein to be executed in computer system as described above.

Memory system includes any suitable type number and configuration of volatile or non volatile storage devices configured to store instructions and data. The storage devices of memory system represent computer readable storage media that store computer executable instructions including STM code STM library runtime environment OS compiler and code . The instructions are executable by computer system to perform the functions and methods of STM code STM library runtime environment OS compiler and code as described herein. Memory system stores instructions and data received from processor packages input output devices display devices peripheral devices and network devices . Memory system provides stored instructions and data to processor packages input output devices display devices peripheral devices and network devices . Examples of storage devices in memory system include hard disk drives random access memory RAM read only memory ROM flash memory drives and cards and magnetic and optical disks such as CDs and DVDs.

Input output devices include any suitable type number and configuration of input output devices configured to input instructions or data from a user to computer system and output instructions or data from computer system to the user. Examples of input output devices include a keyboard a mouse a touchpad a touchscreen buttons dials knobs and switches.

Display devices include any suitable type number and configuration of display devices configured to output textual and or graphical information to a user of computer system . Examples of display devices include a monitor a display screen and a projector.

Peripheral devices include any suitable type number and configuration of peripheral devices configured to operate with one or more other components in computer system to perform general or specific processing functions.

Network devices include any suitable type number and configuration of network devices configured to allow computer system to communicate across one or more networks not shown . Network devices may operate according to any suitable networking protocol and or configuration to allow information to be transmitted by computer system to a network or received by computer system from a network.

Although specific embodiments have been illustrated and described herein it will be appreciated by those of ordinary skill in the art that a variety of alternate and or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore it is intended that this invention be limited only by the claims and the equivalents thereof.

