---

title: Distributed stream output in a parallel processing unit
abstract: A technique for performing stream output operations in a parallel processing system is disclosed. A stream synchronization unit is provided that enables the parallel processing unit to track batches of vertices being processed in a graphics processing pipeline. A plurality of stream output units is also provided, where each stream output unit writes vertex attribute data to one or more stream output buffers for a portion of the batches of vertices. A messaging protocol is implemented between the stream synchronization unit and the plurality of stream output units that ensures that each of the stream output units writes vertex attribute data for the particular batch of vertices distributed to that particular stream output unit in the same order in the stream output buffers as the order in which the batch of vertices was received from a device driver by the parallel processing unit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08817031&OS=08817031&RS=08817031
owner: NVIDIA Corporation
number: 08817031
owner_city: Santa Clara
owner_country: US
publication_date: 20100929
---
This application claims priority benefit to United States provisional patent application titled DISTRIBUTED STREAM OUTPUT filed on Oct. 2 2009 and having Ser. No. 61 248 385.

The invention relates generally to parallel data processing and more specifically to distributed stream output in a parallel processing unit.

General purpose computing on graphics processing units GPGPU is a technique used to perform highly parallel processing tasks using a graphics processing unit GPU in place of a traditional central processing unit CPU . Programmable shader programs enable software to configure the GPU to perform highly parallel computing tasks such as physics calculations and financial simulations. The graphics application programming interface API includes a mechanism for performing stream output after primitive data or vertex data has been processed by a shader program. Stream output enables the data processed in the GPU to bypass the pixel shader and rasterization units in the graphics pipeline.

Conventional GPUs include a single hardware unit for performing stream output. The stream output unit writes data to one or more stream output buffers located in memory. Conventionally the stream output buffers are located in the frame buffer stored in a local DRAM memory. The graphics API expects stream output generated by the GPU to be written to the stream output buffers in a serialized fashion e.g. the first work packet sent to the GPU corresponds to the first stream output data written to the stream output buffers. In addition the stream output unit bandwidth is typically smaller than the total frame buffer bandwidth in the GPU.

One drawback to the technique of using a single stream output unit is that the stream output unit is unable to saturate the available frame buffer bandwidth. Increasing the bandwidth of the single stream output unit to match the bandwidth of the frame buffer would increase the size and complexity of the layout of the stream output unit on the GPU integrated circuit as well as increasing power consumption. A further drawback to this technique is that in the case where a GPU implements parallel shader programs in a multi core processor using a single stream output unit creates a bottleneck in the graphics processing pipeline. In such cases each shader program is required to wait until all prior issued work packets are written to the stream output buffers by the stream output unit. Therefore a shader program that is ready to write data to the stream output buffers may sit idle while other shader programs finish processing and write data to the stream output buffers using the stream output unit. This serialized stream output technique reduces the advantages of executing parallel shader programs.

As the foregoing illustrates what is needed in the art is an improved method for performing stream output by parallel processing units.

One embodiment of the present invention sets forth a method for controlling distributed stream output operations in a parallel processing unit. The method includes the steps of receiving a request message from a first stream output unit that includes a current batch identification number corresponding to a batch of vertices being processed within the parallel processing unit and determining whether the current batch identification number is equal to a batch identification number corresponding to a next batch of vertices being processed in the parallel processing unit that is to be written to one or more stream output buffers. If the current batch identification number is equal to the batch identification number sending a response message that includes one or more stream output buffer offsets where each stream output buffer offset indicates a location in a different one of the one or more stream output buffers where data is to be written. However if the current batch identification number is not equal to the batch identification number waiting for a request message from a different stream output unit.

One advantage of the disclosed method is that the distributed stream output units are able to fully saturate the available frame buffer bandwidth. Multiple distributed stream output units may write data to the frame buffer during the same clock cycle. Therefore even though each individual stream output unit may have a narrow bandwidth the total stream output bandwidth is scalable to match the available frame buffer bandwidth. A further advantage of the disclosed method is that each stream output unit may write data to the frame buffer in parallel without waiting for the frame buffer to be filled by all prior issued work bundles. Therefore the bottleneck created when using a single stream output unit for multiple parallel shader programs is reduced.

In the following description numerous specific details are set forth to provide a more thorough understanding of the invention. However it will be apparent to one of skill in the art that the invention may be practiced without one or more of these specific details. In other instances well known features have not been described in order to avoid obscuring the invention.

In one embodiment the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry and constitutes a graphics processing unit GPU . In another embodiment the parallel processing subsystem incorporates circuitry optimized for general purpose processing while preserving the underlying computational architecture described in greater detail herein. In yet another embodiment the parallel processing subsystem may be integrated with one or more other system elements such as the memory bridge CPU and I O bridge to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of parallel processing subsystems may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip. Large embodiments may include two or more CPUs and two or more parallel processing systems . The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

Referring again to in some embodiments some or all of PPUs in parallel processing subsystem are graphics processors with rendering pipelines that can be configured to perform various tasks related to generating pixel data from graphics data supplied by CPU and or system memory via memory bridge and bus interacting with local parallel processing memory which can be used as graphics memory including e.g. a conventional frame buffer to store and update pixel data delivering pixel data to display device and the like. In some embodiments parallel processing subsystem may include one or more PPUs that operate as graphics processors and one or more other PPUs that are used for general purpose computations. The PPUs may be identical or different and each PPU may have its own dedicated parallel processing memory device s or no dedicated parallel processing memory device s . One or more PPUs may output data to display device or each PPU may output data to one or more display devices .

In operation CPU is the master processor of computer system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPUs . In some embodiments CPU writes a stream of commands for each PPU to a pushbuffer not explicitly shown in either or that may be located in system memory parallel processing memory or another storage location accessible to both CPU and PPU . PPU reads the command stream from the pushbuffer and then executes commands asynchronously relative to the operation of CPU .

Referring back now to each PPU includes an I O input output unit that communicates with the rest of computer system via communication path which connects to memory bridge or in one alternative embodiment directly to CPU . The connection of PPU to the rest of computer system may also be varied. In some embodiments parallel processing subsystem is implemented as an add in card that can be inserted into an expansion slot of computer system . In other embodiments a PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . In still other embodiments some or all elements of PPU may be integrated on a single chip with CPU .

In one embodiment communication path is a PCI EXPRESS link in which dedicated lanes are allocated to each PPU as is known in the art. Other communication paths may also be used. An I O unit generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path directing the incoming packets to appropriate components of PPU . For example commands related to processing tasks may be directed to a host interface while commands related to memory operations e.g. reading from or writing to parallel processing memory may be directed to a memory crossbar unit . Host interface reads each pushbuffer and outputs the work specified by the pushbuffer to a front end .

Each PPU advantageously implements a highly parallel processing architecture. As shown in detail PPU includes a processing cluster array that includes a number C of general processing clusters GPCs where C 1. Each GPC is capable of executing a large number e.g. hundreds or thousands of threads concurrently where each thread is an instance of a program. In various applications different GPCs may be allocated for processing different types of programs or for performing different types of computations. For example in a graphics application a first set of GPCs may be allocated to perform tessellation operations and to produce primitive topologies for patches and a second set of GPCs may be allocated to perform tessellation shading to evaluate patch parameters for the primitive topologies and to determine vertex positions and other per vertex attributes. The allocation of GPCs may vary dependent on the workload arising for each type of program or computation.

GPCs receive processing tasks to be executed via a work distribution unit which receives commands defining processing tasks from front end unit . Processing tasks include indices of data to be processed e.g. surface patch data primitive data vertex data and or pixel data as well as state parameters and commands defining how the data is to be processed e.g. what program is to be executed . Work distribution unit may be configured to fetch the indices corresponding to the tasks or work distribution unit may receive the indices from front end . Front end ensures that GPCs are configured to a valid state before the processing specified by the push buffer is initiated.

When PPU is used for graphics processing for example the processing workload for each patch is divided into approximately equal sized tasks to enable distribution of the tessellation processing to multiple GPCs . A work distribution unit may be configured to produce tasks at a frequency capable of providing tasks to multiple GPCs for processing. By contrast in conventional systems processing is typically performed by a single processing engine while the other processing engines remain idle waiting for the single processing engine to complete its tasks before beginning their processing tasks. In some embodiments of the present invention portions of GPCs are configured to perform different types of processing. For example a first portion may be configured to perform vertex shading and topology generation a second portion may be configured to perform tessellation and geometry shading and a third portion may be configured to perform pixel shading in screen space to produce a rendered image. Intermediate data produced by GPCs may be stored in buffers to allow the intermediate data to be transmitted between GPCs for further processing.

Memory interface includes a number D of partition units that are each directly coupled to a portion of parallel processing memory where D 1. As shown the number of partition units generally equals the number of DRAM . In other embodiments the number of partition units may not equal the number of memory devices. Persons skilled in the art will appreciate that DRAM may be replaced with other suitable storage devices and can be of generally conventional design. A detailed description is therefore omitted. Render targets such as frame buffers or texture maps may be stored across DRAMs allowing partition units to write portions of each render target in parallel to efficiently use the available bandwidth of parallel processing memory .

Any one of GPCs may process data to be written to any of the DRAMs within parallel processing memory . Crossbar unit is configured to route the output of each GPC to the input of any partition unit or to another GPC for further processing. GPCs communicate with memory interface through crossbar unit to read from or write to various external memory devices. In one embodiment crossbar unit has a connection to memory interface to communicate with I O unit as well as a connection to local parallel processing memory thereby enabling the processing cores within the different GPCs to communicate with system memory or other memory that is not local to PPU . In the embodiment shown in crossbar unit is directly connected with I O unit . Crossbar unit may use virtual channels to separate traffic streams between the GPCs and partition units .

Again GPCs can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. tessellation shader vertex shader geometry shader and or pixel shader programs and so on. PPUs may transfer data from system memory and or local parallel processing memories into internal on chip memory process the data and write result data back to system memory and or local parallel processing memories where such data can be accessed by other system components including CPU or another parallel processing subsystem .

A PPU may be provided with any amount of local parallel processing memory including no local memory and may use local memory and system memory in any combination. For instance a PPU can be a graphics processor in a unified memory architecture UMA embodiment. In such embodiments little or no dedicated graphics parallel processing memory would be provided and PPU would use system memory exclusively or almost exclusively. In UMA embodiments a PPU may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high speed link e.g. PCI EXPRESS connecting the PPU to system memory via a bridge chip or other communication means.

As noted above any number of PPUs can be included in a parallel processing subsystem . For instance multiple PPUs can be provided on a single add in card or multiple add in cards can be connected to communication path or one or more of PPUs can be integrated into a bridge chip. PPUs in a multi PPU system may be identical to or different from one another. For instance different PPUs might have different numbers of processing cores different amounts of local parallel processing memory and so on. Where multiple PPUs are present those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including desktop laptop or handheld personal computers servers workstations game consoles embedded systems and the like.

Operation of GPC is advantageously controlled via a pipeline manager that distributes processing tasks to streaming multiprocessors SPMs . Pipeline manager may also be configured to control a work distribution crossbar by specifying destinations for processed data output by SPMs .

In one embodiment each GPC includes a number M of SPMs where M 1 each SPM configured to process one or more thread groups. Also each SPM advantageously includes an identical set of functional execution units e.g. arithmetic logic units and load store units shown as Exec units and LSUs in that may be pipelined allowing a new instruction to be issued before a previous instruction has finished as is known in the art. Any combination of functional execution units may be provided. In one embodiment the functional units support a variety of operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation trigonometric exponential and logarithmic functions etc. and the same functional unit hardware can be leveraged to perform different operations.

The series of instructions transmitted to a particular GPC constitutes a thread as previously defined herein and the collection of a certain number of concurrently executing threads across the parallel processing engines not shown within an SPM is referred to herein as a warp or thread group. As used herein a thread group refers to a group of threads concurrently executing the same program on different input data with one thread of the group being assigned to a different processing engine within an SPM . A thread group may include fewer threads than the number of processing engines within the SPM in which case some processing engines will be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of processing engines within the SPM in which case processing will take place over consecutive clock cycles. Since each SPM can support up to G thread groups concurrently it follows that up to G M thread groups can be executing in GPC at any given time.

Additionally a plurality of related thread groups may be active in different phases of execution at the same time within an SPM . This collection of thread groups is referred to herein as a cooperative thread array CTA or thread array. The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group and is typically an integer multiple of the number of parallel processing engines within the SPM and m is the number of thread groups simultaneously active within the SPM . The size of a CTA is generally determined by the programmer and the amount of hardware resources such as memory or registers available to the CTA.

Each SPM contains an L1 cache not shown or uses space in a corresponding L1 cache outside of the SPM that is used to perform load and store operations. Each SPM also has access to L2 caches within the partition units that are shared among all GPCs and may be used to transfer data between threads. Finally SPMs also have access to off chip global memory which can include e.g. parallel processing memory and or system memory . It is to be understood that any memory external to PPU may be used as global memory. Additionally an L1.5 cache may be included within the GPC configured to receive and hold data fetched from memory via memory interface requested by SPM including instructions uniform data and constant data and provide the requested data to SPM . Embodiments having multiple SPMs in GPC beneficially share common instructions and data cached in L1.5 cache .

Each GPC may include a memory management unit MMU that is configured to map virtual addresses into physical addresses. In other embodiments MMU s may reside within the memory interface . The MMU includes a set of page table entries PTEs used to map a virtual address to a physical address of a tile and optionally a cache line index. The MMU may include address translation lookaside buffers TLB or caches which may reside within multiprocessor SPM or the L1 cache or GPC . The physical address is processed to distribute surface data access locality to allow efficient request interleaving among partition units. The cache line index may be used to determine whether of not a request for a cache line is a hit or miss.

In graphics and computing applications a GPC may be configured such that each SPM is coupled to a texture unit for performing texture mapping operations e.g. determining texture sample positions reading texture data and filtering the texture data. Texture data is read from an internal texture L1 cache not shown or in some embodiments from the L1 cache within SPM and is fetched from an L2 cache parallel processing memory or system memory as needed. Each SPM outputs processed tasks to work distribution crossbar in order to provide the processed task to another GPC for further processing or to store the processed task in an L2 cache parallel processing memory or system memory via crossbar unit . A preROP pre raster operations is configured to receive data from SPM direct data to ROP units within partition units and perform optimizations for color blending organize pixel color data and perform address translations.

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Any number of processing units e.g. SPMs or texture units preROPs may be included within a GPC . Further while only one GPC is shown a PPU may include any number of GPCs that are advantageously functionally similar to one another so that execution behavior does not depend on which GPC receives a particular processing task. Further each GPC advantageously operates independently of other GPCs using separate and distinct processing units L1 caches and so on.

In graphics applications ROP is a processing unit that performs raster operations such as stencil z test blending and the like and outputs pixel data as processed graphics data for storage in graphics memory. In some embodiments of the present invention ROP is included within each GPC instead of partition unit and pixel read and write requests are transmitted over crossbar unit instead of pixel fragment data.

The processed graphics data may be displayed on display device or routed for further processing by CPU or by one of the processing entities within parallel processing subsystem . Each partition unit includes a ROP in order to distribute processing of the raster operations. In some embodiments ROP may be configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.

Persons skilled in the art will understand that the architecture described in A and B in no way limits the scope of the present invention and that the techniques taught herein may be implemented on any properly configured processing unit including without limitation one or more CPUs one or more multi core CPUs one or more PPUs one or more GPCs one or more graphics or special purpose processing units or the like without departing the scope of the present invention.

In embodiments of the present invention it is desirable to use PPU or other processor s of a computing system to execute general purpose computations using thread arrays. Each thread in the thread array is assigned a unique thread identifier thread ID that is accessible to the thread during its execution. The thread ID which can be defined as a one dimensional or multi dimensional numerical value controls various aspects of the thread s processing behavior. For instance a thread ID may be used to determine which portion of the input data set a thread is to process and or to determine which portion of an output data set a thread is to produce or write.

A sequence of per thread instructions may include at least one instruction that defines a cooperative behavior between the representative thread and one or more other threads of the thread array. For example the sequence of per thread instructions might include an instruction to suspend execution of operations for the representative thread at a particular point in the sequence until such time as one or more of the other threads reach that particular point an instruction for the representative thread to store data in a shared memory to which one or more of the other threads have access an instruction for the representative thread to atomically read and update data stored in a shared memory to which one or more of the other threads have access based on their thread IDs or the like. The CTA program can also include an instruction to compute an address in the shared memory from which data is to be read with the address being a function of thread ID. By defining suitable functions and providing synchronization techniques data can be written to a given location in shared memory by one thread of a CTA and read from that location by a different thread of the same CTA in a predictable manner. Consequently any desired pattern of data sharing among threads can be supported and any thread in a CTA can share data with any other thread in the same CTA. The extent if any of data sharing among threads of a CTA is determined by the CTA program thus it is to be understood that in a particular application that uses CTAs the threads of a CTA might or might not actually share data with each other depending on the CTA program and the terms CTA and thread array are used synonymously herein.

SPM provides on chip internal data storage with different levels of accessibility. Special registers not shown are readable but not writeable by LSU and are used to store parameters defining each CTA thread s position. In one embodiment special registers include one register per CTA thread or per exec unit within SPM that stores a thread ID each thread ID register is accessible only by a respective one of the exec unit . Special registers may also include additional registers readable by all CTA threads or by all LSUs that store a CTA identifier the CTA dimensions the dimensions of a grid to which the CTA belongs and an identifier of a grid to which the CTA belongs. Special registers are written during initialization in response to commands received via front end from device driver and do not change during CTA execution.

A parameter memory not shown stores runtime parameters constants that can be read but not written by any CTA thread or any LSU . In one embodiment device driver provides parameters to the parameter memory before directing SPM to begin execution of a CTA that uses these parameters. Any CTA thread within any CTA or any exec unit within SPM can access global memory through a memory interface . Portions of global memory may be stored in the L1 cache .

Local register file is used by each CTA thread as scratch space each register is allocated for the exclusive use of one thread and data in any of local register file is accessible only to the CTA thread to which it is allocated. Local register file can be implemented as a register file that is physically or logically divided into P lanes each having some number of entries where each entry might store e.g. a 32 bit word . One lane is assigned to each of the N exec units and P load store units LSU and corresponding entries in different lanes can be populated with data for different threads executing the same program to facilitate SIMD execution. Different portions of the lanes can be allocated to different ones of the G concurrent thread groups so that a given entry in the local register file is accessible only to a particular thread. In one embodiment certain entries within the local register file are reserved for storing thread identifiers implementing one of the special registers.

Shared memory is accessible to all CTA threads within a single CTA any location in shared memory is accessible to any CTA thread within the same CTA or to any processing engine within SPM . Shared memory can be implemented as a shared register file or shared on chip cache memory with an interconnect that allows any processing engine to read from or write to any location in the shared memory. In other embodiments shared state space might map onto a per CTA region of off chip memory and be cached in L1 cache . The parameter memory can be implemented as a designated section within the same shared register file or shared cache memory that implements shared memory or as a separate shared register file or on chip cache memory to which the LSUs have read only access. In one embodiment the area that implements the parameter memory is also used to store the CTA ID and grid ID as well as CTA and grid dimensions implementing portions of the special registers. Each LSU in SPM is coupled to a unified address mapping unit that converts an address provided for load and store instructions that are specified in a unified memory space into an address in each distinct memory space. Consequently an instruction may be used to access any of the local shared or global memory spaces by specifying an address in the unified memory space.

The L1 Cache in each SPM can be used to cache private per thread local data and also per application global data. In some embodiments the per CTA shared data may be cached in the L1 cache . The LSUs are coupled to a uniform L1 cache the shared memory and the L1 cache via a memory and cache interconnect . The uniform L1 cache is configured to receive read only data and constants from memory via the L1.5 Cache .

Data assembler processing unit collects vertex data for high order surfaces primitives and the like and outputs the vertex data including the vertex attributes to vertex processing unit . Vertex processing unit is a programmable execution unit that is configured to execute vertex shader programs lighting and transforming vertex data as specified by the vertex shader programs. For example vertex processing unit may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. Vertex processing unit may read data that is stored in L1 cache parallel processing memory or system memory by data assembler for use in processing the vertex data.

Primitive assembler receives vertex attributes from vertex processing unit reading stored vertex attributes as needed and constructs graphics primitives for processing by geometry processing unit . Graphics primitives include triangles line segments points and the like. Geometry processing unit is a programmable execution unit that is configured to execute geometry shader programs transforming graphics primitives received from primitive assembler as specified by the geometry shader programs. For example geometry processing unit may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives.

In some embodiments geometry processing unit may also add or delete elements in the geometry stream. Geometry processing unit outputs the parameters and vertices specifying new graphics primitives to a viewport scale cull and clip unit . Geometry processing unit may read data that is stored in parallel processing memory or system memory for use in processing the geometry data. Viewport scale cull and clip unit performs clipping culling and viewport scaling and outputs processed graphics primitives to a rasterizer .

Rasterizer scan converts the new graphics primitives and outputs fragments and coverage data to fragment processing unit . Additionally rasterizer may be configured to perform z culling and other z based optimizations.

Fragment processing unit is a programmable execution unit that is configured to execute fragment shader programs transforming fragments received from rasterizer as specified by the fragment shader programs. For example fragment processing unit may be programmed to perform operations such as perspective correction texture mapping shading blending and the like to produce shaded fragments that are output to raster operations unit . Fragment processing unit may read data that is stored in parallel processing memory or system memory for use in processing the fragment data. Fragments may be shaded at pixel sample or other granularity depending on the programmed sampling rate.

Raster operations unit is a processing unit that performs raster operations such as stencil z test blending and the like and outputs pixel data as processed graphics data for storage in graphics memory. The processed graphics data may be stored in graphics memory e.g. parallel processing memory and or system memory for display on display device or for further processing by CPU or parallel processing subsystem . In some embodiments of the present invention raster operations unit is configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.

Although the method steps are described in conjunction with the systems of A B and C persons skilled in the art will understand that any system configured to perform the method steps in any order is within the scope of the inventions.

In operation work distribution unit receives a sequence of packets from device driver via the front end and distributes the operations and data included in the packets to the one or more GPCs for processing in graphics processing pipeline . The sequence of packets includes state bundles that configure the operation of PPU as well as work packets that have microcode and pointers to graphics primitives that are processed by PPU .

Work distribution unit bundles up to 32 vertices from a work packet into a batch for distribution to one of the GPCs of PPU . Work distribution unit also generates unique batch IDs and assigns them to each batch of vertices distributed to the GPCs . In one embodiment batch IDs are generated consecutively from a 13 bit wrapping counter and a 1 bit phase that is stored in the most significant bit of the 14 bit batch ID. Work distribution unit is responsible for ensuring that each batch ID assigned to a batch of vertices processed by PPU is unique with respect to the other batches of vertices currently being processed in the graphics pipeline. Once a batch of vertices has been processed the SSYNC unit sends a batch ID retirement message to the work distribution unit to indicate that a batch ID may be released and reused for a subsequent batch of vertices.

Work distribution unit sends work tokens and stream enable and stream disable state bundles to SSYNC unit via the communications interface . Each work token includes a batch ID that corresponds to a particular batch of vertices distributed by work distribution unit . Stream enable and stream disable bundles indicate to SSYNC unit the start and end of a stream output operation. A stream output operation includes writing the processed vertex attribute data of all work packets received by the work distribution unit between a stream enable state bundle and a stream disable state bundle to one or more stream output buffers defined by a graphics API.

For example if work distribution unit receives a sequence of packets in the following order W W W E W W W D W W W E W W W W D W W W where W depicts a work packet E depicts a stream enable bundle and D depicts a stream disable bundle the work packets between the first stream enable bundle and the first stream disable bundle as well as the work packets between the second stream enable bundle and the second stream disable bundle would be processed and written to one or more stream output buffers and by PPU .

SSYNC unit is configured to track all outstanding stream output operations using a FIFO stored in dedicated static random access memory SRAM internal to SSYNC unit . In alternative embodiments SSYNC unit may store FIFO in the parallel processing memory L2 cache or system memory . SSYNC unit creates an entry in FIFO for each stream output operation received from work distribution unit . A stream output operation entry stored in FIFO by SSYNC unit includes the batch ID assigned to the first work packet received after a stream enable state bundle and the batch ID assigned to the first work packet received after the immediately subsequent stream disable state bundle. Thus SSYNC unit may determine when a stream output operation begins and ends using the batch IDs included in the stream output operation entry.

Ideally a graphics API would like to specify that stream output of vertex attribute data should be written to one or more stream output buffers in the same order that the vertices associated with the vertex attribute data are received by PPU from the device driver . This ensures that the device driver may correctly map the vertices passed as input to PPU to the vertex attribute data written as output in the stream output buffers and . SSYNC unit is advantageously configured to synchronize the various distributed stream output units of PPU such that the stream output buffers and are filled in a serialized manner to comply with this type of API requirement.

In one embodiment stream output buffers and are stored in a frame buffer in parallel processing memory . In alternative embodiments stream output buffers and may be stored in system memory . SSYNC unit maintains starting stream output buffer offsets SSOBO for each of the four stream output buffers and . From one stream output operation to the next vertex attribute data is appended to the stream output buffers and at the SSOBOs maintained by SSYNC unit . SSYNC unit increments the SSOBOs by the amount of vertex attribute data written to each stream output buffer and . SSYNC unit may also adjust the SSOBOs in response to an offset state bundle received from the work distribution unit between stream output operations. The offset state bundle includes a new SSOBO for each of the four stream output buffers and .

A messaging protocol may be implemented between SSYNC unit and the various distributed stream output units of PPU . In one embodiment SSYNC unit stores messages received from the various stream output units in a message table stored in dedicated SRAM internal to SSYNC unit . In alternative embodiments message table may be stored in the parallel processing memory L2 cache or system memory . Because stream output units send messages serially i.e. each stream output unit only sends one message at a time message table is sized to hold the same number of messages as there are stream output units in PPU . SSYNC unit may be configured to set an outstanding message flag bit when there are outstanding messages in the message table .

As discussed above SSYNC unit synchronizes SO unit with the one or more other stream output units in PPU to fill the stream output buffers and in a serialized fashion. In order to synchronize the various stream output units in PPU a messaging protocol is implemented between the different units of PPU . SSYNC unit communicates with SO unit over the crossbar unit .

When MPC unit schedules a batch of vertices for processing on SM or PE and stream output is enabled i.e. the batch ID associated with the batch of vertices is part of an outstanding stream output operation MPC unit sends a batch ID packet to SO unit . The batch ID packet includes the batch ID associated with the batch of vertices scheduled on the SM or PE . When SO unit receives the batch ID packet from MPC unit SO unit sends a first request message described below in conjunction with to SSYNC unit .

In response to receiving the first request message and if SSYNC unit is not currently processing a stream output operation SSYNC unit fetches the next stream output operation entry from FIFO . SSYNC unit sets the current batch ID to the first batch ID associated with the stream output operation entry fetched from FIFO . SSYNC unit determines whether the current batch ID is equal to the batch ID included in the first request message . If SSYNC unit determines that the current batch ID matches the batch ID in the first request message then SSYNC unit sends a response message described below in conjunction with to SO unit . Response message includes the SSOBO for each of the four stream output buffers and that indicates to SO unit where to write the processed vertex attribute data for the batch of vertices associated with the batch ID included in the first request message .

If SSYNC unit determines that the current batch ID does not match the batch ID included in the first request message then SSYNC unit waits to send the response message to SO unit until the current batch ID matches the batch ID included in the first request message . As the other stream output units in PPU write vertex attribute data for batches of vertices associated with the current batch ID to the stream output buffers and SSYNC unit increments the current batch ID such that when all prior issued batches of vertices have been written the current batch ID matches the batch ID included in the first request message . If SSYNC unit determines that the current batch ID does not match the batch ID included in the first request message then SSYNC may be configured to store the first request message in message table and set an outstanding message flag bit. If the outstanding message flag bit is set every time SSYNC unit increments the current batch ID SSYNC unit compares the current batch ID to the batch IDs included in all messages stored in message table to determine whether one of the various SO units of PPU is currently waiting to write vertex attribute data associated with the current batch ID to the stream output buffers and .

When SM or PE has finished processing the batch of vertices MPC sends a batch end packet to SO unit . SO unit computes how much data SO unit needs to write to each of the four stream output buffers by looking at the amount of vertex attribute data written to the L1 cache . SO unit then sends SSYNC unit a second request message described below in conjunction with that includes the number of bytes SO unit needs to write to each of the four stream output buffers and . SO unit may then fill the stream output buffers and with the processed vertex attribute data. It will be appreciated that the order of the response message and the second request message may be reversed such that SSYNC unit receives both the first request message and second request message from SO unit before SSYNC unit sends the response message to SO unit .

After SSYNC unit receives the second request message from SO unit SSYNC unit increases the SSOBO for each of the four stream output buffers and by the number of bytes needed that is included in the second request message . SSYNC unit then increments the current batch ID and waits for a new first request message that includes the current batch ID.

In one embodiment graphics processing pipeline includes shader programs such as a tessellation shader or a geometry shader that emit one or more vertices for each vertex received by the shader programs as input. In such cases graphics processing pipeline may be configured to split a batch of vertices associated with a unique batch ID into two or more batches of vertices associated with that same batch ID. In order to maintain ordered stream output when a batch of vertices associated with a unique batch ID is split into two or more batches of vertices graphics processing pipeline may be configured to associate the original batch ID as well as a unique task number and a last task bit with each of the two or more batches of vertices generated by the shader program. The task number is set to zero 0 for the first batch of vertices generated from the original batch of vertices. For each additional batch of vertices generated from the original batch of vertices the task number is incremented by one. The last task bit is set for the last batch of vertices generated from the original batch of vertices.

When a shader program generates multiple batches of vertices associated with the same batch ID SSYNC unit may be configured to ensure that batches associated with the same batch ID are also processed in order according to the task number. Certain operational aspects of SSYNC unit and SO unit described above are adjusted to incorporate functionality the enables SSYNC unit to synchronize stream output of multiple batches of vertices associated with the same batch ID. For example SSYNC unit checks the current batch ID and current task number of the outstanding stream output operation against the batch ID and task number included in the first request message . When the current batch ID is incremented by SSYNC unit the current task number is also set to zero 0 . The first request message includes the batch ID the task number and the last task bit associated with the batch of vertices waiting to be output by SO unit . SSYNC unit then compares both the current batch ID and current task number to the batch ID and task number included in the first request message .

In addition SSYNC unit only increments the current batch ID if all batches of vertices associated with the current batch ID have been written to stream output. In response to receiving the second request message and after increasing the SSOBO for each of the four stream output buffers and SSYNC unit adjusts the current batch ID or current task number accordingly based on whether the last task bit is set. If the last task bit is not set indicating that there are additional batches of vertices associated with the current batch ID that have not been written to stream output SSYNC unit increments the current task number after receiving the second request message . In contrast if the last task bit is set indicating that all batches of vertices associated with the current batch ID have been written to stream output SSYNC unit increments the current batch ID and resets the current task number to zero 0 . In this manner SSYNC unit processes each batch of vertices associated with the same batch ID in order according to the task number before moving on to the next batch ID included in the stream output operation.

As shown in the first request message is 25 bits long and includes the batch ID task number and last task bit . The batch ID is a 14 bit value that holds the batch ID associated with the batch of vertices waiting to be written by SO unit to the stream output buffers and . The task number is a 10 bit value that holds the task number associated with the batch of vertices waiting to be written by the SO unit . The last task bit is a 1 bit value that indicates whether the batch of vertices waiting to be written by the SO unit is the last batch of vertices associated with the batch ID .

In alternative embodiments where the graphics pipeline is not configured to split batches of vertices into two or more batches of vertices the first request message may include the task number and last task bit as dummy bits always set to 0. In yet other embodiments the first request message may only include the 14 bit batch ID.

As shown in the response message is 128 bits long. SSOBOs and are the byte offsets into the four stream output buffers and at which SO unit may start writing processed vertex attribute data. As shown in the second request message is 128 bits long. Stream buffer bytes needed SBBN and are the number of bytes that SO unit needs to write to each of the four stream output buffers and .

As shown method begins at step where device driver sends a sequence of packets to PPU for processing. In one embodiment device driver writes packets to a push buffer not shown stored in system memory that may be read by PPU . I O unit host interface and front end fetch the packets from the push buffer and send the packets to the work distribution unit . At step work distribution unit assigns a unique batch ID to each batch of up to 32 vertices received from device driver . At step work distribution unit distributes the batches of vertices for processing by the one or more GPCs in PPU . In one embodiment each GPC in PPU may be configured to implement one functional unit of graphics pipeline . In alternative embodiments a GPC may be configured to implement more than one functional unit of graphics pipeline .

At step work distribution unit sends state bundles and work tokens associated with the work packets to SSYNC unit . SSYNC unit is responsible for tracking all outstanding stream output operations and ensuring that the distributed SO units write processed vertex attribute data to the stream output buffers and in the correct order. At step SSYNC unit stores all outstanding stream output operations in a FIFO . For each pair of stream enable and stream disable state bundles received by SSYNC unit SSYNC unit pushes a stream output operation entry to FIFO that includes the batch ID associated with the first work token received after the stream enable bundle and the batch ID associated with the first work token received after the stream disable bundle.

At step SSYNC unit pops the next outstanding stream output operation entry from FIFO . SSYNC unit then waits to receive a first request message from one of the SO units that includes a batch ID that matches the first batch ID from the stream output operation entry.

It will be appreciated that method enables a single SSYNC unit to track the order of a plurality of batches of vertices distributed to different SO units in PPU . A protocol for synchronizing distributed stream output operations using the batch IDs associated with the plurality of batches of vertices is described below in conjunction with .

As shown the method begins at step where pipeline manager of GPC receives a batch of vertices for processing from the work distribution unit or work distribution crossbar . The batch of vertices is associated with a batch ID assigned by work distribution unit . In addition in the case where the original batch of vertices has been split into multiple batches of vertices by a shader program the batch of vertices may also be associated with a task number and a last task bit. At step pipeline manager distributes the batch of vertices to one of the SPMs of GPC . SPM implements one or more of the functional units in graphics processing pipeline . SPM is configured with SM and primitive engine that includes a distributed SO unit . At step MPC unit schedules the batch of vertices for processing on SM or PE . At step MPC unit sends a batch ID packet to SO unit in PE .

At step when SO unit receives a batch ID packet from MPC unit and stream output is enabled SO unit sends a first request message to SSYNC unit . The first request message communicates to SSYNC unit that the batch of vertices associated with the batch ID included in the first request message is ready to be written to the stream output buffers and by SO unit . At step SSYNC unit determines whether the current batch ID matches the batch ID included in the first request message . If the current batch ID does not match the batch ID included in the first request message then the method proceeds to step where SSYNC unit stores the first request message in message table and sets an outstanding message flag bit. Then SSYNC unit waits until the current batch ID matches the batch ID included in the first request message . As SSYNC unit receives other first request messages from other SO units that include a batch ID that matches the current batch ID SSYNC unit allocates space in the stream output buffers and for the other SO units to perform stream output operations and increments the current batch ID. When all prior issued batches of vertices have requested space in the stream output buffers and from the SSYNC unit such that the current batch ID matches the batch ID included in the first request message stored in message table method proceeds to step .

At step SSYNC unit determines whether the current task number matches the task number included in the first request message . If the current task number does not match the task number included in the first request message then the method proceeds to step described above. SSYNC unit then waits until the current batch ID and current task number match the batch ID and task number included in the first request message . If at step the current task number matches the task number included in the first request message then method proceeds to step . It will be appreciated that step may be skipped when graphics pipeline is not configured to split batches of vertices into multiple batches of vertices associated with the same batch ID. In such cases method may proceed directly to step if the current batch ID matches the batch ID included in the first request message .

At step SSYNC unit sends a response message to SO unit . The response message includes the SSOBOs for each of the four stream output buffers and . In this fashion SSYNC unit allocates memory in the stream output buffers and so that SO unit may write vertex attribute data to the stream output buffers and for the batch of vertices distributed to SO unit . At step MPC unit sends a batch end packet to SO unit that indicates that SM or PE is finished processing the batch of vertices. At step in response to receiving the batch end packet SO unit calculates the total number of bytes needed to write vertex attribute data for the current batch of vertices to the stream output buffers and . In one embodiment SO unit computes the total number of bytes written to the L1 cache by SM or PE for the batch of vertices to determine how many bytes need to be written to the stream output buffers and . In alternative embodiments SO unit may determine how many bytes need to be written to the stream output buffers and in any technically feasible manner such as by receiving a message from MPC unit of how many bytes were written to the L1 cache .

At step SO unit sends a second request message to SSYNC unit . The second request message includes the total number of bytes needed to be written to the stream output buffers and by SO unit . At step SSYNC unit increases the SSOBOs by the amounts indicated in the second request message . In this manner SSYNC unit allocates memory in the stream output buffers and for all vertex attribute data needed to be written by SO unit .

At step SSYNC unit determines whether the last task bit associated with the current batch of vertices distributed to SO unit is set. If the last task bit is not set then method proceeds to step where SSYNC unit increments the current task number and process terminates. If the last task bit is set then SSYNC unit resets the current task number to zero 0 and method proceeds to step . It will be appreciated that steps and may be skipped when graphics pipeline is not configured to split batches of vertices into multiple batches of vertices associated with the same batch ID. In such cases method may proceed directly to step .

At step SSYNC unit sends a batch ID retire message to work distribution unit . The batch ID retire message releases the batch ID to be reused by work distribution unit for subsequent batches of vertices distributed to graphics processing pipeline . At step SSYNC unit determines whether the current batch of vertices is the last batch of vertices in the current stream output operation. If the current batch of vertices is not the last batch of vertices in the current stream output operation then method proceeds to step where SSYNC unit increments the current batch ID resets the current task number to zero and method terminates.

Returning now to step if the current batch of vertices is the last batch of vertices in the current stream output operation then method proceeds to step where SSYNC unit pops the next outstanding stream output operation entry from FIFO and method terminates.

It will be appreciated that method describes the steps for synchronizing the stream output operation with respect to a single outstanding batch of vertices in one of the SPM units of GPC . The steps described in method may be repeated for each outstanding batch of vertices included in an outstanding stream output operation distributed within PPU by the work distribution unit .

In sum the technique used for distributed stream output disclosed above provides a more efficient way to perform stream output operations in a parallel processing system. More specifically a stream synchronization unit is provided that enables the parallel processing unit to track one or more batches of vertices being processed in a graphics processing pipeline. A plurality of stream output units is also provided where each stream output unit writes vertex attribute data to one or more stream output buffers for a portion of the batches of vertices. A messaging protocol is implemented between the stream synchronization unit and the plurality of stream output units that ensures that each of the stream output units writes vertex attribute data for the particular batch of vertices distributed to that particular stream output unit in the same order in the stream output buffers as the order in which the batch of vertices was received from a device driver by the parallel processing unit.

One advantage of the disclosed approach is that the distributed stream output units are able to fully saturate the available frame buffer bandwidth. Multiple distributed stream output units may write data to the frame buffer during the same clock cycle. Therefore even though each individual stream output unit may have a narrow bandwidth the total stream output bandwidth is scalable to match the available frame buffer bandwidth. A further advantage of the disclosed method is that each stream output unit may write data to the frame buffer in parallel without waiting for the frame buffer to be filled by all prior issued work bundles. Therefore the bottleneck created when using a single stream output unit for multiple parallel shader programs is reduced.

While the foregoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof and the scope thereof is determined by the claims that follow.

