---

title: Failover recovery in a distributed data store
abstract: Disclosed are various embodiments for failover recovery in a distributed data store. A computing device determines whether it is a master data store in a distributed data store. New data item updates are assigned the next transaction identifier in a gapless numbering scheme relative to the most durably persisted entry. New data item updates are also associated with a data store identifier that identifies the new master data store.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08301600&OS=08301600&RS=08301600
owner: Amazon Technologies, Inc.
number: 08301600
owner_city: Reno
owner_country: US
publication_date: 20101115
---
A data store such as for example a non relational database a relational database management system RDBMS or other data systems may be implemented as a distributed system. Distributed systems can offer improved reliability and availability better fault tolerance increased performance and easier expansion. Some distributed models employ single master replication where data written to a master data store is replicated to one or more secondary stores. Distributed data stores may experience difficulties if the master data store fails.

The present disclosure relates to failover recovery in a distributed data store. In one embodiment a distributed data store can employ a single master replication model that provides for a master data store and one or more slave data stores. The master data store can accept and evaluate any updates to data items stored in the distributed data store received from client systems and use a replication log to facilitate propagation of updates to data items to slave data stores. Upon receiving an update and propagating the update to a requisite number of slave data stores the master data store can then consider the update as successful durable and or committed to the distributed data store. To provide data durability or integrity from a client or user point of view any update to a data item acknowledged to the user as successful in a distributed data store according to embodiments of the disclosure should be able to survive the failure of the master data store. In such a scenario a slave data store in the distributed data store can be designated as the new master data store. To provide such failover capability to the distributed data store the new master data store previously a slave data store must be able to determine at least the last successful updates committed to the distributed data store and acknowledge as successful to a client in order to properly assume its role as the master.

With reference to shown is a networked environment according to various embodiments. The networked environment includes one or more computing devices . . . N in communication with one or more clients by way of a network . The network includes for example the Internet intranets extranets wide area networks WANs local area networks LANs wired networks wireless networks or other suitable networks etc. or any combination of two or more such networks.

Each of the computing devices . . . N may comprise for example a server computer or any other system providing computing capability. Alternatively a respective plurality of computing devices . . . N may be employed that are arranged for example in one or more server banks or computer banks or other arrangements. For example a plurality of computing devices . . . N together may comprise a cloud computing resource a grid computing resource and or any other distributed computing arrangement. Such computing devices . . . N may be located in a single installation or may be distributed among many different geographical locations. For purposes of convenience the computing device is referred to herein in the singular. Even though the computing device is referred to in the singular it is understood that a plurality of computing devices . . . N may be employed in the various arrangements as described above.

Various applications and or other functionality may be executed in the computing device according to various embodiments. Also various data is stored in a respective data store . . . N that is accessible to the computing device . The respective data store . . . N may be representative of a plurality of data stores as can be appreciated. The data stored in the data store for example is associated with the operation of the various applications and or functional entities described below. In a distributed data store model as described herein any of the depicted computing devices can be designated as a master data store and likewise any of the data stores can be designated as a slave data store. Accordingly these computing devices can be disparately located to provide for greater stability of a distributed data store so that a catastrophic event occurring in one location that may affect a subset of the computing devices in the distributed data store does not jeopardize the system as a whole.

The components executed on the computing device for example include a data store management application and other applications services processes systems engines or functionality not discussed in detail herein. When a computing device is designated as a master data store for a distributed data store implemented by computing devices . . . N the data store management application is executed to manage the data store and to facilitate replication of data to one or more data stores accessible to computing devices that are designated as slave data stores. In a master data store the data store management application may obtain data item update requests from the client and respond with data item update confirmations . The data store management application may also generate and send data item replication requests to the computing devices and obtain data item replication confirmations from the computing devices .

In a computing device designated as a slave data store the data store management application can receive data item replication requests from a master data store and cause the corresponding data item to be stored in the data store managed by the slave data store. In other words the data store management application when a computing device is designated as a slave data store is configured to obtain data item replication requests from the master data store. In response to the data item replication requests the data store management application executed in a slave data store is configured to commit data item updates to its respective data store and then generate and send data item replication confirmations to the master data store.

The data stored in a data store includes for example replicated data a log and potentially other data. The replicated data includes any data maintained in the data store that can be durably persisted across a distributed data store implemented by the various computing devices in the system. The log includes a plurality of log entries that correspond to update transactions for various data items stored or to be stored in the replicated data . It should also be appreciated that log entries can correspond to new data items submitted by a client that are created in the data store .

In this sense each log entry can describe an intent to make a change to a data item in the distributed data store. As a non limiting example a log entry may describe a change of inserting a data item with a specified list of attribute values. As another non limiting example a log entry may describe a change of modifying one or more attribute values of an existing data item. As will be described in further detail herein each log entry may be associated with a data store identifier from which a data store can deduce the identity of the master data store when the log entry was generated. Each log entry can also be associated with a transaction identifier to maintain ordering of update transactions regarding a data item. The transaction identifier may be defined for example by a sequence number that is one of a monotonically increasing sequence of integer values. The transaction identifier can also be defined for example as a gapless sequence identifier in a gapless sequence numbering scheme. The generating of data store identifiers as well as transaction identifiers and their use in facilitating failover of computing devices acting as a master data store in a distributed data store is described in further detail herein.

The client is representative of a plurality of client devices that may be coupled to the network . The client may comprise for example a processor based system such as a computer system. Such a computer system may be embodied in the form of a desktop computer a laptop computer a server computer a cloud computing resource a grid computing resource or other devices or systems with like capability. The client may be configured to execute various applications such as a data store client application and or other applications. The data store client application may be executed in a client to facilitate interaction with the data store management application . In one embodiment the data store client application may be configured for example to access and render network pages such as web pages or other network content served up by the computing device and or other servers for the purpose of interfacing with the data store management application .

In various embodiments the data store client application may comprise a thin client application a thick client application or another type of client application. Some embodiments may include a graphical user interface and or a command line interface. In some embodiments the client can be configured to interact with a distributed data store provided by the computing devices . . . N via an application programming interface API provided by the data store management application executed in a master data store or slave data store.

A data item update request is generated by a data store client application . Although the data store client application is described as executed in a client it is understood that the client may correspond to a server computer that processes business logic generates network pages and or performs other tasks. Thus although a user may generate a data item update request through a user interface a data item update request may also be generated automatically by business logic applications workflow engines network page generation applications and or other applications.

The data store client application may correspond to a portion of another application such as for example a module a library etc. in various embodiments. The data item update request may be sent over the network to the data store management application using hypertext transfer protocol HTTP simple object access protocol SOAP remote procedure call RPC remote method invocation RMI and or other protocols. In various embodiments the data item update request may describe updates to data items by using for example structured query language SQL extensible markup language XML JavaScript object notation JSON yet another markup language YAML and or other formats.

Next a general description of the operation of the various components of the networked environment is provided. As described above in a distributed data store according to embodiments of this disclosure any of the computing devices in such a distributed system can be designated as a master data store with the remaining computing devices being designated as slave data stores. One objective of such a distributed system is data redundancy as data items stored in the data store can be mirrored across one or more of the slave data stores in the system. Additionally embodiments of the present disclosure can provide failover capability in the event of a failure or other malfunction of a computing device designated as a master data store.

In a distributed data store employing single master replication updates are directed to and processed by a designated master data store that is in communication with at least one slave data store. The computing device that is designated as a master data store can be elected by consensus of the various computing devices . . . N in the distributed system. In some embodiments the data store management application . . . N executed in the various computing devices can be configured to collectively employ a Paxos election scheme in order to determine the identity of the computing device that will serve as the master data store. The election of a master data store among the various computing devices in the distributed data store can also be determined by other methods of reaching consensus in a distributed system of peers as can be appreciated. During election of the master data store in a distributed data store a data store identifier that identifies the master data store can also be generated by the data store management application executed in the elected master data store. In one embodiment the data store identifier can be based at least upon a distributed logical clock that identifies the relative order of events occurring within the distributed data store. Such a logical clock can be employed in the framework of a Paxos election of a master data store and can in one embodiment simply be adopted as the data store identifier identifying the master data store. In another embodiment the Paxos transition associated with the election of the master data store can be adopted

Additionally when applying changes or updates to a data item in a distributed data store that can employ a single master replication scheme and that is implemented by the computing devices the data item update can be presented to a computing device designated as the master data store. Accordingly the master data store can replicate changes associated with the update to at least one slave data store. The changes associated with an update transaction are propagated to the slave data stores by way of log entries that can be embedded within data item replication requests generated by the master data store and transmitted to the slave data stores. The data store management application executed in a slave data store is configured to commit the changes described by the log entries embodied in the data item replication requests from a master slave data store to the respective data store in an order according to the transaction identifiers associated with the log entries. The log entries can also be associated with a data store identifier and both the transaction identifier and data store identifier associated with each log entry is employed to facilitate failover recovery as will be described below.

In the distributed data store the replicated data in a slave data store is configured to mirror the replicated data in the master data store. The data store management application may also be configured to save the log entries to the log to facilitate rollback of committed updates if necessary. When one or more of the slave data stores respond to the data store management application executed in the master data store confirming that a change has been committed in their respective data stores the data store management application executed in the master data store can determine that the change has been made durably persistent in the distributed data store. In some embodiments the master data store can determine that a change has been made durably persistent when a predetermined number of slave data stores or a requisite quorum of slave data stores have confirmed receipt of an update to a data item in the distributed data store at which point the master data store can issue a command to the slaves that the update be committed. Accordingly the master data store can then provide a data item update confirmation to a data store client application . If an appropriate quorum has not been reached the data store management application associated with a master data store can respond to a data store client application with an error.

Reference is now made to which illustrate one example of failover in a distributed data store and how the data store management application executed in the various computing devices in the networked environment to maintain synchronization of replicated data upon election of a new master data store. illustrates a master data store designated by computing device that can log data item updates in the log associated with the data store . In the depicted non limiting example the each log entry can include data regarding changes to be made to data in the data store not shown . Additionally each log entry can be associated with a tuple that includes a data store identifier and a transaction identifier that can uniquely identify the sequence of data item updates as described above. In the depicted example the data store identifier can be based upon a logical clock used to identify the master data store in a Paxos election scheme. Accordingly the data store identifier associated with log entries can remain constant until a new master data store is elected e.g. in a failover scenario .

In the depicted example the log contains entries corresponding to data item updates that the data store management application of the master data store has identified as being replicated among a predetermined number or a quorum of slave data stores. Therefore these log entries like the data item updates are replicated among at least a predetermined number of slave data stores in the distributed data store. Log entry is associated with a data item update that the master data store has attempted to replicate among a quorum of slave data stores. However log entry and the replication attempt has not been acknowledged by a quorum of slave data stores in the distributed data store. Accordingly the master data store does not issue a command to the slave data stores to commit the data item update associated with log entry . If before acknowledgement from a quorum of slave data stores the master data store fails a client application interacting with the master data store will not receive confirmation that the data item update was successful. Additionally if the master data store fails before the log entry can be removed from the log and or the associated data item update rolled back the log entry may remain in the log when the master data store rejoins the distributed data store as a slave data store.

Accordingly reference is now made to which continues the example of . In assume for the purposes of illustration that the previous master data store represented by computing device has failed in some way. A failure can be represented by a hardware failure of some kind an abnormal termination of the data store management application and or other failure as can be appreciated. Therefore the remaining computing devices executing an instance of the data store management application can elect a new master data store by employing a consensus algorithm as described above. In the depicted example the computing device is elected as the new master data store.

To accomplish failover upon failure of the previous master data store the new master data store can determine a most recent log entry by identifying such an entry in its own log. In some embodiments the new master data store can consult a quorum of slave data stores in the distributed data store and determine the most recent entry committed to a quorum of respective logs in the slave data stores by the previous master data store. As one non limiting example the new master data store can identify a log entry having the highest transaction identifier in a quorum of slave data stores. Such a determination identifies the most recent log entry that the previous master data store could have considered committed to the distributed data store.

In other words the new master data store determines the end of log. The end of log includes an entry with a data store identifier identifying the previous master as well as a transaction identifier identifying the last update that was committed to the distributed data store by the previous master data store. Accordingly when the data store management application in the new master data store receives a new data item update from a data store client application it can generate a new data store identifier that can be employed for the new data item updates as well as future updates for which it is the master data store. The new data item update can be associated with the data store identifier as well as a transaction identifier representing the next in the sequence of a gapless sequence numbering scheme relative to the transaction identifier of the most recent entry in its log . As described above the data store management application can then replicate the data item update and corresponding log entry to at least a quorum of the slave data stores in the distributed data store.

Reference is now made to which continues the example of . In the example of the computing device which was previously a master data store has rejoined the distributed data store as a slave data store. As described above with reference to log entry was not durably persisted in a sufficient quorum of data stores in the distributed data stores prior to failure of the computing device in its capacity as the previous master data store. Accordingly the now slave data store represented by computing device can receive data item updates as well as corresponding log entries from the new master data store represented by computing device . As shown in one of the data item updates received from new master data store is associated with a transaction identifier that conflicts with the transaction identifier corresponding to log entry .

In one embodiment because the generation of a data store identifier can be based upon an always increasing number relative to the data store identifier associated with a previous master a slave data store in a scenario such as illustrated in can determine whether such a conflicting entry was over written by a newly elected master data store elsewhere in the distributed data store. This determination can be made because the data store identifier associated with the log entry will be greater than the data store identifier associated with a log entry such as the one represented by log entry . Accordingly in the depicted example of the slave data store computing device can determine that the data item update associated with log entry was not durably persisted in the distributed data store and roll back the transaction associated with the log entry in its data store

Referring next to shown is a flowchart that provides one example of the operation of a portion of the data store management application according to various embodiments. It is understood that the flowchart of provides merely an example of the many different types of functional arrangements that may be employed to implement the operation of the portion of the data store management application as described herein. As an alternative the flowchart of may be viewed as depicting an example of steps of a method implemented in the computing device according to one or more embodiments.

Beginning with box the data store management application determines whether the computing device in which it is executed has been designated as the master data store. As described above upon failure of a master data store in a distributed data store the remaining slave data stores can determine by employing a consensus algorithm a computing device formerly acting as a slave data store that should be designated as the new master data store. Next the data store management application can identify the tail or end of log that contains at least the most recent entry that could have been considered committed by the previous master data store in box . Next in box the data store management application can generate a new data store identifier which can be used to identify the identity of the master data store among the computing devices in the distributed data store. As described above the data store identifier can be based upon a logical clock employed to facilitate election of the new master data store.

In box the data store management application can receive a new update to a data item in the distributed data store. Accordingly in box the data store management application can generate a new log entry associated with the new update. The new log entry can be associated with the new data store identifier as well as a transaction identifier that represents the next entry in a gapless numbering scheme relative to the most recent durably persisted log entry. The log entry and data item update can then be replicated among the slave data stores in the distributed data store.

With reference to shown is a schematic block diagram of the computing device according to an embodiment of the present disclosure. The computing device includes at least one processor circuit for example having a processor and a memory both of which are coupled to a local interface . To this end the computing device may comprise for example at least one server computer or like device. The local interface may comprise for example a data bus with an accompanying address control bus or other bus structure as can be appreciated.

Stored in the memory are both data and several components that are executable by the processor . In particular stored in the memory and executable by the processor is the data store management application and potentially other applications. Also stored in the memory is the primary data store and other data. In addition an operating system may be stored in the memory and executable by the processor .

It is understood that there may be other applications that are stored in the memory and are executable by the processors as can be appreciated. Where any component discussed herein is implemented in the form of software any one of a number of programming languages may be employed such as for example C C C Objective C Java JavaScript Perl PHP Visual Basic Python Ruby Delphi Flash or other programming languages.

A number of software components are stored in the memory and are executable by the processor . In this respect the term executable means a program file that is in a form that can ultimately be run by the processor . Examples of executable programs may be for example a compiled program that can be translated into machine code in a format that can be loaded into a random access portion of the memory and run by the processor source code that may be expressed in proper format such as object code that is capable of being loaded into a random access portion of the memory and executed by the processor or source code that may be interpreted by another executable program to generate instructions in a random access portion of the memory to be executed by the processor etc. An executable program may be stored in any portion or component of the memory including for example random access memory RAM read only memory ROM hard drive solid state drive USB flash drive memory card optical disc such as compact disc CD or digital versatile disc DVD floppy disk magnetic tape or other memory components.

The memory is defined herein as including both volatile and nonvolatile memory and data storage components. Volatile components are those that do not retain data values upon loss of power. Nonvolatile components are those that retain data upon a loss of power. Thus the memory may comprise for example random access memory RAM read only memory ROM hard disk drives solid state drives USB flash drives memory cards accessed via a memory card reader floppy disks accessed via an associated floppy disk drive optical discs accessed via an optical disc drive magnetic tapes accessed via an appropriate tape drive and or other memory components or a combination of any two or more of these memory components. In addition the RAM may comprise for example static random access memory SRAM dynamic random access memory DRAM or magnetic random access memory MRAM and other such devices. The ROM may comprise for example a programmable read only memory PROM an erasable programmable read only memory EPROM an electrically erasable programmable read only memory EEPROM or other like memory device.

Also the processor may represent multiple processors and the memory may represent multiple memories that operate in parallel processing circuits respectively. In such a case the local interface may be an appropriate network that facilitates communication between any two of the multiple processors between any processor and any of the memories or between any two of the memories etc. The local interface may comprise additional systems designed to coordinate this communication including for example performing load balancing. The processor may be of electrical or of some other available construction.

Although the data store management application and other various systems described herein may be embodied in software or code executed by general purpose hardware as discussed above as an alternative the same may also be embodied in dedicated hardware or a combination of software general purpose hardware and dedicated hardware. If embodied in dedicated hardware each can be implemented as a circuit or state machine that employs any one of or a combination of a number of technologies. These technologies may include but are not limited to discrete logic circuits having logic gates for implementing various logic functions upon an application of one or more data signals application specific integrated circuits having appropriate logic gates or other components etc. Such technologies are generally well known by those skilled in the art and consequently are not described in detail herein.

The flowchart of shows the functionality and operation of an implementation of portions of the data store management application. If embodied in software each block may represent a module segment or portion of code that comprises program instructions to implement the specified logical function s . The program instructions may be embodied in the form of source code that comprises human readable statements written in a programming language or machine code that comprises numerical instructions recognizable by a suitable execution system such as a processor in a computer system or other system. The machine code may be converted from the source code etc. If embodied in hardware each block may represent a circuit or a number of interconnected circuits to implement the specified logical function s .

Although the flowchart of shows a specific order of execution it is understood that the order of execution may differ from that which is depicted. For example the order of execution of two or more blocks may be scrambled relative to the order shown. Also two or more blocks shown in succession in may be executed concurrently or with partial concurrence. Further in some embodiments one or more of the blocks shown in may be skipped or omitted. In addition any number of counters state variables warning semaphores or messages might be added to the logical flow described herein for purposes of enhanced utility accounting performance measurement or providing troubleshooting aids etc. It is understood that all such variations are within the scope of the present disclosure.

Also any logic or application described herein including the data store management application that comprises software or code can be embodied in any non transitory computer readable medium for use by or in connection with an instruction execution system such as for example a processor in a computer system or other system. In this sense the logic may comprise for example statements including instructions and declarations that can be fetched from the computer readable medium and executed by the instruction execution system. In the context of the present disclosure a computer readable medium can be any medium that can contain store or maintain the logic or application described herein for use by or in connection with the instruction execution system. The computer readable medium can comprise any one of many physical media such as for example magnetic optical or semiconductor media. More specific examples of a suitable computer readable medium would include but are not limited to magnetic tapes magnetic floppy diskettes magnetic hard drives memory cards solid state drives USB flash drives or optical discs. Also the computer readable medium may be a random access memory RAM including for example static random access memory SRAM and dynamic random access memory DRAM or magnetic random access memory MRAM . In addition the computer readable medium may be a read only memory ROM a programmable read only memory PROM an erasable programmable read only memory EPROM an electrically erasable programmable read only memory EEPROM or other type of memory device.

It should be emphasized that the above described embodiments of the present disclosure are merely possible examples of implementations set forth for a clear understanding of the principles of the disclosure. Many variations and modifications may be made to the above described embodiment s without departing substantially from the spirit and principles of the disclosure. All such modifications and variations are intended to be included herein within the scope of this disclosure and protected by the following claims.

