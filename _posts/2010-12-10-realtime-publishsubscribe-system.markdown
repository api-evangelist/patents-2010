---

title: Real-time publish-subscribe system
abstract: A real-time protocol for real-time network programming applications is disclosed. The protocol is executable on a computer network having a plurality of nodes that include applications, a network stack, an operating system, and middleware capable of executing real-time operations. The protocol can use group objects to model physical and logical devices connected to the network wherein each group object comprises at least one variable. Changes in these variables are encapsulated in variable change messages which are propagated in the network using communication objects. Also described is a real-time messaging format useful for implementing the protocol.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08150988&OS=08150988&RS=08150988
owner: Real-Time Innovations, Inc.
number: 08150988
owner_city: Sunnyvale
owner_country: US
publication_date: 20101210
---
This application is a continuation of and claims priority under 35 U.S.C. 120 to U.S. patent application Ser. No. 10 118 470 filed Apr. 5 2002 now U.S. Pat. No. 7 882 253 issued on Feb. 1 2011 and entitled Real Time Publish Subscribe System which claims priority under 35 U.S.C. 119 e from U.S. Provisional Patent Application No. 60 282 321 filed Apr. 5 2001 now abandoned which are incorporated by reference herein in their entirety and for all purposes.

The invention described herein relates to network programming. In particular the present invention pertains to the implementation of a real time publish subscribe RTPS protocol that can be used in real time network programming applications.

A real time system such as a RTPS system is defined as a system which operates within finite time boundaries. By finite time boundaries what is meant is that responses to system queries must occur within some predictable time boundary or response time. For example within two seconds of the query. Response within the predictable time boundary is the overriding parameter. So the system is not real time in the sense that transfer of information is instantaneous but rather that the transfer of information is in accord with some set of time sensitive parameters. Thus a real time system is not purely asynchronous nor is it strictly instantaneous. The time boundary conditions are flexible depending on the system. For example a radar tracking system for an anti aircraft missile requires extremely fast response time. Whereas a mass production assembly line in a factory may require a much reduced response time on the order of tens of minutes. Both are considered real time under the definition provided here. Examples of real time systems can include without limitation command control systems sensor actuator systems network management systems distributed real time simulations or games and the like.

In the field of network applications high level protocols such as DCOM FTP DHCP DCE RTP HTTP and CORBA have been used for constructing commercial applications. Each of these protocols fills a specific niche and are well designed for their specific purposes. However such protocols are found to be lacking when applied to distributing data in real time applications. Such protocols do not provide the right level of abstraction and for the most part lack certain key functionalities necessary to create and or implement real time applications. In particular such protocols do not include functionalities for achieving real time attributes such as predictable communication time aware decisions and notifications operation over unreliable transports use of multicast transparent hot swap substitution or time and resource aware quality of service QoS controls.

The publish subscribe communications model also referred to herein as publish subscribe is a new model of network programming whereby a message sender does not explicitly specify the receiver. Instead the sender publishes data with a topic while receivers who are subscribing to the topic will receive the data and possibly an asynchronous notification that the data has changed. This model is quite different from the traditional request response programming wherein an application program explicitly indicates the service it wants and synchronously waits for a return from a blocked I O call. The publish subscribe model has some distinct advantages over typical server client networks. For example there are no special server nodes. Thus any node can send or receive information streams from any other node. As such publish subscribe systems reduce the amount of system overhead required for the operation of a networked system.

Publish subscribe communications reduce network loading and simplify programming for one to many network communications. It reduces network loading because there is no need for request messages and it eliminates for polling. Finally publish subscribe also lets a developer make use of multicast technology where one message can be sent to many receivers. Importantly publish subscribe simplifies network programming because publishers do not need to know where the subscribers are on the network and subscribers do not need to know where the publishers are. Publishers simply declare a publication topic and start sending messages. Each subscriber simply declares an interest in that topic. The publish subscribe software takes care of all the packet addressing data marshalling serializing de marshalling and packet sending.

The publish subscribe model is a natural fit for the complex communications required in distributed real time systems. However there are limitations to ordinary publish subscribe systems. Ordinary publish subscribe systems do not provide the time and resource predictability fault tolerance robustness and data delivery control that real time systems require.

Therefore an improved communication protocol is needed for facilitating real time communications in real time computer networks and for implementing real time network programming applications.

In accordance with the principles of the present invention one embodiment of the present invention is a real time protocol executable on a computer network having a plurality of nodes wherein the nodes can include applications a network stack an operating system and middleware capable of executing real time operations. The protocol can use group objects to model physical and logical devices connected to the network wherein each group object comprises at least one variable. Changes in these variables are encapsulated in variable change messages which are propagated in the network using communication objects. The variables can be state variables which encapsulate the state of the variables and or objects the represent. Also the variables can include sub variables which represent portions or aspects of the variable.

Another embodiment comprises a real time computer architecture that includes write objects read objects and a message interpreter. Also the architecture includes variable reference tables which write objects use to track variable information and remote reader reference tables for each reader so that the writer can determine a message status for each reader. In this architecture the write object writes variable change messages to associated read objects and a message interpreter receives and interprets the variable change messages so that they can be read by the read object.

In another embodiment the invention includes a modular message format having a RTPS message header of a uniform length. The format also includes a variable number of RTPS submessages where each RTPS submessage includes a RTPS submessage header of uniform length and a RTPS submessage payload comprised of a variable number of RTPS submessage elements. Also the message format provides a mechanism to extend the number and types of submessages in such way that the applications using this extended submessages remain backwards compatible with applications that were not aware of these submessages. Also the format provides a way to describe variable properties encapsulated within submessages such that new properties can be added in the future in such way that the applications using this additional properties remain backwards compatible with applications that were not aware of these properties.

The invention includes a method embodiment for writing variable change message from a writer to a registered reader. The method comprises determining if there is a new reader and where there is no new reader determining if there has been a change to a variable saving the changes and modifying the sequence number. Where there is a new reader a remote reader process is activated to update the reader. Also the method provides a way to propagate changes in the order they occurred and to indicate that a set of variable changes should be interpreted by the receiving application in a coherent indivisible or atomic manner i.e. either all the changes are available to the receiving application or no changes are available to the receiving application .

The invention also includes a method embodiment for a registered reader to read variable change messages sent by a writer using the steps of determining if there is a writer for which the reader is registered to receive variable change messages and where there is a suitable writer activating a remote writer process to update the registered reader. Also a method for determining which changes are relevant to a particular remote application coalesce combine changes in a way that the overall meaning is preserved and propagate only the changes required to reconstruct a consistent view at the receiving end.

These and other aspects and advantages of the invention will become apparent from the following detailed description and accompanying drawings which illustrate by way of example the principles of the invention.

Reference numerals refer to the same or equivalent parts of the present invention throughout the several figures of the drawings.

The present invention has been particularly shown and described with respect to certain preferred embodiments and specific features thereof. The embodiments set forth herein below are to be taken as illustrative rather than limiting. It should be readily apparent to those of ordinary skill in the art that various changes and modifications in form and detail may be made without departing from the spirit and scope of the invention.

The protocol of the present invention is a real time publish subscribe RTPS communications protocol that can be put to advantageous use in real time applications. The RTPS protocol is more efficient than client server protocols e.g. DCOM or CORBA in both latency and bandwidth and particularly for periodic data exchange. By using subscriptions occasional low bandwidth subscription requests replace the numerous high bandwidth client requests thereby substantially reducing the overhead required in a RTPS system. Latency is also reduced as the outgoing request message time is eliminated. Additionally a RTPS protocol is capable of supporting unicast and multicast messaging thereby supporting many to many connectivity in group subscriptions. Thus the RTPS protocol is ideal for building reconfigurable robust applications that can be scaled to many participating nodes. The RTPS protocol can also take advantage of multicast technology to efficiently send real time data to many subscribers. The present RTPS protocol can support high performance real time communication over standard IP networks. The advantage to this type of publication is that users need not specify computer addresses routes port numbers or any of the other identifying information generally required with message based communications because this information has already been sent and is cached. The publication includes the data format s of updates for that publication. Communications occur in three simple steps declaration of intent to publish by an information producer declaration of interest in the subject by an information consumer and delivery of information produced. Each time an information producer publishes a new sample the communication real time RTPS middleware operating on the network automatically routes the data from the information producer to all interested information consumers.

RTPS communications are event driven. This means that whenever new data is produced subscribers are notified and provided with the new data. The subscribers may be notified asynchronously i.e. interrupted or synchronously by polling . Such data transfer is initiated by the publisher.

Many other arrangements and combinations of busses hubs switches and routers are possible. The key aspect is the connection of all the computing elements to a network that allows messages to be exchanged.

As previously stated distributed real time systems can be distributed over vast distances e.g. nationwide or over much smaller distances e.g. throughout a factory manufacturing floor or distributed throughout a ship . In reality the principles of the present invention may be applied to many different types of a distributed real time systems that use any number of real time components and non real time components interconnected in a variety of ways. In addition to physical devices the real time nodes of the system can include logical devices e.g. executable software capable of conducting real time operations with respect to devices of the system .

The real time computer nodes of the distributed real time system are capable of executing real time operations and can include without limitation CPU s embedded systems robots sensors or a variety of other real time devices. is a block diagram of a network node suitable for use as a real time computer node of the distributed real time system . The network node includes an operating system O S with a network stack . The network node also includes real time middleware and application software . The real time middleware also referred to herein as just middleware accomplishes messaging and object management utilized to communicate with other network nodes of the distributed real time computing system . The network node is connected to the distributed real time system using a network connection . The network connection can be a wired or wireless connection. In one embodiment the network connection is provided through an Ethernet network link. Still further the network node includes one or more applications . The application comprising software and or devices. The middleware is in communication with the applications and the O S of the network node . Still further the middleware of the network node also communicates with like middleware resident on other network nodes within the distributed real time system .

The use of variables with group objects allows the middleware to impose more controlled behavior in the propagation of changes that affect variables within the group. As a result the application can specify whether certain changes need to be propagated causally i.e. in the same logical sequence as they occurred or atomically i.e. either all available to the application of none available to the application . Moreover a communication object can determine cases where multiple changes to the group can be combined without affecting the interpretation by the observers and thus limit the amount of memory and network traffic needed to communicate the state of the group to the remote observers. These capabilities are also extensively described hereinbelow.

Additionally the variable can include a special parameter called a data parameter . The data parameter is associated with a data value that represents the most current value of the data parameter identified by the variable . Changes to the data value can be intermittent as shown by the intermittent change values or can be a stream of sequential data values taken at regular intervals as shown by the data stream . The variable provides the data values that are sent to the middleware of the real time system. The middleware is configured to transmit the data values to appropriate receivers or to store the data values in memory buffers until delivered to appropriate receivers.

Other parameters can be specified that identify and characterize other variables sub variables that are subordinate to the depicted variable . For example a variable can have a topic identified as boiler and also have three sub variables each pertaining to a separate sensor reading that supplies information concerning boiler .

The real time communications protocol of the present invention is structured such that it can accommodate information produced and transmitted by both group objects and by individual variables. Communications can be grouped in two generalized categories sporadic communications and stream communications.

 Sporadic communications include messages that can represent different and in many cases only tenuously related data items. Some characteristics of such sporadic communications include messages that can have different formats sizes and semantics. As a consequence successive data changes may pertain to completely different types of data. For example if the system being modeled is an aircraft carrier a first data message update can include information concerning changes to aircraft fuel status i.e. current remaining fuel is 11 000 tons . The second data message update can be unrelated to fuel for example it can be a listing of the number and types of aircraft on the flight deck and ready for takeoff. Additionally such sporadic messages can reflect changes in certain parameters of a variable. Another characteristic of such sporadic communication is that the messages can be sent at irregular time intervals rather than periodically or in a continuous stream of data updates. In sporadic communications data is generally sent only when there are changes to the preexisting state of some data item. As a result reliable message delivery is frequently required in order to ensure that the receiver actually receives the message. Thus reliability is an important QoS parameter for sporadic communications. Such reliable messages are generally transmitted requiring the receiver to acknowledge receipt of the message. This may in some case require the system to store a certain backlog of messages until receipt of the message is acknowledged. In the present invention sporadic communications can optionally invoke the capability of maintaining the updates in a coherent logical order. This means that the receiver if desired can receive the messages in the order that the changes occurred even if the changes occurred to different data items. The invention also enables applications to group a set of changes into indivisible units so that receiving applications can view the entire set of changes or none of the changes in the set.

Sporadic communications can easily accommodate data transmission concerning group objects. The details of how the real time protocol of the present invention facilitates such sporadic communications will be described in greater detail hereinbelow.

Another type of data communication uses stream based communications. Stream based communications include message streams of successive messages that have the same or similar format and size. Examples of such messages are data values pertaining to a data parameter. In such message streams the format is identical or selected from a small well defined set of formats and message sizes . Also stream based messages have similar semantics. For example the messages may include data information that includes different data values but all the data values pertain to the same data item. For example the data information can relate to a temperature sensor reading in degrees C. but each successive data value can represent a different value for the temperature. Characteristically stream based communications are often repetitive or periodic in nature e.g. a stream of stock prices over time or a series of pressure readings from a pressure sensor taken at periodic intervals . Due to the repetitive or periodic nature of most stream based messages the message receiver is frequently interested in only the current value of the message stream. As a result best efforts message delivery is frequently a sufficient quality of service QoS parameter. Such best efforts messages are commonly transmitted without the need for the receiver to acknowledge receipt of the message. Such stream based messaging can be thought of as a simplified and less complicated version of the aforementioned sporadic communications. The details of how the real time protocol of the present invention facilitates such stream based communications will be described in greater detail hereinbelow.

Changes in the state of group objects and or state variables are transmitted to appropriate receivers of these changes using specialized communication objects. These communication objects include read objects which can include Readers and Subscribers which are collectively referred to herein as Readers and write objects which can include Writers and Publishers which are collectively referred to herein as Writers . The operation of these Readers and Writers is explained in later paragraphs.

As soon as a new application or device or other entity is connected to a network Readers and Writers are generated that correspond to that new application or device or other entity. Writers are generated to communicate or publish information having certain topics to the rest of the network. Readers are generated by applications or devices or other entities that wish to receive or subscribe to information having a desired topic or attributes matching that of the Writers.

The writer process describes communications between writers mounted on nodes and associated readers which can be mounted locally on the same node or remotely on another node . System software and hardware track changes to variables and group objects collectively referred to herein as variables . Changes to variables are communicated by a Writer to registered Readers i.e. readers that are registered to receive information about selected variables . The variable change information transmitted between Reader objects and Writer objects is transmitted using messages which will be referred to herein as change messages or changes . Generally changes are received put in sequence and then stored until they can be communicated to registered readers.

When a Reader object is registered to receive changes a remote reader process is initiated Step and the changes are transmitted to registered Reader objects in the form of change messages.

In one example this process can be illustrated with respect to . depicts a variable reference table for a group object after five change messages have already been saved. If the state is changed for example by adding another variable z the table is updated. This depicted by the updated of the variable reference table shown in . Because the addition of z occurs after the previously saved change messages the change message introducing the additional variable z is assigned a higher Seq. No. namely Seq. No. 6 . In this way a sequence of changes can be tracked and maintained a logical sequence order.

Sequence Numbers can also be used to indicate to a Reader that a set of changes should be interpreted as a unit. This can be important in cases where other change interpretations can cause a Reader to make incorrect deductions about the state of the system. For example variables can be used model the position of a ship using variables x and y to represent latitude and longitude respectively. Assuming that these latitude and longitude variables are changed multiple times resulting in a set of continuously updated variables. In one simplified example successive x and y readings are depicted by the following set of change messages x 1 y 1 x 5 y 5 x 10 y 10 . These readings can represent the path followed by the ship. In order to correctly interpret the readings it is important that the change messages be interpreted correctly by the Reader. In some implementations each change to a variable can be sent as a separate change e.g. Seq. No. 1 x 1 which is separate from Seq. No. 2 y 1 which is separate from Seq. No. 3 x 5 and Seq. No. 4 y 5 and so on . Where the readings are so separated it is important that the order of the changes be preserved. In addition to maintaining sequential change order it may be important to maintain the interrelationship between the changes. This is especially true where changes are not completely independent. Using the above example change y 1 Seq. No. 2 and should not be grouped together with change x 5 Seq. No. 3 because the resulting interpretation by the Reader will result in an incorrect location x 5 y 1 . As can be imagined this incorrect interpretation can cause the Reader to deduce that the ship is off course or has collided with an obstacle. In this context Seq. Nos. can be used to indicate to a Reader that the interpretation of a given change such as x 5 Seq. No. 3 must be associated with another change y 5 Seq. No. 4 in order to obtain a correct interpretation.

With continued reference to if there are one or more registered Reader objects a remote reader process is activated Step for each Reader object. Each remote reader process can be operated sequentially or simultaneously with respect to other remote reader processes. Additionally as new Reader objects are added to the system remote reader processes are initiated as necessary for those Reader objects.

One embodiment of a remote reader process comprises the following operations described with respect to .

Before a detailed discussion of the remote reader process is completed a brief discussion of timers is in order. An advantageous feature of the invention is the use of timers to improve the efficiency of message traffic flow in a real time system. When a timer regulated process is initiated data is not sent immediately when directed by the system instead the timer regulated process starts a timer with a prescribed time interval and continues with other tasks. When the timer fires the process stops the timer and the actions that initiated the starting of the timer e.g. the sending of messages are re assessed and undertaken if they are still pertinent. Thus in an interim period between timer initiation and timer firing additional data and information requests to be sent are accumulated by the system. The timer regulated process is aware of this additional data and information requests. To the extent such message traffic pertains to messages that are relevant to the timer regulated process the actions taken and the messages sent can be altered. This best illustrated in by simple example.

A timer regulated process has been requested to send a message M to a message receiver A. The timer starts for example having duration of two seconds. Rather then sending Mas soon as requested the process waits two seconds. In the intervening two seconds the process receives two further requests for sending message Mto receivers B C D E F and G. So when the timer fires at the end of two seconds one multicast message Mis sent to receivers A B C D E F and G. In a non timed process six times the amount of message traffic would be generated one message for each receiver A B C D E F and G . Additionally the time periods of the timers can be adjusted by user configuration or by adaptive algorithms to manage message traffic and bandwidth. For example for systems with less memory capacity and thus less ability to store large volumes of messages accumulated during wait periods provided by the timers shorter time periods can be used. By contrast in systems where bandwidth is an issue longer wait periods could be used to reduce the amount of message traffic. Additionally adaptive algorithms can be used to dynamically adjust time periods throughout the system to continuously adapt to system and user needs.

The flow diagram of describes a process embodiment whereby a remote reader process can send change messages to a registered Reader object. Initially the remote reader process determines if all change messages have been sent to the registered Reader object Step . If there are any unsent changes a first timer a SEND VARIABLE timer is started Step unless it was already running Step . Until the timer fires i.e. until the time period of the timer elapses the remote reader process defers any sending of unsent change messages and proceeds with the rest of the process Step . When it is determined that the timer has fired Step the timer stops Step and the next unsent change messages are sent to Reader objects registered to receive those messages Step . Typically such unsent change messages comprise unsent change messages having the lowest Seq. Nos. i.e. the oldest remaining messages . Such messages can include changes to variables and GAP messages the function of which is explained in greater detail below . The sent changes are then marked on a remote reader reference table as having been sent. Alternatively if there are no unsent variable changes the remote reader process proceeds to Step of described in detail with respect to Step .

The operation of the flow diagram of can be better understood with reference to . depicts a variable reference table similar to that shown in and an associated remote reader reference table . Each Writer maintains a variable reference table that tracks changes to variables for the Writer and the logical order in which those changes occurred. Also one writer object can be associated with many different reader objects each one having its own remote reader reference table. The remote reader reference table is used to track message traffic information. For example a remote reader reference table can track message status information including but not limited to messages sent to that reader object messages received by that reader object messages acknowledged as received by that reader object and messages requested by that reader object.

Referring to the remote reader reference table depicted in sent messages are tracked . Here messages and have been marked as having been sent. Acknowledged messages can also tracked . Here messages and have been marked as acknowledged as having been received by the reader object. Other included message categories within the remote reader reference table include messages requested which tracks whether the reader object has requested that the remote reader process for the writer object send resend one or more messages.

Returning to when the timer elapses Step and the timer is stopped Step . Then at least one of the next unsent change messages is sent to the registered reader object. For example consulting the variable reference table of the next unsent message message y 99 would be sent to the reader object. Once sent the message box of the sent messages column of the variable reference table of can be checked off.

Again returning to if there are no unsent variable changes e.g. change messages the process continues by proceeding to of Step where positive and negative acknowledgements can be processed. describes processing for treating not only positive acknowledgement messages ACK but also for treating negative acknowledgement messages NACK s . The processing depicted in determines whether a positive acknowledgement message ACK has been received from a reader object Step . If an ACK has been sent by a reader object and received by the associated remote reader process the remote reader reference table for that reader object is updated to reflect the acknowledgement Step . Once the remote reader reference table is updated the process returns to point of .

On the other hand if it is determined Step that no ACK has been received it is determined whether a negative acknowledgement message NACK has been received from a reader object Step . A NACK is a request to resend unacknowledged change messages. If a NACK has been sent by a reader object and received by the associated remote reader process the remote reader reference table for that reader object is updated to reflect the negative acknowledgement Step . Once the remote reader reference table is updated the process returns to point of . Alternatively if it is determined that no NACK has been received Step then the process proceeds to of Step .

The process of updating positive acknowledgement status may be better understood with reference to which illustrates this process using an embodiment of a remote reader reference table . In the depicted embodiment all change information e.g. up to Seq. No. 4 has been sent. The highest number for a received ACK is Seq. No. 3. Then if the reader object were to send an ACK message regarding Sequence No. 4 to the remote reader process namely writer object and such ACK message were to be received the remote reader process would cause the remote reader reference table to be updated to reflect the receipt of the ACK for Seq. No. 4. Alternatively when a reader object sends an a NACK negative acknowledgment message regarding Sequence No. 4 to a remote reader process that is received the remote reader process would cause the remote reader reference table to be updated to reflect the receipt of the NACK for Seq. No. 4.

After updating ACK or NACK status Steps and of the process continues to Step of . This is illustrated as Step of .

Returning to messages that are requested are resent Step . This process is illustrated in . The processing illustrated in begins by determining whether any readers objects are requesting variable information Step . This step is commonly used by reader objects to request that missed variable change messages be resent. In one implementation a remote reader reference table can be consulted to determine if the corresponding reader object has requested that variable information e.g. change message identified by Sequence No. be resent. These requests can be made in the form of a NACK message from the reader object for a change message having a specific Seq. No.

Returning to if there are no requests for variable change messages the process continues to Step of . This is reflected by activating the process illustrated in Step . However if there are pending requests for variable change information Step and a second timer a reply to request timer is not already started then the second timer is started Step . The process continues to Step . However if the second timer was already running the process checks if it has fired Step . If the second reply to request timer has not fired then the process continues to Step . But if the second timer has fired Step then the remote reader reference table is consulted and the pending requests for change messages are located and identified. Indicators and for such identified requests are shown in . The process then stops the timer Step and sends at least one of the identified requested variable change messages to the requesting reader objects Step . In most cases the change messages sent will be those the identified requested variable change messages having the lowest Seq. Nos. i.e. the oldest messages . Such messages can include changes to variables and GAP messages GAP messages will be explained in greater detail below . At this point the processing returns to point of Step .

Returning to the process determines if there are unacknowledged variable change messages Step . As indicated message is an unacknowledged variable change message. This starts a third timer timer Step . Until the time period of third timer elapses and the timer fires the processing waits for the third timer to fire Step . When the third timer does fires then a heartbeat is sent to the reader object Step . This heartbeat identifies the highest Seq. No. of a message sent thus far by the writer object namely the associated remote reader process . For example using the highest Seq. No. for a sent message is Seq. No. 5. Inherent in such heartbeat messages is a request for acknowledgement that the sent messages have been received. At this point the process returns to point of Step .

As shown in the process determines if there are unacknowledged variable change messages Step . As indicated message is an unacknowledged variable change message. Where a third timer is not already running Step this starts the third timer heartbeat timer Step . If the third timer is already started Step or was started but it has not fired Step the process goes back to point of Step . Once the heartbeat timer fires Step the process stops the timer Step and sends a heartbeat message to the reader Step . The heartbeat identifies the highest Seq. No. of the variable change message sent by the writer to the Reader process. For example using the highest Seq. No. for a sent message is Seq. No. 5. Inherent in such heartbeat messages is a request for acknowledgement that the sent messages have been received. At this point the process returns to point of Step .

Still referring to if there are no unacknowledged variable change messages in Step the processing continues by activating the portion of the process illustrated by Steps and Step . If there are no unacknowledged variable changes in Step then the process checks whether another fourth timer heartbeat timer has already been started Step . If it has not been started the process starts the fourth timer Step and then returns to point of Step . Where the fourth timer has been started but has not yet fired Step the process also goes back to back to point of Step . However when the fourth timer heartbeat timer fires Step the process stops the timer Step . Then a heartbeat message stating that no confirmation is requested is sent to the reader object Step . At this point the processing returns to point of Step . Previous reference has been made to GAP messages. GAP messages can be used to provide a continually updated picture of a group object and can be used to limit the amount of memory required to store the history of changes the variables within the group have undergone. Furthermore GAP messages can be used to present a different view of a group object to different remote readers that may only be interested in a subset of the variables within the group.

One implementation of such GAP messages can be explained with respect to which depicts an embodiment of a variable reference table . As previously discussed a variable reference table includes a list of Seq. Nos. and a list of variable change messages associated with the Seq. Nos. . In this example the variable reference table illustrates a series of changes to the variable pertaining to a group object. Using the depicted table as an example a first message having Seq. No. 1 tracks the addition of a new variable x to the group object. At some later time new variables y and z have also been added to the group object i.e. messages and . Messages updating values for x messages and have also been posted to the table as have messages updating values for y messages and . If a reader object is interested in the current value of a variables older information is not particularly relevant or important to the reader object. The GAP message is a convenient way of efficiently dealing with this situation. For example if a new reader object is connected to a real time network after message GAP messages can be used to efficiently present the current state of the group object to the reader object. In an implementation where only the most current information is desired by the reader object GAP messages replace all prior values for each variable. As an example chart shown in depicts a list of the variable messages and GAP messages that represent the current state of the group object to the reader object that is activated connected to the writer object after Sequence No. 9 . Only the addition of new variables and their most recent values is presented. All other messages can be replaced with GAP messages. Thus the Chart depicts the following change messages and Seq. Nos. 1 new x 2 GAP 3 GAP 4 new y 5 GAP 6 GAP 7 new z 8 x 12 9 y 5 . A more complete history of the previous values for variables can also be presented. In such cases GAP messages replace only the older messages in one example all changes except for the last three changes affecting each variable x y or z may be replaced with GAP messages .

In another example explained with reference to table of where a reader is only interested in variables x and z the latest state of the group object with the sequence following sequence of messages is depicted. Table which is only interested in variables x and z includes the following set of Seq. Nos. and values. Seq. Nos. 1 new x 2 GAP 3 GAP 4 GAP 5 GAP 6 GAP 7 new z 8 x 12 9 GAP. Additionally the format of the GAP submessage described in greater detail hereinbelow allows for consecutive GAP submessages such as in to be grouped to further reduce the actual number of submessages sent by the system. For example referring to table the complete sequence of change information can be sent using five submessages e.g. Seq. No. 1 new x one GAP that includes Seq. Nos. 2 through 6 Seq. No. 7 new z Seq. No. 8 x 12 and a GAP for Seq. No. 9 .The general mechanism for determining which changes are to be propagated to a remote reader and which changes which can be coalesced into combination of new GAP and modified changes is described hereinbelow. A writer propagates its most current state to readers associated with the writer. It is not necessary for the writer to propagate all the changes to a reader causing the reader goes though all the same states as the writer. Nor it is required that the writer maintain a record of all changes and states as long as the reader can recreate a valid subset of states of the writer and as long as the logical order in which the subset of writer states experienced by the reader consistent with the order of states in the writer.

More formally a writer can be considered to have a state S consisting of the values of all the data objects it contains. As these data objects are modified the state of the writer also changes and thus we can see the writer as transitioning through a sequence of states S S S etc. Any one of the states Scan be decomposed as a sequence of changes C C . . . C. Each of these changes typically represent changes deltas from the previous state e.g. the addition of new data objects the removal of existing data objects modifications to values for existing data objects and numerous other changes . So a sequence of states e.g. S S S S . . . of a group object can be expressed as containing the sequence of changes C C . . . C as follows. S C S C C S C C C S C C C C and so on. A writer can ensure that each reader only sees a subset of the valid states here S S S S in the correct logical sequence. In other words a reader could be presented with states in order S S S S but not in order S S S S nor order where S S S where state Sis not a valid state of the group object in the writer.

As previously mentioned each individual change in a sequence of the changes C C . . . C need not be preserved. For instance assume that the group of changes Crepresents the change sequence C C. A writer can propagate C C and Cas changes. The receiving reader observes states S S S. Referring again to tables and in example states are S x S x 5 S x 7 S x 7 y S x 7 y 10 S x 11 y 10 S x 11 y 10 z S x 12 y 10 z S x 12 y 5 z . In this same example change Crepresents the creation of the new x variable at Seq. No. 1. Change Crepresents the change occurring at Seq. No. 2 setting x 5 and change Crepresents the change at Seq. No. 3 that sets x 7 and so forth. Changes Cand Ccan be combined into the single change Cwhich simply sets x 7. A remote reader receiving the change messages in table observes Cas new x GAP for Seq. No 2 Cwill reconstruct the states S x S S x S S x 7 Swhich is a proper subset of the sequence S S S and so on.

Furthermore with respect to a specific reader a writer only needs to propagate the changes needed to reconstruct a projection of the state of the writer that includes only changes the reader is interested in. The projected state being defined as the state of the group object when only the values of the variables of interest to the reader are considered in the definition of the state. Again referring to the example in table depicts the projection of the writer onto a reader that is only interested in variables x and z and thus the only changes propagated are those pertaining to variables x and z . It is worthwhile to note that even though different variables are important to different readers the writer preserves the logical sequence of changes for each reader. Additionally change information can be selected by readers based on many different parameters including but not limited to identity topic of the variable variable metadata or the contents of the data itself.

The importance of in some embodiments grouping changes so that the reader does not misinterpret the state of the system was previously discussed. This means that each change in the state of a group object associated with the writer can involve changes to more than one variable of the group object. In other words transitioning from one valid state of the group object to the next valid state of the group object may require multiple changes.

In one illustration a simplified group object includes variables x and y . The simplified group object has a set of valid states S S S comprising S x 1 y 1 S x 5 y 5 S x 10 y 10. To maintain a propagation of these valid states requires that the changes be aggregated in a particular way. For example the above example can include six changes C C C C C and C where C x 1 C y 1 C x 5 C y 5 C x 10 C y 10 . Using these changes Cis aggregated with C Cis aggregated with C and Cis aggregated with C. This can be accomplished by the RTPS protocol by including an additional Seq. No. propagated with each change submessage. This additional Seq. No. is included in the change submessage thereby identifying the Seq. No. of the last change that belongs to the aggregation of changes. For example a submessage containing Ccan also contain Seq. No. 2 identifying the Seq. No. of the last change in this aggregation and the submessage containing Calso contains Seq. No. 2 identifying the Seq. No. of the last change in this aggregation effectively ending the aggregation . In like manner a submessage containing Ccan also contain Seq. No. 4 identifying the Seq. No. for the last change in the aggregation and the submessage containing Ccontains Seq. No. 4 identifying the Seq. No. of the last change in this aggregation thereby ending the aggregation . These approach can be used to aggregate all such groups of associated changes. Additionally this approach is readily extended to groups of changes having several more than two changes as part of the same aggregation.

Working in conjunction with the above described writer process and remote reader process is a corresponding reader process and a remote writer process. is a general depiction of such a reader process for receiving change information and heartbeat messages requests for confirmation from writers to the readers. Also the reader process facilitates the communication of acknowledgements confirmations and negative acknowledgements requests from the readers back to the writers. From the readers point of view a writer is identified and a remote writer process is initiated Steps . The details of this reader process and associated remote writer process are described in greater detail herein below.

When viewed from a reader perspective the processing begins with the reader determining if there are writers that have variables with topics the reader is interested in Step . This means that registered readers can determine if there are writers having variables pertaining to the topics that the reader is interested in. If there are no appropriate writers the processing returns to point until such a writer appears. If there are appropriate writers then a remote writer process is initiated and executed Step .

Alternatively if the reader object has not a received new variable change message then the process goes to of to mark messages identified by heartbeat messages as confirmation requested Step . depicts a portion of the remote writer process corresponding to of . The process begins by determining whether any heartbeat messages have been received Step . As previously explained a heartbeat message identifies the highest Seq. No. message sent by the writer object. If a heartbeat has not been received confirmation requests are dealt with Step . This portion of the processing namely of will be discussed in greater detail below with respect to . However if a heartbeat has been received the processing determines if the reader object has received all the variable change messages it should have Step . This can be accomplished by comparing the Seq. No. of the heartbeat with the Seq. No. of all messages received. For example if a heartbeat sends Seq. No. 8 that means that messages having Seq. Nos. 1 8 have been sent. If the reader object has also received messages having Seq. Nos. 1 8 that means that the reader object has received all the variable change messages it should have and the process can then proceed to the next Step . However if reader object has not received all the variable change messages the unreceived change messages are marked as missing Step . This is because a standard heartbeat message informs the reader of the changes it should have received. Thus the reader can determine that it has missed some of those messages. Once the change messages are marked as missing the process returns to point of . Step .

Where the reader has received all the changes indicated in the heartbeat Step it is determined whether the heartbeat itself requires confirmation Step . If confirmation is not required then the process returns to point of Step . On the other hand if the heartbeat does require confirmation then the variable change message having the highest Seq. No. is identified in the heartbeat message and marked as requesting confirmation. The process then returns to point of . Step .

Returning to Step where no changes are marked as missing the processing proceeds to Step where it is determined if there are changes marked as confirmation requested. If there are no changes marked as confirmation requested the processing goes to of Step . Where changes are marked as confirmation requested the processing checks whether a sixth timer confirmation timer has been started Step . If the timer has not been started the confirmation timer is activated Step and the processing returns to of Step . If the confirmation timer is already activated the processing determines whether the confirmation timer is activated has fired Step . In the case where the confirmation timer has not fired the processing returns to of Step . In the case where the confirmation timer has fired the processing stops the confirmation timer Step and sends a confirmation message ACK back to the writer that requested the confirmation Step . At this point the status of messages is updated to reflect the fact that messages marked as confirmation requested have now been sent confirmation messages ACK s Step . The processing returns to of Step .

The processing described hereinabove describes a process where a reader to sends confirmation messages for particular Seq. Nos. once they have been marked as confirmation requested. In different implementations the middleware can operate differently. For example when a change is marked as confirmation requested the middleware can unmark all changes that were marked confirmation requested that have smaller sequence numbers than the current ones. The state of the confirmation timer is however preserved so the confirmation will be send on the same schedule as before but with a higher Seq. No. thus saving confirmation messages.

Another useful attribute of the present invention is its ability to self configure network nodes or applications as soon as they are connected to the network. To this end each node has a set of built in Readers and Writers concerning topics useful to the configuration of the nodes. As soon as the node is connected to the network the RTPS communication protocol automatically assumes the existence of certain built in readers and writers in a pre configured set of nodes given individually as a list or in group manner using multicast or broadcast . It then creates remote readers for the assumed readers on those remote nodes and uses the writer to reader communication to send and receive information regarding the properties of the node. Properties of the node include but are not limited to protocol versions vendor information source and destination hostnames IP addresses pathnames communication ports. The built in readers and writers communicate also the existence of publications subscriptions and other variables. Using this mechanism and with the aid of built in writers that have group objects containing the list of all subscription publications variables and other relevant information the nodes inform each other of topics readers writers and other things they can publish or subscribe to. This permits each node to set itself up without the need for a network administrator to do it manually.

In order to be correctly interpreted by the Message Interpreter the messages should comply with some standardized format. Although many formats can be used one message format embodiment will be detailed hereinbelow. Items like data must be encoded. In one suitable implementation data is encoded using OMG CDR See The Object Management Group CDR data representation http www.omg.org corba corbiiop.htm August 1998 . Such CDR data representation encapsulates data using the native order and the endianess of the sending machine and leaves correct interpretation up to the receiver. Seq. Nos. are encoded using 64 bits. Timestamp information uses standard NTP representations of time Internet Engineering Task Force IETF RFC 1305 Network Time Protocol Version 3 Specification Implementation and Analysis . See http www.ietf.org rfc rfc1305. txt . The objects on the network can be uniquely identified using 12 octet Global Unique Object ID s GUID . The GUID is built of three components HostId ApplicationId ObjectId each comprising a 4 octet data stream. Such identifiers can be constructed using the UUID specification from OSF DCE See The Open Call Group Document C706 CDR 1.1 Remote Procedure Call see http www.opengroup.org publications .

Using these formats a modular message format can be constructed that allows the use of small set of well known and readily understood submessages to communicate information in accordance with the real time communication protocol of the present invention. illustrates a typical RTPS message suitable for use with the RTPS communication protocol of the present invention. In one implementation when UDP IP is used a RTPS message is the contents of one UDP IP Datagram. A RTPS message includes an RTPS header followed by a variable number of RTPS submessages . A more detailed view of an RTPS submessage shows a RTPS submessage header and RTPS submessage payload . The RTPS submessage payload is comprised of a variable of submessage elements . Each of these components of an RTPS message will be briefly explained.

Referring again to the RTPS message further includes a variable number of RTPS submessages . Each RTPS submessage includes a RTPS submessage header and RTPS submessage payload comprised of one or more RTPS submessage elements .

An advantage to the above described message format is that a single submessage can be used to control the context of the interpreter and thus affect the interpretation of an entire stream of related submessages. Because this information is cached by the Message Interpreter the information only needs to be sent once per message and does not need to accompany each submessage as is often conventionally required. Furthermore the use of globally unique object identifiers GUID to identify source and destination of many submessages allows readers and writers to remember information previously conveyed by that same reader and writer. This information pertaining to for example the properties of the Reader or Writer does not need to be sent along with each message they exchange as is often conventionally required. These two attributes reduce message and submessage size having the result that network message traffic is reduced.

The present invention has been particularly shown and described with respect to certain preferred embodiments and specific features thereof. However it should be readily apparent to those of ordinary skill in the art that various changes and modifications in form and detail may be made without departing from the spirit and scope of the invention as set forth in the appended claims. Although the disclosed system is particularly suitable for real time applications the inventors contemplate that its attributes and characteristics are also well suited for use with conventional publish subscribe systems. Furthermore the examples provided herein are intended to be illustrative rather than limiting. The inventions illustratively disclosed herein can be practiced without any element which is not specifically disclosed herein.

