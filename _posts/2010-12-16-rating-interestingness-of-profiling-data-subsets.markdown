---

title: Rating interestingness of profiling data subsets
abstract: Systems and methods for rating interestingness of profiling data subsets are described. Profiling data including a set of nodes associated with at least one executed computer program is received. The profiling data contains a first set of scores corresponding to the resource consumption of the nodes. A second set of scores is identified from the profiling data, wherein a score of the second set of scores indicates a combined resource consumption of a corresponding node of the set of nodes and at least one other node of the set of nodes related to the corresponding node. An interestingness rate is evaluated for groups of nodes of the set of nodes based on the corresponding scores. The group of nodes with the highest, or satisfactory high value of the calculated interestingness rate is presented.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08839208&OS=08839208&RS=08839208
owner: SAP AG
number: 08839208
owner_city: Walldorf
owner_country: DE
publication_date: 20101216
---
Software profiling is a technique for measuring resource consumption in computer systems by different software structures. A software profiling mechanism implemented in a computer system environment can collect and analyze data about various resources consumed by different software applications running in the computer system environment. For example the various resources may include central processing unit CPU usage memory allocations input output IO operations number of method calls etc. The software profiling mechanism or the profiler may collect resource consumption data for different parts of the running software applications e.g. per software objects instantiated in the computer system environment per separate methods or functions etc. The profiling data can be used for different purposes and is especially helpful for identifying inefficient programming structures.

A profiling mechanism may collect data and generate statistics about a quantity of a certain type of resource consumed by different parts of software applications. For example a profiler may collect data and generate statistics about memory allocations for each method invoked within an application server runtime environment. In case of a relatively complex application server runtime environment where profiling mechanisms are usually implemented the number of invoked methods during a single profiler run may easily exceed several thousands. With such a big number it is hard to identify inefficient methods characterized with excessive resource consumption. Simple sorting of the methods or of other investigated programming structures based on their individual levels of resource consumption could be misleading as the programming structures are often interrelated. The resource consumption of one programming structure could be a function from the resource consumption of another programming structure.

Various embodiments of systems and methods for rating interestingness of profiling data subsets are described herein. In one aspect profiling data including a set of nodes associated with at least one executed computer program is received. Together with the set of nodes a first set of scores is received where a score of the first set of scores indicates a resource consumption of a corresponding node of the set of nodes. A second set of scores is identified from the profiling data wherein a score of the second set of scores indicates a combined resource consumption of a corresponding node of the set of nodes and at least one other node of the set of nodes related to the corresponding node. In another aspect a group of nodes is selected from the set of nodes based on the scores from one or more of the first set of scores and the second set of scores corresponding to the selected nodes. In yet another aspect an interestingness rate is evaluated for the group of nodes of the set of nodes based on the corresponding scores. The group of nodes is presented when the value of the calculated interestingness rate is satisfactory.

These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof presented in connection with the following drawings.

Embodiments of techniques for rating interestingness of profiling data subsets are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

The client system may represent a variety of processing devices e.g. desktop computers laptops cellular phones handheld devices for example personal digital assistant PDA navigation devices etc. Each of the users may access one or more sessions of user interface UI to operate with the available software services. Client runtime provides an environment where client side software applications are deployed and executed. In one embodiment different client side software applications may be installed on the client system to provide functionality necessary for accessing the services provided by the server system . For example some client side software applications may pre process service requests initiated through UI . Other client side software applications can be used in designing new or in changing existing software services at the server systems .

The client system establishes interface with server system using appropriate functions methods and data formatting as defined by client application programming interface API . In one embodiment the different elements of the client system e.g. UI client runtime and client API are implemented within a common framework. For example an Internet browser could provide such a common framework. The additional functionality required for the described is plug ins or other extensions e.g. Silverlight development platform provided by Microsoft Corporation. Other examples for such frameworks may include Java Virtual Machine JVM originally specified by Sun Microsystems Inc. .Net Framework specified by Microsoft Corporation etc.

The modules of server system correspond to some of the basic elements included in general application server architectures. Server runtime establishes an environment where one or more software applications are deployed and executed. The access to the services provided by applications is managed through server API . In one embodiment metadata component represents data structures where the application server stores descriptions of programming or business objects and or different parameters relevant to the deployed applications . The metadata could be accessed by the server runtime during the deployment and the execution of the applications . In one embodiment the server system is built using Java based application server platform e.g. compliant with Java Enterprise Edition Java EE specification. The elements of the server system could be executed within a server side JVM.

Interfaces provide the server system with access to external resources. External services represent an example for such external resources. The external services may be provided from other computer systems connected to the server system directly via network or via other networks. The external services may include business services provided by legacy systems infrastructure services messaging or notification services etc. Storage is another example for external resource. The storage could be a database where any of the software and hardware elements of the server system including the physical servers and the application server instances may extract and store data. The data that is placed in the storage could be shared among the different units of the server system .

In one embodiment the software profiling mechanism implemented in the computer system includes profiler frontend and profiler backend parts. The main function of the profiling mechanism is to collect analyze and present data for the runtime of various computer programs including system programs applications etc. The profiler backend could be deployed and executed in the server runtime environment . In one embodiment the profiler backend may be integrated with the server runtime e.g. developed as an integral part or enhancement of the JVM. The profiler backend is capable of tracing and capturing data about the process threads of the software programs executed in the server runtime e.g. applications .

For example the profiler backend may collect data about function calls parameter values variables memory consumption execution times instantiated objects etc. The granularity of the collected data could be broken down to individual methods or program instructions. The profiler backend could store the selected profiling data locally at the server system . Alternatively the profiler backend may transfer the collected data to storage where data from all units of the server system could be collected and aggregated. In one embodiment the profiling data is directly communicated to the client system through server API .

The setup and execution management of the profiler backend could be administered through profiler frontend . The responsible users who are authenticated with respective privileges at client system may access the profiler frontend through a session of the UI . The profiler frontend may include various controls for setup and management of the execution of the profiling mechanism implemented in the system . Further the profiler frontend may include functionality for processing analyzing and presenting the data collected by the profiler backend . The responsible users may configure the type of analysis of the profiling data to be performed the way the profiling data is to be presented etc.

The data extracted by the profiler mechanism e.g. the profiling data generally relates to actions or events occurring in the server runtime . The examples for such actions may include the start of process threads allocation of objects method enter events method exit events method parameters thread stack traces etc. In one embodiment the profiling data includes identifications of a set of runtime structure entities associated with the running computer programs. The profiling data also includes measures or scores for quantities of resources consumed by the runtime structure entities with respect to one or more of the actions occurring in the server runtime .

Usually there are relationships between the different structure entities in a runtime environment. shows the set of runtime structure entities nodes A to with a number of relationships between the entities. The relationships are illustrated with the help of directed graph edges connecting related nodes. The relationships correspond to dependencies between the structure entities established in the runtime environment. For example when the nodes of set correspond to methods executed in the runtime environment the relationship between two nodes shows that the method represented by one of the nodes calls the method represented by the other node. Thus edge represents a relationship between node A and node B according to which the method represented by node A calls the method represented by node B .

The relationships between the nodes e.g. the runtime structure entities associated with the profiled computer programs executed in a computer system define hierarchical structure. Some of the nodes in the hierarchical structure are senior e.g. they are parent nodes some are child nodes and some of the nodes are both parents and children. The direction of an edge connecting nodes illustrates the parent child relationship. Node A is parent to node B and node B is child to node A . A parent method calls or invokes the execution of one or more child methods e.g. the execution of a child method is invoked by a parent method. In one embodiment relationships may exist between entities of different executed programs. In one embodiment the relationships between the runtime structure entities of the profiled computer programs may define a tree structure.

The resource consumption of the runtime structure entities e.g. nodes may be further profiled by including data for total consumed quantity when relationships between the entities are defined. The total quantity for a given node includes the quantity consumed by the node and the quantity consumed by any other node from the profiled set of nodes related to the given node. In one embodiment only the resource quantities consumed by the child nodes are added to the total quantity of the given node. Label in contains the total resource quantity consumed by node A and the related node B while label holds the self quantity of the resource e.g. the consumption attributed to the node A itself.

In one embodiment a user may not be interested in the profiling data for all nodes in the set of the runtime structure entities. A subset of the nodes could be selected based on certain criteria. Only the nodes in subset and their respective resource consumption scores could be analyzed and presented to the responsible parties.

In one embodiment an execution of a profiling mechanism implemented in a computer system may generate statistics about a certain type of resource consumed within the structure entities of the profiled programs by a certain type of program entities. For example the profiling mechanism could generate statistics about resources consumed by the methods executed within one or more of the running applications or one or more of the running system programs in the computer system. One such resource could be the memory allocations between a number of methods in a Java application program where a generated statistics could contain the size of the operational memory allocated for each method called within the program.

Area shows a list of the quantities of memory allocated or consumed by the corresponding methods displayed in the area . The quantities in the area represent the resource consumption directly attributed to the nodes in area e.g. the self quantity values or scores. Area shows the total values of the quantities consumed by the methods enlisted in area . Each of the total values in area includes the quantities consumed by the children of the corresponding node if any.

Usually a profiling run may contain thousands of nodes methods or other entities associated with the profiled programs . Therefore different approaches may apply to get an overview of where the profiled resource quantity is consumed the most e.g. at which nodes. One of the approaches is to convert the tree into a flat statistic e.g. not presenting the existing hierarchy between the nodes sorted by the self scores. This would show in which methods the measured resource is mostly consumed. shows UI screen with areas and displaying a flat list of methods with highest values for memory allocation quantities. However with this approach generic methods e.g. for string and collection handling usually end up at the top of the sorted list of methods since these methods are the building blocks of the Java programs.

Another approach is to sort a list of the methods executed within the profiled programs by the total scores. illustrates UI screen with areas and showing statistics for the profiled data sorting the nodes by the total scores. The most interesting methods from the perspective of the program developers and administrators should be those methods at the top of the list in area as they have the highest total scores as shown in area . However what UI screen shows is the list of the most delegating methods e.g. the methods which most often start threads from where most of the other methods are called.

An advantageous approach of presenting profiling statistics for computer programs is based on evaluating interestingness of subsets of nodes e.g. subsets of profiled runtime structure entities. According to this approach a subset of N nodes best representing the whole set of profiled entities has to be identified. This approach requires definition of criteria for selecting the appropriate subset of the nodes from the profiling data. One of the elements of this criteria specifies that the total value for resource consumption assigned to a node should be relatively large to exclude insignificant methods from the set of N most representative nodes. Another element of the criteria defines that a node should not be dominated by a related node. For example if a parent method A simply forwards the work to a child method B it is better to select method B as more specific and interesting from resource consumption perspective.

In addition to the criteria for individual selection of interesting nodes to represent the profiling data the nodes in the subset should comply with group criteria as well. The whole subset of N nodes should be selected to cover most of the measured quantity e.g. the consumed resources. In the example of the memory allocation trace a group criteria element specifies that the subset of N selected methods or the methods related to the N selected methods should consume most of the allocated memory. The overlap between the selected nodes in the subset should be avoided e.g. the number of related nodes in the subset should be at minimum. Another group criteria element for selecting the nodes in the representative subset requires selecting nodes with similar corrected scores. A corrected score for a method is the total resource consumption quantity when the method does not directly or indirectly call another method of the representative subset where the quantity is consumed.

Some of the elements of the individual and group criteria for selecting a representative subset of nodes associated with the profiled computer programs could be conflicting e.g. depending on resource consumption distribution. shows process for selecting a subset of N nodes from profiling data containing information for a set of hierarchically related nodes according to one embodiment. The process may be executed in a frontend of a profiling mechanism based on profiling data collected by a backend of the profiling mechanism. In other words a client profiling application manipulates the data collected by a server profiling application according to one embodiment. The client and server profiling applications may be integrated in a single profiling mechanism implemented in a computer system as illustrated in . In another embodiment client profiling application and server profiling application may be autonomous. The communication between the client and server profiling applications may be online e.g. by utilizing messaging tools distributed transactions etc. or offline e.g. by transferring profiling data stored in files.

At a client profiling application receives profiling data for a set of nodes e.g. runtime structure events associated with one or more computer programs executed at a server system. The profiling data could be communicated online or offline depending on the implementation of the profiling mechanism. Generally the profiling data contains information about the nodes including identification of the nodes and quantities of consumed resources for each of the nodes. At the profiling application identifies self and total resource quantity consumed per node. The self quantity is a score indicating resource consumption attributed to a single node e.g. the memory allocated for each of a set of methods executed within the profiled programs. The total quantity indicates the combined resource consumption attributed to a node and to other nodes related to this node e.g. the total memory allocated for a method and for all child methods directly or indirectly called by this method.

Nodes with relatively small resource consumption are removed from the set of received nodes at . For example the nodes with total resource consumption score below a predefined threshold are not interesting for further analysis. These are the nodes consuming limited quantity of resources and respectively any improvement of the computer programs concerning these entities will bring only limited reduction of the overall resource consumption. In one embodiment the threshold is defined as a function of the overall reported resource consumption and the cardinality N of the target subset of nodes 

At a number of dominated nodes are removed from the received set of nodes associated with the profiled programs. For example a node with small self resource consumption is usually dominated by a child node. In one embodiment node A is considered dominated by its child node B if the total quantity of the resource consumed by node B is at least as large as a fraction of the total quantity of the resource consumed by node A . An example value for could be 0.8 units or higher. The reason for this operation is to remove those nodes which simply forward the work tasks for execution to their child nodes.

After the completion of the actions of process corresponding to blocks and the initially received profiling data is significantly reduced. However the remaining data may still include too many nodes to be directly presented. Once again the goal of process is to extract a manageable subset of nodes together with their corresponding resource consumption scores from the received profiling data. The subset of nodes should correspond to the runtime program entities which account for the bulk of the resource consumption. Therefore an optimization of the nodes in the target subset would result in significant reduction of the overall resource consumption of the profiled programs.

As discussed earlier the nodes associated with the profiled computer programs are related to each other. Therefore rating the interestingness of a single node without taking into account the existing relations with other nodes may produce misleading results. It would be inefficient to assign a single interestingness rate to a single node e.g. to a single method isolated from the other methods called by this method or isolated from the other methods calling the method. In general all parts of the profiled software programs have to be accounted for. For example different program modules may execute different thread sequences of the monitored methods or other runtime structure events. These different relations should also be considered in order to identify the elements of the profiled programs which in combination account for the most part of the consumed resources.

At N of the remaining nodes with similar self resource consumption quantities are grouped in a subset. The grouped nodes could be either randomly or systematically selected. In one embodiment the requirement for similar self resource consumption may be modified to account for corrected scores or the N nodes may be selected without any criteria. The N nodes may be selected to cover at least a predefined fraction of the overall resource consumption of the profiled programs.

At interestingness rate is calculated for the subset of N grouped nodes. Different criteria or mathematical formulas could be used for calculating the interestingness rate of the group of nodes. In one embodiment the interestingness rate of the subset of N nodes corresponds to the result of the following function 

The illustrated formula includes three parts. The first part is a constant and ensures that the maximum value V of the interestingness rate is zero. The maximum value is calculated only if nodes with optimal distribution of consumed resource quantities are selected. The second part of the formula accounts for the differences between the quantities corresponding to resources consumed by the nodes in the group e.g. for the resource consumption distribution within the group of nodes. The smaller the differences the bigger the value e.g. the groups of nodes with more even distribution of the consumed resource quantities will have higher interestingness rate. The last part of the formula reflects the overlapping between the grouped nodes e.g. the number of related nodes within the subset.

Different embodiments may use different formulas for calculating interestingness rates. The selection of the mathematical expression to be applied may depend on the type or the purpose of the profiled programs. Further the formula may reflect what kind of runtime structure entities are profiled and what kind of data is collected e.g. consumption of what kind of resources is logged memory allocation number of allocated objects CPU usage I O operations etc. . For example a slightly different formula for calculating interestingness rate of a subset of N nodes could be applied 

At the interestingness rate calculated for the selected group of N nodes is compared with other rates. For example the calculated rate may be compared with interestingness rates calculated for different groups of nodes based on profiling data collected on previous profiling runs. Alternatively the interestingness rate value may be measured according to an existing or predefined grid or levels of interestingness.

At it is verified whether the rate of interestingness calculated for the group of nodes is satisfactory based on the comparison. When the calculated group interestingness of the selected N nodes is not satisfactory e.g. the selected nodes in their combination are not representative for the resource consumption to consider relevant program optimizations another group of N nodes is selected at . However before moving back to a check is performed at to verify if all permutations of the available nodes in the profiling data have been tested. More specifically it is tested whether interestingness rate have been calculated for all possible subsets of N nodes.

If at it is confirmed that the interestingness rate calculated for a current group of N nodes is satisfactory or if at it is confirmed that all permutations of subsets of N nodes has been tested the group of N nodes selected from the current profiling data with the highest interestingness rate is presented at . The group of N nodes with the highest interestingness rate could be the currently tested group which satisfied the check at . The presentation of the subset of N nodes with highest or satisfactory interestingness rate may display the hierarchical relationships between the grouped nodes and or between the grouped nodes and the rest of the profiled entities.

Generally finding an optimal set of nodes e.g. methods could be computationally expensive. In one embodiment the process would just try every possible permutation of nodes combinations and choose the one which yields the highest interestingness rate. While not feasible for the general case if enough nodes have been removed at steps and and the selected number N of nodes to be presented is not too large this could be a viable strategy. Otherwise a sampling approach is appropriate where random subsets of N nodes are selected to compute interestingness rate until a satisfactory level is reached at .

Some embodiments of the invention may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment of the invention may be implemented using Java C or other object oriented programming language and development tools. Another embodiment of the invention may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather the scope of the invention is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

