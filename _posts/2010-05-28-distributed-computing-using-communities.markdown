---

title: Distributed computing using communities
abstract: Distributed computing using communities is described. In an embodiment computations in a distributed computing system are driven and controlled by a document storing a distributed computing graph, a graph layout view of that graph and visualization elements. For example, the document is replicated and synchronized at each of a plurality of entities in the distributed computing system. In examples a community may be drawn as a rectangle or other shape in the graph layout view and represents one or more computing resources in the distributed computing system. For example by placing graphical elements representing currently executing processes into the community on the graph layout view a user is able to ensure that those processes execute using the computing resources of the community. In examples communities may be nested and may have parameters specifying conditions which are to be met by the computing resources they represent.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09268615&OS=09268615&RS=09268615
owner: Microsoft Technology Licensing, LLC
number: 09268615
owner_city: Redmond
owner_country: US
publication_date: 20100528
---
Distributed computing is required in many application domains. For example computational science management of distributed database systems management of distributed computing systems for bio informatics image analysis or other applications in which very large amounts of data are to be processed or huge amounts of computational resources are required. However orchestration of complex data flows of substantial amounts of data from live streaming sources is difficult with existing approaches. Communities may be thought of as groups of one or more computing devices in a distributed computing system.

The use of distributed computing systems is becoming more widespread. Often computational processes are decomposed into multiple subprocesses which are executed on different computing systems or computational processes are divided into fragments and the fragments are spread over multiple systems to be computed. Management of these distributed computing systems is typically carried out by a single entity which owns the computational process and there is a general need to simplify and improve the manner in which the management is achieved. For example existing tools to manage scientific workflows enable a scientist to make use of remote computing resources to carry out in silico experiments. However it is difficult to enable the experiments to be managed by multiple users working on different computers at the same time in a simple and effective manner. In addition existing approaches are often unsuited to novice users who have little or no knowledge of remote computing resources that may be used.

There is an increasing need to harness the cumulative power of multiple computing devices owned by a single person e.g. an individual s laptop office desktop computer and home computer or to harness the power of grid and cloud computing. For example multiple computing devices owned by a single person or which are harnessed for a particular computing activity may be thought of as a community of computing devices. However current systems do not enable this to be achieved in a simple to use and effective manner. As a result it is difficult to engage in collaborative design development and review of scientific or technical computing projects. In addition the results of any such collaborative computations are difficult to visualize and use by executives policy makers and other users.

The embodiments described below are not limited to implementations which solve any or all of the disadvantages of known distributed computing systems.

The following presents a simplified summary of the disclosure in order to provide a basic understanding to the reader. This summary is not an extensive overview of the disclosure and it does not identify key critical elements of the invention or delineate the scope of the invention. Its sole purpose is to present some concepts disclosed herein in a simplified form as a prelude to the more detailed description that is presented later.

Distributed computing using communities is described. In an embodiment computations in a distributed computing system are driven and controlled by a document storing a distributed computing graph a graph layout view of that graph and visualization elements. For example the document is replicated and synchronized at each of a plurality of entities in the distributed computing system. In examples a community may be drawn as a rectangle or other shape in the graph layout view and represents one or more computing resources in the distributed computing system. For example by placing graphical elements representing currently executing processes into the community on the graph layout view a user is able to ensure that those processes execute using the computing resources of the community. In examples communities may be nested and may have parameters specifying conditions which are to be met by the computing resources they represent.

Many of the attendant features will be more readily appreciated as the same becomes better understood by reference to the following detailed description considered in connection with the accompanying drawings.

The detailed description provided below in connection with the appended drawings is intended as a description of the present examples and is not intended to represent the only forms in which the present example may be constructed or utilized. The description sets forth the functions of the example and the sequence of steps for constructing and operating the example. However the same or equivalent functions and sequences may be accomplished by different examples.

The entities in the distributed computing system are arranged to enable activities to be carried out in the distributed computing system under the control of one or more distributed computing graphs. An activity is one or more processes which are associated with an aim or objective. For example the activity may be an experiment a data centre management process a computational computing objective or other group of processes associated with an objective. Each activity has an associated distributed computing graph which controls currently executing processes in the distributed computing system in order to carry out the activity. Entities in the distributed computing system are aware of the distributed computing graph and this is achieved in any suitable manner. For example the distributed computing graph may be replicated at the entities. It is also possible for the distributed computing graph to be shared amongst the entities using a peer to peer distribution system of any suitable type. As described in more detail below each entity has a graph layout view of the distributed computing graph and is aware of communication protocols addresses and contracts associated with the processes assigned to the distributed computing graph.

The term distributed computing graph is used to refer to a data structure storing a plurality of nodes connected by links where each node represents a currently executing process at a specified entity in a distributed computing system. For example the process may be a computational process which takes data from one or more sources which could also be other processes and produces output. It is also possible for the process to be one which retrieves data from a source and reformats or pre processes that data so that it is suitable for a later computation process. In this case the data sourc es are specified at the node representing the process. Entities in the distributed computing system are arranged to carry out the represented processes which may be parallel concurrent or sequential using the specified entities and data sources. Each distributed computing graph is associated with an activity as described above.

For example one of the entities in the distributed computing system may be a PC operated by an end user in order to participate in a collaborative computing activity with other entities. The PC may provide a graphical user interface which displays a graph layout view of a distributed computing graph as illustrated schematically in . The end user is able to edit the graph layout view of the distributed computing graph in order to carry out a type of programming activity. Changes that the end user makes to the graph layout view cause the underlying distributed computing graph to update and thus control the currently executing processes that form the activity. End users at other entities in the distributed computing system are also able to control those currently executing processes in a collaborative manner by using graph layout views at their respective entities.

End users are also able to view the outputs of an activity. For example an entity in the distributed computing system may be a laptop computer displaying data resulting from an activity as illustrated schematically in . Various views viewports and user interface objects may be created and edited by an end user and associated with the distributed computing graph in order to achieve this. Those views viewport and user interface objects are collectively referred to in this document as a visualization layer. All the entities in the distributed computing system are aware of the visualization layer in the same manner as for the distributed computing graph.

In an example a data source such as a text file exists on a local machine operated by a user. The user is able to create or modify a graph layout view of a distributed computing graph using a user interface at an entity in the distributed computing system such as PC . This is achieved by connecting a node representing the text file to one or more other nodes representing other entities in the distributed computing system and in this way a process is added to the graph. For example these other entities may comprise a remote web service. The edge in the graph created between the text file node and the web service node may be implemented using a SOAP call to the web service to send the text file data to the web service for processing. However this is not essential. Any suitable method of implementing the edge in the graph may be used. Another process may then be added to the graph layout view of the distributed computing graph. For example this process may be a local executable file which is added as a node to the graph layout view by connecting it to the node representing the web service. This connection may be implemented using a SOAP call to the web service to pull the processed text file data from the web service. Another process may be created and a node representing it connected to the node representing the executable file. This newly added process may represent a file comprising the pulled data and is interpreted as a file by the distributed computing system. In this way a file system is effectively used to perform the process making use of remote web services. The file system and web service are examples only and may be substituted by any other suitable technology. For example databases custom executable files for computational processes reading and writing to and from files.

Within the distributed computing system processes are able to notify each other. This is implemented using any suitable notification mechanism for example using push and pull notification mechanisms or publish and subscribe mechanisms. Once a process is completed for example the web service call is finished in the above example a local representation of the process actively sends out to all entities in the distributed computing system a notification to indicate this using the particular notification mechanism being used.

Any suitable methods may be used to enable the processes and the local graph nodes to communicate. For example an application programming interface is provided at each entity. This may be used by a programmer to link a process to a local graph item. For example the application programming interface provides a set of contracts and communication mechanisms to be used by local representations of processes in the graph layout views to communicate with one another in the distributed computing system. In this way the graph layout view of a process may be thought of as a wrapper which enables a process to talk to one or more other graph items. Thus process events such as process notification process error process completion may be communicated to other graph items. Whether two processes are able to communicate may be specified by details in the wrappers.

It is possible for the graph layout view to contain visual elements that are not represented in the distributed computing graph. For example comments titles callouts and other visual elements which do not affect computation but which enhance a user s understanding of the graph.

The graph layout view of the distributed computing graph comprises nodes connected by links. At least some of the nodes represent processes carried out at specified entities in a distributed computing system. For example node represents a process carried out at machine A for example this might be to retrieve data node represents a process carried out at machine B for example to carry out computations using the data from node A and node represent processes carried out at machine C of for example to carry out computations on the results provided by node B . Node may represent processes to retrieve or format data from entity D. Nodes and may be in a community . A community is represented as a visually distinguished region on a graph layout view of the distributed computing graph. For example the community may be represented as a rectangle or other shape enclosing graphical elements in the graph layout view. When a user drags a community onto the graph layout view it appears as a rectangular region that can be moved or sized. A user is able to drag nodes representing currently executing processes into the graph layout view and place those either outside or inside a community. Nodes placed outside a community will be executed on the local computer which is providing the graph layout view in this example machine A . Nodes placed inside a community rectangle are executed remotely on the resources of that community. Any suitable ones of the community resources are used in a manner that is transparent to the user who edits the graph layout view. In addition the particular resources in the community that are used may change over time without the user who edits the graph layout view being aware of that change. A user editing the graph layout view is thus able to specify which processes are to be executed at a community resource without the need for detailed knowledge about entities that make up that community. By representing communities graphically in the graph layout view and providing the dynamic updating between the graph layout view and the underlying distributed computing graph it is possible to harness the computing power of grid and cloud computing in a simple and effective manner. In addition a user is able to harness computing power from a community which is formed from his or her own computing devices.

Another example of a community is given in which shows entities within dotted line forming a community. For example a scientist may need to carry out a new experiment and may set up a community comprising users resources and data. The users may comprise the scientist and his or her assistant. The resources may comprise the scientist s research computer home computer laptop and the assistant s research computer. The scientist specifies one or more data sources. The scientist may belong to a plurality of different communities. In the example of database and entity are outside the community and are unable to access any resources of the community. However entities within the community may be able to access database and entity outside the community by using appropriate credentials or in other manners.

As described above with reference to an entity in the distributed computing system may comprise a user interface which provides a facility to view and modify communities. For example shows an example user interface display which may be provided at local machine A of for example. In this example the user at local machine A is a member of two communities which are illustrated schematically. The user interface display provides details about the communities such as the number of members in a community the number of workspaces a given community has and an average daily population of active members in the community. A workspace is associated with one or more activities such as an experiment or other computational computing activity and a given community may comprise one or more workspaces. Each activity has its own distributed computing graph and is able to access all resources within its associated communities. A distributed computing graph is limited to the scope of its associated activity and so is not part of two different activities.

A visualization layer is illustrated in . This layer is optional and enables a display of outputs from an activity to be easily created and managed. The visualization layer may comprise any combination of views view ports and user interface objects. For example these views view ports and user interface objects are connected to nodes in the distributed computing graph using a suitable application programming interface. This enables data output from the processes represented by the nodes of the distributed computing graph to be directly provided to the visualization layer. For example shows a web page displaying data from process A of the distributed computing graph. It also shows a graphical user interface display comprising a button that may be activated or deactivated depending on data output from process B of the distributed computing graph. A ranked list of documents may also be presented at this graphical user interface display using output from process D of the distributed computing graph.

Each participant in an activity has access to the associated distributed computing graph even if that participant does not host any parts of that activity. The graph layout view is maintained in parallel with the distributed computing graph so that it corresponds to the distributed computing graph. If a change is made to the graph layout view of the distributed computing graph this change is dynamically updated in the distributed computing graph itself and so is updated in the graph layout view at each of the entities in the distributed computing system. That is the graph layout view always reflects changes made by others in the distributed computing system.

As mentioned above each participant in an activity has access to the associated distributed computing graph even if that participant does not host any parts of that activity. For example a participant may require only to view the output of an experiment. In this case the participant connects to the distributed computing graph concerned but does not provide any input data storage processing capabilities or other resources for sharing.

Metadata may be coupled to a community as now described with reference to . The bottom part of shows a distributed computing graph and the top part shows a graph layout view of that distributed computing graph. In this example the graph layout view comprises two communities a research community and a home computing community . A currently executing process or task at a local machine which provides the graph layout view is able to receive data input from these two communities as indicated by the graph layout view. The Home community has a task currently executing on resources of that community which might be a user s home computer for example. The research community has currently executing processes running on a plurality of research computers at various geographical locations which form that community . The research community has associated metadata which may comprise account and login requirements or other credentials that are needed in order to access the community. This metadata may be stored with the community as described in more detail later in this document.

In order to enable data to successfully cross a community boundary adaptations are made to the distributed computing graph in an automated manner without the need for user input. These adaptations are not necessarily displayed as part of the graph layout view.

In addition the graph engine at the entities on either side of a community boundary are also arranged to implement marshalling also known as data transformation for the data flow. As mentioned above the graph layout view of a process may be thought of as a wrapper which enables a process to talk to one or more other graph items. Whether two processes are able to communicate may be specified by details in the wrappers. This information may be used by the graph engine to automatically insert intermediaries to the distributed computing graph in order to transform the data as required in order to enable process to be connected across a community boundary.

As illustrated in communities may be nestable. shows a graph layout view of a distributed computing graph which is the same as that from except that the research community now contains a nested community . The nested community has a parameter which is set to GPU graphics processing unit so that GPUs within the research community are members of the nested community. In this way a user is able to specify that currently executing processes are to be carried out on GPUs of the research community by placing the nodes for those processes within the nested community .

A community may have one or more parameters which are stored with that community. In the example of the nested community has a parameter specifying that hardware of the community resources is to be GPUs. Other types of parameters may also be used to specify requirements about hardware also referred to as resource class capacity functionality security geographical location or other factors. shows an example where an ad hoc grid computing community has community parameters . This community supports a plurality of processes illustrated by nodes in the community some of which are within a nested community for GPUs of the ad hoc grid community. A local computer supports task which communicates with the ad hoc grid community and also with a home community . An example of a parameter to specify requirements about capacity is computers with a specified amount of available disk space.

Parameters may be used to specify requirements about numbers or proportions of computing devices to be used in a community. For example shows a community of high performance computers in a cluster connected to a task at a local machine. The community has two nested communities each having a 50 allocation parameter such that they each have 50 of the computing resources available in the community . For example by using community parameters to specify requirements about numbers or proportions of computing devices it is possible to ensure that communities are used only if they contain a certain quorum of resources. For example community parameters may be used to ensure that a community on a graph layout view becomes active when it is possible to reserve a specified number of CPUs.

The community control document is stored as a distributed document available to each of the community members. Any suitable storage mechanism may be used and two examples are now described with reference to .

As a community adapts and changes it may be beneficial to switch between the publication community storage mechanism of and the participation community storage mechanism of . For example an entity in the distributed computing system may be arranged to monitor the ratio of members of a community who are readers to members who are writers. With reference to a distributed community control document is stored using a publication community mechanism or a participation community mechanism . Community members leave or join the community and resulting updates to the community control document are made available to the community members . The creator owner or administrator of a community might make reasonable predictions of the makeup of a community for example expecting more readers than writers or might observe the evolution of an existing community over time and choose to transition the community from participatory storage to centralized web server based storage. The creator owner or administrator can choose to initially create the community using one or the other storage mechanism or transition from one storage mechanism to the other without requiring action on the part of other community members. In this way such administrative transitions are able to occur without any change in experience becoming apparent to community members. Such a change is carried out by marking the old community control document with a reference to the new location.

Users may discover and join communities as now described with reference to . A user discovers a community by finding an address such as a URL or other address at which the community control document for that community is available. For example this may be by checking a well known web directory service or by participating in a peer to peer distributed directory system. It is also possible to receive an invitation to join the community for example by receiving an invitation message from a current member. Once a community has been discovered a user may join that community after credentials checks or other access control checks and receive access to the distributed community control document. A community may be publicized through newsgroups social networking postings web pages or in other ways.

Users may create communities as now described with reference to . A user creates a community control document and specifies any access control details for the community in that document. The user then publicizes or announces the existence of the community and invites new members to join.

As mentioned above an entity in the distributed computing system may comprise a reputation system. The reputation system may operate using a points system or equivalent to rate any one or more of users communities and extensions.

Extensions are units of code that are written to a particular application programming interface and which extend the functionality of a graph engine in some way. Extensions may be distributed via file system e.g. disk CD thumb drive or network or via communities. A community may contain extensions which may be added to a workspace and then used in any activity created in that workspace. Any extension that is added to a community is available to anyone in that community. Any extension that is added to an activity within a workspace within a community has a copy of that extension stored by reference within the activity. Where ever that activity is replicated copied or moved the extension goes with it because the activity relies on some aspect of that extension. Extensions are intended to be run in a sandbox with no direct access to local disk storage or local registry extensions are able to store data back into an activity document.

Any user in a community may comment on or rate an extension in the community. The rating may be explicit for example by a user giving input specifying the rating. The rating may also be implicit and inferred by the reputation system by observing how often an extension is used. By this mechanism extensions gain or lose reputation among community members. For example there may be 10 statistical extensions in a community and the good ones will quickly rise in reputation.

In order to replicate and synchronize the activity document at each entity in a simple and effective manner a particular type of data structure is used to store the document. This data structure is a semi structured store which is created by forming a tree based representation of the document and then storing nodes of the tree and properties associated with those nodes as rows in a relational database table. This data structure is particularly beneficial in allowing fine scale and accurate version control and conflict resolution. For example if two users simultaneously make changes to the activity document any conflicting changes can be detected at a fine scale and either resolved or addressed by branching the document into two.

As mentioned above an activity comprises a graph layout view a distributed computing graph and a visualization layer comprising views and viewports. Each of these may be stored as a document as mentioned above so that a complete activity may itself be stored as a document. A tree data structure is used to store the activity document as now described with reference to .

An activity is stored as a root node having a plurality of child nodes one for each of the graph layout view document distributed computing graph document and views and viewports document. Each of those child nodes itself has a plurality of child nodes representing lower level components of the documents. Each child node may have more children such as nodes in and so on in order to represent all components of the documents to a fine level of detail. Associated with each node are properties such as a date when that component was created a date when it was last modified its previous value or other properties. A relational database table is then created with data for each node and each property being stored in a separate row of the table.

For example activity document may be stored as a hierarchy of rows in a relational database table. Each row may be a NamedObject AttributedObject Symbol or a ContainerObject. A named object is simply a name and no value. An AttributedObject is a NamedObject which has associated with it a list of properties attributes each of which is a Symbol. A Symbol is a name value pair. A ContainerObject is a special type of AttributedObject that can contain other named objects similar to a folder . Each row in the database also contains version information and a globally unique replication identifier that work together to facilitate replication among different readers writers on a document and to facilitate version control so that documents edited by two people can be merged at a very fine level rather than having the documents simply be the same or different . For instance if a graph layout view has five elements on it and user A moves one and user B moves another those two changes can safely be merged together as can any changes that do not touch the same row in the database. Any changes which do touch the same row for instance two users changing the same title or moving a flow connection have to be merged. If the changes result in the same value or end result they may be silently merged but if they conflict in some way then one user must chose to either accept one change or the other or branch the document into two new documents that are now no longer merged.

In many cases processes in the distributed computing system run much longer than an individual user s laptop may be turned on for. For example a user may start a computation that runs in a high performance computer community and then close his or her laptop. Later when the user starts up the laptop it is updated with the latest data from the ongoing computation.

Each part of a computation each community participant has its own graph engine which manages the local computation. Each participant has its own copy of the controlling document the activity for the ongoing computation. Computations are driven and controlled by the document not by any one computer so it is possible to start a computation by opening a document on one computer and then open the same document on another computer and see the current data. In this way a decentralized document is provided to control a distributed or cloud computing system. Data may also be stored via the document either in a local location that is replicated to other participants or in a shared well known location like a cloud store . These things all work together to create documents that appear to run on the cloud and which appear to continue to run even when a user is not actively watching controlling them. Documents may stop computing when they have either reached their cache limits or when the calculations naturally wind down.

With reference to if two or more changes are received simultaneously at the activity document then a check is made for any conflict using a data synchronization system. If the changes produce the same end result then the changes are merged . If the changes conflict then user input is requested and or two versions of the activity document are created . The branch version of the document can later be merged back with the main document or can continue to exist as a distinct document. The relational database table also allows users to go back in time and recover a previous version of any document.

Computing based device also comprises one or more processors which may be microprocessors controllers or any other suitable type of processors for processing computing executable instructions to control the operation of the device in order to operate as part of a distributed computing system. Platform software comprising an operating system or any other suitable platform software may be provided at the computing based device to enable application software to be executed on the device. The computing based device comprises a graph engine which implements a dynamic mapping with a distributed computing graph as described herein. A visualization component may be provided to implement a visualization layer associated with the distributed computing graph. A data store may be provided to buffer store or cache data.

The computer executable instructions may be provided using any computer readable media that is accessible by computing based device . Computer readable media may include for example computer storage media such as memory and communications media. Computer storage media such as memory includes volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EPROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that can be used to store information for access by a computing device. In contrast communication media may embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism. Although the computer storage media memory is shown within the computing based device it will be appreciated that the storage may be distributed or located remotely and accessed via a network or other communication link e.g. using communication interface .

The computing based device also comprises an input output controller arranged to output display information to a display device which may be separate from or integral to the computing based device . The display information may provide a graphical user interface. The input output controller is also arranged to receive and process input from one or more devices such as a user input device e.g. a mouse or a keyboard . This user input may be used to influence or select data to be presented on the display device . In an embodiment the display device may also act as the user input device if it is a touch sensitive display device. The input output controller may also output data to devices other than the display device e.g. a locally connected printing device.

The term computer is used herein to refer to any device with processing capability such that it can execute instructions. Those skilled in the art will realize that such processing capabilities are incorporated into many different devices and therefore the term computer includes PCs servers mobile telephones personal digital assistants and many other devices.

The methods described herein may be performed by software in machine readable form on a tangible storage medium. Examples of tangible or non transitory storage media include disks thumb drives memory etc and do not include propagated signals. The software can be suitable for execution on a parallel processor or a serial processor such that the method steps may be carried out in any suitable order or simultaneously.

This acknowledges that software can be a valuable separately tradable commodity. It is intended to encompass software which runs on or controls dumb or standard hardware to carry out the desired functions. It is also intended to encompass software which describes or defines the configuration of hardware such as HDL hardware description language software as is used for designing silicon chips or for configuring universal programmable chips to carry out desired functions.

Those skilled in the art will realize that storage devices utilized to store program instructions can be distributed across a network. For example a remote computer may store an example of the process described as software. A local or terminal computer may access the remote computer and download a part or all of the software to run the program. Alternatively the local computer may download pieces of the software as needed or execute some software instructions at the local terminal and some at the remote computer or computer network . Those skilled in the art will also realize that by utilizing conventional techniques known to those skilled in the art that all or a portion of the software instructions may be carried out by a dedicated circuit such as a DSP programmable logic array or the like.

Any range or device value given herein may be extended or altered without losing the effect sought as will be apparent to the skilled person.

It will be understood that the benefits and advantages described above may relate to one embodiment or may relate to several embodiments. The embodiments are not limited to those that solve any or all of the stated problems or those that have any or all of the stated benefits and advantages. It will further be understood that reference to an item refers to one or more of those items.

The steps of the methods described herein may be carried out in any suitable order or simultaneously where appropriate. Additionally individual blocks may be deleted from any of the methods without departing from the spirit and scope of the subject matter described herein. Aspects of any of the examples described above may be combined with aspects of any of the other examples described to form further examples without losing the effect sought.

The term comprising is used herein to mean including the method blocks or elements identified but that such blocks or elements do not comprise an exclusive list and a method or apparatus may contain additional blocks or elements.

It will be understood that the above description of a preferred embodiment is given by way of example only and that various modifications may be made by those skilled in the art. The above specification examples and data provide a complete description of the structure and use of exemplary embodiments of the invention. Although various embodiments of the invention have been described above with a certain degree of particularity or with reference to one or more individual embodiments those skilled in the art could make numerous alterations to the disclosed embodiments without departing from the spirit or scope of this invention.

