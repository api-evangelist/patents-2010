---

title: Displaying a visual representation of performance metrics for rendered graphics elements
abstract: The present disclosure describes various techniques for displaying a visual representation of performance metrics for rendered graphics elements. One example method comprises receiving performance information provided by a graphics processing unit, wherein the performance information has been measured by the graphics processing unit in association with individual graphics elements for rendering a graphics scene, and computing values of a performance metric for the graphics elements based upon the performance information, wherein each computed value is associated with at least one of the graphics elements. The method further comprises assigning graphical identifiers to the graphics elements based upon the computed values of the performance metric for the graphics elements, wherein one of the graphical identifiers is assigned to each of the graphics elements, and displaying the graphics elements, when rendering the graphics scene, according to the graphical identifiers that are assigned to the graphics elements.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08471858&OS=08471858&RS=08471858
owner: QUALCOMM Incorporated
number: 08471858
owner_city: San Diego
owner_country: US
publication_date: 20100601
---
This application claims the benefit of U.S. Provisional Application 61 183 476 filed on Jun. 2 2009 the entire content of which is incorporated herein by reference.

Graphics processors are widely used to render two dimensional 2D and three dimensional 3D images for various applications such as video games graphics programs computer aided design CAD applications simulation and visualization tools and imaging. Display processors may be used to display the rendered output of the graphics processor for presentation to a user via a display device.

Graphics applications such as 3D graphics applications may describe or define contents of a scene by invoking application programming interface API calls or instructions which in turn use the underlying graphics hardware such as one or more processors in a graphics device to generate an image. The graphics hardware may undergo a series of state transitions that are exercised through the invocation of these APIs. A full set of states or state transitions for each API call such as a draw call or instruction may describe the process with which the image is rendered by the hardware.

In the development of an embedded hardware accelerated graphics application it is often difficult to quantify many aspects of how individual graphics elements e.g. meshes polygons or other graphical primitives are processed by a graphics processing unit GPU hardware device. Such aspects of GPU processing such as the number of clock cycles devoted to the element stalls incurred in its rendering memory bandwidth consumed etc. constitute highly valuable information for an application developer.

The present disclosure describes various techniques for providing a performance analysis application that may be used to display a visual representation of performance metrics for rendered graphics elements. The analysis application may in some cases be used by developers who are writing multimedia applications for platforms that make use of certain application programming interfaces APIs such as Open Graphics Library OpenGL OpenGL for embedded systems OpenGL ES or OpenVG vector graphics APIs. The analysis application may allow an application developer to visualize a large set of properties of the processing of individual 2D or 3D elements that are rendered by graphics processing hardware. Information gleaned from this process may help the developer more effectively tune design or performance characteristics of the developed application in order to run more efficiently on a targeted hardware platform.

In some instances the analysis application may enable the capture of one or more large sets of performance measurements from a target device such as a mobile or other device for each individual graphics element that is rendered in a graphics scene. The target device may be the device or device class on which the graphics application is intended to operate. The application may allow a developer to graphically visualize performance metrics on a development device based upon received performance data. The development device may comprise the actual device that collects the performance data or a separate device e.g. a personal computer that serves as an emulator or simulator of the actual device .

One example method comprises receiving performance information provided by a graphics processing unit wherein the performance information has been measured by the graphics processing unit in association with individual graphics elements for rendering a graphics scene and computing values of a performance metric for the graphics elements based upon the performance information wherein each computed value is associated with at least one of the graphics elements. The method further comprises assigning graphical identifiers to the graphics elements based upon the computed values of the performance metric for the graphics elements wherein one of the graphical identifiers is assigned to each of the graphics elements and displaying the graphics elements when rendering the graphics scene according to the graphical identifiers that are assigned to the graphics elements.

One example device includes a display device and one or more processors. The one or more processors are configured to receive performance information provided by a graphics processing unit wherein the performance information has been measured by the graphics processing unit in association with individual graphics elements for rendering a graphics scene and to compute values of a performance metric for the graphics elements based upon the performance information wherein each computed value is associated with at least one of the graphics elements. The one or more processors are further configured to assign graphical identifiers to the graphics elements based upon the computed values of the performance metric for the graphics elements wherein one of the graphical identifiers is assigned to each of the graphics elements and to display on the display device the graphics elements when rendering the graphics scene according to the graphical identifiers that are assigned to the graphics elements.

One example computer readable storage medium includes instructions for causing one or more programmable processors to receive performance information provided by a graphics processing unit of a graphics device wherein the performance information has been measured by the graphics processing unit in association with individual graphics elements for rendering a graphics scene and to compute values of a performance metric for the graphics elements based upon the performance information wherein each computed value is associated with at least one of the graphics elements. The computer readable storage medium further includes instructions to assign graphical identifiers to the graphics elements based upon the computed values of the performance metric for the graphics elements wherein one of the graphical identifiers is assigned to each of the graphics elements and to display the graphics elements when rendering the graphics scene according to the graphical identifiers that are assigned to the graphics elements.

The techniques described in this disclosure may be implemented in hardware software firmware or any combination thereof. If implemented in software the software may be executed in a processor which may refer to one or more processors such as a microprocessor application specific integrated circuit ASIC field programmable gate array FPGA or digital signal processor DSP or other equivalent integrated or discrete logic circuitry. Software comprising instructions to execute the techniques may be initially stored in a computer readable medium and executed by a processor.

Accordingly this disclosure also contemplates computer readable media comprising instructions to cause a processor to perform any of a variety of techniques as described in this disclosure. In some cases the computer readable medium may form part of a computer program product which may be sold to manufacturers and or used in a device. The computer program product may include the computer readable medium and in some cases may also include packaging materials.

The details of one or more aspects are set forth in the accompanying drawings and the description below. Other features objects and advantages will be apparent from the description and drawings and from the claims.

Graphics device may comprise a computing device and may also be part of a personal computer or a laptop device. Graphics device may also be included in one or more integrated circuits or chips chipsets which may be used in some or all of the devices described above. shows an example of performance analysis application being executed in a device that is separate and distinct from graphics device . In other cases such as in the example shown in a performance analysis application may also be executed or implemented directly within a graphics device as described in more detail with reference to .

In some cases graphics device may be capable of executing or implementing various applications such as graphics applications video applications audio applications and or other multimedia applications. For example graphics device may be used for graphics applications video game applications video playback applications digital camera applications instant messaging applications video teleconferencing applications mobile applications or video streaming applications.

Graphics device may be capable of processing a variety of different data types and formats. For example graphics device may process still image data moving image video data or other multimedia data as will be described in more detail below. The image data may include computer generated graphics data. In the example of graphics device includes a graphics processing system a storage medium which comprises memory and a display device .

Processors and may be included within graphics processing system . Processor is a control or general purpose processor. Processor is a graphics processor processor is a vertex processor and processor is a display processor. Control processor may be capable of controlling graphics processing unit vertex processor and or display processor . In one example graphics processing system may include other processors including other media processors e.g. an audio engine . In some cases graphics processing system may not include vertex processor when graphics device does not provide vertex processing capabilities e.g. if graphics device does not implement processing for OpenVG .

In graphics device graphics processing system is coupled both to storage medium and to display device . Storage medium may include any permanent or volatile memory that is capable of storing instructions and or data. Storage medium may comprise synchronous dynamic random access memory SDRAM read only memory ROM non volatile random access memory NVRAM embedded dynamic random access memory eDRAM static random access memory SRAM or flash memory. Display device may be any device capable of displaying image data for display purposes such as an LCD liquid crystal display plasma display device or other display device.

Vertex processor is capable of managing vertex information and processing vertex transformations. In one example vertex processor may comprise a digital signal processor DSP . Graphics processing unit may be a dedicated graphics rendering device utilized to render manipulate and display computerized graphics. Graphics processing unit may implement various complex graphics related algorithms. For example the complex algorithms may correspond to representations of two dimensional or three dimensional computerized graphics. Graphics processing unit may implement a number of so called primitive graphics operations such as forming points lines and triangles or other polygon surfaces to create complex three dimensional images on a display such as display device .

Graphics processing unit may carry out commands that are stored in storage medium . Storage medium is capable of storing application instructions for an application such as a graphics or video application as well as one or more graphics drivers . Application instructions may be loaded from storage medium into graphics processing system for execution. For example one or more of control processor graphics processing unit and display processor may execute instructions . In one example application instructions may comprise one or more downloadable modules that are downloaded dynamically over the air into storage medium . In one example application instructions may comprise a call stream of binary instructions that are generated or compiled from application programming interface API instructions created by an application developer.

Graphics drivers may also be loaded from storage medium into graphics processing system for execution. For example one or more of control processor graphics processing unit and display processor may execute certain instructions from graphics drivers . In one example aspect graphics drivers are loaded and executed by graphics processing unit . Graphics drivers will be described in further detail below.

As also shown in graphics processing system includes one or more buffers . Control processor graphics processing unit vertex processor and or display processor each have access to buffers and may store data in or retrieve data from buffers . Buffers may comprise cache memory and may be capable of storing both data and instructions. For example buffers may include one or more of application instructions or one or more instructions from graphics drivers that have been loaded into graphics processing system from storage medium . Buffers and or storage medium may also contain graphics data used during instruction execution.

Applications instructions may in certain cases include instructions for a graphics application such as a 3D graphics application. Application instructions may comprise instructions that describe or define contents of a graphics scene that includes one or more graphics objects. When application instructions are loaded into and executed by graphics processing system graphics processing system may undergo a series of state transitions. One or more instructions within graphics drivers may also be executed to render or display rendered graphics elements on display device during executing of application instructions . Each individual element may be rendered during execution of a particular draw command which causes the rendered element to be drawn on a display.

A full set of states for an instruction such as a draw call may describe a process with which an element is rendered by the draw call or command within graphics processing system . However an application developer who has written application instructions may often have limited ability to interactively view or modify these states for purposes of debugging or experimenting with alternate methods of describing or rendering elements in a defined scene. In addition different hardware platforms may have different hardware designs and implementations of these states and or state transitions.

Thus in one example an application developer may use application computing device shown in to assist in the processing of debugging and experimenting with alternate methods for describing or rendering images in a scene. Application computing device is coupled to graphics device . For example in one example application computing device is coupled to graphics device via a Universal Serial Bus USB connection. In other aspects other types of connections such as wireless or other forms of wired connections may be used.

Application computing device includes one or more processors a display device and a storage medium . Processors may include one or more of a control processor a graphics processor a vertex processor and a display processor according to one aspect. Storage medium may include any permanent or volatile memory that is capable of storing instructions and or data. Storage medium may comprise synchronous dynamic random access memory SDRAM read only memory ROM non volatile random access memory NVRAM static random access memory SRAM or flash memory. Display device may be any device capable of displaying image data for display purposes such as an LCD liquid crystal display plasma display device or other display device.

In the development of certain applications such as embedded hardware accelerated graphics applications it is often difficult or impossible to quantify many aspects of how individual graphics elements e.g. meshes polygons or other graphical primitives are processed by graphics processing unit on graphics device . Such aspects of graphics processing such as for instance the number of clock cycles devoted to the element in graphics processing unit stalls incurred in its rendering memory bandwidth consumed etc. may comprise highly valuable information for an application developer yet are typically unavailable during actual application development. Without having detailed insight into the detailed activity of graphics processing unit a developer may miss opportunities for optimization misdirect tuning efforts and or be forced to degrade visual quality in order to meet performance targets and schedules.

Thus as shown in application computing device is capable of capturing and analyzing graphics commands along with state and or performance information which is sent from graphics device . In one example graphics drivers are configured to send graphics commands and state performance information to application computing device . Graphics commands may include one or more of application instructions and state performance information may be generated or captured during execution or implementation of graphics commands within graphics processing system .

State performance information includes information about the state and performance of graphics processing system during instruction execution or implementation and will be described in more detail below. State performance information may include graphics data e.g. primitive and or rasterized graphics data that may be used or is otherwise associated with graphics commands . Graphics processing system may execute graphics commands to display an image or a scene of rendered graphics elements on display device . Application computing device is capable of using graphics commands along with state performance information to create the graphics image or scene that may in some cases also be shown on display device of graphics device .

Performance analysis application may be executed by processors of application computing device to create the graphics image or scene of rendered elements upon receipt of graphics commands and state performance information and display the rendered elements on display device . Performance analysis application may comprise a software module that contains a number of application instructions. Performance analysis application is stored in storage medium and may be loaded and executed by processors . Performance analysis application may be pre loaded into storage medium and may be customized to operate with graphics device . In one example performance analysis application simulates the hardware operation of graphics device and provides graphical information that may represent one or more aspects of state performance information .

Different versions of performance analysis application may be stored in storage medium and executed by processors for different graphics devices having different hardware designs. In some cases software libraries may also be stored within storage medium which are used in conjunction with performance analysis application . In one example performance analysis application may be a generic application and specific hardware or graphics device simulation functionality may be included within each separate library that may be linked with performance analysis application during execution.

For example a first library may provide simulation functionality for a first specific type of graphics device e.g. one contained within a first type of wireless communication handset while a second different library may provide simulation functionality for a second different type of graphics device that has a different hardware architecture that the first graphics device. Each of these libraries may be stored within storage medium and may be separately linked in with performance analysis application during execution to simulate either the first or second graphics device. As a result performance analysis application or different versions of such an application upon execution is capable of simulating various different types of graphics device on application computing device .

In one example a visual representation of state performance information may be displayed to application developers on display device of application computing device . In addition a visual representation of graphics commands may also be displayed. Because in many cases graphics commands may comprise binary instructions application computing device may use performance analysis application to generate the visual representation of graphics commands on display device . Performance analysis application is stored within storage medium and may be loaded into processors in order to display a visual representation of graphics commands .

In one example performance analysis application may provide functionality to map graphics commands to corresponding API instructions that may have been previously compiled when generating graphics commands . Application developers may write programs that use API instructions but these API instructions are typically compiled into binary instructions such as graphics commands for execution on graphics device .

One or more instructions within graphics commands may be mapped to an individual API instruction. The mapped API instructions may then be displayed to an application developer on display device to provide a visual representation of the graphics commands that are actually being executed. In some cases performance analysis application may utilize mapping information in order to perform such mapping. Such mapping information may be stored for instance within storage medium . The mapping information may be provided in some cases from graphics device and may also be pre programmed on application computing device in other cases.

In one example a user such as an application developer may wish to change one or more of the graphics commands to determine for example the effects of such changes on performance. In such cases application computing device may optionally provide requested modifications such as modifications to commands that are to be executed to graphics device as will be described in more detail below.

As described above the graphics image or set or rendered elements displayed on display device may also be displayed on graphics device . Because performance analysis application may use graphics commands and state performance information to create a scene of rendered graphics elements exactly as presented on graphics device application developers that use application computing device may be able to quickly identify potential performance issues or bottlenecks during execution of graphics applications and even prototype modifications to improve the overall performance of graphics applications .

For example an application developer may optionally choose to make one or more requested modifications to graphics commands and or state performance information during execution of performance analysis application on application computing device and display of the image on display device . Any such requested modifications may be based upon observed performance issues or bottlenecks during execution of graphics commands or analysis of state performance information . These requested modifications may then be sent from application computing device to graphics device where they are processed by graphics processing system . In one example one or more of graphics drivers are executed within graphics processing system to process requested modifications . Requested modifications in some cases may include modified commands. In some cases requested modifications may include modified state and or performance information.

Upon processing of requested modifications updated instructions and or information is sent back to application computing device such as by one or more of graphics drivers . Updated commands information may include updated graphics instructions for execution based upon requested modifications that were processed by graphics device . Updated commands information may also include updated state and or performance information based upon the requested modifications that were processed by graphics device .

The updated commands information is processed by performance analysis application to update the display of the image information or rendered graphics elements on display device and also may provide a visual representation of updated commands information to the application developer which may include again using performance analysis application . The application developer may then view the updated image information on display device as well as the visual representation of updated commands information to determine if the performance issues have been resolved or mitigated. The application developer may use an iterative process to debug graphics commands or prototype modifications to improve the overall performance graphics applications .

Thus performance profiling application may be used as an application development tool by content developers e.g. video game developers who are writing multimedia applications for embedded platforms that make use of certain APIs such as OpenGL OpenGL ES or OpenVG APIs. The use of performance analysis application may allow an application developer to measure and visualize a large set of properties of the processing of individual 2D or 3D elements by the graphics processing hardware of graphics processing unit . Information gleaned from this may help the developer more effectively tune design or performance characteristics of the application in order to run more efficiently on a targeted hardware platform e.g. platform provided by graphics device in .

Performance analysis application enables the capture of one or more large sets of performance measurements from graphics device per each individual rendered element e.g. per draw command per graphics primitive per vertex per pixel fragment . Performance analysis application may allow the developer to graphically visualize performance metrics on a development device such as application computing device based upon performance measurements e.g. state performance information received from graphics device . In some cases each draw command is capable of rendering during execution of one or more graphics primitives vertices pixel fragments or any portions combinations thereof.

For example when a draw command included within application instructions is executed by graphics processing unit one or more of graphics drivers may obtain the values of one or more counters of graphics processing unit that encompasses the work performed by graphics processing unit in order to execute the draw command. One or more of these counters may comprise a low level hardware counter that may be sampled and aggregated with other counters or measurements from graphics processing unit or other components of graphics processing system such that performance analysis application can compute the high level performance metrics. The counter values may be included within state performance information that is sent to application computing device . State performance information may further include data needed by performance analysis application to recreate graphics commands in an emulation environment including function call parameters render state geometrical data textures shaders and the like.

In one aspect of the disclosure performance analysis application during execution may receive performance information e.g. included within state performance information that has been provided by graphics processing unit . The performance information has been measured by graphics processing unit is association with individual graphics elements for rendering a graphics scene. For example the graphics elements may be draw commands e.g. commands included within application instructions to render a graphics scene. In some cases the graphics elements may comprise graphics primitives vertices and or pixel fragments.

Upon receipt of the performance information performance analysis application may compute values of a performance metric for the graphics elements based upon the performance information where each computed value is associated with at least one of the graphics elements. For example as will be described further below a specified performance metric may comprise a high level performance measurement such as a metric for pixels written per clock cycle a metric for shader instructions issued per vertex and or a metric for the number of memory writes executed per second to name only a few examples.

As will also be described further below performance analysis application may assign graphical identifiers e.g. colors shading cross hatching identifiers other graphical identifiers to each of the graphics elements based upon the computed values of the performance metric for the graphics elements and may process the graphics elements to render the graphics scene for purposes of display such as on display device . One of the graphics identifiers may be assigned to each of the graphics elements. In such fashion performance analysis application is capable of displaying rendered graphics elements during processing of the graphics elements e.g. during execution of draw commands and visually displaying such elements according to the graphical identifiers that are assigned to the graphics elements.

The display of such information may in many cases assist an application developer in directly and precisely measuring a large set of properties of the processing of individual graphics elements e.g. 2D or 3D objects by graphics processing unit and easily viewing a representation of such measurements on display device . The displayed information may also help the developer more effectively tune design or performance characteristics of application instructions to run more efficiently on the target hardware platform provided by graphics device .

For example the developer may tune various aspects of the application to determine if any changes may improve one or more performance characteristics of the executed application upon inspection of an updated visual representation of performance metrics for rendered elements on display device . The developer may also utilize performance analysis application to modify one or more of the commands which are included within requested modifications sent from application computing device to graphics device as described above. An updated display of performance metrics for the rendered elements may then be provided on display device upon receipt of updated commands information .

Graphics processing system includes a control processor a graphics processing unit one or more buffers an optional vertex processor and a display processor . Graphics processing system includes vertex processor when system provides vertex processing operations.

Storage medium similar to storage medium shown in includes application instructions and graphics drivers . However unlike storage medium storage medium includes a performance analysis application which may be loaded into and executed by one or more of the processors units in graphics processing system .

Performance analysis application may operate similarly to performance analysis application shown in . However in the example of the same device i.e. graphics device that actually executes application instructions within the device also executes performance analysis application . Hence no separate application computing device is needed or shown in the example of .

Graphics device of may have various operational modes. For example in a main mode graphics processing system may execute or implement application instructions and or graphics drivers in a main operational mode without the use of performance analysis application . However in a different e.g. test emulation simulation mode graphics processing system may further execute or implement performance analysis application . A developer may be able to directly view the results and output of performance analysis application in display device .

Thus performance analysis application may be used as an application development tool by content developers e.g. video game developers who are writing multimedia applications for embedded platforms that make use of certain APIs such as OpenGL OpenGL ES or OpenVG APIs. The use of performance analysis application may allow an application developer to measure and visualize a large set of properties of the processing of individual 2D or 3D elements by the graphics processing hardware of graphics processing unit directly on display device . Information gleaned from this may help the developer more effectively tune design or performance characteristics of the application in order to run more efficiently on a targeted hardware platform e.g. platform provided by graphics device in .

Performance analysis application enables the capture of one or more large sets of performance measurements from graphics device per each individual rendered element e.g. per draw command per graphics primitive per vertex per pixel fragment . Performance analysis application may allow the developer to graphically visualize performance metrics directly on graphics device without the need for another separate application computing device based upon performance measurements received from graphics processing unit .

In one aspect outgoing pixel fragments can obtain their values directly from performance counter data such as performance counter data provided by graphics processing unit during the implementation or execution of performance analysis application . In some cases a fragment shader engine implemented by graphics processing system e.g. by graphics processing unit and or display processor could be given access to one or more performance counters by exposing special registers to shader code. Pixel fragment values may be based upon or derived from the data in the special registers. Blending hardware in graphics processing system may accumulate or combine those pixel fragments upon a frame buffer since multiple pixel fragments can be located at the same screen coordinate. Thus graphical identifiers e.g. colors cross hatching shading patterns that are assigned to the pixel fragments may be determined by using blending to combine multiple ones of the pixel fragments based upon values of one or more of the counters e.g. counters of graphics processing unit .

As shown in graphics processing system includes four programmable processors control processor optional vertex processor graphics processing unit and display processor which are also shown in . Control processor may control any of vertex processor graphics processing unit or display processor . In many cases these processors and may be part of a graphics processing pipeline within system .

Control processor may control one or more aspects of the flow of data or instruction execution through the pipeline and may also provide geometry information for a graphics image to vertex processor . The optional vertex processor may manage vertex transformation or geometry processing of the graphics image which may be described or defined according to multiple vertices in primitive geometry form. When utilized vertex processor may provide its output to graphics processing unit which may perform rendering or rasterization operations on the graphics image. Graphics processing unit may provide its output to display processor which prepares the graphics image in pixel form for display. Graphics processing unit may also perform various operations on the pixel data such as shading or scaling.

Often graphics image data may be processed in this processing pipeline during execution of graphics commands which may be part of application instructions . As a result graphics commands may be executed by one or more of control processor vertex processor graphics processing unit and display processor . Application developers may typically not have much knowledge or control of which particular processors within graphics processing system execute which ones of graphics commands . In some cases one or more of control processor vertex processor graphics processing unit and display processor may have performance issues or serve as potential bottlenecks within the processing pipeline during the execution of graphics commands . In these cases overall performance within graphics processing system may be deteriorated and the application developer may wish to make changes to the graphics commands to improve performance. However the developer may not necessarily know which ones of processors or may be the ones that have performance issues.

To assist with the problem of identifying performance bottlenecks and potential solutions the graphics driver A of graphics device may capture or collect graphics commands from graphics processing system and route them to application computing device as shown in . Graphics driver A is part of graphics drivers shown in . Graphics driver A may be loaded and executed by one or more of control processor vertex processor graphics processing unit and display processor . In addition graphics driver A may also collect state and or performance information from one or more of control processor vector processor graphics processing unit and display processor and route this information to application computing device as well. In one example graphics driver A may comprise an OpenGL ES driver when graphics commands include binary instructions that may have been generated or compiled from OpenGL ES API instructions.

Various forms of state data may be included within state performance information . For example the state data may include graphics data used during execution of or otherwise associated with graphics commands . The state data may be related to a vertex array such as position color coordinates size or weight data. State data may further include texture state data point state data line state data polygon state data culling state data alpha test state data blending state data depth state data stencil state data or color state data. As described previously state data may include both state information and actual data. In some cases the state data may comprise data associated with one or more OpenGL tokens.

Various forms of performance data may also be included within state performance information . In general this performance data may include metrics or hardware counter data from one or more of control processor vertex processor graphics processing unit and display processor . The performance data may include frame rate or cycle data. The cycle data may include data for cycles used for profiling command arrays vertex and index data or other operations. In various aspects various forms of state and performance data may be included within state performance information that is collected from graphics processing system by graphics driver A. In some examples the performance data may also comprise counter data provided by graphics processing unit .

As described previously application computing device may display a representation of a graphics image according to received graphics commands and state performance information . Application computing device may also display a visual representation of state performance information . By viewing and interacting with the re created graphics image and or the visual representation of the state performance information an application developer may be able to quickly identify and resolve performance issues within graphics processing system of graphics device during execution of graphics commands . For example the application developer may be able to identify which specific ones of processors and or may have performance issues.

Performance analysis application may be used as an application development tool by the application developers. In some examples the use of performance analysis application may allow an application developer to measure and visualize a large set of properties of the processing of individual 2D or 3D elements by the graphics processing hardware of graphics processing unit . Performance analysis application enables the capture of one or more large sets of performance measurements for graphics processing system per each individual rendered element e.g. per draw command per graphics primitive per vertex per pixel fragment .

Performance analysis application may allow the developer to graphically visualize performance metrics on a development device such as application computing device based upon performance measurements received from graphics processing system . Information gleaned from this may help the developer more effectively tune design or performance characteristics of the application in order to run more efficiently on a targeted hardware platform e.g. platform provided by graphics processing system .

In an attempt to identify a workaround or resolution to any identified performance issues the developer may initiate one or more requested modifications on application computing device . For example the developer may interact with the re created image or the representation of state performance information to create the requested modifications . In some cases the developer may even directly change the state performance information as described in more detail below to generate the requested modifications . In certain cases requested modifications may include one or more requests to disable execution of one or more of graphics commands in graphics processing system of graphics device or requests to modify one or more of graphics commands .

Requested modifications are sent from application computing device to graphics driver A which handles the requests for graphics device during operation. In many cases the requested modifications may include requests to modify state information which may include data within one or more of processors or within graphics processing system during execution of graphics commands . Graphics driver A may then implement the changes within graphics processing system that are included within requested modifications . These changes may alter the flow of execution amongst processors and or for execution of graphics commands . In certain cases one or more of graphics commands may be disabled during execution in graphics processing system according to requested modifications .

Graphics driver A is capable of sending updated instructions and or information to application computing device in response to the processing of requested modifications . Updated commands information may include updated state information collected from graphics processing system by graphics driver A including performance information. Updated commands information may also include updated graphics instructions.

Application computing device may use updated commands information to display an updated representation of the graphics image as well as a visual representation of updated commands information through execution or implementation of performance analysis application . Performance analysis application may update the graphical representation of the performance metrics on a rendered element basis for a graphics scene based upon the updated commands information received from graphics driver A. The application developer may then be capable of assessing whether the previously identified performance issues have been resolved or otherwise addressed. For example the application developer may be able to analyze the updated image as well as the visual representation of updated commands information to determine if certain textures polygons or other features have been optimized or if other performance parameters have been improved.

In such fashion the application developer may be able to rapidly and effectively debug or analyze execution of graphics commands within an environment on application computing device that simulates the operation of graphics processing system on graphics device . The developer may iteratively interact with the displayed image and state performance information on application computing device to analyze multiple graphics images in a scene or multiple image frames to maximize execution performance of graphics commands .

As described previously control processor may control one or more aspects of the flow of data or instruction execution through the graphics processing pipeline and may also provide geometry information to vertex processor . As shown in control processor may perform geometry storage at . In some cases geometry information for one or more primitives may be stored by control processor in buffers . In some cases geometry information may be stored in storage medium .

Vertex processor if used within the graphics device may then obtain the geometry information for a given primitive provided by control processor and or stored in buffers for processing at . In certain cases vertex processor may manage vertex transformation of the geometry information. In certain cases vertex processor may perform lighting operations on the geometry information.

Vertex processor may provide its output to graphics processing unit which may perform rendering or rasterization operations on the data at . Graphics processing unit may provide its output to display processor which prepares one or more graphics images in pixel form for display. Display processor may perform various operations on the pixel data including fragment processing to process various fragments of the data at . In certain cases this may include one or more of depth testing stencil testing blending or texture mapping as is known in the art. When performing texture mapping display processor may incorporate texture storage and filtering information at . In some cases graphics processor may perform other operations on the rasterized data such as shading or scaling operations.

Display processor provides the output pixel information for storage into a frame buffer at . In some cases the frame buffer may be included within buffers . In other cases the frame buffer may be included within storage medium . The frame buffer stores one or more frames of image data which can then be displayed on display device such as on display device .

As described previously graphics commands may be executed by one or more of control processor vertex processor graphics processing unit and display processor . Application developers may typically not have much knowledge or control of which particular processors within graphics processing system execute which ones of graphics commands . In certain cases one or more of control processor vertex processor graphics processing unit and display processor may have performance issues or serve as potential bottlenecks within the processing pipeline during the execution of graphics commands .

It may often be difficult for an application developer to pinpoint the location of a bottleneck or how best to resolve or mitigate the effects of such a bottleneck. Thus in one example graphics commands and or state information may be provided from graphics device to an external computing device such as application computing device . The state information may include data from one or more of control processor vertex processor graphics processing unit and display processor with respect to various operations such as those shown in that occur during the execution of graphics commands . Application computing device may create a graphics image that is shown on device in order to help identify and resolve bottlenecks in an efficient and effective manner.

Graphics driver A when executed may include various functional blocks which are shown in as examples of transport interface processor usage module hardware counter module state performance data module that can manage other state and or performance data API trace module and override module . Graphics driver A uses transport interface module to communicate with performance analysis application of application computing device .

Processor usage module collects and maintains processor usage information for one or more of control processor vertex processor graphics processing unit and display processor . The processor usage information may include processor cycle and or performance information. Cycle data may include data for cycles used for profiling command arrays vertex and index data or other operations. Processor usage module may then provide such processor usage information to application computing device via transport interface module . In some cases processor usage module provides this information to device as it receives the information in an asynchronous fashion. In other cases processor usage module may provide the information upon receipt of a request from performance analysis application .

Hardware counter module collects and maintains various hardware counters during execution of instructions by one or more of control processor graphics processing unit vertex processor or display processor . The counters may keep track of various state indicators and or metrics with respect to instruction execution within graphics processing system . Hardware counter module may provide information to device asynchronously or upon request. In particular hardware counter module may capture various counter values from graphics processing unit and provide such values as performance information associated with execution of commands by graphics processing unit to performance analysis application .

State performance data module collects and maintains other state and or performance data for one or more of control processor graphics processing unit vertex processor and display processor in graphics processing system . For example the state data may in some cases comprise graphics data. The state data may include data related to a vertex array such as position color coordinates size or weight data. State data may further include texture state data point state data line state data polygon state data culling state data alpha test state data blending state data depth state data stencil state data or color state data. Performance data may include various other metrics or cycle data. State performance data module may provide information to performance analysis application asynchronously or upon request.

API trace module manages a flow and or trace of graphics instructions that are executed by graphics processing system and transported to performance analysis application via transport interface module . As described previously graphics device provides a copy of graphics commands which are executed by graphics processing system in its processing pipeline to device . API trace module manages the capture and transport of these graphics commands . API trace module may also provide certain information used with performance analysis application to map graphics commands to a visual representation of graphics commands such as API instructions that may have been used to generate graphics commands .

In one example state performance information e.g. sent from graphics device to application computing device may include any of the data or information provided by processor usage module hardware counter module and or state performance data module . In one example graphics commands e.g. sent form graphics device to application computing device may include information provided by API trace module .

Override module allows graphics driver A to change or override the execution of certain instructions within graphics processing system . As described previously performance analysis application may send one or more requested modifications such as modifications to graphics device . In certain cases requested modifications may include one or more requests to disable execution of one or more of graphics commands in graphics processing system or requests to modify one or more of graphics commands . In some cases requested modifications may include requests to change state performance information .

Override module may accept and process requested modifications . For example override module may receive from performance analysis application any requests to modify one or more of graphics commands along with any requests to modify state performance information and send such requests to graphics processing system . One or more of control processor graphics processing unit vertex processor and display processor may then process these requests and generate updated commands information . Override module may then send updated commands information to performance analysis application for processing as described previously.

In such fashion graphics driver A provides an interface between graphics processing system and performance analysis application of application computing device . Graphics driver A is capable of providing graphics instructions and state performance information to performance analysis application and also receiving requested modifications from performance analysis application . After processing such requested modifications graphics driver A is subsequently able to provide updated commands information back to performance analysis application .

The performance analysis application may receive performance information provided by a graphics processing unit e.g. graphics processing unit of graphics device wherein the performance information has been measured by the graphics processing unit in association with individual graphics elements for rendering a graphics scene . For example the performance information may be part of the state performance information shown in which is provided to application computing device . The performance information may be associated with execution of certain draw commands included within graphics commands . Graphics commands may comprise binary instructions that are generated from API instructions.

The performance information in some examples may comprise performance counter data collected by the graphics processing unit. For example the performance counter data may include counter values for the number of culled or clipped graphics primitives as draw commands are being executed by the draw commands. Various other forms of performance counter data may also be collected. Various other forms of performance counter data may also be collected including but not limited to the following number of hardware clock cycles per frame draw command primitive vertex or fragment number of idle or stalled cycles within one or more subcomponents of a graphics device e.g. graphics device per frame draw command primitive vertex or fragment and the like.

The performance analysis application may then compute values of a performance metric for the graphics elements based upon the performance information . Each computed value is associated with at least one of the graphics elements. The performance analysis application may compute values for any number of different performance metrics. Example performance metrics may include for instance the number of pixels written per clock cycle the number of shader instructions issued per vertex the number of memory writes executed per second and the like. The performance analysis application may calculate values for these metrics based upon the received performance information.

The performance analysis application may assign graphical identifiers to the graphics elements based upon the computed values of the performance metric for the graphics elements where one of the graphical identifiers is assigned to each of the graphics elements. The performance analysis application may then display e.g. on display device the individual graphics elements when rendering the graphics scene according to the graphical identifiers that are assigned to the graphics elements .

The performance information may comprise values of one or more counters that are collected and provided by the graphics processing unit for each of the graphics elements. Each of the graphics elements may comprise one or more draw commands for rendering the graphics scene a graphics primitive a vertex a pixel fragment or the like. The performance profiling application may also in some instances display a representation of selectable performance metrics and receive a user selection of one of the selectable performance metrics as the specified performance metric. In such fashion a user may specify the performance metric from a list of available selectable metrics in order to view desired performance data for the rendered graphics elements.

In some examples the performance analysis application may determine a range of values of the performance metric based upon the computed values of the performance metric for the graphics elements. The performance profiling application may then assign the graphical identifiers e.g. colors shading identifiers cross hatching identifiers to the graphics elements based upon positions of the computed values of the performance metric for the graphics elements within the range of values.

As noted above the graphical identifiers assigned to the graphics elements may comprise colors. In these cases the performance analysis application may display the individual graphics elements according to colors that are assigned to the graphics elements where one of the colors is assigned to each of the graphics elements. For example upon processing of the graphics elements the performance analysis application may assign a first color to a first rendered element e.g. per draw command per graphics primitive per vertex per pixel fragment upon display a second different color to a second rendered element upon display and so on. In such fashion the performance analysis application may display on a per element basis performance information in an easy to understand format. An application developer may quickly view such information to identify performance characteristics of the graphics elements for rendering the scene which may help the developer with application development debugging optimization and or other functions during application development.

The graphical identifiers assigned to the graphics elements may comprise other forms of identifiers rather than colors. For example shading and or cross hatching patterns or identifiers may be used. In some examples the performance analysis application may display the individual graphics elements according to shading cross hatching identifiers that are assigned to the graphics elements where one of the identifiers is assigned to each of the graphics elements. For example upon processing of the graphics elements the performance analysis application may assign a first cross hatching pattern or identifier to a first rendered element e.g. per draw command per graphics primitive per vertex per pixel fragment upon display a second different cross hatching pattern or identifier to a second rendered element upon display and so on.

In some cases the acts shown in may be implemented by a single device such as graphics device shown in . In some cases the acts of may be implemented by one or more physically distinct devices such as graphics device and or application computing device shown in .

As shown in the example of in some alternate examples the performance analysis application may be executed or implemented directly within the graphics device e.g. within graphics device . In these particular examples receiving the performance information may include receiving values of one or more counters that are collected and provided by the graphics processing unit for each of the graphics elements where the graphics elements comprise pixel fragments. Assigning the graphical identifiers to the graphics elements may include determining the graphical identifiers by using blending e.g. blending hardware within the graphics processing system to combine multiple ones of the pixel fragments based upon the values of the one or more counters.

Further for the example device shown in the method of may include further acts that are performed by graphics device e.g. by a graphics driver of the device such as graphics driver A shown in . As will be described in further detail with reference to for example a graphics processing unit may determine at least a first value of at least one counter e.g. counter for number of culled clipped primitives of the graphics processing unit prior to processing at least one of the graphics elements by the graphics processing unit.

The graphics processing unit may then determine at least a second value of the at least one counter of the graphics processing unit subsequent to processing of the at least one graphics element by the graphics processing unit. The graphics processing unit may determine the performance information for the at least one graphics element based upon a difference between at least the first and second values of the at least one counter of the graphics processing unit. In such fashion the performance information comprises deltas in the counter values that are based upon the actual processing of the graphics elements thereby providing performance related information for the processing of these elements.

Initially the graphics driver may intercept a particular draw command which may be included within a set of instructions e.g. instructions of instructions of . The graphics driver may intercept the command prior to its execution by the graphics processing unit.

After intercepting the command the graphics driver may check to see if any per element e.g. per draw command per graphics primitive per vertex per pixel fragment performance data collection has been enabled by the performance analysis application e.g. performance analysis application of performance analysis application of . Thus the performance analysis application has the ability to dynamically enable or disable such data collection on a per command basis by the graphics driver given that each draw command may render a particular element.

The performance analysis application may disable data collection functionality in certain cases when per element performance information is not needed or desired. In these cases i.e. NO branch of the graphics driver may drive the execution of the draw command by the graphics processing unit and then transmit command data for the draw command to the performance analysis application . The performance analysis application may then emulate or simulate execution of the command but may not display per element performance metrics given that such data collection by the graphics driver is not enabled. In some optional cases the graphics driver may provide current counter values for the graphics processing unit to the analysis application but such values may comprise current total values of the corresponding counters rather than values that are associated with individual draw commands that are executed to render individual graphics elements.

However if such per element data collection is enabled i.e. YES branch of the graphics driver may sample the current values of all enabled counters of the graphics processing unit GPU prior to execution of the draw commands . One or more of the counters may be enabled for data collection. In some cases the graphics device may enable or disable the counters while in some instances the performance analysis application may enable or disable the counters based upon one or more selections of a user. For example if an application developer is interested in viewing performance metrics information for one or more specified metrics at any point in time the performance analysis application may provide a request to enable data collection from those counters of the graphics processing unit that are used in determining or calculating the specified desired metrics. The analysis application however may disable data collection for any other counters in an effort to mitigate or reduce processing overhead.

Next the graphics driver drives execution of the draw command by the graphics processing unit and then again samples the values of all enabled counters of the graphics processing unit . It is assumed in the example of that sampling GPU counters and executing draw commands are synchronous operations. In this example the graphics driver may query one or more hardware registers exposed by the graphics processing unit which contain the counter values. Those values may then be immediately returned to the graphics driver.

In other examples certain GPU architectures may permit the graphics driver to make a pipelined request to sample a GPU counter and then the graphics driver may be subsequently notified or interrupted by the graphics processing unit when the sample is complete. In these instances the actual collecting or sampling of counter data may be deferred until some time after the draw command executes.

For each GPU counter that is enabled the first sampled values are subtracted from the corresponding second sampled values of the enabled GPU counters . Thus for each specific GPU counter that is enabled the graphics driver computes a delta or difference value which represents the work that is performed by the graphics processing unit as relevant to the specific GPU counter in order to execute the single draw command. Thus if the value of a particular GPU counter is five prior to execution of the draw command and the value changes to eight subsequent to execution of the draw command the delta value of three for that counter is associated with the execution of that particular draw command.

The graphics driver may then transmit command data associated with the draw command to the performance analysis application as well as the delta values for the enabled GPU counters such that the analysis application may recreate the draw command in an emulation environment and display a graphical representation of calculated performance metrics for an individual element based upon execution of the draw command. The command data may include function call parameters render state geometrical data textures shaders and the like.

After transmitting data to the performance analysis application the graphics driver may then repeat the various acts shown in for one or more further draw commands. In so doing the graphics driver is capable of providing state and performance information along with the draw commands to the performance analysis application such that the analysis application can recreate the draw commands and display graphical representations of calculated metrics on a per element basis. shows one example of such graphical representations.

In the example of it has been assumed for purposes of illustration only that the graphics elements comprise individual draw commands. However in other examples the graphics elements may comprise other elements such as graphics primitives vertices or pixel fragments. In these examples the graphics driver is capable of collecting GPU counter data including delta difference data based upon the processing of these graphics elements. For instance at rather than intercepting a draw command the graphics driver may intercept a pixel fragment. At the graphics driver may sample all enabled GPU counters prior to processing of the pixel fragment and at the graphics driver may sample all enabled GPU counters subsequent to processing the pixel fragment. The graphics driver is then capable of transmitting GPU counter data as performance information on a per pixel fragment basis to the performance analysis application.

The performance analysis application may then check to see if it has received a full frame of animation from the graphics driver i.e. whether an end of a frame has been reached . If not i.e. NO branch of the analysis application will continue to buffer incoming data until it has reached the end of a particular frame. If it has reached the end of the frame i.e. YES branch of then for each received graphics element and associated GPU counter data the performance analysis application computes values for one or more specified performance metrics using the received GPU counter values .

The performance analysis application may then normalize the calculated values associated with the commands for each performance metric and then map each value to a graphical identifier within a set of identifiers e.g. to a color within a color range to a shading cross hatching identifier within a range or group of identifiers . For example the performance analysis application may calculate the minimum and maximum values of each specified performance metric across all graphics elements forming a range for each performance metric e.g. pixels written per clock cycle shader instructions issued per vertex memory writes executed per second to name only a few examples within the captured frame. For each performance metric the numerical range may then be mapped to a spectrum or group of graphical identifiers e.g. colors delimiters shades cross hatching or other material properties . The performance analysis application then assign a graphical identifier to each graphics element using the position of the calculated value of the corresponding command within the range of values for that metric.

For example the performance analysis application may receive GPU counter data for three different graphics elements from a graphics driver. The performance analysis application may calculate values of a particular metric for each of the three elements. The first graphics element may have a calculated metric value of three based upon the GPU counter data for this element for instance the second graphics element may have a calculated metric value of five and the third graphics elements may have a calculated metric value of seven. Thus the range of values for this metric may span from three to seven. It may be that for this particular metric a higher value indicates one or more potential performance issues e.g. a higher number of memory writes .

In this particular example the performance analysis application may create a spectrum or range of graphical identifiers for these values. For instance a color yellow may be associated with a metric value of three a color blue may be associated with a metric value of five and a color red may be associated with a metric value of seven. Based upon these color designations the performance analysis application may then assign the color yellow to the first graphics element assign the color blue to the second graphics element and assign the color red to the third graphics element.

As shown in the performance analysis application may modify the shading or other material properties of each graphics element to visually represent e.g. color or tint shading cross hatching any elements that are to be rendered based upon the graphical identifiers that are assigned to these elements and may then process the graphics elements using a device emulator . In such fashion the captured frame is recreated and displayed in a device emulator coupled for the analysis application by processing each captured graphics element e.g. executing each draw command processing each primitive vertex pixel fragment where the individual elements e.g. per draw command per graphics primitive per vertex per pixel fragment are appropriately identified e.g. colored according to the corresponding values of the computed performance metrics.

Thus continuing with the above example the performance analysis application may process the first graphics element and visually display the rendering of this element using the color yellow. The analysis application may process the second graphics element and visually display the rendering of this element using the color blue. Finally the analysis application may process the third graphics element and visually display the rendering of this element using the color red.

In this example it may be that for the particular metric a higher value indicates one or more potential performance issues e.g. a higher number of memory writes . Because higher metric values were associated with the color red an application developer is capable of quickly viewing the visual representation of the elements that were rendered upon processing of the first second and third graphics elements. Those rendered elements that are colored red may have potential performance implications. The developer can then select these elements or otherwise identify the red graphics elements e.g. within a command window as shown in and may then assess whether any optimizations to the command or to the program in general can be made. As noted above various other forms of graphical identifiers other than colors may be used in different examples.

In such fashion the developer is able to quickly view a graphical display of rendered elements in an emulation environment and identify particular elements that may have performance implications based upon the way in which they are displayed. The developer may in some cases identify corresponding draw commands that cause these elements to be rendered and make tune or otherwise modify the application for optimization.

Upon processing of the graphics elements the performance analysis application may repeat and for multiple different frames. In the above example the performance analysis application utilized different colors to differentiate rendered elements. In other cases various other forms of graphical identifiers may be used in lieu of or combination with colors. For instance the performance analysis application may assign shading or cross hatching properties or identifiers to different graphics elements based upon the calculated values of a particular metric for these elements. In general the performance analysis application may assign graphical identifiers to the various different graphics elements that are processed.

Display device may also be capable of displaying visual representations of the instructions and state performance information such that a developer may change these instructions and information to modify graphics image or an entire scene that includes graphics image . As shown in the example of display device may display various types of information within a graphical user interface. In this example display device displays graphical window within the graphical user interface. Window includes a display area a graphics commands area and a state performance information area . Display area includes graphics image . In this example graphics image comprises a cube.

In the example of graphics commands area includes a visual representation of one or more graphics commands including draw commands which have been received by the analysis application and that are currently being or have been executed. The visual representation of such commands may comprise a representation of such commands. For example when the analysis application receives binary graphics commands display device may display a representation of such binary instructions in another form such as higher level application programming interface API instructions e.g. OpenGL instructions . Mapping information such as mapping information stored locally with performance analysis application or provided by the graphics device may be used to map received binary commands into another format that may be displayed within graphics commands area .

State performance information area includes a visual representation of selected state and or performance information that has been received by the performance analysis application. The received graphics commands and state performance information may be used to display graphics image within display area.

Window also includes one or more selectors A N. A user such as an application developer may select any of these selectors A N. Each selector A N may be associated with different functions such as statistical and navigation functions as will be described in more detail below. Window further includes selectors A N and A N each of which may be selected by a user. Each selector A N and A N may also be associated with different functions such as metric functions override functions and or texture functions as will be described in more detail below in reference to .

A user such as an application developer may change information displayed within window . For example the user may modify one or more of the instructions displayed within graphics commands area or any of the state performance information within state performance information area .

Any changes initiated by the user within window may then be sent back to or within the graphics device as requested modifications e.g. requested modifications shown in . The graphics device may then process these modifications and provide updated instructions and or information which may then be displayed within graphics commands area and or state performance information area . The updated instructions and or information may also be used to display a modified version of graphics image within display area .

In one example the state and or performance information that may be displayed within area may be analyzed by the device that includes display device which may be the graphics device or a separate application computing device to identify potential bottlenecks during execution of the graphics commands. Ultimately a user such as an application developer may wish to view the information presented in window during a debugging process to optimize the execution of the commands. Through analysis of state and or performance information potential bottlenecks and possible workarounds can be displayed in window such as within one or more sub windows or pop up windows or within area of window .

In one example window may display a report on the bottlenecks encountered in the call stream of the graphics instructions received from graphics device and may also display possible workarounds. In some cases these possible workarounds may be presented as what if scenarios to the user. For example rendering a non optimized triangle list in a call stream may be presented as one possible scenario while pre processing that list through a triangle strip optimization framework may be presented as a second possible scenario. The user may select any of these possible workaround scenarios as requested modifications and the requested modifications are then transmitted back to the graphics device where the performance produced by the modification may be measured.

The graphics device then sends updated commands information which may be presented within graphics commands area and or state performance information area . The user can then view the results and compare results for various potential workarounds to identify an optimum solution. The user can use this process to quickly identify a series of steps that can be taken in order to remove bottlenecks from their application.

The user may iteratively continue to make adjustments within window for purposes of experimentation or trial error debugging. The user may experiment with various different forms or combinations of graphics commands and state performance information to identify changes in the images or scenes that are displayed within display area . The user can use the simulation environment provided by the contents of window to interactively view and modify the graphics commands which may be part of a call stream and states provided by the graphics device without having to recompile source code and re execute the compiled code on the graphics device.

In some cases the user may manipulate one or more of buttons A N to manipulate a graphical navigation controller such as graphical camera to modify a perspective view of graphics image . Such manipulation may be captured as requested modifications that are then sent back to graphics device . The updated commands information provided by the graphics device are then used to modify the perspective view of graphics image .

In some cases various texture and or state information may be provided in area of window as modifiable entities. In addition a user may even select for example a pixel of graphics image within display area such that one or more corresponding instructions within graphics commands area are identified. In this fashion a user can effectively drill backwards to a rendering instruction or call that was used to render or create that pixel or other portions of graphics image . Because graphics device may create image in window exactly as it is presented on graphics device the user is able to quickly isolate issues in their application which may be based on the various graphics instructions displayed in graphics commands area and modify any states within state performance area to prototype new effects.

The information displayed within display area may allow an application developer to measure and visualize a large set of properties of the processing of individual 2D or 3D elements by the graphics processing unit of the graphics device. The performance analysis application may enable the capture of one or more large sets of performance measurements per each individual rendered element e.g. per draw command per graphics primitive per vertex per pixel fragment within image . Information gleaned from this may help the developer more effectively tune design or performance characteristics of the application in order to run more efficiently on a targeted hardware platform.

For example as noted above each element e.g. per draw command per graphics primitive per vertex per pixel fragment of image rendered within display area may be assigned a graphical identifier based upon computed metric values of a specified performance metric for the draw commands that are executed to render the elements. The computed metric values are based upon the performance information that is received by the performance analysis application. Because each element of image is displayed according to its assigned graphical identifier e.g. color shading cross hatching as described previously and further described with reference to the developer is able to quickly identify the performance issues or impacts of rendering the elements according to the particular draw commands that have been provided in a given application.

For example within graphics commands area various graphics commands are shown. Graphics commands may be a subset of graphics commands that are provided by a graphics device.

As is shown in the example of graphics commands include both high level instructions and low level instructions. A user such as an application developer may use scrollbar to view the full set of instructions . Certain high level instructions may include one or more low level instructions such as lower level API instructions. The application developer may in some cases select e.g. such as by clicking on a particular high level instruction in order to view any low level instructions that are part of or executed by the associated high level instruction.

In some examples a developer is capable of viewing the commands within area that are executed to render the graphics elements of image . In some cases if particular elements of image are shown with graphical identifiers or properties e.g. colors based upon computed performance metric values a user may be able to select such elements and determine from the display within graphics commands area which command s have been executed to render the selected elements. In some cases the commands themselves within area may be associated with the same graphical identifiers as the rendered elements of image such that a user can associate particular commands with rendered elements. In such fashion the user is able to have a better understanding of which commands are associated with which rendered elements in image .

Various selection buttons are shown below state performance information area in . These selection buttons include a textures button an override button and a metrics button . In the example of the application developer has selected the metrics button . Upon selection of this button various metrics options may be displayed. For example one or more metric buttons A N may be displayed above state performance area . Each metric button A N may be associated with a particular metric. In some cases one or more of these metrics may be predefined or preconfigured metric types and in some cases the application developer may select or customize one or more of the metrics. Example metrics may include for example any one or more of the following frames per second busy for one or more processors bus busy memory busy vertex busy vertices per second triangles per second pixel clocks per second fragments per second shader instructions issued per vertex etc. The application developer may select any of metric buttons A N to view additional details regarding the selected metrics.

By selecting one of metric buttons A N the developer is able to select or specify a particular performance metric for which to compute metric values for particular commands. For example upon receipt of a group of draw commands and performance information from a graphics device that includes a graphics processing unit a performance analysis application such that the ones shown in is capable of calculating metric values of a specified metric for the commands based upon the receiving performance information e.g. counters for a graphics processing unit . The specified metric may be based upon a selection of one of metric buttons A N.

For example if metric button A is associated with the number of frames per second the application developer may select metric button A to view additional details on the number of frames per second related to performance for graphics image or select portions of graphics image . The developer may in some cases select metric button A or drag metric button A into state performance information area . The detailed information on the number of frames per second may be displayed within state performance information area . The developer also may drag metric button A into display area or select a portion of graphics image for application of metric button A. For example the developer may select a portion of graphics image after selecting metric button A and then detailed information on the number of frames per second for that selected portion may be displayed within state performance information area . In such fashion the developer may view performance data for any number of different metric types based upon selection of one or more of metric buttons A N and even possible selection of graphics image or a portion thereof.

In one example metric data that may be displayed within window may be provided by a graphics driver e.g. graphics driver A shown in of a graphics device. This graphics driver may implement a hardware counter module e.g. hardware counter module of and or a processor usage module e.g. processor usage module of to provide various data that may then be displayed as metric data within window .

The developer may in some cases also select textures button . Upon selection various forms of texture information related to graphics image may be displayed by the graphics device. For example texture information may be displayed within window such as within state performance information area . In some cases the texture information may be displayed within an additional e.g. pop up window not shown . The developer may view the displayed texture information but may also in some cases modify the texture information. In these cases any modifications to the texture information may be propagated back to the graphics device as requested modifications. Upon receipt of updated commands information from the graphics device changes to graphics images may be displayed within display area .

The developer may in some cases also select override button . After selection of override button certain information such as instruction and or state information may be displayed e.g. within window or another window which may be modified or overridden by the developer. Any modifications or overrides may be included within one or more requested modifications that are sent to the graphics device. In one example the graphics device may implement a graphics driver such as graphics driver A to process any requested modifications. For example the graphics device may use override module to process such requested modifications that comprise one or more overrides.

In some cases the developer may override one or more over graphics commands that are shown within graphics commands area . In these cases the developer may type or otherwise enter information within graphics commands area to modify or override one or more of graphics commands . These modifications may then be sent to the graphics device which will provide updated commands information to update the display of graphics image within display area . The developer may change for example parameters ordering type etc. of graphics commands to override one or more functions that are provided by instructions .

Window further includes selection buttons and . Selection button is a statistics button and selection button is a navigation button. The developer may select statistics button to view statistical information associated with the display of graphics image . This statistical information may comprise one or more graphs tables or other forms of statistical information. The developer may view statistical information to obtain a better understanding of various performance or other related issues associated with the display of graphics image .

The developer may select navigation button to navigate within display area and even possibly to change a perspective view of graphics image within display area . For example upon selection of navigation button a 3D graphical camera or navigation controller may be displayed. The developer may interact with the controller to navigate to any area within display area . The developer may also use the controller to change a perspective view of graphics image such as by rotating graphics image or zooming in out.

In one example any developer initiated changes through selection of navigation button and interaction with a graphical navigation controller may be propagated back to the graphics device as requested modifications e.g. part of requested modifications shown in . Updated commands information then provided by the graphics device may then be used to update the display e.g. perspective view of graphics image . In addition updated instructions may be displayed within graphics commands area . Updated state performance information may also be displayed within state performance information area .

As a result the developer may effectively and efficiently determine how alternate perspectives orientations views etc. for rendering and displaying graphics image may affect performance and state of the graphics device. This may be very useful to the developer in optimizing the graphics commands that are used to create and render graphics image in the simulation environment displayed on display device and effectively of the graphics image that is displayed on the graphics device.

However in the diagram of the performance analysis application has not rendered the graphics elements using graphical identifiers that represent performance metrics values associated with the graphics elements. In this example per element data collection may not be enabled see e.g. NO branch of in such that the rendered elements are displayed without any extra graphical identifiers or characteristics e.g. colors cross hatching shading given that per element performance metrics are not calculated by the performance analysis application.

Window displays the graphics elements within a display area e.g. display area of . Graphics element is a star within the scene graphics element is a circle within the scene graphics element is a cube.

Window further includes a graphics commands area e.g. graphics command area of . In the example of various different high level commands and or low level commands e.g. Command 1 Command 2 Command 3 such as those shown within area of may be displayed. In some cases a list of OpenGL ES API calls executed by an application to draw the graphics elements in the scene may be shown in graphics commands area . These OpenGL ES API calls may comprise draw calls that when executed by the performance analysis application render the various graphics elements of the scene that is shown. In one particular example each draw call may comprise a glDrawElements call where each call to glDrawElements corresponds to an individual rendered object in the scene.

Rendered elements may comprise objects such as the various objects shown in or any portions thereof e.g. primitives vertices pixel fragments combinations thereof . In some cases rendered elements may comprise individual primitives vertices pixels fragments etc. that are displayed within a graphics scene. In these cases a particular draw command upon execution may render one or more of these primitives vertices pixels fragments etc.

Performance analysis application has collected performance data from a graphics processing unit for each of the draw commands shown in area and has computed values of a specified performance metric based upon the collected performance data. Performance analysis application has also assigned a graphical identifier e.g. color shading identifier cross hatching identifier to each of the graphics elements based upon the corresponding computed value of the specified performance metric and displayed individual graphics elements that are rendered according to the graphical identifiers that are assigned to the graphics elements. In general graphics elements may comprise one or more draw commands primitives vertices pixels pixel fragments or the like that are processed or execution during rendering of the displayed scene. Performance analysis application may compute such metric values of each command for a number of different performance metrics.

In the example of an example performance metric of Metric 1 is shown in metrics area . Metric 1 for example may comprise a performance metric for fragments shaded or clocks. Metric 1 is the currently specified performance metric for which metric values of the graphics elements are computed for displaying the rendered elements with the particular graphical identifiers.

If the graphical identifiers comprise cross hatching identifiers as shown in the example of the performance analysis application may render certain elements using one cross hatching identifier e.g. pattern if such elements have higher metric values for the specified performance metric meaning they may be more computationally expensive e.g. require more processing higher bandwidth to draw. The performance analysis application may render other elements using another cross hatching identifier e.g. pattern if the elements have lower metric values meaning they may be computationally cheaper to draw.

If the graphical identifiers were in another example to comprise colors rather than cross hatching identifiers the performance analysis application may color rendered elements in one color such as red if such elements have higher metric values for the specified performance metric meaning they may be more computationally expensive e.g. require more processing higher bandwidth to draw. The performance analysis application may color rendered elements in another color such as green if the elements have lower metric values meaning they may be computationally cheaper to draw.

Visualizing the metrics data in this way may allow a game developer for example to take a quick survey of how a device is rendering a particular scene. In the scene of element may be the reddest in color or have a particular cross hatching pattern meaning that it is taking the most clock cycles on the graphics processing unit to render.

Rendered elements may comprise objects such as the various objects shown in . In some cases rendered elements may comprise individual primitives vertices pixels pixel fragments and the like that are displayed within a graphics scene. In such cases the elements within the graphics scene rather than the larger objects may be displayed using the graphical identifiers e.g. colors shading cross hatching identifiers that are associated with certain metric values based upon processing of the elements during rendering of the scene. Thus the user is capable of viewing performance metric data on a per element basis e.g. per draw command per graphics primitive per vertex per pixel fragment and assessing which elements are more computationally expense to render.

Area shows individual horizontal bar graphs associated with specific commands. Each bar graph comprises a representation of the computed metric value for the corresponding command. For instance Command 1 has a particular computed metric value for Metric 1 and the corresponding bar graph in area provides a graphical representation of this value. As shown each of the draw commands Command 1 Command 2 and Command 3 include bar graph representations for their corresponding metric values of the metric Metric 1 e.g. fragments shaded metric clocks metric .

Each of the individual bar graphs may also be displayed according to the graphical identifiers that have been assigned to the corresponding commands by the performance analysis application. Thus if graphics command Command 1 has been assigned a particular cross hatching identifier e.g. pattern for Metric 1 indicating that the execution of this command may be computationally expensive for this metric the corresponding bar graph for Command 1 e.g. located to the right of Command 1 in area may also be displayed or represented using the same cross hatching identifier. In such fashion the user is capable of associating particular commands with the corresponding metric values. Assuming that element is also displayed or represented with the same cross hatching identifier in this example the user is able to determine which rendered element is rendered or otherwise associated with a particular command e.g. Command 1 and then able to quickly identify those elements commands that are computationally expensive based upon their associated identifiers. In some cases the user may click or select the bar graphs to view numerical values of the calculated metrics.

In the example of Command 1 may be executed to render element Command 2 may be executed to render element and Command 3 may be executed to render element . As shown by the corresponding bar graphs in area for Metric 1 Command 1 for corresponding element may be more computationally expensive to render than Command 2 for corresponding element given the lengths of the corresponding bar graphs. Command 2 for corresponding element may be more computationally expensive to render than Command 3 for corresponding element .

The techniques described in this disclosure may be implemented within a general purpose microprocessor digital signal processor DSP application specific integrated circuit ASIC field programmable gate array FPGA or other equivalent logic devices. Accordingly the terms processor or controller as used herein may refer to any one or more of the foregoing structures or any other structure suitable for implementation of the techniques described herein.

The various components illustrated herein may be realized by any suitable combination of hardware software firmware or any combination thereof. In the figures various components are depicted as separate units or modules. However all or several of the various components described with reference to these figures may be integrated into combined units or modules within common hardware and or software. Accordingly the representation of features as components units or modules is intended to highlight particular functional features for ease of illustration and does not necessarily require realization of such features by separate hardware or software components. In some cases various units may be implemented as programmable processes performed by one or more processors.

Any features described herein as modules devices or components including graphics device and or its constituent components may be implemented together in an integrated logic device or separately as discrete but interoperable logic devices. In various aspects such components may be formed at least in part as one or more integrated circuit devices which may be referred to collectively as an integrated circuit device such as an integrated circuit chip or chipset. Such circuitry may be provided in a single integrated circuit chip device or in multiple interoperable integrated circuit chip devices and may be used in any of a variety of image display audio or other multimedia applications and devices. In some aspects for example such components may form part of a mobile device such as a wireless communication device handset.

If implemented in software the techniques may be realized at least in part by a computer readable data storage medium comprising code with instructions that when executed by one or more processors performs one or more of the methods described above. The computer readable medium may form part of a computer program product which may include packaging materials. The computer readable medium may comprise random access memory RAM such as synchronous dynamic random access memory SDRAM read only memory ROM non volatile random access memory NVRAM electrically erasable programmable read only memory EEPROM embedded dynamic random access memory eDRAM static random access memory SRAM flash memory magnetic or optical data storage media.

The techniques additionally or alternatively may be realized at least in part by a computer readable communication medium that carries or communicates code in the form of instructions or data structures and that can be accessed read and or executed by one or more processors. Any connection may be properly termed a computer readable medium. For example if the software is transmitted from a website server or other remote source using a coaxial cable fiber optic cable twisted pair digital subscriber line DSL or wireless technologies such as infrared radio and microwave then the coaxial cable fiber optic cable twisted pair DSL or wireless technologies such as infrared radio and microwave are included in the definition of medium. Combinations of the above should also be included within the scope of computer readable media. Any software that is utilized may be executed by one or more processors such as one or more DSP s general purpose microprocessors ASIC s FPGA s or other equivalent integrated or discrete logic circuitry.

Various aspects have been described in this disclosure. These and other aspects are within the scope of the following claims.

