---

title: Availability and scalability in a messaging system in a manner transparent to the application
abstract: Methods, systems, and computer program products that provide for a runtime messaging infrastructure, which abstracts send and receive operations for exchanging messages with partner endpoint. The messaging infrastructure improves availability and scalability of a message application by improving on the availability and scalability of the underlying message transports. In particular, availability and scalability are improved by linking the message application at runtime with any number of the message transports, without the message application specifying a transport at development time. The message infrastructure receives instructions from the message application specifying end-to-end delivery assurances. The infrastructure uses transports in order to fulfill the specified delivery assurance, and creates a link between the message application and transports for use in exchanging messages. Session state storage can be maintained in a pluggable store, which could be, for example, a durable database store or an application memory store.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08135794&OS=08135794&RS=08135794
owner: Microsoft Corporation
number: 08135794
owner_city: Redmond
owner_country: US
publication_date: 20100331
---
This application is a continuation of and claims priority to and the benefit of U.S. patent application Ser. No. 10 402 052 filed on Mar. 27 2003 and entitled AVAILABILITY AND SCALABILITY IN A MESSAGING SYSTEM IN A MANNER TRANSPARENT TO THE APPLICATION which application is expressly incorporated herein by this reference in its entirety.

The present invention generally relates to reliable messaging systems. More particularly the present invention provides systems methods and computer program products for improving availability and scalability for reliable two party messaging systems such that the improvements are transparent to the application.

Messaging systems have become an increasingly popular way to communicate. These communication systems range from e mail systems to secured transactions from chat rooms to various web services such as internet shopping. These systems and applications have widely varying requirements regarding messaging reliability security performance availability and scalability. Existing systems offer partial solutions that address specific limited combinations of the more general requirements.

Traditional prior art messaging systems typically offer limited flexibility in terms of the assurances e.g. exactly once delivery message exchange patterns e.g. one way versus request response or full duplex and messaging interface semantics e.g. transactional message buffering . Each of these messaging systems typically address a limited set of scalability and availability requirements and either offer few options for extending the system to increase overall scalability or availability or require extensive application involvement.

For example consider the following two party communication models. Datagram systems typically offer one way session less message exchange with fire and forget reliability and offer little direct support for scalability and availability. These systems offer developers the ultimate freedom and flexibility to build everything themselves.

TCP provides full duplex session oriented communication. It has a richer but fixed set of delivery assurances exactly once in order delivery of bytes . Connection state is maintained in volatile in memory data structures and connections cannot survive system and process failures and many network failures limiting availability.

RCP provides a half duplex exchange pattern some systems limit this to single request response interactions and some provide for conversational sessions. In either case endpoint state is typically maintained in memory and hence has availability limitations similar to TCP. While the session less request response systems can sometimes achieve great scalability consider HTTP based web farms these typically do not provide at most once request processing hence limiting their use to idempotent requests. Session based RPC systems can provide request retry with at most once processing allowing for some increased availability. In some cases the underlying transport connections are managed by the runtime allowing multiplexing with some increase in scalability.

Finally message queuing systems generally provide exactly once delivery semantics. Unlike the datagram TCP and RPC models queues impose buffering between the two communicating parties allowing for additional connectivity and scheduling flexibility. Many message queuing systems provide durable state storage affording additional availability by tolerating process and system failures. Some queuing systems also have transaction support this model can increase reliability and availability by automatically undoing partial work and enabling automatic retry processing. These systems generally impose limited storage options such as requiring the use of a proprietary durable store and have transport dependencies that limit network configuration.

Accordingly there exists a need for a messaging system that allows increased flexibility to adapt applications to special runtime conditions and requirements as long as the application mandated assurances are met. Further there exists a need for a messaging system with the aforementioned flexibility that can be used to tailor application availability and scalability to the needs of a specific deployment in a manner transparent to the application program.

In accordance with example embodiments of the present invention the above identified deficiencies and drawbacks of current messaging systems are overcome. For example exemplary embodiments provide for a runtime messaging infrastructure that abstracts send and receive operations for exchanging messages with a partner endpoint over a number of message transports. The present invention improves availability and scalability of a message application by improving the availability and scalability of the underlying message transport. For example availability is improved by masking many errors providing support for durable state maintenance support for clusters redundancy of service configurable timeouts and configurable buffer sizes all invisible to the application. Scalability is achieved by configurable buffer sizes and replication of services e.g. service farms.

In particular availability and scalability are improved by selecting one of the message transports to link with the message application at runtime. A message infrastructure in accordance with the present invention receives instructions from the message application specifying end to end message delivery assurances such as at least once message delivery at most once message delivery in order sent message delivery and session time to live. The selected assurances are used in selecting a suitable message transport at runtime without the message application specifying the suitable transport at development time. The infrastructure selects at least one transport that meets the end to end message delivery assurances and creates a link between the message application and the selected transport for use in exchanging messages between the message application and the partner endpoint.

In accordance with other example embodiments of the present invention the infrastructure can receive instructions from the message application specifying local reliable message features such as a session state storage a message time to live and a transacted messaging buffering. The local reliable messaging feature of a session state storage can be maintained in a pluggable store which could be for example a daemon process store a durable database store or an application memory store. The selection of the store defines the durability of the session state providing the ability to recover from more kinds of failures e.g. application crashes node crashes etc. which in turn provides increased availability. Similarly a disk based store may be able to hold more messages than a memory based store thus improving both scalability and availability.

Among other things the local reliable messaging features also may include the following a buffer quota which defines the maximum number of messages that will be buffered by the messaging infrastructure a send timeout which unblocks the send operation after the send timeout expires a priority option wherein higher priority messages are transmitted before lower priority messages and a configurable poison message feature wherein the number of times a message delivery is aborted is configurable to determine when the message is poison.

Additional features and advantages of the invention will be set forth in the description which follows and in part will be obvious from the description or may be learned by the practice of the invention. The features and advantages of the invention may be realized and obtained by means of the instruments and combinations particularly pointed out in the appended claims. These and other features of the present invention will become more fully apparent from the following description and appended claims or may be learned by the practice of the invention as set forth hereinafter.

The present invention extends to methods systems and computer program products for simplifying reliable messaging application development by providing a single programming model for accessing and using a plurality of distinct message transports while developing one or more applications. The embodiments of the present invention may comprise a special purpose or general purpose computer including various computer hardware as discussed in greater detail below.

In accordance with example embodiments of the present invention however reliable messaging stacks and are provided with a Reliable Messaging Protocol . Accordingly for example the Reliable Messaging Framework or alternatively can insure that the message or messages sent from Application properly arrive at their destination endpoint. For example if Application desires to transfer message or messages to its session counterpart Application Application can Send message or messages to the Reliable Messaging Framework where they are assigned to the session and given message sequence numbers. A session identifier corresponds to the session communication between Application and Application . In other words a session refers to the duplex conversation between the two Applications and . The sequence numbering corresponds to the particular message within the session communication. For example there may be several messages within a single session communicated between the two Applications and and each message is numbered sequentially in the order sent by the application. In addition there may be multiple sessions established between Applications and possibly other applications each session established may have the same or different delivery assurances . Accordingly each message would be assigned a session and sequence number uniquely identifying the particular session and sequence ordering of the messages within the session.

After writing a session and sequence header on the message and performing other required channel processing message is stored in Session State in a send buffer. Subsequently a copy of message is transported down through the datagram Messaging which facilitates end to end transmission of message by e.g. providing routing headers. Message is then transferred potentially through one or more intermediaries e.g. Intermediary each facilitating end to end transmission of message as a series of point to point transmissions. The extensible interception mechanism may be used to implement behaviors such as routing filtering policy management and security. It is noted that the transports and behaviors available at end points in messaging endpoints and intermediary can be established either programmatically or through configuration.

If the assurance for At Least Once delivery described in greater detail below is specified for Application Reliable Messaging Framework expects to receive acknowledgements from Reliable Messaging Framework indicating which messages are properly received. Message carries an acknowledgement that message e.g. message in a sequence was received. Periodically if an acknowledgment message is not received by Reliable Messaging Framework either because a copy has not been properly received by Reliable Messaging Framework or because none of the acknowledgements from were received by message is transmitted again. Accordingly if message was dropped delayed or misrouted for example by Intermediary Reliable Messaging Framework continues within a timeout period later described to periodically transmit message in an attempt to assure that at least one copy of message is properly received by Reliable Messaging Framework . It should be noted however that for similar reasons as those described above with regard to message acknowledgment can be dropped delayed or misrouted. As such the present invention provides for reliable message delivery of acknowledgment message as described hereinafter.

Once the Reliable Messaging Framework successfully receives a copy of message it sends acknowledgment message to Reliable Messaging Framework . Upon receipt of acknowledgment message Reliable Messaging Framework deletes from its Session State send buffer the copy of message and stops doing additional transmissions of it. Similarly Reliable Messaging Framework records in its Session State that it has received a copy of message so that any duplicate messages received by Reliable Message Framework can be discarded independent of whether or not the messages have already been delivered to the application . Thereafter Application can retrieve from the Session State receive buffer the received message though its Receive command. If Reliable Messaging Framework does not receive acknowledgment because it was dropped delayed or misrouted then retransmission of message will continue thereby triggering Reliable Messaging Framework to send another copy of acknowledgement . This process may continue until at least one acknowledgment is received by Reliable Messaging Framework or until Reliable Messaging Framework gives up retrying and sends a fault indication to application .

Reliable Messaging Frameworks and or can each be configured as Dialog in accordance with the present invention and as described in greater detail with regard to . Dialog is a message framework abstraction wherein services or application instances use Dialog for reliable session oriented communication with other services. Programmers can use a Dialog Channel to access Dialogs. Moreover Dialog provides a reliable messaging infrastructure and a single programming model where the message delivery assurances to the applications are configurable. These reliability assurances need to be met or a session failure occurs. The design of Dialog gives a corresponding runtime implementation the flexibility to offer additional features subject to maintaining the assurances correctness constraints asserted for the application implementation. In particular an application can be provided with varying degrees of availability and scalability transparent to the application implementation. Further these session communications between Applications and may be realized over a variety of transport types e.g. TCP IP and HTTP transport connection instances and network topologies.

The reliability assurances provided by Dialog include At Least Once ALO At Most Once AMO and In Order delivery. An additional Session Time To Live TTL assurance is also provided. The AMO assurance guarantees that for any given message sent by the sending application the message will be delivered to the receiving application at most one time. Because Dialog is an abstraction the application is relieved from having to detect and discard duplicate messages if duplicate messages would break the application semantics. Similarly the ALO assurance provides that all the messages sent by the sending application are received by the receiving endpoint which relieves the applications from having to detect lost or misdirected messages and coordinate their retransmission. The 10 assurance provides that messages are delivered to the receiving application in the order they were sent by the sending application. This relieves the application from having to deal with out of order receipt of messages.

Dialog also provides a session TTL assurance which requires that the dialog session between the partner endpoint partners be completed before the session TTL expires. If the session TTL expires before the dialog session has been completed the dialog channels are placed in a faulted state and notification of the fault is provided to the applications. The applications can extend the session TTL by renegotiating the TTL.

Dialogs allow these message delivery assurances to be used either individually or in any combination to meet the particular requirements of a given application and deployment. For example the combination of the three AMO ALO and IO assurances provides the exactly once in order delivery typical of most reliable communication mechanisms such as TCP IP. Unlike typical communication mechanisms and their corresponding programming models however these assurances can be customized without changing the programming model that the application uses.

Dialog not only allows for configurable assurances but also allows for local reliable messaging features to be chosen and configured independently of each other and independently of the assurances chosen above. These local reliable messaging features fall into two distinct categories those that are integral to the programming model and those concerned with customization independent from the application program. For example integral local features may include transacted buffering which has consistency isolation and atomicity semantics for the application or a profile reference which associates a profile with a session to allow independent customization. Customizable local features might include session state storage configuration buffer quota send timeout configurable message TTL session priority messages or poison message detection threshold as described hereinafter.

In accordance with example embodiments of the present invention Dialog provides session state and message storage as a replaceable component called the Dialog Store . Because the Dialog Store is replaceable third parties can independently author and distribute Dialog Store implementations. Administrators can pick and choose the Dialog Stores actually used in a given installation. Accordingly this mechanism allows tremendous flexibility to meet durability performance autonomy and administrative goals. The Dialog Store can be a pluggable store that has at least one of an in memory storage on disk durable storage in a daemon process storage in non volatile memory store on optical storage magnetic tape network attached storage or removable. Further the Dialog Store can be remote or off node.

In accordance with an example embodiment of the present invention an in memory Dialog Store implementation e.g. Dialog Store is provided which keeps all state in the application memory. This store provides very fast access to the state however at the cost of all state being lost if the application process state is lost e.g. the application is terminated by the user it is terminated by the operating system e.g. due to an application fault or the system where the application executes fails .

In accordance with another example embodiment an express Dialog Store implementation e.g. Dialog Store keeps state in the memory of a separate dedicated daemon process. This Dialog Store insures that the state survives application process failure however at the cost of doing process switches to maintain the state. If the daemon process fails or the operating system or computer node fails then all state for the sessions that it is responsible for are lost.

In accordance with yet another embodiment of the Dialog Store implementation e.g. Dialog Store session state information is maintained in a durable fashion in a database such as Structured Query Language SQL server. This durable state can survive computer node or operating system failure however at the cost of doing disk writes to maintain state. One benefit of using a database system such as an SQL server for state maintenance is that installations may already have tools techniques and processes in place for doing regular back up and recovery of important application state.

The present invention also provides that some Dialog Stores can be configured to run on the local computer node or another node. For example a durable Dialog Store such as an SQL server may be configured to use a local server database or one on another node. The other node may be part of a clustered system and thus have very high availability.

The present invention also provides that multiple stores or store configurations can exist simultaneously to meet the specific deployment characteristics used by an application or applications. Further an application configuration can be modified to use a different store or store configuration in order to accommodate changes such as increased load or capacity requirements to take advantage of new storage options or to address other deployment environment considerations. Furthermore different communication sessions within the same application may have different configuration requirements. Dialog allows each session to be configured individually. For example some sessions within an application may work best with durable state storage whereas other sessions may work best with volatile state storage. Dialog store can be configured via a profile described below or specified in application code.

Another configurable feature offered by Dialog is a buffer quota. Dialog buffers messages at the sender and receiver applications. This buffering increases the autonomy of the two applications allowing either side to send or receive messages to or from their local buffers even if the other party is not running or is unreachable e.g. due to a network partition. For example Application may continue to send messages even though the other party is temporarily unavailable i.e. not running or unreachable. This is accomplished by accumulating messages in the local Send Buffer until they can be successfully transferred. Similarly Application can receive messages that were previously buffered in Receive Buffer even though the application that sent them currently may not be running. Dialog provides a configurable buffer quota which defines the maximum number of messages contingent on the message size that will be buffered by the system. Accordingly this limits the amount of space consumed by the Dialog State and limits the local resources that can be consumed by the other endpoint. This also allows the messaging system to reserve space sufficient for the application to locally buffer the specified number of messages. Dialog also provides for a minimum buffer quota that defines a minimum reserved number of messages that will be buffered by the messaging infrastructure which in combination with a maximum message size defines a minimum number of bytes that will be buffered by the messaging infrastructure. Buffer quota can be configured via a profile described below or specified in application code.

Dialog also provides a configurable send timeout feature. When a message is sent it is placed in the Dialog store send buffer . If the buffer is full i.e. if the buffer quota has been reached then the call to Send is blocked until either the send timeout expires or space becomes available in the buffer to hold the message. Space is made available in the buffer when messages are successfully transferred to and acknowledged by the receive endpoint and are no longer needed at the local endpoint for retry. If space becomes available before the send timeout expires the Send calls complete normally. If the send timeout expires before space is available an exception is raised providing notification to the application that the message could not be successfully buffered captured . Accordingly the application can try again later. The configurable timeout allows applications to choose the degree of responsiveness over the simplicity of blocking. Send timeout can be configured via a profile described below or specified in application code.

As mentioned previously Dialog supports a end to end session TTL assurance. Dialog also provides an optional message Time To Live that is configurable as a local feature. The message TTL requires that transmitted messages must be successfully received by the receiving endpoint within a time specified in the TTL otherwise an error is raised to the Application . Dialog also provides a configurable extension for the message TTL. Accordingly when the TTL expires notification is provided to the sending Application . Application then has the choice of terminating the dialog or extending the message s TTL. Similar to send timeouts TTL s can be set by application code or configured indirectly using a profile.

Another feature provided by Dialog is the assigned optional priority. All messages within a Dialog have the same priority. However when messages from multiple Dialogs are available for transmission Dialogs with higher priority are given precedence over Dialogs with lower priority in transmitting the messages. Similarly when messages are available for delivery to the receiving application messages with higher priority are received prior to messages with lower priority. Priorities can be set by application code or indirectly using profiles described hereinafter.

Dialog also provides optional transacted buffering of messages. When a Dialog is used with transactions the local send and receive buffers act as transactional resource managers. In this case messages received under a transaction are considered tentatively delivered deleted from the receive buffer subject to transaction outcome. Similarly messages sent under a transaction are tentatively captured added to the send buffer subject to transaction outcome. If the transaction commits these tentative message captures and deliveries are made permanent. If the transaction aborts these tentative operations are abandoned as if they never occurred. Like other transactional resource managers the dialog stores are responsible for providing transactional isolation for tentative buffer operations e.g. captured messages are not visible outside the transaction and transactional atomicity with transaction completion under the control of a transaction manager.

Transactional buffering simplifies the development of correct messaging applications e.g. that make correct state transitions even in the face of failures or concurrent activity . Applications can use this feature to coordinate message exchange and local message processing. For example an application might receive and process a message within the scope of a transaction. This message processing might include reading and updating one or more transactional databases as well as sending one or more messages on dialogs included in the transaction. If the transaction aborts all of the work is undone. In particular the messages that were tentatively sent are abandoned i.e. session partners won t see these partial results and the received message remains available for delivery. The latter allows the message to be processed within the scope of a new transaction. When a transaction commits all of this activity becomes permanent including the deletion of the received message and the buffering of sent messages. The net affect is exactly once message processing. Transactional buffering is a local Dialog feature in that whether or not the application uses this feature is completely transparent to its session partner applications.

In accordance with example embodiments and as described below with reference to at the sender endpoint when Send is called the message is tentatively placed in the Dialog Store . If the transaction commits the message is committed to the Store and made available for transmission to the partner endpoint. If the transaction aborts the message is discarded. At the receiver when Receive or Delete is called the message is tentatively deleted from the Dialog Store . If the transaction commits the message is permanently deleted from the Store . If the transaction aborts the message remains in the Store and is available for re delivery. Transacted receive allows for exactly once processing of messages.

It should be noted that although transacted buffering is a common feature of queuing systems these systems generally require a durable store. Dialog provides these same transaction semantics regardless of durability of the Dialog Store providing the same program model in all cases. For example the in memory store provides transactional semantics by participating as a transactional resource manager. Dialog however allows the application implementation to be isolated from deployment details including the details associated with transport and connectivity characteristics message routing and endpoint state management.

Another feature provided by Dialog is an optional poison message function. As previously mentioned when a message is received and processed under a transaction and that transaction aborts the message remains in the Dialog Store and is available for re delivery to the application. Sometimes the problem that causes the transaction to abort is transient e.g. timeout due to deadlock and delivery and message processing succeeds on the next attempt. If delivery attempts for a given message repeatedly cause an abort the message is considered poison . Dialog provides a way to configure how many times message delivery aborts before the message is considered poison. When a poison message is detected an error is raised to the application and further attempts at processing the message are halted until the application takes corrective action. This ensures that processing resources are not wasted attempting work that may never succeed or may succeed only after some intervention. Poison message detection can be configured via a profile described below or specified in application code.

The optional profiles feature provides a named set of Dialog configuration options. As described above there are many configurable features of Dialogs such as buffer quotas timeouts stores etc. Further Dialog provides for configurable message delivery assurances e.g. ALO AMO and IO which application codes can independently specify a minimum level of desirable delivery assurance that can be increased through configuration if desired. Profile provides a way to group common Dialog settings and to refer to those settings by name. Further Dialog implementation allows the selection of profiles through application configuration files so that administrators have deployment time control over settings. When creating or accepting Dialogs applications refer to the profile by name and all the settings as specified in the profile are used to create the Dialog . Setting may be established directly as part of an application program as code or as other programming constructs. Profiles may be associated with a program indirectly by references in code or other programming constructs such that profile values can be set independent of the application programs. Profile values established directly take precedence over profile value set indirectly by profile references.

Because Dialog provides for any combination of these features and assurances independent of one another Dialog can be configured to meet any coupling configuration from tightly coupled programming models similar to that of Transmission Control Protocol TCP and Remote Procedure Call RPC to loosely coupled programming models similar to datagrams and queues. In addition Dialog efficiently supports the various two party message exchange patterns MEPs such as one way half duplex from a single request response to more complex patterns and the most complex full duplex interactions. Accordingly Dialog allows for the unification of two party communication programming models.

Messages are buffered in Send State to maintain state about the individual messages in a sequence. At this point the messages are said to be captured in State and Send returns to the application. More particularly the Send method accepts one message as a parameter. It is this message that is passed to the Send buffer to be stamped with a sequence number and subsequently or simultaneously stored in Store . It is at this point that the message is deemed captured and the Send method returns. Repeating this call with other messages results in a sequence or partial sequence of messages .

The Dialog State comprises Send and Receive Buffers and respectively. The Dialog State controls and stores such invariant information as the Dialog identifier the assurances specified by the application and the partner endpoint address. The Dialog State also controls session information such as next outgoing transmission sequence number and acknowledgement state. Further configuration data such as the Dialog TTL timeouts the location of the store etc. is maintained in Dialog Session State .

Once a message is captured Protocol can then process and transmit the captured message e.g. message accordingly through Port . The programming model and runtime infrastructure for Dialog provide a flexible and efficient endpoint resolution model.

The model at a minimum insures that the two endpoints are sufficiently resolved to provide for reliable message exchange. In particular Protocol can insure prior to delivering the initial message in a dialog for processing that both endpoints hold a reference sufficient to guarantee endpoint uniqueness and the correct correlation of messages through Dialog and its corresponding session. This is required for example to ensure that a message is reliably delivered to a single session partner so as to ensure at most once delivery. This endpoint resolution can be based on multiple factors including an identifier that identifies the partner application e.g. a Universal Resource Identifier URI used by the creator of Dialog local configuration routing data in message headers intermediary configurations and the target application configuration.

It is important to note that the Application implementation does not need to be concerned with the details of Dialog endpoint resolution. The infrastructure for Dialog performs a resolution process to coordinate with the initiating endpoint to ensure that it is the uniquely selected peer endpoint for the session. This is done as needed and is transparent to the Application implementation .

The runtime end point resolution for Dialog can also be provided to ensure achieving message delivery goals while providing the flexibility to achieve correct execution in a wide range of network configurations. This feature supports the flexible deployment of applications in various configurations to address scalability availability security such as firewalls and performance requirements. Service deployment configurations include for example application farms e.g. scale out replicas and application partitions e.g. to partition processing by customer number or geographic region . Application farms and partitions can be used separately or together. For example an application may be deployed to use data dependent routing to an application partition which is in turn comprised of a farm of application servers.

Protocol also determines what type of end to end assurance and local features have been specified by Application independent of the method for performing endpoint resolution described above. If the Application specifies ALO assurance the Protocol keeps a copy of the message in Dialog s Send Buffer until the Protocol receives a positive acknowledgment from the receiver not shown that the message was properly received. When Protocol receives a positive acknowledgment from the receiver it records this fact in Session State and deletes the message from the Send Buffer . If the Protocol does not receive a positive acknowledgment within a specified retry timeout the protocol retransmits a copy of the same message with the same message sequence number. Dialog may repeat this process a number of times and may employ retry timer back off strategies in order to avoid further congestion on the network. If an acknowledgment is not received within the time period specified by the message TTL then an error is raised to inform the sending Application that the assurance could not be met.

When a dialog message is received Protocol copies the message in Receive Buffer state . The Protocol also records the next expected message sequence number. When a message is received if the Dialog assurances include AMO the message sequence number of the arriving message is compared with the set of message sequence numbers that have previously arrived which as previously mentioned are stored in Receive Buffer state . If the set already contains a matching sequence number the message is considered a duplicate and is discarded otherwise the message is placed in the local Receive Buffer for future reference.

If the assurances include ALO then the Protocol sends an un sequenced complete selective positive acknowledgment on receipt of the message to the partner endpoint for the dialog. This acknowledgement must include the sequence numbers of all messages that have been received thus far in the session. A shorthand notation that includes a set of sequence ranges can be used to conserve message space.

If the specified assurances do not include IO then the message is immediately made available for delivery to the receiving Application through the Receive Channel . In particular a notification is sent to the Application that a message is available for receipt. The Application can then call Receive whereupon the next message available for delivery is passed to the Application and delivery is said to occur.

If the IO assurance is specified the sequence number of the arriving message is compared with the next expected sequence number. If the sequence number is less than the next expected sequence number the arriving message is discarded. If they match the arriving message is immediately made available for delivery to the receiving Application and the next expected sequence number is set to the number of the next missing message. If the sequence number is greater than the next expected sequence number then the behavior depends on whether or not the ALO assurance is also specified. If the ALO assurance is not specified then the message is immediately made available for delivery to the receiving application and the next expected sequence number is set to one more than the sequence number of the arriving message . If the ALO assurance is specified the message is not made available for delivery to the receiving Application but remains in the Receive Buffer . Accordingly if they do not match a presumption that at least one other message of a lower sequence number has not yet been received. When all such missing lower numbered messages have arrived then the continuous range of messages is made available for delivery to the receiving application in the appropriate sequence and the next expected sequence number is set to the number of the next missing message.

As mentioned above when messages are available for delivery to the receiving Application a notification is issued to the receiving Application . The receiving application can then call Receive method on the Dialog Channel to accept delivery of the next message available. Receive can be called multiple times to receive each available message in turn. In order to insure ordering the event notifications are delivered serially. Accordingly when a message is available for delivery to Application a single event notification is delivered to Application by calling application code that was previously registered with a Dialog event. Until that call to the application code returns no other calls to that application code will be made even if other messages are available for delivery. Within that application code the Application would typically call Dialog Receive to receive the next available message.

Also as described above when Send is called the number of messages currently in the Send Buffer is compared with the specified buffer quota. If it exceeds the quota the caller Send is blocked on an event until either space becomes available or until the send timeout is exceeded. When space becomes available in the Send Buffer the buffer checks if there are any callers waiting to send messages. If so caller Send unblocks and again can send messages.

All states for Dialog including those in message buffers and those in Channel and those in Protocol can be simultaneously maintained in Dialog Store . The Dialog Store should contain the most up to date information. This guarantees that the Dialog State has the durability properties of the Dialog Store and allows all the features to function irrespective of the Store that is in use. For example placing a message in the Receive Buffer may involve disk writes to Store . In order to provide the assurances acknowledgments are sent only after the message has been recorded in the Store . This insures for example that either the sender or receiver always has a copy of the message. Similarly on the sending side the Send would complete only after the message has been recorded in the Store .

As previously mentioned the Dialog Store may be a pluggable store allowing tremendous flexibility to meet durability performance autonomy and administrative goals. For example a store can be selected from one of a plurality of stores within a single framework including the following a memory Dialog Store implementation that keeps all state in the application memory an express Dialog Store implementation that keeps state in the memory of a separate dedicated daemon process or a durable database store implementation such as Structured Query Language SQL server. Different dialogs within the same Application may use different stores. Moreover the present invention also provides that some Dialog Stores can be configured to run on the local computer node or another node.

Because Dialog acts as an agent on behalf of the Application Application is insulated to changes in connectivity. This enables for example batch styles of processing where an application starts sends and receives some messages and then exits without having to wait for the other endpoint to respond or even be available. Further message delivery can be scheduled with great flexibility subject only to meeting the various delivery assurances and local features e.g. message or session TTL. For example subject to delivery assurances Dialog can spread peak message loads over some period of time load balance or otherwise shift message delivery to a more cost effective time wait for a resource to become available account for message or Dialog priority etc. independent of the Application . In addition Store provides shutdown and restart capabilities for Application . Batch processing scheduling as well as application shutdown and restart capabilities increase the availability and the scalability of the system.

In addition and as alluded to above the Application can specify that the Send or Receive operations be transacted with respect to the Dialog Buffers and . This allows the application to for example receive a message send some messages on one or more dialogs and update an application table all within a single transaction. In this usage of transactions it is simply a local notion and does not carry to the other endpoint.

Dialog also provides fault recovery during runtime which can automatically recover mask many faults without involving the application implementation. An application can rely on receiving the asserted characteristics i.e. the asserted assurance and features for the life of a Dialog . If the infrastructure for Dialog or Protocol determines that the asserted characteristics can no longer be met the dialog is placed in a faulted state and a fault event is raised allowing for out of band corrective action independent from mainline application code or even the Application . If the fault can be corrected repaired the dialog can be placed back into service. Unrecoverable failures i.e. faults that cannot be repaired can result in termination of Dialog and application notification. Such a design conforms to the fail fast model which is fundamental to the development of reliable applications.

Survivable failures can include the following corrupt lost duplicated or delayed messages transport and network failures process failures intermediary failures and system failures. As mentioned above because Dialog provides an abstraction to the application and maintains its own buffers and store Dialog also supports applications and environments with intermittent connectivity. Dialogs can also adapt to changing environments such as changes to network topology renegotiated security contexts or endpoint relocation.

Dialog can automatically attempt to repair these faults on its own such as by resending a message. Alternatively or in conjunction Dialog can send a request to a third party e.g. a system operator or diagnostic code requesting assistance in repairing the fault. This assistance could be for example simple human intervention to repair a broken connection in a network or possibly an automated repair process. In any event once the fault is repaired Dialog can continue sending messages. These coupled with other availability features allows for long lived Dialogs. If however a fault cannot be resolved by Dialog or through some other third party intervention an error message should be raised to the Application that initiated the dialog.

Applications can be configured to use Dialog Stores that allow Dialogs to be maintained across application process failure and restart. Some Stores can additionally tolerate system failure and restart.

Other transmission faults can be handled automatically by a combination of domain specific fault handlers and basic message retransmission support as described above. Examples include faults resulting from security credential or policy expiration. If a message transmitted on a secured session faults due to credential expiration Dialog can renegotiate the security credentials and clear the dialog fault. When dialog processing resumes the buffered messages will be retransmitted with the updated credentials by virtue of standard retry process.

Also as mentioned above the design and corresponding infrastructure for Dialog allows the runtime to dynamically adapt a Dialog to a changing execution environment. This can be provided transparent to the application implementation and supports the existence of long lived Dialogs and highly available applications.

The above described combinations of fault handlers that can be pluggable transmission and delivery retry and the fault and repair model allow Dialogs to adapt to many environmental changes. These changes include but are not limited to policy changes e.g. message privacy protocol changes e.g. support for new security protocols network topology changes e.g. the addition or removal of routers or firewalls changing a deployed application to handle increased load e.g. introducing an application farm and or partitions and relocation of a dialog endpoint and associated state e.g. disaster recovery . This also allows for scalable deployment options which includes support from the very small to the very large. For example Dialog supports scale up scale out application replication or partitioning again transparent to the application implementation.

Reactivation can occur manually if an application requests the Channel from Dialog Manager not shown or Reactivation may occur automatically if a new message arrives for the session. Each dialog is assigned a unique ID by the Dialog Manager during Dialog Creation . This ID is passed by the Application to the Dialog Manager on a Reactivation request and the Dialog Manager uses the ID to locate the dialog state and reinitiate the channel. The Deactivation and Reactivation interfaces allow the system to limit the processing resources associated with Dialogs that are not being actively used to send outgoing messages or processing incoming messages. This allows the infrastructure to reclaim related resources except those associated with the Dialog Store . Further this design allows for resource scheduling including scheduling message transmission based on priority or resource availability batching messages for more efficient transmission scheduling message delivery based on priority or resource availability and batching message delivery for more efficient processing.

The Creation of a Dialog is controlled by the Dialog Manager and can be initiated by the application that calls the Creation function. Alternatively the messaging system can initiate Dialog Creation after receiving a message from another endpoint indicating the need for a new dialog. In this case the system notifies the Application that a dialog is requested. The Application can then call an Accept method on the Dialog Manager to accept the dialog request and cause Dialog Creation or it can call a Reject method on the Dialog Manager to reject the dialog request. The Dialog Manager also controls Teardown which can be initiated for a couple of reasons. One reason could be that the session completes successfully i.e. both sides are done sending and no more messages remain. Another reason for Teardown might be that the Dialog is terminated e.g. the application calls a Terminate function or an indication is received from the partner endpoint for termination. When one side terminates the dialog a message is sent to the other side to indicate this. There is no reliability for this message it is simply an attempt to tell the other side that the dialog was terminated. Termination implies that no further messages will be exchanged over the dialog session.

Although the description of the invention defines the dialog as a duplex communication mechanism in which application messages can be sent and received by both session endpoint partners another example embodiment includes a simplex model. In accordance with the embodiment one session endpoint only sends application messages and does not receive application messages from its partner endpoint and the session endpoint partner only receives application messages but does not send application messages. The same configurable assurances and configurable local endpoint features apply as in dialog. The implementation changes in that at the sending endpoint a receive buffer is not required and at the receiving endpoint a send buffer is not required.

Embodiments within the scope of the present invention also include computer readable media for carrying or having computer executable instructions or data structures stored thereon. Such computer readable media can be any available media that can be accessed by a general purpose or special purpose computer. By way of example and not limitation such computer readable media can comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium which can be used to carry or store desired program code means in the form of computer executable instructions or data structures and which can be accessed by a general purpose or special purpose computer. When information is transferred or provided over a network or another communications connection either hardwired wireless or a combination of hardwired or wireless to a computer the computer properly views the connection as a computer readable medium. Thus any such connection is properly termed a computer readable medium. Combinations of the above should also be included within the scope of computer readable media. Computer executable instructions comprise for example instructions and data which cause a general purpose computer special purpose computer or special purpose processing device to perform a certain function or group of functions.

Those skilled in the art will appreciate that the invention may be practiced in network computing environments with many types of computer system configurations including personal computers hand held devices multi processor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by local and remote processing devices that are linked either by hardwired links wireless links or by a combination of hardwired or wireless links through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a conventional computer including a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help transfer information between elements within the computer such as during start up may be stored in ROM .

The computer may also include a magnetic hard disk drive for reading from and writing to a magnetic hard disk a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to removable optical disk such as a CD ROM or other optical media. The magnetic hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of computer executable instructions data structures program modules and other data for the computer . Although the exemplary environment described herein employs a magnetic hard disk a removable magnetic disk and a removable optical disk other types of computer readable media for storing data can be used including magnetic cassettes flash memory cards digital versatile disks Bernoulli cartridges RAMs ROMs and the like.

Program code means comprising one or more program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computer through keyboard pointing device or other input devices not shown such as a microphone joy stick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface coupled to system bus . Alternatively the input devices may be connected by other interfaces such as a parallel port a game port or a universal serial bus USB . A monitor or another display device is also connected to system bus via an interface such as video adapter . In addition to the monitor personal computers typically include other peripheral output devices not shown such as speakers and printers.

The computer may operate in a networked environment using logical connections to one or more remote computers such as remote computers and . Remote computers and may each be another personal computer a server a router a network PC a peer device or other common network node and typically include many or all of the elements described above relative to the computer although only memory storage devices and and their associated application programs and have been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN that are presented here by way of example and not limitation. Such networking environments are commonplace in office wide or enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the local network through a network interface or adapter . When used in a WAN networking environment the computer may include a modem a wireless link or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing communications over wide area network may be used.

The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is therefore indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

