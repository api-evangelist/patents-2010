---

title: Matching queries to data operations using query templates
abstract: Systems and methods are described herein that can implemented by a middle tier of a multi-tier data retrieval system to select data operation(s) that correspond to a query. The query may be received from a front tier. The selection is performed by comparing the query to a query template associated with each data operation. The query template for each data operation includes an algebraic description of queries that each respective data operation can satisfy. The selected data operation(s) are then executed against a data service to obtain data, which is then provided to the front tier. In some embodiments, an execution plan may be created by the middle tier for satisfying the query. The execution plan can include the selected data operation(s) and post-processing step(s). The post-processing step(s) can be applied to the obtained data to satisfy the query. The post-processed data is then provided to the front tier.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08903806&OS=08903806&RS=08903806
owner: Microsoft Corporation
number: 08903806
owner_city: Redomnd
owner_country: US
publication_date: 20101210
---
Today s information technology professionals often use data retrieval systems having an n tier such as a three tiered architecture. By separating the different tiers each tier can be managed upgraded and used independently of each other. A typical three tier data retrieval system may include a front tier a middle tier and a back tier. The front tier typically interfaces to a user and can receive and or generate queries for data. The middle tier typically processes queries received from the front tier and translates them into a form that the back tier can process. The back tier typically consists of some combination of database servers that respond to data operations such as queries or stored procedures and web services that respond to web service operations. In particular the middle tier typically translates queries received from the front tier into database or web service operations collectively referred to herein as data operations that are executed by the back tier to obtain data. The middle tier then sends the obtained data back to the front tier. The middle tier thus interfaces with the front tier e.g. a client computer and the back tier e.g. one or more database servers or web services.

However typical approaches used by the middle tier to translate queries received from the front tier into data operations that can be executed by the back tier are somewhat cumbersome. A typical translation technique may only use one to one matching of front tier queries to data operations. For example a typical approach may directly translate one front tier query to one data operation. As a result the front tier queries can have little if any variation thus limiting their functionality and usefulness. Furthermore these typical approaches require that the front tier present queries using a limited and rigid syntax that can be easily translated by the middle tier using the one to one mapping.

As a result typical approaches may not be able to compensate for any variations in the front tier query. In fact these approaches limit the capability of the front tier to compose queries that have any variations. Even approaches that attempt to give the front tier more flexibility in composing queries still only use limited and inflexible mappings between queries and data operations.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter. Moreover it is noted that the invention is not limited to the specific embodiments described in the Detailed Description and or other sections of this document. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art s based on the teachings contained herein.

Systems and methods for matching queries to data operation s using query templates are described herein. In accordance with certain embodiments such systems and methods may be implemented by a middle tier of a three tier data retrieval system to select data operation s that correspond to a query. The query received from a front tier can access a data service in the back tier. Selection of data operation s is made by comparing the query to a query template associated with each data operation. The query template for each data operation includes an algebraic description of queries that each respective data operation can satisfy. The selected data operation s are then executed against a data service to obtain data which is then provided to the front tier. In some embodiments an execution plan may be created by the middle tier for satisfying the query. The execution plan can include the selected data operation s and post processing step s . The post processing step s can be applied to the obtained data to satisfy the query. The post processed data is then provided to the front tier.

Further features and advantages of the invention as well as the structure and operation of various embodiments of the invention are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art s based on the teachings contained herein.

The features and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings in which like reference characters identify corresponding elements throughout. In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements. The drawing in which an element first appears is indicated by the leftmost digit s in the corresponding reference number.

The following detailed description refers to the accompanying drawings that illustrate exemplary embodiments of the present invention. However the scope of the present invention is not limited to these embodiments but is instead defined by the appended claims. Thus embodiments beyond those shown in the accompanying drawings such as modified versions of the illustrated embodiments may nevertheless be encompassed by the present invention.

References in the specification to one embodiment an embodiment an example embodiment or the like indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic. Moreover such phrases are not necessarily referring to the same embodiment. Furthermore when a particular feature structure or characteristic is described in connection with an embodiment it is submitted that it is within the knowledge of one skilled in the relevant art s to implement such feature structure or characteristic in connection with other embodiments whether or not explicitly described.

A system for matching queries to data operation s using query templates is described herein. In accordance with certain embodiments such system may be implemented by a middle tier of an n tier data retrieval system such as a three tier data retrieval system to select data operation s that correspond to a query. The query received from a front tier can access a data service in the back tier. The selection of data operation s is made by comparing the query to a query template associated with each data operation. The query template for each data operation includes an algebraic description of queries that each respective data operation can satisfy. The use of query templates associated with each data operation advantageously allows a variety of queries to match the data operations. In certain embodiments query templates with optional operators and operators and values that can be extracted from a query may be used to provide additional flexibility. The selected data operation s are then executed against a data service to obtain data which is then provided to the front tier.

In some embodiments an execution plan may be created by the middle tier for satisfying the query. The execution plan can include the selected data operation s and one or more post processing steps. The selected data operation s can be executed against the data service to obtain data that only partially satisfies the query. The post processing step s can then be applied to the obtained data to substantially fully satisfy the query. The post processed data is then provided to the front tier.

Data retrieval system may be implemented using an n tier architecture such as a three tier architecture. Data retrieval system may include a front tier a middle tier and a back tier . In one embodiment three tiers and may be logical tiers also referred to as layers that are implemented on a single computing system or device. In another embodiment one or more of three tiers and of data retrieval system may be each implemented using a separate computing system or device. In various embodiments and examples presented herein three tier data retrieval system is described. However the scope of the example embodiments is not limited to three tier data retrieval systems. For example another type of an n tier data retrieval system can be used that has more logical and or physical tiers.

In one embodiment front tier may include a user interface such as graphical user interface GUI that allows a user to compose or select a query. In another embodiment front tier may execute an application that generates the query. Middle tier may include query processing logic that processes the query received from front tier . Middle tier may select one or more data operations that correspond to the query such as by comparing the query to a query template associated with each data operation. Embodiments for selecting data operation s that correspond to the query are described below.

Middle tier then passes the selected data operation s to back tier to be executed. Back tier may comprise for example a database server and one or more databases associated therewith or one or more web services although these examples are not intended to be limiting. Back tier executes the selected data operation s to obtain data and then passes the obtained data to middle tier . Middle tier may perform one or more post processing functions on the obtained data in order to satisfy the query. Embodiments for selecting or identifying post processing function s for satisfying the query are described below. Middle tier then returns the obtained and or post processed data to front tier . An interface such as a graphical user interface GUI implemented by front tier may present the obtained and or post processed data to user s . Also an application that initially requested this data e.g. by generating the query on front tier may use the obtained and or post processed data.

In embodiments data operation s may be selected based on the query in various ways. For instance is a detailed block diagram of an example three tier data retrieval system that is configured to match queries to data operations using query templates in accordance with an embodiment. Data retrieval system includes a requesting entity a middle tier and a data service . Requesting entity is an example of a front tier such as front tier of and it may interface with user s . Middle tier is an example of middle tier of . Data service is an example of a back tier such as back tier of .

Requesting entity is intended to broadly represent any system or device capable of generating a query and providing it to middle tier . In one embodiment a user may interact with an application executing on requesting entity in order to generate the query. For example a user may interact with an application that executes in the context of a Web browser e.g. where requesting entity includes the application and the web browser. The application may cause the Web browser to generate a query in a Uniform Resource Location URL form. The query in URL form may then be converted to a form that can be provided to middle tier by a Web services component such as a Windows Communication Foundation WCF services component. The query is then provided to middle tier by requesting entity .

In another embodiment requesting entity may execute an application that automatically generates a query at run time. For example the application may include a query that is written i.e. hard coded into the application during development thereof using C C C Java and or any other programming language known in the art. During compilation of the application the hard coded query may be automatically converted into a form that can be submitted to middle tier . During execution of the compiled application the query can then be automatically submitted to middle tier as necessary to carry out the functionality of the application.

In another embodiment requesting entity may execute an application that allows a user to dynamically compose and submit a query to middle tier at run time. Still other methods used by requesting entity to generate the query are contemplated and the scope of the example embodiments is not limited to the examples described above.

Middle tier processes the query received from front tier in a manner that will be described below to obtain data from data service and returns query results that include the obtained data to requesting entity . Requesting entity may then use the query results such as by presenting the query results to user s such as user s via a suitable interface and or using the query results in an application that generated the query.

The query received by middle tier may be expressed using one or more of various protocols used for presenting queries such as Standard Query Language SQL Language Integrated Query LINQ Extensible Markup Language Query XML Query or XQuery etc. In various embodiments and examples presented herein LINQ form s of the query are described but the scope of the example embodiments is not limited in this respect.

In one embodiment the query may be represented using a data structure known in the art as a LINQ expression tree. For example in one embodiment the query is represented as a LINQ expression tree that includes a root node that points to the query and one or more child nodes connected to the root node that contain body and or parameters of the query. However this is only an example and other data structures and forms may be used to represent the query.

As further shown in middle tier includes a plurality of interconnected components including a request processor a query normalizer a query matcher a catalog and a result assembler . These components may comprise for example software modules executing upon a single computing device or alternatively software modules distributed across and executing upon separate but connected computing devices.

Middle tier receives a query from requesting entity . Middle tier processes the query in a manner to be described below wherein such processing includes selecting one or more data operations from among a fixed set of data operations that correspond to the query. Middle tier executes the selected data operation s against data service and receives data from data service in response to the execution of the selected data operation s . Middle tier is configured to return query results to requesting entity that includes the obtained data.

Request processor receives a query from requesting entity . Request processor forwards the query to query normalizer for application of a normalization process thereto. Query normalizer returns a normalized version of the query referred to herein as the normalized query to request processor . Request processor then forwards the normalized query to query matcher . Query matcher returns an execution plan to request processor wherein the execution plan includes one or more data operations to be executed against data service that are selected based on the normalized query. Request processor then forwards the execution plan to result assembler . Result assembler executes the selected data operation s against data service to obtain data. Result assembler transmits query results that include the obtained data to request processor . Request processor then forwards query results that include the obtained data received from result assembler to requesting entity .

In one embodiment the execution plan generated by query matcher also includes one or more post processing functions in addition to the selected data operation s to be executed against data service . The post processing function s are to be performed on the data obtained from data service to satisfy the query. In accordance with this embodiment request processor forwards the execution plan that includes the post processing function s and the data operation s to result assembler .

Query normalizer normalizes the query received from request processor by generating a representation of the query that accords with a standard or canonical query form. The generated representation is referred to herein as the normalized query. This normalized query is then returned to request processor . By performing the normalization function query normalizer ensures that query matcher will return consistent results i.e. will select the same one or more data operations for equivalent queries that request the same data but that are expressed in different forms. Example normalization operations that may be performed by query normalizer when the query is expressed as a LINQ expression may include reordering the expressions of binary operators so that they are handled consistently or merging consecutive filtering e.g. .Where calls into a single call joining them into a conjunctive AND ed form. If query normalizer determines that the query received from request processor does not require modification to be placed in the standard or canonical form then the normalized query passed by query normalizer back to request processor may be the same as the original query.

Query matcher receives the normalized query from request processor . Query matcher is configured to select one or more data operations that correspond to the normalized query from among a fixed set of data operations by comparing the normalized query to a query template associated with each data operation. In one embodiment query matcher creates an execution plan that includes the selected data operation s . The selected data operation s can be executed against a data service e.g. data service to obtain data that fully satisfies the normalized query. In another embodiment query matcher creates an execution plan that includes the selected data operation s and one or more post processing steps. In accordance with this embodiment the selected data operation s that are executed against data service obtain data that only partially satisfy the normalized query. However the post processing step s can then be applied to the obtained data to fully satisfy the normalized query. In accordance with both embodiments the execution plan is transmitted to request processor for forwarding to result assembler .

As noted above query matcher selects data operation s from among a fixed set of data operations based on the normalized query. In particular query matcher accesses catalog that stores a set of query templates wherein each query template is associated with a data operation in the fixed set of data operations. Each query template comprises an algebraic description of queries that the associated data operation can satisfy. Query matcher then selects one or more data operations that match the normalized query based on the query template s associated with each data operation. In one embodiment the catalog may contain additional information about the data operations for example an associated cost estimate. Query matcher may utilize this information to minimize the cost of the selected data operation s .

To facilitate matching each query template may be specified using a language or format that is substantially similar to that used to represent the normalized query. For example in an embodiment in which the normalized query is expressed using a LINQ expression each of the query templates may also be expressed as a LINQ expression. Furthermore in an embodiment in which the normalized query is represented using a LINQ expression tree each of the query templates may be represented by a LINQ expression tree.

Query matcher selects those data operation s from among the fixed set of data operations that are associated with query templates that are deemed to best match the normalized query. In accordance with certain embodiments query matcher performs this function by evaluating similarities between a LINQ expression or LINQ expression tree that represents the normalized query and each of a plurality of LINQ expressions or LINQ expression trees that represent the query templates associated with the data operations. This may involve for example evaluating similarities between the content of nodes of a LINQ expression tree that represents the normalized query and the content of corresponding nodes of a LINQ expression tree associated with each data operation. Persons skilled in the relevant art s will appreciate that a number of alternative methods for matching tree structures may also be used. Furthermore in certain embodiments query matcher may use a set of rules to drive the matching process. Additional query template operators in query template algebraic descriptions may allow query matcher to match a wider set of normalized queries and to extract information from them.

Examples of the matching process performed by query matcher will now be provided. These examples will be described in reference to an embodiment in which the normalized query and query templates are represented using LINQ expressions. However the scope of the example embodiments is not limited in this respect. For example the normalized queries and query templates described below may also be represented using LINQ expression trees and query matcher may use an analogous selection process to the one described.

which is intended to obtain a list of all customers from data service . Query matcher may receive the above normalized query in either the form shown and or as a LINQ expression tree. Query matcher may compare the normalized query to each of the query templates stored in catalog . Such query templates may include a query template for the following data operation 

In accordance with the above example query matcher may select the ListGetAllCustomers data operation from among the fixed set of data operations based on the comparison of the Customers LINQ expression of the normalized query to the GetAllCustomers Customers LINQ expression of the query template associated with the ListGetAllCustomers data operation. In this example when the selected data operation of ListGetAllCustomers is executed against data service data will be returned that satisfies the normalized query. Thus in accordance with this example query matcher can select a single data operation from among the fixed set of data operations that can be executed against data service to satisfy the normalized query Customers . It is noted that in certain embodiments query matcher may select two or more data operations from among the fixed set of data operations that when executed against data service will satisfy the normalized query.

In one embodiment query matcher may select data operation s from among the fixed set of data operations that only partially satisfy the normalized query. In other words the data returned from data service responsive to execution of the selected data operation s will not fully satisfy the normalized query. For example such returned data may comprise more data than the normalized query was intended to obtain and or data that is sorted in a different order than that specified by the normalized query. In one embodiment query matcher may identify one or more post processing functions to be applied by result assembler on data obtained by executing the selected data operation s against the data service. These post processing function s may be identified as part of the execution plan that is provided by query matcher to request processor along with an identification or description of the selected data operation s .

which is intended to obtain a list of all customers having a customer identifier of MSFT from data service . Query matcher may receive the above normalized query in either the form shown and or as a LINQ expression tree. Query matcher may compare the normalized query to each of the query templates stored in catalog . Such query templates may include a query template for the following data operation 

In accordance with the above example query matcher may select the ListGetAllCustomers data operation from among the fixed set of data operations based on the comparison of the Customers .Where c c.ID MSFT LINQ expression of the normalized query to the GetAllCustomers Customers LINQ expression of the query template associated with the ListGetAllCustomers data operation. In this example when the selected data operation of ListGetAllCustomers is executed against data service data will be returned that will not fully satisfy the normalized query. Therefore query matcher may identify one or more post processing functions to be performed on the data obtained from data service by result assembler to satisfy the normalized query. In accordance with this example the identified post processing function s may filter the data obtained from data service based on execution of the selected data operation of ListGetAllCustomers to generate a subset of that data that contains a list of customers having a customer identifier of MSFT thus satisfying the normalized query.

which is intended to obtain a list of all orders for all customers having a customer identifier of MSFT from data service . Query matcher may receive the above normalized query in either the form shown and or as a LINQ expression tree. Query matcher may compare the normalized query to each of the query templates stored in catalog . Such query templates may include query templates for the following data operations 

In accordance with the above example query matcher may select the ListGetAllOrders data operation from among the fixed set of data operations based on the comparison of the Customers .Where c c.ID MSFT .SelectMany c c.Orders LINQ expression of the normalized query to the GetAllOrders Orders LINQ expression of the query template associated with the ListGetAllOrders data operation. For example query matcher may select the ListGetAllOrders data operation over the other data operations in the fixed set of data operations based on several matching factors including how close the LINQ expression of the query template associated with this data operation matches the LINQ expression of the normalized query. In this example when the selected data operation of GetAllOrders Orders is executed against data service data will be returned that will not fully satisfy the normalized query. Therefore query matcher may identify one or more post processing functions to be performed on the data obtained from data service by result assembler to satisfy the query. In accordance with this example the identified post processing function s may filter the data obtained from data service based on execution of the selected data operation of GetAllOrders Orders to obtain a subset of that data that contains all orders for the list of customers with a customer identifier of MSFT thus satisfying the query.

In one embodiment query matcher may compare the normalized query to a query template that includes an operator that indicates optionality. Query matcher ascertains whether or not the query template with the operator that indicates optionality matches the normalized query. The operator that indicates optionality is used to indicate that an element of a query template is to be deemed optional during matching meaning that the normalized query need not include the optional element in order to be deemed matching. The use of query templates that include operators that indicate optionality advantageously enables a query template to be defined that will match up with many different variations of the same query wherein the variations are premised on the inclusion or exclusion of certain optional elements such as optional parameters.

Any of a variety of suitable operators may be used to indicate optionality within a query template depending upon the implementation. For example in certain embodiments a .Where element of a query template expressed as a LINQ expression may be identified as optional by expressing the .Where element as an .OptionalWhere element wherein the indicator of optionality is the inserted Optional text. However this is merely one example. Persons skilled in the relevant art s will readily appreciate that any number of other operators may be used.

In one embodiment query matcher compares the normalized query to a query template that includes at least one extraction element. As referred to herein an extraction element is a part of a query template that is specified in a manner that indicates to the query matcher that the element should be replaced with a particular value or operator extracted from the normalized query prior to matching. During the selection process performed by query matcher query matcher will extract the value operator or information element such as the name of a property element or a sequence of property element references in the normalized query that is identified by the extraction element and then replace the extraction element with the extracted value operator or information element. This feature enables query templates to be defined in a flexible manner that allows elements of the template to be defined in reference to corresponding elements of the normalized query.

In accordance with the above example query matcher may select the ListGetOrdersForCustomer string customerID data operation from among the fixed set of data operations based on the comparison of the LINQ expression of the normalized query to the LINQ expression of the query template associated with the respective data operation. In this example the element Where c c.ID ExtractConstantForParam customerID in the query template includes the extraction element ExtractConstantForParam customerID . During the selection process query matcher extracts the parameter customerID from the normalized query which in this case may be MSFT. Once this parameter is extracted from the query it can be used as a part of the respective query template. In accordance with this example the query template after extraction and replacement is GetOrdersForCustomer Customers . Where c c.ID MSFT .SelectMany c c.Orders . In other words the extraction element ExtractConstantForParam is replaced with of the constant MSFT which is extracted from the normalized query. Query matcher then continues with the selection process using the query template that includes the extracted constant. Query matcher may record information about the extraction occurrence in the execution plan. For example query matcher may configure a designated element of a description of the execution plan with a corresponding element extracted from the query or provided by the query template associated with a selected data operation.

It is noted that in accordance with certain embodiments query templates may be defined that include any combination of the above features. For example query templates may be defined that use one or more extraction elements in conjunction with one or more optional elements.

In one embodiment query matcher may determine that there are no data operation s from the fixed set of data operations that can fully satisfy the normalized query and may further determine that there are no available post processing function s that can be applied to data obtained from data service to fully satisfy the query. For example in certain embodiments certain post processing function s may not be made available due to a determination by developers or administrators of middle tier that such post processing function s are too expensive or otherwise undesirable to perform. In this case query matcher may return a result to request processor indicating that the normalized query cannot be performed and that result may be passed back to requesting entity . Alternatively query matcher may return an execution plan to request processor that when executed by result assembler will result in the production of query results that do not fully satisfy the originally submitted query. These query results may then be passed back to requesting entity by request processor .

In one embodiment catalog stores a fixed set of data operations and associated query templates. In another embodiment catalog only stores query templates associated with the fixed set of data operations and the fixed set of data operations are stored in and ready to be executed by result assembler . The fixed set of data operations and associated query templates stored in catalog may be defined by administrators and or developers of middle tier or by some other entity. In one embodiment catalog may store a set of data operations that is modified over time by developers or by some other entity. In another embodiment catalog may not store associated query templates but instead derive them from other information such as a set of conventions on data operation names.

It is noted that although catalog is shown in as a logically distinct component an implementation may combine catalog with another component of data retrieval system . For example an implementation may integrate catalog directly into query matcher or may store catalog inside data service itself.

Result assembler receives the execution plan from request processor . The execution plan may contain selected data operation s to be executed against data service to obtain data. In one embodiment result assembler includes the fixed set of data operations for which catalog stores respective associated query templates. In other words catalog may only store the query templates for data operations that are included in and executable by result assembler . Result assembler may execute the selected data operation s as specified by the execution plan against data service . Data service may return data to result assembler in response to the selected data operation s being executed.

Result assembler may also store and be able to execute post processing function s . As discussed above the execution plan may also contain post processing function s that can be performed on data obtained from data service . Result assembler may execute the post processing function s specified by the execution plan on the data obtained from data service . As described above post processing function s can include filtering and other functions that can be performed on the obtained data in order to satisfy the normalized query.

In one embodiment the fixed set of data operations that is executable by result assembler may include one or more data operations associated with the Simple Object Access Protocol SOAP the Distributed Common Object Model DCOM and or Remote Procedure Call RPC . For example a selected data operation may be a SOAP operation that when executed accesses data service .

Result assembler returns query results to request processor for forwarding to requesting entity . The query results include the obtained data and or the post processed data.

Data service serves as a back tier of 3 tier data retrieval system . Data service may include a database server and one or more databases connected thereto or one or more web services. In an embodiment in which data service comprises a database server the database server may comprise any type of a database server including any type of a relational database server an object relational database server an object oriented database server etc. As discussed above data service may be accessed using data operation s executed by middle tier i.e. result assembler . In response to receiving data operation s from result assembler data service is configured to return data.

Example methods for matching queries to data operations using query templates in accordance with various embodiments will now be described. In particular depicts a flowchart of an example data retrieval method that matches queries to data operations using query templates in accordance with an embodiment. The method of flowchart will now be described with continued reference to system as described above in reference to . However persons skilled in the relevant art s will appreciate that the method of flowchart is not limited to those implementations.

As shown in the method of flowchart begins at step in which a query is received from a requesting entity. This step may be performed for example by request processor of system . As discussed above with reference to system the query may request specified data from a data service such as data service of system . For example request processor may receive the query from requesting entity .

At step data operation s are selected from among a fixed set of data operations for accessing the data service by comparing the query to a query template associated with each data operation. Each query template includes an algebraic description of queries that the associated data operation can satisfy. This step can be performed for example by query matcher of system .

At step the selected data operation s are executed against the data service to obtain data. This step can be performed for example by result assembler of system . For example the selected data operations may be executed by result assembler against data service to obtain data.

At optional step post processing function s can be performed on data obtained from the data service to satisfy the query. This step can be performed for example by result assembler of system . For example the post processing function s may be executed by result assembler on data obtained from data service to satisfy the query.

At step the obtained data is provided to the requesting entity. This step can be performed for example by request processor of system . For example request processor can provide query results that include the obtained data or the post processed data to requesting entity .

As shown in the method of flowchart begins at step in which a query is received. This step may be performed for example by request processor of system . As discussed above with reference to system the query may request specified data from a data service such as data service of system .

At step an execution plan is generated for satisfying the query. The execution plan may include references to data operation s executable against a data service and post processing step s to be applied to data obtained from the data service. This step may be performed for example by query matcher of system . For example query matcher may generate an execution plan that includes data operation s for obtaining data and post processing step s to be performed on the obtained data. The execution plan identifies the data operation s based on an extent to which the query matches an algebraic description of queries that can be satisfied by each of the data operation s .

At optional step the execution plan is provided to an entity for execution. This step can be performed for example by request processor of system . For example request processor may provide the execution plan to result assembler for execution.

As shown in computer system includes a processing unit a system memory and a bus that couples various system components including system memory to processing unit . Processing unit may comprise one or more processors or processing cores. Bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. System memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS is stored in ROM .

Computer system also has one or more of the following drives a hard disk drive for reading from and writing to a hard disk a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM DVD ROM or other optical media. Hard disk drive magnetic disk drive and optical disk drive are connected to bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of computer readable instructions data structures program modules and other data for the computer. Although a hard disk a removable magnetic disk and a removable optical disk are described other types of computer readable media can be used to store data such as flash memory cards digital video disks random access memories RAMs read only memories ROM and the like.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM. These programs modules may include one or more of request processor query normalizer query matcher and or result assembler . When executed by processing unit these program modules can perform functions and features described above including but not limited to any of the steps or functions described above in reference to flowchart of and flowchart of .

A user may enter commands and information into the computer system through input devices such as keyboard and pointing device . Other input devices not shown may include a microphone joystick game controller scanner or the like. In one embodiment a multi touch capable touch screen is provided in conjunction with a display to allow a user to provide user input via the application of a touch as by a finger or stylus for example to one or more points on the touch screen. These and other input devices are often connected to processing unit through a serial port interface that is coupled to bus but may be connected by other interfaces such as a parallel port game port or a universal serial bus USB . A display is also connected to bus via an interface such as a video adapter . In addition to the display computer system may include other peripheral output devices not shown such as speakers and printers. Computer system is connected to a network e.g. a local area network or wide area network such as the Internet through a network interface or adapter a modem or other means for establishing communications over the network. Modem which may be internal or external is connected to bus via serial port interface .

As used herein the terms computer program medium and computer readable medium are used to generally refer to non transitory media such as the hard disk associated with hard disk drive removable magnetic disk removable optical disk as well as other media such as flash memory cards digital video disks random access memories RAMs read only memories ROM and the like.

As noted above computer programs and modules including application programs and other program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM. Such computer programs may also be received via network interface or serial port interface . Such computer programs when executed or loaded by an application enable computer to implement features of embodiments discussed herein. Accordingly such computer programs represent controllers of computer system .

Embodiments are also directed to computer program products comprising software stored on any computer readable medium. Such software when executed in one or more data processing devices causes a data processing device s to operate as described herein. Embodiments may employ any computer useable or computer readable medium known now or in the future. Examples of computer readable mediums include but are not limited to storage devices such as RAM hard drives floppy disks CD ROMs DVD ROMs zip disks tapes magnetic storage devices optical storage devices MEMS based storage devices nanotechnology based storage devices and the like.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. It will be apparent to persons skilled in the relevant art s that various changes in form and details can be made therein without departing from the spirit and scope of the invention. Thus the breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

