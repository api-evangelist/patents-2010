---

title: Layering concept for a repository of a user interface framework for web applications
abstract: Various embodiments of systems and methods for a layering concept for a repository of a user interface framework for Web applications are described herein. The content of a repository provided by different parties (e.g., vendor, partner, customer, user, etc.) is separated. The separation is achieved by assigning solutions to the parties that store content in the repository. Simplified access to the repository is achieved by layering the solutions in a stack and implementing a layer strategy for the layers and their order of access.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08694544&OS=08694544&RS=08694544
owner: SAP AG
number: 08694544
owner_city: Walldorf
owner_country: DE
publication_date: 20101227
---
The field generally relates to the software arts and more specifically to methods and systems for a layering concept for a repository of a user interface framework for Web applications.

In the world of computing Web applications such as Rich Internet Applications RIAs have many of the characteristics of desktop applications. The RIAs are typically delivered either by a site specific browser a browser plug in or independently via a virtual machine. The most commonly used frameworks that support such Web applications are Adobe Flash Java and Microsoft Silverlight . Generally the framework has to be installed using the computer s operating system prior to launching the RIA. The Web application framework typically downloads updates verifies and executes the RIA. Microsoft Silverlight is a programmable Web browser plug in that enables features such as animation vector graphics and audio video playback that characterize RIAs. Microsoft Silverlight brings additional interactivity features and support for .NET languages and development tools. It is compatible with multiple Web browser products. Microsoft Silverlight which was developed under the codename Windows Presentation Foundation Everywhere WPF E is a web based subset of WPF.

Many Web application frameworks follow the Model View Controller MVC architectural pattern to separate the data model with the business logic from the user interface. The MVC pattern modularizes code promotes code reuse use of existing software code or software knowledge to build new software code and allows multiple interfaces to be applied. The MVC architecture consists of a model a view and a controller. The model part of the MVC pattern is a domain specific representation of the data upon which the application operates. Domain logic adds meaning to raw data for example calculating the totals taxes and shipping charges for shopping cart items . When a model changes its state it notifies its associated views so they can refresh. The view of the MVC pattern renders the model into a form suitable for interaction typically a user interface element. Multiple views can exist for a single model for different purposes. The controller of the MVC pattern receives input and initiates a response by making calls on model objects. When a Web application user interface framework is built on the MVC architectural pattern approach high speed development of uniform user interfaces UIs is possible.

Various embodiments of systems and methods for a layering concept for a repository of a user interface framework for Web applications are described herein. In an embodiment the method includes receiving a request to obtain a data object from a repository wherein the repository is organized in a set of layers each layer implemented as a file system that stores content for a solution. The method further includes providing access to the repository based on a layer strategy wherein the layer strategy includes a definition of at least one layer from the set of layers and a definition of a sequence access to the set of layers. Finally the set of layers of the repository is searched for the data object based on the sequence access to the set of layers defined in the layer strategy.

In an embodiment the system includes a processor and a memory in communication with the processor. The memory includes a repository organized in a set of layers each layer implemented as a file system that manages content for a solution. The repository includes a personalization file system that stores personalization settings a development file system that stores temporary content which in response to activation is moved to a writable layer and a list file system that includes the set of layers wherein the set of layers are defined in a layer strategy.

These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof presented in connection with the following drawings.

Embodiments of techniques for a layering concept for a repository of a user interface framework for Web applications are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiment.

In one embodiment the UI Framework Client Runtime may be implemented in a programming language such as C using a RIA based framework such as Microsoft Silverlight technology. The UI Framework Client Runtime is responsible for rendering user interfaces and accessing business data from backend . Every user request is triggered on the UI Framework Client Runtime . The very first request is a navigation request that results in a request to the backend to read a UI component. The UI component is read from the Repository in the backend and transported to the frontend . A component manager instantiates the UI component and a corresponding component controller for the UI component on the frontend and triggers the initialization of the UI component on the backend . The component manager builds up a control tree for the UI component out of a set of UI controls . These UI controls ensure conformable look and feel and the ability to change UI themes consistently. The controls in the themed UI controls package are all enabled in a consistent way for test automation and accessibility and are provided in a manner so that native implemented custom UI panes can make use of those controls. Usually more than one UI component is needed to render a UI as UI components typically embed other UI components e.g. a Work Center component embeds a set of Work Center View Components and they again embed other components . The top level UI component that is rendered is the root UI component which ensures the rendering of a common frame for all UI components e.g. by rendering the top level navigation and the ability for personalization from personalization unit .

In an embodiment the UI Framework Client Runtime also comprises the following built in units analytics mashups diagnostics shell and frontend scripting engine . Analytics are components that represent data in a grouped aggregated and hierarchical way. These components serve to answer business questions about for example how many products were sold in a particular country and provide drill down capabilities to different levels of abstraction. Diagnostics allows the collection of for example the context of the current framework and all other running entities of the overall system at a specific point in time e.g. in case of an exception or error . The collected information can help to track down the cause of the exception. Shell unit provides the shell for running the UI Framework Client Runtime. It includes all units for the user interface ranging from defining the overall appearance of windows including standard elements such as menus toolbars navigation areas windows management as well as the mediator layer that maps logical component definitions from the configuration model to physical controls. In addition there are possibilities to use a Silverlight feature to run the client in out of browser mode. Also a prototype exists to run the client as a standard WPF desktop client in contrast to the Silverlight browser plug in. This requires some replacement of connectivity and authorization code which is provided by the browser stack itself. Frontend scripting engine enables data from the client side data model to be read evaluated and modified which eventually causes configured events again in the runtime execution of the model. With these capabilities UI only logic can be expressed and modeled via some script it is not required to implement or model the logic in the backend. Optionally the script can be executed on the client or backend.

The frontend communicates with the backend via browser on a regular HTTP HTTPs connection using JavaScript Object Notation JSON also other serialization formats such as XML can be used in parallel to JSON as a lightweight data interchange format. The requests from the frontend are received at Internet Communication Framework ICF . The ICF forwards the requests to the UI Framework Server Runtime and Repository . The Repository stores all UI entities with their metadata. The UI Framework Server Runtime reads and interprets the UI model of the application manages the access to the backend and ensures an optimized communication with the UI Framework Client Runtime . After the UI Framework Client Runtime triggers the initialization of a UI component in the backend for a first time in a session the UI Framework Server Runtime first creates a master controller for the complete session and then creates a component controller for each component that is requested from the UI Framework Client Runtime . Each component controller builds a UI data container out of the information of the UI model for a component. At runtime the composition of the dependent components is combined within the master controller which holds one event queue and performs data updates for all included components as one component. In an embodiment logically separated declared components can be configured to run as one virtual controller at runtime.

After the master controller has processed all component controllers it collects all the data that has changed in the UI data container and makes sure that all changed data and only the changed data is transported to the client . The access from the UI Framework Server Runtime to business data is performed via connector . Connector is able to connect to different technologies.

The service provider is managed by the repository . For UI components the service provider is aware of the internal buildup of the entity. The structure of UI components may be described in an XML Schema Definition XSD format. A UI component consists of a model part a controller part and a view part. The model part contains the binding to the business objects and represents the data sources available in the UI. The controller part describes special UI logic and can contain reference script coding e.g. Ruby Script . The view part contains the UI elements and their layout. UI texts are language dependent and need to be mixed in according to the logon language of the user.

The service provider registry and all other metadata that belongs to the repository are also exposed by the APIs which are accessed through different clients. The repository provides an option to expose text from the different content types into tables and other units of the framework to access the tables and handle the exposed text. For example a translation unit can translate the text and when the translation is performed the repository handles the merging back of the text into the different content types via service calls. For example some text can be defined in a user interface such as a title of a floor plan the header of a section etc. and this text is stored in a UI component which is stored in the repository . A service provider implements the interfaces from the core repository layer. Using the implemented interface the framework is notified that there is some text for translation available. The framework extracts the text in a separate table or tables and the translation process is performed. Once the translation is finished the translated text is filled back in the table. Later when the runtime requests that specific user interface for which the text has been translated to run then the repository has the feature to merge text in the appropriate language into the content and thus the content provides the translated UI back to the user.

The administration user interfaces allow the users to manage and configure the repository by actions such as registering service provider creating solutions creating projects handling transport issues and so on. The design time UIs and the runtime UIs communicate with the repository via HTTP HTTPs connections. The HTTP calls get post are routed directly via JSON connector to the repository APIs . The core part of repository includes repository engine and core toolbox . Core toolbox is used by repository engine to provide core functionalities such as addressing naming layering versioning locking transport handling caching etc. The core part of repository is not aware of the semantics of its content if the content is an image a document coding a .dll file and so on. The commonly needed core functionalities guarantee a fast and easy integration of different content types into the repository . Specific functionalities concerning the semantics of the content are handled by specialized service providers. A service provider such as service provider can be written and registered in the repository core to perform the handling of dedicated content types. The registered service provider can use the core toolbox to implement their functionalities.

In an embodiment internal file systems may be implemented in the repository core to execute base operations such as put get and list of files. In repository a file system that can be delivered or imported into a system is unique in the repository as identified with a globally unique identifier GUID and has type of solution . The file systems include but are not limited to a default file system a customer file system a development file system a personalization file system list file system layer strategy file system all file system and so on.

The default file system accesses the core header table of the repository it is user and client independent. The default file system also provides the transport connection and lock mechanism. The customer file system is a special implementation of default file system. This file system accesses the client dependent header table. In the customer file system all changes that belong to one customer are stored. The customer file system does not provide a transport mechanism but a lock mechanism is available so that nobody from the same client is able to edit the same file concurrently. This type of a file system is used in a customer system. Customers are not allowed to modify any entities that belong to solutions of other partners. Modifying or extending entities is performed by using the relative URL of the entity for an own replacement of the entity.

The development file system is a default file system that is not created based on the user settings. This file system is always added by the core of the repository. The development file system accesses the client and the user dependent header table and acts as a work list during development. All content in this file system is temporarily stored and after activation will be moved into the next writable layer. This type of a file system does not provide a transport and a lock mechanism. Partners can deliver their own solutions which can refer to other solutions. Partners are not allowed to modify any entities that belong to solutions of other partners. Modifying or extending entities is performed by using the relative URL of the entity for replacement of the entity.

Personalization file system is also user and client dependent it stores the user specific changes. The personalization file system does not provide transport and locking mechanism too. The personalization file system does not store the content temporarily the content is kept until it is removed explicitly. Users can personalize their UI or the UI of special user groups by creating their views or their texts in the appropriate file system. The list file system is a collection of all layers defined in the layer strategy table. This file system creates corresponding default or customer file systems based on the defined layer sequences. All operation calls that are delegated to the corresponding file system depend on the defined sequences and whether the layer is writable or not.

The layer strategy itself is also implemented as a file system internally. Layer strategy contains a list file system and two user dependent file systems on top for development and personalization. Layer strategy just delegates all operations to the personalization development or list file system. Layer strategy file system can have two modes. One mode has personalization on top then development file system and then list file system. Another mode has only development file system on top and then list file system. The mode with personalization is for the normal customer runtime environment where the main change operations are for personalization. The mode without personalization is for the development design time environment where a work list and corresponding states transition such as edit create save and activation are required.

All file system is a special file system which only implements the read only access. This file system represents the internal view of repository without taking layer strategy settings into account. Solutions branches and projects are displayed in the all file system.

The repository content may be stored by the repository core repository engine and core toolbox and by the service provider . While the repository core stores administrative data the service provider stores the actual content. User personalization data is stored into separate files to better support switch upgrades. In various embodiments the repository content is arranged in branches as each branch may contain the complete set of a solution such as a product a full branch or only subsequently changed content delta branches . Delta branches refer to a preceding branch. A layer in the repository is a view of one branch including all preceding branches of one solution. A layer strategy defines an ordered list of layers. Repository uses the layer strategy as a search path from top to bottom when servicing content retrieval requests. The top most entry of a layer strategy can be marked as writable. Repository chooses the corresponding solution when serving change requests. Depending on the logon client different layer strategies can be used. In an embodiment user specific layer strategies may exist.

In various embodiments the layers and their order must be configured manually in a layer strategy or by some management layer e.g. that handles to switch on and off partner solutions to be used by the customer. User layers are added by the repository by default without the need for manual configuration. The top most layer the user specific layer of a strategy is marked as writable while all layers below are read only. In an embodiment there can be only one layer in a strategy that is writable. shows the layering concept for access to the repository based on solutions by parties. The horizontal axis represents the branches of a product e.g. releases of a product service patches etc. while the vertical axis represents the solutions . The solution at the bottom layer represents the solution provided by the vendor e.g. SAP Business ByDesign by SAP . Solution represents the solution provided by the partner at layer . Solution represents the solution provided by the customer at layer . Solution represents the solution provided by the user at layer . Layer is marked as writable which means that the users have rights to change the content of solution in the repository.

 Copy on write COW operation on the content takes place whenever a change request comes in the repository e.g. an XML file that is assigned to a read only layer. The COW operation exists as one optional mode in this case the content overshadows the content from the lower layer. There is also the mode when a change is stored in the upper layer and also as delta information to the lower content implicit merge logic provided by the framework . There is also a third mode where the delta information so called change transaction is stored separately and linked to the original content and merged semantically by the repository framework explicit merge logic .

The content is copied to the writable layer e.g. layer while keeping a reference to the original content. Accordingly whiteout on delete WOD operation marks content as deleted in the writable layer. Repository offers explicit API methods for personalization changes because it treats personalization changes different from development changes especially with regard to software logistics and automatic diff merge functionality redoes changes performed to a file when a new version of that file comes in this is done automatically without human interaction . Repository adds user specific layers automatically to the configured layer strategy. One layer is added for design time requests. When a developer activates the changes the content of this layer is moved back to the layer below. For runtime requests two layers are added one for user specific development and another one for personalization.

In various embodiments layers and corresponding layer strategies can be defined. The layer strategy includes a stack of layers and a sequence with a precedence of the different layers. For example layer includes the solution provided by the vendor and one or more layers that include solutions for different partners on top of layer which refer to layer . Also there is one or more layers for the customers e.g. and a plurality of layers for users including a layer for each user e.g. layer . For a specific party user customer partner etc. there is a layer strategy defined which starts with the corresponding user layer for the party and points to the vendor layer. The vendor layer points to any sequence of partner layers if there are any and finally the vendor layer is referenced as the lowest layer. This stack of layers and the layer strategy which can be different for different users and different clients or companies can aggregate a view to the different content. This means that if a specific object is accessed by one user through the aggregation mechanisms of the repository it may result in a different view of the entities than for another user or for another company or partner etc.

Semantic changes can be defined to an existing entity and that entity may be stored to any layer in the repository. For example there may be an object instance in the solution provided by the vendor e.g. solution and a partner may want to bring additional fields to this object instance. The changes that the partner will perform are not stored within the vendor solution but are stored in a semantic description of this change in a small entity called change transaction which describes the actual change e.g. the additional fields to the object instance in an abstract way. The change transaction is stored in the partner layer. Then the repository has the feature that once this object instance is accessed it knows that there are change transactions in the partner layer and if the partner layer is present in the current layer strategy of the request then the change transaction will be merged into the object instance and a resulting view as result of the merge will be passed back as a response to the request. For atomization reasons once the merge has happened the result is stored in the partner layer of the repository and will be reapplied only if something is changed in the change transaction or in the underlying object that is changed by the change transaction .

The layers stack and the layering strategy guarantee lifecycle stability. For example there are different layers and a set of entities stored in the repository by a given solution. When an update of the solution is provided the customer changes or the personalization settings to the layers are not lost but just they have been reapplied and remerged together with the newly content.

In some embodiments the different releases of a solution are stored separately so that a switch between the releases is possible in case some data from an old release is needed. If the content in the repository is shipped to customers and there is a new release the new release is stored in parallel to the old release and the content of the old release is present to the customer so that the customer is able to run the former release using the UIs of the new release.

At block a request is received that requires a data object to be read from the repository during runtime. At block the request is forwarded to the layer strategy file system. The layer strategy is implemented as an internal file system the layer strategy file system. The layer strategy includes definitions of a set of layers and a definition of a sequence access to the layers with a precedence of the different layers. The sequence access represents a number that defines which layer has precedence to be accessed when searching the layers or when delegating an operation. The layer strategy file system contains a list file system and on top of it two user dependent file systems development file system and personalization file system.

At block the request is forwarded to personalization file system to search and retrieve information for the data object. At decision block it is checked if the data object is found in the personalization file system. If the result is yes then the method continues at block otherwise at block . At block the request is forwarded to development file system to search and retrieve information for the data object. At decision block it is checked if the data object is found in the development file system. If the result is yes then the method continues at block otherwise at block . At block the request is forwarded to list file system to search and retrieve information for the data object. The list file system is a collection of all layers defined in the layer strategy. At block the defined layers are searched in sequence according to the sequence access defined in the layer strategy. At block the data object is located in a layer of the repository. At block data object attribute value is returned in response to the initial request.

Some embodiments of the invention may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. A computer readable storage medium may be a non transitory computer readable storage medium. Examples of a non transitory computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment of the invention may be implemented using Java C or other object oriented programming language and development tools. Another embodiment of the invention may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather the scope of the invention is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

