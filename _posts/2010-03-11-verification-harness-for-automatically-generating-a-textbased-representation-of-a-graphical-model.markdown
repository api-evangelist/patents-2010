---

title: Verification harness for automatically generating a text-based representation of a graphical model
abstract: A system and method automatically generates an object-oriented, textual program from a graphical model, and verifies the performance of the textual program as compared to the graphical model. The graphical model may have a plurality of interconnected blocks, and each block may have a plurality of parameters. One or more of the blocks are mapped to a system object, and the block's parameters are mapped to properties of the system object. An object-oriented, executable textual string is generated automatically for the block. The generated string includes at least one command to: instantiate a system object having functionality that matches the block; set one or more properties of the system object based on the block's parameters; and run the instantiated object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08983823&OS=08983823&RS=08983823
owner: The MathWorks, Inc.
number: 08983823
owner_city: Natick
owner_country: US
publication_date: 20100311
---
The present application is a continuation in part of commonly assigned copending U.S. patent application Ser. No. 11 321 919 which was filed on Dec. 29 2005 by David Koh and Brian K. Ogilvie for an Automatic Comparison and Performance Analysis Between Different Implementations and is hereby incorporated by reference in its entirety.

The present invention generally relates to technical computing and more particularly to generating automatically an object oriented textual representation of a graphical model and performing verification testing of the textual representation and the graphical model.

Block diagrams are used to model real world systems. Historically engineers and scientists have utilized time based block diagram models in numerous scientific areas such as Feedback Control Theory and Signal Processing to study design debug and refine dynamic systems. Dynamic systems which are characterized by the fact that their behaviors change over time are representative of many real world systems. A dynamic system either natural or man made is a system whose response at any given time is a function of its input stimuli its current state and the current time. Such systems range from simple to highly complex systems. Physical dynamic systems include for example a falling body the rotating earth biomechanical systems muscles joints etc. biochemical systems gene expression protein pathways and weather and climate pattern systems. Examples of man made or engineered dynamic systems include a bouncing ball a spring with a mass tied on an end automobiles airplanes control systems in major appliances communication networks audio signal processing nuclear reactors and a stock market.

A block diagram model of a dynamic system is represented schematically as a collection of blocks interconnected by lines that represent signals. Each block represents an elemental dynamic system. A signal represents either the input or the output of a dynamic system. A line emanating at one block and terminating at another signifies that the output of the first block is an input to the second block. Each distinct input or output on a block is referred to as a port . Signals correspond to the time varying quantities represented by each line connection and are assumed to have values at each time instant at which the connecting blocks are enabled. The source block of a signal writes to the signal at a given time instant when its system equations are solved. The destination blocks of this signal read from the signal when their system equations are being solved.

It should be noted that the term block diagram as used herein also refers to other graphical modeling formalisms. For instance flow charts are block diagrams of entities that are connected by relations. Flow charts are used to capture process flow and are not generally suitable for describing dynamic system behavior. Data flow block diagrams are diagrams of entities with relations between them that describe a graphical programming paradigm where the availability of data is used to initiate the execution of blocks where a block represents an operation and a line represents execution dependency describing the direction of data flowing between blocks. It will be appreciated that a block diagram model may include entities that are based on other modeling domains within the block diagram. A common characteristic among these various forms of block diagrams is that they define semantics on how to execute them.

In graphical modeling environments such as model based design tools block diagram models can be created to represent a design or algorithm of an implementation for a computational hardware. One or more block diagram models may represent a design for a target hardware platform. A target hardware platform used in this application may include a single computing platform or multiple computing platforms. A target hardware platform may also have other elements such as memory interfaces or other integrated circuits ICs . An automatic code generation application can automatically generate code and build programs from the block diagram model for implementation on the target hardware platform based on the design specified by the model. In this manner the design of a block diagram model behaves as an implementation specification for automatic code generation. A graphical block diagram modeling environment can be used to produce designs and algorithms that can be implemented on a processor or computational IC such as an FPGA or ASIC.

In conventional systems users typically have no convenient way to verify that automatically generated code from a block diagram model will execute in an intended manner on a target platform e.g. in a manner consistent with a design implemented in the block diagram model.

Briefly the present invention in an embodiment is directed to a system and method for automatically generating an object oriented textual program from a graphical model and for verifying the performance of the textual program as compared to the graphical model. The graphical model may have a plurality of executable graphical blocks that are interconnected to define a function or procedure. Each block may have a plurality of parameters. A user may identify one or more target block types of the graphical model that is to be verified. The system interrogates the model and identifies each occurrence of the identified target block types and obtains each block s parameters. The system maps each occurrence of the identified block types to a system object and maps the block s parameters to properties of the system object. The system may include one or more predefined look up tables LUTs for mapping executable graphical blocks and their parameters to system objects and their properties. The system generates for each occurrence of the target graphical block in the graphical model an object oriented executable textual string. Each generated string includes at least one command to instantiate a system object having functionality that matches the target graphical block set one or more properties of the instantiated object based on the parameters of the respective block and run the instantiated object. The generated strings may be loaded into embedded text blocks which may be assembled into a verification model. The graphical model and the verification model may be simulated and the results produced by the two models compared in order to verify the objection of the system objects.

In another embodiment the object oriented executable textual strings may be stored in a textual verification file. The file may be executed and the results produced during the execution of the file may be compared with the results produced by the graphical model.

For the purpose of discussion in this application the following terms are given the following meaning in this application.

A processor includes but not limited to general purpose processor GPP microcontroller graphics processor multi core processor and Digital Signal Processor DSP .

A computational IC includes but not limited to FPGA ASIC programmable logic device PLD and programmable logic array PLA .

A host computer is a computing device with a processor wherein the simulation environment such as the Simulink model based design system resides.

A computing platform is a processor computational IC an emulator of a processor an emulator of a computational IC a simulator of a processor a simulator of a computational IC or a combination thereof. An emulator or a simulator of a processor or a computation IC is a software emulation or software simulation that resides on a host computer.

The simulator allows execution of standalone code implementation such as C code or HDL intended for the processor or computation IC. Examples of a simulator includes but not limited to Trace32 from Lauderbach C6000 DSP Simulator from Texas Instruments and ModelSim HDL Simulator from Mentor Graphics.

A design is an algorithm for a hardware or software architecture components modules interfaces to satisfy specified requirements.

A simulation is for execution on a computing device with a simulation environment such as the MATLAB programming environment or the Simulink model based design system both from The MathWorks Inc. of Natick Mass.

A model executes within a simulation environment such as the MATLAB programming environment and the Simulink model based design system on a host computer. A model can include but not limited to application design that can be executed in simulation application design from which code can be automatically generated communications interface with ail external computing platform.

A block diagram model is a graphical representation of a model using block diagrams. A single block diagram may represent a design for one or more computing platforms. On the other hand one or more block diagram models may represent a design for a single computing platform.

A standalone code implementation is a standalone software that can be executed on a host computer or a computing platform.

An implementation is the realization of the intended design in simulation or a standalone code implementation. Examples of an implementation include but not limited to a simulation of a design on a host computer and execution of a standalone code implementation on a computing platform. One or more models can also be used to represent one implementation.

A subsystem is a hierarchical model abstraction that can include multiple blocks and other subsystems.

A parameter is a variable defined by an algorithm. For example given a function y K u where y is the output and u is the input K is a parameter of the function that can be varied by a user manually or programmatically to determine what the function will be.

An intermediate output is an intermediate result of a simulation or execution of a standalone code implementation. For example in a graphical block diagram modeling application an intermediate output can be an output or output signal of a block within a block diagram model. In another example in the execution of a standalone code implementation an intermediate output can be an output of a function or execution results of a sequence of instructions.

The present invention provides a method and system for comparing different implementations of one or more designs. An illustrative embodiment of the present invention provides a method and system for automatic verification of automatically generated standalone code implementation intended for execution on a target computing platform against its original simulation design from which the standalone code is generated. A user can use this verification to double check if the automatically generated code performs as predicted in the original simulation design. The illustrative embodiment relieves the user s burden to write manual code to communicate with the target computing platform and administer manual tests.

The present invention provides a method and system for comparing simultaneous executions of different implementations. A block a collection of blocks a subsystem a model or a collection of integrated models can be used to represent an implementation. Comparison of different implementations can be done at different levels. Comparison of only the final execution results of the different implementations is not always helpful as different components of the implementations can affect the final execution results. Hence one advantage of the present invention is that a user can choose to compare intermediate outputs and choose how errors between the different implementations should be propagated such as if an error at an earlier stage should be allowed to propagate to a later stage in the execution.

The present invention also provides a method and system for comparing simultaneous executions of standalone code implementations on the same or different computing platforms. A host computer can communicate with the one or more computing platforms that execute the standalone code implementations and instruct the computing platforms to execute the standalone code implementations simultaneously in a locked step manner. A user can compare how one standalone code implementation performs on two different computing platforms or how two different standalone code implementations perform on the same platform.

For example when the computing platforms are external to the host computer the present invention allows an application program on the host computer to communicate with the external computing platforms and instruct the simultaneous execution of the standalone code implementations and further retrieve and compare the executions results on the host computer. A user does not need to analyze data after execution of the standalone code implementations. The present invention may allow real time analysis and comparison of two executions of standalone code implementations. One of ordinary skill in the art will appreciate there are many combinations and modifications one can make with the exemplary embodiments described herein but still does not depart from the spirit and scope of the present invention.

In a preferred embodiment of the present invention a block diagram can be used to represent a comparison model that compares two implementations such as two simulations two standalone code implementations or one simulation and one standalone code implementation. The comparison can be done at a block level a subsystem level a model level or multi model level. The present invention may allow automatic comparison once a user identifies the intermediate outputs and or signals that the user wants to compare and monitor. Reports can be generated to show the statistics of the comparison results.

Illustrative embodiments will be described below for illustrative purposes relative to the technical computing environment of the MATLAB programming environment and the Simulink model based design system from The MathWorks Inc. of Natick Mass. Although the illustrative embodiments are described relative to a Math Works based application one of ordinary skill in the art will appreciate that the present invention may be applied to other graphical modeling environments and technical computing environments such as any technical computing environments using software products of Rhapsody from I Logix Inc. TargetLink and Real Time Interface from dSPACE GmbH RT LAB from Opal RT Technologies Inc. EXITE from EXTESSY AG LabVIEW and MATRIXx from National Instruments Inc. SystemVue from Eagleware Elanix Corporation Mathematica from Wolfram Research Inc. Mathcad of Mathsoft Engineering Education Inc. COSSAP from Synopsys Inc. HyperSignal from Hyperception Inc. Dymola from Dynasim AB or Maple from Maplesoft a division of Waterloo Maple Inc. Furthermore one ordinarily skilled in the art will appreciate that the present invention may apply to any graphical modeling environment such as one providing modeling with a Unified Modeling Language UML Hardware Description Language HDL or that provides a physics modeling domain. Additionally those skilled in the art will also appreciate that the principles and concepts are equally applicable to non graphical modeling applications as well.

The memory may comprise a computer system memory or random access memory such as DRAM SRAM EDO RAM etc. The memory may comprise other types of memory as well or combinations thereof. A user may interact with the host computer through a visual display device such as a computer monitor which may include a user interface . The host computer may include other I O devices such a keyboard and a pointing device for example a mouse for receiving input from a user. Optionally the keyboard and the pointing device may be connected to the visual display device . The host computer may include other suitable conventional I O peripherals. The host computer may further comprise a storage device such as a hard drive or CD ROM for storing an operating system and other related software and for storing application such as the Simulink model based design system. Application may include a concurrent execution environment to enable concurrent execution and or monitoring of simulations and or standalone code implementations on the host computer . Concurrent execution environment includes comparison mechanism and communication control discussed later . Those skilled in the art will appreciate that communication control is adaptable to be included as part of the application or a stand alone application that responds to calls from the application such as communication control . Additionally the application can be run from a bootable CD such as for example KNOPPIX a bootable CD for GNU Linux.

Additionally the host computer may include a network interface to interface to a Local Area Network LAN Wide Area Network WAN or the Internet through a variety of connections including but not limited to standard telephone lines LAN or WAN links e.g. 802.11 T1 T3 56 kb X.25 broadband connections e.g. ISDN Frame Relay ATM wireless connections or some combination of any or all of the above. The network interface may comprise a built in network adapter network interface card PCMCIA network card card bus network adapter wireless network adapter USB network adapter modem or any other device suitable for interfacing the host computer to any type of network capable of communication and performing the operations described herein. Moreover the host computer may be any computer system such as a workstation desktop computer server laptop handheld computer or other form of computing or telecommunications device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein.

The host computer can be running any operating system such as any of the versions of the Microsoft Windows operating systems the different releases of the Unix and Linux operating systems any version of the MacOS for Macintosh computers any embedded operating system any real time operating system any open source operating system any proprietary operating system any operating systems for mobile computing devices or any other operating system capable of running on the computing device and performing the operations described herein.

In another embodiment of the present invention comparison mechanism can compare simulation with simulation that is executed by application . Application can execute on the same or different processor that executes application . Application can also be controlled by the same or different operating system as the one that controls application . Communication control is capable of communicating between application and application . Communication control is also capable of controlling execution of simulation . In other words communication control can determine when to execute pause or terminate the simulation . Communication control can also determine what inputs simulation should use for execution. Communication control can further determine if a portion or all of simulation should be executed. Communication control can issue instructions to cause simultaneous execution of simulation and simulation in a locked step manner. Comparison mechanism can automatically generate a comparison model to compare the simulation with simulation . The comparison model may be implemented as a block diagram model where one or more blocks are used to represent semantics of the simulation and .

In a further embodiment of the present invention comparison mechanism can compare execute results of simulation executing by application and simulation executing by application . Application and application can execute on the same or different processor and be controlled by the same or different operating system. Communication control communicates with application and application regarding data related to simulation and simulation respectively. Communication control can issue instructions to cause simultaneous execution of simulation and simulation in a locked step manner.

Semantics of simulation and simulation can be represented by model and model respectively. In a preferred embodiment of the present invention model and model are built using a block diagram modeling application such as the Simulink model based design system. Application uses model and model in the concurrent execution environment to represent simulation and simulation respectively. Comparison mechanism can request communication control to obtain data from simulation and or simulation for comparison purposes. Communication control can make a function call to a specific portion of simulation or simulation . Comparison mechanism can automatically generate a comparison model to compare the simulation and simulation . The comparison model may be implemented as a block diagram model where one or more blocks are used to represent semantics of the simulation and 132 .

In another aspect of the present invention comparison mechanism can compare simulation or simulation with simulation that executes on application which resides on host computer . Communication control communicate between application on host computer and application on computing device regarding data related to simulation . Application can use a model in concurrent execution environment to represent semantics of simulation . The model can be stored locally in storage or externally at computing such as model . Comparison mechanism can make a function call to a specific portion of simulation . Communication control is also capable of controlling execution of simulation . In other words communication control can determine when to execute pause or terminate the simulation . Communication control can also determine what inputs simulation should use for execution. Communication control can further determine if a portion or all of simulation should be executed. Communication control can issue instructions to cause simulation and simulation or simulation to execute simultaneously in a locked step manner. Comparison mechanism can automatically generate a comparison model to compare the simulation and simulation or simulation . The comparison model may be implemented as a block diagram model where one or more blocks are used to represent semantics of the simulation and simulation or simulation .

In a further embodiment of the present invention comparison mechanism can compare execution of simulation with execution of simulation . Simulation can be executed by an application on a host computer that is different from host computer . Host computer can also include a model that application uses to represent the semantics of simulation . Communication control can issue instructions to cause simultaneous execution of simulation and simulation in a locked step manner. Comparison mechanism can automatically generate a comparison model to compare the simulation and simulation . The comparison model may be implemented as a block diagram model where one or more blocks are used to represent semantics of the simulation and .

One of ordinary skill in the art will appreciate that any type of simulation may be used in the present invention. Additionally applications and may be different applications different instances of the same application or a combination thereof.

In one aspect of the present invention model represents a design being simulated by simulation and standalone code implementation is automatically generated from the same design using specification information of computing platform such as memory information interface information processing speed information of the computing platform . In this case model is used to represent the physical execution of standalone code implementation on the computing platform whereas model represents a simulation of the design in a simulation environment such as one provided by the Simulink model based design system. In one embodiment of the present invention application can automatically generate model . Application or comparison mechanism can automatically generate a comparison model to help illustrate the verification of the automatically generated standalone code implementation against the design as simulated by simulation . Hence the present invention provides an automatic method to verify the generated standalone code implementation with the original design. The present invention also allows a user to specify how one wants to verify the automatically generated code with its original design details later . One of ordinary skill in the art can appreciate that a user would generally like to know if the automatically generated standalone code implementation from the design behaves as predicted in the simulation simulating the design. Additionally one of ordinary skill in the art will also appreciate that there is some discrepancy between the automatically generated code and the simulation due to many factors such as design choices and quality of the automatically generated standalone code implementation that a user would generally like to be able to compare the execution of the automatically generated standalone code implementation with the simulation to see how different the execution results are.

In a preferred embodiment of the present invention model is built using gateway blocks described in U.S. patent application Ser. No. 11 028 172 the content of which is incorporated herein by reference. In another embodiment of the present invention the functionalities of the gateway block can be achieved by using the processor in the loop PIL technology featured in Embedded Target for Motorola MPC555 from The MathWorks Inc. of Natick Mass. or TargetLink from dSPACE of Germany. One of ordinary skill in the art will appreciate that there are many different ways and technologies that can be used to achieve the purpose of a gateway block.

A gateway block can provide input to the standalone code implementation on the computing platform and wait for the computing platform to execute a portion of the standalone code implementation that is represented by the gateway block. Once the gateway block receives the output from the execution of the portion of the standalone code implementation that is represented by the gateway block the gateway block can provide the received output as an input to another block in the block diagram model. The gateway block can carry out the above processing by using many different technologies such as via APIs to the computing platform s debugger or IDE of the computing platform and via direct interface device drivers to the computing platform Universal Serial Bus USB Joint Test Action Group JTAG TCP IP RS 232 . Additionally a gateway block does not need to be a visible block in a block diagram model because the purpose of the use of the gateway block is to communicate with a computing platform external to the host computer.

When the standalone code implementation is implemented in HDL model can be automatically created using one or more gateway blocks or co simulation blocks such as ones from The MathWorks product EDA Simulator Link to communicate with a computing platform executing standalone HDL code implementation.

In another embodiment of the present invention comparison mechanism can compare simulation executing by application with standalone code implementation embedded on a computing platform . Communication control can communicate with application regarding data related to simulation and also communicate with computing platform regarding data related to standalone code implementation . Communication control can issue instructions to cause simultaneous execution of simulation and standalone code implementation in a locked step manner so that comparison mechanism can make comparison during execution of simulation and standalone code implementation . Comparison mechanism can automatically generate a comparison model to compare the simulation and standalone code implementation . The comparison model may be implemented as a block diagram model where one or more blocks are used to represent semantics of the simulation and standalone code implementation .

In still another embodiment of the present invention comparison mechanism can compare simulation executing on host computer with standalone code implementation embedded on a target platform. Communication control can communicate with application regarding simulation and communicate with computing platform regarding standalone code implementation . Communication control can issue instructions to cause simultaneous execution of simulation and standalone code implementation in a locked step manner so that comparison mechanism can make comparison during execution of simulation and standalone code implementation . Comparison mechanism can automatically generate a comparison model to compare the simulation and standalone code implementation . The comparison model may be implemented as a block diagram model where one or more blocks are used to represent semantics of the simulation and standalone code implementation .

One of ordinary skill in the art will appreciate that although the illustrated example only show the standalone code implementation being executing on a computing platform external to the host computer the present invention can be equally applied to standalone code implementations executed on a computing platform internal to the host computer .

In another embodiment of the present invention comparison mechanism can compare standalone code implementation executed on computing platform with standalone code implementation executed on host computer . Communication control can issue instructions to cause simultaneous execution of standalone code implementation and standalone code implementation in a locked step manner so that comparison mechanism can make comparison during execution of the standalone code implementation and standalone code implementation . Models can be used to represent the execution of the standalone code implementation under a certain environment. Comparison mechanism can automatically generate a comparison model to compare the standalone code implementation and standalone code implementation . The comparison model may be implemented as a block diagram model where one or more blocks are used to represent semantics of the standalone code implementations and .

In a further embodiment of the present invention comparison mechanism can compare execution results of standalone code implementation and standalone code implementation . Standalone code implementation and standalone code implementation mayor may not be executed by the same processor or controlled by the same operating system. Communication control can also issue instructions to cause simultaneous execution of the standalone code implementations and in a locked step manner so that comparison mechanism can make comparison during execution of the standalone code implementations and . Comparison mechanism can automatically generate a comparison model to compare the standalone code implementation and standalone code implementation . The comparison model may be implemented as a block diagram model where one or more blocks are used to represent semantics of the standalone code implementations and 146 .

Once a user provides comparison instructions comparison mechanism can compare execution of two different standalone code implementations on the same type of computing platforms. In another embodiment of the present invention comparison mechanism can obtain comparison instructions from a specific location in the storage. Comparison mechanism can also compare execution of the same standalone code implementations on different types of computing platforms. The present invention also allows comparison mechanism to compare execution of different standalone code implementations on different types of computing platforms. Furthermore the present invention can also compare execution of one standalone code implementation on an external computing platform with another standalone code implementation on an internal computing platform on the host computer. Additionally the present invention also enables comparison of execution of two standalone code implementations on the same computing device.

Implementation includes block that receives input signals from block via input port and outputs signals to output port . Block can represent execution of a portion of standalone code implementation on the computing platform . Furthermore block can represent execution of a function of the standalone code implementation on the computing platform . Communication control can make a function call via block to computing platform . For example block can be a gateway block that is described in the U.S. patent application Ser. No. 11 028 172 which is incorporated herein by reference in its entirety. Alternatively real time data transfer such as Texas Instruments Real Time Data Exchange RTDX processor in the loop PIL or hardware in the loop HIL technology may be used by communication control to communicate with computing platform to implement a gateway block. In another embodiment of the present invention the gateway block can be built using the PIL technology featured in Embedded Target for Motorola MPC555 from Math Works of Natick Mass. or TargetLink from dSPACE of Germany. One of ordinary skill in the art will appreciate that there are many technologies that can be used to construct a gateway block that is suitable to use in the present invention. In another embodiment of the present invention block can be a co simulation block such as one from The MathWorks product EDA Simulator Link to communicate between the host computer and the computing platform that executes the standalone code implementation.

In one embodiment of the present invention block can be viewed as the equivalent of block that is in the standalone code implementation . A user can choose to compare output signals from block with output signals from block . Hence block is the part of the standalone code implementation that the user wishes to compare with block . A user can use a difference block to compare the output signals from blocks and . Difference block takes the output signals of block and subtracted from the output signals of block . The output of the difference block can then be supplied to sink block .

Implementation also includes block that receives signals via input port . Switch can be provided to choose between output signals from block and the ones from block . Hence a user can choose if block will have the same inputs as block and to prevent error propagation from one block to another. On the other hand a user might want to know the cumulative error in the implementation relative to implementation so that in this case the user would want to use output signals from block to feed into block . Block has an output port where a signal exits block . Again a use can choose to compare output signals from block and block via a difference block . Difference block takes the output signals from block and subtracted from the ones from block . The results from the difference block are then inputted to sink block . Switch allows a user to choose an input signal to block via input port . If switch is used to choose output signals from block then block will have the same input signals as block . Alternatively if switch is used to choose output signals from block then errors in the output signals of block are included as part of the input signals into block . Block output signals via output port and the signals are inputted to sink block via its input port . Output signals from 208 and block are compared using difference block and the output from the difference block is then inputted into block . Outputs from blocks and 208 are considered as intermediate outputs of the implementation as they are not inputs or the final outputs of the implementation . Hence the present invention provides a method and a system to compare intermediate outputs of different implementations.

One of ordinary skill in the art will appreciate that there are many ways to compare two signals and difference blocks and are merely examples. Additionally a user can choose if he wants to compare signals at every block such as shown in or only at specific blocks. Furthermore a user can also choose to compare outputs from two models where each model can include more than one smaller model. If implementation is used to generate code to embed in computing platform and implementation is used to represent the execution of the generated code on the target platform then the comparison verification model can be automatically generated and the user just needs to specify which signals that the user wishes to compare. One of ordinary skill in the art will further appreciate that the comparison verification model shown in can also be used in systems such as shown in and . When implementation is automatically generated from a design that implementation simulates then the comparison verification model can be automatically generated. Otherwise a user may need to define what each block is corresponding to so that the user can choose later what signals from what blocks the user wishes to compare.

Block block block and block can be implemented as gateway blocks that is described in the U.S. patent application Ser. No. 11 028 172. A gateway block may transmit and receive data for exchange between the application and the computing platform . A gateway block can contain discrete components capable of accomplishing a variety of tasks. For example the gateway block can include a component for use in passing the input data and parameters of a function to be executed to the external processor a component for use in executing the function and a component which retrieves the intermediate outputs from the target platform. Using a plurality of discrete components designed for accomplishing individual tasks the interaction between the application and the computing platform can be separated.

In one embodiment of the present invention a communication channel can be set up by the gateway block or the application to communicate with computing platform . An application program interface API containing a set of routines and protocols necessary for initialing control and data transfer communications to the target platform can be used. By invoking the API s individual functions of the processor in the external environment can be called with input data and parameters provided from the model environment for use in the processor environment. Additionally with the API several functions residing on the computing platform can be called. Furthermore for each target platform or external processor using the API the application can manage all context switching associated with calling the function such as saving and restoring context setting the program counter setting a breakpoint at the end of the called function and executing standalone code implementation on the target platform or external processor. After the function has executed the API can be used in retrieving the output data via the communication channel for use in the block diagram model.

One of ordinary skill in the art will appreciate that although blocks and have been described to communicate with the same target platform blocks in one model can communicate with different target platforms or external processors. The combination of the different target platforms and or external processors can be viewed as one big system that communicates with one model. One of ordinary skill in the art will also appreciate that are merely exemplary block diagram models that can be used to practice with the present invention and other graphical models or textual models can also be used to practice with the present invention.

Lastly a comparison report can be generated in step . The report can include statistics that include but not limited to error rates error distribution and sensitivity. Error rates can be any commonly used error rate or ally user defined error rate such as mean time before error mean time between errors errors per unit time and errors per run. Error distribution can include a commonly used distribution or any user defined distribution such as a probability distribution function and a probability density function. Sensitivity can include but not limited to independent subsystem level sensitivity to subsystem input accumulated subsystem level sensitivity to application input independent subsystem level sensitivity to subsystem parameters and accumulated subsystem level sensitivity to parameters. Commonly used statistic tools may be included as part of the application . Application can also provide mechanisms so that a user can use a custom defined function implemented in a technical computing application such as the MATLAB programming environment to calculate a user defined error rate user defined error distribution or user defined sensitivity. The report may also include statistics that include percentage of occurrences in which differences in value of two intermediate outputs are greater than a user defined tolerance. The report may additionally include figures such as plots of differences as a function of time bar graphs showing sensitivity metrics of different intermediate outputs pi charts showing percentage of error contribution factors.

The present invention provides a method for comparing and or verifying by a user using user defined information and or rules. Reports can also be automatically generated using user defined information and or rules. The present invention relieves the user the burden to write manual code to compare two implementations. The present invention also relieves the user the burden to write manual code to communicate with an external computing platform to send instructions and retrieve execution data. The present invention allows easy verification between original design and the automatically generated standalone code implementation from the original design. The present invention also allows easy comparisons among a number of different simulations and or standalone code implementations such as multiple implementation techniques for a given computing platform multiple automatically generated standalone code implementations from one design for multiple different computing platforms simulations of a design with different optimization techniques simulations of a design using different combinations of computing platforms.

The verification harness may include a plurality of components or modules. Specifically the verification harness may include a target block identifier a textual string generator a plurality of look up tables LUTs an embedded text block generator a verification model builder a text file builder an optimizer and a result comparator . The textual string generator may include a mapper .

A suitable text based computing environment is the MATLAB programming environment which is a dynamically typed matrix based programming system. A suitable graphical modeling environment is the Simulink model based design system.

It should be understood that the arrangement of is for illustration purposes only and that this embodiment of the present invention may implemented in other ways. For example the verification harness and or the code generation engine may be included within text based computing environment itself the mapper may be included in the LUTs etc.

As described herein the verification harness receives a selected graphical model as illustrated by arrow and one or more specified target blocks as indicated by arrow . The verification harness is configured to automatically generate a verification model and or one or more executable text files . The verification harness is further configured to perform simulation verification between the selected graphical model and the verification model and or the text files . Specifically the verification harness may run or execute the selected graphical model and the verification model and or the one or more executable text files and compare the results produced thereby.

The target block identifier textual string generator LUTs embedded text block generator verification model builder text file builder optimizer and result comparator as well as the system object class definition may be or may include software modules or libraries containing program instructions pertaining to the methods described herein that may be stored on computer readable media such as memory and executable by one or more processing elements such as processor A and or B. Other computer readable media may also be used to store and execute these program instructions. In alternative embodiments various combinations of software and hardware including firmware may be utilized to implement the present invention.

The model includes a plurality of executable graphical blocks that are interconnected by lines or edges. Depending on the type of graphical model the lines may represent data flow pathways for signals etc. The model includes a plurality of Mean blocks . Each Mean block moreover is coupled to a respective source block and a respective sink block .

It should be understood that the graphical model of is meant for illustrative purposes only and that the present invention may be used with other possibly far more complex graphical models.

Each block of graphical model such as the Mean blocks may have one or more parameters or properties. Block parameters are attributes that may be specified by the user for the respective block and are used during execution of the block. The user specifies an attribute of a block by setting the parameter to a corresponding value. For example a Gain block may include a Gain parameter a Mean block may include Running Mean and Dimension parameters etc. The parameters of a block may be initialized to default values by the graphical modeling environment . A user may set the block s parameters by calling up a parameter or property page for display on the visual display device .

Referring now to and in particular to block the user preferably inputs the selected model e.g. model to the verification harness . In an embodiment the menu bar may include a Verify Model command. Alternatively or additionally the toolbar may include a Verify Model icon.

In addition to inputting the selected model to the verification harness the user also may select one or more graphical executable blocks of the model as target blocks i.e. the blocks of the model that are to be verified as indicated at block . For example upon selection of the Verify Model command a pop window or dialog box may be presented to the user. The dialog box may include fields and command buttons for configuring the verification process. By manipulating one or more fields or buttons of the dialog box the user may select one or more of the graphical executable blocks of the selected graphical program for automatic verification. In an embodiment the dialog box lists each of type of graphical executable block that is present in the selected graphical model. The user may specify one or more types of blocks of the model as the target blocks to be verified.

It should be understood that instead of selecting one or more target block types the user may specify one or more particular blocks of the selected graphical model one or more subsystem blocks or the entire graphical model. The target block identifier may examine e.g. parse the received graphical model and identify each individual occurrence of the specified target block type in the selected graphical model as indicated at block . The target block identifier may pass information regarding each occurrence of the target block type in the graphical model to the textual string generator . In particular the target block identifier may determine the parameter values of each occurrence of the target block type based on its analysis of the selected graphical model as indicated at block . A block s parameters may be obtained by accessing the block mask of the block. The target block identifier also may determine the signals received by each occurrence of the target block type i.e. the input data to the block and the source of those signals such as other blocks of the model. The target block identifier may also determine the signals produced by the block i.e. the block s output data and the other blocks of the model that receive those signals.

It should be understood that the target block identifier and the textual string generator may process an in memory representation of the graphical model generated by the graphical modeling environment .

In accordance with an embodiment of the present invention the functionality of each target block type may be implemented through a corresponding system object instantiated by the system object constructor . That is for each target block type of the selected model there is a corresponding system object class provided by the class packages . For example for a Mean block there is a system object class that performs a similar mean function for a Gain block there is a system object class that performs a similar gain function for a counter block there is a system object class that performs a similar counter function. As indicated above each executable graphical block has a plurality of block parameters that are used by the block to implement the functionality of the block. Similarly each system object has a plurality of object properties that are used by the system object to implement its functionality.

A suitable system object architecture for use with the present invention is described in commonly owned co pending U.S. patent application Ser. No. 11 519 255 filed Sep. 11 2006 for a System and Method for Using Stream Objects to Perform Stream Processing in a Text Based Computing Environment which has been published as U.S. Patent Publication No. 2008 0127064 A1 and which is hereby incorporated by reference in its entirety. Notably the application uses the term stream object rather than system object as used herein.

The textual string generator preferably accesses information in the LUTs in order to automatically generate an object oriented textual string implementing a corresponding system object for each occurrence of a target block type in the selected graphical model. Each LUT represents a predefined mapping between block parameters and system object properties. In most cases however there is not a one to one mapping between block parameters and object properties.

As shown while the Counter system object performs essentially the same function as the Counter block of the graphical model the property types of the system object are not exactly the same as the parameter types of the block. Nonetheless the LUT provides a mapping of each block parameter to one or more properties of the system object as illustrated by arrows . Some block parameters map to a single system object property. For example the Direction parameter maps to the Direction object property the SamplesPerFrame parameter maps to the SamplesPerFrame object property and the MaxCount parameter maps to the MaximumCount object property . Other block parameters however map to multiple object properties. For example the CountEvent parameter maps to both the CountEventInputPort object property and the CountEventCondition object property . Similarly the Output parameter maps to the CountOutputPort property and the HitOutputPort property

In an embodiment the mapping of block types to system object classes as well as the mapping of block parameters to system object properties is predefined and stored at the LUTs of the verification harness . The mapping may be defined manually based on a review of the block types supported by the graphical modeling environment and the object classes defined by the class packages . It should be understood that in some cases there may not be a suitable system object class for a given block type.

It should be understood that graphical blocks may be mapped to system objects based on name as stored at the LUTs . That is a Mean block may map to a Mean system object. A Counter block may map to a Counter system object. It should be further understood that a graphical block may map to a system object of another name. As mentioned above the mapping of graphical blocks to system objects may be predefined and stored at the LUTs . A single graphical block moreover may map to multiple system objects and multiple graphical blocks may map to a single system object. The desired mapping may be implemented through the mapper .

It should be further understood that in addition to mapping block parameter types to object property types the values of a block parameter also may need to be translated converted or otherwise modified as they are mapped to one or more system object properties as indicated at block . In an embodiment the LUTs are implemented through code snippets that when executed e.g. by the mapper of the textual string generator map block parameters to object properties and perform any conversion or processing of the block parameter values that may be required. In an embodiment the code snippets may be written in a format that is executable by the execution engine of the text based computing environment.

For those block parameter values that can be assigned directly to a system object property value an assignment statement may be used such as assignment which assigns the block parameter Direction to the system object property of the same name and assignment which assigns the block parameter InitialCount to the system object parameter of the same name. For other block parameters condition statements such as switch statements may be used to perform the mapping of block parameters to system object properties. A first condition section may be used to evaluate the block parameter CountEvent and assign values to one or more system object properties depending on the value of the block s CountEvent parameter. For example if the CountEvent parameter is set to Rising edge then the system object property CountEventInputPort is set to true as indicated by line and the system object CountEventCondition is set to Rising edge as indicated by line . Alternatively if the block s CountEvent parameter is set to Free running then the system object s CountEventInputPort property is set to false as indicated by line and the object s SamplesPerFrame property is set to the same value as the block s SamplesPerFrame property as indicated by line .

A second condition section of the code snippet evaluates the block s CounterSize parameter and sets the system object s CounterSize and MaximumCount properties. A third condition section evaluates the block s Output parameter and sets the system object s CountOutputDataType CountOutputPort and HitOutputPort properties among others. A fourth condition section evaluates the block s ResetInput parameter and sets the system object s ResetInputPort property.

It should be understood that the other LUTs may be implemented through other such code snippets that may be executed by the mapper .

The textual string generator processes the information received from the target block identifier regarding each occurrence of the target block type in the received graphical model as well as mapping information from the mapper and automatically generates one or more executable object oriented OO textual strings for each such occurrence of the target block type in the graphical model as indicated at block . Specifically the textual string generator may utilize the props structures that are created by running the getMap function for each occurrence of the target block type in order to automatically generate an object oriented textual string for performing the functionality of the respective occurrence of the target block type as indicated at block .

Each textual string may include one or more commands that when executed instantiates an instance of a system object sets the properties of the instantiated system object and calculates one or more outputs based on one or more specified inputs and on the system object s properties. In addition to calculating the one or more outputs the system object may also update one or more internal states. It should be understood that two or more or even all of these commands may be combined into a single command depending on the syntax supported by the system object constructor .

As shown the command for instantiating the system object and setting its properties has the following syntax 

As shown in the object handle of the instantiated system object is h the packagename is signalblks and the ObjectName is Mean .

It should be understood that the system object constructor may support other ways or techniques besides the use of property value pairs to set the system object s properties.

The textual string also includes a line that terminates the if statement as indicated at line . The textual string also includes a command that runs the instantiated object as indicated at line . The run command may have the following syntax 

The step command or method causes the system object to calculate its outputs using the inputs to the system object and the object s properties and internal states. The definition of the function fcn is then terminated as indicated at line .

It should be understood that an instantiated system object s properties may be set with a separate command such as a Set command. It should also be understood that the instantiation of the system object the setting of its properties and the running of the object all may be implemented through a single command or method.

In this way the textual string generator may create an object oriented textual string automatically for each occurrence of the target block type in the selected graphical model. In an embodiment the textual string generator may pass each generated textual string to the embedded text block generator which in turn may create an embedded text block containing the respective textual string as indicated at block . It should be understood that multiple textual strings corresponding to multiple system objects may be embedded in a single embedded text block. The embedded text blocks containing the generated strings may be passed to the verification model builder . The verification model builder may be configured to create a verification model that is similar to the selected graphical model except that in the verification model each occurrence of the target block type is replaced with the corresponding embedded text block that contains the textual string generated for that occurrence of the target block type as indicated at block . The verification model is designed to function like the selected graphical model that was received by the verification harness.

For those blocks of the graphical model that are not target blocks the verification model builder uses the same executable graphical blocks. In addition the verification model builder assembles the verification model in the same way as the selected graphical model. The verification model created by the verification model builder may be output by the verification harness .

The optimizer may perform one or more optimization operations on the verification model such as block reduction and insertion. Specifically the optimizer may be configured to reduce the number of embedded text blocks in the verification model . For example the optimizer may analyze the verification model and determine that at least some of the embedded text blocks may be combined into a single embedded text block. That is the object oriented textual strings that represent several graphical blocks may be combined into a single embedded text block of the verification model . Such an optimization may facilitate efficient code generation from the verification model e.g. by reducing overhead and reducing the number of embedded text blocks to be compiled. The optimizer may be configured to perform other optimization operations including other operations intended to further enhance code generation from the verification model .

In another embodiment the textual string generator may pass each of the automatically generated textual strings to the textual file builder . The textual file builder may assemble the textual strings into one or more executable textual verification files as indicated at block . These verification files may then be output by the verification harness .

It should be understood that the optimizer may be configured to perform one or more optimization operations on the textual verification files e.g. to improve code generation from those files.

To perform simulation verification the verification harness may cause both the selected graphical model and the verification model to be run i.e. executed as indicated at block . In particular the verification harness may cause the simulation engine of the graphical modeling environment to run both the selected graphical model and the verification model . To execute the textual strings contained in the embedded text blocks of the verification model the simulation engine may access or pass the strings to the system object constructor e.g. via the API layer . The system object constructor may invoke the methods or commands of the textual strings thereby instantiating the system objects setting their properties and running the system objects to produce one or more outputs. The outputs produced by the system objects may be returned to the simulation engine for further processing as part of the verification model .

The outputs produced by the graphical model and the verification model may be provided by the simulation engine to the verification harness . The result comparator of the verification harness may examine the results from the graphical model and the verification model and determine whether or not the results are the same as indicated at block . If a textual verification file was created by the verification harness it may be provided to the text based computing environment for execution by the execution engine in cooperation with the system object constructor as indicated at block . The results e.g. the outputs of the execution of the textual verification file may be provided by the text based computing environment to the verification harness . These outputs may be analyzed by the result comparator as indicated at block .

The result comparator may produce a report for the user that presents the results produced by both the selected graphical model and the verification model and or the selected graphical model and the textual verification file as indicated at block . For example the report may indicate whether the results from the various implementations are the same or not. If the results are the same then the system objects represent an equivalent manner of implementing the functionality or procedure represented by the selected graphical model. Processing may then terminate as indicated by end block .

It should be understood that data logging probes may be added to the selected graphical model so that signals may be obtained from the graphical model and provided as inputs to the system objects instantiated by the textual verification file. Similarly outputs of the system objects may be returned to the graphical model through data logging probes.

It should be further understood that the verification harness may be configured to verify or compare the selected graphical model with the verification model as previously described in connection with . Similarly the verification harness may be configured to verify or compare the selected graphical model with the textual verification file as previously described in connection with .

It should be understood that the verification harness may be used solely to create the verification model and or the textual verification files without verifying their behavior as compared to the selected graphical model. A user may conduct further study and perform additional refinements to the verification model and or the textual verification files . The user may also compile the verification model and or the textual verification file to generate stand alone object code.

Suitable code generation engines for use with the present invention include the Real Time Workshop code generation system and the Simulink HDL Coder system from The MathWorks Inc. the DSP Builder product from Altera Corp. of San Jose Calif. and the System Generator product from Xilinx Inc. of San Jose Calif. Additional code generation systems are described in U.S. Patent Publication No. 2008 0127057 for Specifying Implementations of Code for Code Generation from a Model published May 29 2008 and U.S. Patent Publication No. 2006 0064669 for Automatic Generation of Code for Component Interfaces in Models published Mar. 23 2006 each of which is hereby incorporated by reference in its entirety.

The code generation engine generates code for the received verification model or verification files utilizing the user specified options as indicated at block . To the extent the code generation engine generates source code conforming to a high level programming language the source code may be compiled into object code as indicated at block . To the extent the code generation engine generates HDL code the generated HDL code may be used to synthesize a target hardware device as indicated at block . More specifically the HDL code may be provided to a synthesis tool and synthesized into a gate level netlist which may be used to create a layout for creating or configuring a physical hardware device such as an Application Specific Integrated Circuit ASIC a Field Programmable Gate Array FPGA a Programmable Array Logic PAL or other type of physical hardware devices.

The generated code may be subjected to testing such as hardware in the loop HIL testing as indicated at block . That is a target platform configured to run the generated code may be connected to the computing device . A graphical model simulated by the graphical modeling environment may interoperate with the generated code running on the target platform. The graphical model may provide input data to the target platform and may receive output data e.g. for display produced by the target platform.

Suitable systems for performing HIL testing including the xPC Target system from The MathWorks Inc. With the xPC Target system a target personal computer PC which operates as a real time target is connected to a host PC that is running a text based computing environment and or a graphical modeling environment.

It should be understood that the code generation process may be used to accelerate verification of a model based design.

Following the testing if any the generated code may be deployed in a finished real life component that operates wholly outside and independently of the confines of the text based computing environment or the graphical modeling environment as indicated at block .

It should be understood that other forms of target code execution such as Rapid Prototyping Embedded System Deployment and Processor in the Loop which execute a graphical model or portions of a model via the generated code on a real time system target may be utilized.

The verification harness may be implemented in a computing device such as device and may be coupled to a text based computing environment and a graphical modeling environment.

The block generator may pass the selected and configured graphical blocks to the graphical model builder . The graphical model builder may examine the input and output data of the system objects of the textual program file. The graphical model builder may then use this information in determining how the executable graphical blocks are to be interconnected to form the graphical model as indicated at block . The graphical model may be output from the verification harness and may be simulated or run by the simulation engine of the graphical modeling environment as indicated at block .

The foregoing description of exemplary embodiments of the invention provides illustration and description but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. For example some of the steps illustrated in the flow diagrams may be performed in other orders and non dependent steps may be performed in parallel.

In addition implementations consistent with the principles of the invention may be implemented using devices and configurations other than those illustrated in the figures and described in the specification without departing from the spirit and scope of the invention. As mentioned devices modules or components may be added removed or combined depending on a specific deployment or application of the invention. Further disclosed implementations may not be limited to any specific combination of hardware.

