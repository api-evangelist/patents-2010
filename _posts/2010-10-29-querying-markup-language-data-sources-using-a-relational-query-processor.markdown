---

title: Querying markup language data sources using a relational query processor
abstract: An XML wrapper queries an XML document in an on-the-fly manner so that only parent nodes in the document that satisfy the query are extracted and then unnested. The parent nodes and associated descendent nodes are located using XPath expressions contained as options in data definition language (DDL) statements. The parent nodes satisfying the query and associated descendent nodes are extracted and stored outside of a database according to a relational schema. The wrapper facilitates applications that use convention SQL queries and views to operate on that information stored according to the relational schema. The wrapper also responds to query optimizer requests for costs associated with queries against external data sources associated with the wrapper.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08335800&OS=08335800&RS=08335800
owner: International Business Machines Corporation
number: 08335800
owner_city: Armonk
owner_country: US
publication_date: 20101029
---
This is a divisional application of U.S. application Ser. No. 11 837 567 filed on Aug. 13 2007 the entire contents of which are incorporated herein by reference.

The invention relates to information storage and retrieval systems methods and articles of manufacture. More particularly it relates to handling information contained in a markup language document using database tools and techniques.

The Extensible Markup Language XML is a type of markup language using tags to designate data. XML was created as a data exchange and representation standard that provides techniques for storing complex data structures in a hierarchical manner and in a way suitable for exchange over the Internet. An XML document can be a file or a data stream containing nested elements or nodes starting with a root node. Nested below the root node in a hierarchical fashion such as in a parent child relation are other nodes. Nested below those other nodes can be further nested nodes.

Methods of integrating XML data with other data generally fall into two groups. In one group the XML data is copied from its original location and stored persistently in a centralized database. In the other group the XML data is brought to the centralized database only in response to specific application requests and is stored persistently outside the centralized database in one or more external stores. There are various tradeoffs between the two approaches. The second approach has certain advantages over the first including 1 avoiding the need to replicate in the centralized database special functionality of backend sources of the XML data and 2 having current data found in response to queries since that data comes directly from the source. However with both of those conventional approaches the entire XML schema is mapped to a single table and accordingly the output from the XML source is flat. When the XML data is flattened into a single table data values can be repeated in many tuples. For example in an XML document holding information concerning customer names and orders they place when the XML data is flattened into a single table a customer name will appear with every order associated with the customer thereby repeating the customer name many times.

With either of these conventional approaches the XML schema is mapped into a flat space prior to a query operating on the XML information. All the data requested by the query must pass through the database management system and with the data flattened into a single table this can be a large volume of data due to the repeating information. Such a flat mapping operation can be expensive in that it can take a long time to map the data into the flat space and in the process can consume a large amount of memory. Further the number of operations performed over the XML data values is increased because those operations must be performed over the repeating data values in the single table. Further still with the data flattened into a single table a query optimizer cannot be used to unnest the nested XML elements in a just in time manner.

Accordingly there is a need to extract XML data from a data source into a plurality of tables in a just in time manner to reduce the volume of data that must pass through a database management system

Methods are described here of querying data in a mark up language document stored in a data source in which the mark up language document such as an XML document contains a plurality of nodes. These methods include a wrapper receiving in response to a request to extract a node from the markup language document a data stream including a parent node and evaluating the parent node with respect to a query. In response to evaluating the query the wrapper requests one or more nodes in a nested relationship with the parent node if the parent node satisfies the query. The wrapper maps the data stream according to a relational schema into a plurality of tables buffered in a non persistent memory. The wrapper translates the query into the request to extract the node from the document by evaluating an expression such as an XPath expression for locating the parent node.

Another method described here involves querying a document such as an XML document that contains hierarchical information including includes parent and child nodes. A wrapper locates a first parent node in the document by using a mapping specification. If the first parent node satisfies a query the first parent node is stored in a first table. Nested child nodes relating to the first parent node are fetched from the document and stored in a second table in response to determining that the first parent node satisfies the query. Other parent nodes that satisfy the query are stored in the first table and the nested child nodes relating to these other parent nodes are fetched from the document. The fetched child nodes are stored in a second table wherein the nested child nodes are located by using the mapping specification.

Also described here is a computer based system for querying a markup language document such as an XML document. The system includes a data source configured to manage the markup language document and a wrapper unit configured to extract information from the XML document in response to a query. The wrapper extracts the information by consulting a mapping specification containing information for locating the parent node. The wrapper further extracts the parent node and determines if the parent node satisfies the query. If the parent node satisfies the query that node is stored in a first table prior to extracting another parent node. Only the children nodes of parent nodes stored in the first table are extracted by consulting the mapping specification and those nodes are stored in a second table. The first and second tables are buffered in non persistent storage.

Another method described here optimizes a query of information in a markup language document that is stored in a data source external to a database. The method includes a wrapper associated with the data source containing the markup language document such as an XML document receiving a request for information concerning a cost of a query against the data source. In response to the request the wrapper determines a cost of performing the query and responds to the request by providing information concerning the cost.

Features and advantages of the invention will become apparent upon consideration of the following descriptions and descriptive figures of specific embodiments thereof. While these descriptions go into specific details it should be understood that variations may and do exist and would be apparent to those skilled in the art based on the descriptions herein.

The embodiments described below are described with reference to the above drawings in which like reference numerals designate like components.

A wrapper is described here for use with a relational database system to map hierarchical data contained in a markup language document located in a source external to the database into a relational schema composed of a set of tables. An example of such a markup language document is an Extensible Markup Language XML document. The XML wrappers described here enable use of conventional database languages such as the Structured Query Language SQL to query external XML documents stored in files or in other locations such as the database. The wrappers can provide read only access to XML documents.

An XML document contains elements or nodes related to one another in a hierarchical manner. The wrappers described here map certain elements in the XML document into a relational schema composed of a set of tables or nicknames. A federated database is a distributed computing system that includes a database management system server with one or more local databases and one or more external data sources. A nickname is a name given to a table in a federated database that is stored by one of the data sources in the federation. Clients refer to the table by this nickname without having to specify the data source name. A nickname is like a pointer to a table with which a server in the federated database refers the actual database object.

XML Path Language XPath expressions specified as options can be used to locate nodes within the XML document. XPath is a language for addressing parts of an XML document and XPath expressions are described in XML Path Language XPath Version 1.0 W3C Recommendation 16 Nov. 1999 located at http www.w3.org TR xpath. Each table for the XML document is defined by an XPath expression that identifies the XML elements representing individual tuples or rows in a relational table and a set of XPath expressions specifying how to extract the column values from each element. Nested XML elements can be represented by separate views relating to the outer views by using primary foreign keys that are either extracted from the document or generated by the system. By employing the wrappers described here SQL applications existing SQL generation tools and available SQL trained programmers can be leveraged for processing XML data without need to materialize or move the data into a database.

A federated database architecture employing such an XML wrapper is shown in . A client running an application that requires information communicates through an SQL application programming interface API with a relational database system to request that information. The SQL API can include for example a Java Database Connectivity JDBC API an Open Database Connectivity ODBC API or other well known APIs. In a preferred embodiment the DB2 database marketed by International Business Machines Corp. IBM is used as the relational database which includes a catalog and a data storage area . Coupled to the backend of the database are data sources and each containing data storage areas and respectively. Operating in conjunction with the database are wrappers and that operate to map the hierarchical data in the XML document into relational tables. Although the wrapper is described here for use with the IBM DB2 relational database management system DBMS the XML wrapper can be used with other DBMSs.

The XML wrappers or retrieve data from one or more of the XML data sources on demand without materializing it or storing it in the database. The wrapper reads the data from a stream produced as a result of a parameterized call such as a Simple Object Access Protocol SOAP call or user written program code that accesses the data sources. Application can use SQL to query the external XML data without being aware of its origin and original format. This paradigm enables reuse of legacy SQL applications as well as leverages existing SQL generation tools and available SQL trained programmers for development of new SQL applications operating on XML data. The XML tables can be used in user queries in the same manner as other tables. Queries can combine data from several XML and non XML data sources with data stored locally in the relational database. A query processor within the DBMS breaks the queries into fragments for the individual sources and produces an efficient execution plan using cost estimates supplied by the XML wrapper. The planning phase allows for plans where the nested repeating elements in the XML documents are unnested into tuples or rows in a relational table in a just in time manner to reduce the number of processed tuples and lower the query execution time.

A structure of an XML document is logically similar to a relational schema where the nested and the repeating elements are modeled as separate tables with foreign keys. Mapping XML data to a single relational table as is done in some conventional methods has similar deficiencies as using one denormalized table to model all the data represented by a schema. The tables or nicknames corresponding to an XML document are organized into a tree where the child nicknames model elements that are nested in the element corresponding to the parent nickname. There are basically two cases when an nested element should be modeled as a separate nickname 1 repeating elements and 2 elements with distinct identity and rich structure.

The wrapper identifies selected repeating elements or elements with distinct identity and rich structure and maps that information into a plurality of related tables held in non persistent storage. shows the nickname information of mapped into four separate tables namely a customer table an order table a payment table and an item table .

An example of a portion of an XML document is shown on the right hand side of . The left hand side of shows table names corresponding to the nicknames and lists the columns within those tables. The wrapper maps the information in the XML document to the tables as shown in . Here the customer element corresponding to a root node its location indicated by customer is mapped to a customer table having columns for a customer ID CID a name and an address. The CID column operates as a primary key for the customer table. Nested within the customer element are order elements and . These elements are mapped to an order table having columns for an order ID OID which operates as a primary key for the order table an amount of the order the date the order was placed and a foreign key namely the CID for the customer thereby relating the order to a customer entry in the customer table. Since the order elements are children of the customer element their location is indicated as order. The amount element for example is a leaf node in the hierarchical XML tree and its location is indicated as . amount indicating that the element is present below the current node in this case an order node. Nested within the order elements are item elements and . These elements are mapped into an item table having columns for an item id iid which operates as a primary key an item name a quantity of the item in the order and a foreign key namely the order ID OID thereby relating the item to an order in the order table. By mapping selected portions of the XML hierarchical tree structure into a plurality of relational tables held in non persistent memory the XML data can be operated on in real time or on the fly using conventional database queries and tools.

Each nickname that is mapped into a separate table is defined in the wrapper by an XPath expression that identifies the XML elements representing individual tuples and a set of XPath expressions specifying how to extract the column values from each element.

In a conventional method for handling XML documents the information within the XML document is extracted from the document as depicted in . An XML parser parses the information of as shown in table of . Once the information from the XML document shown in table is parsed a query is applied to it causing the information to be filtered resulting in an output . The filter can be implemented using SQL statements such as those depicted in . Here the customer name address and order date fields are selected from the customer order and payment tables. The query requires that the order date equal the payment date the customer name equal John the payment amount be greater than the order amount and that the payment and order dates be equal. The result of applying this SQL query to the data produces the information shown in table . The intermediate tables and shown in illustrate the amount of data that a central server must handle transiently.

In the manner described above the XML data is parsed into a single flat table and queried using conventional techniques to produce the output . The method described next avoids having to flatten the XML data into a single table and thereby repeat information in that table. Instead the method operates on the XML information on the fly as a wrapper extracts it from the XML document. Here the top level nodes within the XML document shown in namely the customer nodes are represented by information in . The XML wrapper first parses only the customer nodes and outputs them to a filter which evaluates one of the predicates in the SQL statement shown in that selects only the rows for the column John. Here the customer nodes for John and Ted are applied to filter . Because the filter operates only on the customer nodes in the XML document since those are parsed first only the customer node for John is passed through the filter as shown by information . The customer node John is then unnested by the wrapper to produce the table shown in . In this manner the XML data in the document is processed in an on the fly manner using a plurality of related tables to reduce the volume of data processed and without first materializing the XML information. While the end result namely the output information is the same as in the method shown in the latter method saves time and resources.

The wrapper handles three phases of processing the XML document registration and initialization query compilation and runtime query execution as illustrated in . The wrapper is first registered with the database. Queries are compiled by using optimizing processes in the database to produce query fragments that are sent to the wrappers for execution. Once the queries are compiled they are executed to extract selected data from the document. A description of each of these phases follows from registration to query execution.

The wrapper can map the markup language document into relational tables by using a DDL syntax that uses options to provide all the needed information. shows an example of a group of DDL statements following the syntax used with the DB2 program product that map the XML document illustrated in into the tables illustrated in .

Preliminary statements in the XML wrapper DDL shown in include a statement that creates a wrapper called xml from a specified library and a statement that creates an xml wrapper server called xml customers .

The XML wrapper DDL syntax shown in includes statements for creating nickname definitions for a customer table an order table and an items table. The payment nickname definition is omitted from for brevity. The customer nickname creation statement creates a nickname or table named customer and introduces three column options and and a nickname option .

The nickname option FILE PATH can appear only at the root nickname in the hierarchy. This option specifies the file from where the XML document is obtained. Another variant for specifying the location of the XML document is where the XML document is specified as a parameter bound to a column. The nickname XPATH option specified in statement supplies the XPath expression used to identify the document elements producing tuples. Here the statement specifies the customer nickname as the root and specifies a literal file path i.e. C bio data sequences.xml . One nickname tuple or row is generated for each node in the input document selected by that XPATH expression. In the example shown in for each customer node in the XML document one tuple is included in the customer nickname table. The column XPATH option shown in statements through is used to retrieve the column values to be placed in the customer table. Note that the XPath expression contained in an XPATH option is applied in a context of a tuple. For instance the . name XPath expression used in statement is applied to customer elements identified by the customer expression in the nickname XPATH option where customer indicates all elements under the root customer element.

In an XML document correspondence between different elements in the document is indicated by nesting elements within other elements. No keys are necessary as in the relational model. In order to map the information in an XML document into a relational schema the XML wrapper generates primary foreign keys based on the nesting that relate the tuples in the nicknames produced from the same XML document. Note that these keys are not repeatable i.e. they do not repeat over several query executions for the same elements and cannot appear in the SELECT list of an SQL statement. Also the wrapper is stateless as it does not materialize data since it does not write data into the database. Therefore it cannot generate repeatable keys.

In the example shown in keys are present in the document and they are used in the relational schema. Accordingly every parent nickname is required to have a column defined as PRIMARY KEY with type VARCHAR of a certain length e.g. a length of 16 . A nickname is designated as a child of another nickname by including a column that references the primary key of the parent nickname indicated with a FOREIGN KEY option and no XPATH option. A nickname can have multiple children although it must have exactly one parent except for the root which has no parent. The nickname graph has a tree structure and hence there can be at most one PRIMARY KEY and FOREIGN KEY column in a nickname.

In the customer nickname or table is created with three columns namely columns for NAME ADDRESS and CID where CID is the primary key for the customer table. Statement defines the NAME column having a variable length of characters up to sixteen. The XPATH option expression . NAME specifies that the NAME element in the XML document is located at a child of the current customer location. Similarly statement specifies the ADDRESS column having a variable length of characters up to thirty and an XPATH option expression . ADDR STREET specifying that the ADDRESS element in the XML document is located under the current customer location. Statement defines the customer identifier CID column with a variable length of characters up to sixteen with a path location at the same level as the customer location and designated as the primary key for the customer table.

The order table is defined in a similar manner by statement with statements through specifying four columns namely AMOUNT DATE OID and CID . The locations for these elements in the XML document are specified by the XPath expressions set forth in the options respectively. The OID column is designated as the primary key and the CID is designated as the foreign key. Here statement specifies that the information in the XML document pertaining to orders is located at the same level as the current context and with a tag of order. Statement also specifies that a customer element is the parent of an order element.

The items nickname or table also is specified in a similar manner by statement with statements through specifying three columns namely ITEM NAME QUANTITY and OID with their locations specified by the respective XPATH options. Here the OID is specified as the foreign key. Statement specifies that the information in the XML document pertaining to items is located at the same level as the current context and with a tag of item and specifies that an order element is the parent of an item element.

The DDL format for defining the root nickname where the filename is not fixed by an option value but rather is specified in a query is shown in . shows query statements including WHERE statement specifying a location of the document. Here the customer nickname creation statement creates a table named customer and a statement introduces a column that represents the document name. The nickname option DOCUMENT can appear only at the root nickname in the hierarchy. One nickname tuple or row is generated for each element in the input document. In the example shown in for each customer node in the XML document that satisfies the query one tuple is included in the customer nickname.

Referring to the database upon receiving a query from an application breaks the query into fragments in order to optimize the query. The database might determine that data for one or more of the query fragments resides in an external data source such as back end data source that contains a markup language document such as an XML document. The database sends a request to wrapper with the query fragment intended to retrieve the desired data from data source . When wrapper receives the request it determines what portion if any of the corresponding query fragment can be satisfied by the data source. The wrapper returns a reply that describes the accepted portion of the fragment. The reply also includes cost estimates for the query such as an estimate of the number of rows that will be produced an estimate of the total execution time and a wrapper plan that is an encapsulated array of the accepted portion of the fragment.

A query optimizer incorporates the replies from the various wrappers to which it sent requests into a global plan for the original query introducing additional operators as necessary to compensate for portions of fragments that were not accepted by a wrapper. The cost and cardinality information from the replies is used to estimate the total cost of the plan and the plan with minimum total cost is selected from among all the candidates. This process is referred to as a request reply compensate protocol. During the plan enumeration the database sends the wrapper increasingly larger plans. The XML wrapper accepts only plans of size one i.e. a single table access over nicknames from the XML server. For example the plan for a simple query shown in selects the amounts and customer names for each order of each customer assuming the XML file name is specified by a FILE PATH option . The plan produced by the optimizer is illustrated in and includes a filtering process following a bind join of the customer table and the order table .

The plan first selects the customer name and the CID and then performs a bind join to get the customer orders. The bind join models an unnest operation for the nested XML elements. If there are multiple child nicknames in a single query there will be one bind join for each. The bind joins in the plan do not need to make a consecutive sequence and other operations including joins with nicknames from other sources and local tables can be interleaved. The ordering of all the operations in the query is determined by the optimizer. Bind joins to children nicknames are always passed using the PRIMARY KEY column of the parent nickname. The XML wrapper generates a value for this column based on an in memory pointer of a node such as a node in a XPath XSLT processor such as an XALAN processor representing the XML document element for the parent element. In the example shown in a pointer to the customer element is passed to the bind join that unnests the orders. Using this pointer the wrapper applies the XPath expressions for extracting the orders using this node as a context. The pointer is used to directly identify the orders of the currently processed customer without another traversal through the document and in this manner allows the information from the XML document to be processed on the fly .

The wrapper returns a plan for single nickname accesses containing exactly one of the following predicates or their symmetrical versions dc parameter dc constant or fkc parameter. Where dc is a DOCUMENT column and fkc is a FOREIGN KEY column. The wrapper accepts only this predicate and the rest are evaluated by the database.

A plan is also returned for single table plans over a root nickname when there is a nickname DOCUMENT option. In this case no predicates are accepted. A request with more than one predicate of the forms listed above is due to invalid use of pseudo columns in a query and should be reported as an error. Any other predicates using the pseudo columns are also detected and an error is reported. The wrapper does not return plans for requests having the pseudo column in the select list and not in one of the accepted predicates. This forces the optimizer to generate only the bind join plans as shown in .

It might happen that a pseudo column is used in an equi join predicate compared to a column from another wrapper or local database table. The access plan in that case has a form similar to the form of the supported queries. Since such queries do not make sense this can be detected and prevented by checking the predicates in the multi nickname requests. While the wrapper never returns a plan for such requests if it detects an invalid predicate it will report an error that will abort the query compilation.

The plan returned by the wrapper also contains all the columns that were in the request. Since only single nickname requests are accepted all the columns are from that nickname. The FROM clause in contains the quantifier from the request.

The database uses the reply from the wrapper to determine the query fragment that the wrapper will execute. The wrapper also prepares an execution descriptor that contains a description of the query fragment used by the wrapper at run time. The execution descriptor is a continuous self contained block since as a part of the query execution plan it can be stored in the catalog or shipped to a fenced process for execution. The XML wrapper packs its internal structures into a plan array containing an entry for the nickname and one entry for each selected column. Each entry has attached an XPath expression. The column entries also carry the position in the SELECT list output tuple and the data type. The execution descriptor contains a flag to indicate how to obtain the context for the XPath expressions evaluation. If the plan is for a root nickname where the file name is supplied with a DOCUMENT nickname option or the nickname had a DOCUMENT column and the file name was given as a query constant then the file name is also added to the execution descriptor. In the case when the file name is generated by the other parts of the query and it is not available at compile time the name is extracted from the bound in parameter at runtime. When the descriptor represents a plan for a non root nickname the context is given by the bound in value produced by the access plan for the parent nickname preceding the current access plan. The descriptor in this case indicates that the context is a memory pointer stored in the input parameter.

The XML wrapper can use a conventional XPath XSLT processor such as an XALAN processor to process the XPath expressions. Execution of the query fragment received from the database is divided into Open Fetch and Close phases that employ similar semantics as used with database cursors. These functions can be implemented in an object oriented class in a query gateway such as an object class referred to here as the XML Query class.

Operation of the runtime phase is described with reference to . In the Open phase the wrapper unpacks the execution descriptor created during query compilation and initializes the context either by opening and parsing the file or by obtaining a supplied memory pointer . The pointer points to an XML Query object of the access operator for the parent nickname. The XML Query objects of the non root nicknames are initialized by copying the information for the passed parent object. In this manner the parse tree is reused and access is obtained to the context by passing only one pointer between the access sub plans.

Each time an Open is invoked with a new context the XPath expression for the nickname is applied and the resulting list of nodes is stored in an object attached to the XML Query object . The first time the document is opened a first node is selected for processing. That first node can be selected according to certain criteria such as the node satisfying a query. The nodes in the list are processed in order and in operation the next node in the list is selected. Each consecutive invocation of a Fetch uses one object in this list to retrieve the required column values and buffer those values in memory. When the end of the list is reached Fetch returns an end of file EOF indication . If an EOF indication is not returned the next node in the list is selected for unnesting . If an EOF indication is returned but the node is not the last node the next ancestor node is selected and the XPath expression applied to that node . This causes one of the preceding access operators representing ancestor nicknames in the hierarchy to move to the next node in their list and call the child with a new context. When the last node is processed the document is closed . In operation the next ancestor node that is selected can be qualified by certain criteria such as the node satisfying a query. This qualification of a node can be performed by the database management system. In this manner only the nodes satisfying a query or meeting some other criteria are unnested.

For example for the query shown in during opening of the plan segment for the order nickname the customer XPath is applied and the resulting list of customer nodes is stored. The context index is set to point to the first of the retrieved nodes the first customer node and is also stored in the XML Query object.

The Fetch function returns the required columns including the pseudo column containing the pointer to the current XML Query object. Next the system opens the inner operand of the nested loop join by calling the Open function on the XML Query object representing the order nickname access plan. Here the first node identified by the list and the current context index being 0 in the list of the passed XML Query object is used as a context to apply the order XPath expression retrieving a set of orders for the first customer. Here again the resulting list is stored in the current XML Query object together with context index set to 0. A subsequent Fetch invocation returns the tuples of columns for the first customer orders by applying the XPath expressions for the columns to the nodes in the list. When the Fetch for the order table returns EOF the next customer is fetched and the process continues until all the orders for all the customers are processed. Finally Close deletes the node lists and other intermediate storage.

As described so far the XML wrapper supports only queries that have a join over the PRIMARY KEY and FOREIGN KEY columns. A query over nicknames from the same hierarchy that does not contain the correct set of joins cannot be processed. While the joins over the primary foreign keys are the most common ones in certain situations other joins might be required. One such example is when the XML document contains keys that relate the elements in addition to the nesting. For convenience or if the queries are already written the joins might be expressed over these logical keys. Logical keys cannot be used without some auxiliary structures as indexes to locate the corresponding input document tree nodes. In a federated environment indexes for data from external sources are not available and therefore queries over the logical keys need to be augmented with predicates that join the nicknames using the pseudo columns that during the execution contain physical keys e.g. memory pointers. This applies to all other queries that join nicknames over non key data or join pieces of the nickname hierarchy that does not start at the root of the hierarchy.

To allow any type of query the user can define federated views on top of the nicknames that will guarantee the inclusion of the required predicates and a full path to the root. The technique described below uses existing DB2 rewrite rules to add the required predicates while in most cases the redundancies are eliminated by existing DB2 rewrite rules.

Such views for orders payments and items are shown in . These views are defined for each non root nickname as a join of all the nicknames on the path to the root. The join predicates are over the PRIMARY KEY and FOREIGN KEY columns and the SELECT list contains all the columns of the nickname. In the case where the XML document contains keys the pseudo columns can be omitted from the list. In the view definitions the primary key column is defined by selecting the parent nickname s PRIMARY KEY.

To illustrate the use of such views assume that the nicknames in the example shown in are declared as customer order i payment i and item i. Exemplary views for orders payments and items are shown in . The order view selects the order amount order date order ID OID and customer ID CID from the customer and order i tables related by the CID key. The payment view selects the payment amount payment date and customer ID from the customer and payment i tables related by the CID key. The item view selects the item quantity item name and order ID from the customer order i and item i tables related by the CID and OID keys.

A query submitted against any of the views shown in is processed correctly since the join path to the root is present once the view is expanded. An example of such a query is a query that pairs the amounts of customer s orders and payments having the same date as shown in .

If order and payment are XML wrapper nicknames the query will not execute since no plan can be produced without the customer nickname in the query. However if the query is evaluated over the views shown in the views first will be expanded into the query segment shown in . During the database rewrites performed in this example by DB2 the query rewrite deduces c1.cid c2.cid and based on the uniqueness of the customer CID column c1 c2. Accordingly the database rewrites the query as shown in and this query is accepted by the wrapper.

Similarly the query shown in is expanded into the query shown in . This query is finally rewritten into the form shown in where the redundancy is eliminated.

Another example of an application of the XML wrapper described here is depicted with reference to concerning a life sciences application. Here an XML document a portion of which is shown in includes DNA sequences with DNA codes and associated comments to those codes. As shown in an XML tag identifies the beginning of a sequence. In the sequence are DNA codes and . Also in sequence are comment statements and that contain information concerning the codes. An end tag marks the end of the sequence.

An SQL query to process this XML document is shown in . Here a code and comment are selected from the sequence and comment tables in which a relatively expensive operation namely a match operation is performed on the XML document. A conventional method for processing the SQL query is illustrated in . Referring to the information contained in the XML document is first extracted into a table . In this manner the XML information is flattened so that a tuple or row for each code and corresponding comment is included in the table . The match operation then operates on the flattened table to produce the desired results . However the expensive match operation must operate on each tuple in table namely on each of the codes and comments in the XML document resulting in a expensive operation.

The XML wrapper described here can be used to reduce the expense of the operation. Referring to the information in the XML document is processed on the fly to thereby reduce the number of matches performed. Only the separate codes in the XML document and not duplicated codes are extracted and the match performed only on those extracted codes. As shown in the XML information for the codes AGTGA . . . and TGAGA . . . are extracted from the XML document and matched using the match operation . The XML document output includes the code ID namely code ID1 and code 1D2 corresponding to the two codes that are extracted from the document. These code IDs are set forth in the comment column of the tables shown in . Applying the match operation to the two codes results in one of the codes being matched namely the code AGTGA . . . The unnest operation is then performed only on that matched code resulting in the information being output. In this manner the number of match operations is minimized so that the match operation is only applied once to each unique code within the XML document thereby reducing the expense of the match operation.

Having described systems articles of manufacture and methods of handling information contained in a markup language document using database tools and techniques it is believed that other modifications variations and changes will be suggested to those skilled in the art in view of the teachings set forth herein. It is therefore to be understood that all such variations modifications and changes are believed to fall within the scope of the present invention as defined by the appended claims. Although specific terms are employed herein they are used in their ordinary and accustomed manner only unless expressly defined differently herein and not for purposes of limitation.

IBM is a trademark or registered trademark of International Business Machines Corporation in the United States and other countries.

DB2 is a trademark or registered trademark of International Business Machines Corporation in the United States and other countries.

