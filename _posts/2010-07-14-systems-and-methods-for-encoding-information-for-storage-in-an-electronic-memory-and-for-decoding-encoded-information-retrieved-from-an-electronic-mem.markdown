---

title: Systems and methods for encoding information for storage in an electronic memory and for decoding encoded information retrieved from an electronic memory
abstract: Method and system embodiments of the present invention are directed to encoding information in ways that are compatible with constraints associated with electrical-resistance-based memories and useful in other, similarly constrained applications, and to decoding the encoded information. One embodiment of the present invention encodes k information bits and writes the encoded k information bits to an electronic memory, the method comprising systematically encoding the k information bits to produce a vector codeword, with additional parity bits so that the codeword is resilient to bit-transition errors that may occur during storage of the codeword in, and retrieval of the codeword from, the electronic memory, ensuring that the codeword does not violate a weight constraint, and writing the codeword to the electronic memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08407560&OS=08407560&RS=08407560
owner: Hewlett-Packard Development Company, L.P.
number: 08407560
owner_city: Houston
owner_country: US
publication_date: 20100714
---
This invention has been made with Government support. The government has certain rights in the invention.

The present invention is related to error control coding and electronic memories and in particular to methods and systems for encoding information for storage in electronic memories associated with constraints related to the encoded information.

Error control coding is a well developed interdisciplinary field that spans applied mathematics computer science and information theory. Error control coding techniques are used throughout modern computing communications and data storage systems. In general error control coding involves supplementing digitally encoded information with additional redundant information in order to render the encoded information less susceptible to corruption or loss due to various types of transmission errors errors that arise as the encoded information is passed through various types of physical and logical interfaces and errors that arise when the information is stored in and retrieved from various types of electronic data storage media.

Recently a new generation of electrical resistance based memories various types of which include one dimensional two dimensional and three dimensional arrays of nanoscale resistors or memristors have been developed for a variety of data storage and computational applications. These newly developed memory arrays have various electronic and physical properties and characteristics that constrain the types of data that can be stored within and retrieved from the memories. Researchers and developers of these new types of memories therefore are seeking error control coding techniques that can accommodate the data constraints associated with electrical resistance based memories and error control coding theoreticians and researchers continuously seek new methods and systems for error control coding applicable to newly encountered and not yet encountered applications.

Method and system embodiments of the present invention are directed to encoding information in ways that are compatible with constraints associated with electrical resistance based memories and useful in other similarly constrained applications and to decoding the encoded information. Method and system embodiments of the present invention employ a combination of error control coding techniques and encoding and decoding techniques based on bitwise complementation operations. The error control coding techniques provide systematic redundancy error detection and error correction and the bitwise complement operations generate encoded information that satisfies the constraints associated with electrical resistance based memories and other application domains.

It should be noted at the onset the method embodiments of the present invention discussed below are necessarily implemented for execution on a computer system and or implemented as logic circuits within an electronic device. When executed by a general purpose computer the general purpose computer is transformed into a special purpose encoding and decoding machine that represents a system embodiment of the present invention. The methods of the present invention cannot be carried out by hand calculation or by mental calculation because the methods involve very large numbers of arithmetic and logic operations even when small amounts of information are encoded. Calculation by any means other than an electronic computer or other electronic device would take many orders of magnitude of time in excess of the times needed for preparing data for storage in electronic memories and would be far too error prone to serve any practical purpose.

In a first subsection below electrical resistance based memories are described along with a data constraint associated with certain electrical resistance based memories. In a second subsection certain error control coding techniques are described. In a third subsection certain embodiments of the present invention are discussed.

A problem encountered in certain types of resistance based memory arrays particularly those with nanoscale components is that when too many memory elements are in the low resistance state the current flow through a column signal line or row signal line that interconnects them may be sufficiently high to damage or destroy the signal line and the memory array containing the signal line and even when not sufficiently high to destroy the signal line may be sufficiently high to induce various unwanted current paths through unselected memory elements. Thus as also shown in graph in a memory array may be constrained to store data that can be represented in the array with no more than a threshold number of memory elements in any row or column in the low resistance state at any particular point in time. As an example in graph the current i represents the highest current that can be safely carried by a column signal line or row signal line corresponding to 100 memory elements out of 200 memory elements being in the low resistance state.

Embodiments of the present invention employ concepts derived from well known techniques in error control encoding. An excellent reference for this field is the textbooks Error Control Coding Fundamentals and Applications Lin and Costello Prentice Hall Incorporated New Jersey 1983 and Introduction to Coding Theory Ron M. Roth Cambridge University Press 2006. In this subsection a brief description of the error detection and error correction techniques used in error control coding are described. Additional details can be obtained from the above referenced textbooks or from many other textbooks papers and journal articles in this field. The current subsection represents a concise description of certain types of error control encoding techniques.

Error control encoding techniques systematically introduce supplemental bits or symbols into plain text messages or encode plain text messages using a greater number of bits or symbols than absolutely required in order to provide information in encoded messages to allow for errors arising in storage or transmission to be detected and in some cases corrected. One effect of the supplemental or more than absolutely needed bits or symbols is to increase the distance between valid codewords when codewords are viewed as vectors in a vector space and the distance between codewords is a metric derived from the vector subtraction of the codewords.

In describing error detection and correction it is useful to describe the data to be transmitted stored and retrieved as one or more messages where a message comprises an ordered sequence of symbols that are elements of a field F. A message can be expressed as . . . where F. The field F is a set that is closed under multiplication and addition and that includes multiplicative and additive inverses. It is common in computational error detection and correction to employ finite fields GF p comprising a subset of integers with size equal to the power m of a prime number p with the addition and multiplication operators defined as addition and multiplication modulo an irreducible polynomial over GF p of degree m. In practice the binary field GF 2 or a binary extension field GF 2 is commonly employed and the following discussion assumes that the field GF 2 is employed. Commonly the original message is encoded into a message c that also comprises an ordered sequence of elements of the field GF 2 expressed as follows where c GF 2 .

Block encoding techniques encode data in blocks. In this discussion a block can be viewed as a message comprising a fixed number of symbols k that is encoded into a message c comprising an ordered sequence of n symbols. The encoded message c generally contains a greater number of symbols than the original message and therefore n is greater than k. The r extra symbols in the encoded message where r equals n k are used to carry redundant check information to allow for errors that arise during transmission storage and retrieval to be detected with an extremely high probability of detection and in many cases corrected.

In a linear block code the 2codewords form a k dimensional subspace of the vector space of all n tuples over the field GF 2 . The Hamming weight of a codeword is the number of non zero elements in the codeword and the Hamming distance between two codewords is the number of elements in which the two codewords differ. For example consider the following two codewords a and b assuming elements from the binary field 

The encoding of data for transmission storage and retrieval and subsequent decoding of the encoded data can be notationally described as follows when no errors arise during the transmission storage and retrieval of the data where c s is the encoded message prior to transmission and c r is the initially retrieved or received message. Thus an initial message is encoded to produce encoded message c s which is then transmitted stored or transmitted and stored and is then subsequently retrieved or received as initially received message c r . When not corrupted the initially received message c r is then decoded to produce the original message . As indicated above when no errors arise the originally encoded message c s is equal to the initially received message c r and the initially received message c r is straightforwardly decoded without error correction to the original message .

When errors arise during the transmission storage or retrieval of an encoded message message encoding and decoding can be expressed as follows Thus as stated above the final message r may or may not be equal to the initial message s depending on the fidelity of the error detection and error correction techniques employed to encode the original message s and decode or reconstruct the initially received message c r to produce the final received message r . Error detection is the process of determining that while error correction is a process that reconstructs the initial encoded message from a corrupted initially received message 

The encoding process is a process by which messages symbolized as are transformed into encoded messages c. Alternatively a message can be considered to be a word comprising an ordered set of symbols from the alphabet consisting of elements of F and the encoded messages c can be considered to be a codeword also comprising an ordered set of symbols from the alphabet of elements of F. A word can be any ordered combination of k symbols selected from the elements of F while a codeword c is defined as an ordered sequence of n symbols selected from elements of F via the encoding process 

Linear block encoding techniques encode words of length k by considering the word to be a vector in a k dimensional vector space and multiplying the vector by a generator matrix as follows Notationally expanding the symbols in the above equation produces either of the following alternative expressions 

The syndrome S is used for error detection and error correction. When the syndrome S is the all 0 vector no errors are detected in the codeword. When the syndrome includes bits with value 1 errors are indicated. There are techniques for computing an estimated error vector from the syndrome and codeword which when added by modulo 2 addition to the codeword generates a best estimate of the original message . Details for generating the error vector are provided in the above mentioned texts. Note that only up to some maximum number of errors can be detected and fewer than the maximum number of errors that can be detected can be corrected.

As discussed above embodiments of the present invention are directed to encoding and decoding techniques for coding information to be stored in memory arrays and memory vectors and decoding information retrieved from memory arrays and memory vectors with the codewords produced by coding embodiments of the present invention satisfying the above discussed data constraint. For example the constraint may specify that no row or column in a two dimensional bit matrix codeword can have a Hamming weight greater than a threshold value. In examples used to illustrate embodiments of the present invention square matrix codewords may be constrained to have no column or row with a Hamming weight greater than n 2 where n is the row or column dimension of the matrix and indicates integer division.

While the encoding and decoding method that represents one embodiment of the present invention discussed above with reference to does allow for encoding of information bits in compliance with a Hamming weight constraint the methods suffer from disadvantages when errors occur in storage or while a codeword x is being written to or read from a vector memory. For example when the final bit of the encoded vector x is erroneously inverted the resulting decoded vector u is generally quite different in bit values from the original input information bits.

A second encoding and decoding method that represents another embodiment of the present invention is based on identifying a generator matrix G for a linear block code 

The encoding and decoding methods illustrated in which represent embodiments of the present invention have certain desirable features. Encoded vector inversion by bitwise complementation ensures that encoded vectors comply with the Hamming weight constraint namely having Hamming weights less than a threshold weight . Encoding of the modified information bit vector u using generator matrix G introduces additional parity bits that are subsequently used on decoding to detect and correct up to a maximum number of errors. As discussed in the preceding section the number of errors that can be detected is generally greater than the number of errors that can be both detected and corrected.

Next in step the q received information bits are arranged within an m n array A using a well defined mapping between an ordered vector representation of the input q bits and the bit positions within array A. Within array A p positions are reserved for the parity bits and are referred to as reserved bits and the final row and final column of array A are initialized to contain only bits with value 0. As discussed in greater detail below the parity bits are distributed within the array so that even were all the parity bits equal to 1 the array would nonetheless comply with the Hamming constraint for the columns and rows of the array. Note that the arrangement of information bits and 0 valued bits in memory may be different from the logical arrangement and the logical arrangement obtained by programmatic retrieval of bits in a particular order during array based operations. Next in a while loop comprising steps a row or column in matrix A with a Hamming weight greater than a threshold weight is selected assuming the reserved R positions are 1 s in each iteration of the while loop and inverted in all non reserved positions using bitwise complement operations until no column or row in array A has a weight greater than the threshold weight. Next in step values of the p parity bits are computed from all but the reserved bits in array A using a systematic code and finally in step the computed parity bits are placed into the reserved positions of the array A to complete construction of the array codeword A. The codeword can be stored in a two dimensional resistor based memory without violating the row and column constraints.

In it is assumed that there is a single threshold Hamming weight constraint represented by threshold value t that applies both to columns and rows of array A. In alternative embodiments of the present invention different threshold values tand tmay be applied to rows and columns respectively to reflect different constraints in the underlying two dimensional resistor based array. As is discussed in greater detail below the encoding method that represents one embodiment of the present invention discussed with reference to is well suited for generating two dimensional codewords in an array with dimensions m n where m and n are even and row and column threshold values tand tare greater than or equal to n 2 and m 2 respectively and p is less than or equal to the minimum of in and n. In this case any q input bits can be successfully encoded by the method discussed above with reference to . In other cases the method is slightly altered as discussed further below.

Note that the parity bits are arranged along the main diagonal of the array codeword. This arrangement insures that each column and row contains only a single parity bit. As discussed above with reference to the non reserved bits of the array codeword are input to a systematic encoder in order to compute the values for the parity buts in the penultimate step of . Therefore prior to that step it needs to be guaranteed that regardless of what value is assigned to each parity bit no column or row of the array codeword will have more than n 2 or m 2 respectively bits with value 1. In order to make this guarantee the reserved positions are assumed to have a value 1 during the while loop in which bitwise complement operations are carried out until the Hamming weight constraint is satisfied in . Since the threshold t is m 2 or 3 no row or column containing a reserved position can have more than 2 bits with value 1 and no row or column without a reserved position can have more than 3 bits with value 1 prior to calculation of the parity bit values. Because both m and n are even and equal when a row or column has more than m 2 bits with value 1 inversion of the row or column necessarily produces a complementary row or column with less than m 2 bits regardless of the value subsequently assigned to a parity bit in the row or column. However in the case that a row or column length m or n is odd then either the minimum Hamming weight constraint threshold needs to be m 2 1 or n 2 1 respectively or any reserved positions need to be paired with an additional reserved 0 valued position and the minimum Hamming weight constraint threshold maintained at m 2 or n 2. The additional reserved positions are assumed to be 0 in the Hamming weight computation and like the original reserved positions are unchanged during the inversion step of the row column inversion loop .

Next the row and column inversions are carried out as in the while loop of steps in . Intermediate array codewords are generated by row and column inversion with array codeword satisfying the row and column Hamming constraint that no row or column should have more than three bits with value 1. For example array codeword is generated by inversion of the 5row of array codeword . Note in intermediate array codeword that the Hamming weight constraint is satisfied even when all five parity bits represented by the symbol R are set to bit value 1. Then the non reserved bits of the codeword are assembled into a modified vector s which is multiplied by a generator matrix G of a systematic encoding method to produce a codeword c from which five parity bits are obtained . These parity bits are then inserted in the intermediate array codeword to produce a final array codeword . The vector s may not necessarily be constructed in memory but may only be logically constructed as bits are selected from array codeword during the multiplication by generator matrix G .

Although the present invention has been described in terms of particular embodiments it is not intended that the invention be limited to these embodiments. Modifications will be apparent to those skilled in the art. For example a variety of different implementations of the various embodiments of the present invention can be obtained by varying any of many different implementation parameters including programming language modular organization control structures data structures and other such implementation parameters. Many embodiments of the represent invention employ systematic coding and decoding techniques including systematic linear block codes. A variety of different systematic coding and decoding techniques can be used in certain embodiments of the present invention. While descriptions of embodiments of the present invention refer to vectors array codewords and other such entities these entities may be implemented in various ways for storage and retrieval from computer memory and mass storage devices and often a vector codeword and an array codeword equivalent to the vector codeword may be stored in one form that is programmatically transformed to between various formal representations. Thus for example were a two dimensional data array used to store a codeword the two dimensional data array can be programmatically treated as a vector codeword for matrix multiplication by a generator matrix. While the above discussion of embodiments of the present invention use vectors and arrays containing elements of the GF 2 field equivalent methods can be implemented to handle information encoded using elements of other fields. The positions of the all 0 column and row of the array codewords is illustrated and described as the final row and column of the array codeword but other positions can be selected for the all 0 row and column in alternative embodiments of the present invention. Of course an opposite convention in which the reserved row and column are initialized to have bits with 1 values and the inverse of the column and row inversion inverts bits when the sum of related bits is even can also be used to implement embodiments of the present invention. Similarly in the vector encoding embodiments of the present invention the additional bit can be initially set to 0 with inversion indicated by a value 1 in the additional bit. In similar fashion the weight of a codeword can be computed according to either of two conventions the convention chosen determining the nature of the threshold comparison used to decide whether or not to invert a row column or vector codeword.

The foregoing description for purposes of explanation used specific nomenclature to provide a thorough understanding of the invention. However it will be apparent to one skilled in the art that the specific details are not required in order to practice the invention. The foregoing descriptions of specific embodiments of the present invention are presented for purpose of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments are shown and described in order to best explain the principles of the invention and its practical applications to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents 

