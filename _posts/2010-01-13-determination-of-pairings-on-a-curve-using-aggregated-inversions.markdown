---

title: Determination of pairings on a curve using aggregated inversions
abstract: One or more techniques and/or systems are disclosed that provide for determining mathematical pairings for a curve for use in cryptography. A plurality of inversions used for determining the mathematical pairings for the curve are aggregated (e.g., into a single inversion in respective levels of a binary tree representation of elements of the computation). The mathematical pairings for the curve are determined in affine coordinates from a binary representation of a scalar read from right to left using the aggregated plurality of inversions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08548160&OS=08548160&RS=08548160
owner: Microsoft Corporation
number: 08548160
owner_city: Redmond
owner_country: US
publication_date: 20100113
---
Computers have become increasingly interconnected via networks such as the Internet and security and authentication concerns have become increasingly important. Cryptographic techniques that involve a key based cipher for example can take sequences of intelligible data e.g. typically referred to as plaintext that form a message and mathematically transform them into seemingly unintelligible data e.g. typically referred to as ciphertext through an enciphering process. In this example the enciphering can be reversed thereby allowing recipients of the ciphertext with an appropriate key to transform the ciphertext back to plaintext while making it very difficult if not nearly impossible for those without the appropriate key from recovering the plaintext.

Public key cryptographic techniques are an embodiment of key based cipher. In public key cryptography for example respective communicating parties have a public private key pair. The public key of each respective pair is made publicly available e.g. or at least available to others who are intended to send encrypted communications and the private key is kept secret. In order to communicate a plaintext message using encryption to a receiving party for example an originating party can encrypt the plaintext message into a ciphertext message using the public key of the receiving party and communicate the ciphertext message to the receiving party. In this example upon receipt of the ciphertext message the receiving party can decrypt the message using its secret private key thereby recovering the original plaintext message.

An example of public private key cryptology comprises generating two large prime numbers and multiplying them together to get a large composite number which is made public. In this example if the primes are properly chosen and large enough it may be extremely difficult e.g. practically impossible due to computational infeasibility for someone who does not know the primes to determine them from just knowing the composite number. However in order for this method to be secure the size of the composite number should be more than 1 000 bits. In some situations such a large size makes the method impractical to be used.

An example of authentication is where a party or a machine attempts to prove that it is authorized to access or use a product or service. Often a product ID system is utilized for a software program s where a user enters a product ID sequence stamped on the outside of the properly licensed software package as proof that the software has been properly paid for. If the product ID sequence is too long then it will be cumbersome and user unfriendly. Other common examples include user authentication when a user identifies themselves to a computer system using an authentication code.

As another example in cryptography elliptic curves are often used to generate cryptographic keys. An elliptic curve is a mathematical object that has a structure and properties well suited for cryptography. Many protocols for elliptic curves have already been standardized for use in cryptography. A recent development in cryptography involves using a pairing where pairs of elements from one or more groups such as points on an elliptic curve can be combined to generate new elements from another group to create a cryptographic system.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Encryption and decryption are usually performed based on a secret. This secret can utilize an order of a group of points or some other characteristic of the group such as the generator or a multiple of the generator. A variety of different groups can be used in cryptography such as implementing the points on an elliptic curve for the group s elements. A group of elements e.g. points derived from an elliptic curve can be used in the encryption decryption for example as the discrete logarithm problem DLP for such a group is considered to be hard. A hard DLP is preferred in cryptography in order to create a secure encryption decryption process for example.

Currently when computing pairings on an elliptic curve a lot of operations such as multiplications or inversions in the finite field that the elliptic curve is defined over can be required. One can attempt to reduce the number of multiplications to reduce computation expense and or speed the computations up in other ways. One technique for speeding up the computations is to reduce a number of inversions undertaken when computing the pairing.

For example when working in affine space both multiplications and inversions are performed where inversions are more computationally expensive than multiplications. In order to reduce the number of inversions current practitioners change the coordinate system of the curve points from affine space to projective space. This has an effect of reducing the inversions while increasing the number of multiplications which are computationally cheaper.

One or more of the techniques and or systems described herein provide an alternate to converting the coordinates to projective space while still reducing a number of inversions needed to compute the pairing on the elliptic curve. Using these techniques and systems one may aggregate inversions for coordinates in affine space for example and reuse the aggregated inversions for an additive act used for the pairing computation. Further portions of the computations can be parallelized on multi core systems for example to speed up the overall computation time. In this way for example pairings used in a cryptographic system can be computed using less computational resources and in a shorter time e.g. faster than present implementations.

In one embodiment when determining mathematical pairings for a curve for use in cryptography a plurality of inversions that are used when determining the mathematical pairings for the curve are aggregated e.g. into a single inversion such as an intermediate calculation in the pairings computation . The mathematical pairings for the curve are determined in affine coordinates along a binary representation of a scalar read from right to left using the aggregated plurality of inversions.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

The one or more cryptographic pairings techniques and or systems described herein can determine mathematical pairings for an elliptic curve that can be used for cryptographic applications. For example they can be used to determine pairings for a proposed authorization e.g. an electronic signature for cryptographic applications.

Typically a pairing based cryptosystem utilizes a group e.g. of elements and a binary multiplier derived from an elliptic curve whose elements are publicly known e.g. by knowing the curve . The scalar that is used to compute the pairing is publicly known. Unknown secrets are either the input points or implicitly contained in the input points to the pairing. The basis for the security is the hardness of an associated discrete logarithm problem. A pairing based encryption and decryption as illustrated in as an example typically refers to encryption and decryption that uses keys that are generated based on aspects or characteristics of an algebraic curve. The exemplary cryptosystem of can be based on the curve being publically known but the points generated being secret as the points generated from the curve by the scalar are secret e.g. and difficult to determine . In one embodiment of the pairing based cryptography the curve may be an elliptic curve and the elements that comprise the group can be generated from points on the elliptic curve. As one of ordinary skill in the art may appreciate in a typical situation a point P is publicly known and a scalar m is secret. Then a point Q mP is made public as well. Because an associated discrete log problem is hard it is infeasible to determine m from P and Q. Accordingly the secrets are usually just the scalars and the points are public.

Pairing based cryptosystems can be used to encrypt a wide variety of information. For example a cryptosystem may be used to generate a short signature or product identifier which is a code that allows validation and or authentication of a machine program or user for example. The signature can be a short signature in that it uses a relatively small number of characters.

An output module of the encryptor outputs an encrypted version of the plaintext message which can be ciphertext . Ciphertext which may comprise a string of unintelligible text or some other data can then be communicated to the decryptor which can be implemented for example on a computer system remote from a computer system on which encryptor is implemented. Given the encrypted nature of ciphertext the communication link between the encryptor and the decryptor need not be secure e.g. it is often presumed that the communication link is not secure . As an example the communication link can be one of a wide variety of public and or private networks implemented using one or more of a wide variety of conventional public and or proprietary protocols and including both wired and wireless implementations. Additionally the communication link may include other non computer network components such as hand delivery of media including ciphertext or other components of a product distribution chain.

The decryptor receives the ciphertext at an input module and because the decryptor is aware of the secret key corresponding to the public key used to encrypt the message e.g. as well as the necessary generator can decrypt the ciphertext to recover the original plaintext message which is output by an output module as a plaintext message . In one embodiment the decryptor is a pairing based decryptor that decrypts the message based on the group of points generated from the elliptic curve e.g. a group as was used by encryptor and is discussed in more detail below.

In one embodiment the encryption and decryption are performed in the exemplary cryptosystem based on a secret which may be the scalar used to generate the public key an element of a group of points from the elliptic curve thereby allowing the solution to the problem to be difficult to determine. The secret is known to the decryptor and a public key can be generated based on the secret known to encryptor . In this embodiment this knowledge may allow the encryptor to encrypt a plaintext message that can be subsequently decrypted merely by the decryptor . Other components including the encryptor which do not have knowledge of the secret cannot decrypt the ciphertext e.g. although decryption may be technically possible it is not computationally feasible . Similarly in one embodiment the decryptor may also generate a message using the secret key based on a plaintext message a process referred to as digitally signing the plaintext message. In this embodiment the signed message can be communicated to other components such as the encryptor which can verify the digital signature based on the public key.

A product ID generator can generate a product ID that may include numbers letters and or other symbols. The generator generates a product ID using the pairing based encryption techniques and or systems described herein. The product ID may be printed on a label and affixed to either a carrier containing software media or a box into which software media is placed. Alternatively the product ID may be made available electronically such as a certificate provided to a user when receiving a softcopy of the application program via an on line source e.g. downloading of the software via the Internet . The product ID can serve multiple functions such as being cryptographically validated to verify that the product ID is a valid product ID e.g. thus allowing the application program to be installed . As a further example the product ID may serve to authenticate the particular software media to which it is associated.

The generated software media and associated product ID can be provided to a distribution chain . The distribution chain can represent one or more of a variety of conventional distribution systems and methods including possibly one or more middlemen e.g. wholesalers suppliers distributors retail stores either on line or brick and mortar etc. and or electronic distribution such as over the Internet. Regardless of the manner in which media and the associated product ID are distributed the media and product ID are typically purchased by e.g. licensed or distributed to the user of a client computer for example.

The client computer can include a media reader that is capable of reading the software media and installing an application program onto client computer e.g. installing the application program on to a hard disk drive or memory not shown of client computer . In one embodiment part of the installation process can involve entering the product ID e.g. to validate a licensed copy . This entry may be a manual entry e.g. the user typing in the product ID via a keyboard or alternatively an automatic entry e.g. computer automatically accessing a particular field of a license associated with the application program and extracting the product ID therefrom . The client computer can also include a product ID validator which validates during installation of the application program the product ID . In one embodiment the validation can be performed using the pairing based decryption techniques and or systems described herein. If the validator determines that the product ID is valid an appropriate course of action can be taken e.g. an installation program on software media allows the application to be installed on computer . However if the validator determines that the product ID is invalid a different course of action can be taken e.g. the installation program terminates the installation process preventing the application program from being installed .

In one embodiment the product ID validator can also optionally authenticate the software media e.g. application program based on the product ID . This authentication verifies that the product ID entered at computer corresponds to the particular copy of the application be accessed for example. As an example the authentication may be performed at different times such as during installation or when requesting product support or an upgrade. Alternatively in this embodiment the authentication may be performed at a remote location e.g. at a call center when the user of client computer calls for technical support the user may be required to provide the product ID before receiving assistance .

In one embodiment if an application program manufacturer desires to utilize the authentication capabilities of the product ID the product ID generated by generator for each copy of an application program can be unique. As an example unique product IDs can be created by assigning a different initial number or value to each copy of the application program e.g. this initial value is then used as a basis for generating the product ID . The unique value associated with the copy of the application program can be optionally maintained by the manufacturer as an authentication record e.g. a database or list along with an indication of the particular copy of the application program. The indication of the copy can be for example a serial number embedded in the application program or on software media and may be hidden in any of a wide variety of conventional manners. Alternatively for example the individual number itself may be a serial number that is associated with the particular copy thereby allowing the manufacturer to verify the authenticity of an application program by extracting the initial value from the product ID and verifying that it is the same as the serial number embedded in the application program or software media .

A method can be devised that allows a mathematical pairing to be determined for a curve where a first set of elements submitted as a cryptographic key e.g. points on an elliptic curve can be compared with known points on the curve and used for cryptographic purposes. Effective cryptosystems are typically based on groups where the Discrete Logarithm Problem DLP for the group is hard e.g. difficult to calculate such as a group of points from the elliptic curve. The DLP can be formulated in a group which is a collection of elements together with a binary operation such as a group multiplication. As an illustrative example the DLP may be given an element g in a finite group G and another element h that is an element of G find an integer x such that g h. Generating pairings for use in cryptography typically requires a lot of underlying multiplications in a finite field over which the elliptic curve is defined.

In one embodiment in the finite field for the curve both multiplications and inversions e.g. identifying multiplicative inverses or reciprocals are performed for the pairing operation. Inversions are typically more computationally expensive to perform than the multiplications. For example an inversion to multiplication ratio for computations can often be eighty to one as a coordinate system used for the curve points is commonly changed from affine to projective in order to reduce a number of inversions. As an illustrative example of an inversion determination to approximate a multiplicative inverse of a nonzero real number x a number y can be repeatedly replaced with 2y xy. In this example when changes to y remain within a threshold y is an approximation of the multiplicative inverse of x. It will be appreciated that this example is merely for illustration purposes and that there are other techniques for determining inversions particularly for other types of numbers such as complex numbers.

In the exemplary method for example while working in the affine coordinate system a number of inversions can be greatly mitigated by combining the inversions and determining them at a same time. In one embodiment when using affine coordinates for the pairing computation respective doubling e.g. multiplication and addition acts use a finite field inversion to compute a slope value for a line that is evaluated in a subsequent act. In this embodiment the inversions can be aggregated for example using Montgomery s trick to replace I finite field inversions by a single inversion and 3 I 1 multiplications.

As an illustrative example of Montgomery s trick in order to determine inversions for elements x and y instead of determining two inversions the product xy can be determined and its inverse computed. In this example the inverse of x and y can then be determined by the multiplications x xy y and y xy x. In this way in this example the inversions of the two elements x and y can be determined by one inversion and three multiplications. Where inversions are to be determined for n elements merely one inversion and 3 n 1 multiplications can be performed. Therefore in one embodiment where the pairing computation comprises a plurality of inversions n the n inversions can be aggregated into one inversion.

In one embodiment let a . . . a be a sequence of elements of which reciprocals a . . . a are to be computed. The reciprocals can be computed by first computing a product a. . . a its reciprocal a. . . a the products aaafor 1 i s and the reciprocals of single elements by . The acts can be performed in 1 inversion and 3 s 1 multiplications. That is s inversions can be replaced by 1 inversion and 3 s 1 multiplications.

In one embodiment the product aa. . . acan be computed in a binary tree with s 1 multiplications for example where the s 1 products can be stored for use in the inversion aggregation. Further in this embodiment the reciprocals aa. . . a are computed and subsequent reciprocals are computed along a same tree with 2 s 1 multiplications.

Returning to the exemplary method of at the mathematical pairings are determined for the curve in affine coordinates along a binary representation of a scalar read from right to left using the aggregated inversions. When computing a Tate pairing for a curve a typical Miller loop algorithm goes through the scalar from left to right or from top down . As an illustrative example assume that k 1 so that denominators in a Miller algorithm are eliminated.

For the following exemplary embodiment and illustrative examples utilize the following notations Let p 3 be a prime and Fbe a finite field of characteristic p. Let E be an elliptic curve defined over Fhaving a Weierstrass equation E y 2 x 3 ax b. For a prime r with r E F let k be an embedding degree of E with respect to r i.e. k is a smallest positive integer with r q k 1. A set of r torsion points on E can be denoted by E r and a set of F  q i rational r torsion points by E F  q i r for i 0. Let  q be a q power Frobenius endomorphism on E.

Further define 1 ker 1 2 ker   Let k 1. A reduced Tate pairing is a map 123   1 where f  r P F q E is a function with divisor r P r O . Denote the function in F q E given by a line through two points R and S on E by I  R S . If R S then the line is given by the tangent to the curve passing through R.

The following illustrates one embodiment of a typical Miller loop for computing a Tate pairing using the above notations 

In this illustrative example Lines 3 and 4 in the above algorithm together are commonly called a doubling act and Lines 6 and 7 are commonly called an addition act.

In one embodiment of the act of the exemplary method the Miller loop algorithm can be modified where the binary representations are read from right to left or bottom up . The following is an illustrative example of the right to left or bottom up approach 

In this illustrative example the doubling act is in Lines 8 and 9 and the addition act in Lines 5 and 6. The above algorithm does m doubling acts and h addition acts. In this example although the loop can be done m times merely m 1 doubling acts are used a last one may not influence the computation.

Further in this embodiment when using the bottom up approach the addition acts can be postponed in line 5 and 6 in the bottom up algorithm above . Here for example pairs of relevant function values and corresponding points f R can be stored in a list L e.g. in a database and a computation of a final function value can be computed later. As an illustrative example the following algorithm provides a bottom up approach with postponement of the addition acts by storing the values and points see Line 5 of the following algorithm and carries out the computation of the final function value later see Line 10 

In one embodiment using the aggregated inversions line 10 of the above algorithm Compute f Q from the pairs in L can also be carried out along a binary tree. In this embodiment in each layer of the binary tree the aggregated inversion technique can be applied. In this way for example as described above h 1 inversions can be substituted for log h inversions and 3 h 1 log h multiplications when computing mathematical pairings for the curve. Therefore the number of inversions is dramatically reduced while a small number of multiplications are added which are computationally cheaper.

At a multiple of a curve point is determined by computing a scalar multiple of a curve point where the scalar multiple for example is a m fold sum of the curve point in affine space. That is for example the multiplication acts of the bottom up approach algorithm can be performed a plurality of curve point multiples can be determined. This act is often called the doubling act for example where for i 0 i m 1 i do . . . f f l Q and R 2 R using the above described notations . Notably in this embodiment the multiplication is performed on the coordinates in affine space unlike current commonly used techniques that switch the coordinates to projective space in order to mitigate a number of inversions for example.

At the inversions of the additions of the curve point can be determined for the finite field. That is for example while reading the scalar from right to left curve points are added depending on the binary representation of the scalar. In this example for the curve point additions inversions are determined in the finite field. As an example an inversion is often referred to as a multiplicative inverse or a reciprocal. As described above the inversions are aggregated for example into a single inversion for respective acts in the additive process. In this way a plurality of inversions are combined at respective levels in the binary tree representation of the pairing portion of the algorithm for example merely using one inversion for respective levels.

At an output of the aggregated inversion is determined for example as a slope value for a line function and the line function is updated with the outputted slope value. For example when computing pairings for elements e.g. curve points for a curve over a finite field line functions are evaluated to compute the pairings such as to a new element in a different group. As such in this example the aggregated inversion output is used as the slope value for the line function for example at respective levels of the binary tree representation and the line is evaluated with the slope value to determine the pairings.

At multiples of the curve points submitted as elements of the group are determined as described above. In this embodiment binary representations of the scalar read from right to left are used to determine the multiples of the curve point. The inversions are aggregated from the multiples at into a single inversion and are stored such as in a remote or local database. In one embodiment the scalar which is read from right to left in a binary representation may be comprised in a cryptographic key such as a public key.

In one embodiment the determining of pairings for the curve in affine coordinates along a binary representation of a scalar read from right to left can be parallelized on a plurality of processors at . For example computers commonly have multi core processors which may allow the computations to be parallelized on more than one core in order to speed up the computation and free resources. In one embodiment the parallelization may comprise two or more instances for the determination of the multiples of the curve point on two or more processors for example at a same time.

At an output for the aggregated inversions is retrieved for example as a slope value. As described above an aggregated inversion may be used at respective levels in a binary tree representation of the additive act in the pairings computations. Further in one embodiment the stored aggregated inversions may be reused in a subsequent pairing computation of a set of coordinates in affine space. As an example the aggregated inversions can be retrieved from the remote or local database and reused. In this way a number of computations can be mitigated by reducing the inversion aggregation act.

In one embodiment the aggregated inversion may be reused when a first curve point that was used in determining the aggregated inversions is a same element as a second curve point for which the aggregated inversions are reused. That is the aggregated inversions can be determined using a curve point submitted as an element in the pairings computation. In this embodiment if a second set of elements submitted after the first set is computed and the second set comprises an element that is the same as the element from the first set the aggregated inversions may be reused in computing the pairings for the second set of elements for example.

At the line function is updated using the aggregated inversions output as a slope value. In one embodiment the output of the aggregated inversions may be used to update a coefficient in the function of the line used for the pairing computation. At the pairings can be determined for the elements for example by evaluating the updated line function resulting in a mathematical pairing for the encrypted signature authorization element and a mathematical pairing for the secret elements .

At the respective pairings can be compared to determine whether they are equal for example to determine authenticity of the submitted electronic signature. In this embodiment if the elements are found not to be equal at or they are not from the same group the submitted signature is not authenticated at . If the elements are found to be equal at and from the same group the submitted signature is authenticated at . In this way for example the computation of the pairings for elements can be used for cryptographic purposes and the one or more techniques described herein may be used to facilitate a more efficient and faster pairing computation.

One or more systems may be devised for determining mathematical pairings for a curve in order to compare submitted elements for cryptographic purposes for example. Because the computation of pairings for use in cryptography can require a lot of underlying multiplications and inversions in a finite field over which the elliptic curve is defined the one or more systems described herein can be devised to mitigate the time and resources used to compute these pairings. is a component block diagram illustrating an exemplary system for determining mathematical pairings for a curve for use in cryptography.

The exemplary system comprises an inversion aggregation component which aggregates inversions that are used to determine the mathematical pairings for the curve. The inversion aggregation component is operably coupled with one or more programmed processors which reside in one or more computing devices and with a data storage component that can store one or more of the aggregated inversions . Further in the exemplary system a mathematical pairings determination component is operably coupled with the data storage component and can determine the mathematical pairings for the curve in affine coordinates along a binary representation of a scalar read from right to left using the aggregated inversions stored thereon.

In one embodiment the inversion aggregation component pairings determination component and data storage component may be comprised in a same computing device such as the computing device that comprises the one or more processors . Alternatively the components of the system may be disposed on different devices or in some combination thereof.

In one embodiment the inversion aggregation component can be configured to aggregate the plurality of inversions into a single inversion for use in the mathematical pairing determination. For example respective inversions for a level of a binary representation of multiples of the curve point can be combined by the inversion aggregation component into a single inversion for that level. In this example the combined aggregated inversion e.g. can be stored in the data storage component and used by the pairings determination component for computing pairings.

In this exemplary embodiment an input component such as a component that can read an incoming document that uses cryptographic authentication receives a document that comprises cryptographic elements and a public key . As an example the document may be an encrypted document that is being submitted to a decryptor e.g. in order to be read the cryptographic elements are points on a curve e.g. group elements comprised from the group if the document is authentic and a scalar used in the computation of the pairings. The public key is usually a point on the curve while the secret key is a scalar.

In this embodiment the pairing on an elliptic curve based determiner can determine a pairing for the submitted cryptographic elements and for elements from the private key to determine whether the submitted document is authentic for example. That is if the document is authentic for example the cryptographic elements will match to the same element as those from the private key when pairings are computed for each using the scalar from the public key . In this way the cryptographic system can output an authentication for the document for example in order for the document to be decrypted for viewing.

Further in the exemplary embodiment the mathematical pairings determination component can be configured to reuse the aggregated plurality of inversions such as where a first curve point that was used in determining the aggregated plurality of inversions is a same element as a second curve point for which the aggregated inversions are reused. In this embodiment an inversion reuse determination component can determine whether the second curve point is the same element as the first curve point such as by comparing a stored version of the first curve point to a second one received . Additionally the inversion reuse determination component can retrieve the aggregated inversions from the data storage component that correspond to the first curve point. In this way the retrieved inversions can be reused by the pairing determination component for example instead of computing new aggregated inversions.

Still another embodiment involves a computer readable medium comprising processor executable instructions configured to implement one or more of the techniques presented herein. An exemplary computer readable medium that may be devised in these ways is illustrated in wherein the implementation comprises a computer readable medium e.g. a CD R DVD R or a platter of a hard disk drive on which is encoded computer readable data . This computer readable data in turn comprises a set of computer instructions configured to operate according to one or more of the principles set forth herein. In one such embodiment the processor executable instructions may be configured to perform a method such as the exemplary method of for example. In another such embodiment the processor executable instructions may be configured to implement a system such as the exemplary system of for example. Many such computer readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 1394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Various operations of embodiments are provided herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein.

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

