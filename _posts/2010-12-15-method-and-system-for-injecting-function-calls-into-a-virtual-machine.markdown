---

title: Method and system for injecting function calls into a virtual machine
abstract: A method and apparatus for injecting function calls into a virtual machine whereby a Function Call Injection (FCI) process is employed, through which a Secure Virtual Machine (SVM) is used to trigger desired function call invocations inside a Guest Virtual Machine (GVM) by externally manipulating the GVMs memory and CPU register contents using a security API. Once the triggered function is executed, control is then returned at the originating SVM invocation point. Therefore, the GVM state is manipulated to externally inject function calls, making it possible to create control appliances which do not require an in-GVM agent.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09003402&OS=09003402&RS=09003402
owner: Symantec Corporation
number: 09003402
owner_city: Mountain View
owner_country: US
publication_date: 20101215
---
Current computing systems and computing system architectures often employ a host computing system implementing one or more virtual machines or Guest Virtual Machines GVMs . In a typical implementation of this host and GVM architecture the host computing system is the physical hardware system and each of the GVMs is a virtual entity created in memory associated with the host computing system. However in many cases each GVM behaves for all practical purposes as an independent virtual computing system that in many cases is capable of implementing running its own copy of applications and in some cases its own operating system. Each GVM also typically has allocated its own memory and controls its own threads and associated memory stacks.

In some implementations of these host and GVM architectures a special application called a hypervisor is employed through which each of the GVMs is implemented and controlled. Typically the hypervisor controls various GVM operations and the use and access of various hardware systems associated with the host computing system such as but not limited to keyboards mice various other input and output systems data storage devices and any other physical hardware systems associated with the host computing system.

In addition to the hypervisor some host and GVM architectures include a special virtual machine called a Secure Virtual Machine SVM . While the SVM is itself a virtual machine run on the host system unlike a typical GVM the SVM is aware of the fact it is operating in a multiple GVM environment and is provided with special access and control privileges with respect to the other virtual machines such as the ability to access the other virtual machines i.e. the GVMs and their associated memory. In many cases the SVM is provided its privileged access to the other GVMs via a hypercall interface or security Application Program Interface security API that allows communication between the hypervisor and SVM and therefore often acts as an extension to the hypervisor.

One example of a currently available security API is VMsafe available from VMware Inc. of Palo Alto Calif. SVMs and security APIs typically provide a mechanism for changes to be made to and interactions to be conducted with individual GVMs without making changes to the hypervisor. This is generally desirable because changes to the hypervisor are often difficult and or present a security risk. In addition it is highly desirable to keep the hypervisor as simple clean as possible.

One way in which SVMs and security APIs are currently used is to inspect control the access of new unknown memory pages by the individual GVMs. For instance in some implementations when a given GVM page handler determines that a desired page of memory is not present the new page of memory is requested. The GVM state is then suspended and the new page of memory is then trapped and sent to the SVM for inspection security analysis prior to resumption of the GVM and use by the GVM.

Traditionally interactions with a virtual machine i.e. a GVM have required the presence of a software agent running in on the GVM. An agent is typically a program or other code responsible for receiving commands often via a network and translating them into actions such as operating system OS API function calls. Traditionally the agent must be either pre installed in the individual GVMs or dynamically injected into the GVMs. However agents are often undesirable particularly in cases where security and transparency are important requirements or when the memory footprint created by the presence of the agent is not acceptable.

Despite the problems described above currently there is no general and or OS independent technique for allowing external control of a virtual machine i.e. a GVM without the use of an in GVM agent.

In addition one disadvantage to the use of SVMs and the current host GVM architecture is that as noted above each GVM can be implementing its own applications and Operating System OS or versions of a given application or OS and while the SVM may have access to the GVMs memory the SVM does not know what application or OS or version of a given application or OS is being implemented by the GVM. Therefore the SVM often does not know the structural content or context of the data it can access. This results in what is termed a semantic gap whereby the SVM is unable to interpret the internal state of GVMs despite having full access to that state.

As noted above there is currently no general and OS independent technique for allowing external control of a virtual machine i.e. a GVM without the use of an in GVM agent.

In accordance with one embodiment a method and system for injecting function calls into a virtual machine includes a Function Call Injection FCI process through which a Secure Virtual Machine SVM is used to trigger desired function call invocations inside a Guest Virtual Machine GVM by externally manipulating the GVMs memory and CPU register contents using a security API. In one embodiment once the triggered function call is executed control is then returned at the originating SVM invocation point. Therefore in one embodiment the GVM state is manipulated to externally inject function calls making it possible to create control appliances which do not require an in GVM agent.

Using the method and system for injecting function calls into a virtual machine discussed herein function call invocations are triggered inside a GVM without the use or need for in GVM agents. In addition since using the method and system for injecting function calls into a virtual machine discussed herein the GVM s stack is manipulated by SVM the GVM s OS is used to create the desired function calls. Consequently the method and system for injecting function calls into a virtual machine discussed herein is a general and OS independent solution that largely avoids the semantic gap problem.

Common reference numerals are used throughout the FIG.s and the detailed description to indicate like elements. One skilled in the art will readily recognize that the above FIG.s are examples and that other architectures modes of operation orders of operation and elements functions can be provided and implemented without departing from the characteristics and features of the invention as set forth in the claims.

Embodiments will now be discussed with reference to the accompanying FIG.s which depict one or more exemplary embodiments. The following description includes reference to specific embodiments for illustrative purposes. However the illustrative discussion below is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the teachings below. The embodiments discussed below were chosen and described in order to explain the principles of the invention and its practical applications to thereby enable others skilled in the art to utilize the invention and various embodiments with various modifications as may be suited to the particular use contemplated. Therefore embodiments may be embodied in many different forms other than those shown and discussed herein and should not be construed as limited to the embodiments set forth herein shown in the FIG.s and or described below.

According to one embodiment a method and system for injecting function calls into a virtual machine includes a process for Function Call Injection FCI whereby a host virtual machine is provided that includes at least one Guest Virtual Machine GVM and at least one Secure Virtual Machine SVM . In one embodiment a hypervisor is provided. In one embodiment a security Application Program Interface security API is provided that acts as an interface between the hypervisor and SVM and therefore operates as an extension to the hypervisor.

In one embodiment a SVM invocation point is defined found such that when the SVM invocation point is reached the GVM is placed in a suspended state. In one embodiment the SVM invocation point is reached and the GVM is placed in a suspended state. In one embodiment the state of the GVM at the SVM invocation point is then saved.

In one embodiment while the GVM is in the suspended state the SVM is provided access to the GVM using the security API also referred to herein as virtual machine introspection. In one embodiment the SVM then modifies the contents of key CPU registers and the contents of the current thread stack associated with the GVM. In one embodiment a FCI return address is added.

In one embodiment the GVM is released from the suspended state and resumed. In one embodiment when the GVM resumes the GVM executes the function call just as if it had been invoked from GVM code. In one embodiment when the FCI return address occurs the GVM is placed in a suspended state and then restored to the saved GVM state of the SVM invocation point.

More specifically in one embodiment a hypervisor enabled execution breakpoint is generated that requires no modifications inside the GVM. In one embodiment the hypervisor enabled execution breakpoint is placed inserted at a pre selected GVM code location such that whenever that code is executed a trap to the SVM occurs and the GVM is placed in a suspended state.

In one embodiment once trapped the SVM initially saves the context of the interrupted GVM thread at the hypervisor enabled execution breakpoint. The SVM then sets the GVM s instruction pointer i.e. in 32 bit architectures the Extended Instruction Pointer EIP register program counter in the x86 architecture to the address of a desired function.

In one embodiment the stack pointer i.e. the Extended Stack Pointer ESP in a 32 bit architecture is then subtracted so that room can be made in the stack for the arguments passed to the desired function and the return address. In a Windows environment the location of the desired function can be determined by parsing the binary s in memory symbol table once the base address is known. With other operating systems different techniques may be used.

In one embodiment e.g. in an Intel x 86 architecture arguments to be passed to the desired function are copied to the stack in reverse order. In some embodiments arguments to be passed to the desired function whose corresponding parameter is defined as call by values are directly copied to the stack. In some embodiments in the case of call by reference arguments a pointer pointing to the actual data is placed on the stack.

In some embodiments the actual data can also be on the stack or in a dedicated memory page used for call by reference arguments e.g. strings or file buffers . In one embodiment before such a page is allocated in one embodiment by injecting a memory allocation function call the stack technique is used to store call by reference arguments.

In one embodiment a FCI return address is inserted and the FCI return address is initially set to a special location in the active code segment that has no actual code e.g. a special location that is either known to be empty or is known to be typically used for padding purposes. In one embodiment a hypervisor enabled execution breakpoint is placed on this memory location and the return address of the desired function call is set to this hypervisor enabled execution breakpoint. Consequently when the desired function finishes executing the final Return RET instruction will transfer control to this special location suspending the GVM and trapping into the SVM. In one embodiment empty or pad space is identified. In one embodiment at a later stage just as with the arguments a dedicated page is allocated for the sole purpose of acting as a trapping destination for return instructions in the identified empty or pad space.

In one embodiment after reassuming control the SVM retrieves the desired function s scalar result in one embodiment by reading the value stored in the EAX register and retrieves other additional output parameters of the desired function directly from the GVM s memory.

In one embodiment the SVM releases the GVM and the GVM resumes and makes the desired function call. The GVM is then suspended when the FCI return address is reached and the SVM then restores the saved GVM state at the SVM invocation point. The GVM then resumes its execution from the point at which it was interrupted.

The process for Function Call Injection discussed herein can be applied in user or kernel mode to invoke system level API functions without the need for an in guest agent to be present. In addition since the process for Function Call Injection only manipulates the GVM s virtual hardware state it is generic enough to be used with different operating systems although as those of skill in the art will recognize the invoked routines may be somewhat different.

In addition by invoking GVM routines instead of trying to directly interpret its memory contents the process for Function Call Injection discussed herein reduces the semantic gap problem as it relies on the GVM s own code that naturally navigates and interprets the state of the GVM.

As used herein the term computing system such as is included in the term host computing system includes but is not limited to a portable computer a workstation a two way pager a cellular telephone a smart phone a digital wireless telephone a Personal Digital Assistant PDA a media player i.e. an MP3 player and or other music and or video player a server computer an Internet appliance or any other device that includes components that can execute all or part of any one of the processes and or operations as described herein. In addition as used herein the term computing system can denote but is not limited to computing systems made up of multiple computers wireless devices cellular telephones digital telephones two way pagers PDAs media players server computers or any desired combination of these devices that are coupled to perform the processes and or operations as described herein.

In various embodiments host computing system is any computing system as defined herein and or as known in the art at the time of filing and or as developed thereafter that includes components that can execute all or part of a process for injecting function calls into a virtual machine in accordance with at least one of the embodiments as described herein.

As also seen in in one embodiment host computing system includes host memory and Guest Virtual Machines GVMs and implemented in and or associated with host computing system and host computing system memory . As discussed above current computing systems and computing system architectures often employ a host computing system such as host computing system implementing one or more virtual machines or Guest Virtual Machines GVMs such as are represented by GVMs and . It should be noted that while two GVMs are shown in for illustrative purposes host computing system can implement more of fewer GVMs and GVMs and are therefore representative of any number of GVMs.

In a typical implementation of host and GVM architecture the host computing system is the physical hardware system and each of the GVMs is a virtual entity created in memory associated with the host computing system. However in many cases each GVM behaves for all practical purposes as an independent virtual computing system that in many cases is capable of implementing running its own copy of applications and in some cases its own operating system. Each GVM also typically has allocated its own memory such as GVM memories A and or A of and controls its own threads and associated memory stacks such as GVM stack of discussed below.

The creation implementation operation and use of GVMs and host computing system GVM architectures are well known to those of skill in the art. Consequently a more detailed discussion of specific examples of the creation implementation operation and use of GVMs and host computing system GVM architectures is omitted here to avoid detracting from the invention.

In one embodiment SVM is itself a virtual machine run on host computing system . However unlike a typical GVM such as GVMs and SVM is aware of the fact it is operating in a multiple GVM environment and is provided with special access and control privileges with respect to the other virtual machines such as the ability to access the other virtual machines i.e. GVMs and and their associated memory such as GVM memories A and A.

The creation implementation operation and use of SVMs and host computing system GVM architectures are well known to those of skill in the art. Consequently a more detailed discussion of specific examples of the creation implementation operation and use of SVMs and host computing system GVM architectures is omitted here to avoid detracting from the invention.

Also shown in is hypervisor implemented on and or associated with host computing system and host memory . In one embodiment each of GVMs and or is accessed controlled and or manipulated via hypervisor . In one embodiment hypervisor controls various GVM and operations and the use and access of various hardware systems associated with host computing system such as but not limited to keyboards such as keyboard mice such as mouse various other input and output systems data storage devices such as Data and any other physical hardware systems associated with the host computing system.

The creation implementation operation and use of hypervisors and host computing system GVM architectures are well known to those of skill in the art. Consequently a more detailed discussion of specific examples of the creation implementation operation and use of hypervisors and host computing system GVM architectures is omitted here to avoid detracting from the invention.

Also shown in is security API as implemented in and or associated with host computing system and or SVM . In one embodiment SVM is provided privileged access to the other GVMs and or via the hypercall interface provided by security API that allows communication between hypervisor and SVM and therefore allows SVM to act as an extension to hypervisor . One example of a currently available security API is VMsafe available from VMware Inc. of Palo Alto Calif.

As also noted above SVMs and security APIs typically provide a mechanism for changes to be made to and interactions to be conducted with individual GVMs without making changes to the hypervisor. This is generally desirable because changes to the hypervisor are often difficult and or present a security risk. In addition it is typically highly desirable to keep the hypervisor as simple clean as possible.

The creation implementation operation and use of security APIs is known to those of skill in the art. However absent various embodiments discussed herein security APIs have not been used to trigger desired function call invocations inside a Guest Virtual Machine GVM by externally manipulating the GVMs memory and CPU register contents thereby making it possible to create control appliances which do not require an in GVM agent.

On the contrary one way in which SVMs and security APIs are currently used is to inspect control the access of new unknown memory pages by the individual GVMs. For instance in some implementations when a given GVM page handler determines that a desired page of memory is not present the new page of memory is requested. The new page of memory is then trapped and sent to the SVM for inspection security analysis prior to use by the GVM.

As also noted above absent various embodiments discussed herein interactions with a virtual machine i.e. a GVM such as GVMs and of have required the presence of a software agent running in on the GVM. An agent is typically a program or other code responsible for receiving commands often via a network and translating them into actions such as operating system OS API function calls. Traditionally the agent must be either pre installed in the individual GVMs or dynamically injected into the GVMs. However agents are often undesirable particularly in cases where security and transparency are important requirements or when the memory footprint created by the presence of the agent is not acceptable.

Despite the problems described above absent various embodiments discussed herein there was no general and or OS independent technique for allowing external control of a virtual machine i.e. a GVM without the use of an in GVM agent.

In addition one historical disadvantage to the use of SVMs and the host GVM architecture absent various embodiments discussed herein is that as noted above each GVM can be implementing its own Operating System OS or version of a given OS and while the SVM may have access to the GVMs memory the SVM does not know what OS or version of a given OS is being implemented by the GVM and therefore the SVM often does not know the structural content or context of the data it can access. This results in what is termed a semantic gap whereby the SVM is unable to interpret the internal state of GVMs despite having full access to that state.

As discussed above due largely to the semantic gap problem absent various embodiments discussed herein there was no general and OS independent technique for allowing external control of a virtual machine i.e. a GVM such as GVMs and or of without the use of an in GVM agent.

In one embodiment operating system includes procedures data and or instructions for handling various services and performing coordinating hardware dependent tasks.

In one embodiment GVM stack is a memory stack associated with a given thread being processed by a CPU associated with GVM . As seen in GVM stack also includes registers and Extended Stack Pointer ESP .

As noted above the creation implementation operation and use of GVMs GVM memory and GVM stacks and host computing system GVM architectures is well known to those of skill in the art. Consequently a more detailed discussion of specific examples of the creation implementation operation and use of GVMs such as GVM of GVM memory such as GVM memory A of and GVM stacks such as GVM stack and ESP of and host computing system GVM architectures is omitted here to avoid detracting from the invention.

Those of skill in the art will readily recognize that the choice of components data modules and information shown in the organization of the components data modules and information shown in and the manner of storage and location of storage of the data modules and information shown in was made for illustrative purposes only and that other choices of components data modules and information organization of the components data modules and information manner of storing and location of storage of the data modules and information can be implemented without departing from the scope of the invention as set forth in the claims below. In particular the various modules and or data shown in are illustrative only and not limiting. In various other embodiments the particular modules and or data shown in can be grouped together in fewer modules and or data locations or divided among more modules and or data locations. Consequently those of skill in the art will recognize that other orders and or grouping are possible and the particular modules and or data order and or grouping shown in discussed herein do not limit the scope as claimed below.

A more detailed discussion of the operation of GVM and GVM memory A is provided below with respect to .

As seen in SVM memory A includes operating system that includes procedures data and or instructions for handling various services and performing coordinating hardware dependent tasks.

As also seen in SVM memory A includes process module that includes procedures data and or instructions for implementing at least part of a process for injecting function calls into a virtual machine such as exemplary process of discussed below.

As also seen in process module includes suspend state of GVM module that includes procedures data and or instructions for suspending the state of a GVM such as GVMs and or of .

As also seen in process module includes GVM modification module that includes procedures data and or instructions for modifying the CPU registers and or the contents of a GVM stack such as GVM stack of of GVMs such as GVM and or GVM of .

As also seen in process module includes GVM state restoration module that includes procedures data and or instructions for restoring the state of a GVM such as such as GVM and or GVM of

Those of skill in the art will readily recognize that the choice of components data modules and information shown in the organization of the components data modules and information shown in and the manner of storage and location of storage of the data modules and information shown in was made for illustrative purposes only and that other choices of components data modules and information organization of the components data modules and information manner of storing and location of storage of the data modules and information can be implemented without departing from the scope of the invention as set forth in the claims below. In particular the various modules and or data shown in are illustrative only and not limiting. In various other embodiments the particular modules and or data shown in can be grouped together in fewer modules and or data locations or divided among more modules and or data locations. Consequently those of skill in the art will recognize that other orders and or grouping are possible and the particular modules and or data order and or grouping shown in discussed herein do not limit the scope as claimed below.

In accordance with one embodiment a method and system for injecting function calls into a virtual machine includes a Function Call Injection FCI process through which a Secure Virtual Machine SVM is used to trigger desired function call invocations inside a Guest Virtual Machine GVM by externally manipulating the GVMs memory and CPU register contents using a security API. In one embodiment once the triggered function is executed control is then returned at the originating SVM invocation point. Therefore in one embodiment the GVM state is manipulated to externally inject function calls making it possible to create control appliances which do not require an in GVM agent.

Process for injecting function calls into a virtual machine begins at ENTER OPERATION and process flow proceeds to PROVIDE A HOST COMPUTING SYSTEM OPERATION .

In one embodiment at PROVIDE A HOST COMPUTING SYSTEM OPERATION a host computing system such as host computing system of is provided.

As used herein the term computing system such as is included in the term host computing system includes but is not limited to a portable computer a workstation a two way pager a cellular telephone a smart phone a digital wireless telephone a Personal Digital Assistant PDA a media player i.e. an MP3 player and or other music and or video player a server computer an Internet appliance or any other device that includes components that can execute all or part of any one of the processes and or operations as described herein. In addition as used herein the term computing system can denote but is not limited to computing systems made up of multiple computers wireless devices cellular telephones digital telephones two way pagers PDAs media players server computers or any desired combination of these devices that are coupled to perform the processes and or operations as described herein.

Returning to in various embodiments the host computing system provided at PROVIDE A HOST COMPUTING SYSTEM OPERATION is any computing system as defined herein and or as known in the art at the time of filing and or as developed thereafter that includes components that can execute all or part of a process for injecting function calls into a virtual machine in accordance with at least one of the embodiments as described herein.

In one embodiment once a host computing system is provided at PROVIDE A HOST COMPUTING SYSTEM OPERATION process flow proceeds to IMPLEMENT AT LEAST ONE GUEST VIRTUAL MACHINE GVM ON THE HOST COMPUTING SYSTEM OPERATION .

In one embodiment at IMPLEMENT AT LEAST ONE GUEST VIRTUAL MACHINE GVM ON THE HOST COMPUTING SYSTEM OPERATION at least one Guest Virtual Machine GVM is implemented in and or associated with the host computing system of PROVIDE A HOST COMPUTING SYSTEM OPERATION .

In one embodiment at IMPLEMENT AT LEAST ONE GUEST VIRTUAL MACHINE GVM ON THE HOST COMPUTING SYSTEM OPERATION at least one Guest Virtual Machine GVM such as GVM and or GVM of and is implemented in and or associated with a host computing system of PROVIDE A HOST COMPUTING SYSTEM OPERATION such as host computing system of .

Returning to as discussed above current computing systems and computing system architectures often employ a host computing system such as is provided at PROVIDE A HOST COMPUTING SYSTEM OPERATION implementing one or more virtual machines or Guest Virtual Machines GVMs . In a typical implementation of this host and GVM architecture the host computing system is the physical hardware system and each of the GVMs is a virtual entity created in memory associated with the host computing system. However in many cases each GVM behaves for all practical purposes as an independent virtual computing system that in many cases is capable of implementing running its own copy of applications and in some cases its own operating system. Each GVM also typically has allocated its own memory such as GVM memories A and or A of and controls its own threads and associated memory stacks such as GVM stack of .

The creation implementation operation and use of GVMs and host computing system GVM architectures are well known to those of skill in the art. Consequently a more detailed discussion of specific examples of the creation implementation operation and use of GVMs and host computing system GVM architectures is omitted here to avoid detracting from the invention.

Returning to in one embodiment once at least one Guest Virtual Machine GVM is implemented in and or associated with the host computing system of PROVIDE A HOST COMPUTING SYSTEM OPERATION at IMPLEMENT AT LEAST ONE GUEST VIRTUAL MACHINE GVM ON THE HOST COMPUTING SYSTEM OPERATION process flow proceeds to IMPLEMENT AT LEAST ONE SECURITY VIRTUAL MACHINE SVM ON THE HOST COMPUTING SYSTEM OPERATION .

In one embodiment at IMPLEMENT AT LEAST ONE SECURITY VIRTUAL MACHINE SVM ON THE HOST COMPUTING SYSTEM OPERATION at least one Security Virtual Machine SVM is implemented in and or associated with the host computing system of PROVIDE A HOST COMPUTING SYSTEM OPERATION .

In one embodiment at IMPLEMENT AT LEAST ONE SECURITY VIRTUAL MACHINE SVM ON THE HOST COMPUTING SYSTEM OPERATION at least one Secure Virtual Machine SVM such as SVM of and is implemented in and or associated with a host computing system of PROVIDE A HOST COMPUTING SYSTEM OPERATION such as host computing system of .

As noted above a Secure Virtual Machine SVM is itself a virtual machine run on the host system. However unlike a typical GVM such as GVMs and of the SVM is aware of the fact it is operating in a multiple GVM environment and is provided with special access and control privileges with respect to the other virtual machines such as the ability to access the other virtual machines i.e. GVMs and and their associated memory such as GVM memories A and A of .

Returning to the creation implementation operation and use of SVMs and host computing system GVM architectures is well known to those of skill in the art. Consequently a more detailed discussion of specific examples of the creation implementation operation and use of SVMs and host computing system GVM architectures is omitted here to avoid detracting from the invention.

In one embodiment once at least one Security Virtual Machine SVM is implemented in and or associated with the host computing system of PROVIDE A HOST COMPUTING SYSTEM OPERATION at IMPLEMENT AT LEAST ONE SECURITY VIRTUAL MACHINE SVM ON THE HOST COMPUTING SYSTEM OPERATION process flow proceeds to IMPLEMENT A HYPERVISOR ON THE HOST COMPUTING SYSTEM OPERATION .

In one embodiment at IMPLEMENT A HYPERVISOR ON THE HOST COMPUTING SYSTEM OPERATION a hypervisor is implemented on and or associated with the host computing system of PROVIDE A HOST COMPUTING SYSTEM OPERATION the GVMs of IMPLEMENT AT LEAST ONE GUEST VIRTUAL MACHINE GVM ON THE HOST COMPUTING SYSTEM OPERATION and or the SVM of IMPLEMENT AT LEAST ONE SECURITY VIRTUAL MACHINE SVM ON THE HOST COMPUTING SYSTEM OPERATION .

In one embodiment at IMPLEMENT A HYPERVISOR ON THE HOST COMPUTING SYSTEM OPERATION a hypervisor such as hypervisor of is implemented on and or associated with the host computing system of PROVIDE A HOST COMPUTING SYSTEM OPERATION such as host computing system of the GVMs of IMPLEMENT AT LEAST ONE GUEST VIRTUAL MACHINE GVM ON THE HOST COMPUTING SYSTEM OPERATION such as GVMs and or of and or the SVM of IMPLEMENT AT LEAST ONE SECURITY VIRTUAL MACHINE SVM ON THE HOST COMPUTING SYSTEM OPERATION such as SVM of .

As noted above in some implementations of host and GVM architectures a hypervisor is employed through which each of the GVMs is implemented and controlled. Typically the hypervisor controls various GVM operations and the use and access of various hardware systems associated with the host computing system such as but not limited to keyboards such as keyboard of mice such as mouse of various other input and output systems data storage devices such as Data of and any other physical hardware systems associated with the host computing system.

Returning to the creation implementation operation and use of hypervisors and host computing system GVM architectures is well known to those of skill in the art. Consequently a more detailed discussion of specific examples of the creation implementation operation and use of hypervisors and host computing system GVM architectures is omitted here to avoid detracting from the invention.

In one embodiment once a hypervisor is implemented on and or associated with the host computing system of PROVIDE A HOST COMPUTING SYSTEM OPERATION the GVMs of IMPLEMENT AT LEAST ONE GUEST VIRTUAL MACHINE GVM ON THE HOST COMPUTING SYSTEM OPERATION and or the SVM of IMPLEMENT AT LEAST ONE SECURITY VIRTUAL MACHINE SVM ON THE HOST COMPUTING SYSTEM OPERATION at IMPLEMENT A HYPERVISOR ON THE HOST COMPUTING SYSTEM OPERATION process flow proceeds to PROVIDE A SECURITY API AS AN INTERFACE BETWEEN THE HYPERVISOR AND THE SVM OPERATION .

In one embodiment at PROVIDE A SECURITY API AS AN INTERFACE BETWEEN THE HYPERVISOR AND THE SVM OPERATION a security API is implemented in and or associated with the host computing system of PROVIDE A HOST COMPUTING SYSTEM OPERATION the GVMs of IMPLEMENT AT LEAST ONE GUEST VIRTUAL MACHINE GVM ON THE HOST COMPUTING SYSTEM OPERATION the hypervisor of IMPLEMENT A HYPERVISOR ON THE HOST COMPUTING SYSTEM OPERATION and or the SVM of IMPLEMENT AT LEAST ONE SECURITY VIRTUAL MACHINE SVM ON THE HOST COMPUTING SYSTEM OPERATION .

As noted above in addition to the GVMs of IMPLEMENT AT LEAST ONE GUEST VIRTUAL MACHINE GVM ON THE HOST COMPUTING SYSTEM OPERATION the hypervisor of IMPLEMENT A HYPERVISOR ON THE HOST COMPUTING SYSTEM OPERATION and the SVM of IMPLEMENT AT LEAST ONE SECURITY VIRTUAL MACHINE SVM ON THE HOST COMPUTING SYSTEM OPERATION the SVM is provided privileged access to the other GVMs via a hypercall interface or security Application Program Interface security API that allows communication between the hypervisor and SVM and therefore often acts as an extension to the hypervisor.

One example of a currently available security API such as is provided at PROVIDE A SECURITY API AS AN INTERFACE BETWEEN THE HYPERVISOR AND THE SVM OPERATION is VMsafe available from VMware Inc. of Palo Alto Calif.

As also noted above SVMs and security APIs typically provide a mechanism for changes to be made to and interactions to be conducted with individual GVMs without making changes to the hypervisor. This is generally desirable because changes to the hypervisor are often difficult and or present a security risk. In addition it is typically highly desirable to keep the hypervisor as simple clean as possible.

The creation implementation operation and use of security APIs is known to those of skill in the art. However absent various embodiments discussed herein security APIs have not been used to trigger desired function call invocations inside a Guest Virtual Machine GVM by externally manipulating the GVMs memory and CPU register contents thereby making it possible to create control appliances which do not require an in GVM agent.

On the contrary one way in which SVMs and security APIs are currently used is to inspect control the access of new unknown memory pages by the individual GVMs. For instance in some implementations when a given GVM page handler determines that a desired page of memory is not present the new page of memory is requested. The new page of memory is then trapped and sent to the SVM for inspection security analysis prior to use by the GVM.

As also noted above absent various embodiments discussed herein interactions with a virtual machine i.e. a GVM such as GVMs and of have required the presence of a software agent running in on the GVM. An agent is typically a program or other code responsible for receiving commands often via a network and translating them into actions such as operating system OS API function calls. Traditionally the agent must be either pre installed in the individual GVMs or dynamically injected into the GVMs. However agents are often undesirable particularly in cases where security and transparency are important requirements or when the memory footprint created by the presence of the agent is not acceptable.

Despite the problems described above absent various embodiments discussed herein there was no general and or OS independent technique for allowing external control of a virtual machine i.e. a GVM without the use of an in GVM agent.

In addition one historical disadvantage to the use of SVMs and the host GVM architecture absent various embodiments discussed herein is that as noted above each GVM can be implementing its own Operating System OS or version of a given OS and while the SVM may have access to the GVMs memory the SVM does not know what OS or version of a given OS is being implemented by the GVM and therefore the SVM often does not know the structural content or context of the data it can access. This results in what is termed a semantic gap whereby the SVM is unable to interpret the internal state of GVMs despite having full access to that state.

As discussed above due in large part to the semantic gap problem absent various embodiments discussed herein there was no general and OS independent technique for allowing external control of a virtual machine i.e. a GVM such as GVMs and or of without the use of an in GVM agent.

Returning to once a security API is implemented in and or associated with the host computing system of PROVIDE A HOST COMPUTING SYSTEM OPERATION the GVMs of IMPLEMENT AT LEAST ONE GUEST VIRTUAL MACHINE GVM ON THE HOST COMPUTING SYSTEM OPERATION the hypervisor of IMPLEMENT A HYPERVISOR ON THE HOST COMPUTING SYSTEM OPERATION and or the SVM of IMPLEMENT AT LEAST ONE SECURITY VIRTUAL MACHINE SVM ON THE HOST COMPUTING SYSTEM OPERATION at PROVIDE A SECURITY API AS AN INTERFACE BETWEEN THE HYPERVISOR AND THE SVM OPERATION process flow proceeds to FIND DEFINE A SVM INVOCATION POINT OPERATION .

In one embodiment at FIND DEFINE A SVM INVOCATION POINT OPERATION a SVM invocation point is defined found such that when the SVM invocation point is reached the GVM is placed in a suspended state.

In one embodiment at FIND DEFINE A SVM INVOCATION POINT OPERATION a hypervisor enabled execution breakpoint is generated that requires no modifications inside the GVM.

In one embodiment at FIND DEFINE A SVM INVOCATION POINT OPERATION the hypervisor enabled execution breakpoint is placed inserted at a pre selected GVM code location such that whenever that code is executed a trap to the SVM occurs and the GVM is placed in a suspended state.

Numerous means methods procedures processes and mechanisms for finding defining a SVM invocation point such that when the SVM invocation point is reached the GVM is placed in a suspended state are known in the art. Consequently a more detailed discussion of means methods procedures processes and mechanisms for finding defining a SVM invocation point such that when the SVM invocation point is reached the GVM is placed in a suspended state are omitted here to avoid detracting from the invention.

In one embodiment once a SVM invocation point is defined found such that when the SVM invocation point is reached the GVM is placed in a suspended state at FIND DEFINE A SVM INVOCATION POINT OPERATION process flow proceeds to SUSPEND THE STATE OF A FIRST GVM WHEN SVM INVOCATION POINT IS REACHED OPERATION .

In one embodiment at SUSPEND THE STATE OF A FIRST GVM WHEN SVM INVOCATION POINT IS REACHED OPERATION the state of a given or first GVM is suspended.

In one embodiment at SUSPEND THE STATE OF A FIRST GVM WHEN SVM INVOCATION POINT IS REACHED OPERATION the state of a given or first GVM such as GVM of is suspended.

As discussed in more detail below in one embodiment using the security API the SVM is provided access to the GVM while the GVM is in a suspended state also referred to herein as virtual machine introspection. In one embodiment the SVM then uses the security API to modify the contents of key CPU registers and the contents of the current stack associated with the GVM prior to releasing the GVM from the suspended state and resuming the GVM. When it resumes the GVM executes a function call just as if it had been invoked from GVM code.

Numerous means methods procedures processes and mechanisms to suspend the state of a GVM are known to those of skill in the art. Consequently a more detailed discussion of specific means methods procedures processes and mechanisms used to suspend the state of a GVM at SUSPEND THE STATE OF A FIRST GVM WHEN SVM INVOCATION POINT IS REACHED OPERATION is omitted here to avoid detracting from the invention.

In one embodiment once the state of a given or first GVM such as GVM of is suspended at SUSPEND THE STATE OF A FIRST GVM WHEN SVM INVOCATION POINT IS REACHED OPERATION process flow proceeds to SAVE THE FIRST GVM STATE AT THE SVM INVOCATION POINT OPERATION .

In one embodiment at SAVE THE FIRST GVM STATE AT THE SVM INVOCATION POINT OPERATION the state of the GVM at the SVM invocation point of SUSPEND THE STATE OF A FIRST GVM WHEN SVM INVOCATION POINT IS REACHED OPERATION is saved.

Numerous means methods procedures processes and mechanisms for saving the state of a GVM are known to those of skill in the art. Consequently a more detailed discussion of specific means methods procedures processes and mechanisms used to save the state of a GVM at SAVE THE FIRST GVM STATE AT THE SVM INVOCATION POINT OPERATION is omitted here to avoid detracting from the invention.

In one embodiment once the state of the GVM at the SVM invocation point of SUSPEND THE STATE OF A FIRST GVM WHEN SVM INVOCATION POINT IS REACHED OPERATION is saved at SAVE THE FIRST GVM STATE AT THE SVM INVOCATION POINT OPERATION process flow proceeds to USE THE SVM AND SECURITY API TO MODIFY CPU REGISTERS AND OR THE CONTENTS OF A CURRENT THREAD STACK ASSOCIATED WITH THE FIRST GVM TO TRIGGER A DESIRED FUNCTION CALL INVOCATION ONCE THE GVM IS RESUMED OPERATION .

In one embodiment at USE THE SVM AND SECURITY API TO MODIFY CPU REGISTERS AND OR THE CONTENTS OF A CURRENT THREAD STACK ASSOCIATED WITH THE FIRST GVM TO TRIGGER A DESIRED FUNCTION CALL INVOCATION ONCE THE GVM IS RESUMED OPERATION using the security API of PROVIDE A SECURITY API AS AN INTERFACE BETWEEN THE HYPERVISOR AND THE SVM OPERATION the SVM of IMPLEMENT AT LEAST ONE SECURITY VIRTUAL MACHINE SVM ON THE HOST COMPUTING SYSTEM OPERATION is provided access to the first GVM while the GVM is in the suspended state of SUSPEND THE STATE OF A FIRST GVM WHEN SVM INVOCATION POINT IS REACHED OPERATION and the contents of key CPU registers e.g. the EIP and ESP registers and the contents the GVMs associated memory e.g. the current thread stack associated with the GVM are modified.

Referring to together in one embodiment once a trap to the SVM occurs at SUSPEND THE STATE OF A FIRST GVM WHEN SVM INVOCATION POINT IS REACHED OPERATION and context of the interrupted GVM thread is saved at SAVE THE FIRST GVM STATE AT THE SVM INVOCATION POINT OPERATION the SVM sets the GVM s instruction pointer i.e. in 32 bit architectures the Extended Instruction Pointer EIP register program counter in the x86 architecture to the address of a desired function at USE THE SVM AND SECURITY API TO MODIFY CPU REGISTERS AND OR THE CONTENTS OF A CURRENT THREAD STACK ASSOCIATED WITH THE FIRST GVM TO TRIGGER A DESIRED FUNCTION CALL INVOCATION ONCE THE GVM IS RESUMED OPERATION .

In one embodiment at USE THE SVM AND SECURITY API TO MODIFY CPU REGISTERS AND OR THE CONTENTS OF A CURRENT THREAD STACK ASSOCIATED WITH THE FIRST GVM TO TRIGGER A DESIRED FUNCTION CALL INVOCATION ONCE THE GVM IS RESUMED OPERATION the stack pointer i.e. the Extended Stack Pointer ESP in a 32 bit architecture is then subtracted so that room can be made in the stack for the arguments passed to the desired function and the return address.

In a Windows environment at USE THE SVM AND SECURITY API TO MODIFY CPU REGISTERS AND OR THE CONTENTS OF A CURRENT THREAD STACK ASSOCIATED WITH THE FIRST GVM TO TRIGGER A DESIRED FUNCTION CALL INVOCATION ONCE THE GVM IS RESUMED OPERATION the location of the desired function can be determined by parsing the binary s in memory symbol table once the base address is known. With other operating systems different techniques may be used.

Referring to and together in one embodiment e.g. in an Intel x 86 architecture at USE THE SVM AND SECURITY API TO MODIFY CPU REGISTERS AND OR THE CONTENTS OF A CURRENT THREAD STACK ASSOCIATED WITH THE FIRST GVM TO TRIGGER A DESIRED FUNCTION CALL INVOCATION ONCE THE GVM IS RESUMED OPERATION arguments to be passed to the desired function are copied to the stack in reverse order. In some embodiments arguments to be passed to a desired function whose corresponding parameter is defined as call by value are directly copied to the stack. In some embodiments in the case of call by reference arguments a pointer pointing to the actual data is placed on the stack.

In some embodiments at USE THE SVM AND SECURITY API TO MODIFY CPU REGISTERS AND OR THE CONTENTS OF A CURRENT THREAD STACK ASSOCIATED WITH THE FIRST GVM TO TRIGGER A DESIRED FUNCTION CALL INVOCATION ONCE THE GVM IS RESUMED OPERATION the actual data can also be on the stack or in a dedicated memory page used for call by reference arguments e.g. strings or file buffers . In one embodiment before such a page is allocated in one embodiment by injecting a memory allocation function call the stack technique is used to store call by reference arguments.

Referring to and together in one embodiment at USE THE SVM AND SECURITY API TO MODIFY CPU REGISTERS AND OR THE CONTENTS OF A CURRENT THREAD STACK ASSOCIATED WITH THE FIRST GVM TO TRIGGER A DESIRED FUNCTION CALL INVOCATION ONCE THE GVM IS RESUMED OPERATION a FCI return address is initially set to a location in the active code segment that has no actual code e.g. a location that is either known to be empty or is known to be typically used for padding purposes.

In one embodiment a hypervisor enabled execution breakpoint is placed on this memory location and the FCI return address of the desired function call is set to this hypervisor enabled execution breakpoint. Consequently as discussed below when the desired function finishes executing the final Return RET instruction will transfer control to this special location suspending the GVM and trapping into the SVM.

In one embodiment once using the security API of PROVIDE A SECURITY API AS AN INTERFACE BETWEEN THE HYPERVISOR AND THE SVM OPERATION the SVM of IMPLEMENT AT LEAST ONE SECURITY VIRTUAL MACHINE SVM ON THE HOST COMPUTING SYSTEM OPERATION is provided access to the first GVM while the GVM is in the suspended state of SUSPEND THE STATE OF A FIRST GVM WHEN SVM INVOCATION POINT IS REACHED OPERATION and the contents of key CPU registers e.g. the EIP and ESP registers and the contents the GVMs associated memory e.g. the current thread stack associated with the GVM are modified at USE THE SVM AND SECURITY API TO MODIFY CPU REGISTERS AND OR THE CONTENTS OF A CURRENT THREAD STACK ASSOCIATED WITH THE FIRST GVM TO TRIGGER A DESIRED FUNCTION CALL INVOCATION ONCE THE GVM IS RESUMED OPERATION process flow proceeds to RESUME THE FIRST GVM AND ALLOW THE DESIRED FUNCTION CALL TO TAKE PLACE OPERATION .

In one embodiment at RESUME THE FIRST GVM AND ALLOW THE DESIRED FUNCTION CALL TO TAKE PLACE OPERATION the GVM executes the desired function call of USE THE SVM AND SECURITY API TO MODIFY CPU REGISTERS AND OR THE CONTENTS OF A CURRENT THREAD STACK ASSOCIATED WITH THE FIRST GVM TO TRIGGER A DESIRED FUNCTION CALL INVOCATION ONCE THE GVM IS RESUMED OPERATION just as if it had been invoked from GVM code.

In one embodiment once the GVM executes the desired function call of USE THE SVM AND SECURITY API TO MODIFY CPU REGISTERS AND OR THE CONTENTS OF A CURRENT THREAD STACK ASSOCIATED WITH THE FIRST GVM TO TRIGGER A DESIRED FUNCTION CALL INVOCATION ONCE THE GVM IS RESUMED OPERATION at RESUME THE FIRST GVM AND ALLOW FCI TO TAKE PLACE OPERATION process flow proceeds to SUSPEND THE STATE OF THE FIRST GVM WHEN THE FCI RETURN ADDRESS OCCURS OPERATION .

In one embodiment at SUSPEND THE STATE OF THE FIRST GVM WHEN THE FCI RETURN ADDRESS OCCURS OPERATION when the FCI return address occurs the GVM is placed in a suspended state.

In one embodiment once the FCI return address occurs and the GVM is placed in a suspended state at SUSPEND THE STATE OF THE FIRST GVM WHEN THE FCI RETURN ADDRESS OCCURS OPERATION process flow proceeds to RESTORE THE GVM STATE AT THE ORIGINATING SVM INVOCATION POINT OPERATION .

In one embodiment at RESTORE THE GVM STATE AT THE ORIGINATING SVM INVOCATION POINT OPERATION the SVM then releases the GVM and restores the saved GVM state at the SVM invocation point of SAVE THE FIRST GVM STATE AT THE SVM INVOCATION POINT OPERATION .

Numerous means methods procedures processes and mechanisms to release a GVM from a suspended state and restore the initial state of the GVM are known to those of skill in the art. Consequently a more detailed discussion of specific means methods procedures processes and mechanisms used to release the first GVM from the suspended state and restore the initial state of the first GVM at RESTORE THE GVM STATE AT THE ORIGINATING SVM INVOCATION POINT OPERATION is omitted here to avoid detracting from the invention.

In one embodiment once the SVM releases the GVM and restores the saved GVM state at the SVM invocation point of SAVE THE FIRST GVM STATE AT THE SVM INVOCATION POINT OPERATION at RESTORE THE GVM STATE AT THE ORIGINATING SVM INVOCATION POINT OPERATION process flow proceeds to THE GVM RESUMES EXECUTION AT THE ORIGINATING SVM INVOCATION POINT OPERATION .

In one embodiment at THE GVM RESUMES EXECUTION AT THE ORIGINATING SVM INVOCATION POINT OPERATION the first GVM resumes its execution from the point at which it was interrupted when the function call injection first took place.

Various embodiments of process for injecting function calls into a virtual machine can be applied in user or kernel mode to invoke system level API functions without the need for an in guest agent to be present. In addition since the process for Function Call Injection only manipulates the GVM s virtual hardware state it is generic enough to be used with different operating systems although as those of skill in the art will recognize the invoked routines may be somewhat different.

In addition by invoking GVM routines instead of trying to directly interpret its memory contents the process for Function Call Injection discussed herein reduces the semantic gap problem as it relies on the GVM s own code that naturally navigates and interprets the state of the GVM.

In one embodiment once the first GVM resumes its execution from the point at which it was interrupted when the function call injection first took place at THE GVM RESUMES EXECUTION AT THE ORIGINATING SVM INVOCATION POINT OPERATION process flow proceeds to EXIT OPERATION where process for injecting function calls into a virtual machine is exited to await new data.

Using process for injecting function calls into a virtual machine function call invocations are triggered inside a GVM without the use or need for in GVM agents. In addition since using process for injecting function calls into a virtual machine the GVM s stack is manipulated by the SVM the GVM s OS is used to create the desired files function calls. Consequently process for injecting function calls into a virtual machine is a general and OS independent solution that largely avoids the semantic gap problem.

In the discussion above certain aspects of one embodiment include process steps and or operations and or instructions described herein for illustrative purposes in a particular order and or grouping. However the particular order and or grouping shown and discussed herein are illustrative only and not limiting. Those of skill in the art will recognize that other orders and or grouping of the process steps and or operations and or instructions are possible and in some embodiments one or more of the process steps and or operations and or instructions discussed above can be combined and or deleted. In addition portions of one or more of the process steps and or operations and or instructions can be re grouped as portions of one or more other of the process steps and or operations and or instructions discussed herein. Consequently the particular order and or grouping of the process steps and or operations and or instructions discussed herein do not limit the scope of the invention as claimed below.

Herein embodiments have been discussed with reference to the accompanying FIG.s which depict one or more exemplary embodiments. The above description includes reference to specific embodiments for illustrative purposes. However the illustrative discussion above is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the teachings below. The embodiments discussed above were chosen and described in order to explain the principles of the invention and its practical applications to thereby enable others skilled in the art to utilize the invention and various embodiments with various modifications as may be suited to the particular use contemplated. Therefore embodiments may be embodied in many different forms than those shown and discussed herein and should not be construed as limited to the embodiments set forth herein shown in the FIG.s and or described below. In addition the nomenclature used for components capitalization of component designations and terms the attributes data structures or any other programming or structural aspect is not significant mandatory or limiting and the mechanisms that implement the invention or its features can have various different names formats and or protocols. Further the system and or functionality of the invention may be implemented via various combinations of software and hardware as described or entirely in hardware elements. Also particular divisions of functionality between the various components described herein are merely exemplary and not mandatory or significant. Consequently functions performed by a single component may in other embodiments be performed by multiple components and functions performed by multiple components may in other embodiments be performed by a single component.

Some portions of the above description present the features of the present invention in terms of algorithms and symbolic representations of operations or algorithm like representations of operations on information data. These algorithmic and or algorithm like descriptions and representations are the means used by those of skill in the art to most effectively and efficiently convey the substance of their work to others of skill in the art. These operations while described functionally or logically are understood to be implemented by computer programs and or computing systems. Furthermore it has also proven convenient at times to refer to these arrangements of operations as steps or modules or by functional names without loss of generality.

Unless specifically stated otherwise as would be apparent from the above discussion it is appreciated that throughout the above description discussions utilizing terms such as providing implementing suspending using restoring resuming receiving analyzing extracting generating sending capturing monitoring obtaining requesting storing saving classifying comparing calculating processing filtering extracting defining detecting transforming distributing etc. refer to the action and processes of a computing system or similar electronic device that manipulates and operates on data represented as physical electronic quantities within the computing system memories registers caches or other information storage transmission or display devices.

Certain aspects of the present invention include process steps or operations and instructions described herein in an algorithmic and or algorithmic like form. It should be noted that the process steps and or operations and instructions of the present invention can be embodied in software firmware and or hardware and when embodied in software can be downloaded to reside on and be operated from different platforms used by real time network operating systems.

The present invention also relates to an apparatus or system for performing the operations described herein. This apparatus or system may be specifically constructed for the required purposes or the apparatus or system can comprise a general purpose system selectively activated or configured reconfigured by a computer program stored on a computer program product as defined herein that can be accessed by a computing system or other device.

Those of skill in the art will readily recognize that the algorithms and operations presented herein are not inherently related to any particular computing system computer architecture computer or industry standard or any other specific apparatus. Various general purpose systems may also be used with programs in accordance with the teaching herein or it may prove more convenient efficient to construct more specialized apparatuses to perform the required operations described herein. The required structure for a variety of these systems will be apparent to those of skill in the art along with equivalent variations. In addition the present invention is not described with reference to any particular programming language and it is appreciated that a variety of programming languages may be used to implement the teachings of the present invention as described herein and any references to a specific language or languages are provided for illustrative purposes only and for enablement of the contemplated best mode of the invention at the time of filing.

The present invention is well suited to a wide variety of computer network systems operating over numerous topologies. Within this field the configuration and management of large networks comprise storage devices and computers that are communicably coupled to similar and or dissimilar computers and storage devices over a private network a LAN a WAN a private network or a public network such as the Internet.

It should also be noted that the language used in the specification has been principally selected for readability clarity and instructional purposes and may not have been selected to delineate or circumscribe the inventive subject matter. Accordingly the disclosure of the present invention is intended to be illustrative but not limiting of the scope of the invention which is set forth in the claims below.

In addition the operations shown in the FIG.s are identified using a particular nomenclature for ease of description and understanding but other nomenclature is often used in the art to identify equivalent operations.

Therefore numerous variations whether explicitly provided for by the specification or implied by the specification or not may be implemented by one of skill in the art in view of this disclosure.

