---

title: Inter-shader attribute buffer optimization
abstract: One embodiment of the present invention sets forth a technique for reducing the amount of memory required to store vertex data processed within a processing pipeline that includes a plurality of shading engines. The method includes determining a first active shading engine and a second active shading engine included within the processing pipeline, wherein the second active shading engine receives vertex data output by the first active shading engine. An output map is received and indicates one or more attributes that are included in the vertex data and output by the first active shading engine. An input map is received and indicates one or more attributes that are included in the vertex data and received by the second active shading engine from the first active shading engine. Then, a buffer map is generated based on the input map, the output map, and a pre-defined set of rules that includes rule data associated with both the first shading engine and the second shading engine, wherein the buffer map indicates one or more attributes that are included in the vertex data and stored in a memory that is accessible by both the first active shading engine and the second active shading engine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08619087&OS=08619087&RS=08619087
owner: Nvidia Corporation
number: 08619087
owner_city: Santa Clara
owner_country: US
publication_date: 20100930
---
This application claims priority benefit to U.S. provisional patent application titled INTER SHADER ATTRIBUTE BUFFER OPTIMIZATION filed on Oct. 6 2009 and having Ser. No. 61 249 220.

The present invention generally relates to computer graphics and more particularly to a method and system for connecting multiple shaders.

Unless otherwise indicated herein the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.

Over the past decade graphics hardware has gone from a simple memory device to a configurable device and relatively recently to a programmable graphics processing unit GPU . To fully realize the parallel processing capabilities of a GPU as much GPU functionality as possible needs to be programmable and be exposed to developers. Among other things doing so enables developers to tailor their shader programs to optimize the way a GPU processes graphics scenes and images. In a prior art approach a GPU includes a series of processing units each is configured to carry out a different and often dedicated function of a graphics pipeline where the output of one processing unit is the input to the next processing unit in the chain. Some of these processing units in the graphics pipeline are programmable such as a vertex processing unit and a fragment processing unit but other processing units perform fixed functions such as a primitive assembler a geometry processor and a rasterizer.

The aforementioned prior art approach has some shortcomings. First without full programmability the graphics pipeline is unable to efficiently respond to changes in Application Programming Interface API such as OpenGL and DirectX or address any bugs identified to be associated with the pipeline. Second because many functions of the graphics pipeline and the sequence of performing such functions are fixed a graphics application utilizing the graphics pipeline does not have the full flexibility to maneuver various shader programs such as invoking shader programs in a different sequence than the sequence of the pipeline stages e.g. invoking a geometry shader ahead of a vertex shader or repeating a particular shader program multiple times e.g. invoking a vertex shader six times . Even with workaround approaches capable of emulating the maneuvering of various shader programs on the prior art system these approaches are cumbersome to implement and are inefficient to operate. For example one workaround approach is to configure a graphics pipeline to execute a particular shader program stream the output of the shader program into a frame buffer reconfigure the graphics pipeline to execute another shader program re inject the stored data from the frame buffer back to the reconfigured pipeline for processing and repeat these steps until all the shader programs are processed in a specific sequence. The repeated configurations of the graphics pipeline and the accesses of the frame buffer consumes significant processing and memory resources and introduces undesirable delays. Another workaround approach involves merging the multiple shader programs and recompiling the merged program to generate a single all encompassing shader program for the graphics pipeline to process. However this approach is inefficient because if any of the shader programs or the sequence of executing the shader programs needs to be altered then these extra steps of merging and compiling also need to be repeated.

Lastly the prior art approach does not support a mechanism that reconciles different input and output requirements of multiple shader programs. To illustrate suppose a first shader program to be executed by a prior art GPU requests for 40 outputs but a second shader program coupled to the first shader program only requests for 6 inputs. In other words the second shader program is designed to read only 6 of the 40 outputs from the first shader program. Without considering the requirements of the second shader program the GPU still allocates the resources for all 40 outputs for the first shader program.

As the foregoing illustrates what is needed in the art is a method and system for supporting a user configurable graphics pipeline capable of efficiently managing storage of inputs and outputs between shader programs.

One embodiment of the present invention sets forth a technique for reducing the amount of memory required to store vertex data processed within a processing pipeline that includes a plurality of shading engines. The method includes determining a first active shading engine and a second active shading engine included within the processing pipeline wherein the second active shading engine receives vertex data output by the first active shading engine. An output map is received and indicates one or more attributes that are included in the vertex data and output by the first active shading engine. An input map is received and indicates one or more attributes that are included in the vertex data and received by the second active shading engine from the first active shading engine. Then a buffer map is generated based on the input map the output map and a pre defined set of rules that includes rule data associated with both the first shading engine and the second shading engine wherein the buffer map indicates one or more attributes that are included in the vertex data and stored in a memory that is accessible by both the first active shading engine and the second active shading engine.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances well known features have not been described in order to avoid obscuring the present invention.

In one embodiment the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry and constitutes a graphics processing unit GPU . In another embodiment the parallel processing subsystem incorporates circuitry optimized for general purpose processing while preserving the underlying computational architecture described in greater detail herein. In yet another embodiment the parallel processing subsystem may be integrated with one or more other system elements such as the memory bridge CPU and I O bridge to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of parallel processing subsystems may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip. Large embodiments may include two or more CPUs and two or more parallel processing systems . The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

Referring again to in some embodiments some or all of PPUs in parallel processing subsystem are graphics processors with rendering pipelines that can be configured to perform various tasks related to generating pixel data from graphics data supplied by CPU and or system memory via memory bridge and bus interacting with local parallel processing memory which can be used as graphics memory including e.g. a conventional frame buffer to store and update pixel data delivering pixel data to display device and the like. In some embodiments parallel processing subsystem may include one or more PPUs that operate as graphics processors and one or more other PPUs that are used for general purpose computations. The PPUs may be identical or different and each PPU may have its own dedicated parallel processing memory device s or no dedicated parallel processing memory device s . One or more PPUs may output data to display device or each PPU may output data to one or more display devices .

In operation CPU is the master processor of computer system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPUs . In some embodiments CPU writes a stream of commands for each PPU to a pushbuffer not explicitly shown in either or that may be located in system memory parallel processing memory or another storage location accessible to both and PPU . PPU reads the command stream from the pushbuffer and then executes commands asynchronously relative to the operation of CPU .

Referring back now to each PPU includes an I O input output unit that communicates with the rest of computer system via communication path which connects to memory bridge or in one alternative embodiment directly to CPU . The connection of PPU to the rest of computer system may also be varied. In some embodiments parallel processing subsystem is implemented as an add in card that can be inserted into an expansion slot of computer system . In other embodiments a PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . In still other embodiments some or all elements of PPU may be integrated on a single chip with CPU .

In one embodiment communication path is a PCI EXPRESS link in which dedicated lanes are allocated to each PPU as is known in the art. Other communication paths may also be used. An I O unit generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path directing the incoming packets to appropriate components of PPU . For example commands related to processing tasks may be directed to a host interface while commands related to memory operations e.g. reading from or writing to parallel processing memory may be directed to a memory crossbar unit . Host interface reads each pushbuffer and outputs the work specified by the pushbuffer to a front end .

Each PPU advantageously implements a highly parallel processing architecture. As shown in detail PPU includes a processing cluster array that includes a number C of general processing clusters GPCs where C 1. Each GPC is capable of executing a large number e.g. hundreds or thousands of threads concurrently where each thread is an instance of a program. In various applications different GPCs may be allocated for processing different types of programs or for performing different types of computations. For example in a graphics application a first set of GPCs may be allocated to perform tessellation operations and to produce primitive topologies for patches and a second set of GPCs may be allocated to perform tessellation shading to evaluate patch parameters for the primitive topologies and to determine vertex positions and other per vertex attributes. The allocation of GPCs may vary dependent on the workload arising for each type of program or computation.

GPCs receive processing tasks to be executed via a work distribution unit which receives commands defining processing tasks from front end unit . Processing tasks include indices of data to be processed e.g. surface patch data primitive data vertex data and or pixel data as well as state parameters and commands defining how the data is to be processed e.g. what program is to be executed . Work distribution unit may be configured to fetch the indices corresponding to the tasks or work distribution unit may receive the indices from front end . Front end ensures that GPCs are configured to a valid state before the processing specified by the pushbuffers is initiated.

When PPU is used for graphics processing for example the processing workload for each patch is divided into approximately equal sized tasks to enable distribution of the tessellation processing to multiple GPCs . A work distribution unit may be configured to produce tasks at a frequency capable of providing tasks to multiple GPCs for processing. By contrast in conventional systems processing is typically performed by a single processing engine while the other processing engines remain idle waiting for the single processing engine to complete its tasks before beginning their processing tasks. In some embodiments of the present invention portions of GPCs are configured to perform different types of processing. For example a first portion may be configured to perform vertex shading and topology generation a second portion may be configured to perform tessellation and geometry shading and a third portion may be configured to perform pixel shading in screen space to produce a rendered image. Intermediate data produced by GPCs may be stored in buffers to allow the intermediate data to be transmitted between GPCs for further processing.

Memory interface includes a number D of partition units that are each directly coupled to a portion of parallel processing memory where D 1. As shown the number of partition units generally equals the number of DRAM . In other embodiments the number of partition units may not equal the number of memory devices. Persons skilled in the art will appreciate that DRAM may be replaced with other suitable storage devices and can be of generally conventional design. A detailed description is therefore omitted. Render targets such as frame buffers or texture maps may be stored across DRAMs allowing partition units to write portions of each render target in parallel to efficiently use the available bandwidth of parallel processing memory .

Any one of GPCs may process data to be written to any of the DRAMs within parallel processing memory . Crossbar unit is configured to route the output of each GPC to the input of any partition unit or to another GPC for further processing. GPCs communicate with memory interface through crossbar unit to read from or write to various external memory devices. In one embodiment crossbar unit has a connection to memory interface to communicate with I O unit as well as a connection to local parallel processing memory thereby enabling the processing cores within the different GPCs to communicate with system memory or other memory that is not local to PPU . In the embodiment shown in crossbar unit is directly connected with I O unit . Crossbar unit may use virtual channels to separate traffic streams between the GPCs and partition units .

Again GPCs can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. tessellation shader vertex shader geometry shader and or pixel shader programs and so on. PPUs may transfer data from system memory and or local parallel processing memories into internal on chip memory process the data and write result data back to system memory and or local parallel processing memories where such data can be accessed by other system components including CPU or another parallel processing subsystem .

A PPU may be provided with any amount of local parallel processing memory including no local memory and may use local memory and system memory in any combination. For instance a PPU can be a graphics processor in a unified memory architecture UMA embodiment. In such embodiments little or no dedicated graphics parallel processing memory would be provided and PPU would use system memory exclusively or almost exclusively. In UMA embodiments a PPU may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high speed link e.g. PCI EXPRESS connecting the PPU to system memory via a bridge chip or other communication means.

As noted above any number of PPUs can be included in a parallel processing subsystem . For instance multiple PPUs can be provided on a single add in card or multiple add in cards can be connected to communication path or one or more of PPUs can be integrated into a bridge chip. PPUs in a multi PPU system may be identical to or different from one another. For instance different PPUs might have different numbers of processing cores different amounts of local parallel processing memory and so on. Where multiple PPUs are present those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including desktop laptop or handheld personal computers servers workstations game consoles embedded systems and the like.

Operation of GPC is advantageously controlled via a pipeline manager that distributes processing tasks to streaming multiprocessors SPMs . Pipeline manager may also be configured to control a work distribution crossbar by specifying destinations for processed data output by SPMs .

In one embodiment each GPC includes a number M of SPMs where M 1 each SPM configured to process one or more thread groups. Also each SPM advantageously includes an identical set of functional execution units e.g. arithmetic logic units and load store units shown as Exec units and LSUs in that may be pipelined allowing a new instruction to be issued before a previous instruction has finished as is known in the art. Any combination of functional execution units may be provided. In one embodiment the functional units support a variety of operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation trigonometric exponential and logarithmic functions etc. and the same functional unit hardware can be leveraged to perform different operations.

The series of instructions transmitted to a particular GPC constitutes a thread as previously defined herein and the collection of a certain number of concurrently executing threads across the parallel processing engines not shown within an SPM is referred to herein as a warp or thread group. As used herein a thread group refers to a group of threads concurrently executing the same program on different input data with one thread of the group being assigned to a different processing engine within an SPM . A thread group may include fewer threads than the number of processing engines within the SPM in which case some processing engines will be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of processing engines within the SPM in which case processing will take place over consecutive clock cycles. Since each SPM can support up to G thread groups concurrently it follows that up to G M thread groups can be executing in GPC at any given time.

Additionally a plurality of related thread groups may be active in different phases of execution at the same time within an SPM . This collection of thread groups is referred to herein as a cooperative thread array CTA or thread array. The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group and is typically an integer multiple of the number of parallel processing engines within the SPM and m is the number of thread groups simultaneously active within the SPM . The size of a CTA is generally determined by the programmer and the amount of hardware resources such as memory or registers available to the CTA.

Each SPM contains an L1 cache not shown or uses space in a corresponding L1 cache outside of the SPM that is used to perform load and store operations. Each SPM also has access to L2 caches within the partition units that are shared among all GPCs and may be used to transfer data between threads. Finally SPMs also have access to off chip global memory which can include e.g. parallel processing memory and or system memory . It is to be understood that any memory external to PPU may be used as global memory. Additionally an L1.5 cache may be included within the GPC configured to receive and hold data fetched from memory via memory interface requested by SPM including instructions uniform data and constant data and provide the requested data to SPM . Embodiments having multiple SPMs in GPC beneficially share common instructions and data cached in L1.5 cache .

Each GPC may include a memory management unit MMU that is configured to map virtual addresses into physical addresses. In other embodiments MMU s may reside within the memory interface . The MMU includes a set of page table entries PTEs used to map a virtual address to a physical address of a tile and optionally a cache line index. The MMU may include address translation lookaside buffers TLB or caches which may reside within multiprocessor SPM or the L1 cache or GPC . The physical address is processed to distribute surface data access locality to allow efficient request interleaving among partition units. The cache line index may be used to determine whether of not a request for a cache line is a hit or miss.

In graphics and computing applications a GPC may be configured such that each SPM is coupled to a texture unit for performing texture mapping operations e.g. determining texture sample positions reading texture data and filtering the texture data. Texture data is read from an internal texture L1 cache not shown or in some embodiments from the L1 cache within SPM and is fetched from an L2 cache parallel processing memory or system memory as needed. Each SPM outputs processed tasks to work distribution crossbar in order to provide the processed task to another GPC for further processing or to store the processed task in an L2 cache parallel processing memory or system memory via crossbar unit . A preROP pre raster operations is configured to receive data from SPM direct data to ROP units within partition units and perform optimizations for color blending organize pixel color data and perform address translations.

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Any number of processing units e.g. SPMs or texture units preROPs may be included within a GPC . Further while only one GPC is shown a PPU may include any number of GPCs that are advantageously functionally similar to one another so that execution behavior does not depend on which GPC receives a particular processing task. Further each GPC advantageously operates independently of other GPCs using separate and distinct processing units L1 caches and so on.

In graphics applications ROP is a processing unit that performs raster operations such as stencil z test blending and the like and outputs pixel data as processed graphics data for storage in graphics memory. In some embodiments of the present invention ROP is included within each GPC instead of partition unit and pixel read and write requests are transmitted over crossbar unit instead of pixel fragment data.

The processed graphics data may be displayed on display device or routed for further processing by CPU or by one of the processing entities within parallel processing subsystem . Each partition unit includes a ROP in order to distribute processing of the raster operations. In some embodiments ROP may be configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.

Persons skilled in the art will understand that the architecture described in A and B in no way limits the scope of the present invention and that the techniques taught herein may be implemented on any properly configured processing unit including without limitation one or more CPUs one or more multi core CPUs one or more PPUs one or more GPCs one or more graphics or special purpose processing units or the like without departing the scope of the present invention.

In embodiments of the present invention it is desirable to use PPU or other processor s of a computing system to execute general purpose computations using thread arrays. Each thread in the thread array is assigned a unique thread identifier thread ID that is accessible to the thread during its execution. The thread ID which can be defined as a one dimensional or multi dimensional numerical value controls various aspects of the thread s processing behavior. For instance a thread ID may be used to determine which portion of the input data set a thread is to process and or to determine which portion of an output data set a thread is to produce or write.

A sequence of per thread instructions may include at least one instruction that defines a cooperative behavior between the representative thread and one or more other threads of the thread array. For example the sequence of per thread instructions might include an instruction to suspend execution of operations for the representative thread at a particular point in the sequence until such time as one or more of the other threads reach that particular point an instruction for the representative thread to store data in a shared memory to which one or more of the other threads have access an instruction for the representative thread to atomically read and update data stored in a shared memory to which one or more of the other threads have access based on their thread IDs or the like. The CTA program can also include an instruction to compute an address in the shared memory from which data is to be read with the address being a function of the thread ID. By defining suitable functions and providing synchronization techniques data can be written to a given location in shared memory by one thread of a CTA and read from that location by a different thread of the same CTA in a predictable manner. Consequently any desired pattern of data sharing among threads can be supported and any thread in a CTA can share data with any other thread in the same CTA. The extent if any of data sharing among threads of a CTA is determined by the CTA program thus it is to be understood that in a particular application that uses CTAs the threads of a CTA might or might not actually share data with each other depending on the CTA program and the terms CTA and thread array are used synonymously herein.

SPM provides on chip internal data storage with different levels of accessibility. Special registers not shown are readable but not writeable by LSU and are used to store parameters defining each CTA thread s position. In one embodiment special registers include one register per CTA thread or per exec unit within SPM that stores a thread ID each thread ID register is accessible only by a respective one of the exec unit . Special registers may also include additional registers readable by all CTA threads or by all LSUs that store a CTA identifier the CTA dimensions the dimensions of a grid to which the CTA belongs and an identifier of a grid to which the CTA belongs. Special registers are written during initialization in response to commands received via front end from device driver and do not change during CTA execution.

A parameter memory not shown stores runtime parameters constants that can be read but not written by any CTA thread or any LSU . In one embodiment device driver provides parameters to the parameter memory before directing SPM to begin execution of a CTA that uses these parameters. Any CTA thread within any CTA or any exec unit within SPM can access global memory through a memory interface . Portions of global memory may be stored in the L1 cache .

Local register file is used by each CTA thread as scratch space each register is allocated for the exclusive use of one thread and data in any of local register file is accessible only to the CTA thread to which it is allocated. Local register file can be implemented as a register file that is physically or logically divided into P lanes each having some number of entries where each entry might store e.g. a 32 bit word . One lane is assigned to each of the N exec units and P load store units LSU and corresponding entries in different lanes can be populated with data for different threads executing the same program to facilitate SIMD execution. Different portions of the lanes can be allocated to different ones of the G concurrent thread groups so that a given entry in the local register file is accessible only to a particular thread. In one embodiment certain entries within the local register file are reserved for storing thread identifiers implementing one of the special registers.

Shared memory is accessible to all CTA threads within a single CTA any location in shared memory is accessible to any CTA thread within the same CTA or to any processing engine within SPM . Shared memory can be implemented as a shared register file or shared on chip cache memory with an interconnect that allows any processing engine to read from or write to any location in the shared memory. In other embodiments shared state space might map onto a per CTA region of off chip memory and be cached in L1 cache . The parameter memory can be implemented as a designated section within the same shared register file or shared cache memory that implements shared memory or as a separate shared register file or on chip cache memory to which the LSUs have read only access. In one embodiment the area that implements the parameter memory is also used to store the CTA ID and grid ID as well as CTA and grid dimensions implementing portions of the special registers. Each LSU in SPM is coupled to a unified address mapping unit that converts an address provided for load and store instructions that are specified in a unified memory space into an address in each distinct memory space. Consequently an instruction may be used to access any of the local shared or global memory spaces by specifying an address in the unified memory space.

The L1 Cache in each SPM can be used to cache private per thread local data and also per application global data. In some embodiments the per CTA shared data may be cached in the L1 cache . The LSUs are coupled to a uniform L1 cache the shared memory and the L1 cache via a memory and cache interconnect . The uniform L1 cache is configured to receive read only data and constants from memory via the L1.5 Cache .

To ensure resources are efficiently utilized to execute the various shaders in MPipe one approach is to match the expected output of a first shader at a current stage and the expected input of a second shader at an immediately subsequent stage. Specifically a shader typically has a shader header which is generated by a compiler along with executable program instructions and includes an input map IMap and an output map OMap . The IMap describes the input that the shader expects to receive and the OMap describes the output that the shader expects to generate. The logical AND between the OMap of the first shader and the IMap of the second shader is referred to as a buffer map BMap .

Upon completion of the BMap whenever shader A generates an output including the attribute of a SPM recognizes that a is not in BMap and thus removes a before it reaches shader B . In other words instead of allocating resources for a b and c only the resources for b and c are allocated. In a second scenario suppose the OMap of shader A still contains attributes of a b and c but the IMap of shader B contains b c and d. Here before shader B reads its input SPM recognizes that d is not in BMap and thus adds a default value e.g. 0 0 0 1 for a vector or 1.0 for a scalar in place of d. Accordingly with BMap only the needed resources are allocated and the remaining resources can be reserved for operating additional instances of MPipe . Both of the aforementioned scenarios assume the output from one shader e.g. shader A is used as input for also only one shader e.g. shader B and each entry in BMap is the result of performing a custom AND operation between bits included in an OMap and an IMap and further between corresponding entries included in an Attribute Address Map Table AAMT and a BMap Generation Truth Table described in further detail below.

Table 1 sets forth a format of an AAMT according to one embodiment of the present invention. As shown Table 1 includes one or more rows where each row corresponds to an attribute of a vertex such as a vertex identification code herein referred to as VertexID or x coordinate of the vertex herein referred to as PositionX . Each of the rows for the vertex attributes comprises one or more columns where each column associated with a particular shader type that may be enabled in the MPipe such as a vertex shader a tessellation shader and a geometry shader. Included in each column are a first and a second keyword where the first keyword specifies a configuration type for an IDMap of the associated shader and where the second keyword specifies a configuration type for an ODMap of the associated shader. The keyword that is associated with each of the IDMap and ODMap provide additional configuration parameters that are considered by the custom AND operation to provide optimizations when connecting the output of one shader to the input of a successive shader. In one embodiment seven keyword types are considered each described in detail below.

The first keyword type Load LD indicates that the associated shader may load the corresponding vertex attribute from the memory if a value for that vertex attribute is present in the memory. Otherwise if the value is not present in the memory then a default value is loaded.

The second keyword type Store ST indicates that the associated shader may store the corresponding vertex attribute in the memory if a downstream shader requires the vertex attribute. Otherwise the vertex attribute is discarded.

The third keyword type Load Required LD REQ causes the corresponding bit in the BMap generated by the custom AND operation to always be set to a value of 1 when the corresponding IMap bit is a value of 1.

The fourth keyword type Store Required ST REQ causes the corresponding bit in the BMap generated by the custom AND operation to always be set to a value of 1 when the corresponding OMap bit is a value of 1 which enables a shader to subsequently read a vertex attribute output and to use the vertex attribute output as an input to perform further processing on the vertex attribute.

The fifth keyword type Store Last ST LAST indicates that if the shader is the last enabled shader in the MPipe then the OMap is configured with respect to the rules of ST REQ keyword described above. Otherwise the OMap is configured with respect to the rules of the ST keyword also described above.

The sixth keyword type DEFAULT indicates that an error should occur if a value of 1 is present in the IMap. The DEFAULT keyword also indicates that for any attribute load that is performed a default value is received. However if the OMap of the previous shader specifies the ST REQ keyword and the OMap bit is 1 then the vertex attribute output from the previous shader is received. Further if an interpolation is performed then a value of zero is received.

The seventh and final keyword type DISCARD indicates that an error should occur when the OMap bit is 1. The DISCARD keyword also indicates that if an attribute store operation is performed then the resulting attribute data is discarded regardless of the IMap bit of the subsequent shader.

To generate a BMap between the first shader and the second shader each of the corresponding keywords specified within an AAMT along with the OMap of the first shader and the IMap of the second shader are used in conjunction with the BMap Generation Truth Table shown in Table 3. As such consider an example where a BMap for a two attribute vertex is generated between a vertex shader and a geometry shader. For this example a Table 2 is included below which is formatted according to the AAMT set forth in Table 1 and populated with example data.

As shown Table 2 includes a row for each of the attributes that comprise the vertex in this case the VertexID attribute and the PositionX attribute. Table 2 further includes for each of the vertex shader and geometry shader one keyword that specifies a configuration type corresponding to the IDMap and another keyword that specifies a configuration type corresponding to the ODMap. In this example the vertex shader precedes the geometry shader in the MPipe such that the geometry shader receives vertex data output by the vertex shader. Accordingly to generate the BMap bits for each of the VertexID and PositionX vertex attributes a logic operation is performed according to the truth table shown in Table 3 operating on each of the ODMap keywords of the vertex shader the corresponding IDMap keywords of the geometry shader the corresponding bit values included in the vertex shader s Omap and the corresponding bit values included in the geometry shader s IMap.

Continuing with the example described above in Table 3 the column Omap n represents an nth bit of the vertex shader s OMap while the column Imap n represents an nth bit of the geometry shader s IMap. The columns Odmap n and Idmap n correspond to the IDMap and ODMap keywords specified in the Table 1 and control the behavior of the logic operation that is used to generate the final BMap bits between the vertex shader and the geometry shader.

Thus to determine the BMap bit for each of the attributes the corresponding OMap bit of the vertex shader which may be a value of 1 or 0 depending on the configuration of the vertex shader is compared against the value of the IMap bit of the geometry shader the ODMap keyword type of the vertex shader and the IDMap keyword type of the geometry shader.

For example with respect to the VertexID vertex attribute if the OMap of the Vertex Shader is a value of 1 and the IMap of the Geometry Shader is a value of 0 then the resultant value of the BMap bit corresponding to the VertexID vertex attribute is 0. Similarly with respect to the PositionX vertex attribute if the OMap of the Vertex Shader is a value of 1 and the IMap of the Geometry Shader is a value of 1 then the resultant value of the BMap bit corresponding to the PositionX vertex attribute is 1.

To illustrate aspects of Table 3 consider the 19row that has Odmap n ST REQ Omap n 1 Idmap n LD Imap n 0 and Bmap n 1. In this case the upstream shader is outputting attribute n as indicated by Omap n 1 but the downstream shader is not going to read attribute n as indicated by Imap n 0. If attribute n was not used for anything else it would make sense to have Bmap n 0 because the attribute is not passed from the upstream shader to the downstream shader. However attribute n gets special treatment due to having Odmap n ST REQ. With Odmap n ST REQ Bmap n 1 even though Imap n 0. The 19row of Table 3 is applicable to special attributes such as DirectX s RenderTargetArrayIndex which is an index used to select amongst indexed render targets but only if it is present at the Geometry Shader output otherwise index 0 is used. In this API RenderTargetArray is needed in the ISBE whenever it is generated even if downstream shaders do not read it. A similar example is DirectX s ViewportIndex attribute. In Table 3 special handling of the attribute is indicated by any row where Bmap n is not equal to the logical AND of Imap n and Omap n .

The method begins at step where the parallel processing subsystem receives a command. At step the parallel processing subsystem determines whether the command specifies an MPipe configuration update. The determination may be performed by the front end the work distribution unit or an addition block not shown in . If at step the parallel processing subsystem determines that the command specifies an MPipe configuration update then the method proceeds to step .

At step the parallel processing subsystem according to the configuration command enables or disables one or more processing stages included in the MPipe . At step the parallel processing subsystem establishes a BMap between each of the enabled stages included in the MPipe according to the techniques described above in conjunction with the AAMT in Table 1 and the BMap generation truth table in Table 3. The method then ends.

Referring back now to step if the parallel processing subsystem determines that the command does not specify an MPipe configuration update then the method proceeds to step . At step the command is executed according to the one or more instructions specified within the command and the method ends.

In addition is a conceptual diagram of a packet format suitable for the MPipe according to one embodiment of the invention. Specifically the packet of work corresponds to an Inter Stage Buffer Element ISBE which includes a vertex packet and a primitive packet . Vertex packet contains attribute information such as color and position information for multiple vertices. Primitive packet contains topology information for a plurality of primitives where the topology information selects vertices associated with each primitive and where the vertices are selected from the vertex packet . Because each shader in MPipe defines its expected input data and output data the ISBE is expected to be configured different at different points in the MPipe. For example a vertex shader can modify vertex packet and a geometry shader can modify both vertex packet and primitive packet . Other types of shaders may even generate multiple output ISBE s each of which is independent of the others.

To illustrate further suppose shader A is a vertex shader and shader A expects to operate on an input primitive of a certain type e.g. triangle and generates an output primitive of the same type e.g. triangle . Here since the topology information is expected to remain the same shader A does not modify the primitive packet of the ISBE and instead modifies the data in the vertex packet of the ISBE . On the other hand suppose shader B is a geometry shader and shader B expects to operate on an input primitive of a first type e.g. triangle and generates an output primitive of a second type e.g. point . Here since the topology information is expected to change the ISBE at the output of shader B has different data in the vertex packet and the primitive packet when compared to the ISBE at the input to shader B.

The above description illustrates various embodiments of the invention along with examples of how aspects of the invention may be implemented. The above examples embodiments instruction semantics and drawings should not be deemed to be the only embodiments and are presented to illustrate the flexibility and advantages of the invention as defined by the following claims.

