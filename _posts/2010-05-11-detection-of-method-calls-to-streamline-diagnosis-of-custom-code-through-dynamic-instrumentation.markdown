---

title: Detection of method calls to streamline diagnosis of custom code through dynamic instrumentation
abstract: A technique for analyzing software in which un-instrumented components can be discovered and dynamically instrumented during a runtime of the software. Initially, an application configured with a baseline set of instrumented components such as methods. As the application runs, performance data is gathered from the instrumentation, and it may be learned that the performance of some methods is an issue. To analyze the problem, any methods which are callable from a method at issue are discovered by inspecting the byte code of loaded classes in a JAVA Virtual Machine (JVM). Byte code of the class is parsed to identify opcodes which invoke byte code to call other methods. An index to an entry in a constants pool table is identified based on an opcode. A decision can then be made to instrument and/or report the discovered methods.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08566800&OS=08566800&RS=08566800
owner: CA, Inc.
number: 08566800
owner_city: Islandia
owner_country: US
publication_date: 20100511
---
The growing presence of the Internet as well as other computer networks such as intranets and extranets has brought many new applications in e commerce education and other areas. Organizations increasingly rely on such applications to carry out their business or other objectives and devote considerable resources to ensuring that they perform as expected. To this end various application management techniques have been developed.

One approach involves monitoring the infrastructure of the application by collecting application runtime data regarding the individual software components that are invoked in the application. This approach can use agents that essentially live in the system being monitored. For example using instrumentation of the software a thread or process can be traced to identify each component that is invoked as well as to obtain runtime data such as the execution time of each component. Tracing refers to obtaining a detailed record or trace of the steps a computer program executes. One type of trace is a stack trace. Traces can be used as an aid in debugging. However deciding which components to instrument can be problematic. An over inclusive approach can result in excessive overhead costs and possibly impair the operation of the application while an under inclusive approach can result in the omission of important performance data. As a result analysis and diagnosis of software can be problematic.

The present invention provides a technique for analyzing software which addresses the above and other issues.

In one embodiment a computer implemented method for analyzing an application includes the computer implemented steps of identifying at least one method in the application to analyze determining a class of the at least one method from among loaded classes in memory loading a byte code representation of the class from a resource location parsing the byte code representation of the class to identify one or more instances of an invoke byte code and based on the one or more instances of the invoke byte code identifying one or more referenced methods. The method further includes storing the one or more referenced methods as a string.

In another embodiment a computer implemented method for analyzing an application includes identifying at least one instrumented method to analyze in a first instance of the application at a first application server determining a class of the at least one instrumented method from among loaded classes in memory loading a byte code representation of the class from a resource location parsing the byte code representation of the class to identify one or more instances of invoke byte codes and based on the one or more instances of the invoke byte code identifying one or more un instrumented and referenced methods. The method further includes reporting the one or more un instrumented and referenced methods from the first application server to a central manager where the central manager pushes an identification of the one or more un instrumented and referenced methods to a second instance of the application at a second application server.

Another embodiment provides a tangible computer readable storage having computer readable software embodied thereon for programming at least one processor to perform a method for analyzing an application. The method performed includes instrumenting components in the application obtaining performance data from the instrumented components determining that performance data of at least one component of the instrumented components falls below a threshold performance level and in response to the determining triggering a process for identifying and instrumenting one or more components which are callable by the at least one component and which are currently un instrumented.

Corresponding methods systems and computer or processor readable storage devices which include a storage media encoded with instructions which when executed perform the methods provided herein may be provided.

The present invention provides a technique for analyzing software in which un instrumented components can be discovered and dynamically instrumented during a runtime of the software. Initially software such as an application can be configured with a baseline set of instrumented components such as methods. As the application runs performance data can be gathered from the instrumentation and it may be learned that the performance of some methods is below expectations or is otherwise an issue. To analyze the problem a technique can be used to discover any methods which are callable from a method at issue. In a particular implementation the callable methods are discovered by inspecting the byte code of loaded classes in a JAVA Virtual Machine JVM . A decision can then be made to instrument and or report the discovered methods. By selectively adding instrumentation additional performance data can be obtained from the discovered components to allow a deep diagnosis of a performance problem without initially requiring over inclusive instrumentation. Thus the goals of efficient and lightweight instrumentation can be achieved along with the capability for a deep diagnosis when needed.

For example a corporation running an enterprise application such as a web based e commerce application may employ a number of application servers at one location for load balancing. Requests from users such as from an example web browser of a user are received via the network cloud such as the Internet and can be routed to any of the application servers and . The web browser typically accesses the network cloud via an Internet Service Provider not shown. Agent software running on the application servers and denoted by Agent A and Agent A respectively gather information from an application middleware or other software running on the respective application servers and in one possible approach. For example such information may be obtained using instrumentation one example of which is byte code instrumentation. However the gathered data may be obtained in other ways as well. The agents essentially live in the computer system being monitored and provide a data acquisition point. The agents organize and optimize the data communicated to the manager .

Various approaches are known for instrumenting software to monitor its execution. For example as mentioned at the outset tracing may be used to track the execution of software. One example of tracing is discussed in U.S. Patent Application Publication No. 2004 0078691 titled Transaction Tracer published Apr. 22 2004 incorporated herein by reference. In one approach discussed therein object code or byte code of an application to be monitored is instrumented e.g. modified with probes. The probes measure specific pieces of information about the application without changing the application s business or other logic. Once the probes have been installed in the byte code of an application it is referred to as a managed application. The agent software receives information such as performance data from the probes and may communicate the information to another process such as at the manager or process the information locally such as to determine whether the information indicates an abnormal condition. For example the information from the probes may indicate performance data such as start and stop times of a transaction or other execution flow or of individual components within a transaction execution flow. This information can be compared to pre established criteria to determine if it within bounds. If the information is not within bounds the agent can report this fact to the manager so that appropriate troubleshooting can be performed. The agents and are typically aware of the software executing on the local application servers and respectively with which they are associated.

The manager can be provided on a separate computer system such as a workstation which communicates with a user interface such as a monitor to display information based on data received from the agents. See example displays in and . The manager can also access a database to store the data received from the agents. In the example provided the application servers can communicate with the manager without accessing the network cloud . For example the communication may occur via a local area network. In other designs the manager can receive data from the agents of a number of application servers via the network cloud . For instance some large organizations employ a central network operations center where one or more managers obtain data from a number of distributed agents at different geographic locations. To illustrate a web based e commerce enterprise might obtain agent data from servers at different geographic locations that receive customer orders from servers that process payments from servers at warehouses for tracking inventory and conveying orders and so forth. The manager and user interface display might be provided at a corporate headquarters location. Other applications which are not necessarily web based or involve retail or other sales can similarly employ agents and managers for managing their systems. For example a bank may use an application for processing checks and credit accounts. Moreover in addition to the multi computer system arrangements mentioned a single computer system can be monitored as well with one or more agents.

Further the functionality described herein may be implemented using hardware software or a combination of both hardware and software. For software one or more tangible processor readable storage devices having processor readable code embodied thereon for programming one or more processors may be used. The tangible processor readable storage devices can include computer readable media such as volatile and nonvolatile media removable and non removable media. For example tangible computer readable media may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Examples of tangible computer readable media include RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer. In alternative embodiments some or all of the software can be replaced by dedicated hardware including custom integrated circuits gate arrays FPGAs PLDs and special purpose processors. In one embodiment software stored on a storage device implementing one or more embodiments is used to program one or more processors. The one or more processors can be in communication with one or more tangible computer readable media storage devices peripherals and or communication interfaces.

Component oriented programming models are useful in allowing the programmer to assemble an application or other program from building blocks referred to as components. Each component can perform a specific function which fits in with an overall functionality of the software. Furthermore a component can call other components as well as calling itself in a recursive call so that a sequence of components is invoked in a program. The components are examples of resources in a computer system that are consumed or work that is done when a program executes. One example of a component oriented programming model is J2EE which can employ components such as a Java Server Page an Enterprise Java Bean a servlet and a Java Database Connectivity component. However other component oriented programming models may also be used such as those using Microsoft .NET components. Moreover the programming model need not be object oriented. In one approach the components are considered to be methods.

The specific example shown refers to a web based e commerce application which allows users to order items. The components correspond to business logic or e commerce steps in the application. In particular a component C provides a shopping cart which allows a user to select an item to purchase and to enter information such as the payment method e.g. type of credit card and credit card number and the shipping information e.g. the address to which the item is to be shipped and the method of shipping e.g. ground delivery or overnight air delivery. C calls a component CA to check an inventory to determine if the selected item is in stock. Once it is determined that the selected item is in stock C calls a component C which reserves the item so that it will not be sold to another user while the transaction is still pending. Once finished C calls a component C which checks the user s credit card information to authorize and validate the purchase. This typically involves communicating with an external server that is managed by a credit card clearinghouse. For example C can call a component CA which contacts a credit card service.

Once C successfully finishes thereby approving the purchase it calls a component C which adjusts an inventory by decrementing the quantity of the item which is purchased. C calls a component C which arranges for the item to be shipped such as by contacting a warehouse where a shipping label is printed and an operator is prompted to manually locate and pack the item. For example C can call a component CA which contacts a warehouse A and or a component CB which contacts a warehouse B.

Once the components C C have executed the execution path returns to C which calls an order completion component C to confirm the purchase to the user such as by providing an order confirmation number and a tracking number e.g. in a confirmation e mail or web page. The execution path can similarly return to C if the inventory is out of stock at CA or the credit card payment is unsuccessful at C . In one possible implementation C and C are Java Server Pages and C C are Enterprise JavaBeans.

Note that a first component can continue executing after calling another component which begins executing in an asynchronous multi thread or multi process mode or can temporarily pause until the called component has finished executing in a synchronous single thread or single process mode. For example C can pause while the components C C execute. Moreover a given component may be invoked more than once during a transaction. For example assume the user has purchased multiple items that are stored at different warehouses. In this case C may execute repeatedly contacting a different warehouse and or warehouse department for each item.

An example execution path includes the sequence C CA C C C CA C C C C C C C C and C . A host receives a request from a client and notes when C begins executing at t. Each transition in the sequence is noted by the agent based on instrumentation. C calls CA at t. CA completes executing at t. C calls C at t. C calls C at t. C calls CA at t. CA completes executing at t. C calls C at t. C calls C at t. C completes executing at t. C completes executing at t. At t C completes executing. C completes executing at t. C calls C at t. C completes executing at t. The host provides a response to the client at which time C completes executing at t. The host periodically reports time and transaction data to the central manager.

In this case CA is instrumented after it is discovered and the application continues to execute so that new performance data is gathered. The call stack position vs. time graph of is assumed to be same as in for simplicity although it represents different method invocation instances and the time t t of occurs after the time t t in . The graph indicates that C has called CA at t and CA executes until t so that the response time of CA is t t. This can provided an important aid in diagnosing and analyzing the application. For example it may be concluded that CA is the reason for the excessive execution time. The method discovery process can also determine that CB is callable from C. In the example of we may assume that CB has instrumentation added to it. However since it was not called in this example it can be concluded that CB is not reason for the excessive execution time. This is important diagnostic information which would otherwise be unavailable.

The registers includes a program counter pc which keeps track of where in the memory it should be executing instructions. The program counter identifies the next byte code to be executed. The frame register contains a pointer to the execution environment of the current method in the operand stack. The operand top optop register contains a pointer to the top of the operand stack and is used to evaluate arithmetic expressions. The variable vars register contains a pointer to local variables.

The operand stack supplies parameters to methods and operations and receives results back from them. All byte code instructions take operands from the stack operate on them and return results to the stack. The operand stack includes a stack frame of an executing method. The stack frame holds the state e.g. local variables and intermediate results of calculations for a particular invocation of a method. Specifically each JVM thread has a private JVM stack created at the same time as the thread. A JVM stack stores frames holds local variables and partial results and plays a part in method invocation and return. A frame is thus used to store data and partial results as well as to perform dynamic linking return values for methods and dispatch exceptions. A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes whether that completion is normal or abrupt it throws an uncaught exception . Frames are allocated from the JVM stack of the thread creating the frame. Each frame has its own array of local variables its own operand stack and a reference to the runtime constant pool of the class of the current method.

The heap or memory allocation pool is garbage collected. The heap is the runtime data area from which memory for all class instances and arrays is allocated. The heap is created on virtual machine start up and heap storage for objects is reclaimed by an automatic storage management system known as a garbage collector. Specifically each program running in the Java runtime environment has a garbage collected heap assigned to it. Moreover each class in the heap has a constant pool associated with it. Because constants do not change they are usually created at compile time. Items in the constant pool encode all the names used by any method in a particular class. The class contains a count of how many constants exist and an offset that specifies where a particular listing of constants begins within the class description.

The method area stores byte code instructions that are associated with methods in the compiled code and a symbol table which the execution environment needs for dynamic linking. Any debugging or additional information that might need to be associated with a method is stored in this area as well. The program counter always points to e.g. contains the address of some byte in the method area. The program counter is used to keep track of the thread of execution. After a byte code instruction has been executed the program counter will contain the address of the next instruction to execute.

The method area is shared among all JVM threads and stores per class structures such as the runtime constant pool field and method data and the code for methods and constructors including the special methods used in class and instance initialization and interface type initialization. The method area is created on virtual machine start up. A runtime constant pool is a per class or per interface runtime representation of the constant pool table in a class file. It contains several kinds of constants ranging from numeric literals known at compile time to method and field references that must be resolved at run time. Each runtime constant pool is allocated from the JVM s method area. The runtime constant pool for a class or interface is constructed when the class or interface is created by the JVM.

If the application byte code matches rules directives at a decision block the transformer adds probes in the form of tracer byte code. If the application byte code does not matches the rules at the decision block the transformer does not add instrumentation to the byte code. The transformer and the decision block may be considered to be part of a probe builder .

In this implementation the rules are a set of typically static rules that identify portions of the managed application which are to be instrumented. The rules are usually implemented when a class is defined in a virtual machine for the first time. A class can be loaded multiple times while being defined only once. For example there can be multiple class loaders loading the same class. Further components such as classes may be instrumented based on whether they are named a certain way whether they implement a certain interface whether they extend a certain subclass or super class and so forth. Such components are selected to be instrumented because it is believed they might provide performance data which is useful or otherwise interesting.

For instance a rule may indicate that all servlets should be instrumented since it is believed that at least some of the servlets may provide interesting data. In this case the rules may indicate that all components that are subclasses of the JAVA class HttpServlet should be instrumented. HttpServlet is an abstract class from which all servlets depend. However not all components can be instrumented and there is a tension in that over inclusive instrumentation results in excessive overhead costs and possibly impairing the operation of the application while under inclusive instrumentation results in the omission of important performance data.

Moreover the CLR is an implementation of a Common Language Infrastructure CLI which provides a language neutral platform for application development and execution including functions for exception handling garbage collection security and interoperability. The CLI includes the core class libraries Common Type System and the Common Intermediate Language CIL . As with JAVA byte code CIL is another example of intermediate byte code. JAVA and .NET provide example implementations only as other implementations are possible.

Here the process may be implemented by an agent in one possible approach. In one possible scenario some process in the .NET framework references a class by name and the CLR finds the class shows it to a transformer if any and uses the resultant CIL. In particular if the class matches rules at a decision block instrumentation is added. If the class does not match the rules at the decision block instrumentation is not added. The transformer and the decision block may be considered to be part of a probe builder .

Step includes identifying at least one method in an application to analyze. Further details are provided in . This can be at least one method which is already instrumented such as based on static rules which determine which components such as methods are to be instrumented when the components are loaded into the application as discussed in connection with . In another approach the at least one method may be instrumented after it is loaded into the application. The at least one method may be identified based on performance data for instance which indicates a performance problem with the at least one method. This identification can be performed by continuously monitoring the performance data and providing a report to a user on a user interface for instance. See e.g. . Performance data which is out of range based on comparison with preset limits can be automatically flagged. The user may then manually select one or more methods to instrument. In another possible approach the process is fully automated not requiring user intervention so that an identified method is automatically instrumented. Step includes checking a cache to determine if method calls of the at least one method are present. The cache can be within a virtual machine of the agent of the application server in which the application is running for instance.

Generally the cache may be provided for execution performance. When the application begins executing the cache is empty. Assume that the at least one method identified in step is called method doSomething . The process to retrieve its callable methods begins. The first thing we do is to look into the cache. If the callable methods are not in cache at decision step then steps to are performed to identify the callable methods and store them in cache. Step caches the method calls retrieved for doSomething using the following pseudo code cache.put classLoader of the class class where the doSomething method is defined doSomething callable method 1 callable method 2 . . . where classLoader of the class class where the doSomething method is defined doSomething is the key unequivocally identifying the method doSomething and the callable methods are the identified callable methods for doSomething . The next time that the procedure is activated for the method doSomething the cache will contain the information retrieved previously therefore we do not need to execute steps to anymore because we have the information on the method called in the cache. We retrieve the information by the key described above.

Thus if the callable methods of the at least one identified method of step are in the cache as one or more referenced methods at decision step then the one or more referenced methods can be reported and or instrumented at step as discussed further in connection with . If the callable methods of the at least one identified method of step are not in the cache at decision step then steps to are performed. Step determines a class of the at least one method through reflection. In one possible implementation this includes using the JAVA application programming interface API java.lang.instrument step . The at least one method may be considered to be an invoking method since it can invoke or call one or more callable methods. Step can include determining a class of the at least one method such as by fetching a JAVA class from among all loaded classes in memory e.g. in the JVM.

Step includes loading a byte code representation of the class such as from an original resource location from which the byte code was obtained. In an example implementation the JAVA class ClassLoader is used if available step . Note that a safety precaution can be enforced to limit the amount of code which is loaded in memory in step so that very large automatically generated classes will not overwhelm the memory.

Step includes parsing a byte code representation of each class obtained in step to identify one or more instances of an invoke byte code. In a particular implementation this includes identifying specific opcodes operation codes in the byte code representation of a class step . For instance four opcodes in the JAVA language identify a byte code which can invoke another method. Specifically the opcode for invokevirtual is decimal value 182 or hexadecimal value 0xb6 or b6 the opcode for invokespecial is decimal value 183 or hexadecimal value 0xb7 or b7 the opcode for invokestatic is decimal value 184 or hexadecimal value 0xb8 or b8 and the opcode for invokeinterface is decimal value 185 or hexadecimal value 0xb9 or b9 . The presence of any of these opcodes identifies callable methods.

It is also possible to limit step to detecting one or more specified opcodes but fewer than all possible opcodes. For instance it may be determined that an interface method is not of interest in which case only the opcodes for invokevirtual invokespecial and invokestatic but not invokeinterface are detected.

Step identifies one or more referenced methods based on the one or more instances of an invoke byte code. In an example implementation the one or more referenced methods are extracted from a constant pool of the class determined at step . Specifically step identifies indexes to entries in a constant pool table based on the opcodes and step identifies one or more referenced methods based on the indexes. Step stores the one or more referenced methods as a string in cache e.g. the called methods for doSomething . Step includes reporting and or instrumenting the one or more referenced methods as discussed further in connection with .

Note that the process of can be performed separately for each of a number of different methods at the same time or at different times.

The java.lang.instrument API is used to access all loaded classes to determine a particular class of the at least one method being analyzed in correspondence with steps and of . In one approach all loaded classes are provided in an array. Based on the class a class loader is used to access the resource to load class byte code for the class in correspondence with steps and of . The class byte code is parsed to identify one or more instance of opcodes and in correspondence with steps and of . Each opcode can have respective index bytes which are used to fetch a string of a method call from a constants pool in correspondence with steps and of .

A discovered component can include a dynamically updatable list of classes which should be instrumented. This list can change from time to time so that particular methods are instrumented for limited periods of time in which diagnosis is performed. The user interface may specify the time period or a default time period may be used. Thus a component can be redefined so that it transitions e.g. from not having instrumentation at one point in time to having instrumentation at another point in time. It is also possible to provide different types or levels of instrumentation e.g. a high level of instrumentation in which many aspects of the performance of a component are tracked and a low level of instrumentation in which only a few aspects of the performance of a component are tracked. Redefining a component can thus involve a transition to a different type of instrumentation.

Instrumentation can yield many types of performance metrics data including an average execution or response time of a component an invocation rate per second or per interval a count of invocations a concurrency metric indicating a number of invocations that have started but not finished per interval and a stalled metric indicating a number of invocations that have started whose method invocation times have exceeded a specific threshold per interval. Further the data can identify a garbage collection heap size a bandwidth metric indicating file and socket activity a number of threads system logs exceptions memory leaks and component interactions. The data can also identify which components are called by the instrumented component or which call the instrumented component. For instance in a controller architecture control flows in through a controller component which has control over which components are executed next and knows how often they are executing and how they are performing. The controller component can report via instrumentation on which un instrumented components are being frequently invoked and therefore are perhaps of interest and should be redefined to add instrumentation.

As mentioned it is possible to redefine a component to change its type of instrumentation. For example more instrumentation may be added when the existing instrumentation detects a problem e.g. due to one or more parameters being out of bounds. Also the additional instrumentation may be subsequently removed when the instrumentation establishes that a normal condition has returned. The removal could be performed based on a user command or automatically without user intervention.

Note that the discovered components user interface static list of components and performance monitor can be provided at the same location or at different locations. For example the user interface can be provided at the user interface host the discovered components and the static list of component can be provided at the application server or and the performance monitor may be associated with the manager which receives performance data from the agents and at the application servers and respectively.

The performance monitor provides an idea of what components are involved in a problem transaction and can determine whether these components could be causing or are causing issues and identify this information on the user interface .

The user interface allows a user to manually pick and choose which components including the discovered components are to be instrumented or not instrumented for instance. The type of instrumentation when different types are available could also be specified via the user interface.

The static list of components may include classes or other components which are to be instrumented when the application begins running. This may be a baseline list of components which are expected to yield important data. In one approach a list of the discovered components can be persisted so that the next time the system starts up the same components are instrumented. This allows the user to have constant data reporting and performance data from a component and provides a good way to allow the user to set up the environment.

A component can be redefined in different ways according to whether the component has already been incorporated into the application at runtime. If a component is not already incorporated into the application it can be incorporated normally by being loaded by the class loader such as in a JVM in one possible implementation. In other implementations such as those which use the .NET framework a class loader is not used.

When a component is loaded the transformer probe builder instruments the component if instructed e.g. in response to the user interface discovered components static list of component and performance monitor . A component which is already incorporated into the application but is not instrumented can be reincorporated into the application with instrumentation. For example the component can be removed from the application and reloaded during the runtime without restarting the virtual machine. To achieve this the JAVA redefineClass command is provided to the class loader with the component. The JAVA DEVELOPMENT KIT JDK version 1.5 or higher has a redefinition capability which uses this command. This command redefines a supplied set of classes using supplied class files. It operates on a set in order to allow interlocked changes to more than one class at the same time. Moreover if a redefined method has active stack frames those active frames continue to run the byte codes of the original method and the redefined method will be used on new invokes.

Redefining a component such as a class is analogous to restarting the virtual machine but only for that class. When a class is redefined if the class is already in existing method stacks it stays there. But for every new method invocation the new class is used. That is once it is redefined the new version is picked up.

When the transformer probe builder receives the redefined component it instruments the component if instructed to do so. The transformer probe builder could also add a specified type of instrumentation to the component.

After a discovered component has been instrumented and reincorporated into the application and the instrumentation is no longer need for diagnosis the component can be reincorporated into the application again but without instrumentation. This removal of instrumentation can be based on a user command a time out after a specified diagnosis period or other some other event. For instance the performance monitor may determine that performance data of the discovered component has been acceptable for a certain period of time or for number of invocations of the component. That is the performance monitor may determine that performance data of at least one method of the instrumented methods no longer fails to meet a threshold performance level. In response the performance monitor can issue a command such as redefineClass to remove the instrumentation.

The adding and removal of instrumentation can be done dynamically at runtime so that the virtual machine in which the byte code is executing does not have to be brought down and data from the instrumented components can be accessed immediately in the case of adding instrumentation .

Similarly the user can uncheck a checked box to indicate that instrumentation should be removed from a component. For specifying different types of instrumentation additional checkboxes or other user interface techniques may be used. Moreover when the user initially views the user interface the checkboxes can be pre checked or unchecked according to their current instrumentation status. In some cases a checkbox may be grayed out to indicate that the instrumentation status of a component cannot be changed e.g. so that instrumentation is not inadvertently removed from critical components.

The user may indicate that instrumentation should be added to certain discovered components based on e.g. observations of which components are involved in errors or have themselves generated an error prior troubleshooting experience and other factors.

The display region can be automatically populated with each of the components in the application using a hierarchical structure such as a tree which shows which components are under or called by another component. The display region depicts performance data such as transaction traces of the instrumented components based on the instrumentation for selected ones of the components in the region . For example components C C and CA are currently selected by a user as indicated by the underlining of the component names and corresponding performance data such as transaction traces is provided by curves and in region . The region can be populated with performance data provided from the agent to the central manager.

In some approaches the displayed information in region can be filtered so that only the discovered components are displayed. Moreover the user can expand nodes of the tree to view lower level components of a node.

Step includes running the application with the one or more instrumented methods. In practice the application may continue running with the one or more referenced methods which have instrumentation added. Step includes obtaining performance data for the one or more instrumented methods. Thus due to the additional of instrumentation performance data regarding the one or more discovered methods can now be obtained. This can be especially useful in diagnosing a problem involving the method. Step includes evaluating the performance data. This can be done automatically such as by comparing the performance data to an allowable range of values and setting a flag if the performance data is out of range or otherwise below a minimum level or above a maximum level. Step includes triggering a process for identifying and or instrumenting one or more methods which are callable by the one or more instrumented methods such as described in . That is an iterative technique can be performed in which there is a drill down to one level below an original method being analyzed to a child method. Subsequently if warranted by performance data of the child method or for other reasons a drill down can be performed to two levels below the original method being analyzed to a grandchild method or a child of the previous child method. The process can be repeated to analyze successively lower level methods in a hierarchy of methods.

In another possible approach the initial drill down can be to two or more levels below the original method being analyzed to both a child method and a grandchild method for instance. Instrumentation can be added to both the child method and a grandchild method at the same time. Performance data from this instrumentation can indicate whether a drill down to and instrumentation of a further level is warranted.

A report can be made via a user interface indicating that a rule indicated that the one or more referenced methods should not be instrumented. Step includes determining whether the one or more referenced methods are already instrumented. For instance in some cases a method may have instrumentation that is not activated in which case it is possible to activate the instrumentation. Also we may want to display to the user that a method has already been instrumented therefore if it does not see any information on it in the Transaction Components it is because it is not called. Step includes determining whether the one or more referenced methods are in an interface class. The user interface may report this fact and allow the user to provide a command to indicate whether the one or more referenced methods should be instrumented. In this case instrumentation involves instrumenting all implementing classes. This may be a significant amount of instrumentation which may not be desirable in some cases.

The information of steps to may be provided by the agent using reflection for each of the possible method calls. The information supports the user in determining whether to add instrumentation to the callable methods. The information can be obtained through reflection on the class retrieved from the array of loaded classes provided e.g. by the JAVA 5 Instrument API. This information can be cached for subsequent access to avoid consuming computational resources in re determining the information.

In an example process step reports the one or more referenced methods to a manager from a first agent associated with a first instance of an application. At step the manager pushes an identification of the one or more referenced methods to one or more other agents associated with one or more other instances of the application. At step the one or more other agents instrument the one or more other instances of the one or more referenced methods in the one or more other instances of the application.

The foregoing detailed description of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. The described embodiments were chosen in order to best explain the principles of the invention and its practical application to thereby enable others skilled in the art to best utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims appended hereto.

