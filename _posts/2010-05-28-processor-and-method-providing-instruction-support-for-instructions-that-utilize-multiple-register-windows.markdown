---

title: Processor and method providing instruction support for instructions that utilize multiple register windows
abstract: A processor including instruction support for large-operand instructions that use multiple register windows may issue, for execution, programmer-selectable instructions from a defined instruction set architecture (ISA). The processor may also include an instruction execution unit that, during operation, receives instructions for execution from the instruction fetch unit and executes a large-operand instruction defined within the ISA, where execution of the large-operand instruction is dependent upon a plurality of registers arranged within a plurality of register windows. The processor may further include control circuitry (which may be included within the fetch unit, the execution unit, or elsewhere within the processor) that determines whether one or more of the register windows depended upon by the large-operand instruction are not present. In response to determining that one or more of these register windows are not present, the control circuitry causes them to be restored.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08555038&OS=08555038&RS=08555038
owner: Oracle International Corporation
number: 08555038
owner_city: Redwood City
owner_country: US
publication_date: 20100528
---
This invention relates to processors and more particularly to the implementation of processor support for register windows.

Securing transactions and communications against tampering interception and unauthorized use has become a problem of increasing significance as new forms of electronic commerce and communication proliferate. For example many businesses provide customers with Internet based purchasing mechanisms such as web pages via which customers may convey order and payment details. Such details often include sensitive information that might be subject to misuse if intercepted by a third party.

To provide a measure of security for sensitive data cryptographic algorithms have been developed that may allow encryption of sensitive information before it is conveyed over an insecure channel. The information may then be decrypted and used by the receiver. However as the performance of generally available computer technology continues to increase e.g. due to development of faster microprocessors less sophisticated cryptographic algorithms become increasingly vulnerable to compromise.

Cryptographic algorithms are continually evolving to meet the threat posed by new types of attacks. In particular the use of increased key sizes may help bolster the security of a given algorithm for example by increasing its resistance to a brute force attack. However computational workload can increase dramatically as key sizes increase. For example the use of large key sizes may require an algorithm to perform arithmetic operations on operands that greatly exceed the typical operand size supported by general purpose processor hardware. Supporting such large operands presents various implementation challenges such as ensuring that the operands are present when they are needed for execution.

Various embodiments of a processor and method providing instruction support for instructions that use multiple register windows are disclosed. In an embodiment a processor includes an instruction fetch unit that during operation issues instructions for execution where the instructions are programmer selectable from a defined instruction set architecture ISA . The processor may also include an instruction execution unit that during operation receives instructions for execution from the instruction fetch unit and executes a large operand instruction defined within the ISA where execution of the large operand instruction is dependent upon a plurality of registers arranged within a plurality of register windows.

The processor may further include control circuitry which may be included within the fetch unit the execution unit or elsewhere within the processor that determines whether one or more of the register windows depended upon by the large operand instruction are not present. In response to determining that one or more of these register windows are not present the control circuitry causes them to be restored.

While the disclosure is susceptible to various modifications and alternative forms specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood however that the drawings and detailed description thereto are not intended to limit the disclosure to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present disclosure as defined by the appended claims.

In the following discussion instruction support for large operand instructions is explored. First an overview is provided of one type of multithreaded processor in which such instruction support may be provided. Next large operand instructions are discussed with particular reference to large operand multiplication. Particular embodiments of multiplier datapath and control logic are then described as well as embodiments of large operand multiplication instructions and their execution. Techniques for supporting large operand instructions that depend on multiple register windows are then explored. Finally an example system embodiment is discussed that includes a processor that may implement support for large operand instructions that depend on multiple register windows.

A block diagram illustrating an embodiment of a multithreaded processor is shown in . In the illustrated embodiment processor includes a number of processor cores which are also designated core 0 though core n. Various embodiments of processor may include varying numbers of cores such as 8 16 or any other suitable number. Each of cores is coupled to a corresponding L2 cache which in turn couple to L3 cache via a crossbar . Cores and L2 caches may be generically referred to either collectively or individually as core s and L2 cache s respectively.

Via crossbar and L3 cache cores may be coupled to a variety of devices that may be located externally to processor . In the illustrated embodiment one or more memory interface s may be configured to couple to one or more banks of system memory not shown . One or more coherent processor interface s may be configured to couple processor to other processors e.g. in a multiprocessor environment employing multiple units of processor . Additionally system interconnect couples cores to one or more peripheral interface s and network interface s . As described in greater detail below these interfaces may be configured to couple processor to various peripheral devices and networks.

Cores may be configured to execute instructions and to process data according to a particular instruction set architecture ISA . In an embodiment cores may be configured to implement a version of the SPARC ISA such as SPARC V9 UltraSPARC Architecture 2005 UltraSPARC Architecture 2007 or UltraSPARC Architecture 2009 for example. However in other embodiments it is contemplated that any desired ISA may be employed such as x86 32 bit or 64 bit versions PowerPC or MIPS for example.

In the illustrated embodiment each of cores may be configured to operate independently of the others such that all cores may execute in parallel. Additionally as described below in conjunction with the description of in some embodiments each of cores may be configured to execute multiple threads concurrently where a given thread may include a set of instructions that may execute independently of instructions from another thread. For example an individual software process such as an application may consist of one or more threads that may be scheduled for execution by an operating system. Such a core may also be referred to as a multithreaded MT core. In an embodiment each of cores may be configured to concurrently execute instructions from a variable number of threads up to eight concurrently executing threads. In a 16 core implementation processor could thus concurrently execute up to 128 threads. However in other embodiments it is contemplated that other numbers of cores may be provided and that cores may concurrently process different numbers of threads.

Additionally as described in greater detail below in some embodiments each of cores may be configured to execute certain instructions out of program order which may also be referred to herein as out of order execution or simply OOO. As an example of out of order execution for a particular thread there may be instructions that are subsequent in program order to a given instruction yet do not depend on the given instruction. If execution of the given instruction is delayed for some reason e.g. owing to a cache miss the later instructions may execute before the given instruction completes which may improve overall performance of the executing thread.

As shown in in an embodiment each core may have a dedicated corresponding L2 cache . In an embodiment L2 cache may be configured as a set associative writeback cache that is fully inclusive of first level cache state e.g. instruction and data caches within core . To maintain coherence with first level caches embodiments of L2 cache may implement a reverse directory that maintains a virtual copy of the first level cache tags. L2 cache may implement a coherence protocol e.g. the MESI protocol to maintain coherence with other caches within processor . In an embodiment L2 cache may enforce a Total Store Ordering TSO model of execution in which all store instructions from the same thread must complete in program order.

In various embodiments L2 cache may include a variety of structures configured to support cache functionality and performance. For example L2 cache may include a miss buffer configured to store requests that miss the L2 a fill buffer configured to temporarily store data returning from L3 cache a writeback buffer configured to temporarily store dirty evicted data and snoop copyback data and or a snoop buffer configured to store snoop requests received from L3 cache . In an embodiment L2 cache may implement a history based prefetcher that may attempt to analyze L2 miss behavior and correspondingly generate prefetch requests to L3 cache .

Crossbar may be configured to manage data flow between L2 caches and the shared L3 cache . In an embodiment crossbar may include logic such as multiplexers or a switch fabric for example that allows any L2 cache to access any bank of L3 cache and that conversely allows data to be returned from any L3 bank to any L2 cache . That is crossbar may be configured as an M to N crossbar that allows for generalized point to point communication. However in other embodiments other interconnection schemes may be employed between L2 caches and L3 cache . For example a mesh ring or other suitable topology may be utilized.

Crossbar may be configured to concurrently process data requests from L2 caches to L3 cache as well as data responses from L3 cache to L2 caches . In some embodiments crossbar may include logic to queue data requests and or responses such that requests and responses may not block other activity while waiting for service. Additionally in an embodiment crossbar may be configured to arbitrate conflicts that may occur when multiple L2 caches attempt to access a single bank of L3 cache or vice versa.

L3 cache may be configured to cache instructions and data for use by cores . In the illustrated embodiment L3 cache may be organized into eight separately addressable banks that may each be independently accessed such that in the absence of conflicts each bank may concurrently return data to a respective L2 cache . In some embodiments each individual bank may be implemented using set associative or direct mapped techniques. For example in an embodiment L3 cache may be an 8 megabyte MB cache where each 1 MB bank is 16 way set associative with a 64 byte line size. L3 cache may be implemented in some embodiments as a writeback cache in which written dirty data may not be written to system memory until a corresponding cache line is evicted. However it is contemplated that in other embodiments L3 cache may be configured in any suitable fashion. For example L3 cache may be implemented with more or fewer banks or in a scheme that does not employ independently accessible banks it may employ other bank sizes or cache geometries e.g. different line sizes or degrees of set associativity it may employ write through instead of writeback behavior and it may or may not allocate on a write miss. Other variations of L3 cache configuration are possible and contemplated.

In some embodiments L3 cache may implement queues for requests arriving from and results to be sent to crossbar . Additionally in some embodiments L3 cache may implement a fill buffer configured to store fill data arriving from memory interface a writeback buffer configured to store dirty evicted data to be written to memory and or a miss buffer configured to store L3 cache accesses that cannot be processed as simple cache hits e.g. L3 cache misses cache accesses matching older misses accesses such as atomic operations that may require multiple cache accesses etc. . L3 cache may variously be implemented as single ported or multiported i.e. capable of processing multiple concurrent read and or write accesses . In either case L3 cache may implement arbitration logic to prioritize cache access among various cache read and write requestors.

Not all external accesses from cores necessarily proceed through L3 cache . In the illustrated embodiment non cacheable unit NCU may be configured to process requests from cores for non cacheable data such as data from I O devices as described below with respect to peripheral interface s and network interface s .

Memory interface may be configured to manage the transfer of data between L3 cache and system memory for example in response to cache fill requests and data evictions. In some embodiments multiple instances of memory interface may be implemented with each instance configured to control a respective bank of system memory. Memory interface may be configured to interface to any suitable type of system memory such as Fully Buffered Dual Inline Memory Module FB DIMM Double Data Rate or Double Data Rate 2 3 or 4 Synchronous Dynamic Random Access Memory DDR DDR2 DDR3 DDR4 SDRAM or Rambus DRAM RDRAM for example. In some embodiments memory interface may be configured to support interfacing to multiple different types of system memory.

In the illustrated embodiment processor may also be configured to receive data from sources other than system memory. System interconnect may be configured to provide a central interface for such sources to exchange data with cores L2 caches and or L3 cache . In some embodiments system interconnect may be configured to coordinate Direct Memory Access DMA transfers of data to and from system memory. For example via memory interface system interconnect may coordinate DMA transfers between system memory and a network device attached via network interface or between system memory and a peripheral device attached via peripheral interface .

Processor may be configured for use in a multiprocessor environment with other instances of processor or other compatible processors. In the illustrated embodiment coherent processor interface s may be configured to implement high bandwidth direct chip to chip communication between different processors in a manner that preserves memory coherence among the various processors e.g. according to a coherence protocol that governs memory transactions .

Peripheral interface may be configured to coordinate data transfer between processor and one or more peripheral devices. Such peripheral devices may include for example and without limitation storage devices e.g. magnetic or optical media based storage devices including hard drives tape drives CD drives DVD drives etc. display devices e.g. graphics subsystems multimedia devices e.g. audio processing subsystems or any other suitable type of peripheral device. In an embodiment peripheral interface may implement one or more instances of a standard peripheral interface. For example an embodiment of peripheral interface may implement the Peripheral Component Interface Express PCI Express or PCIe standard according to generation 1.x 2.0 3.0 or another suitable variant of that standard with any suitable number of I O lanes. However it is contemplated that any suitable interface standard or combination of standards may be employed. For example in some embodiments peripheral interface may be configured to implement a version of Universal Serial Bus USB protocol or IEEE 1394 Firewire protocol in addition to or instead of PCI Express .

Network interface may be configured to coordinate data transfer between processor and one or more network devices e.g. networked computer systems or peripherals coupled to processor via a network. In an embodiment network interface may be configured to perform the data processing necessary to implement an Ethernet IEEE 802.3 networking standard such as Gigabit Ethernet or 10 Gigabit Ethernet for example. However it is contemplated that any suitable networking standard may be implemented including forthcoming standards such as 40 Gigabit Ethernet and 100 Gigabit Ethernet. In some embodiments network interface may be configured to implement other types of networking protocols such as Fibre Channel Fibre Channel over Ethernet FCoE Data Center Ethernet Infiniband and or other suitable networking protocols. In some embodiments network interface may be configured to implement multiple discrete network interface ports.

As mentioned above in an embodiment each of cores may be configured for multithreaded out of order execution. More specifically in an embodiment each of cores may be configured to perform dynamic multithreading. Generally speaking under dynamic multithreading the execution resources of cores may be configured to efficiently process varying types of computational workloads that exhibit different performance characteristics and resource requirements. Such workloads may vary across a continuum that emphasizes different combinations of individual thread and multiple thread performance.

At one end of the continuum a computational workload may include a number of independent tasks where completing the aggregate set of tasks within certain performance criteria e.g. an overall number of tasks per second is a more significant factor in system performance than the rate at which any particular task is completed. For example in certain types of server or transaction processing environments there may be a high volume of individual client or customer requests such as web page requests or file system accesses . In this context individual requests may not be particularly sensitive to processor performance. For example requests may be I O bound rather than processor bound completion of an individual request may require I O accesses e.g. to relatively slow memory network or storage devices that dominate the overall time required to complete the request relative to the processor effort involved. Thus a processor that is capable of concurrently processing many such tasks e.g. as independently executing threads may exhibit better performance on such a workload than a processor that emphasizes the performance of only one or a small number of concurrent tasks.

At the other end of the continuum a computational workload may include individual tasks whose performance is highly processor sensitive. For example a task that involves significant mathematical analysis and or transformation e.g. cryptography graphics processing scientific computing may be more processor bound than I O bound. Such tasks may benefit from processors that emphasize single task performance for example through speculative execution and exploitation of instruction level parallelism.

Dynamic multithreading represents an attempt to allocate processor resources in a manner that flexibly adapts to workloads that vary along the continuum described above. In an embodiment cores may be configured to implement fine grained multithreading in which each core may select instructions to execute from among a pool of instructions corresponding to multiple threads such that instructions from different threads may be scheduled to execute adjacently. For example in a pipelined embodiment of core employing fine grained multithreading instructions from different threads may occupy adjacent pipeline stages such that instructions from several threads may be in various stages of execution during a given core processing cycle. Through the use of fine grained multithreading cores may be configured to efficiently process workloads that depend more on concurrent thread processing than individual thread performance.

In an embodiment cores may also be configured to implement out of order processing speculative execution register renaming and or other features that improve the performance of processor dependent workloads. Moreover cores may be configured to dynamically allocate a variety of hardware resources among the threads that are actively executing at a given time such that if fewer threads are executing each individual thread may be able to take advantage of a greater share of the available hardware resources. This may result in increased individual thread performance when fewer threads are executing while retaining the flexibility to support workloads that exhibit a greater number of threads that are less processor dependent in their performance. In various embodiments the resources of a given core that may be dynamically allocated among a varying number of threads may include branch resources e.g. branch predictor structures load store resources e.g. load store buffers and queues instruction completion resources e.g. reorder buffer structures and commit logic instruction issue resources e.g. instruction selection and scheduling structures register rename resources e.g. register mapping tables and or memory management unit resources e.g. translation lookaside buffers page walk resources .

An embodiment of core that is configured to perform dynamic multithreading is illustrated in . In the illustrated embodiment core includes an instruction fetch unit IFU that includes an instruction cache . IFU is coupled to a memory management unit MMU L2 interface and trap logic unit TLU . IFU is additionally coupled to an instruction processing pipeline that begins with a select unit and proceeds in turn through a decode unit a rename unit a pick unit and an issue unit . Issue unit is coupled to issue instructions to any of a number of instruction execution resources an execution unit 0 EXU0 an execution unit 1 EXU1 a load store unit LSU that includes a data cache and or a floating point graphics unit FGU . These instruction execution resources are coupled to a working register file . Additionally LSU is coupled to L2 interface and MMU .

In the following discussion exemplary embodiments of each of the structures of the illustrated embodiment of core are described. However it is noted that the illustrated partitioning of resources is merely one example of how core may be implemented. Alternative configurations and variations are possible and contemplated.

Instruction fetch unit may be configured to provide instructions to the rest of core for execution. In an embodiment IFU may be configured to select a thread to be fetched fetch instructions from instruction cache for the selected thread and buffer them for downstream processing request data from L2 cache in response to instruction cache misses and predict the direction and target of control transfer instructions e.g. branches . In some embodiments IFU may include a number of data structures in addition to instruction cache such as an instruction translation lookaside buffer ITLB instruction buffers and or structures configured to store state that is relevant to thread selection and processing.

In an embodiment during each execution cycle of core IFU may be configured to select one thread that will enter the IFU processing pipeline. Thread selection may take into account a variety of factors and conditions some thread specific and others IFU specific. For example certain instruction cache activities e.g. cache fill ITLB activities or diagnostic activities may inhibit thread selection if these activities are occurring during a given execution cycle. Additionally individual threads may be in specific states of readiness that affect their eligibility for selection. For example a thread for which there is an outstanding instruction cache miss may not be eligible for selection until the miss is resolved. In some embodiments those threads that are eligible to participate in thread selection may be divided into groups by priority for example depending on the state of the thread or of the ability of the IFU pipeline to process the thread. In such embodiments multiple levels of arbitration may be employed to perform thread selection selection occurs first by group priority and then within the selected group according to a suitable arbitration algorithm e.g. a least recently fetched algorithm . However it is noted that any suitable scheme for thread selection may be employed including arbitration schemes that are more complex or simpler than those mentioned here.

Once a thread has been selected for fetching by IFU instructions may actually be fetched for the selected thread. To perform the fetch in an embodiment IFU may be configured to generate a fetch address to be supplied to instruction cache . In various embodiments the fetch address may be generated as a function of a program counter associated with the selected thread a predicted branch target address or an address supplied in some other manner e.g. through a test or diagnostic mode . The generated fetch address may then be applied to instruction cache to determine whether there is a cache hit.

In some embodiments accessing instruction cache may include performing fetch address translation e.g. in the case of a physically indexed and or tagged cache accessing a cache tag array and comparing a retrieved cache tag to a requested tag to determine cache hit status. If there is a cache hit IFU may store the retrieved instructions within buffers for use by later stages of the instruction pipeline. If there is a cache miss IFU may coordinate retrieval of the missing cache data from L2 cache . In some embodiments IFU may also be configured to prefetch instructions into instruction cache before the instructions are actually required to be fetched. For example in the case of a cache miss IFU may be configured to retrieve the missing data for the requested fetch address as well as addresses that sequentially follow the requested fetch address on the assumption that the following addresses are likely to be fetched in the near future.

In many ISAs instruction execution proceeds sequentially according to instruction addresses e.g. as reflected by one or more program counters . However control transfer instructions CTIs such as branches call return instructions or other types of instructions may cause the transfer of execution from a current fetch address to a nonsequential address. As mentioned above IFU may be configured to predict the direction and target of CTIs or in some embodiments a subset of the CTIs that are defined for an ISA in order to reduce the delays incurred by waiting until the effect of a CTI is known with certainty. In an embodiment IFU may be configured to implement a perceptron based dynamic branch predictor although any suitable type of branch predictor may be employed.

To implement branch prediction IFU may implement a variety of control and data structures in various embodiments such as history registers that track prior branch history weight tables that reflect relative weights or strengths of predictions and or target data structures that store fetch addresses that are predicted to be targets of a CTI. Also in some embodiments IFU may further be configured to partially decode or predecode fetched instructions in order to facilitate branch prediction. A predicted fetch address for a given thread may be used as the fetch address when the given thread is selected for fetching by IFU . The outcome of the prediction may be validated when the CTI is actually executed e.g. if the CTI is a conditional instruction or if the CTI itself is in the path of another predicted CTI . If the prediction was incorrect instructions along the predicted path that were fetched and issued may be cancelled.

Through the operations discussed above IFU may be configured to fetch and maintain a buffered pool of instructions from one or multiple threads to be fed into the remainder of the instruction pipeline for execution. Generally speaking select unit may be configured to select and schedule threads for execution. In an embodiment during any given execution cycle of core select unit may be configured to select up to one ready thread out of the maximum number of threads concurrently supported by core e.g. 8 threads and may select up to two instructions from the selected thread for decoding by decode unit although in other embodiments a differing number of threads and instructions may be selected. In various embodiments different conditions may affect whether a thread is ready for selection by select unit such as branch mispredictions unavailable instructions or other conditions. To ensure fairness in thread selection some embodiments of select unit may employ arbitration among ready threads e.g. a least recently used algorithm .

The particular instructions that are selected for decode by select unit may be subject to the decode restrictions of decode unit thus in any given cycle fewer than the maximum possible number of instructions may be selected. Additionally in some embodiments select unit may be configured to allocate certain execution resources of core to the selected instructions so that the allocated resources will not be used for the benefit of another instruction until they are released. For example select unit may allocate resource tags for entries of a reorder buffer load store buffers or other downstream resources that may be utilized during instruction execution.

Generally decode unit may be configured to prepare the instructions selected by select unit for further processing. Decode unit may be configured to identify the particular nature of an instruction e.g. as specified by its opcode and to determine the source and sink i.e. destination registers encoded in an instruction if any. In some embodiments decode unit may be configured to detect certain dependencies among instructions to remap architectural registers to a flat register space and or to convert certain complex instructions to two or more simpler instructions for execution. Additionally in some embodiments decode unit may be configured to assign instructions to slots for subsequent scheduling. In an embodiment two slots 0 1 may be defined where slot 0 includes instructions executable in load store unit or execution units and where slot 1 includes instructions executable in execution units floating point graphics unit and any branch instructions. However in other embodiments other numbers of slots and types of slot assignments may be employed or slots may be omitted entirely.

Register renaming may facilitate the elimination of certain dependencies between instructions e.g. write after read or false dependencies which may in turn prevent unnecessary serialization of instruction execution. In an embodiment rename unit may be configured to rename the logical i.e. architected destination registers specified by instructions by mapping them to a physical register space resolving false dependencies in the process. In some embodiments rename unit may maintain mapping tables that reflect the relationship between logical registers and the physical registers to which they are mapped.

Once decoded and renamed instructions may be ready to be scheduled for execution. In the illustrated embodiment pick unit may be configured to pick instructions that are ready for execution and send the picked instructions to issue unit . In an embodiment pick unit may be configured to maintain a pick queue that stores a number of decoded and renamed instructions as well as information about the relative age and status of the stored instructions. During each execution cycle this embodiment of pick unit may pick up to one instruction per slot. For example taking instruction dependency and age information into account for a given slot pick unit may be configured to pick the oldest instruction for the given slot that is ready to execute.

In some embodiments pick unit may be configured to support load store speculation by retaining speculative load store instructions and in some instances their dependent instructions after they have been picked. This may facilitate replaying of instructions in the event of load store misspeculation. Additionally in some embodiments pick unit may be configured to deliberately insert holes into the pipeline through the use of stalls e.g. in order to manage downstream pipeline hazards such as synchronization of certain load store or long latency FGU instructions.

Issue unit may be configured to provide instruction sources and data to the various execution units for picked instructions. In an embodiment issue unit may be configured to read source operands from the appropriate source which may vary depending upon the state of the pipeline. For example if a source operand depends on a prior instruction that is still in the execution pipeline the operand may be bypassed directly from the appropriate execution unit result bus. Results may also be sourced from register files representing architectural i.e. user visible as well as non architectural state. In the illustrated embodiment core includes a working register file that may be configured to store instruction results e.g. integer results floating point results and or condition code results that have not yet been committed to architectural state and which may serve as the source for certain operands. The various execution units may also maintain architectural integer floating point and condition code state from which operands may be sourced.

Instructions issued from issue unit may proceed to one or more of the illustrated execution units for execution. In an embodiment each of EXU0 and EXU1 may be similarly or identically configured to execute certain integer type instructions defined in the implemented ISA such as arithmetic logical and shift instructions. In the illustrated embodiment EXU0 may be configured to execute integer instructions issued from slot 0 and may also perform address calculation for load store instructions executed by LSU . EXU1 may be configured to execute integer instructions issued from slot 1 as well as branch instructions. In an embodiment FGU instructions and multicycle integer instructions may be processed as slot 1 instructions that pass through the EXU1 pipeline although some of these instructions may actually execute in other functional units.

In some embodiments architectural and non architectural register files may be physically implemented within or near execution units . It is contemplated that in some embodiments core may include more or fewer than two integer execution units and the execution units may or may not be symmetric in functionality. Also in some embodiments execution units may not be bound to specific issue slots or may be differently bound than just described.

Load store unit may be configured to process data memory references such as integer and floating point load and store instructions and other types of memory reference instructions. LSU may include a data cache as well as logic configured to detect data cache misses and to responsively request data from L2 cache . In an embodiment data cache may be configured as a set associative write through cache in which all stores are written to L2 cache regardless of whether they hit in data cache . As noted above the actual computation of addresses for load store instructions may take place within one of the integer execution units though in other embodiments LSU may implement dedicated address generation logic. In some embodiments LSU may implement an adaptive history dependent hardware prefetcher configured to predict and prefetch data that is likely to be used in the future in order to increase the likelihood that such data will be resident in data cache when it is needed.

In various embodiments LSU may implement a variety of structures configured to facilitate memory operations. For example LSU may implement a data TLB to cache virtual data address translations as well as load and store buffers configured to store issued but not yet committed load and store instructions for the purposes of coherency snooping and dependency checking LSU may include a miss buffer configured to store outstanding loads and stores that cannot yet complete for example due to cache misses. In an embodiment LSU may implement a store queue configured to store address and data information for stores that have committed in order to facilitate load dependency checking. LSU may also include hardware configured to support atomic load store instructions memory related exception detection and read and write access to special purpose registers e.g. control registers .

Floating point graphics unit may be configured to execute and provide results for certain floating point and graphics oriented instructions defined in the implemented ISA. For example in an embodiment FGU may implement single and double precision floating point arithmetic instructions compliant with the IEEE 754 1985 floating point standard such as add subtract multiply divide and certain transcendental functions. Also in an embodiment FGU may implement partitioned arithmetic and graphics oriented instructions defined by a version of the SPARC Visual Instruction Set VIS architecture such as VIS 2.0 or VIS 3.0. In some embodiments FGU may implement fused and unfused floating point multiply add instructions. Additionally in an embodiment FGU may implement certain integer instructions such as integer multiply divide and population count instructions. Depending on the implementation of FGU some instructions e.g. some transcendental or extended precision instructions or instruction operand or result scenarios e.g. certain denormal operands or expected results may be trapped and handled or emulated by software.

In an embodiment FGU may implement separate execution pipelines for floating point add multiply divide square root and graphics operations while in other embodiments the instructions implemented by FGU may be differently partitioned. In various embodiments instructions implemented by FGU may be fully pipelined i.e. FGU may be capable of starting one new instruction per execution cycle partially pipelined or may block issue until complete depending on the instruction type. For example in an embodiment floating point add and multiply operations may be fully pipelined while floating point divide operations may block other divide square root operations until completed.

Embodiments of FGU may also be configured to implement hardware cryptographic support. For example FGU may include logic configured to support encryption decryption algorithms such as Advanced Encryption Standard AES Data Encryption Standard Triple Data Encryption Standard DES 3DES the Kasumi block cipher algorithm and or the Camellia block cipher algorithm. FGU may also include logic to implement hash or checksum algorithms such as Secure Hash Algorithm SHA 1 SHA 256 SHA 384 SHA 512 or Message Digest 5 MD5 . FGU may also be configured to implement modular arithmetic such as modular multiplication reduction and exponentiation as well as various types of Galois field operations. In an embodiment FGU may be configured to utilize the floating point multiplier array for modular multiplication. In various embodiments FGU may implement several of the aforementioned algorithms as well as other algorithms not specifically described.

The various cryptographic and modular arithmetic operations provided by FGU may be invoked in different ways for different embodiments. In an embodiment these features may be implemented via a discrete coprocessor that may be indirectly programmed by software for example by using a control word queue defined through the use of special registers or memory mapped registers. In another embodiment the ISA may be augmented with specific instructions that may allow software to directly perform these operations.

As previously described instruction and data memory accesses may involve translating virtual addresses to physical addresses. In an embodiment such translation may occur on a page level of granularity where a certain number of address bits comprise an offset into a given page of addresses and the remaining address bits comprise a page number. For example in an embodiment employing 4 MB pages a 64 bit virtual address and a 40 bit physical address 22 address bits corresponding to 4 MB of address space and typically the least significant address bits may constitute the page offset. The remaining 42 bits of the virtual address may correspond to the virtual page number of that address and the remaining 18 bits of the physical address may correspond to the physical page number of that address. In such an embodiment virtual to physical address translation may occur by mapping a virtual page number to a particular physical page number leaving the page offset unmodified.

Such translation mappings may be stored in an ITLB or a DTLB for rapid translation of virtual addresses during lookup of instruction cache or data cache . In the event no translation for a given virtual page number is found in the appropriate TLB memory management unit may be configured to provide a translation. In an embodiment MMU may be configured to manage one or more translation tables stored in system memory and to traverse such tables which in some embodiments may be hierarchically organized in response to a request for an address translation such as from an ITLB or DTLB miss. Such a traversal may also be referred to as a page table walk or a hardware table walk. In some embodiments if MMU is unable to derive a valid address translation for example if one of the memory pages including a necessary page table is not resident in physical memory i.e. a page miss MMU may be configured to generate a trap to allow a memory management software routine to handle the translation. It is contemplated that in various embodiments any desirable page size may be employed. Further in some embodiments multiple page sizes may be concurrently supported.

As noted above several functional units in the illustrated embodiment of core may be configured to generate off core memory requests. For example IFU and LSU each may generate access requests to L2 cache in response to their respective cache misses. Additionally MMU may be configured to generate memory requests for example while executing a page table walk. In the illustrated embodiment L2 interface may be configured to provide a centralized interface to the L2 cache associated with a particular core on behalf of the various functional units that may generate L2 accesses. In an embodiment L2 interface may be configured to maintain queues of pending L2 requests and to arbitrate among pending requests to determine which request or requests may be conveyed to L2 cache during a given execution cycle. For example L2 interface may implement a least recently used or other algorithm to arbitrate among L2 requestors. In an embodiment L2 interface may also be configured to receive data returned from L2 cache and to direct such data to the appropriate functional unit e.g. to data cache for a data cache fill due to miss .

During the course of operation of some embodiments of core exceptional events may occur. For example an instruction from a given thread that is selected for execution by select unit may be not be a valid instruction for the ISA implemented by core e.g. the instruction may have an illegal opcode a floating point instruction may produce a result that requires further processing in software MMU may not be able to complete a page table walk due to a page miss a hardware error such as uncorrectable data corruption in a cache or register file may be detected or any of numerous other possible architecturally defined or implementation specific exceptional events may occur. In an embodiment trap logic unit may be configured to manage the handling of such events. For example TLU may be configured to receive notification of an exceptional event occurring during execution of a particular thread and to cause execution control of that thread to vector to a supervisor mode software handler i.e. a trap handler corresponding to the detected event. Such handlers may include for example an illegal opcode trap handler configured to return an error status indication to an application associated with the trapping thread and possibly terminate the application a floating point trap handler configured to fix up an inexact result etc.

In an embodiment TLU may be configured to flush all instructions from the trapping thread from any stage of processing within core without disrupting the execution of other non trapping threads. In some embodiments when a specific instruction from a given thread causes a trap as opposed to a trap causing condition independent of instruction execution such as a hardware interrupt request TLU may implement such traps as precise traps. That is TLU may ensure that all instructions from the given thread that occur before the trapping instruction in program order complete and update architectural state while no instructions from the given thread that occur after the trapping instruction in program order complete or update architectural state.

Additionally in the absence of exceptions or trap requests TLU may be configured to initiate and monitor the commitment of working results to architectural state. For example TLU may include a reorder buffer ROB that coordinates transfer of speculative results into architectural state. TLU may also be configured to coordinate thread flushing that results from branch misprediction. For instructions that are not flushed or otherwise cancelled due to mispredictions or exceptions instruction processing may end when instruction results have been committed.

In various embodiments any of the units illustrated in may be implemented as one or more pipeline stages to form an instruction execution pipeline that begins when thread fetching occurs in IFU and ends with result commitment by TLU . Depending on the manner in which the functionality of the various units of is partitioned and implemented different units may require different numbers of cycles to complete their portion of instruction processing. In some instances certain units e.g. FGU may require a variable number of cycles to complete certain types of operations.

Through the use of dynamic multithreading in some instances it is possible for each stage of the instruction pipeline of core to hold an instruction from a different thread in a different stage of execution in contrast to conventional processor implementations that typically require a pipeline flush when switching between threads or processes. In some embodiments flushes and stalls due to resource conflicts or other scheduling hazards may cause some pipeline stages to have no instruction during a given cycle. However in the fine grained multithreaded processor implementation employed by the illustrated embodiment of core such flushes and stalls may be directed to a single thread in the pipeline leaving other threads undisturbed. Additionally even if one thread being processed by core stalls for a significant length of time for example due to an L2 cache miss instructions from another thread may be readily selected for issue thus increasing overall thread processing throughput.

As described previously however the various resources of core that support fine grained multithreaded execution may also be dynamically reallocated to improve the performance of workloads having fewer numbers of threads. Under these circumstances some threads may be allocated a larger share of execution resources while other threads are allocated correspondingly fewer resources. Even when fewer threads are sharing comparatively larger shares of execution resources however core may still exhibit the flexible thread specific flush and stall behavior described above.

As noted above in some embodiments FGU may be configured to provide hardware support for cryptographic operations including encryption decryption and hashing algorithms. Certain types of cryptographic operations may perform operations on operand values that are significantly larger than the width of the datapath provided by core . For example the Rivest Shamir Adleman RSA public key cryptographic algorithm may employ lengthy cipher keys having 1024 2048 4096 or other numbers of bits. During its course of operation the RSA algorithm may perform modular exponentiation operations on operands that may be at least as wide as the cipher key. These operations may be implemented using integer multiplication necessitating multiplication of 1024 bit or larger operands. Other types of cryptographic algorithms such as Elliptic Curve Cryptography ECC may similarly require multiplication of large operands.

However as the width of the input operands increases the implementation cost of a hardware multiplier in terms of e.g. die area and power consumption typically grows by at least the square of the operand width. Thus it is uncommon for a processor to provide hardware support for multiplication of operands larger than 64 or 128 bits. As described in greater detail below multiplication of large operands as used herein operands that are wider than the processor hardware natively supports may be accomplished through repeated application of the multiplication operations actually implemented by the processor. Multiplication of large operands may also be referred to herein as multiple precision multiplication.

In some embodiments a processor may implement a single large operand multiplication by executing an instruction sequence that includes multiple instances of instructions defined within the processor s ISA. In these embodiments to perform a large operand multiplication a programmer may define an appropriate sequence of instructions that may be fetched from memory and executed by the processor such that upon completion of the sequence the multiplication result is complete. For example the processor s ISA may define general purpose integer instructions such as integer multiply shift arithmetic and Boolean operations that may be individually issued for execution. In some embodiments the processor s ISA may define special purpose instructions designed to facilitate the particular task of large operand multiplication. For example an individual special purpose instruction might combine several aspects of multiply shift and add operations that are specific to the context of large operand multiplication. As a result a sequence of special purpose instructions that is configured to implement a large operand multiplication may be shorter than an equivalent sequence of general purpose instructions and thus may typically execute more quickly than the latter sequence.

Processors that rely on sequences of executable instructions to implement large operand multiplication may present certain implementation challenges particularly in processor embodiments that support multithreaded speculative out of order execution of instructions. For example it may be difficult for scheduling hardware to ensure that the multiple instructions execute in a consistent manner with respect to architectural state while ensuring that the performance of other threads is not unduly affected. In the following discussion embodiments of core are described that are configured to provide single instruction support for large operand multiplication. That is in the described embodiments a large operand multiplication may be accomplished through execution of a single instruction in a manner that is analogous from a programmer s perspective to execution of an ordinary integer or floating point multiplication using the native operand width supported by the multiplier hardware. In some embodiments as discussed below core may be configured to provide single instruction support for large operand multiplications having varying operand widths e.g. for operands that are some multiple of 64 bits . Such an instruction may also be referred to as a multiple precision multiplication or MPMUL instruction.

Broadly speaking in various embodiments multiplier datapath may include a variety of logic elements configured to produce a multiplicative result from input data operands. For example as discussed in greater detail below multiplier datapath may include logic elements configured to generate partial products from multiplicand and multiplier operands e.g. according to a Booth recoding technique or another suitable technique as well as logic elements configured to accumulate the generated partial products into a resultant product e.g. through the use of a Wallace tree or another type of adder accumulator architecture .

In various embodiments MPMUL control logic may include state machines microcode or other control structures configured to coordinate the operation of multiplier datapath during large operand multiplications. For example MPMUL control logic may be configured to coordinate the sequencing of successive multiplication operations the retrieval of operands from other sources within core e.g. register files and the storage of results within architecturally visible state.

Prior to exploring particular embodiments of multiplier datapath and MPMUL control logic it is helpful to examine the dataflow characteristics of large operand multiplications. As an example consider the multiplication of two 512 bit operands A and B where each operand includes 8 64 bit words denoted A7 through A0 and B7 through B0 and where 7 and 0 denote the most and least significant words respectively. Generally speaking the term word is used herein to denote the largest input operand multiplier datapath is capable of receiving during its operation. That is an instance of multiplier datapath having a word size of M bits is capable of multiplying operands having at most a maximum number of bits M. For example if multiplier datapath is configured to implement multiplication of 64 bit operands then a word corresponds to a 64 bit quantity.

In a full precision hardware multiplier most or all partial products might be generated concurrently and then the resultant array of partial products would be accumulated in parallel to generate the resultant product. However by definition a large operand multiplication exceeds the full precision of the available hardware multiplier. Thus adopting a similar approach as the full precision multiplier in which partial products are fully generated and then accumulated may result in a considerable amount of data movement.

A more efficient implementation for large operand multiplication may result from a column oriented accumulation technique. Assume for example that the available hardware multiplier supports multiplication of 64 bit operands to produce a 128 bit product. Starting with the rightmost value in the partial product array shown above the least significant 64 bits of the large operand product may be determined from the lower 64 bits of the 128 bit product A0B0. The next 64 bits of the large operand product may be determined from the lower 64 bits of the sum of the 128 bit products A1B0 and A0B1 summed with the upper 64 bits that effectively carried out of product A0B0.

This process may generally proceed in a columnar fashion where word k of the resultant product may be determined from the sum of the products AiBj where i j k plus the most significant bits carried out of column k 1. In this approach the large operand product may be determined from least significant word to most significant word where any given column k depends only on column k 1.

It is noted that timing elements such as latches or pipeline registers are not specifically shown in but may be included in various embodiments of multiplier datapath . The placement of timing elements relative to other datapath structures may vary depending on factors such as the targeted operating frequency of the processor the electrical characteristics of the process technology used to construct the physical circuits testability concerns and or other design considerations. In addition to the features described below numerous examples of particular circuits and logic configurations that may be employed within or in connection with various embodiments of multiplier datapath may be found in U.S. Patent Application Publication No. 2004 0267855 naming Shantz et al. as inventors filed on Feb. 27 2004 and published on Dec. 30 2004 which is hereby incorporated by reference in its entirety. However to the extent that there exists any conflict between the incorporated application and this specification it is intended that this specification control.

Partial product generation logic may generally be configured to generate partial products from the multiplier and multiplicand operands according to any suitable technique. For example a given partial product that corresponds to a particular bit of the multiplier operand may be generated by shifting the multiplicand left so that the LSB of the shifted multiplicand aligns with the particular bit of the multiplier and multiplying the shifted multiplicand by the value of the particular bit of the multiplier e.g. 0 or 1 . In other embodiments partial product generation logic may implement a radix 4 Booth encoding that may reduce the total number of partial products required to be generated for a given multiplication.

CSAs may be configured to accumulate the partial products generated by partial product generation logic . Generally speaking an N M CSA is an adder circuit that is configured to receive N input bits count them and output the result as an M bit value. For example a 4 2 CSA may be configured to receive 4 input bits and to produce a 2 bit output value as well as a carry out to the next most significant bit position. In some embodiments CSAs may be configured as a Wallace tree although any suitable configuration of CSAs may be employed. Also in some embodiments CSAs may be configured to accumulate a third operand not shown in addition to the generated partial products. For example in embodiments that support multiply accumulate operation two input operands may correspond to the multiplier and multiplicand while the third operand may correspond to the value to be accumulated with the product of the first two.

In many embodiments CSAs may be configured to reduce the several partial products to a pair of values that when added together in an adder such as fast adder yield the final multiplicative product. This pair of values may also be referred to as a sum and carry representation. In various embodiments fast adder may be implemented according to any suitable organization such as a carry lookahead adder CLA for example.

It is noted that in some embodiments multiplier datapath may be configured to perform multiplication over binary fields e.g. Galois field multiplication in addition to multiplication over ordinary integer fields. In a binary field mode of operation addition of two operands may be performed by a bitwise exclusive OR XOR operation between the operands i.e. without carrying any values across bit positions . Binary field multiplication may be performed in a manner similar to integer multiplication except that during binary field multiplication partial products may be accumulated using bitwise XOR operations i.e. without carrying any values across columns of bits . Thus in some embodiments CSAs may be configured to support a binary field mode of partial product accumulation during which carries out of a given bit position within CSAs are suppressed. Other elements of multiplier datapath such as e.g. fast adder may be similarly configured to perform field arithmetic rather than integer arithmetic during a binary field mode of operation for example by suppressing carries between adjacent bits within fast adder . The optional MPXMUL control signal is shown as an input to partial product generation logic CSAs MPMUL CSA and fast adder such that when this signal is asserted the controlled elements perform binary field operations rather than integer field operations. However it is noted that binary field capability may be omitted from embodiments of multiplier datapath .

In the illustrated embodiment processing of the output of CSAs prior to the operation of fast adder depends upon the status of several control inputs which in turn depend upon whether the multiplication being performed is an ordinary multiplication or a large operand multiplication. As shown select muxes are controlled by the MPMUL SELECT signal which may be provided by control logic such as MPMUL control logic . During ordinary multiplication the MPMUL SELECT signal may be deasserted and select muxes may be configured to select the sum and carry values produced by format muxes thus bypassing MPMUL CSA . In various embodiments format muxes may be configured to perform any necessary formatting e.g. shifting value substitution that may be required during the course of ordinary multiplication.

As noted above large operand multiplication may be implemented in a column by column fashion where each portion of the computed final product is dependent in part on the uppermost bits of the immediately less significant portion of the final product. In the illustrated embodiment this procedure may be implemented as follows. During large operand multiplication the MPMUL SELECT signal may be asserted resulting in the selection of the output of MPMUL CSA . Additionally during large operand multiplication the values of registers store the uppermost bits of the immediately prior product. As indicated in these values qualified by the MPMUL ADD signal may be added within MPMUL CSA along with the output of CSAs . Thus during large operand multiplication this embodiment of multiplier datapath may be configured to produce at the output of select muxes a sum and carry representation of a summation of both the outputs of CSAs and the values stored in registers 

During large operand multiplication the output of MPMUL CSA may additionally be right shifted by the amount necessary to align the most significant bits of the product currently being computed with the least significant bits of the product to be computed during the next iteration of large operand multiplication. In the illustrated embodiment this shifting may be performed by shift muxes under control of the MPMUL SHIFT signal and may be stored within register under control of the MPMUL STORE signal. In some embodiments shifting may occur only when the final accumulated product for a given column of the large operand multiplication has been determined. During earlier stages of accumulation within the given column registers may operate to accumulate an intermediate value without shifting.

For example consider the previously discussed case of multiplying two 512 bit operands A and B each consisting of 8 64 bit words within an embodiment of multiplier datapath that is configured to perform multiplication of 64 bit operands. As noted above initially words A0 and B0 may be multiplied to determine a 128 bit result. The least significant 64 bits of this result may correspond to the least significant 64 bits of the final 1024 bit product while the remaining bits of the product of A0 and B0 may be accumulated within the next columnar addition. Thus in the illustrated embodiment the product A0B0 may be right shifted by 64 bits and stored within registers 

To accumulate the next column the product A1B0 or alternatively A0B1 may then be determined and via MPMUL CSA added to the shifted portion previously stored within registers . The result may then be stored within registers without shifting. Then the product A0B1 or alternatively A1B0 may be determined and via MPMUL CSA added to the earlier result. Because this represents the final accumulated product for the current column the least significant 64 bits correspond to bits 127 64 of the final 1024 bit product while the most significant bits are to be shifted and added to the next column. Accordingly the result may be right shifted by 64 bits and stored within registers . Operation may continue in a similar fashion until all columns of the large operand multiplication have been processed.

It is noted that when multiple N bit values are accumulated within a column of a large operand multiplication a representation of the accumulated value may require more than N bits. For example adding four 128 bit numbers may yield a 130 bit result. Accordingly in some embodiments relevant elements of multiplier datapath e.g. registers MPMUL CSA may be implemented to accommodate the largest accumulated value that is anticipated during large operand multiplication.

As shown in the illustrated embodiment shift muxes and registers are configured to operate on values represented in sum and carry form as produced by CSAs and MPMUL CSA . In other embodiments it is contemplated that a single shift mux and accumulator register may be employed following fast adder such that shifting and accumulation is performed on the final two s complement or other representation produced by fast adder rather than the sum and carry representation.

When properly sequenced the embodiments of multiplier datapath described above may be configured to perform large operand multiplication as a sequence of multiplications and accumulations. In various embodiments MPMUL control logic may be configured to provide the proper sequence of operands and control signals to multiplier datapath such that an entire large operand multiplication may be performed in response to execution of a single instruction issued by issue unit . For example MPMUL control logic may include state machines microcode or other suitable sequencing circuits that may be configured to autonomously perform a large operand multiplication in response to a large operand multiplication instruction without further control or involvement by other programmer visible instructions.

In various embodiments MPMUL control logic may implement a number of counter registers configured to track the progress of a large operand multiplication as well as logic that is configured to carry out certain operations dependent upon the state of the large operand multiplication as reflected by the counter registers. illustrates one example of such an embodiment of MPMUL control logic . In the illustrated embodiment MPMUL control logic includes a set of counters that includes four counters denoted MAX MIN J and K. As described in greater detail below counters J and K may track specific words of the large operands currently being multiplied while MAX and MIN together may track the column of the large operand multiplication currently being performed. In different embodiments the width of counters may vary depending on the maximum operand size supported for a large operand multiplication operation. For example if core supports multiplication of 2048 bit operands and implements a multiplier datapath capable of performing 64 bit multiplications each of the large operands may be divided into 32 64 bit words. In such a case counters J and K may be implemented as 5 bit counters i.e. sufficient to distinguish the 32 input words .

In response to initiation of a large operand multiplication state initialization may occur block . In various embodiments upon commencing a large operand multiplication MPMUL control logic may be configured to set or reset state elements such as counters state machines and or other elements to known initial values. For example MPMUL control logic may be configured to initialize each of the MAX MIN J and K counters to zero. In some embodiments MPMUL control logic may also be configured to initialize state elements within multiplier datapath . For example registers may be initialized to zero at the beginning of a large operand multiplication.

Operand words are then retrieved block and multiplied block . For example counters J and K may respectively denote the words of operand A and B to be retrieved and multiplied together thus if J 0 and K 1 then the words A 0 and B 1 may be retrieved. In some embodiments MPMUL control logic may be configured to coordinate the retrieval of the words as they are needed from architecturally visible storage e.g. registers in an integer register file and or a floating point register file that can be read and written by software . In other embodiments some or all of the words may be copied into non architecturally visible storage e.g. a private register file local to FGU during initialization. To perform the multiplication MPMUL control logic may be configured to control the various control inputs of multiplier datapath . For example MPMUL control logic may cause the MPMUL ADD signal to enable addition of the accumulated values in registers and may cause the MPMUL SELECT signal to select a result from MPMUL CSA each at the appropriate time during datapath operation.

As noted above the process of performing large operand multiplication may be understood as a process of generating and summing products in a column oriented fashion and then repeating this process across the columns of words in the result of the large operand multiplication. Correspondingly when a product of words has been determined it may then be determined whether this product was the last product to be computed for the current column block . In some embodiments MPMUL control logic may be configured to determine this condition by ascertaining whether the values of counter A and counter MAX are equal or equivalently whether B and MIN are equal . If so then the last product for the current column has been computed.

If the currently produced product is not the last to be computed for the current column the counters may be adjusted to reflect the next words of A and B to be retrieved and the currently produced product may be stored within registers block . Operation may then continue from block . In some embodiments adjusting the counters for the next product may include incrementing A and decrementing B.

If the currently produced product is the last to be computed for the current column then it may be determined whether the current column is the last column to be computed block . In some embodiments MPMUL control logic may be configured to determine this condition by ascertaining whether counters MIN and MAX are equal. If so then the last column has been computed. In this case the currently produced product may be output as the most significant portion of the large operand multiplication result block . In some embodiments the most significant portion of the result may be output over several cycles. For example in some implementations multiplier datapath may be configured to output only one word of a product even though the product may be larger than one word e.g. when 64 bit operands are multiplied only 64 bits of the 128 bit result may be output from multiplier datapath . Thus considering the 512 bit large operand multiplication example discussed above in some embodiments generation of the A7B7 product may produce the final 128 bits of the 1024 bit product over two cycles of operation. First product bits 959 896 may be generated from the lower half of the A7B7 product and then product bits 1023 960 may be generated from the upper half of the A7B7 product which in some cases may be taken from the shifted bits stored within registers as described below with respect to block .

The large operand multiplication may then be finalized as required by the particular implementation of core block . For example in some embodiments a commit process may be required to ensure that only nonspeculative results become architecturally visible. In some such embodiments MPMUL control logic may be configured to coordinate with other units of core to ensure that the results are properly committed.

If the current column is not the last column to be computed several actions may occur in preparation for computing the next column. The least significant word of the currently produced product may be output as the word of the final result that corresponds to the current column block . In some embodiments these output words may be stored within temporary storage that is not architecturally visible e.g. a private register file within FGU until the entire large operand multiplication is complete and the entire result can be committed to architecturally visible state. In other embodiments output words may be stored within architecturally visible state as they are produced though other techniques may be employed to ensure that other instructions cannot utilize interim results until the entire large operand multiplication is complete. For example other instructions from the same thread as the large operand multiplication may be prevented from issuing while the large operand multiplication is executing traps may be prevented from occurring within that thread until the large operand multiplication is complete and or shadow registers may be employed to restore previous architectural state if a large operand multiplication cannot complete after producing partial results.

The currently produced product may be right shifted such that the least significant word is shifted out and the shifted result may be stored within registers block . For example in an embodiment where the word size is 64 bits MPMUL control logic may be configured to cause multiplier datapath to shift the currently produced product by 64 bits and store the result through appropriate manipulation of the MPMUL SHIFT and MPMUL STORE signals.

The counters may also be adjusted in preparation for computing the next column block and operation may continue from block . In some embodiments adjustment of the counters may be performed dependent upon the size in words of the large operand multiplication. For example FGU may be configured to perform large operand multiplication operations using operands having a programmer specified variable size. In other embodiments the operand size may be fixed.

In embodiments using counters such as those shown in a parameter SIZE may be employed where SIZE equals one less than the number of words in an operand of the large operand multiplication or the larger of the two operands if they are of different sizes . Thus for example if 512 bit operands are being multiplied and the word size is 64 bits then there may be 8 words in the operand and SIZE may be set to 7. In some such embodiments the counter adjustment of block may include determining whether counter MAX equals SIZE. If MAX equals SIZE then MAX is incremented and counter MIN is held constant. If MAX does not equal SIZE then MAX is held constant and MIN is incremented. After either MAX or MIN has been incremented in this fashion then counter A is initialized to MIN and counter B is initialized to MAX and operation may continue from block .

It is noted that the sequence of operations illustrated in is merely one example. In other embodiments certain actions may be deleted or performed in a different order than that shown and or other actions may be performed in addition to those shown. Moreover some embodiments of MPMUL control logic may include different configurations of counters or may use fixed state machines or techniques other than counters to control large operand multiplication. Such variations are considered to be within the scope of the present disclosure.

The following table indicates one example of the application of the operations of to the 512 bit large operand multiplication that was previously discussed. Here SIZE equals 7 or 00111 in binary representation . The table indicates the binary values of the MAX MIN A and B counters as operation progresses down and across the columns as well as the specific product term that is produced at each iteration.

As noted above in an embodiment FGU may be configured to provide support for a large operand multiplication instruction such that execution of a single instance of the large operand multiplication instruction results in FGU performing an entire large operand multiplication to completely determine the result of the large operand multiplication instruction. That is rather than using a number of discrete general purpose or special purpose instructions defined within the processor s ISA to perform the large operand multiplication a programmer may specify a single instance of a large operand multiplication instruction such that execution of this instruction determines all bits of the large operand multiplication result without requiring execution of any other programmer selected instruction within the ISA. It is noted that as used herein programmer may refer to either a human programmer who manually specifies a sequence of instructions for example by creating an assembly language program or a machine implemented entity configured to generate executable code sequences such as a compiler for a high level programming language. 

One such embodiment of FGU is shown in . In the illustrated embodiment FGU includes multiplier datapath and MPMUL control logic which may be configured as described above with respect to . Additionally multiplier datapath is shown communicatively coupled to receive operands from a register file under the control of MPMUL control logic .

In the illustrated embodiment MPMUL control logic may be configured to receive for execution a large operand multiplication instruction defined within the processor s ISA. This instruction is denoted with the instruction mnemonic MPMUL though any suitable mnemonic may be employed . In various embodiments MPMUL control logic may directly decode this instruction from opcode bits sent from upstream pipeline stages such as from issue unit or may receive already decoded or partially decoded signals indicative of the occurrence of any of these instructions. Also in the illustrated embodiment the MPMUL instruction may support a programmable SIZE parameter such that large operand multiplications of varying sizes may be performed. The SIZE parameter is illustrated as an additional input to MPMUL control logic although in various embodiments it may be either directly decoded from the MPMUL instruction by MPMUL control logic or received as a decoded field from upstream pipeline stages.

As noted above in some embodiments multiplier datapath may also be configured to perform multiplication over a binary field in addition to integer multiplication. Correspondingly in some embodiments MPMUL control logic may also be configured to receive a large operand binary field multiplication instruction which may be denoted with the instruction mnemonic MPXMUL. Upon execution the MPXMUL instruction may behave in the same fashion as the MPMUL instruction described herein except that as noted above carries across bit positions within the CSAs and fast adder of multiplier datapath may not occur in binary field multiplication. Support for this instruction is optional.

In the illustrated embodiment the operands to be multiplied may be received from register file and the result of the large operand multiplication may be stored to register file . In various embodiments register file may correspond to an architecturally visible integer register file an architecturally visible floating point register file portions of both of these types of register file or an alternatively addressed structure such as a set of memory mapped registers a defined set of memory locations or a private i.e. non architecturally visible storage structure.

In response to receiving a single instance of the MPMUL instruction the instruction execution unit multiplies the operands of the MPMUL instruction within a hardware multiplier datapath circuit to completely determine the result of the MPMUL instruction such that to determine the result of the MPMUL instruction the execution of no other programmer selected instruction within the ISA other than the MPMUL instruction is performed block . For example upon receiving the MPMUL instruction MPMUL control logic may be configured to autonomously and iteratively perform the large operand multiplication according to the method of operation shown in or a similar method. Correspondingly multiplier datapath may produce all of the words of the result of the large operand multiplication in response to execution of the MPMUL instruction.

As a result of executing the MPMUL instruction production of all the words of the result may occur without the need for any other programmer selected instruction to be fetched by IFU or executed. That is in embodiments the MPMUL instruction may behave from an architectural perspective e.g. the perspective of a programmer of core as a single instruction producing a single associated result where the result occupies multiple architecturally defined registers and where the result may be obtained over multiple execution cycles.

In various embodiments the MPMUL instruction may be implemented within any suitable ISA. For example as noted previously processor may be configured to implement a version of the SPARC ISA the x86 ISA or the PowerPC or MIPS ISAs. Because large operands required by the MPMUL instruction may exceed the maximum width of a single operand under the implemented ISA in some embodiments the MPMUL operation may implicitly specify that its operands and result are to be stored in a defined set of architecturally visible registers. For example suppose that a hypothetical ISA defined a flat register file that included 128 individually addressable 64 bit registers denoted R0 through R127 and suppose that within this hypothetical ISA the MPMUL instruction is defined to operate on operands of at most 2048 bits in size. In some such instances the MPMUL instruction may implicitly define registers R0 through R31 as the source of the first operand registers R32 through R63 as the source of the second operand and registers R64 through R127 as the destination for the 4096 bit result. Thus prior to executing the MPMUL instruction other instructions may need to ensure that the operands have been properly stored within registers R0 through R63.

Rather than a flat integer register file in which all architectural registers are concurrently visible to software embodiments of the SPARC ISA may employ a set of register windows. In one such embodiment at any given time software may have access to 32 integer registers 8 global registers and 24 registers defined within the current register window. Of the latter 8 registers may be denoted input registers 8 may be denoted local registers and 8 may be denoted output registers. Moreover if the current register window is denoted with a number CWP the output registers of window CWP are identical to the input registers of window CWP 1 and the input registers of window CWP are identical to the output registers of window CWP 1 each of these being determined modulo the number of register windows implemented . illustrates the relationship among register windows for an embodiment that includes 8 register windows denoted w0 through w7. As shown in execution of a SAVE or RESTORE instruction may cause CWP to be incremented or decremented respectively. In alternative embodiments such as some processor embodiments prior to SPARC V9 CWP may instead be decremented on a SAVE and incremented on a RESTORE. In some multithreaded embodiments of core such as described above one complete set of register windows e.g. including the 8 windows shown in may be provided for each thread such that each thread has its own register state that is read and modified independent of the execution of other threads.

One possible example of a MPMUL instruction as it might be defined within a version of the SPARC ISA is as follows. In this example the MPMUL instruction may take a 5 bit argument that defines the SIZE field discussed above. That is the SIZE specified by the MPMUL instruction may denote the quantity N 1 where N is the number of 64 bit words in each operand to be multiplied. Thus in this example the MPMUL instruction may support up to 2048 bit operands although in other embodiments both the size and number of words supported by the MPMUL instruction may vary. It is noted that in some embodiments a single MPMUL opcode may be employed and the SIZE field may be encoded within the MPMUL instruction e.g. as an immediate. In other embodiments multiple distinct MPMUL opcodes may be defined each of which implicitly encodes a single respective value of the SIZE field.

In some embodiments the MPMUL instruction may be executed without regard to the privilege of the executing thread e.g. it may be executed by user level code though in other embodiments execution of the MPMUL instruction may be restricted to privileged code e.g. code that executes in supervisor or hypervisor mode .

In this example the MPMUL instruction makes use of seven integer register windows as well as a number of floating point registers which are not windowed in the described embodiment to store operands and results. Let i denote the current window pointer CWP at the time the MPMUL instruction is executed let multiplier 31 0 and multiplicand 31 0 respectively denote 2048 bit multiplier and multiplicand operands each including 32 64 bit words and let product 63 0 denote a 4096 bit product including 64 64 bit words where the highest numbered words are the most significant. Given these assumptions the following represents one possible correspondence of the MPMUL operands and result to various integer and floating point registers 

Given the particular mapping of registers just detailed the following code sequence demonstrates one example of how the MPMUL operands may be retrieved from memory and stored in the appropriate registers and how the MPMUL result may be stored to memory after it has been computed. In the following sequence it is noted that the SAVE and RESTORE instructions may be employed to adjust the current register window.

It is noted that this code sequence represents merely one example of how an embodiment of the MPMUL instruction may be invoked. Numerous other embodiments and applications of the MPMUL instruction are possible and contemplated. For example in other embodiments different register mappings may be employed or a dedicated register file that is distinct from existing integer and floating point register files may be used.

In some embodiments the MPMUL instruction may have scheduling implications for the execution of other instructions. For example in some implementations the MPMUL instruction may be non pipelined such that only one MPMUL instruction from any thread within core may be executing at any given time. In such an implementation the thread that issued the MPMUL instruction may be blocked from executing any further instructions until the MPMUL instruction completes although other threads may continue execution. That is the MPMUL instruction may be blocking with respect to the issuing thread but non blocking with respect to other threads.

Because multiplier hardware tends to require a significant amount of die area relative to other datapath elements multiplier datapath may also be used to execute multiplications other than large operand multiplications. For example it may be employed for integer multiplication and or floating point multiplication. Because MPMUL instructions may take a significant number of execution cycles to complete relative to other instructions in some embodiments an active MPMUL instruction may arbitrate with other instructions for access to multiplier datapath . If the MPMUL instruction loses arbitration it may be temporarily interrupted while another instruction uses the datapath. For example registers which may be actively written only during an MPMUL may hold an intermediate value of the MPMUL instruction while the remainder of multiplier datapath operates on an unrelated multiplication instruction.

In response to receiving the given multiplication instruction execution of the large operand multiplication instruction is suspended block . For example in some embodiments MPMUL control logic may be configured to arbitrate for access to multiplier datapath prior to each iteration of the MPMUL instruction. If MPMUL control logic loses arbitration execution of the MPMUL instruction may be suspended until MPMUL control logic subsequently wins arbitration. In some embodiments the intermediate state of the MPMUL instruction that is suspended may be stored within registers until the MPMUL resumes.

While execution of the large operand multiplication instruction is suspended the result of the given multiplication instruction is determined block . For example the integer or floating point instruction may be allowed to execute within multiplier datapath .

After the result of the given multiplication instruction has been determined execution of the large operand multiplication instruction resumes block . For example when MPMUL control logic subsequently wins arbitration it may retrieve operands and resume execution of the suspended MPMUL instruction. It is noted that in some embodiments an MPMUL instruction may be suspended and resumed multiple times before it finally completes.

As noted previously in some embodiments the MPMUL instruction may commit intermediate results to architectural state as they are generated. For example the various output registers identified above may be modified as result words are iteratively generated by multiplier datapath . In some such embodiments the remainder of core may guarantee that no pipeline flushes occur with respect to the executing thread until the MPMUL instruction finishes in order to prevent architectural state from becoming inconsistent. In other embodiments other suitable techniques may be employed to coordinate the writing of result data taking into account the consistency requirements and implications of the particular implementation of core .

As described above with respect to the MPMUL instruction some embodiments of processor may be configured to execute instructions that utilize operands and generate results where the operands and or results may span multiple registers. In embodiments of processor that support register windows like the window configuration shown in operands and or results may span multiple register windows.

For example in the MPMUL code example given above two register windows were employed to store MPMUL operands while five register windows were employed to store the MPMUL result. In this example SAVE and RESTORE instructions were employed to select a particular register window to be written to or read from by manipulating the current window pointer CWP. As previously noted in various embodiments other types of instructions may employ different numbers of register windows for operands and or results.

The code sequence that stores input operands into and reads results from the appropriate register windows may be assigned to its own executing thread within processor . Ordinarily this process may be expected to execute without interference from other processes because other processes are typically assigned to their own respective threads having respective architectural state. However it is possible that a process may be displaced by a different process executing on the same thread such as a disrupting trap. For example an interrupt request may be generated by an external I O device that requires servicing by processor e.g. to manage data transfer or a previously executed instruction might generate an exception that requires special handling.

Depending on how processor is architected there may be a variety of events that may cause a process to be displaced by a different process executing on the same thread. Such events may be variously referred to as traps interrupts exceptions or by other terms it being noted that these terms may connote different semantics or operational behavior in different embodiments. For example trap and exception may be synonymous in some embodiments or may denote different types of events in other embodiments.

In some embodiments when a new process displaces an existing process on the same thread the new process may require one or more register windows to store its own state. For example in the SPARC architecture the SAVE instruction may be used to allocate a new register window while saving the window of the displaced or calling process. If there is at least one free register window executing the SAVE instruction will advance the CWP to reference the free window. However if all register windows are currently occupied by valid data when a SAVE is attempted it may be necessary to copy the contents of a window to memory in order to free that window to be allocated by the SAVE. Such a copy operation may also be referred to as a spill and may be implemented as an exception raised by the SAVE instruction if no free register window is available when the SAVE is attempted. For example if there is no free register window available when the SAVE is attempted an exception handler may copy the contents of one or more occupied register windows to memory. After the handler completes executing the SAVE may be attempted again and should successfully be able to allocate a new register window for example provided that no other event has attempted to allocate a register window between the original attempt and the subsequent attempt to execute the SAVE .

As noted above some large operand instructions like MPMUL may depend upon registers in multiple register windows. However because a disrupting trap might occur at any time during normal instruction execution it is possible that some of the register windows that had been set up with operands for the large operand instruction may have been displaced or spilled before the large operand instruction executes. For example in an embodiment of MPMUL like the one described above a total of seven register windows may be employed for input operands and the instruction result. If an embodiment of processor implements eight total register windows per thread then by the time the SAVE instruction just prior to the MPMUL completes at most one register window may be free. Suppose that the process to which the MPMUL belongs is displaced by a different process at this point. If more than one additional SAVE instruction is subsequently executed then a spill will occur because all eight register windows will have been allocated. In some situations all register windows might be allocated even before this point. Such a spill will typically cause at least one of the windows on which the MPMUL depends to be stored to memory.

In some embodiments when a large operand instruction that depends on multiple register windows executes processor may be configured to determine whether all of the register windows the instruction depends on are present within the register file. If not processor may be configured to restore the missing window s and to retry the large operand instruction and may do so transparently to the process executing the large operand instruction.

For example an embodiment of processor that implements the SPARC architecture may implement registers CANSAVE and CANRESTORE in addition to a register CWP. Collectively these registers may indicate how many register windows have been allocated as well as the currently active register window. According to the SPARC V9 architecture if CANSAVE is nonzero when a SAVE executes then the SAVE increments CWP and CANRESTORE and decrements CANSAVE. If CANSAVE is zero when a SAVE executes then a spill trap may occur freeing a window for use. Similarly if CANRESTORE is nonzero when a RESTORE executes then the RESTORE decrements CWP and CANRESTORE and increments CANSAVE. If CANRESTORE is zero when a RESTORE executes then the desired register window was previously spilled and a fill trap may occur to restore this window from memory.

Ordinarily CANRESTORE may indicate the total number of register windows that can be successively restored by a process before a fill trap occurs. Thus the value of CANRESTORE may represent the number of currently present register windows allocated to the current process excluding the current register window. In the MPMUL example discussed above a total of seven register windows are used so if all of the allocated register windows are present CANRESTORE should equal six or in some instances be equal to or greater than six just before the MPMUL executes. This can be seen from the above code example in which six SAVE instructions should result in incrementing CANRESTORE six times. If CANRESTORE is less than six then at least one of the register windows has been displaced and needs to be filled from memory before the MPMUL executes.

It is noted that in other embodiments the threshold value of CANRESTORE may vary depending upon how many register windows a large operand instruction utilizes for both operands and result. For example for an instruction that requires four register windows then CANRESTORE should be at least three if all windows are present when the instruction executes.

The number of currently present register windows for the particular thread associated with the large operand instruction is then determined block . For example in some embodiments the number of currently present register windows may be indicated by the value of the CANRESTORE register. In various embodiments processor may be configured to check the number of currently present register windows at different stages of the execution pipeline. For example processor may be configured to perform this check as soon as an instruction is decoded sufficiently to be identified as a large operand instruction e.g. in decode unit or earlier if large operand status is predecoded . Alternatively this check may be performed at a later stage in the pipeline. Regardless of where the logic or circuitry that implements this check is located in its various embodiments e.g. within decode unit within FGU or elsewhere within processor it may be referred to as control circuitry that determines whether register windows are present and causes absent register windows to be restored.

In response to determining that the number of register windows present is less than the number of register windows needed by the large operand instruction a register window may be restored for the large operand instruction blocks . In some embodiments different large operand instructions may require different numbers of register windows to completely store their operands and or results. The particular number of register windows required by a particular large operand instruction may be implicitly defined for that instruction e.g. the instruction may always require some constant number of register windows . Alternatively the particular number of register windows required may be explicitly defined and possibly variable e.g. the number may be encoded within the instruction or in a control or data register referenced by the instruction . Once the required number of register windows is identified in some embodiments the required number may be compared against the value of CANRESTORE in order to effect the test shown in block . Put another way this comparison may be described as determining whether the value of CANRESTORE satisfies a number of register windows required by or depended upon by the large operand instruction.

In the event that the number of currently present register windows is insufficient for the large operand instruction various embodiments may employ different techniques for restoring register windows. For example the large operand instruction may generate a fill trap that identifies one or more register windows to be restored. In some embodiments the fill trap raised by the large operand instruction may cause a fill trap handler to execute. The fill trap handler may restore from memory the contents of a register window needed by the large operand instruction that was previously spilled or copied to memory. In some embodiments the fill trap handler may write the existing contents of the identified register window s to memory before restoring the register window contents needed by the large operand instruction. 

For example the fill trap handler may attempt to restore the window identified by CWP at the time the handler is called. Correspondingly in some embodiments if the missing register window differs from the one referenced by CWP then prior to calling the fill trap handler the processor may be configured to manipulate the value of CWP to refer to the specific register window that is to be restored.

In other embodiments instead of causing a software trap handler to execute register windows may be restored by other techniques. For example a microcode routine state machine or other control mechanism may be used to restore register windows. Such a routine or other control mechanism may directly manipulate the instruction pipeline for example by causing load instructions or other suitable instructions to be inserted into the instruction pipeline. Upon execution the inserted instructions may cause a register window to be restored in a manner similar to that of the software trap handler described above although a trap may not actually occur. It is noted that the various embodiments for restoring register windows described herein are merely non limiting examples and it is contemplated that any other suitable technique for restoring register windows may be employed.

Once a register window has been restored in the illustrated embodiment operation may return to block where the large operand instruction is once again attempted. For example in embodiments where a fill trap handler is employed to restore register windows the handler may terminate by causing the instruction that raised the trap i.e. the large operand instruction to be reexecuted. If multiple register windows were not present the first time the large operand instruction was attempted the large operand instruction may trap multiple times to restore the several register windows. However in other embodiments it is contemplated that multiple register windows may be restored on a single occasion such that operation need not return to block . Alternatively it is contemplated that after a register window is restored operation may resume from block or rather than block . For example the large operand instruction may be held pending in the pipeline while register windows are restored such that it need not be refetched.

Once the needed register windows have been restored or alternatively if no register windows needed to be restored because all were initially present the large operand instruction may be executed block . In some embodiments external interrupts traps or other exceptions e.g. displacing events other than those that might be raised by execution of the large operand instruction itself may be disabled during execution of the large operand instruction. This may prevent register windows from being displaced during execution of the large operand instruction allowing it to execute to completion.

In other embodiments it may not be possible or desirable to disable some or all displacing events during execution of the large operand instruction. In some such embodiments execution hardware may be configured to monitor the state of the register windows used by the large operand instruction to detect whether any windows have been displaced during execution of the large operand instruction. If this condition occurs the executing large operand instruction may be aborted or suspended while displaced windows are restored and later restarted or resumed. For example the displacement of a register window during execution of the large operand instruction might be treated analogously to a virtual memory page fault.

It is noted that in some embodiments the method illustrated in may iteratively restore missing register windows such that during each iteration the method restores the first missing register window e.g. if multiple register windows are missing the first missing window may be the one that is closest to CWP . That is even if multiple register windows are missing when the large operand instruction is first executed in some embodiments exactly one register window may be restored on this occasion. Then the large operand instruction may be reexecuted and the number of missing register windows if any may be determined once again. If there are still missing register windows the first missing register window of these may be restored and the process may repeat. Thus the number of times a large operand instruction may be attempted may be a function of the number of missing register windows.

In other embodiments instead of only restoring the first missing register window during an iteration processor may restore multiple missing register windows e.g. some or all missing windows in a single pass when a missing register window is detected. For example upon detecting that multiple register windows are missing processor may cause two or more of the missing register windows to be restored before the large operand instruction is reexecuted. In such embodiments the number of times the large operand instruction is reexecuted may be reduced relative to embodiments in which only one register window is restored per execution attempt.

As a specific example of how restoration of register windows for large operand instructions might occur consider the MPMUL instruction described above. In this example MPMUL requires the presence of seven register windows and executes with CWP equal to 6. Thus on this occasion MPMUL depends upon register windows 0 through 6 inclusive.

However suppose that at the time the MPMUL instruction executes register windows 0 and 1 have been displaced. This may be indicated by the register CANRESTORE. For example as noted above CANRESTORE may be compared against a value indicative of the number of register windows required by a large operand instruction. In this example the value may be 6 indicating that 7 register windows are required . Because register windows 0 and 1 have been displaced when the MPMUL instruction executes CANRESTORE may be equal to 4 indicating because 4 is less than 6 that not all of the required register windows are present.

In response to determining from the value of CANRESTORE that one or more register windows need to be restored the fill trap handler may be called. In this example the value of CWP that is passed to the fill trap handler may be determined from the formula CWP CWP CANRESTORE 1 where CWPdenotes the value of CWP at the time the MPMUL instruction executes which is assumed to be 6 in this example. Thus the trap handler may be called with the CWP value of 6 4 1 1 indicating that register window 1 is to be restored.

Once called the fill trap handler may proceed to restore register window 1. Once it has done so in some embodiments the fill trap handler may execute the RESTORED instruction which increments the value of CANRESTORE. In this example after RESTORED executes CANRESTORE will equal 5. The fill trap handler may terminate by executing the RETRY instruction which attempts to cause reexecution of the instruction that triggered the fill trap.

In this example RETRY may cause the MPMUL instruction to be attempted again this time with a CWP value of 6 and a CANRESTORE value of 5 after restoration of register window 1 . Once again the value of CANRESTORE may be tested. Because CANRESTORE is still less than the value of 6 required by MPMUL the fill trap handler may be called once again. On this occasion the trap handler may be called with the CWP value of 6 5 1 0 indicating that register window 0 is to be restored.

As before the fill trap handler may register the identified register window and execute RESTORED causing CANRESTORE to be incremented to 6. Then execution of RETRY may cause MPMUL to be attempted once again. On this occasion because CANRESTORE satisfies the value of 6 required by MPMUL all register windows required by MPMUL are present and the MPMUL instruction may proceed to execute.

As described above in some embodiments processor of may be configured to interface with a number of external devices. An embodiment of a system including processor is illustrated in . In the illustrated embodiment system includes an instance of processor shown as processor that is coupled to a system memory a peripheral storage device and a boot device . System is coupled to a network which is in turn coupled to another computer system . In some embodiments system may include more than one instance of the devices shown. In various embodiments system may be configured as a rack mountable server system as a standalone system or in any other suitable form factor. In some embodiments system may be configured as a client system rather than a server system.

In some embodiments system may be configured as a multiprocessor system in which processor may optionally be coupled to one or more other instances of processor shown in as processor . For example processors may be coupled to communicate via their respective coherent processor interfaces .

In various embodiments system memory may comprise any suitable type of system memory as described above such as FB DIMM DDR DDR2 DDR3 DDR4 SDRAM or RDRAM for example. System memory may include multiple discrete banks of memory controlled by discrete memory interfaces in embodiments of processor that provide multiple memory interfaces . Also in some embodiments system memory may include multiple different types of memory.

Peripheral storage device in various embodiments may include support for magnetic optical or solid state storage media such as hard drives optical disks nonvolatile RAM devices etc. In some embodiments peripheral storage device may include more complex storage devices such as disk arrays or storage area networks SANs which may be coupled to processor via a standard Small Computer System Interface SCSI a Fibre Channel interface a Firewire IEEE 1394 interface or another suitable interface. Additionally it is contemplated that in other embodiments any other suitable peripheral devices may be coupled to processor such as multimedia devices graphics display devices standard input output devices etc. In an embodiment peripheral storage device may be coupled to processor via peripheral interface s of .

As described previously in an embodiment boot device may include a device such as an FPGA or ASIC configured to coordinate initialization and boot of processor such as from a power on reset state. Additionally in some embodiments boot device may include a secondary computer system configured to allow access to administrative functions such as debug or test modes of processor .

Network may include any suitable devices media and or protocol for interconnecting computer systems such as wired or wireless Ethernet for example. In various embodiments network may include local area networks LANs wide area networks WANs telecommunication networks or other suitable types of networks. In some embodiments computer system may be similar to or identical in configuration to illustrated system whereas in other embodiments computer system may be substantially differently configured. For example computer system may be a server system a processor based client system a stateless thin client system a mobile device etc. In some embodiments processor may be configured to communicate with network via network interface s of .

It is noted that the above exemplary assembly language code sequences use the setx instruction. However the setx instruction is defined within the SPARC ISA as a synthetic instruction. As described in section G.3 of the SPARC Architecture Manual Version 9 synthetic instructions may be provided in a SPARC assembler for the convenience of assembly language programmers and they do generate instructions. The synthetic instructions map to actual instructions.

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

