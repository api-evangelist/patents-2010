---

title: Methods for using unique identifiers to identify systems in collaborative interaction in a mesh network
abstract: Described herein are methods and systems for using unique identifiers to identify systems in collaborative interaction in a mesh network. For example, in at least certain embodiments, upon initiation of a collaborative application each system can broadcast packets that include a unique hash identifier for each system to other systems in the mesh network. Each system then can determine when the system has received packets that include the unique hash identifiers from all systems. Then, each system can sort the unique hash identifiers to identify each system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08924304&OS=08924304&RS=08924304
owner: Apple Inc.
number: 08924304
owner_city: Cupertino
owner_country: US
publication_date: 20100604
---
Embodiments of the present invention relate to methods for using unique identifiers to identify systems in collaborative interaction in a mesh network.

Various devices such as electronic devices computing systems portable devices and handheld devices have collaborative applications such as software gaming applications. These devices can network with each other for a multi player gaming experience.

One prior gaming environment allows players to interact with each other online. A server communicates over a data network with a number of client computers. The server receives information from the client computers to update the state of the multi player game and distributes information back to the client computers regarding relevant game state for each of the client computers.

However this prior approach has limitations in terms of connecting players and network delays. These online connections use the transmission control protocol TCP that provides reliable ordered delivery of a stream of bytes from a game application on the client computer to the server and vice versa. The TCP controls segment size flow control the rate at which data is exchanged and network traffic congestion. However TCP packets may have timing readiness and internet issues that cause some client computers to not have relevant game information in a timely manner or at all.

Described herein are methods for using unique identifiers to identify systems in collaborative interaction in for example a mesh network. For example in at least certain embodiments at least one system initiates a collaborative application e.g. music creation document creation multi player games with other systems. In response a data service provides a collaborative environment that matches systems and provides connection data to the systems to generate a mesh network. In one embodiment each system in the mesh network or other network can perform a hash function on a unique identifier associated with each system to generate a unique hash identifier for each system. Then each system can broadcast packets that include the unique hash identifier for each system and also status information to other systems in the mesh network. Each system can then determine when the system has heard from all systems and when the other systems have also heard from all other systems. Then in one embodiment each system can sort the unique hash identifiers to assign a relative reference value to each system in the mesh network and thus identify each system with the sorted unique hash identifier. In one embodiment each system identifies other systems with these assigned relative reference values which can be used for determining for example a player order in a multi player gaming application or can be used for assigning each system to be a server or client in the mesh network.

In an embodiment the unique identifier for each is obtained from memory of the system. Each system performs a hash function on the unique identifier for the system in a non reversible manner to generate a unique hash identifier for the system and to protect the unique identifier. The unique identifier can be universally unique relative to all other systems of relatively unique within a type or subset of systems of a particular type of hardware or a particular combination of hardware and software etc.

The present disclosure includes systems and devices that perform these methods including data processing systems which perform these methods and machine readable media which when executed on data processing systems cause the systems to perform these methods.

Described herein are methods for using unique identifiers to identify systems in collaborative interaction in a mesh network. For example in at least certain embodiments at least one system initiates a collaborative application e.g. music creation document creation multi player games . In response a data service provides a collaborative environment that matches systems and provides connection data to the systems to generate a mesh network. Each system generates a hash identifier based on a unique identifier associated with the system. The hash identifiers are exchanged between systems within the mesh network. The hash identifiers can be sorted to identify systems in the mesh network.

As illustrated in a general network topology implemented in one embodiment can include a group of client or peer computing systems respectively communicating with one another and with one or more services over a network . Although illustrated as a single network cloud in the network can be comprised of a variety of different components including public networks such as the Internet and private networks such as local Wi Fi networks e.g. 902.11n home wireless networks or wireless hotspots local area Ethernet networks cellular data networks and WiMAX networks to name a few. For example system may be connected to a home Wi Fi network represented by network link system may be connected to a 3G network e.g. Universal Mobile Telecommunications System UMTS High Speed Uplink Packet Access HSUPA etc represented by network link system may be connected to a WiMAX network represented by network link and system may be connected to a public Wi Fi network represented by network link . Each of the local network links over which the systems are connected may be coupled to a public network such as the Internet thereby enabling communication between the various systems over the public network. However if two systems are on the same local or private network e.g. the same Wi Fi network then the two systems may communicate directly over that local private network bypassing the public network. It should be noted of course that the underlying principles of the present disclosure are not limited to any particular set of network types or network topologies and that the term mesh network is meant to include one or more networks of the same or different types.

Each of the systems illustrated in can communicate with a data service that may include a collaborative service e.g. game service music creation service document creation service a connection data exchange CDX service a matchmaker service an invitation service an account service and an application service . In one embodiment the collaborative service enables user to collaborate with collaborative applications. For example the collaborative service may be a game service that enables users to collaborate for multi player gaming applications or other multiple user applications. The game service may include or access any of the services . The services can be implemented as software executed across one or more physical computing systems such as servers. As shown in in one embodiment the services may be implemented within the context of a larger data service managed by the same entity e.g. the same company and accessible by each of the systems over the network . The data service can include a local area network e.g. an Ethernet based LAN connecting various types of servers a storage area networks SANs and databases. In one embodiment the databases store and manage data related to each of the user systems e.g. client systems computer systems mobile systems and the users of those systems e.g. user account data system account data user application data etc. .

In one embodiment a collaborative identifier module is located on each system respectively. The collaborative identifier module is associated with a collaborative software application that provides a collaborative environment in conjunction with the data service .

In one embodiment the collaborative identifier module is implemented on a game framework such as that described in co pending applications U.S. patent application No. 61 321 854 entitled APPLICATION PROGRAMMING INTERFACE SYSTEM AND METHOD FOR COLLABORATIVE ONLINE APPLICATIONS Filed Apr. 7 2010 by Mike Lampell U.S. patent application No. 61 321 842 entitled APPARATUS AND METHOD FOR MATCHING USERS FOR ONLINE SESSIONS Filed Apr. 7 2010 by Jeremy Werner Phillip Smith Andrew H. Vyrros U.S. patent application No. 61 321 832 entitled APPARATUS AND METHOD FOR INVITING USERS TO ONLINE SESSIONS Filed Apr. 7 2010 by Andrew H. Vyrros Jeremy Werner and Patrick Gates U.S. patent application No. 61 321 841 entitled APPARATUS AND METHOD FOR ESTABLISHING AND UTILIZING BACKUP COMMUNICATION CHANNELS Filed Apr. 7 2010 by Jeff Tung Barry A. Whitebook Joe Abuan Hyeonkuk Jeong Andy Yang and Roberto Garcia and U.S. patent application No. 61 321 851 entitled APPARATUS AND METHOD FOR EFFICIENTLY AND SECURELY EXCHANGING CONNECTION DATA Filed Apr. 7 2010 by Joe Abuan Jeff Tung Robert Quattlebaum Barry A. Whitebook and Roberto Garcia hereinafter Co pending Applications which are assigned to the assignee of the present application and which are incorporated herein by reference in their entirety. It should be noted however that the game framework described in the co pending applications is not required for complying with the underlying principles of the invention.

The matchmaker service can match two or more systems for a collaborative peer to peer P2P session based on a specified set of conditions. For example users of two or more of the systems may be interested in playing a particular multi player game. In such a case the matchmaker service may identify a group of systems to participate in the game based on variables such as each user s level of expertise the age of each of the users the timing of the match requests the particular game for which a match is requested and game specific variables associated with the game. By way of example and not limitation the matchmaker service may attempt to match users with similar levels of expertise at playing a particular game. Additionally adults may be matched with other adults and children may be matched with other children. Moreover the matchmaker service may prioritize user requests based on the order in which those requests are received. The underlying principles of the present disclosure are not limited to any particular set of matching criteria or any particular type of P2P application.

In response to a match request the matchmaker service can coordinate with the CDX service to ensure that all matched participants receive the necessary connection data for establishing P2P sessions in an efficient and secure manner.

In one embodiment the invitation service also identifies systems for participation in collaborative P2P sessions. However in the case of the invitation service at least one of the participants is specifically identified by another participant. For example the user of system may specifically request a collaborative session with the user of system . As with the matchmaker service in response to an invitation request the invitation service can identify the set of participants and coordinate with the CDX service to ensure that all participants receive the necessary connection data for establishing P2P sessions in an efficient and secure manner.

At block the processing logic can initiate a collaborative application e.g. music creation document creation multi player games and matching of systems interacting collaboratively to form a mesh network. The matchmaker service can match two or more systems for a collaborative session e.g. peer to peer P2P . At block the processing logic of a system can obtain a unique identifier from memory of the system. At block the processing logic can perform a hash function on the unique identifier for the system in a non reversible manner to generate a unique hash identifier for the system.

The unique hash identifier is generated in a non reversible manner to protect the unique identifier of the system and prevent a spoofing attack. Even though the unique hash identifier is provided to other devices in a collaborative session the unique identifier remains a secret relative to those other devices because the hash function used is non reversible e.g. the hash function cannot be reversed to reveal the unique identifier if the unique hash identifier is known . At block the processing logic can wait for the matching to start to form a mesh network with at least one system. As discussed above the matchmaking service can match two or more systems for a collaborative session e.g. music creation session document creation session multi player gaming session .

At block the processing logic can broadcast packets that include the unique hash identifier from the system to at least one other system in the mesh network or other network that has initiated the collaborative application. In one embodiment each packet also contains heard from status information e.g. cointoss data . The status information includes a field that indicates how many systems including the first system in the mesh network that the first system has heard from a heard from status field for the first system a heard from status field for the second system a heard from status field for the third system etc.

In an embodiment the packets are sent and received using an unreliable connectionless protocol e.g. user datagram protocol UDP . UDP is a simple to implement protocol because it does not require tracking of every packet sent or received and it does not need to initiate or end a transmission. An establishment of a series of unique network identifiers to be shared amongst systems is guaranteed by using the unreliable protocol because the reliable protocol TCP is not guaranteed in a mobile environment and TCP queuing is undesirable when establishing this mesh. One of the unique aspects of this unreliable protocol is that by necessity it works well over unreliable networks that can actually be unreliable with only a certain percentage of packets actually arriving.

At block the processing logic can determine when all of the other systems have received packets that include unique hash identifiers from all systems in the mesh network. At block the processing logic can determine when the system has received packets that include unique hash identifiers from all systems in the mesh network. At block the processing logic for each system or the data service can sort the unique hash identifiers in order to identify each system in the mesh network. The unique hash identifiers may be assigned relative reference values to identify each system. In certain embodiments the reference value for each system can be used to order players in a gaming application assign preferences e.g. colors to each user or player sharing the collaborative application or assign systems to be either a server or a client in the mesh network.

At block the processing logic of a system may receive a user selection to initiate a collaborative application e.g. multi player gaming application and matching of systems interacting collaboratively. The matchmaker service can match two or more systems for a collaborative session e.g. peer to peer P2P based on a specified set of conditions. For example users of two or more of the systems may be interested in playing a particular multi player game. In such a case the matchmaker service may identify a group of systems to participate in the game based on variables such as each user s level of expertise the age of each of the users the timing of the match requests the particular game for which a match is requested and game specific variables associated with the game. In response to a match request the matchmaker service can coordinate with the CDX service to ensure that all matched participants receive the necessary connection data e.g. network addresses for establishing P2P sessions in an efficient and secure manner to form a mesh network of systems that interact collaboratively.

At block the processing logic for each system can obtain a unique identifier that uniquely identifies each system. The unique identifier may be obtained from memory of the system. At block the processing logic for each system may perform a hash function on the unique identifier for each system to generate a unique hash identifier for each system. At block the processing logic can wait for the matching to start to form a mesh network with at least one system. As discussed above the matchmaking service can match two or more systems for a collaborative peer to peer P2P session e.g. multi player gaming session . For example the matchmaking service may match four players having similar skill levels to play a multi player gaming application.

At block each system broadcasts packets to determine a cointoss for the multi player gaming application. For example the cointoss may determine player ordering or colors for each player. For a particular system the packets include the unique hash identifier for the particular system. Each packet also contains heard from status information e.g. cointoss data as illustrated in and described in more detail below in conjunction with . In an embodiment the packet for a first system includes a unique hash identifier for the first system a field that indicates how many systems including the first system in the mesh network that the first system has heard from a heard from status field for the first system a heard from status field for the second system a heard from status field for the third system etc.

The processing logic for each system can wait to receive packets broadcasted from other systems in the mesh network at block . Each system may continue to broadcast packets at block . At block one or more systems can receive packets e.g cointoss packets from other systems in the mesh network or other network. For example the first system broadcasts packets to the other systems. These packets indicate that the first system is ready for the collaborative application e.g. multi player application . The other systems broadcast packets and these packets indicate to the first system that these systems are ready and also that these other systems know that the first system is ready. In one embodiment the packets are sent and received using an unreliable connectionless protocol e.g. UDP .

At block the processing logic for each system that receives packets from other systems can update internal cointoss data for the particular system. At block the processing logic for each system can determine whether the cointoss is complete. The flow diagram of describes this operation in more detail. In an embodiment the first system determines whether the cointoss is complete by checking the heard from status information e.g. cointoss data . This data may indicate that the first system has heard from all systems in the mesh network or other network and additionally that each system has individually heard from all systems and received the unique hash identifier from all systems in the mesh network or other network. In this case the cointoss is complete for the first system. If all systems determine that the cointoss is complete then the unique hash identifiers can be sorted at block in each of all of the systems in order to assign a relative reference value to each system in the mesh network or other network. If the cointoss is not complete for a particular system at block then the system broadcasts packets at block .

Each system may sort the unique hash identifiers using the same or similar sorting routine or method e.g. numerical alphabetic alphanumerical etc. and thus generate the same result. The resulting relative reference values may indicate a player order player colors etc. for the multi player gaming application. The relative reference values may also be used to configure the systems in the mesh network or other network. For example one system may be elected as a server and the other systems are elected as clients. Alternatively the systems may form P2P connections.

At block the processing logic for each system can determine a heard from status for the other systems to determine if the other systems have heard from all other systems in the mesh network or other network. The other systems may be checked at block . For example in one embodiment a first system checks a heard from status for a second system. If the second system has an expected final status e.g. 4444 for 4 systems then the second system has heard from all other systems and the cointoss is complete for the second system. The flow returns to block if the second system has not heard from all other systems. If the second system has heard from all other systems then the processing logic determines whether the other systems e.g. third and fourth systems have also heard from all other systems at block . If so then the processing logic for the first system determines whether the first system has heard from all other systems in the mesh network at block and has the expected final status e.g. 4444 for 4 systems as illustrated as bit string in in accordance with one embodiment. The bit string includes the hash identifier for the system and the number of systems that each system has heard from. If the other systems do not have the expected final status then the flow returns to block to determine if the other systems e.g. third system fourth system have heard from all other systems and have the expected final status e.g. 4444 for 4 systems . This flow of operations continues until all systems have heard from all other systems and have received the unique hash identifier from each of the other systems. Once this occurs and each system has heard back from all other systems then the cointoss is complete for all systems. At block sorting of the unique hash identifiers can occur as described at block of method .

If the first system has not heard back from all other systems at block then the flow returns to block . In an embodiment packets are sent and received between systems across an unreliable network using an unreliable connectionless protocol e.g. user datagram protocol UDP . One of the unique aspects of this unreliable protocol is that by necessity it works well over unreliable networks that can actually be unreliable with only a certain percentage of packets actually arriving.

As discussed above in an embodiment the packets are sent and received using an unreliable connectionless protocol e.g. user datagram protocol UDP . An establishment of a series of unique network identifiers to be shared amongst systems is guaranteed by using the unreliable protocol because the reliable protocol TCP is not guaranteed in a mobile environment and TCP queuing is undesirable when establishing this mesh. One of the unique aspects of this unreliable protocol is that by necessity it works well over unreliable networks that can actually be unreliable with only a certain percentage of packets actually arriving.

In one embodiment system has a heard from status field of 1344 system has a heard from status field of 3144 system has a heard from status field of 4134 and system has a heard from status field of 4314. These status fields would indicate that all systems having the same data in regards to each other. If system hears from system then the status field for system updates to 2344.

Alternatively system may have a different status field for system than system actually has because the status field of system has been recently updated and system is not aware of this update.

Mesh networking allows for continuous connections and reconfiguration around broken or blocked paths by hopping from node to node until the destination is reached. Mesh networks are self healing the network can still operate when one node breaks down or a connection goes bad. As a result the network may typically be very reliable as there is often more than one path between a source and a destination in the network. A mesh network can be a local area network LAN that employs one of two connection arrangements full mesh topology or partial mesh topology. In the full mesh topology each system or other device is connected directly to each of the others. In the partial mesh topology some nodes are connected to all the others but some of the nodes are connected only to those other nodes with which they exchange the most data.

In an alternative embodiment the network is a node based network that implements the cointoss to obtain cointoss data from other systems and to identify systems in the network . For example system can be a node that communicates with system system system system and system . System can be a node that communicates with system system and system . If either of system or drops from the node network then the node network automatically reforms using the cointoss data.

Attention is now directed towards embodiments of a system architecture that may be embodied within any portable or non portable device including but not limited to a communication device e.g. mobile phone smart phone a multi media device e.g. MP3 player TV radio a portable or handheld computer e.g. tablet netbook laptop a desktop computer an All In One desktop a peripheral device or any other system or device adaptable to the inclusion of system architecture including combinations of two or more of these types of devices. is a block diagram of one embodiment of system that generally includes one or more computer readable non transitory storage mediums processing system Input Output I O subsystem radio frequency RF circuitry and audio circuitry . These components may be coupled by one or more communication buses or signal lines .

It should be apparent that the architecture shown in is only one example architecture of system and that system could have more or fewer components than shown or a different configuration of components. The various components shown in can be implemented in hardware software firmware or any combination thereof including one or more signal processing and or application specific integrated circuits.

RF circuitry is used to send and receive information over a wireless link or network to one or more other devices and includes well known circuitry for performing this function. RF circuitry and audio circuitry are coupled to processing system via peripherals interface . Interface includes various known components for establishing and maintaining communication between peripherals and processing system . Audio circuitry is coupled to audio speaker and microphone and includes known circuitry for processing voice signals received from interface to enable a user to communicate in real time with other users. In some embodiments audio circuitry includes a headphone jack not shown .

Peripherals interface couples the input and output peripherals of the system to processor and computer readable medium . One or more processors communicate with one or more computer readable mediums via controller . Computer readable medium can be any device or medium e.g. storage device non transitory storage medium that can store code and or data for use by one or more processors . Medium can include a memory hierarchy including but not limited to cache main memory and secondary memory. The memory hierarchy can be implemented using any combination of RAM e.g. SRAM DRAM DDRAM ROM FLASH magnetic and or optical storage devices such as disk drives magnetic tape CDs compact disks and DVDs digital video discs . Medium may also include a transmission medium for carrying information bearing signals indicative of computer instructions or data with or without a carrier wave upon which the signals are modulated . For example the transmission medium may include a communications network including but not limited to the Internet also referred to as the World Wide Web intranet s Local Area Networks LANs Wide Local Area Networks WLANs Storage Area Networks SANs Metropolitan Area Networks MAN and the like.

One or more processors run various software components stored in medium to perform various functions for system . In some embodiments the software components include operating system communication module or set of instructions touch processing module or set of instructions graphics module or set of instructions one or more applications or set of instructions and collaborative identifier module or set of instructions . In an embodiment a collaborative application is associated with a collaborative identifier module . Each of these modules and above noted applications correspond to a set of instructions for performing one or more functions described above and the methods described in this application e.g. the computer implemented methods and other information processing methods described herein . These modules i.e. sets of instructions need not be implemented as separate software programs procedures or modules and thus various subsets of these modules may be combined or otherwise rearranged in various embodiments.

In some embodiments medium may store a subset of the modules and data structures identified above. Furthermore medium may store additional modules and data structures not described above.

Operating system includes various procedures sets of instructions software components and or drivers for controlling and managing general system tasks e.g. memory management storage device control power management etc. and facilitates communication between various hardware and software components.

Communication module facilitates communication with other devices over one or more external ports or via RF circuitry and includes various software components for handling data received from RF circuitry and or external port .

Graphics module includes various known software components for rendering animating and displaying graphical objects on a display surface. In embodiments in which touch I O device is a touch sensitive display e.g. touch screen graphics module includes components for rendering displaying and animating objects on the touch sensitive display.

One or more applications can include any applications installed on system including without limitation a collaborative application a browser address book contact list email instant messaging word processing keyboard emulation widgets JAVA enabled applications encryption digital rights management voice recognition voice replication location determination capability such as that provided by the global positioning system GPS a music player etc.

Touch processing module includes various software components for performing various tasks associated with touch I O device including but not limited to receiving and processing touch input received from I O device via touch I O device controller .

System may further include collaborative identifier module e.g. collaborative mesh network module for performing the method functions as described herein in connection with . In one embodiment the collaborative identifier module may at least function to use unique identifiers associated with systems in a mesh network to identify the systems. For example the collaborative identifier module may identify the systems for player ordering in a multi player gaming application. The collaborative identifier module can perform a hash function on a unique identifier associated with each system to generate a unique hash identifier for each system. Then each system broadcasts packets that include the unique hash identifier for each system and also status information to other systems in the mesh network. The collaborative identifier module then can determine when the system has heard from all systems and when the other systems have also heard from all other systems. Then the collaborative identifier module of each system can sort the unique hash identifiers to assign a relative reference value to each system in the mesh network and thus identify each system. In one embodiment the collaborative identifier module of each system identifies other systems with these assigned relative reference values which can be used for determining a player order in a multi player gaming application or can be used for assigning each system to be a server or client in the mesh network.

Module may also interact with collaborative application to provide the methods and functionality described herein. Module may be embodied as hardware software firmware or any combination thereof. Although module is shown to reside within medium all or portions of module may be embodied within other components within system or may be wholly embodied as a separate component within system .

I O subsystem is coupled to touch I O device and one or more other I O devices for controlling or performing various functions. Touch I O device communicates with processing system via touch I O device controller which includes various components for processing user touch input e.g. scanning hardware . One or more other input controllers receives sends electrical signals from to other I O devices . Other I O devices may include physical buttons dials slider switches sticks keyboards touch pads additional display screens or any combination thereof.

If embodied as a touch screen touch I O device displays visual output to the user in a GUI. The visual output may include text graphics video and any combination thereof. Some or all of the visual output may correspond to user interface objects. Touch I O device forms a touch sensitive surface that accepts touch input from the user. Touch I O device and touch screen controller along with any associated modules and or sets of instructions in medium detects and tracks touches or near touches and any movement or release of the touch on touch I O device and converts the detected touch input into interaction with graphical objects such as one or more user interface objects. In the case in which device is embodied as a touch screen the user can directly interact with graphical objects that are displayed on the touch screen. Alternatively in the case in which device is embodied as a touch device other than a touch screen e.g. a touch pad the user may indirectly interact with graphical objects that are displayed on a separate display screen embodied as I O device .

Touch I O device may be analogous to the multi touch sensitive surface described in the following U.S. Pat. No. 6 323 846 Westerman et al. U.S. Pat. No. 6 570 557 Westerman et al. and or U.S. Pat. No. 6 677 932 Westerman and or U.S. Patent Publication 2002 0015024A1 each of which is hereby incorporated by reference in its entirety.

Embodiments in which touch I O device is a touch screen the touch screen may use LCD liquid crystal display technology LPD light emitting polymer display technology OLED organic LED or OEL organic electro luminescence although other display technologies may be used in other embodiments.

Feedback may be provided by touch I O device based on the user s touch input as well as a state or states of what is being displayed and or of the computing system. Feedback may be transmitted optically e.g. light signal or displayed image mechanically e.g. haptic feedback touch feedback force feedback or the like electrically e.g. electrical stimulation olfactory acoustically e.g. beep or the like or the like or any combination thereof and in a variable or non variable manner.

System also includes power system for powering the various hardware components and may include a power management system one or more power sources a recharging system a power failure detection circuit a power converter or inverter a power status indicator and any other components typically associated with the generation management and distribution of power in portable devices.

In some embodiments peripherals interface one or more processors and memory controller may be implemented on a single chip such as processing system . In some other embodiments they may be implemented on separate chips.

In certain embodiments of the present disclosure the system can be used to implement at least some of the methods discussed in the present disclosure.

Some portions of the detailed descriptions are presented in terms of algorithms which include operations on data stored within a computer memory. An algorithm is generally a self consistent sequence of operations leading to a desired result. The operations typically require or involve physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like can refer to the action and processes of a data processing system or similar electronic device that manipulates and transforms data represented as physical electronic quantities within the system s registers and memories into other data similarly represented as physical quantities within the system s memories or registers or other such information storage transmission or display devices.

The present disclosure can relate to an apparatus for performing one or more of the operations described herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a machine e.g. computer readable non transitory storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs erasable programmable ROMs EPROMs electrically erasable programmable ROMs EEPROMs flash memory magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a bus.

A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example machines store and communicate internally and with other devices over a network code and data using machine readable media such as machine storage media e.g. magnetic disks optical disks random access memory read only memory flash memory devices phase change memory .

One or more Application Programming Interfaces APIs may be used in some embodiments. An API is an interface implemented by a program code component or hardware component hereinafter API implementing component that allows a different program code component or hardware component hereinafter API calling component to access and use one or more functions methods procedures data structures classes and or other services provided by the API implementing component. An API can define one or more parameters that are passed between the API calling component and the API implementing component.

An API allows a developer of an API calling component which may be a third party developer to leverage specified features provided by an API implementing component. There may be one API calling component or there may be more than one such component. An API can be a source code interface that a computer system or program library provides in order to support requests for services from an application. An operating system OS can have multiple APIs to allow applications running on the OS to call one or more of those APIs and a service such as a program library can have multiple APIs to allow an application that uses the service to call one or more of those APIs. An API can be specified in terms of a programming language that can be interpreted or compiled when an application is built.

In some embodiments the API implementing component may provide more than one API each providing a different view of or with different aspects that access different aspects of the functionality implemented by the API implementing component. For example one API of an API implementing component can provide a first set of functions and can be exposed to third party developers and another API of the API implementing component can be hidden not exposed and provide a subset of the first set of functions and also provide another set of functions such as testing or debugging functions which are not in the first set of functions. In other embodiments the API implementing component may itself call one or more other components via an underlying API and thus be both an API calling component and an API implementing component.

An API defines the language and parameters that API calling components use when accessing and using specified features of the API implementing component. For example an API calling component accesses the specified features of the API implementing component through one or more API calls or invocations embodied for example by function or method calls exposed by the API and passes data and control information using parameters via the API calls or invocations. The API implementing component may return a value through the API in response to an API call from an API calling component. While the API defines the syntax and result of an API call e.g. how to invoke the API call and what the API call does the API may not reveal how the API call accomplishes the function specified by the API call. Various API calls are transferred via the one or more application programming interfaces between the calling API calling component and an API implementing component. Transferring the API calls may include issuing initiating invoking calling receiving returning or responding to the function calls or messages in other words transferring can describe actions by either of the API calling component or the API implementing component. The function calls or other invocations of the API may send or receive one or more parameters through a parameter list or other structure. A parameter can be a constant key data structure object object class variable data type pointer array list or a pointer to a function or method or another way to reference a data or other item to be passed via the API.

Furthermore data types or classes may be provided by the API and implemented by the API implementing component. Thus the API calling component may declare variables use pointers to use or instantiate constant values of such types or classes by using definitions provided in the API.

Generally an API can be used to access a service or data provided by the API implementing component or to initiate performance of an operation or computation provided by the API implementing component. By way of example the API implementing component and the API calling component may each be any one of an operating system a library a device driver an API an application program or other module it should be understood that the API implementing component and the API calling component may be the same or different type of module from each other . API implementing components may in some cases be embodied at least in part in firmware microcode or other hardware logic. In some embodiments an API may allow a client program e.g. collaborative application to use the services provided by a Software Development Kit SDK library. In other embodiments an application or other client program may use an API provided by an Application Framework. In these embodiments the application or client program may incorporate calls to functions or methods provided by the SDK and provided by the API or use data types or objects defined in the SDK and provided by the API. An Application Framework may in these embodiments provide a main event loop for a program that responds to various events defined by the Framework. The API allows the application to specify the events and the responses to the events using the Application Framework. In some implementations an API call can report to an application the capabilities or state of a hardware device including those related to aspects such as input capabilities and state output capabilities and state processing capability power state storage capacity and state communications capability etc. and the API may be implemented in part by firmware microcode or other low level logic that executes in part on the hardware component.

The API calling component may be a local component i.e. on the same data processing system as the API implementing component or a remote component i.e. on a different data processing system from the API implementing component that communicates with the API implementing component through the API over a network. It should be understood that an API implementing component may also act as an API calling component i.e. it may make API calls to an API exposed by a different API implementing component and an API calling component may also act as an API implementing component by implementing an API that is exposed to a different API calling component.

The API may allow multiple API calling components written in different programming languages to communicate with the API implementing component thus the API may include features for translating calls and returns between the API implementing component and the API calling component however the API may be implemented in terms of a specific programming language. An API calling component can in one embedment call APIs from different providers such as a set of APIs from an OS provider and another set of APIs from a plug in provider and another set of APIs from another provider e.g. the provider of a software library or creator of the another set of APIs.

It will be appreciated that the API implementing component may include additional functions methods classes data structures and or other features that are not specified through the API and are not available to the API calling component . It should be understood that the API calling component may be on the same system as the API implementing component or may be located remotely and accesses the API implementing component using the API over a network. While illustrates a single API calling component interacting with the API it should be understood that other API calling components which may be written in different languages or the same language than the API calling component may use the API .

The API implementing component the API and the API calling component may be stored in a machine readable medium e.g. computer readable medium which includes any mechanism for storing information in a form readable by a machine e.g. a computer or other data processing system . For example a machine readable medium includes magnetic disks optical disks random access memory read only memory flash memory devices etc.

In Software Stack an exemplary embodiment applications can make calls to Services A or B using several Service APIs and to Operating System OS using several OS APIs. Services A and B can make calls to OS using several OS APIs.

Note that the Service has two APIs one of which Service API receives calls from and returns values to Application and the other Service API receives calls from and returns values to Application . Service which can be for example a software library makes calls to and receives returned values from OS API and Service which can be for example a software library makes calls to and receives returned values from both OS API and OS API . Application makes calls to and receives returned values from OS API .

In the foregoing specification the disclosure has been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the disclosure as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

