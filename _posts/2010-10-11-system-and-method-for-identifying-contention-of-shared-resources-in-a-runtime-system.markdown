---

title: System and method for identifying contention of shared resources in a runtime system
abstract: A system and computer-implemented method for determining a runtime of a thread of an application. Synchronization events for a first thread of an application executing on the computer system are received, the synchronization events including at least a first synchronization event and a second synchronization event for the first thread. A first difference between a synchronization event timestamp of the first synchronization event and the synchronization event timestamp of the second synchronization event is calculated. A second difference between an accumulated timestamp of the first synchronization event and the accumulated timestamp of the second synchronization event is calculated. A runtime of the first thread of the application is calculated as a difference between the first difference and the second difference.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09280444&OS=09280444&RS=09280444
owner: SAP SE
number: 09280444
owner_city: Walldorf
owner_country: DE
publication_date: 20101011
---
The disclosed embodiments relate generally to identifying contention of shared resources in a runtime system.

Many processors include multiple processing cores. In order to take advantage of the multiple processing cores of a processor programmers write multi threaded applications in which multiple threads of an application are distributed across the processing cores of the processor and executed substantially simultaneously by the cores of the processor. The resources of the processor e.g. cache memory are typically shared between the threads of the application. Accordingly a first thread of the application may attempt to use the same resource as a second thread of the application. In order to maintain consistency of the shared resources only one thread is allowed to use a shared resource at any given time. All other threads are blocked from using the shared resource and must wait for their turn to use the shared resource. As a result deadlocks and or performance bottlenecks may occur because only a subset of the threads can execute in parallel while the other threads wait for the shared resources to become free.

The description that follows includes illustrative systems methods techniques instruction sequences and computing machine program products that embody illustrative embodiments. In the following description for purposes of explanation numerous specific details are set forth in order to provide an understanding of various embodiments of the inventive subject matter. It will be evident however to those skilled in the art that embodiments of the inventive subject matter may be practiced without these specific details. In general well known instruction instances protocols structures and techniques have not been shown in detail.

The embodiments described herein provide techniques for evaluating synchronization traces of contended synchronization primitives in a runtime environment that can execute multi threaded applications. These embodiments may be used to determine which software components methods and or threads block other software components methods and or threads from running due to contention of synchronization primitives that guard shared resources. The embodiments described herein also provide information about the contention of synchronization primitives between software components.

Some embodiments provide a user interface that allows a user to analyze thread synchronization problems by showing the threads that are contending for use of share resources. In some embodiments the user interface allows the user to analyze critical sections at a method and software component level. In some embodiments the user interface provides summaries and detailed information about contention of shared resources.

In the thread requires use of the shared resource and requests use of the synchronization primitive . Since the thread has not released use of the synchronization primitive the thread must wait e.g. idle until the thread has released use of the synchronization primitive .

In the thread releases use of the synchronization primitive . Accordingly the thread no longer has exclusive use of the shared resource .

In since the thread has released use of the synchronization primitive the thread acquires use of the synchronization primitive . Accordingly the thread now has exclusive use of the shared resource .

Note that requesting acquiring and releasing use of a synchronization primitive are each referred to as a synchronization operation herein. In some embodiments a synchronization event is emitted to a synchronization trace when a thread performs a synchronization operation involving a synchronization primitive.

In some embodiments a synchronization primitive is used to guard a shared resource. In these embodiments the synchronization operation may be an operation that requests use of the synchronization primitive and the corresponding synchronization event is an enter event corresponding to a time when the thread attempts to enter a critical section by requesting use of a synchronization primitive. The synchronization operation may also be an operation that acquires use of a synchronization primitive and the corresponding synchronization event is an entered event corresponding to a time when the thread enters the critical section by acquiring use of the synchronization primitive. The synchronization operation may also be an operation that releases use of a synchronization primitive and the corresponding synchronization event is an exit event corresponding to a time when the thread exits the critical section by releasing use of the synchronization primitive.

In some embodiments a synchronization primitive is used to notify threads of changed conditions. In these embodiments the synchronization operation may be an operation that waits for a change in a state of the synchronization primitive and the corresponding synchronization event is a wait event corresponding to a time when the thread starts waiting for a change in a state of the synchronization primitive. The synchronization operation may also be an operation that stops waiting for a change in the state of the synchronization primitive and the corresponding synchronization event is a waited event corresponding to a time when the thread has finished waiting for the change in the state of the synchronization primitive. The synchronization operation may also be an operation that notifies at least one other thread that the state of the synchronization primitive has changed and the corresponding synchronization event is a notify event corresponding to a time when the thread attempts to notify at least one other thread that the state of the synchronization primitive has changed.

Synchronization primitives that are used to notify threads of change conditions e.g. java.lang.Object.wait and java.lang.Object.notify for JAVA usually provide a mechanism to limit the amount of time a thread waits before the thread continues execution. Therefore wait events include the deadline of the waiting period. To distinguish between the possible outcomes when a synchronization primitive is used for notification a waited event may include one of the following exit types 

Notify events may also include additional thread identifiers. For example the additional thread identifiers may include thread identifiers for threads that the current thread notified. Depending on the synchronization primitive the number of threads may be zero e.g. no thread was notified because no thread was waiting for a changed condition one e.g. exactly one thread was notified of a changed condition or several e.g. more than one thread was notified of a changed condition .

In some embodiments the runtime environment provides monitoring functions to monitor synchronization primitives. Whereas third party application programming interfaces APIs allow a programmer to monitor system calls corresponding to synchronization operations e.g. a wait call the monitoring functions of the runtime environment also allow a programmer to obtain information about the synchronization primitives themselves. Since these monitoring functions are provided by the runtime environment the monitoring functions may also include more information about the contention of synchronization primitives and or shared resources that are not available with third party APIs. For example the monitoring functions may include an accumulated timestamp that can be used to identify the accumulated amount of time that the processor spent performing the runtime environment functions and or a synchronization primitive enumerator that allows the runtime system to correctly order the sequence of synchronization events.

The monitoring functions of the runtime system emit synchronization events to a synchronization trace in response to detecting synchronization operations performed by threads executing in the runtime system. In some embodiments the synchronization events emitted to the synchronization trace are used by a synchronization user interface module to display synchronization information relating to contention of synchronization primitives and or shared resources in the runtime system. Each synchronization event may include but is not limited to a synchronization event timestamp corresponding to a time at which a synchronization event was emitted to the synchronization trace an accumulated timestamp corresponding to the accumulated amount of time that the processor spent performing the runtime environment functions at the time that the synchronization event was emitted to the synchronization trace a value of a synchronization primitive enumerator for the synchronization primitive corresponding to the synchronization event at the time that the synchronization operation was performed an identifier for a thread corresponding to the synchronization event an identifier for a current thread that has acquired use of a synchronization primitive that the thread corresponding to the synchronization event requires an identifier for a next thread that will acquire use of the synchronization primitive that the thread corresponding to the synchronization event requires and a maximum amount of time that the thread may wait to acquire use of the synchronization primitive. Using the synchronization event timestamp the accumulated timestamp and the synchronization primitive enumerator the synchronization user interface module may display information including but not limited to a list of threads that a first thread blocks an amount of time that the first thread blocks each of the threads in the list of threads a number of times that the first thread blocks each of the threads in the list of threads a list of threads blocking a first thread an amount of time that each of the threads in the list of threads blocks the first thread a number of times that each of the threads in the list of threads blocks the first thread a list of threads that a synchronization primitive blocks an amount of time that the synchronization primitive blocks each thread in the list of threads a number of times that the synchronization primitive blocks each thread in the list of threads a list of methods blocking a first method an amount of time that each of the methods in the list of methods blocks the first method and a number of times that each of the methods in the list of methods blocks the first method.

At least two issues arise when attempting to display information about synchronization information relating to contention of synchronization primitives and or shared resources. First an amount of time that a first thread is blocked by a second thread may not correspond to a time interval between a time when the first thread requests use of a synchronization primitive guarding a shared resource and a time when the first thread acquires use of the synchronization primitive guarding the shared resource. This issue and a solution to this issue are illustrated in . Second an order in which synchronization events are emitted to a synchronization trace may not correspond to an order that the synchronization operations corresponding to the synchronization events actually occurred in the runtime system. This issue and a solution to this issue are illustrated in .

At time t the thread attempts to enter the critical section by performing a synchronization operation that requests use of the synchronization primitive that guards the shared resource . However since the thread is currently using the shared resource the thread waits until the synchronization primitive that guards the shared resource becomes free. The monitoring functions of the runtime environment emit to the synchronization trace an enter event corresponding to the synchronization operation that requests use of the synchronization primitive that guards the shared resource .

At time t the thread exits the critical section by performing a synchronization operation that releases use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an exit event corresponding to the synchronization operation that releases use of the synchronization primitive that guards the shared resource . After the thread releases use of the synchronization primitive that guards the shared resource e.g. at the next clock edge of a processor within a predetermined time period after the release of the synchronization primitive etc. the thread enters the critical section by performing a synchronization operation that acquires use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an entered event corresponding to the synchronization operation that acquires use of the synchronization primitive that guards the shared resource .

At time t the thread exits the critical section by performing a synchronization operation that releases use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an exit event corresponding to the synchronization operation that releases use of the synchronization primitive that guards the shared resource

As illustrated in the shared resource is not used before time t is used exclusively by thread between times tand time t is used exclusively by thread between times tand t and is free after time t.

Also as illustrated in the time interval wait between times tand t includes the time that the thread waits for the shared resource due to the fact that the thread is blocking the thread from using the shared resource . However the time interval wait also includes the time the processor is performing runtime system functions and or runtime system functions . Runtime system functions and or the runtime system functions may include functions that are not called by a user application. For example the runtime system functions and may include but are not limited to garbage collection functions functions that generate stack traces of threads functions that inspect memory functions that dump memory etc. The runtime system functions and may occur periodically or randomly during execution of the multi threaded application and affect the accuracy of the determination of the time that the thread blocks the thread . For example the runtime system functions may not be executed during the time interval wait . Similarly only a subset of the runtime system functions illustrated in may be executed during the time interval wait . Thus when the multi threaded application is analyzed over several successive runs of the multi threaded application or over several successive iterations of the execution of the critical sections and the amount of time that the processor spent executing runtime system functions and may vary from run to run or iteration to iteration . Accordingly in some embodiments when determining the amount of time that the thread blocks the thread the amount of time that the processor executes runtime system functions and during the time interval wait is subtracted from the time interval wait . These embodiments are described in more detail with respect to below.

As discussed above an order in which the synchronization events are emitted to the synchronization trace may not correspond to an order in which the synchronization operations corresponding to the synchronization events actually occurred. For example the synchronization operations may be emitted to the synchronization trace when shared resources are highly contended. is a timing diagram illustrating the identification of the order that threads of a multi threaded application block other threads of the multi threaded application according to some embodiments. As illustrated in before time t the shared resource is free e.g. not used by any threads . At time t the thread attempts to enter the critical section by performing a synchronization operation that requests use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to a synchronization trace an enter event corresponding to the synchronization operation that requests use of the synchronization primitive that guards the shared resource . Since the shared resource is currently free the thread enters the critical section by performing a synchronization operation that acquires use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an entered event corresponding to the synchronization operation that acquires use of the synchronization primitive that guards the shared resource . Note that although refers to the term lock e.g. request lock acquire lock release lock any type of synchronization primitive may be used.

At time t the thread attempts to enter the critical section by performing a synchronization operation that requests use of the synchronization primitive that guards the shared resource . However since the thread is currently using the shared resource the thread waits until the synchronization primitive that guards the shared resource becomes free. The monitoring functions of the runtime environment emit to the synchronization trace an enter event corresponding to the synchronization operation that requests use of the synchronization primitive that guards the shared resource .

At time t the thread attempts to enter the critical section by performing a synchronization operation that requests use of the synchronization primitive that guards the shared resource . However since the thread is currently using the shared resource the thread waits until the synchronization primitive that guards the shared resource becomes free. The monitoring functions of the runtime environment emit to the synchronization trace an enter event corresponding to the synchronization operation that requests use of the synchronization primitive that guards the shared resource .

Based on the synchronization operations e.g. requesting a lock acquiring a lock releasing a lock etc. that have occurred by time t the thread blocks the thread and the threads and block the thread . However the ordering of the synchronization events is determined using the time when the synchronization event is emitted and not when the synchronization operation is performed. Times tand tillustrate how an incorrect ordering of the synchronization events may result in an incorrect set of blocking threads.

At time t the thread exits the critical section by performing a synchronization operation that releases use of the synchronization primitive that guards the shared resource . Also shortly after time t e.g. at the next clock edge of a processor within a predetermined time period after the release of the synchronization primitive etc. the thread enters the critical section by performing a synchronization operation that acquires use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an entered event corresponding to the synchronization operation that acquires use of the synchronization primitive that guards the shared resource . However instead of emitting an exit event at time t one or more runtime system functions delay the monitoring functions of the runtime environment from emitting the exit event until time t. This behavior occurs because it is desirable to reduce the amount of code and the corresponding execution time of the code between acquiring a synchronization primitive and releasing the synchronization primitive to reduce the amount of time that a synchronization primitive and or shared resource is blocked. Accordingly code that reports an exit event is typically executed after the release of the synchronization primitive. As illustrated in at time t the monitoring functions of the runtime environment emit to the synchronization trace the exit event corresponding to the synchronization operation that releases use of the synchronization primitive that guards the shared resource . Thus the exit event occurs after the entered event . This ordering of synchronization events produces results that are not consistent with the order in which the corresponding synchronization operations actually occurred in the runtime system.

At time t the thread exits the critical section by performing a synchronization operation that releases use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an exit event corresponding to the synchronization operation that releases use of the synchronization primitive that guards the shared resource . Shortly after time t e.g. at the next clock edge of a processor within a predetermined time period after the release of the synchronization primitive etc. the thread enters the critical section by performing a synchronization operation that acquires use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an entered event corresponding to the synchronization operation that acquires use of the synchronization primitive that guards the shared resource .

At time t the thread exits the critical section by performing a synchronization operation that releases use of the synchronization primitive that guards the shared resource . The monitoring functions of the runtime environment emit to the synchronization trace an exit event corresponding to the synchronization operation that releases use of the synchronization primitive that guards the shared resource .

As illustrated in the shared resource is not used before time t is used exclusively by thread between times tand time t is used exclusively by thread between times tand t is used exclusively by the thread between times tand t and is free after time t.

To correctly report the sequence of synchronization operations performed in the runtime system some embodiments provide a synchronization primitive enumerator for a synchronization primitive that is incremented when the synchronization operation satisfies predetermined criteria. In some embodiments the synchronization operation satisfies predetermined criteria when the synchronization operation is an operation that releases the synchronization primitive. In some embodiments the synchronization primitive enumerator is only incremented when at least one other thread is awaiting use of the synchronization primitive. In other words the synchronization primitive enumerator is only incremented when at least two threads are contending for use of the synchronization primitive. In some embodiments the synchronization primitive enumerator is incremented when a number of threads awaiting use of the synchronization primitive becomes less than or equal to one. These embodiments account for the situation in which a synchronization primitive is in an inflated state when two or more threads are contending for the synchronization primitive and reverts to a deflated state when zero or one thread is using the synchronization primitive.

Exemplary values of the synchronization primitive enumerator are illustrated in . For example assuming that a value of a synchronization primitive enumerator is zero before time t the synchronization primitive enumerator is incremented by one when the thread releases the synchronization primitive because the synchronization primitive is in an inflated state starting at time t e.g. both the threads and are contending for use of the synchronization primitive . The synchronization primitive enumerator is incremented by one again when the thread releases the synchronization primitive . However unlike the previous incrementing of the synchronization primitive enumerator this incrementing of the synchronization primitive enumerator is due to the synchronization primitive transitioning from an inflated state to a deflated state. After the synchronization primitive is in the deflated state the synchronization primitive enumerator is no longer incremented when threads release the synchronization primitive . For example a value of the synchronization primitive enumerator remains the same when the thread releases the synchronization primitive . The synchronization primitive enumerator may be incremented again when the synchronization primitive is in the inflated state and a thread releases use of the synchronization primitive . Note that although the discussion above refers to incrementing the synchronization primitive enumerator when threads release the synchronization primitive the synchronization primitive enumerator may be incremented in response to other synchronization operations.

Using the synchronization primitive enumerator the correct ordering of the synchronization events is now achieved. Specifically the value of the synchronization primitive enumerator for the exit event is 0 and the value of the entered event is 1. Thus the exit event is determined to occur before the entered event .

In some embodiments the synchronization event includes a value of a synchronization primitive enumerator at the time that the synchronization operation occurred. In other words the value of the synchronization primitive enumerator is not the value at the time the synchronization event is emitted but is instead the value of the synchronization primitive enumerator at the time the synchronization event e.g. when requesting use of the synchronization primitive when acquiring use of the synchronization primitive when releasing use of the synchronization primitive etc. occurred.

Attention is now directed to which is a block diagram illustrating a synchronization event data structure according to some embodiments. The synchronization event data structure includes synchronization events . A respective synchronization event includes a thread identifier identifying a thread corresponding to a synchronization operation a synchronization primitive identifying a synchronization primitive on which the synchronization operation is performed an event type identifying the type of synchronization operation being performed a synchronization event timestamp identifying a time that the synchronization operation is reported to the runtime system e.g. a time when the synchronization event is emitted to the synchronization trace an accumulated timestamp indicating an accumulated amount of time that the processor has performed runtime system functions at the time the synchronization operating is reported to the runtime system and a synchronization primitive enumerator identifying an ordering of a sequence of synchronization operations performed on the synchronization primitive. In some embodiments the synchronization events include stack traces for respective threads associated with the respective synchronization event.

The computer system also includes an operating system that includes procedures for handling various basic system services and for performing hardware dependent tasks.

The machine is capable of executing a set of instructions sequential or otherwise that specify actions to be taken by that machine. Further while only a single machine is illustrated the term machine shall also be taken to include any collection of machines that individually or jointly execute a set or multiple sets of instructions to perform any one or more of the methodologies discussed herein.

The example of the computer system includes a processor e.g. a central processing unit CPU a graphics processing unit GPU or both and memory which communicate with each other via bus . Memory includes volatile memory devices e.g. DRAM SRAM DDR RAM or other volatile solid state memory devices non volatile memory devices e.g. magnetic disk memory devices optical disk memory devices flash memory devices tape drives or other non volatile solid state memory devices or a combination thereof. Memory may optionally include one or more storage devices remotely located from the computer system . The computer system may further include video display unit e.g. a plasma display a liquid crystal display LCD or a cathode ray tube CRT . The computer system also includes input devices e.g. keyboard mouse trackball touchscreen display etc. output devices e.g. speakers and a network interface device . The aforementioned components of the computer system may be located within a single housing or case e.g. as depicted by the dashed lines in . Alternatively a subset of the components may be located outside of the housing. For example the video display unit the input devices and the output device may exist outside of the housing but be coupled to the bus via external ports or connectors accessible on the outside of the housing.

Memory includes a machine readable medium on which is stored one or more sets of data structures and instructions e.g. software embodying or utilized by any one or more of the methodologies or functions described herein. The one or more sets of data structures may store data. Note that a machine readable medium refers to a storage medium that is readable by a machine e.g. a computer readable storage medium . The data structures and instructions may also reside completely or at least partially within memory and or within the processor during execution thereof by computer system with memory and processor also constituting machine readable tangible media.

The data structures and instructions may further be transmitted or received over a network via network interface device utilizing any one of a number of well known transfer protocols e.g. HyperText Transfer Protocol HTTP . Network can generally include any type of wired or wireless communication channel capable of coupling together computing nodes e.g. the computer system . This includes but is not limited to a local area network a wide area network or a combination of networks. In some embodiments network includes the Internet.

As discussed above the actual runtime of an application or thread is typically different than a simple difference between two events of the application e.g. a start and an end of the application . This discrepancy in the actual runtime of the application or thread is due to the fact that the runtime system itself has to do some work e.g. updating its own data structures or doing general clean up such as garbage collection . During this time the application or thread typically stops execution of its own code while the runtime system performs its functions. Hence some embodiments determine the time during which the application or thread was temporarily stopped so that the actual runtime of the application or thread can be calculated. Thus the runtime of the application or thread includes only the time that the runtime system or the processor spent executing application code and does not include the time that the runtime system or the processor spent executing runtime system functions or other functions not called by the application or thread .

The synchronization user interface module calculates a first difference between the synchronization event timestamp of the first synchronization event and the synchronization event timestamp of the second synchronization event. Continuing the example from above the difference between the values of the first and second timestamps is 15 minutes.

The synchronization user interface module calculates a second difference between the accumulated timestamp of the first synchronization event and the accumulated timestamp of the second synchronization event. Continuing the example from above the difference between the values of the first and second timestamps is 5 minutes. As discussed above this difference indicates the total amount of time that the runtime system functions were executing in the runtime system module during the execution of the first thread.

The synchronization user interface module calculates a runtime of the first thread of the application as a difference between the first difference and the second difference. Continuing the example from above the actual runtime of the first thread is 15 5 10 minutes.

In some embodiments the synchronization user interface module displays the runtime of the first thread of the application in a user interface of the computer system .

The synchronization user interface module identifies the second thread that blocked the first thread. For example the synchronization user interface module may analyze synchronization events in the synchronization trace to identify the second thread that blocked the first thread.

The synchronization user interface module determines a number of times that the second thread blocked the first thread. For example the synchronization user interface module may analyze synchronization events in the synchronization trace to identify a number of times that the second thread blocked the first thread.

The synchronization user interface module displays in a user interface of the computer system the number of times that the second thread blocked the first thread.

The synchronization user interface module identifies the second thread that blocked the first thread. For example the synchronization user interface module may analyze synchronization events in the synchronization trace to identify the second thread that blocked the first thread.

The synchronization user interface module determines a number of times that the synchronization primitive used by the second thread blocked the first thread. For example the synchronization user interface module may analyze synchronization events in the synchronization trace to identify a number of times that the synchronization primitive used by the second thread blocked the first thread.

The synchronization user interface module displays the number of times that the synchronization primitive used by the second thread blocked the first thread in a user interface of the computer system .

The synchronization user interface module identifies a plurality of threads that blocked the first thread. For example the synchronization user interface module may analyze synchronization events in the synchronization trace to identify the plurality of thread that blocked the first thread.

The synchronization user interface module displays in a user interface of the computer system the plurality of threads that blocked the first thread.

The synchronization user interface module identifies a plurality of threads that blocked the first thread. For example the synchronization user interface module may analyze synchronization events in the synchronization trace to identify the plurality of thread that blocked the first thread.

The synchronization user interface module determines a number of times that each thread in the plurality of threads blocked the first thread. For example the synchronization user interface module may analyze synchronization events in the synchronization trace to identify a number of times that each thread in the plurality of threads blocked the first thread.

The synchronization user interface module displays in a user interface of the computer system the number of times that each thread in the plurality of threads blocked the first thread.

Determining which thread blocks another thread from acquiring a contended synchronization primitive is crucial for calculating the dependencies between the involved threads. It is rather useless to know that a thread of execution was blocked without knowing the actual reason e.g. the thread of execution blocking it .

Additionally synchronization primitives may become contended at any time and contention may disappear any time. In some embodiments the synchronization monitoring functions only emit synchronization events for contended synchronization primitives. In these embodiments the synchronization events in the synchronization trace may not be complete. For example it is possible that the synchronization trace includes enter and entered events for a synchronization primitive but not the corresponding exit event because the contention was resolved meanwhile. The synchronization user interface module has to handle missing events without displaying incorrect or confusing results. Thus in some embodiments the synchronization user interface module considers synchronization events if the complete set of synchronization events is available e.g. an enter event is ignored if no corresponding entered and exit events are received .

Note that it is typically not sufficient to only determine the thread that was blocking another thread. For proper analysis and resolution of the problem the user also needs to know what the thread was executing when it blocked another thread. Thus in some embodiments the synchronization events include information about what the thread was executing at the time the synchronization events were emitted to the synchronization trace. In systems capable of running more than one thread of execution in parallel this is a severe problem because in general there is no easy way of determining the state of a running thread without stopping it. Pausing threads is not desirable for a profiler because it seriously impacts performance and changes the runtime behavior. Thus in some embodiments instead of pausing threads the monitoring functions emit stack traces to the synchronization trace. The synchronization user interface may use the stack traces from the exit events as the stack trace of threads blocking other threads. Although the stack trace from exit events may not be the exact stack trace of the blocking thread when the other thread become blocked using the stack trace of the exit event allows the user to identify the critical section that caused the other thread to be blocked. Knowing the exact position inside the critical section does not add much value since it does not differ from a synchronization point of view e.g. if a critical section includes statements one to three the other thread becomes blocked independent from the current execution position of the thread in the critical section .

In some embodiments the synchronization user interface module takes the events emitted from the synchronization trace evaluates them and visualizes the results. This way the user can start with a comprehensible set of information and drill down into the details of the synchronization problems at hand without being overwhelmed by the amount of information that the synchronization trace includes.

In some embodiments there are two main entry points for the user provided by the synchronization user interface module . First it is possible to begin by focusing on the threads of execution and the contention between them. Second the user can start by directly taking the synchronization primitives into account and look for extensive contention of synchronization primitives. While the first approach is especially useful in environments where each task application runs in its own thread of execution the second one may be better suited for application servers or environments where tasks run on a shared thread pool in a time sharing fashion e.g. i.e. some parts of a task application may be executed on several different threads .

Using the first entry point the blocked thread statistics may show for each thread of execution how often it was blocked by any synchronization primitive and how long it was blocked overall. The times are reported in actual application runtime as discussed above . By selecting a number of threads from the blocked thread statistic the user may drill down into the blocking thread statistic that displays the threads that have been blocking the selected threads. In the blocking thread statistic every thread is annotated with the number of times it has blocked one of the formerly selected threads and with the application runtime the selected thread was blocked.

Both thread statistics allow the user to drill down into a calling method statistic that shows the stack traces of the threads e.g. the stack trace when the thread was blocked or the stack of the thread blocking another thread . For every distinct stack trace of a thread of execution the calling method statistic of the synchronization user interface module shows how long each stack trace was blocked overall and how often it happened. From this point the synchronization user interface module enables the user to deep dive into any suitable single blocking occurrence and to analyze which occurrence took how long.

Using the second major entry point users can start from the contended synchronization primitives. In this statistic each contended synchronization primitive is displayed with a number of times any thread of execution was blocked waiting for exclusive access of this synchronization primitive and the accumulated application runtime that was wasted by the blocked threads e.g. the cumulative time any thread was blocked due to contention of this synchronization primitive . By selecting any number of synchronization primitives the synchronization user interface module enables the user to get blocked thread statistics for the selected synchronization primitives. Furthermore it is possible to deep dive into the single blocking occurrences. Doing so may provide for example insights into whether only a few blocking occurrences took a long time or if the blocking time is uniformly distributed.

Certain embodiments are described herein as including logic or a number of components modules or mechanisms. Modules may constitute either software modules e.g. code and or instructions embodied on a machine readable medium or in a transmission signal or hardware modules. A hardware module is a tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments one or more computer systems e.g. the computer system or one or more hardware modules of a computer system e.g. a processor or a group of processors may be configured by software e.g. an application or application portion as a hardware module that operates to perform certain operations as described herein.

In various embodiments a hardware module may be implemented mechanically or electronically. For example a hardware module may comprise dedicated circuitry or logic that is permanently configured e.g. as a special purpose processor such as a field programmable gate array FPGA or an application specific integrated circuit ASIC to perform certain operations. A hardware module may also comprise programmable logic or circuitry e.g. as encompassed within a general purpose processor or other programmable processor that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware module mechanically in dedicated and permanently configured circuitry or in temporarily configured circuitry e.g. configured by software may be driven by cost and time considerations.

Accordingly the term hardware module should be understood to encompass a tangible entity be that an entity that is physically constructed permanently configured e.g. hardwired or temporarily configured e.g. programmed to operate in a certain manner and or to perform certain operations described herein. Considering embodiments in which hardware modules are temporarily configured e.g. programmed each of the hardware modules need not be configured or instantiated at any one instance in time. For example where the hardware modules comprise a general purpose processor configured using software the general purpose processor may be configured as respective different hardware modules at different times. Software may accordingly configure a processor for example to constitute a particular hardware module at one instance of time and to constitute a different hardware module at a different instance of time.

Modules can provide information to and receive information from other modules. For example the described modules may be regarded as being communicatively coupled. Where multiples of such hardware modules exist contemporaneously communications may be achieved through signal transmission e.g. over appropriate circuits and buses that connect the modules. In embodiments in which multiple modules are configured or instantiated at different times communications between such modules may be achieved for example through the storage and retrieval of information in memory structures to which the multiple modules have access. For example one module may perform an operation and store the output of that operation in a memory device to which it is communicatively coupled. A further module may then at a later time access the memory device to retrieve and process the stored output. Modules may also initiate communications with input or output devices and can operate on a resource e.g. a collection of information .

The various operations of example methods described herein may be performed at least partially by one or more processors that are temporarily configured e.g. by software code and or instructions stored in a machine readable medium or permanently configured to perform the relevant operations. Whether temporarily or permanently configured such processors may constitute processor implemented or computer implemented modules that operate to perform one or more operations or functions. The modules referred to herein may in some example embodiments comprise processor implemented or computer implemented modules.

Moreover the methods described herein may be at least partially processor implemented or computer implemented and or processor executable or computer executable . For example at least some of the operations of a method may be performed by one or more processors or processor implemented or computer implemented modules. Similarly at least some of the operations of a method may be governed by instructions that are stored in a computer readable storage medium and executed by one or more processors or processor implemented or computer implemented modules. The performance of certain of the operations may be distributed among the one or more processors not only residing within a single machine but deployed across a number of machines. In some example embodiments the processors may be located in a single location e.g. within a home environment an office environment or as a server farm while in other embodiments the processors may be distributed across a number of locations.

While the embodiment s is are described with reference to various implementations and exploitations it will be understood that these embodiments are illustrative and that the scope of the embodiment s is not limited to them. In general techniques for identifying contention of shared resources in a runtime system may be implemented with facilities consistent with any hardware system or hardware systems defined herein. Many variations modifications additions and improvements are possible.

Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the embodiment s . In general structures and functionality presented as separate components in the exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements fall within the scope of the embodiment s .

The foregoing description for purpose of explanation has been described with reference to specific embodiments. However the illustrative discussions above are not intended to be exhaustive or to limit the embodiments to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain the principles and its practical applications to thereby enable others skilled in the art to best utilize the embodiments and various embodiments with various modifications as are suited to the particular use contemplated.

