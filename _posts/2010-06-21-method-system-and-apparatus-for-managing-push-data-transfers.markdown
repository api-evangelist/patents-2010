---

title: Method, system and apparatus for managing push data transfers
abstract: A method, system, and apparatus for managing push data transfers is provided whereby in one implementation at least one push data server is situated on a network between a plurality of content servers and a plurality of computing devices. The push data server is configured to only perform a maximum number of concurrent data transfers of content between the content servers and the plurality of computing devices. The push data server is configured to deem that a particular push data transfer has been completed even if no express acknowledgment of such completion is ever received at the push data server, thereby reducing the likelihood of failure of push data transfers due to a misperception that the maximum number of concurrent data transfers being obtained.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09178949&OS=09178949&RS=09178949
owner: BLACKBERRY LIMITED
number: 09178949
owner_city: Waterloo
owner_country: CA
publication_date: 20100621
---
The present specification claims priority from U.S. Provisional Patent Application 61 310 016 filed Mar. 3 2010 the contents of which are incorporated herein by reference.

The present specification relates generally to telecommunications and more particularly relates to a method system and apparatus for managing push data transfers.

Computing devices that connect to servers frequently connect to those servers via one or more network intermediaries such as a mobile telecommunication carrier an enterprise or a manufacturer of the computing device. Increasingly data is pushed to those computing devices from those servers.

An aspect of this specification provides a method for managing push data transfers comprising receiving content at a push data server from a content server for push delivery to a computing device beginning a push data transfer of the content to the computing device from the push data server incrementing a counter for use in determining a maximum number of concurrent push data transfers that can be effected from the push data server and decrementing the counter after the push data transfer is determined to be actually completed or deemed to be completed.

The method can comprise deeming the push data transfer to be completed after a predefined time limit has been reached receiving at the push data server transfer parameters the transfer parameters can include data representing parameters of a historic successfully completed push data transfer and determining the predefined time limit by comparing the transfer parameters.

The transfer parameters can further include at least one of a beginning time and ending time a transfer duration a content size server specifications and link specifications.

The push data transfer can be determined to be actually completed when an acknowledgement is received by the push data server confirming completion of the push data transfer. The comparing can include applying a probability model such that the push data server can infer with a high degree of confidence that the push data transfer is actually completed.

The applying a probability model can include compiling a table of values of the transfer parameters and determining a mean and standard deviation for the transfer parameters that best match an expected duration of time to be used as the predefined time limit. The applying a probability model can include employing a cumulative distribution function to determine a minimum time duration to be used as the predefined time limit.

The method can comprise receiving at the push data server a push data transfer request determining a capacity comparing the capacity to the counter and when the capacity equals the counter queuing the push data transfer request.

The beginning the push data transfer can start when the capacity is greater than the counter. The queuing the push data transfer request can include maintaining at the push data server a record of push data transfer requests. The queuing the push data transfer request can include rejecting the push data request.

The rejecting the push data transfer request can include sending an error message to the content server.

The method can comprise tracking of successful push data transfers where acknowledgements of completions are received at the push data server.

Another aspect of the specification provides a push data server comprising a processor configured to receive content from a content server for push delivery to a computing device begin a push data transfer of the content to the computing device increment a counter for use in determining a maximum number of concurrent push data transfers that can be effected from the push data server and decrement the counter after the push data transfer is determined to be actually completed or deemed to be completed.

The processor can be further configured to deem the push data transfer to be completed after a predefined time limit has been reached. The processor can be further configured to receive transfer parameters the transfer parameters can include data representing parameters of a historic successfully completed push data transfer and determine the predefined time limit by comparing the transfer parameters.

The transfer parameters can further include at least one of a beginning time and ending time a transfer duration a content size server specifications and link specifications.

The processor can be further configured to determine that the push data transfer is actually completed when the processor receives an acknowledgement confirming completion of the push data transfer.

Another aspect of this specification provides a computer program product for a push data server comprising a computer readable storage medium having a computer readable program code adapted to be executable on the push data server to implement a method for managing push data transfers the method comprising receiving content at a push data server from a content server for push delivery to a computing device beginning a push data transfer of the content to the computing device from the push data server incrementing a counter for use in determining a maximum number of concurrent push data transfers that can be effected from the push data server and decrementing the counter after the push data transfer is determined to be actually completed or deemed to be completed.

A method system and apparatus for managing push data transfers is provided whereby in one implementation at least one push data server is situated on a network between a plurality of content servers and a plurality of computing devices. The push data server is configured to only perform a maximum number of concurrent data transfers of content between the content servers and the plurality of computing devices. The push data server is configured to deem that a particular push data transfer has been completed even if no express acknowledgment of such completion is ever received at the push data server thereby reducing the likelihood of failure of push data transfers due to a misperception that the maximum number of concurrent data transfers being obtained.

Referring now to a system for managing pushed data transfers is indicated generally at . System comprises a plurality of content servers . . . . Hereafter generically each is referred to as server and collectively they are referred to as servers . This nomenclature is used elsewhere herein. Each server is configured to host its own content and to deliver that content to a wide area network WAN infrastructure via a respective link . . . Hereafter generically each is referred to as link and collectively they are referred to as links .

System also comprises a plurality of computing devices . . . . Hereafter generically each is referred to as computing device and collectively they are referred to as computing devices . Computing devices are configured to connect to WAN infrastructure via their own respective links . . . Hereafter generically each is referred to as link and collectively they are referred to as links and as will be discussed in further detail below are configured to receive content via a pushed data transfer.

WAN infrastructure also comprises amongst other things a main intermediation infrastructure and a plurality of secondary intermediation servers . . . . Hereafter generically each is referred to as server and collectively they are referred to as servers . Links . . . hereafter generically each is referred to as link and collectively they are referred to as links connect intermediation infrastructure and secondary intermediation servers .

WAN infrastructure can comprise or connect to other computer equipment which is not shown and which may be configured to provide services applications other content or otherwise communicate with for whatever purpose to each computing device . WAN infrastructure can also comprise or be part of the Internet.

Main intermediation infrastructure comprises at least one push server and may also comprise a plurality of additional servers to fulfill other intermediation functions between computing devices and other computer equipment not shown. At least one push server as will be discussed below is configured to retrieve content and to simultaneously push retrieved content to a plurality of computing devices subject to a maximum predefined number of transfers.

In one non limiting implementation main intermediation infrastructure can be based on the mobile data services MDS component from Research In Motion Inc. of Waterloo Canada while the secondary intermediation servers can be based on a BlackBerry Enterprise Server BES or a BlackBerry Internet Server BIS also from Research In Motion Inc. of Waterloo Canada. Again these are non limiting examples and in other implementations for example main intermediation infrastructure and secondary intermediation servers can be omitted in lieu of including at least one push server within WAN infrastructure .

Links links links can be based on any wired structure or wireless structures or combinations thereof. Typically though not necessarily computing devices are wireless and therefore at least a portion of link comprises a wireless base station so that link finally connects to each computing device uses one or more wireless protocols including but not limited to Global System for Mobile communication GSM General Packet Relay Service GPRS Enhanced Data Rates for GSM Evolution EDGE G High Speed Packet Access HSPA Code Division Multiple Access CDMA Evolution Data Optimized EVDO Institute of Electrical and Electronic Engineers IEEE standard 802.11 Bluetooth or any of their variants or successors. It is also contemplated each computing device can include multiple radios to accommodate the different protocols that may be used to implement that final portion of link .

The portion of each link that connects to its respective server is typically wired and comprises a backhaul wired via a T carrier link e.g. T1 T3 or E carrier link or the like. By the same token links and are typically wired and can also comprise a backhaul or can otherwise be effected via the Internet . In general the nature of each link and is not particularly limited.

It is to be understood that each server each server and the at least one server can each be implemented using an appropriately configured hardware computing environment comprising at least one processor volatile storage e.g. random access memory non volatile storage e.g. hard disk drive and at least one network interface all interconnected by a bus. Other components can also be connected to the processor via the bus such as input devices and output devices. Likewise it is to be understood that the hardware computing environment of any particular server is configured to execute an operating system and other software such that the servers are ultimately configured to perform according to the teachings herein. Furthermore it will be understood that each server can itself be implemented as several different servers to provide redundancy or load balancing or alternatively one or more servers in can be consolidated into a single server.

Like servers the structure and features of each computing device can vary. Typically however each computing device thus includes a processor which is configured to receive input from input devices e.g. a trackball a joystick a touch pad a touch screen a keyboard a microphone and to control various output devices e.g. a speaker a display an light emitting diode LED indicator a vibration unit . The Processor is also connected to volatile storage which can be implemented as random access memory and non volatile storage which can be implemented using flash memory or the like or can include other programmable read only memory PROM technology or can include read only memory ROM technology or can include a removable smart card or can comprise combinations of the foregoing. Those skilled in the art will now recognize that such volatile and non volatile storage are non limiting examples of computer readable media capable of storing programming instructions that are executable on processor.

Each device also includes a network interface such as a wireless radio for connecting device to its respective link . Each device also includes a battery which is typically rechargeable and provides power to the components of computing device . Collectively one can view the processor and storage of each device microcomputer. It is now apparent that each device can be based on the structure and functionality of a portable wireless device such as a BlackBerry handheld device but it is to be stressed that this is a purely non limiting exemplary device as device could also be based on any type of client computing device including portable wireless devices from other manufacturers desktop computers laptop computers cellular telephones and the like.

The microcomputer implemented on client is thus configured to store and execute the requisite BIOS operating system and applications to provide the desired functionality of client . In a present embodiment each client is configured to have any content pushed to its non volatile storage unit via push server and its respective secondary intermediation server .

Referring now to a method for managing push data transfers is represented in the form of a flowchart and indicated generally at . Method can be implemented using system or variations thereof. In particular method can also be implemented by push server .

Block comprises determining a capacity. The capacity represents the maximum number of push transfers that are to be simultaneously managed using method . The capacity can be fixed or predefined as part of an architecting system or the capacity may change in real time during or even throughout each performance of method . Generally the capacity may be based on a level of consumption of resources throughout system reflecting the maximum capacity overall which results from whichever component in system has the least capacity. Those skilled in the art will recognize that the available resources within system are dynamic particularly where the components in system have multiple functions beyond the function of effecting push data transfers of content from one or more servers to one or more computing devices . Furthermore different branches of system may have different capacities. For example link link and link which would be used to push content to device in their aggregate may have a first capacity while link link and link in their aggregate may have a second capacity different from the first capacity. Such link capacities may be based on bandwidth for example. Furthermore in addition to links having different capacities servers may each have different capacities whereby server has a different capacity than server . By the same token second server may have a different capacity that server . In any event push server will have its own capacity regardless of the capacity of other components in system . Also each device will have its own capacity to accept push data transfers. Such server and device capacities may be based on processor speed amount of memory network interface limitations and the number of other processing threads that are executing in addition to method . Other metrics for capacity will now occur to those skilled in the art. Furthermore individual and aggregate capacities may change according to time of day or based on resource allocation priorities or other factors. Accordingly in more complex implementations of system block can comprise determining different capacities corresponding to different content push data transfer scenarios and managing the number of push transfers according to those different capacities. However for purposes of providing a simplified but non limiting illustration of method it will be assumed that a maximum capacity of two is determined at block . In a further variation which can be provided in addition to or lieu of the foregoing an application programming interface can be provided at one or more of servers server or server or other suitable location in system where an administrator can manually set the capacity to a predefined level including a level of zero so that at a local level the resources that are consumed by push data transfers can be manually controlled.

Block comprises determining whether the capacity at block has been reached. When method is performed by push server push server can examine a counter or other software object that represents the number of data transfers currently being pushed from servers to devices . If the capacity defined at block has been exceeded e.g. according the specific example referenced above a counter or software object indicates that two or more push data transfers are currently being effected then method advances to block at which point any further push data transfer requests are queued and then method cycles back to block . The means by which such queuing is effected is not particularly limited. For example push server can be configured to locally maintain a record of push data transfer requests or push server can be configured at block to reject ignore or drop push data requests with or without the return of an error message leaving it to the requesting network component to reissue the push data request. At this point it can also be noted that push data transfer requests reflect any instruction to push server to transfer content from a given server to a given device and that such instructions can originate from any component in system and typically do not originate from the device itself. More typically a request to push content originates from it own server For example a request to push content to a given device originates from server itself while a request to push content to a given device originates from server 

It can also be noted that the source of a push data request can be reflective of the nature or type of content but that in any event the nature or type of content is not particularly limited. As a simple example where device has subscribed to a weather service hosted by for example server then content can reflect a weather report that is periodically pushed by server to that device thereby providing automatic weather report updates on device . Other types of content can include but are certainly not limited to news sports traffic stock instant messages social networking status updates videos music chats software applications firmware updates services and the like.

In this example however it will be assumed that during this initial performance of method a total of zero transfers are currently being effected and since zero is less than the exemplary two introduced above a no determination is reached at block and method would therefore advance to block .

Block comprises determining if there are any outstanding push requests. Again in the specific example contemplated in relation to system block is effected by server waiting for a new push data transfer request or where server maintains queues of unprocessed push data transfer requests then examining such a queue to determine if any push data requests are within that queue. A No determination at block results in looping at block effectively placing server into a wait state until a push data transfer request is received. A yes determination at block leads to block .

Block comprises initiating a push data transfer request. In the specific example contemplated in relation to system block is effected by server commencing a push data transfer and without actually waiting for such a transfer to complete method cycles back to block where method begins anew. It can be noted that when block is reached a number of times that is equal to the capacity determined at block then yes determinations will be made at block resulting in cessation of processing of further push data transfer requests. Accordingly and as will be discussed further below a parallel method is performed which monitors progress of push data transfers and track or possibly deems completion of push data transfers so as to reduce the likelihood of method being prevented from reaching block due to a persistent yes determination being made at block .

Method as shown in provides a non limiting example of a method that can be performed in parallel to method so as to reduce the likelihood of method being prevented from reaching block from block .

Block comprises receiving content. In the specific example contemplated in relation to system block is effected by push data server receiving a particular item of content from its respective server . For example assume that a pending data transfer request comprises a request to push content to device . Accordingly as part of performing block content is received locally at push data server .

Block comprises beginning a push data transfer of the content received at block . In the specific example being discussed block is effected by push data server initiating a transfer of content from push data server to device making appropriate use if link and server and link .

Block comprises incrementing a counter. The counter increments the recorded number of active downloads and is accessible at block in order to determine the number of currently active push data transfers. In accordance with the example discussed above the counter will therefore increase to one from zero during this invocation of block such that a parallel performance of block will still result in a No determination leading method to block from block .

Block comprises determining if the push data transfer that was initiated at block is complete. A yes determination is made at block when an acknowledgment is received from device or server at server expressly confirming that content has been received by device . The duration of time to complete the push data transfer can vary according to the size of content and the amount of bandwidth available between push data server and device and accordingly it is contemplated that a no determination may be made at block .

On a no determination at block method advances to block at which point a determination is made as to whether a predefined time limit has been reached. The method by which such a time limit is reached is not particularly limited although a presently contemplated method is discussed further below. In general the time limit corresponds to an expected time for the transfer to complete.

Block which can be reached from a yes determination at either block or block comprises decrementing the counter that was incremented at block . In accordance with the example discussed above and assuming no other invocations of method have occurred then counter will therefore decrease to zero from one during this invocation of block such that a parallel performance of block will also result in a No determination leading method to block from block .

Having discussed a simple invocation of method and method involving only a single push data transfer those skilled in the art will now appreciate the behavior of system when multiple simultaneous push data transfer requests are received by push data server . For example recall a hypothetical capacity of two push data transfer requests is determined at block . Now assume that three push data transfer requests are received at server initially two are received from server and then subsequently one is received from server while the first two from server are still be processed using method and method . When the third data transfer request is received at server method will reach block and the third data transfer request will be queued until one of the first two is determined to be actually completed at block or one of the first to is deemed to be completed at block . Those skilled in the art will now also appreciate one of the advantages of the present specification in that in the event an express acknowledgement of a push data transfer is never received at block then push data transfers from server can still continue due to the deeming of such completion occurring due to performance of block . At the same time method and method also regulate the utilization of network resources in system so that push data transfers or other functions of system do not fail due to overwhelming of those resources due to an overabundance of push data transfers.

As indicated above the means by which the time limit used in block can be determined is not particularly limited. A simple predefined time period can be preselected. In a more complex implementation the time limit may dynamically change according to historical behavior of system including but not limited to tracking the history of acknowledged data transfers. Method in shows on non limiting example of how the time limit in block can be determined using such historical tracking. Method can be run from time to time or in real time in conjunction with method and method to constantly update a time limit that will be used for specific performances of method . Block comprises receiving transfer parameters. Block thus comprises receiving at server or at another computational resource data representing parameters of a historic successfully completed push data transfer whereby an express acknowledgement was actually received confirming completion of the specific push data transfer. Server can for example be configured to input data into block every time a yes determination is reached at block . Such data at block can be comprise to a simple identification of the content that was successfully transferred as well as the time it took to complete that transfer. The data received at block can further comprise an identification of the specific links servers or other network resources involved in the transfer.

Block comprises storing the transfer parameters received at block in a table or other data base resource. Block comprises comparing all of the parameters in the table or other data base resource and block comprises determining a time limit to be used at block based on the comparison from block . The operations used to perform the comparison at block and the determination at block are not particularly limited. In one implementation block and block apply a probability model to the performance of system such that server can infer with a high degree of confidence that data transfers are actually completed even though no completion status i.e. a yes determination has been determined at block . The time limit that is established for block may be determined by historical tracking of successful push data transfers where acknowledgements of such completions are actually received at block and thereby result in a yes determination at block . A table of values can be compiled of historical data from various performances of block and block that comprises the beginning time and ending time of push data transfers and can also comprise transfer duration content size which server is used and which of links and were utilized. Where a plurality of push data servers are employed within a variation of system the table of values can additionally comprise an indication of which push data server was employed. Using the table server or other computational device can be employed to determine a mean and standard deviation for the sample data that best matches an expected duration of time which can then be employed to establish a time limit for use at block in relation to a particular push data transfer during a particular cycle of method . A Cumulative Distribution Function CDF can be employed to determine a minimum time duration that would account for the minimum cumulative probability needed to assume completion of a push data transfer that is initiated at block . Accordingly the time limit established for block can vary between each invocation of method according the specific circumstances of a particular push data transfer.

In preliminary calculations performed by the inventor sample data recorded in a table for a system that is reflective of system substantially matches a normal distribution. However the inventor further believes that versions of system where statistical calculations generate data that do not fit a normal distribution can still be used to generate a time limit for block as in such a situation lacking a normal distribution instead of calculating the mean and standard deviation the time limit can be based on about the 95th percentile value for the sample data that is applicable. Thus in a variation the time limit established for block may be based on a value that accounts for only about 95 of all download durations in the above referenced table of values. The remaining about 5 of transfers that exceed a value may be deemed to be an acceptable failure risk and permit the maximum to be exceeded but by a fairly limited amount.

