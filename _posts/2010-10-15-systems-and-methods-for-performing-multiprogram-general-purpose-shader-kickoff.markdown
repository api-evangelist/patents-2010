---

title: Systems and methods for performing multi-program general purpose shader kickoff
abstract: Systems and methods for thread group kickoff and thread synchronization are described. One method is directed to synchronizing a plurality of threads in a general purpose shader in a graphics processor. The method comprises determining an entry point for execution of the threads in the general purpose shader, performing a fork operation at the entry point, whereby the plurality of threads are dispatched, wherein the plurality of threads comprise a main thread and one or more sub-threads. The method further comprises performing a join operation whereby the plurality of threads are synchronized upon the main thread reaching a synchronization point. Upon completion of the join operation, a second fork operation is performed to resume parallel execution of the plurality of threads.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08499305&OS=08499305&RS=08499305
owner: VIA Technologies, Inc.
number: 08499305
owner_city: Taipei
owner_country: TW
publication_date: 20101015
---
The present application relates generally to a programmable graphics pipeline in a GPU graphics processing unit and more particularly to systems and methods for performing multi program general purpose shader kickoff in a GPU pipeline.

Computer graphics processing systems process large amounts of data including texture data among others. A texture is a digital image often rectangular having a u v coordinate space. The smallest addressable unit of a texture is a texel which is assigned a specific u v coordinate based on its location. In a texture mapping operation a texture is mapped to the surface of a graphical model as the model is rendered to create a destination image. In the destination image pixels are located at specific coordinates in the x y coordinate system. The purpose of texture mapping is to provide a realistic appearance on the surface of objects.

The Direct3D 11 specification from MICROSOFT defines a new kind of shader known as a compute shader that offers such features as multi thread support to aid in the development of such graphics intensive applications as video games. The compute shader provides access to the computing power and bandwidth of SIMD single instruction multiple data cores such as those used in graphics processors. A compute shader is invoked as multiple threads where the threads are divided into thread groups. While synchronization operations exist to provide ordering of thread execution such synchronization techniques may be bandwidth and memory intensive.

Briefly described one embodiment among others is a method for synchronizing a plurality of threads in a general purpose shader in a graphics processor. The method comprises determining an entry point for execution of the threads in the general purpose shader performing a fork operation at the entry point whereby the plurality of threads are dispatched wherein the plurality of threads comprise a main thread and one or more sub threads. The method further comprises performing a join operation whereby the plurality of threads is synchronized upon the main thread reaching a synchronization point. Upon completion of the join operation a second fork operation is performed to resume parallel execution of the plurality of threads.

Another embodiment is a graphics system for performing synchronized execution of a plurality of software threads in a general purpose GP shader of a graphics pipeline. The system comprises a GP task constructor for creating a record associated with a thread group comprising a plurality of threads wherein the record comprises a thread group identifier and a thread counter. The system further comprises a thread scheduler for dispatching the plurality of threads in the thread group via a fork operation wherein the plurality of threads comprise a main thread and one or more sub threads. The system also comprises a thread monitor configured to monitor based on a join operation execution of each of the plurality of threads and monitor arrival at predetermined synchronization points. For such embodiments the thread counter is utilized to track a number of executed threads at the predetermined synchronization points. Furthermore the thread scheduler resumes execution of the plurality of threads in parallel based on the value of the thread counter.

Another embodiment is a computer readable medium having a programmable general purpose GP shader for thread synchronization. For such embodiments the GP shader is configured to assemble a thread group comprising a plurality of threads wherein the group of threads comprises a main thread and a plurality of sub threads. The GP shader is further configured to create a record associated with the thread group wherein the record comprises a thread group identifier and a thread counter for tracking execution of each of the plurality of threads and perform a thread group kickoff by performing a fork operation wherein the fork operation comprise dispatching the main thread followed by the plurality of sub threads. The GP shader is also configured to perform a join operation by synchronizing the plurality of threads at one or more synchronization points and resume execution of the plurality of threads by performing another fork operation.

Other systems methods features and advantages of the present disclosure will be or become apparent to one with skill in the art upon examination of the following drawings and detailed description. It is intended that all such additional systems methods features and advantages be included within this description be within the scope of the present disclosure and be protected by the accompanying claims.

Having summarized various aspects of the present disclosure reference will now be made in detail to the description of the disclosure as illustrated in the drawings. While the disclosure will be described in connection with these drawings there is no intent to limit it to the embodiment or embodiments disclosed herein. On the contrary the intent is to cover all alternatives modifications and equivalents included within the spirit and scope of the disclosure as defined by the appended claims.

Various embodiments are described for a general purpose GP shader within a graphics processing unit GPU pipeline that increases performance of graphics applications with a relatively small change in graphics hardware from the standpoint of gate count and hardware complexity. In particular various embodiments are described for reducing the overhead involved in transitioning back and forth to a separate application programming interface API and associated software stack which consumes valuable central processing unit CPU cycles. Inter thread communication is leveraged to reduce the amount of data transferred back and forth between the GPU and system memory. The various embodiments described provide a flexible approach to thread kickoff such that the embodiments of the GP shader are not tied to particular inputs and outputs. In this regard thread execution and flow control between threads are described for exemplary GP shaders.

Various embodiments of a GP shader are described in the context of a graphics system and in particular in an execution unit EU in which thread invocations are decoupled from the input and output domains. Additionally threads are synchronized at a thread group level where data may be shared between threads. The embodiments described also provide for random access writes based on scatter operations. As one of ordinary skill will appreciate the GP shaders described may be utilized to perform such functions as QTM DBK and post processing. Such tasks as video decoding and other GP shader applications may involve multi program execution. In this nonlimiting example video decoding via QTM DBK techniques may be mapped to multiple GP shaders by configuring a program counter PC corresponding to the GP shader for one shader program followed by a thread group kickoff. The PC is programmed to correspond to another shader program and so on.

In accordance with various embodiments thread group kickoff and thread synchronization are performed based on combinations of fork and join operations. A program or thread is selected and used as the entry point to the main program that invokes multiple thread groups to be dispatched. As an example of a thread group consider a video decoding program that comprises a QTM phase and a DBK phase. These two phases may be mapped to two GP shader programs with the QTM phase being further separated into an inter prediction program and an intra prediction program. The entry point serves as the entrance to the main program among the dispatched thread groups.

For various embodiments of the GP shader various tasks or threads concurrently undergo kickoff as one thread group. For purposes of this disclosure a fork operation or fork phase generally refers to activating or dispatching of one or more threads. For some implementations this may comprise activating both sub threads and or a main thread. A join operation or join phase generally refers to the process in which sub threads arrive at a portion of code and branch to a next barrier or synchronization point whereby sub threads that reach the barrier or synchronization point first are suspended until all the remaining sub threads arrive. The main thread does not branch to the barrier and instead continues execution within the join phase.

For some implementations a thread group may comprise up to 64 EU threads or the equivalent of 1024 software threads. Multiple threads are grouped together prior to undergoing kickoff. For the threads associated with the same thread group a fork phase and join phase are incorporated for thread execution and flow control. For some embodiments of the GP shader thread execution begins with the fork phase whereby all the threads in a defined thread group undergo kickoff concurrently. The threads later synch up at one or more join phases which involve join operations and synchronization points. Specifically for some implementations this may comprise inserting a join instruction at the beginning of shader code designated for thread synchronization. Note that for implementations in which the GP shader is embodied as shader code the shader code is stored on a tangible medium such as a computer readable medium and executed by a processor as described in more detail below.

When embodied in hardware the GP shader may be configured to perform thread kickoff with a fork phase. From here the first fork phase may be succeeded by a join phase. Alternatively the first fork phase may be followed by another fork phase. For some implementations of the join phase a counter is utilized to track the number of threads that have completed execution up to that particular section of code. The threads that have arrived are suspended until the remaining threads catch up. Various components in a system in which embodiments of the GP shader operate are now described followed by a description of the operation of these components.

Reference is made to which is a functional block diagram illustrating a graphics system in which embodiments of a general purpose GP shader are implemented. In some implementations the graphics processor system may be configured as a computer system. The graphics processor system includes a graphics processing unit GPU which further comprises a graphics processor . The graphics processor also comprises a multiple execution unit EU computational core also known as a software programmable core processing unit that in one embodiment comprises the GP shader described herein. The graphics processor also comprises an execution unit pool EUP control and vertex stream cache unit herein EU pool control unit and a graphics pipeline . The computational core comprises a pool of multiple execution units to meet the computing requirements imposed by shader tasks associated with various shader programs including a vertex shader geometry shader and or pixel shader processing data for the graphics pipeline . As the functionality of the GP shader in one embodiment is implemented largely in the computational core a general description of an embodiment of a graphics processor is described.

The various embodiments of the GP shader may be implemented in hardware software firmware or a combination thereof. When implemented in software the GP shader is embodied as one or more programs stored on a computer readable medium for execution by a processor such as the graphics processor shown in . In accordance with some embodiments the GP shader is implemented in hardware and firmware and includes any or a combination of the following technologies a discrete logic circuit s having logic gates for implementing logic functions upon data signals an application specific integrated circuit ASIC having appropriate combinational logic gates a programmable gate array s PGA a field programmable gate array FPGA etc. The graphics system also includes a CPU and a system memory . The CPU performs various functions including determining information such as a viewpoint location which provides for the generation of 3D graphic images. The system memory stores a variety of data including graphics primitive data display data and texture data . As shown the CPU and system memory interfaces with the GPU through a system interface .

The vertex shader processes vertices by performing operations such as transformations skinning and lighting. The graphics pipeline further comprises a hull shader a tessellator and a domain shader . Generally these shaders are utilized to enhance the smoothness of a given surface. In short the hull shader is directed to the selection of control points of a curve and is called for each patch using the patch control points from the vertex shader as inputs. Among other functions the hull shader computes tessellation factors which are passed to the tessellator . This allows for adaptive tessellation which can be used for continuous view dependent LOD level of detail . The data from the domain shader is passed to the geometry shader .

The geometry shader receives as inputs vertices for a full primitive and is capable of outputting multiple vertices that form a single topology such as a triangle strip a line strip point list etc. The geometry shader performs various functions including shadow volume generation and outputs information to the rasterizer which performs clipping primitive setup and determines when and or how to invoke the pixel shader . The pixel shader is invoked for each pixel covered by the primitive that is output by the rasterizer . The GP shader performs such post processing as blur effects and is typically invoked as a plurality of threads with the plurality of threads being divided into thread groups. Finally geometry that represents surfaces or volumes of objects in a scene is translated into pixels picture elements stored in a frame buffer and then displayed on a display device .

Reference is now made to which depicts an embodiment of the GP shader of . For some embodiments the GP shader comprises a GP task constructor a thread scheduler and a thread monitor . The GP task constructor defines a thread group comprising a plurality of threads and creates a thread group record associated with the thread groups . The thread group record comprises a thread group identifier and a thread counter used for tracking execution of the various threads in the thread group . The thread scheduler dispatches the plurality of threads in the thread group via a fork operation where the plurality of threads includes a main or leading thread and one or more sub threads. Upon entering a join phase of execution in the GP shader the thread monitor is configured to monitor execution of each of the plurality of threads and monitor arrival at predetermined synchronization points.

The thread counter in the thread group record is utilized to track the number of executed threads at these predetermined synchronization points. Upon synchronization of the threads the thread scheduler resumes execution of the plurality of threads based on the value of the thread counter . For some embodiments the thread counter is initialized to the total number of threads within the thread group . Once a join operation is invoked the thread monitor decrements the thread counter every time a thread arrives at a synchronization point i.e. completes execution up to the synchronization point .

In this regard one embodiment is directed to a graphics system for performing synchronized execution of a plurality of software threads in a GP shader of a graphics pipeline . The system comprises a GP task constructor for creating a record associated with a thread group comprising a plurality of threads wherein the record comprises a thread group identifier and a thread counter . The system further comprises a thread scheduler for dispatching the plurality of threads in the thread group via a fork operation wherein the plurality of threads comprise a main thread and one or more sub threads. The system also comprises a thread monitor configured to monitor based on a join operation execution of each of the plurality of threads and monitor arrival at predetermined synchronization points. For such embodiments the thread counter is utilized to track a number of executed threads at the predetermined synchronization points. Furthermore the thread scheduler resumes execution of the plurality of threads in parallel based on the value of the thread counter .

Reference is now made to which depicts a flowchart for an embodiment for synchronizing threads using the various components shown in . Block begins with the GP task constructor determining an entry point for execution of the plurality of threads in the GP shader . Generally the entry point serves as the starting point in the GP shader for the threads to begin execution. In block the thread scheduler performs a fork operation at the entry point. The plurality of threads comprise a main thread and one or more sub threads. In this regard tasks in the GP shader stage of the graphics pipeline are kicked off as a single thread group . For some implementations each thread group may comprise up to 64 EU threads or the equivalent of 1024 software threads. For some embodiments the main or leading thread is dispatched prior to the remaining sub threads where the main thread may perform operations common to those in the sub threads.

In block the thread scheduler performs a join operation to synchronize re synchronize the main thread and the sub threads. During the join phase the thread monitor constantly updates the thread counter in to track the number of threads that have completed execution up to a predetermined synchronization point. As described earlier the thread counter may be initialized to the total number of threads and the thread monitor may decrement the thread counter every time a thread arrives. The threads that complete execution first are suspended until the remaining threads arrive i.e. until the thread counter reaches zero . Note that in alternative embodiments the thread counter may be initialized to zero rather than the total number of threads and incremented upon the arrival of a thread. In block the thread schedule resumes execution of the threads upon completion of the join phase as all the threads are now synchronized. The threads may be dispatched by invoking another fork operation.

Thus to summarize one embodiment among others is a method for synchronizing a plurality of threads in a general purpose shader in a graphics processor . The method comprises determining an entry point for execution of the threads in the GP shader performing a fork operation at the entry point whereby the plurality of threads are dispatched wherein the plurality of threads comprise a main thread and one or more sub threads. The method further comprises performing a join operation whereby the plurality of threads are synchronized upon the main thread reaching a synchronization point. Upon completion of the join operation a second fork operation is performed to resume parallel execution of the plurality of threads .

For some embodiments the main or leading thread may be the first thread within the thread group and may be assigned a thread index equal to 0. During execution the main thread performs operations common to some or all the remaining sub threads. The remaining sub threads bypass the portion of code which the main thread executes and branches to the next synchronization point. Once all the threads are re synched a fork operation is invoked to activate the remaining sub threads. As shown in the flow diagram another join operation may follow the fork operation to resume execution. A nonlimiting application of the fork and join operations in the context of a thread group relates to video decoding Inter prediction where every macroblock may be processed in a 4 4 pixel block as one thread using the fork join operations.

With reference to a thread group is kicked off and enters the fork phase. In block the threads in an established thread group are activated and ready for execution. A fork operation is invoked thereby dispatching all threads concurrently. To synchronize the threads a join operation is invoked in block . At this juncture only the main or leading thread is executed while the remaining sub threads branch directly to the next synchronization point block . Once all the threads are accounted for at the synchronization point block proceeds by executing another fork operation to dispatch the threads again. As shown another join operation may be invoked block to re synch the threads. Again during the join phase only the main or leading thread undergoes execution while the remaining sub threads branch directly to the next synchronization point.

It should be noted that while the embodiments above have been described with the fork and join operations being invoked in an alternating fashion other sequences of fork join operations may be performed as well. shows an alternative embodiment of thread group kickoff whereby two consecutive fork operations are invoked. Beginning with block all threads in the thread group are activated and a fork operation is invoked to dispatch all the threads concurrently. For the embodiment shown a synch operation is invoked where threads that finish execution first are suspended until all the remaining threads complete execution block . The synch operation is implemented in accordance with the Direct3D 11 Compute Shader Functional Specification v 1.02 specification by MICROSOFT and should be distinguished from the join operation described.

While the join and synch operations are similar from the standpoint that threads are suspended upon reaching a synchronization point or barrier the join phase further comprises the main or leading thread executing a portion of code while the remaining sub threads branch directly to the next synchronization point. In this regard it should be noted that in the DX11 Compute Shader specification threads within a particular thread group may undergo a series of synch operations. However such synch operations must be resolved one by one and in sequence thereby increasing computational resources that are needed. For the embodiments described the use of fork and join operations do away with the need to resolve each thread on a thread by thread basis. Returning now to the embodiment shown in it should be noted that while a synch operation in accordance with the DX11 Compute Shader specification is shown a fork operation and a join operation are also invoked blocks and . In this regard a combination of known synch operations may be incorporated in conjunction with fork and join operations as described herein to perform synchronization among threads.

It should be emphasized that the above described embodiments are merely examples of possible implementations. Many variations and modifications may be made to the above described embodiments without departing from the principles of the present disclosure. All such modifications and variations are intended to be included herein within the scope of this disclosure and protected by the following claims.

