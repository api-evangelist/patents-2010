---

title: Multi-environment operating system
abstract: A device with multiple, co-existing, and independent environments interacting with a common kernel, and related methods of operation, are disclosed herein. In at least one embodiment, the device is a mobile device on which a run-time method is performed. The run-time method includes interpreting a first software application on a register-based virtual machine coupled to a kernel. The method additionally includes concurrently executing a second software application also coupled to the kernel, where the second software application is a compiled software application. The interpreting of the first software application is performed using a first library, and the executing of the second software application is performed using a second library.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09389877&OS=09389877&RS=09389877
owner: GOOGLE TECHNOLOGY HOLDINGS LLC
number: 09389877
owner_city: Mountain View
owner_country: US
publication_date: 20100719
---
This application claims the benefit of U.S. Provisional Patent Application No. 61 226 988 filed on Jul. 20 2009 and also claims the benefit of U.S. Provisional Patent Application No. 61 291 269 filed on Dec. 30 2009 both of which are titled Multi Environment Operating System .

The present invention relates generally to operating systems and more particularly to operating systems including multiple environments as described below.

Operating systems are designed and typically optimized based on specific applications and user desired performance. It is often desirable to have applications of one type of operating system available to another operating system.

General purpose computer operating systems such as Linux and Windows have an extensive set of features such as file systems device drivers applications libraries etc. Such operating systems allow concurrent execution of multiple programs and attempt to optimize the response time also referred to as latency time and CPU usage or load associated to the servicing of the concurrently executing programs. Unfortunately however such operating systems are not generally suitable for embedded real time applications such as for mobile computing devices. Under certain circumstances it would be desirable for a mobile computing device to have the performance associated with a mobile specific embedded operating system and features of a general purpose operating system.

Linux for example is a well known general purpose desktop operating system with many desirable features for modern devices including modern operating systems features numerous development tools networking etc. However Linux was not designed to be an embedded or real time operating system. Many modern devices such as without limitation set top boxes mobile phones and car navigation systems require not only the features of a general purpose operating system such as Linux but also the features of an embedded or real time operating system including real time performance.

Given that Linux based operating systems offer some benefits but that other types of operating systems offer other benefits particularly in the context of certain types of devices such as mobile devices it would be desirable if somehow multiple operating systems could be implemented on a single device so that the benefits of each different type of operating system could be achieved in relation to that device. Running multiple operating systems on a single device has been accomplished through virtualization techniques such as for example found in VMware VirtualBox QEMU etc. However when using virtualization a complete computer is emulated and one or more software stacks are operated in the emulated computing device. Emulation is wrought with high overhead costs and consequently conventional virtualization techniques are often impractical especially again in the context of certain types of devices such as mobile devices.

In view of the foregoing there is a need for a new type of operating system implementation by which the benefits of multiple distinct operating systems can be achieved with less overhead costs than would otherwise be the case using conventional virtualization techniques.

In accordance with at least one embodiment the present invention relates to a run time method performed on a mobile device. The method includes interpreting a first software application on a register based virtual machine coupled to a kernel and concurrently executing a second software application also coupled to the kernel where the second software application is a compiled software application. The interpreting of the first software application is performed using a first library and the executing of the second software application is performed using a second library.

Additionally in at least one further embodiment the present invention relates to a run time method performed on a mobile device. The method includes interpreting at least one first software application on a register based virtual machine coupled to a kernel and concurrently executing at least one second software application also coupled to the kernel where the second software application is a compiled software application. The executing of the at least one second software application allows for displaying of a plurality of windows simultaneously but only a single window can be displayed based upon the at least one first software application at any given time.

In at least one further embodiment the present invention relates to a device including at least one processing device and at least one storage device that stores computer executable instructions. The computer executable instructions include first instructions that when performed by the at least one processing device establish a first software framework that interacts with a kernel where the first software framework includes a first library and is configured for executing run time interpreted code on a register based virtual machine by way of the first library. The computer executable instructions also include second instructions that when performed by the at least one processing device establish a second software framework that interacts with the kernel where the second software framework includes a second library and is configured for executing pre run time compiled C C code by way of the second library. The computer executable instructions further include third instructions that when performed by the at least one processing device establish the kernel.

Additionally in at least one further embodiment the present invention relates to a method for operating a device having a kernel a first environment with first middleware and a second environment with second middleware where each of the environments interfaces the kernel. The method includes initializing the kernel identifying a device mode state and launching services common to each of the first environment and the second environment. The method also includes determining one of the first and second environments as being a primary environment based at least in part upon the mode state and launching initializing scripts for each of the first and second environments. The first middleware of the first environment is configured to interpret application code at run time with a byte code interpreter and the second middleware of the second environment is configured to execute a pre run time compiled application.

It is envisioned that it would be advantageous to have an operating system including both a first application middleware environment and a second application middleware environment that each communicate directly with a single kernel running directly upon a computing device s hardware. In at least some embodiments one or both of the first and second application middleware environments are Linux based application middleware environments. Also in at least some embodiments one or both of the first and second application middleware environments are embedded. In one exemplary embodiment each of the first and second application middleware environments is an embedded Linux based application middleware environment and both of the application middleware environments communicate directly with a single Linux kernel running directly upon a computing device s hardware e.g. the hardware of a mobile device .

Referring to a mobile device is provided. The mobile device includes a graphical user interface GUI and a plurality of data input buttons . The mobile device is selected from the group including but not limited to a mobile personal computer PC a netbook a mobile telephone a laptop computer a handheld computer and a smart phone. Although the device is mobile it is intended to have significant computing power with a processor speed in excess of 500 MHz although slower processors are not excluded. Considering the computing power a user can connect the mobile device to a variety of peripheral devices not shown . The peripheral devices are selected from a group including but not limited to computer monitor a laptop computer a desktop computer a tablet PC a screen projector a docking station a television monitor etc.

Alternatively the mobile device can include a variety of added functionality. Additional features can be based upon the particular environments that are selected for the device. By example a compass function can be provided for orientation an accelerometer function can be provided in addition to telephony Bluetooth and WiFi stack for connectivity keyboard and touch screen function for enhanced interaction.

Now referring to a block diagram is provided showing in schematic form particular components of the mobile device of . As shown the mobile device of includes a GNU Linux distribution or operating system OS in communication with device hardware as indicated by an arrow . Further as shown the GNU Linux OS more particularly includes a Linux kernel and a Linux user component that are in communication with one another as indicated by an arrow . The Linux user component is further shown to include a first application middleware environment and a second application middleware environment hereinafter the respective first and second application middleware environments will more simply be referred to as the first and second environments respectively . More particularly as further indicated by arrows and respectively each of the first and second environments and respectively of the Linux user component is in communication with the single Linux kernel . In the present embodiment the first environment is an embedded environment intended for use in mobile devices namely an Android environment additional description regarding Android can be found www.openhandsetalliance.com the website of the Open Handset Alliance which is hereby incorporated by reference herein while the second environment is a standard GNU Linux environment. In addition to the environments being capable of communications with the Linux kernel those environments are also capable of communications with one another as represented by an arrow .

As will be described in further detail below it is specifically intended that multiple environments can operate and co exist independently of one another. This is not to say that the two environments are absolutely operationally independent in all respects. Indeed to the extent that both environments interact with and compete for resources of the Linux kernel the two environments are interdependent in that respect. Likewise to the extent that the two environments are in communication with one another e.g. as represented by the arrow the two environments can operate in conjunction with one another in that manner as well. Nevertheless for purposes of the present explanation the two environments are considered independent in the sense that each of the environments is capable of operating by itself even if the other of the environments was not present and indeed each of the environments can be operationally independent before simultaneous implementation of both of the environments upon the same Linux kernel . Additionally in at least some embodiments the two environments can also be considered independent insofar as each of the two environments is of a different type e.g. in terms of being embedded etc. and correspondingly serves different purposes in terms of the operations it performs and the functions it can achieve vis vis the Linux kernel the device hardware and the outside world e.g. users and or other devices .

Although shown to be a GNU Linux OS with the Linux kernel and Linux user component the present invention is intended to encompass alternate embodiments in which other types of operating systems kernels and other operating system components are employed and the present invention is not intended to be limited only to Linux based systems. Likewise notwithstanding that in the present embodiment the first environment is the Android environment and the second environment is the standard GNU Linux environment in other embodiments other environments can be employed instead of the Android environment. Depending upon the embodiment such other environments can be but need not be embedded environments and or can be but need not be suitable for use in mobile devices. Also depending upon the embodiment environments and or operating systems that operate in real time or do not operate in real time can be employed. Further while two environments are shown in the present invention is intended to encompass additional embodiments in which more than two environments are present and can operate and co exist independently of one another where the manner of independence of the environments is as described above .

Still referring in at least the present embodiment in which the first environment is the Android environment and the second environment is in accordance with the standard GNU Linux distribution those environments can more particularly encompass several software components as shown. With respect to the first Android environment that environment includes applications e.g. user applications which are in the Dalvik language and middleware with the applications and middleware being bundled together. The middleware as shown includes an Android application framework and Android run time programming . Although not shown in at least some embodiments the middleware of the first environment can also include other components for example a radio interface layer and or components allowing for global positioning system GPS functioning. In some embodiments the middleware or portions thereof is released under an Apache license. As for the applications these applications are managed by the Android application framework and interpreted in the Android run time programming more particularly an interpreter established by the run time programming translates the applications at run time . The applications which can be understood to include stacks and other application software components are separate from one another and include computer instructions that are recognizable by the middleware atop which the applications are juxtaposed.

The Android run time programming in particular makes use of a Dalvik register based virtual machine VM as well as Dalvik libraries and tools. The VM interacts with the Dalvik libraries and tools as well as with other components such as the Linux kernel . The Dalvik Android implemented libraries are proprietary libraries that are implemented on top of Linux kernel . The functionality implemented by way of the Dalvik libraries is sufficient to run the Dalvik VM but are based on a subset of the libraries supported by GNU Linux. The Dalvik register based virtual machine including the Dalvik language is employed in the present embodiment because it has been optimized for implementation in mobile devices. Dalvik was conceived as an instrument to enable a large population of Java programmers to easily develop applications on relatively computationally weak compared to personal computers mobile devices. Java is not the same as Dalvik. In particular register based virtual machines such as that provided by Dalvik are easier to optimize than stack based architectures such as the Java virtual machine on a particular set of hardware. Also Android Dalvik replicates a complete middleware layer rather than merely a byte code interpreter VM as does Java. Nevertheless while Dalvik is not Java Dalvik and Java share a common syntax so that programmers can easily adapt their skills to develop Dalvik applications. Thus although the applications operated by the middleware and particularly by the Android run time programming are Dalvik interpreted applications rather than Java interpreted applications the applications are similar to Java interpreted applications in that they are byte code interpreted applications.

As for the second GNU Linux environment that environment includes its own applications e.g. user applications coupled to middleware with the middleware including both a GNU application framework and GNU libraries tools . The libraries tools can include a variety of components including for example libraries such as QT Quicktime or GTK GIMP Toolkit libraries useful for the display of information on a GUI as well as other libraries tools discussed in further detail below. Although not shown the middleware can include numerous other types of particular software components including for example one or more desktop environments such as GNOME Enlightenment Xfce Fluxbox LXDE and KDE and or a Gstreamer multimedia framework and or a X11 Window manager. As for the applications these more particularly can be native applications in the sense that the executable code of those applications correspond to the instruction set architecture of the Linux kernel and or the device hardware . As with the applications each of the applications can also be understood to include its own respective stacks and other application software components that are separate from those of the other applications and include computer instructions that are recognizable by the middleware atop which the applications are juxtaposed. In embodiments where the middleware includes one or more of the software components discussed above e.g. the aforementioned desktop environments one or more of the applications can be coupled to those components of the middeware.

In the present embodiment the second environment in combination with the Linux kernel more particularly takes the form of an Ubuntu Linux stack additional description regarding Ubuntu can be found at www.ubuntu.com sponsored by Canonical Ltd. of the United Kingdom which is hereby incorporated by reference herein . For simplicity of description below the second environment is hereinafter referred to as an Ubuntu environment albeit Ubuntu technically also encompasses that Linux kernel as well as the environment . In the present embodiment the second environment and particularly the middleware of that environment additionally is capable of supporting a multiplicity of logical memory data partitions while the first environment only has a single logical memory partition in addition to providing system components. Notwithstanding the above description in alternate embodiments it is possible that the second environment will only have one logical memory partition and or that one or more other environments can also or instead be configured to support multiple logical memory partitions.

Notwithstanding the above description in which the first environment is an Android environment and the second middleware system environment is an Ubuntu environment a variety of other types of environments can also or alternatively be employed including for example standard Linux based environments Symbian Symbian Foundation Ltd. www.symbian.com environments and Windows based environments e.g. Windows and Windows Mobile . In at least some such embodiments the environments are not Linux based environments and correspondingly the environments can be implemented in conjunction with different types of kernels other than a Linux based kernel this can be the case for example with respect to Symbian or Windows based environments as mentioned above . As already noted above while the present embodiment particularly envisions the presence of two environments interacting with the same Linux kernel in alternative embodiments it is envisioned that greater than two environments of any of a variety of types can independently co exist on the same Linux kernel or other core kernel .

The device hardware can include a variety of hardware devices. For example the device hardware can include a memory storage device not shown coupled to a processor not shown which stores computer executable instructions that are configured to perform various functions and operations some of which are described herein. Also for example the device hardware can in addition or instead include any of a variety of other components resources such as cellular Bluetooth and or WiFi transceivers or radios keyboards other input devices such as a mouse and or touch screens memory sub systems audio amplifiers output devices such as speakers and or video screens hardware accelerators IP sockets etc. The Linux kernel allocates resources of the mobile device by connecting and managing interaction between the physical world of the device hardware and the respective middleware of the environments respectively. The software components encompassed by the respective middleware again e.g. the application frameworks run time programming and or GNU libraries tools are often referred to as the middleware because they are logically interposed between the kernel and software applications respectively. The purpose of the respective middleware is to orchestrate interaction between the device hardware physical world and the applications respectively.

Turning to aspects of the components of are shown in greater detail in schematic form. Referring to the device hardware is again shown to be in communication with the Linux kernel that is in communication with the Linux user and the Linux user is again shown to include the first Android based environment and the second Linux based environment . Further as shown the kernel particularly includes several modules which include a set of kernel drivers and an AEV module which is described in more detail below . Included among the drivers are device drivers e.g. input device drivers for components of the device hardware . Additionally while not shown in more particularly shows the first environment as including a portal service module a portal activity module an Android services module and an Android applications module . The modules and can be considered to be among the applications of the first environment as shown in while the modules and can be considered portions of the middleware of that environment. Also more particularly shows the second environment as including an arbiter or resource manager an Android in a window AIW module and a Linux services module . The modules and can be considered portions of the middleware of . The applications of are additionally shown in as Linux applications potentially the AIW module can also be considered one of the applications .

The various modules and are configured to serve particular functions. The AIW module in particular is configured to display a first environment application window on the GUI while the second environment is the primary environment. The AEV which as mentioned above is a kernel module operates in conjunction with the AIW module and in particular takes absolute coordinate and keyboard events from AIW and passes them to an event hub. With respect to the portal service module that module contains a set of instructions configured to allow service for the first environment and directs all communication with the resource manager . While the mobile device is operating the portal service module is preferably running at all times. Additionally the portal service module is connected to activity associated with the portal activity module as well as first environment broadcast events. As already mentioned the portal activity module is an application or set of computer executable instructions. The portal activity module more particularly represents a second environment application located on the first environment stack. By example if the second Linux based environment is the Ubuntu environment the portal activity module can represent a specific Ubuntu application and when the portal activity module has focus Ubuntu is in view through the GUI .

Generally speaking numerous applications can run simultaneously also referred to as a stack of running applications within any given environment. Logically speaking the topmost application is deemed to have focus . Where multiple applications are available for interaction with a user e.g. where multiple windows corresponding respectively to multiple applications are shown on a display such as the GUI that one of the applications which is currently interacting with the user in terms of being configured to receive input commands or signals from the user at a given time can be considered the application having focus. Notwithstanding the above description in at least some embodiments of the present invention while the second environment is capable of causing the simultaneous display e.g. on the GUI of multiple windows corresponding to multiple applications the first environment does not have this capability. Rather in such embodiments the first environment is only able to cause the display e.g. on the GUI of a single window corresponding to a single application at any given time.

As discussed above the co existing environments within the operating system communicate with each other as indicated by the arrow and also communicate with the same Linux kernel as indicated by the arrows and of . Because also as noted above Android Dalvik replicates a complete middleware layer rather than merely a byte code interpreter VM as does Java absent the taking of appropriate steps there is a possibility of conflict in the operation of the middleware and the middleware of the first and second environments and respectively in terms of the allocation of resources physical assets controlled through the Linux kernel . To avoid such conflicts the resource manager which is part of the second environment communicates directly with the portal service module which is part of the first environment . Further the portal service module which is part of the first environment communicates directly with the resource manager . The resource manager is a set of instructions configured to manage the resources shared by the first environment and second environment . The shared resources include display devices input devices power management services and system state information. Furthermore the resource manager is configured to control the accessing of the device hardware by the environments . Additionally the resource manager identifies and controls which user interface associated with the environments is displayed through the GUI .

According to the present embodiment the portal service module is the source of all communications from the first environment to the resource manager . Additionally the portal service module is a sink for all callbacks from the resource manager to the first environment . The resource manager provides a status discoverable application programming interface API to the portal service module . This API is configured to be called by the resource manager at any time. The resource manager is configured to obtain and process run time status which allows for the resource manager to maintain a state machine. For the first environment the portal service module provides run time status to processes that require them. Similarly the portal service module requests and receives status updates from processes which provide status information for these reasons the portal service module can more particularly be considered part of the Android run time programming of . A similar communication for the second environment is controlled by the resource manager which provides run time status to the processes that require them. The resource manager requests and receives status updates from various processes that provide status information. The drivers logically associated with the kernel communicate directly with the resource manager as well as the processes that provide run time status information. By example the aforementioned API of the resource manager arbitrates access to user interface devices such as displays touch screens or the GUI . In yet another example this API arbitrates access to power input devices such as batteries and or AC DC wall plugs.

As mentioned above the first environment and the second environment are independent from the other in the manner discussed above and co exist with respect to the other. Each of the environments is a fully functioning environment and does not need the other environment to function such that the two environments can be said to exist on the mobile device with 100 independence with respect to the other. The first and second environments do not co exist in a virtualization or emulation scheme but rather each of the environments operates on the shared single kernel . The first and second environments in particular have run time co existence in which both of the environments are run as stand alone native environments. Neither of the environments is recompiled as there is no need to leverage a common C run time environment. Because of the presence of the two environments a user can access applications that are coded purely for one or the other of the environments and a user can access an application that is coded for one of the environments without an interruption to the user s computing experience with respect to the other of the environments.

Referring next to an additional block diagram shows in schematic form aspects of the operating system with the Linux user and Linux kernel by which an exemplary co existence scheme for the first Android environment and the second Ubuntu environment is provided. In general each of the environments operates on a separate run time environment which provides software services for programs and or processes while the mobile device is operating. More particularly as shown Android processes and Android libraries access a Bionic C or simply bionic library which is optimized and modified specifically for the Android environment. The Android libraries and bionic library can be considered to form part of the Android run time programming of . Additionally as shown Ubuntu processes and Ubuntu libraries access a GNU C glibc library which is used in many standard desktop Linux based systems. The Ubuntu libraries and glibc library can be considered to form part of the GNU libraries tools of . Each respective one of the environments runs on its respective C libraries without conflicting with the other one of the environments .

Referring further to a more detailed communication path between the first environment and the second environment described in is shown in schematic form. More particularly an inter process communication IPC system is configured to manage the inter environment communication flow between the first environment and the second environment . As shown the portal service module discussed above with respect to of the first environment communicates with a DBUS binding which in turn is a software package containing programming language and executable instructions configured to communicate with a DBUS library the DBUS binding and DBUS library also being components of the first environment . Additionally as shown the resource manager also discussed above with respect to communicates with a Glib DBUS binding which also is a software package containing programming language and executable instructions configured to communicate with a DBUS library configured for the second environment . Both the first environment DBUS library and the second environment library communicate through a DBUS Daemon which along with the Glib DBUS library and DBUS library is logically part of the second environment and which acts as the communication link between the two environments. All of the components and of the first environment can be conceptually considered to be part of the middleware of that environment while all of the components and of the second environment can be conceptually considered to be part of the middleware of that environment.

Referring to a flow chart shows steps of an exemplary boot sequence for the operating system of . The boot sequence includes both common and environment specific steps. The actual boot sequence is dependent upon rules associated with a predetermined device state of the mobile device that dictates the booting sequence. By example if the mobile device is connected to a peripheral device such as a monitor the device state is considered to be in docked mode and the second Linux based environment is the default primary environment. Alternatively if the mobile device is not connected to a peripheral device then it is in mobile mode and the first Android environment is the default primary environment. Although in any given mode of the mobile device one or the other of the first and second environments serves as a primary environment both environments are launched simultaneously that is the secondary non primary environment is launched simultaneously with the primary environment . Further once both of the environments are launched and one of the environments serves as the primary environment the secondary environment nevertheless still operates in the background relative to the primary environment in case the mobile device state changes and the secondary environment is switched to become the primary environment. By example when the mobile device is in docked mode and the peripheral device is unplugged there is an automatic switch to mobile mode which results in the secondary environment becoming the primary environment and vice versa.

As shown in the boot sequence is initiated at step followed by the launching initializing of the Linux kernel or core at step . In this regard a bootloader program initializes prior to the launching of the kernel . After the Linux kernel is launched initialized the kernel itself then launches user space scripts at step . The resource manager is further launched at step followed by an identification of the mode state at step . Once the mode state is identified a reference library is accessed at step to determine the criteria associated with and or dictated by the mode state that is identified. At step services common to both the first environment and the second environment are launched. The mode state determined at step is subsequently referenced and considered at step and depending upon the mode state different paths are followed.

In this regard if at step the mobile mode state is referenced then the first environment should be the primary environment while the second environment should be the secondary environment. Consequently in that circumstance first environment initialization scripts are launched at step followed by the launching of second environment initialization scripts at step . Alternatively if the docked mode state is referenced at step then the second environment should be the primary environment and the first environment should be the secondary environment. Consequently in that circumstance second environment initialization scripts are launched at step followed by the launching of first environment initialization scripts at step . Following each of the steps and the process in each case proceeds to step at which the mobile device becomes operational. Thus regardless of which of the environments is the primary environment both environments are launched and running before the mobile device is operational at step . Indeed since the common services are launched first at step for all intents and purposes the primary and secondary environments are launched in parallel. However the primary environment specific services based upon the device state are launched immediately before the secondary environment specific services. By separating the common services launch with the environment specific launch the mobile device can be quickly operational with multiple co existing and independent environments.

Referring to a flow chart shows steps of an exemplary process for launching a second environment application e.g. one of the applications while the mobile device is in the mobile mode and the first environment is the primary environment and thus has primary control over operations of the mobile device . As shown the process begins with the mobile device initially operating with the first environment as the primary environment at step . Next at step a second environment application is selected e.g. in response to a user command or otherwise launched in response to response to a signal or event. The second environment application can take a variety of forms depending upon the embodiment for example the second environment application in one embodiment is an application referred to as mobile PC which is an application in the second environment that when operating provides a full PC view alternatively referred to as a netbook view while the mobile device is operating in the mobile mode and the first environment is in primary control. In an alternate embodiment individual applications from the second environment can be listed in a first environment menu and individually launched which can be similar to a netbook view.

Still referring to subsequent to step the portal service module sends a status update communication to the resource manager at step indicating that the portal activity module has gained focus. Thereafter the resource manager disables the first environment input and switches a virtual terminal at step . The mobile PC application is then displayed on the GUI at step . While operating the mobile PC application an unsolicited event can occur at step or a user solicited event can occur at step . Unsolicited events include time critical and non time critical events. By example a time critical unsolicited event includes a phone call or a scheduled or unscheduled alarm. Further by example a non time critical unsolicited event includes a short message service SMS message an email message or a device update notification. After an event occurs at either of the steps or the portal service module sends a communication to the resource manager indicating that the portal activity module has lost focus at step . Next at step the resource manager requests the first environment to enable input event flow and switches the virtual terminal. By example the present embodiment includes separate virtual terminals for switching display control between the first environment and the second environment . Broadly speaking a virtual terminal is a Linux application that allows a system user to switch display controls between Windows based view and a system console.

Subsequent to step one of several events can occur at step and depending upon which of such events occurs the process advances in different manners. More particularly when an unsolicited event occurs or a user selects the Home key at step the portal activity module is switched to the background at step while the unsolicited event continues or the user initiates operates another application from the Home menu of the GUI . Alternatively if the user selects the Back key at step then the portal activity module exits the application at step and reverts to the idle main menu step . Once step has been completed then it is determined at step whether another event has occurred. If an event occurs that is an unsolicited event then the process advances from step to step in which the first environment is interrupted. After the environment interruption at step the interrupting application exits and the portal activity module regains focus at step and the mobile device reverts to step . Alternatively if the event occurring at the step is a solicited event such as user selection of the Home key then the device reverts to the idle main menu step . With respect to the above steps it should be noted that user initiated events such as the selecting of the Home key or Back key or the initiating of a new application are exemplary solicited events which are to be contrasted with unsolicited events.

In an alternative embodiment the virtual terminal facility is not utilized. Rendering a second environment application while in the mobile mode can be accomplished through a VNC like application. The second environment application such as Ubuntu can be rendered remotely into the VNC client. Additionally this embodiment does not take physical display control away from the first environment . Additionally in yet another alternative embodiment non time critical notifications generated by the first environment are identified and listed in a panel within the second environment view. By listing the notifications in a panel the first environment status information is integrated with the second environment view when the second environment is the primary environment. At the user s leisure the panel is accessed to reveal non time critical status notifications. When the panel is engaged the first environment becomes the primary environment and allows the notifications to be viewed. By example the panel can be a pull down list that comes down from a status area with a slide gesture.

Referring next to a message sequence chart shows steps of an exemplary process for launching a second environment application while the first environment has primary control. The sequence chart provides a step wise flow from top to bottom of the signals transmitted between the portal activity module and the resource manager . As shown the portal activity module receives a signal to launch the portal and disable the input. The first environment has primary control before signal changes the mode state such that the second environment obtains primary control. A signal is sent from the portal activity to the resource manager which then generates a responsive signal sent to the portal activity module indicating that the second environment is the primary environment. Further as shown a signal is received by the portal activity module and enables the input. A signal is sent from the portal activity to the resource manager changing the mode state such that primary environment is switched from the second environment to the first environment . After receiving the signal the resource manager switches the virtual terminal. The resource manager then sends a status update signal to the portal activity module indicating that the first environment is primary.

Turning to a flow chart shows steps of an exemplary process for switching from the first environment to the second environment . The process begins at step with the mobile device idle in the mobile mode with the primary environment being the first environment . At step the mobile device is connected to a docking station or connected to a peripheral device. By example an HDMI connection can be established between the mobile device and a monitor or a television. The resource manager is notified of the updated connection status at step and the first environment is disabled at step in response to the connection status change. The first environment portal that is the portal activity module switches the shared memory framebuffer at step followed by the resource manager switching the virtual terminal at step . If the mobile PC application is in view at step then the portal activity module exits at step and the process advances to step . Alternatively if the mobile PC application is not in view then the process immediately advances from the step to the step . At the step the docked mode is entered and the second environment is correspondingly enabled.

Next subsequent to the completion of step and enabling of the docked mode it is possible that the state of the mobile device will change at step . By example the state of the mobile device changes when a user removes an HDMI cable or similar connector which is used for connecting the mobile device to a peripheral device. In the event that the device state changes at step then the resource manager receives a status state update at step . Following the receipt of the state update at step the first environment is enabled at step and the device operates again in the mobile mode. Next a framebuffer switch is requested at step and a virtual terminal switch is requested at step both of which are performed by the portal activity . Following step the mobile device reverts to an idle state in the mobile mode by returning to step .

Referring to a message sequence chart shows steps performed during an exemplary process in which the mobile device transitions from the mobile mode where the primary environment is the first environment to the docked mode where the primary environment is the second environment . As shown initially the mobile device is operating in the mobile mode and the first environment is the primary environment. A cable signal is received by the resource manager which indicates that an HDMI or alternate hardwire plug has been attached to the mobile device also as shown the cable signal can be considered as being received from a child resource manager as opposed to the main resource manager . The cable signal is an exemplary mode state initialization change signal. In an alternative embodiment the plug can be representative of wireless communication between the mobile device and a peripheral device and disabling of such wireless communication would cause a mode state initialization change signal to be generated. Subsequent to the signal a sequence of further signals transitioning the device from the mobile mode to the docked mode is initiated. In this regard a signal is sent from the resource manager to the portal activity module indicating a mode status transition and disabling the main data input. The portal activity module then sends a signal to the resource manager identifying the second environment as now being primary and switching the virtual terminal. Further a signal is also sent from the resource manager to the portal activity module identifying the second environment as the primary environment that has taken ownership of the framebuffer. Additionally a mode state change confirmation signal is sent from the portal activity module to the resource manager identifying that the mobile device is now in the docked mode and that the second environment is the primary environment. A system mode update signal is then also sent from the resource manager to the AIW .

Referring to an additional message sequence chart shows steps performed during an exemplary process in which the mobile device transitions from the docked mode where the primary environment is the second environment to the mobile mode where the primary environment is the first environment . As shown a cable signal is received by the resource manager which indicates that an HDMI or alternate hardwire plug has been removed from the mobile device also as shown the cable signal can be considered as being received from a child resource manager as opposed to the main resource manager . Removal of the plug indicates that a peripheral device not shown is no longer in communication with the mobile device . In an alternative embodiment the plug can be representative of wireless communication between the mobile device and a peripheral or alternate device not shown and enabling of such wireless communication would cause a mode state initialization change signal to be generated. Subsequent to the signal a sequence of further signals transitioning the device from docked mode to mobile mode is initiated. In this regard a signal is sent from the resource manager to the portal activity module indicating a mode status transition and enabling the main data input and the main framebuffer. The portal activity module then sends a signal to the resource manager identifying the first environment as now being primary and switching the virtual terminal. Further a signal is sent from the resource manager to the portal activity module identifying the first environment as the primary environment that has taken ownership of the framebuffer. Additionally a mode state change confirmation signal is sent from the portal activity module to the resource manager identifying that the mobile device is now in the mobile mode and that the first environment is the primary environment. A system mode update signal is sent from the resource manager to the AIW .

Turning to a further flow chart shows steps of an exemplary process for using an application controlled by a first environment of the operating system of while a second environment of that operating system has primary control. As shown the process begins at step at which the mobile device is idle in the docked mode such that the second environment is the primary environment. Then if an unsolicited event occurs at step or the user selects the first environment in a window application at step then the first environment in a window application is launched at step . By example assuming that the first environment is Android based as discussed above then the AIW module or application is launched. The AIW module enables a user to access the Android applications see while the device is operating in the docked mode. The resource manager is also notified of the status update at step . Subsequently at step input to the first environment is enabled and further at step a transmission of first environment display update notifications occurs. The AIW module thus is operating and has focus at step .

Referring additionally to an exemplary computer monitor is shown on which are displayed exemplary windows that can appear due to the operation of the mobile device in accordance with the steps discussed above. For purposes of the present example it can be assumed that the monitor is an additional device with which the mobile device is docked in some cases the monitor can be part of or associated with a computer such as a PC with which the mobile device is docked . More particularly as shown due to operation in the docked mode in accordance with the step a primary window generated by a corresponding application of the second environment is displayed on the monitor . Notwithstanding the display of the primary window the monitor is also shown to display a secondary window which is an AIW window. The secondary window appears in response to the occurrence of an unsolicited event at the step which in the present example is the detection by the mobile device of an incoming phone call to the mobile device. Due to the unsolicited event at the step the AIW module is launched and the additional steps are performed such that correspondingly the secondary window is generated. At the step the secondary window is in focus rather than the primary window that is to say the focus has changed from the primary window to the secondary window as a result of the performing of the steps and .

Again particularly with respect to upon reaching step it is subsequently possible that the AIW module will be exited or that a user will remove the AIW module from focus. If the AIW module is exited at step or a user removes AIW from focus at step then in either case the first environment input is disabled at step and additionally the first environment display is stopped at step . Subsequently at step it is again considered whether the AIW module was exited at step or a user removed the AIW from focus at step . If the AIW module was exited at step then following step the mobile device reverts to the idle docked mode by returning to step . Thus with respect to the example shown in the secondary window disappears and the primary window remains and regains focus. Alternatively if the AIW module was merely defocused then the AIW module continues to operate at step in this defocused state. In this case with respect to the example shown in both the primary window and the secondary window remain displayed on the monitor but it is the primary window which has focus.

While the AIW module and correspondingly the secondary AIW window is defocused it is still possible for a user to select the AIW module and continue interaction with the AIW window so as to refocus the AIW module and notify the resource manager of any status update as well as possible for unsolicited interrupting events to occur that may precipitate a refocusing of the AIW module. Thus as shown once the AIW module is operating in the defocused state if either an unsolicited event occurs that interrupts the operation of the AIW module at step or a solicited interaction with the AIW module occurs at step then in either case the AIW module subsequently regains focus at step . After the AIW module regains focus the first Android environment input is enabled at step and also the first environment display update notifications are transmitted to the resource manager at step . After step the mobile device reverts to step where the AIW module is enabled and in focus. As mentioned above when an application is in focus that application is at the logical top of a stack of running applications.

From the above description it should be evident that the capabilities and operational characteristics of different environments such as the first and second environments can be particularly tailored for the applications and functions those environments are intended to serve. In the present embodiment in this regard the first Android environment has special characteristics that are particularly suited for mobile device functionality while the second Linux based environment does not have such characteristics tailored in this manner to such an extent. For example given some of the limitations associated with mobile device displays in comparison with other types of displays e.g. desktop computer displays and given that the first environment in the present embodiment is particularly tailored for facilitating mobile device operation while the second environment is not tailored for such purposes to such an extent in the present embodiment the second environment and particularly the middleware of that environment supports either a greater number of display resolutions or higher level display resolutions than the first environment and its middleware .

Additionally given the limited CPU power available in many mobile devices achieving sufficiently high processing speeds is often of concern in the design and implementation of the mobile devices. Use of the Android environment as the first environment as discussed above is appropriate for such mobile devices given such concerns and the operational circumstances often faced by mobile devices. In particular because the Android environment generally includes a custom library in which the C library has to be loaded in each process the custom library is desirably small. The bionic library in particular is a smaller library than and has more limited functionality than the glibc library. Also use of the bionic library allows for greater speed of operation of a mobile device due to the library s small size and fast code paths. Further the bionic library also has built in support for important Android specific services such as system properties and logging although it should be further noted that the bionic library does not support certain POSIX features such as C exceptions and wide characters thus it is not quite compatible with the glibc library which is substantially POSIX compliant . In view of the above the Android environment utilizes the bionic library rather than the glibc library and all native code is compiled against bionic and not glibc.

In addition embodiments of the present invention are capable of operating in a manner in which pre run time compiled applications are enabled in one environment such as the second Linux based environment while other register based applications are interpreted at run time so as to be enabled in another environment such as the first Android environment . The pre run time compiled applications can among other things include for example C C native applications that are compiled before run time. Given such embodiments it is possible to have both pre run time compiled applications and register based run time interpreted applications interact with a common physical environment simultaneously by virtue of being coupled through the common Linux kernel . Alternatively stated such operation enables GNU to operate pre run time compiled applications like OpenOffice or Mozilla Firefox concurrently with Android running run time interpreted Dalvik intentioned applications.

Notwithstanding the above the present invention is intended to encompass numerous other embodiments including numerous variations of the embodiments discussed above. Thus in a number of embodiments it is envisioned that the mobile device transitions between mode states and consequently between environments in response to an unsolicited event such as the docking or undocking of the mobile device . Yet also in some embodiments it is contemplated that the mobile device can transition between mode states and between environments based upon events other than docking or undocking the mobile device and or based upon events other than unsolicited events. By example if the mobile device is stationary for a preset period of time the mobile device can be programmed to operate in the most energy efficient mode state regardless of the device status otherwise. In yet another example a user can transition the mode state from docked to mobile even if the device has a connection with a peripheral device. Additionally the type of peripheral device connected to the mobile device can dictate whether an automatic mode state change sequence is initiated or a user has provided a mode state change request. In some cases a user is able to select the mode state in which to operate the mobile device .

Further in some embodiments it is possible for the mobile device to switch from one of the mode states environments to the other of the mode states environments when a user invokes an application associated with the other mode state. Indeed depending upon the embodiment the mobile device can be configured so that any event or events can trigger a change in mode state environment . For example in an embodiment where the mobile device is in communication with a web server or intermediate server a push from that web server or intermediate server e.g. a forced sending of information from that server to the mobile device can automatically precipitate a switching from one environment e.g. the environment to another environment e.g. the environment suitable for receiving the pushed information. Notwithstanding the above description depending upon the embodiment the switching from one mode environment to another can be viewed as a process of pre emption. For example when an unsolicited event occurs that triggers a switch between the environment and the environment it can be said that the environment is pre empted by the unsolicited event such that the environment is then initiated. Further the present invention is intended to encompass numerous further embodiments in which a variety of additional mode states environments are contemplated including a variety of mode states environments that depend upon the particular mobile device usage and the applications available in the memory of the device hardware .

It is specifically intended that the present invention not be limited to the embodiments and illustrations contained herein but include modified forms of those embodiments including portions of the embodiments and combinations of elements of different embodiments as come within the scope of the following claims.

