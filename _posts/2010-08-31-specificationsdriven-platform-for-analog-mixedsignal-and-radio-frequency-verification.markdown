---

title: Specifications-driven platform for analog, mixed-signal, and radio frequency verification
abstract: A design specifications-driven platform () for analog, mixed-signal and radio frequency verification with one embodiment comprising a client () and server () is presented. The server comprises an analog verification database (), a code and document generator (), a design to specifications consistency checker (), a symbol generator (), a coverage analyzer (), a server interface (), a web server (), and an analog verification server application (). The client comprises a web browser (), generated datasheets and reports (), generated models, regression tests, netlists, connect modules, and symbols (), generated simulation scripts (), a client interface (), design data (), simulators (), and a design data extractor ().
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08682631&OS=08682631&RS=08682631
owner: 
number: 08682631
owner_city: 
owner_country: 
publication_date: 20100831
---
This application claims the priority of U.S. Provisional Patent Application No. 61 239 664 filed on Sep. 3 2009 by the present inventors which is incorporated by reference herein.

This invention relates to the creation of a design specifications driven platform for analog mixed signal and radio frequency verification in the field of analog mixed signal and radio frequency RF integrated circuit IC and system design and verification. A mixed signal design is a design that includes analog and digital design. The term analog includes purely analog mixed signal radio frequency and any combination of these types of designs. A design may be an entire IC a subblock of an IC or a component of an IC.

The design of a complex analog mixed signal or RF IC is a large undertaking involving a design team which may include system designers digital designers analog designers and a chip level implementation team. Distinct and separate from the design team may be a verification team whose sole focus is to check the work of the design team. In general when designing any large complex system a distinct and separate verification task may become necessary when the complexity of what is being designed increases to a point where the designer or designers may no longer be able to adequately check their own work. In digital IC design this point occurred in the mid 1990 s. The design of complex analog mixed signal and RF ICs has now reached this point. Design bugs or errors now occur in the analog section in the interface between the analog and digital section and in the digital section that works closely with the analog. The root causes for these errors include miscommunication between the design teams incorrect interpretation of the design specifications incorrect or incomplete design specifications and simple human error. It is these symptoms that suggest that a distinct and separate analog verification task may be necessary.

Analog mixed signal and RF designs begin with the creation of at least one specification for the design. Typically there is a plurality of specifications for a design. Depending on the design team specifications may be formal and detailed or these specifications may be as informal as a set of handwritten notes. Regardless there are specifications that represent some level of understanding of what the analog design is to do as agreed to with the end user of the design. A typical flow is that from the specifications the designers implement the design. When completed the design is translated to layout. The layout is checked to match the design and to be design rule correct. If there is digital layout the analog layout is then combined with the digital layout. Additional checks are conducted on the final layout. Once all of the checks pass the design is released to manufacturing. After manufacturing each chip is tested to validate that they are working.

Designs may be implemented hierarchically where there is a top or a chip level comprising blocks or components. The design may be implemented starting from the top starting from the blocks or both. The blocks components top level and chip level have ports consisting of inputs outputs and bidirectional signals that facilitate communication from one part of the design to another.

The purpose of analog verification is to validate that the analog design meets its specifications that the analog is properly connected to the rest of the design and that in conjunction with the register transfer logic RTL that has been developed that the IC behaves correctly. A key technology used when verifying designs is the use of computer simulators. Computer simulators allow the designer or verification engineer to predict what the design will do prior to manufacturing the design. A limitation of computer simulations is that simulations may be very time consuming. At present simulating the analog section with all of the transistors with the rest of the IC is prohibitive because the simulations times are too long. These simulation times may range from weeks to months. Even simulating the analog section alone may be prohibitive. To address this issue analog verification relies on a model representation of the design and the design components. This is often referred to as a behavioral model. Behavioral models when written properly simulate much faster than the design. To use this model however it is critical that the model be proven to match the design implementation. If the model does not match the design there is no certainty as to whether or not the design is truly being verified. To verify the consistency of the model and the design a self checking regression test is applied independently to the model and the design. The regression tests apply stimulus to either the model or the design and checks the outputs of what is being tested. The expected outputs are determined by the specifications. If the actual outputs match the expected outputs then to what the regression tests are applied and specifications are consistent. If both the model and design are consistent with the specifications then the model and design are consistent and therefore the model the design and the specifications are consistent.

Analog verification is a new field in which there is little automation. Datasheets reports models regression tests netlists that combine blocks together connect modules symbols and simulation scripts are usually written manually. Designers and verification engineers typically use templates or files written for a previous project as a starting point to gain efficiency. Of the automation that does exist in the field of analog verification most fall under the categories of formal techniques model generation and testbench generation with most of the work in model generation.

In all fields of study there is much literature on model generation essentially the idea of building an abstract representation of something detailed. However different techniques are required for different disciplines. For example in the field of electronic design automation of which aiding in the design of analog mixed signal and RF ICs is a part there are techniques for the generation of digital models digital system level models and transistor device level models. U.S. Pat. No. 5 363 320 to Graeme Boyle Susan Bergquist Ernest McReynolds and Matson Haug 1993 describes an approach to device or component level modeling. Devices include transistors resistors capacitors and inductors. The creation of a behavioral model of an analog block which is a combination of devices requires different techniques in that abstraction or the removal of detailed behavior is required. One of the primary goals of having an analog model is that it simulate faster than a complete description of the design. The goal of device modeling is to have a very accurate representation of the devices where detailed behavior is included. U.S. Pat. No. 5 463 563 to Owen Bair Patrick Yin and Chih Chung Chen 1995 describes an automatic modeling approach for logic a subset of digital. The focus is on generating accurate timing information. Since analog signals fundamentally differ from digital signals this work cannot be applied to creating analog behavioral models. Digital signals have a fixed number of values usually two on or off. Analog signals are continuous and may take on any value within a range. As a result different modeling techniques are required. Also simulating analog signals may require a different simulator and therefore different types of models. An event driven simulator is typically used to simulate digital designs. Simulating analog signals often requires a simulator have an ordinary differential equation solver engine. This type of engine is known as a SPICE engine or an analog simulator. A SPICE engine requires solving a network of simultaneous equations. Simulators that have both an event driven simulation engine and SPICE engine are generally known as AMS simulators or mixed signal simulators. Modeling languages targeted for analog include Verilog A Verilog AMS and VHDL AMS. Custom language extensions to Verilog and SystemVerilog have also been written to extend an event driven engine to be able to accommodate some amount of analog modeling. Analog modeling may be accomplished using a digital language but in many circumstances an analog modeling language or a digital language with custom extensions is required. Model generation techniques in other fields such as digital do not use analog modeling languages nor do they use custom analog extensions to a digital language.

In the field of analog model generation two basic approaches have been proposed. The first is based on an abstract description of the design such as a specification or equations representing the function that the design is to perform and the second is based on the implementation of the design itself The latter requires that the design be completed before the model can be created. Simulation based Automatic Generation of Signomial and Posynomial Performance Models for Analog Integrated Circuit Sizing by Walter Daems Georges Gielen and Willy Sansen presented at the IEEE ACM International Conference on Computer Aided Design in 2001 describes a technique to create signomial and posynomial performance models based on SPICE or circuit simulation of the implementation of the design to be modeled. First Steps Towards SAT based Formal Analog Verification by Saurabh Tiwary Anubhav Gupta Joel Phillips Claudio Pinello Radu Zlatanovici presented at The IEEE ACM International Conference on Computer Aided Design in 2009 describes an alternative method for analog verification. In both cases the implementation of the design in the form of a netlist of all of the devices and how these devices interconnect is required.

For the model generation approaches that begin with an abstract description of the design the prior art for this approach may be broken into two types of methods. The first is circuit type based where specific knowledge of the type of analog mixed signal or RF circuit being modeled needs to be pre written into the tool generating the models. This knowledge may be in the form of equations or templates for the models where typically all that is required of the user is to enter parameters for the type of circuit. Often model templates or equations specific to the circuit type are build into the tool. Automatic Analog Model Generation for Behavioral Simulation by Brian Antao and Fatehy El Turky presented at the IEEE Custom Integrated Circuits Conference in 1992 discusses the generation of behavioral models for s domain and z domain filters. The input to the model generator are the coefficients for the filters. In this case specific domain knowledge about s domain and z domain filters two types of circuits are pre programmed into the generator. A Formal Approach for Specification Driven AMS Behavioral Model Generation by Subhankar Mukherjee Antara Ain S Panda Rejdeep Mukhopadhyay and Pallab Dasgupta presented at the Design Automation and Test in Europe Conference in April 2009 describes a method in which the user enters specifications including the type of circuit being modeled to generate behavioral models. In this paper the authors use as an example to describe their approach a low drop out LDO regulator and explain how domain knowledge for LDOs is included in their tool. US Patent Application Publication 2008 0048675 by Edouard Ngoya and Jean Rousset published 2008 describes a method to accurately create a noise model in RF circuits. This is focused on analyzing a specific class of circuits RF oscillators RF mixers and RF amplifiers where built in knowledge of these types of circuits are required. This publication is also more of an analysis technique and not a method for generating a behavioral model of a design. The second type of the description based approaches to model generation is to enter a description of the design using a schematic capture tool or topology editor tool. U.S. Pat. No. 5 963 724 to H. Alan Mantooth Christopher Wolff 1999 provides an example of this approach.

U.S. Pat. No. 5 369 604 to Naiknaware Ravindranath G. N. Nandakumar and Srinivasa Kasa 1994 describes an approach for automatic test plan generation. The invention described in U.S. Pat. No. 5 369 604 requires a circuit description functional models test models and heuristic rules to generate the test plan.

The invention described in this patent application part of which generates models and regression tests uses the approach where one starts from an abstract description of the design in the form of specifications. This has the advantage that the implementation of the design does not have to exist before the model and regression test may be generated. There is also the advantage that the generation may be done in a significantly faster manner as circuit simulation is not involved. This invention also does not require circuit type specific information. For example common analog blocks include LDOs analog to digital converters digital to analog converters amplifiers mixers oscillators phased locked loops. When using the method described in this invention to generate models and regression tests the type of analog design being modeled does not have to be specified. The advantage is that a wider variety of analog blocks may be modeled. Often analog blocks comprise various types of analog blocks. It is infeasible for generators to anticipate all combinations. Since this invention does not require domain or circuit specific knowledge analog blocks comprised of other analog blocks may be generated. This invention also does not require that the user enter a topology as a way of describing the design. The user need only enter the specifications for the design. The advantage is that the information entered may be more abstract and is closer to how the designer would naturally write specifications for their design. Finally for the generation of models and regression tests the invention described in this patent application requires only the specifications. Additional information is not required. This has the advantage over the prior art that requires more information in that a reduced set of information is required thus saving the user time when providing the input required for the generator.

In accordance with one embodiment this invention is a design specifications driven platform for analog mixed signal and radio frequency verification for accelerating and improving the quality of the design and verification effort. This invention starts where the analog design starts namely the design specifications. This invention provides a method for verifying an analog mixed signal or radio frequency design where at least one specification is entered for the design where the specification is stored where a code and document generator is used to convert the specification to a behavioral model. The specification may contain a behavior of an analog port. Using the code and document generator and a model template the behavior is converted into a portion of the behavioral model. Further the code and document generator may convert the specification to a regression test where simulations are then performed where simulation results are stored and where these results are used to generate a datasheet and report. Utilizing the regression test an implementation of the design and the specification may be verified for consistency. The coverage including model coverage regression test coverage regression test run completeness and assertion execution completeness may be measured. The code and document generator may also generate netlists connect modules simulation launch scripts simulation launch script configuration files and schematic symbols. The quality of analog verification is improved as automated generation prevents manual errors from being introduced when a manual generation process is used. The quality of analog verification is also improved as the analysis capabilities ensure that the analog verification is more complete.

One embodiment of a design specifications driven platform for analog mixed signal and radio frequency verification is shown in . The components for the platform are divided into server side components and client side components. There is at least one server and at least one client in the preferred embodiment. If there is a plurality of users there may be a plurality of clients. If the capabilities provided by a single server is insufficient a plurality of servers may be used. The server may be a computer such as a laptop desktop workstation or computer server. The server has at least one processor readable storage medium containing instructions that upon execution result in the implementation of operations. This processor readable storage medium may be random access memory read only memory static memory dynamic memory non volatile memory floppy disk or hard disk. For optimal performance the server has high compute power and high bandwidth to the internet and is preferably a workstation or computer server. The client may be a computer such as a netbook mini notebook computer sub notebook computer notebook computer laptop desktop workstation server tablet computer or mobile phone. The client also has at least one processor readable storage medium containing instructions that upon execution result in the implementation of operations. To access the web based functions that the platform provides it is sufficient that the client be a device with web browsing capabilities such as a personal digital assistant mobile phone tablet computer or electronic book reader. The server runs an operating system such as Unix Linux Sun Solaris Microsoft Windows Apple MacOS or Chrome. The client runs an operation system such as Unix Linux Sun Solaris Microsoft Windows Apple MacOS or Android. A user of this platform uses at least one of the client side computers . On the server side our preferred embodiment is a Linux computer server. On the client side our preferred embodiment is a Linux workstation.

On the server side is a web server which connects to the client side . An analog verification server application connects to the web server an analog verification database and functional units including a code and document generator a design to specifications consistency checker a symbol generator and a coverage analyzer . The generator the consistency checker the symbol generator and the coverage analyzer also connect to the database . The database and the analog verification server application connect to a server interface which connects to at least one client . The web server may be a commercial or an open source web server such as Apache. The database may be an open source or a commercial structured query language SQL database such as MySQL. The analog verification server application serves as a user interface capturing information from the user storing data in the database calling the functional units to and retuning that information to the user. The code and document generator takes information from the database and converts the information to at least one type of code or document. Code that is generated is meant to be interpreted by a simulator by a computer operating system a general purpose computer language interpreter or an application. The application may be part of the platform or may be another software application. A general purpose computer language interpreter includes scripting language interpreters. Scripting languages include bourne shell bash shell c shell python ruby tcl and company proprietary extension languages such as Cadence s SKILL and Ocean. A document that is generated is meant to be interpreted by person. The design to specifications consistency checker makes static checks between at least one design data repository and what is in the analog verification database . Inconsistencies and warnings are provided to the analog verification server application and returned to the user. The consistency checker also checks for self consistency within the specifications. For example information may be placed in the database that specifies under what conditions certain design objects may be connected. If connections are made that violate these conditions the consistency checker issues an error and the user is notified. The symbol generator takes information from the database and produces at least one schematic symbol that the user may use in schematic drawings. The coverage analyzer takes data from the database and calculates at least one coverage metric. These metrics include the level to which the design has been verified. The server interface provides an interface to the client to allow data to be transferred to and from the database . The server interface also provides an application programming interface API that allows a client to access functionality provided in the analog verification server application and to access and change contents in the analog verification database without going through the web server .

On the client side a web browser connects to the web server on the server side and to generated datasheets and reports generated models regression tests netlists connect modules and symbols and generated simulation scripts . The generated models regression tests netlists connect modules and symbols simulation scripts a design data extractor and at least one simulator are connected to the design data . The scripts simulators and extractor connect to a client interface . The client interface connects to the server interface on the server side . The web browser may be an open source or a commercial web browser such as Firefox or Microsoft s Internet Explorer. In the preferred embodiment the client uses Firefox as the web browser . The design data may include at least one file stored on a computer or include at least one database for integrated circuit design. Common integrated circuit design databases are developed by companies in the field of electrical design automation EDA . Examples of integrated circuit design databases include the Cadence Database CDB and OpenAccess. A combination of at least one file and at least one database may also be used. The design data hold the design and implementation information for an integrated circuit or system being designed. The simulators may be open source or commercial simulators developed by a company in the field of EDA. The simulators include circuit simulators event driven simulators and mixed circuit and event driven simulators. The simulators may simulate at least one of many hardware description HDL languages. HDL languages include Verilog Verilog A Verilog AMS SystemVerilog VHDL VHDL AMS SystemVerilog and SystemC. In the preferred embodiment the reports models regression tests netlists connect modules and symbols and simulation scripts are outputs from the server . The design data extractor converts the information from the design data to enable the checker . The converted information is stored in the database . The client interface communicates with the server interface to enable the transfer of data to the server . The transfer of data includes storing and retrieving information from the database .

The client and the server communicate via the web server and the database . The server application provides the user interface to the user by receiving inputs and creating outputs in a language that the web browser may interpret such as text hypertext markup language HTML or Javascript.

The components of the code and document generator are shown in . The code and document generator includes a data management module database input and output routines access function parsers user input parsers code fragment generators routines to run executable templates executable templates packaged code support and a prepackaged library . The data management module handles the internal data structures. The database input and output routines serves as the interface to the analog verification database . The user input parsers convert user input to data that the code and document generator may interpret and provide feedback to the user in case there is an error in the input. The access function parsers convert a special type of user input that gives the user the ability to access or set quantities such as voltage or current. Access functions also provide the ability to access or to set compound quantities such as the positive quantity of a differential signal negative quantity of a differential signal differential mode components of a differential signal common mode quantity of a differential signal and a single ended value of a differential signal. The user may also define the name of the access function. The code and document generator may provide many types of outputs including models regression tests netlists connect modules simulation scripts symbols datasheets and reports. These types are defined in the form of the executable templates . The routines to run executable templates support the use of the templates . These routines aid in the interpretation of data in the executable templates . Output from the code and document generator include elements. The elements are defined in the prepackaged library . The prepackaged code support is required to enable the use of the prepackaged library . In the preferred embodiment the components in the executable templates and in the prepackaged library are described using an executable document description language. The routines to run executable templates and prepackaged code support assist in interpreting the executable document description language format.

The components of the prepackaged library shown in include prepackaged analog and RF assertions prepackaged output drivers prepackaged input receivers prepackaged branches prepackaged digital assertions prepackaged transistor models prepackaged passive component models prepackaged assertion tests prepackaged power tests prepackaged common tests and assertion coverage test code . The prepackaged analog and RF assertions are typically put into models to check that analog and RF inputs meet a particular criteria such as being within a range of certain values. Analog and RF assertions may also be placed in regression tests and may also check outputs. The prepackaged digital assertions are typically put into models to check that digital inputs meet a particular criteria such as being within a range of values. Digital assertions may also be placed in regression tests and may also check outputs. The prepackaged output drivers are predefined behavior that describe an output port of a design block. Examples of output drivers include single ended outputs differential outputs class b outputs outputs that may either source or sink current and sine wave generators. The prepackaged input receivers are predefined behavior that describe an input port on a design block. For example an input receiver could be a current input with a value for its input impedance. Another example of an input receiver is one where the user may specify a pull up or pull down resistance value. The input receivers and output drivers contain information that allow for static checks. An example of a static check includes verifying that a particular input may be connected to a particular output. Another example of a static check is verifying that the limits on the number of connections between at least one output to at least one input is satisfied. The prepackaged branches are predefined behavior that describe behavior between two terminals in the design that do not have to be ports. Examples branches are resistors capacitors inductors switches clamps and diodes. The prepackaged transistor models are predefined behavior that describe the behavior of a transistor. These models are not the foundry provided compact models for the transistors but simpler behavioral models that are more efficient but complex enough to still be sufficient for analog mixed signal and RF verification. The prepackaged passive component models are predefined behavior that describe passive components in a design. Example passive components are resistors capacitors and inductors. These models are not the foundry provided compact models for passive components but simpler behavioral models that are efficient but complex enough to still be sufficient for analog mixed signal and RF verification. The prepackaged assertion tests are predefined behavior that checks that the assertions are working properly. The prepackaged power tests are predefined behavior that includes measuring current consumption of blocks. The prepackaged common tests are predefined behavior for tests. Example common tests are tests for analog to digital converters tests for serial deserializer blocks and phase locked loops. The assertion coverage test code measures the extent to which assertions have been placed in the generated models and regression tests and the extent to which they have been exercised. All of the behavior described in the prepackaged library is parameterized and may be customized by the user. The user interface to using the prepackaged components to are designed to be as modeling language independent as possible so that the user may target multiple languages for models regression tests netlists and connect modules.

The components in the executable templates shown in are model templates regression test templates netlist templates connect module templates simulation launch scripts symbol templates and datasheet and report templates . Model templates are templates for the behavioral models that are created from user provided specifications . Behavioral models represent integrated circuits systems or components of integrated circuit or systems. Models may also be empty where a model only includes the port information. Regression test templates are templates for the regression tests that are created from user provided specifications . Regression tests are connected to either behavioral models or the design implementation to verify that the user specifications have been achieved. Regression tests are also used to verify that a behavioral model for a design block matches the implementation. Regression tests may either describe the behavior to be achieved using information from the specifications by including the behavioral model to represent the desired behavior or instantiating the behavioral model to represent the desired behavior. The regression tests may be used in design verification and post manufacturing test. The regression test templates also include tests that run on the design to calibrate models. For example tests may be added to measure the current consumption of the design. These results are stored in the database . Then the models may be generated or regenerated from the model templates to include these results. Netlist templates are templates for netlists that indicate how design blocks are interconnected. An example netlist is a chip top level netlist. The chip top level netlist describes how a plurality of blocks at the chip level are connected. The blocks at the chip level may comprise pads the digital subsystem the analog subsystem and the RF subsystem. Another example of a netlist is one that connects the regression tests to the behavior model or design to be simulated. The connect module templates are templates for connect modules. Connect modules are found in some behavioral modeling languages such as Verilog AMS. Connect modules convert signals from one domain to another. Domains include discrete or logic electrical mechanical discrete analog and baseband equivalent analog and RF. An example of a connect module is one that converts from the digital domain to the analog electrical signal domain. Manually written connect modules exist to convert from some domains to others. The preferred embodiment adds the ability to automatically generate connect modules from one domain to another as needed. The preferred embodiment also gives capability to the user to customize connect modules. Less common connect modules which the code and document generator may generate include converting between the discrete analog domain to and from the electrical domain and the baseband equivalent signal domain to and from the electrical domain. There is at least one template in the templates to . At least one behavioral language is targeted in each of the templates to . These languages include Verilog Verilog A Verilog AMS Verilog with extensions for passing analog information VHDL VHDL AMS and SystemVerilog. Also included are variations on these languages as a result of simulator dependent implementations. The templates to are designed in such a way to make them extensible to future languages. The simulation launch script templates are used to create user specific simulation launch scripts to start regression tests to configure what design data or model data is to be used and which simulator is to be used. The simulation launch scripts that are generated are in a computer language that may run on the client or on another computer of the user s choosing. The scripts are written in a scripting language. The scripts may be in a compiled form may call routines that are written in a compiled language and may be written in a compiled language. The simulation launch script templates include simulation specifics and may be customized to a particular simulator. The symbol templates are used to create the schematic symbol or used to create the code that generates the schematic symbol based on user specifications . The schematic symbol may be in a proprietary database format such as Cadence s CDB or in an open format such as OpenAccess. In addition to templates including the code or symbol data the templates include common shapes for schematic symbols for common analog mixed signal digital and RF blocks. The datasheet and report templates generate documents readable by users. The contents of these documents are derived from the analog verification database . Reports may contain all or some of the data in the database . For example a datasheet may contain the user specifications . Reports may include register lists found in the users specifications global digital control signal tables found in the user specifications coverage analysis results simulation completion analysis found in the simulation data and user specifications with simulation results indicating whether or not the specifications were met. The format of the datasheets and reports include document spreadsheet presentation document interchange format and standard formats. Example document programs are Microsoft s Word Adobe s Framemaker and OpenOffice Writer. Example spreadsheet programs are Microsoft s Excel and OpenOffice Calc. Example presentation format are Microsoft s PowerPoint and OpenOffice Draw. Example document interchange formats are rich text format RTF maker interchange format MIF extensible markup language XML and comma separated values CSV . Standard formats include the hypertext markup language HTML . The datasheet and reports may be in electronic format or printed. The executable templates are applicable to all design types and do not require that specific design type information or circuit type information be incorporated in the templates.

The components of the analog verification server application are shown in . The components web interface routines user payment account management routines user system administration routines and a license manager provide general web server functionality. More specific to the analog verification application are wiki components general system utilities database input and output routines a portable document format PDF generator for printable output download routines and output results display support . Specific to the analog verification application are a specifications organizer specifications editor module import routines a regression test run progress analyzer a revision control system a simple and advanced mode controller a verification plan editor a regression test run controller and simulation results to specifications back annotation routines . The components to provide capabilities to the user. The web interface routines provide the input and output capabilities from and to the web server . These include generating HTML and Javascript and include handling input from the user through the HTML forms using the post mechanism. The user payment account management routines handle the accounting and payment from users for the use of the capabilities provided by the platform . The data for these routines are stored in the database . The user and system administration routines include handling the user accounts and maintaining personal user data such as names addresses and phone numbers. The license manager handles authentication of the use of the server code. The wiki components give extended editing capabilities to the user when editing user specifications . These extended editing capabilities include adding text extensions tables and graphics. The graphics include schematics waveforms and timing diagrams. The general system utilities provide basic functionality to support the server application . An example of a general system utility is data formatting. The database input and output routines provide the capability to access the data in the analog verification database . The PDF generator for printable output formats data from the analog verification database into PDF that may be viewed by a PDF viewer such as Adobe s Acrobat Reader. The output results display support provides the routines to format the data from the analog verification database into a format that may be viewed by a web browser. These formats include HTML and Javascript. The output results display support also provides support to adequately display results from design to specifications consistency checker data and coverage analysis results . The download routines enable the user to download generated documents and code and generated symbols . Utilizing the download routines the user may initiate a download of at least one output. The specifications organizer provides the capabilities that allows the user to organize user specifications . Example organizational capabilities include sorting linking copying deleting organizing hierarchically and utilizing example specifications . The specifications editor module allows the user to modify the contents in the user specifications . Modifying includes creating displaying updating deleting contents in the specifications and including example specification fragments . Updating includes copy paste and undo operations. The specifications editor is suitable for editing component or top level specifications. The import routines allow the user to import information into specifications. Import formats include models manually written and models generated from the platform . For example a Verilog model may be imported and the specifications may be pre populated with port information. Other formats include formats developed for the platform comma separated valued text files an open source or commercial word processing format and an open source or commercial spreadsheet format. The imported data may be incomplete or complete specifications. Imported data may include text equations and figures which may be placed in the generated datasheets and reports . The regression test run progress analyzer reads simulation data and results and returns progress information on simulations to the user. This information may include the number of simulations that have been run the number that remain and an estimate of the time required for the remaining simulations. The revision control system allows the user to manage different versions of the specifications. The simple and advanced mode controller gives the user the ability to switch between a mode with a simple user interface to one that is more complicated but which contains more advanced features. The verification plan editor allows the user to modify verification plans . Modifying includes creating displaying updating and deleting contents in verification plans. The regression test run controller uses the data from the verification plans to provide capabilities to manage the running of regression tests. The simulation results to specifications back annotation routines provide the capability to take results from the simulation data and results and merge them with the user specifications to show which specifications have been met and which have not.

The coverage analyzer is shown in . The components of the coverage analyzer include a model coverage analyzer a regression test coverage analyzer a regression test run completeness analyzer and an assertion execution completeness analyzer . The model coverage analyzer checks to see how complete the generated model is from user specifications . For example if the user does not specify sufficient information in the user specifications the model coverage analyzer will warn the user. The regression test coverage analyzer measures how complete the regression tests are. The regression test run completeness analyzer measures to what extent the regression tests were run. This includes checking to see if the regression tests previously run are still valid. For example if the design data or the user specifications change after a regression test affected by those changes have been run previous runs of the regression test run are considered invalid and not counted as part of the completeness metric. The assertion execution completeness analyzer is used to verify that all of the assertions were executed and that the signals they are supposed to check were checked.

The database contents are shown in . The contents include example specifications example specification fragments user specifications generated documents and code results from the design to specifications consistency checker generated symbols coverage analysis results user account information simulation data and results verification plans and other housekeeping information . The other housekeeping information are data required by any of the components in the server in additional to the other contents to mentioned in the database . An example piece of housekeeping information are web session data to manage active users. In this case the component utilizing the other housekeeping information is the web interface routines .

In this invention design specifications serve as the starting point that drives the platform . The design specifications may be the specifications for an entire design or a component in the design. The design may be the design of an integrated circuit or a system. The specifications include the behavior of the design. The specifications may also include the behavior of the tests to be performed on the design. It is intended that for a design that there is a top level specifications along with many specifications making up the components blocks and subsystems for that design. The design specifications shown in FIG. includes many sections to which are intended to capture the specifications of an analog mixed signal or RF integrated circuit or system design.

In the preferred embodiment the specifications include parameters for the specifications port types used in the specifications a list of ports of the design being specified discrete variables used to describe the behavior continuous variables used to described the behavior user defined behavioral code user comments branches used to describe the behavior instances in the design register and global control signal maps of the design states in the design test sequences to be used on the design and look up tables to aid in describing the behavior of the design . Not all designs or design blocks need to include all of the sections listed in the specifications . Each section of the specifications to and to may have zero or more items. The section of the specifications is required where at least one port needs to be described. This is because the specifications are based on a description of the ports. The behavior of the overall block or design being described may be captured with only a description of the ports and how the ports interrelate to each other. The other sections to and to add to section providing additional descriptions which ultimately connect to the ports in section . The sections to of the specifications do not ask for information on the circuit type of the design. Information on the circuit type of the design is not required. Both analog ports and digital ports may be in the list of ports . An analog port is a port that connects to an analog signal. A digital port is a port that connects to a digital signal.

These items are described by attributes to which may or may not be applicable in each of the sections to . A table indicating which sections to include which attributes to is shown in . The specification sections to are shown in the top row of the table . Attributes for each of these sections are shown in the first column to . A check mark at the intersection of a row and a column indicates that the particular attribute to may be specified in a particular section to of the specifications. An item is described by the attributes listed.

An example is shown in . This example shows the list of ports section . The attributes to associated with the list of ports section are listed in the top row of the table. Each item of this section of the specifications is a row in the table. In this example there are six items to . The list of ports section is specified in second to final row of the table. In this example the user provides the contents in rows to . Each box in each of the rows is a field in which the user may enter data.

Attributes to of each item are provided by the user. Examples to assist the user are provided in examples specifications and example specification fragments . Name is a name given to an item. It has a specific meaning depending on what the specifications section to is. Description is given by the user and is not meant to be interpreted by the computer. Value is the value associated with an item. Aliases is an equivalent for the name and is considered the same when used in the specifications . Differential indicates whether or not an item is differential in nature. Access methods define the methods by which the quantities in an item may be accessed. Pin types refer to types defined in modeling languages. The supply domain indicates to which supply domain an item belongs. This information facilitates static checks to validate that connections between input and outputs are in the same supply domain. Direction indicates a direction for an item. A port types attribute may take on a value of one of the port type contents . A range indicates a valid range for the port . A behavior describes the behavior of an item using an expression. A protected variable may be used to filter the input port. The filtered result is what is given in the protected variable entry. Affects analog indicates whether or not an item affects the analog section of a model or regression test. A reference port is used to indicate whether or not there is a reference port where rather than using ground as the default reference another port is used. For example a signal may want to refer to a port which has a common mode voltage instead of ground. In this case the port with the common mode voltage would be indicated in this field. Gmin refers to the minimum conductance to ground or a reference on that node. Pin number allows a user to enter a value associated with a port. An order field allows a user to order a list of items. Attributes allows the user to specify additional information about a port that may be used in both static and dynamic verification. For example a bias current could have an attribute which indicates its tolerance. Another example would be a supply port could have an attribute indicating that it is regulated or unregulated. Symbol information contains specific information to aid in the generation of the symbol. Included in the symbol information is the location of the pin on the symbol. Test metrics provide information to assist in the automatic generation of the regression tests. A test metric could indicate that pin has to be tested exhaustively for all combinations or that only certain values need to be tested. For analog inputs example test metrics include defining an input such as a sine wave an input ramp and an input test range. A variable type refers to the model variable type to be used. A trigger refers to what ports or variables cause the behavior of an item to change. Wait allows the user to specify a condition for a signal that must be met before behavior is to be executed. Initial specifies the initial condition for the item. A measurement unit specifies the measurement unit for an item. Example measurement units include ampere volt coulomb joule weber meter second Ohm and henry. Smooth specifies a variable that contains a smoothed version of the item. Branch type specifies the type of branch to be used. Connects specifies the connections for the branch units instances or register map. Item parameters are additional information to be provided for an item. Instance reference provides a link to a specifications that is to become an instance of the specifications in which the instance reference is found. The location gives information as to where an item is to go. The default and state columns may add one or more columns to a table where the user may specify values for items when in the default state or specific states. For example for an item in the ports section that is a digital port type with a direction of input the default state could indicate that its value is to be zero. Another example is for a supply port type the default state could indicate its current consumption when in the default state. The behavior for the particular state could also be entered in the field. A behavioral condition may also be placed in the field to verify that when in a particular state that the condition placed in the field has been met. During verification when in default mode an assertion could be added to verify that condition.

Some of the input fields for the attributes and specifications sections have a preselected set of values. Example options for input fields are shown in . Example names for items of the parameters section are listed in table entry . Example values for pin types are listed in table entry . Example port directions are listed in table entry . Example port types are listed in table entry . Example discrete variable types are listed in table entry . Example branch types are listed in table entry . The instance reference refers to other spec sheets and masters in the design data as listed in table entry .

This invention creates a design specifications driven platform for accelerating and improving the quality of analog mixed signal and RF verification. Starting from design specifications models regression tests netlists datasheets symbols connect modules and simulation scripts may be automatically generated. In addition reports may be generated that include coverage analysis results from static checks of the design implementation to the specifications and simulation results.

There are many flows that analog mixed signal and RF designers use when designing and verifying an analog mixed signal or RF integrated circuit or system. This invention fits into many design flows. These include top down bottom up and middle out flows. An example flow in which this invention may be used is shown in . A design flow is on the left and a verification flow is on the right. A user of the design flow is likely a designer and is likely part of a design team all of whom may be using the design flow for a particular integrated circuit or system design. Designers may include analog mixed signal RF system digital engineers and a combination. A user of the verification flow is likely a verification engineer and is likely part of a verification team all of whom may be using the verification flow . Verification engineers may include analog mixed signal RF system digital verification engineers and a combination. The user of the verification flow may also be a designer in the case where the design and verification effort is combined. Users of the platform include analog verification engineers analog designers analog design leads digital verification engineers CAD engineers and system engineers.

The flow begins at the start of a design . The first step is the creation of the top level datasheet . The user may accomplish this using the datasheet generator . Working on a client computer the user uses a web browser connects to the web server and accesses the analog verification server application . The top level design specifications may be entered using the specifications editor . In this way this embodiment of the platform accepts the input of the specifications from the user. The designer utilizes the prepackaged library to be more efficient when entering the specifications. A rich set of information may be entered using the wiki components . Examples and are also available to accelerate the effort. The specifications are stored in the database in the user specifications section. Once entered the code and document generator may be used to generate the data sheet utilizing the datasheet and report templates . The output of the code and document generator is stored in the database specifically in the generated documents and code section. Then using the download routines the data sheet goes through the web server to the web browser and finally stored on the client . Once a version of the top level datasheet has been agreed to by all of the interested parties to the design the designers define an architecture for the integrated circuit or system and create the component datasheets . The interested parties may include the team developing the integrated circuit or system and the team who will ultimately use the manufactured integrated circuit or system. The component datasheets may be generated in the same manner as the top level datasheet described previously. At this point an assessment is conducted to see if the design is feasible . Step may include performing hand calculations using a spreadsheet to predict performance writing models even implementing critical components and running simulations. The datasheets that were generated in steps and facilitate step by providing documentation that the engineers may study. This platform may be used to generate models for this feasibility study. From the specifications entered the code and document generator is once again used this time utilizing the model templates . If the design is determined to be not feasible the top level datasheet architecture and component datasheets are adjusted until feasibility is reached.

At this point analog verification begins with the design flow and the analog verification flow running in parallel. Different engineers may be assigned to the different flows. The engineers on the design flow begin to implement the components . For analog mixed signal and RF circuits implementing includes drawing schematics and performing at least one simulation to validate that the implementation meets the specifications.

For digital circuits implementing includes writing RTL and drawing schematics to validate that the implementation meets specifications. The implementation results are stored in the design database . The first step in the analog verification flow is to create datasheets for the components if they were not previously created in step . Once again this may be done using the code and document generator using the datasheet and report templates . If models exist that define the components or if the specifications are written in one of the formats that may be imported the models or the specifications may be imported using the import routines and serve as the starting point for the specifications. To manage all of the specifications for the components being entered the specification organizer and the revision control system may be utilized.

Models are then created for the components . Models are generated from the specifications using the code and document generator utilizing the model templates . A portion of the generated model would include converting the behavior of analog ports described in the list of ports . The next step is to develop regression tests for the components . The specifications utilizing the code and document generator and the regression test templates are converted to at least one regression test. To efficiently run the regression tests on the models and implementation simulation scripts are developed . These simulation scripts are created using the code and document generator utilizing the simulation launch script templates . The regression tests are then run on the models . The simulation scripts along with the models and regression tests that were generated run on the simulators producing results that are stored in the analog verification database specifically in the simulated data and results section . Next connect modules are developed to enable running the regression tests on the implementation . The connect modules are generated using the code and document generator utilizing the connect module templates . The simulation scripts launch the regression tests on the implementation utilizing the regression test on the implementation that is in the design database using one of the simulators verifying whether or not the implementation of the design is consistent with the specifications. The regression tests results are again stored in the analog verification database . To configure how the regression tests are launched the regression test run controller may be used. Configurations include scheduling and whether or not simulations are to run in parallel. Progress of the simulations may be monitored utilizing the regression test run progress analyzer . To configure the overall goals for the verification effort the verification plan editor may be used. Once entered the verification plan is stored in the database in the verification plans section. Depending on how much the user wants to customize the details of the verification effort the simple advanced mode controller may be utilized. Finally to view the regression test results in the context of the specifications the simulation results to specifications back annotation routines are utilized and the code and document generator utilizing the datasheet and report templates are used this time generating a report which details how the desired specifications compare to simulated results. A datasheet may also be generated which includes the specifications and a summary of the simulated results. The results may be viewed by the user using the output results display support or on paper using the PDF generator for printable output . Steps to are repeated until all of the components that require models have been generated.

A set of static checks is then performed on the components. To accomplish this design data is extracted and stored on the server . The design data is then checked for consistency to the specifications stored in the analog verification database . This is accomplished using the design to specifications consistency checker . The results are stored in the database specifically in the results from design to specifications consistency checker section . Component level coverage is then analyzed . This is accomplished using the coverage analyzer . All aspects of coverage are measured including model coverage regression test coverage regression test run completeness and assertion execution completeness . The coverage analysis results are stored in the database specifically in the coverage analysis results section . After this a user produces reports to document the component level work . These reports may be generated using the code and document generator utilizing the datasheet and report templates . The user may produce the reports in multiple formats to be more suitable for the audience or post processing. For example a report in document form is more suitable for reading by another user while a report in a spreadsheet format is more suitable for post processing. All reports are generated as part of step .

When the implement components step in the design flow completes layout of the components begins. At the same time as long as some of the components are complete the design may be assembled and chip level simulations begun .

Developing schematic symbols for the components is required for the top level work to and to . The symbols are generated using the symbol generator utilizing the symbol templates . The results are stored in the database specifically in the generated symbols section . The generated symbols may be used in the design flow by placing them in the design data where they are instantiated as part of the assemble design and chip level simulations step . As the design is begin assembled top level verification may begin. The top level netlist if it is not available from the assemble design step is created . The top level netlist is generated by the code and document generator specifically using the netlist template . The next step is to produce register maps and top level connectivity descriptions . This may be done using the code and document generator utilizing the datasheet and report templates .

The next set of steps to follow the same procedure as steps to at the component level. The platform is used to generate the reports code and scripts required to execute steps to . These steps are develop top level regression tests develop simulation scripts run top level regression tests on models develop connect modules run top level regression tests on implementation extract the design data check design consistency analyze top level coverage and produce reports for the top level work . The code and document generator utilizing the templates the consistency checker symbol generator and coverage analyzer are used to accelerate steps to .

In the design flow after the design has been assembled the top level layout is then completed followed by final simulations . Physical verification including layout versus schematics and design rule checking procedures follow.

Either after or during steps to all of the regression tests are re run on the final version of the design. All coverage is re analyzed to confirm that verification is complete on the final version of the design. If there is no cause for concern from the analog verification team the team signs off on the design . The analog verification flow is complete .

When the design team is satisfied that it has completed and implemented the design and the verification team has signed off on the design the design team completes the final design steps . This includes creating the data required for manufacturing. At this point the design flow ends .

A detailed flow for specifications entry and output generation is shown in . The start denotes the starting point of the flow which is at the point when the user is prepared to enter the specifications for a design or a component. The user enters the specifications using a web browser that connects to a web server that connects to an analog verification server application . The specifications are accepted and stored in the analog verification database . Entry of specifications is accelerated by the prepackaged library and the examples and . The specifications are saved to the database . The input is parsed by the code and document generator that utilizes the user input parsers and the access function parsers routines. If there is an error or if at least one message needs to be communicated to the user the errors or messages are stored in the database and the errors or messages are presented to the user utilizing the specifications editor module . If there is no error then at least one output is generated . This is accomplished using the code and document generator and the symbol generator . These utilize the executable templates . By doing so the outputs may be models regression tests netlists connect modules symbols simulation scripts and datasheets and reports . Messages are then displayed to the user . These messages may include warnings or suggestions to the user on how to improve the output. The generated outputs are displayed to the user . If the generated outputs are satisfactory the user is then given the option to download one or more of the outputs . This ends the flow for generating outputs.

The flow for the preferred embodiment of the code and document generator is shown in . After the start the first step is to retrieve the specifications from the database . Following retrieving the specifications using the database input output routines the specifications are stored locally using the data management module . Based on the desired output the corresponding template is loaded from the executable templates . The template is then executed . Executing the template requires the user input parsers the access function parsers routines to run executable templates code fragment generators the prepackaged library and prepackaged library support routines . The template is then checked to see if there are fields requiring expansion . Fields requiring expansion are either filled by the specifications input data or data derived from the input or filled by another template . If the check determines that another template is required the load executable template step is performed again. The loop continues until the template no longer has any fields to complete. Messages including errors and warnings are saved to the database . The generated output is saved to the database . This completes the flow for the preferred embodiment of the code and document generator.

An example Verilog AMS model A and B for a gain stage that has been generated is shown in . The list of ports section of the specifications for this example is shown in . The module and input declarations are based on the list of ports section for ports to . Analog assertions that are generated are also based on the list of ports section for ports and . Finally the analog behavior is also specified in the list of ports section . The analog behavior is specified on ports and in this example.

There are alternative embodiments of this invention. A platform need not contain all of the components shown in . A subset is sufficient to provide efficiency gains in analog verification. For example generating only models does accelerate analog verification. In this case the components required are a web browser a web server an analog verification server application a code and document generator an analog verification database a client interface and a server interface . For a subset of functionality the components which are in a code and document generator prepackaged library executable templates analog verification server application coverage analyzer and database contents may also be a subset of the components described in the preferred embodiment. A platform may also include additional components to provide more functionality. Further the code and document generator need not be one entity. The code and document generator may be separated into a code generator and a separate and distinct document generator and if only code is required only the code generator need to be in the platform . If only documents are required only the document generator need to be in the platform .

A platform may also have at least one component implemented in a different manner. These different manners include at least one component being implemented differently a plurality of components being combined or at least one component being split into a plurality of components. Examples of how components may differ follows. Prepackaged library components to need not be described in an executable document description language. Alternative description approaches include using other formats and languages a template where a search and replace mechanism is used and a template which contains embedded code to generate the result. Instead of using an SQL database the data may be stored in a set of files. Another example of a component being implemented in a different manner is to replace a symbol generator with a symbol and schematic generator. In this way netlists that are generated from a code and document generator may also be represented by a schematic. Generated models regression tests netlists connect modules and symbols would now also include schematics which would be stored as part of design data . An example schematic is a top level schematic. Also the code and document generator may also generate a simulation launch script configuration file to be used by a simulation launch script itself as a way of separating the simulation launch script and configuration information specific to design.

Another embodiment of a platform is that rather than be structured as a web based application the platform is structured as a stand alone application. Specifications would be edited in various means including using a custom editor an open source or commercial word processor and an open source or commercial spreadsheet program. An analog verification server application would be part of the stand alone application providing a user interface directly on an operating system such as Microsoft Windows MacOS Solaris Unix or Linux. A client interface and a server interface may not be necessary.

Another embodiment of a platform is where specifications are edited using various means including a custom editor an open source or commercial word processor and an open source or commercial spreadsheet program. An analog verification server application would reside on a server wherein the specifications editor would be enhanced to communicate with the server . An analog verification server application and a server interface would have an interface to the specifications editor.

The sections of the specifications do not have to be separated in the same way as shown in . A least one of the sections to may be split up into multiple sections or a plurality of sections to may be combined into an individual section. An example is that the register section and states section may be combined. Also all of the sections need not be present. For example if a platform is only to generate models then the test sequences section is not required. If only component models are to be generated then the register and global control signals map instances are not necessary. Also simple models may be generated from a small set of sections. For example a simple model may be generated with only the sections parameters port types and list of ports . Finally at least one additional section may be provided in the specifications to add additional functionality.

To simplify the description of port relationships prepackaged units may be included in the prepackaged library . Prepackaged units offer a simplified way of describing analog basic building block functionality. For example the prepackaged units may comprise drivers receivers branches transistor models and passive component models. These prepackaged units serve as a simplified method or short hand for describing the common analog behaviors at the port level within the design. A units section would be added to the specifications . Units may include one or more of the predefined behaviors. As with all of the other sections in the specifications except for list of ports the units section may have zero or more entries.

In the table shown in that shows which attributes to are associated with which specifications section to different embodiments may have different attributes for the different specifications sections. Attributes may be removed. New attributes may also be added.

The table shown in lists example options for particular input fields . The listed options to may be different in different embodiments. Options may be removed and new options may be added.

The first embodiment described in this patent application uses the term datasheet to describe a human readable output document. The term specifications is used to describe an input to the code and document generator. In the field of analog mixed signal and RF design the term datasheet is often used synonymously with the term specifications. An alternative embodiment of the invention described in this patent application would be to use the term datasheet in addition to the term specifications to describe the specifications . The term specification the singular form of specifications is also often used to mean specifications. An alternative embodiment of the invention described in this patent would also be to use the term specification in addition to the term specifications to describe the specifications .

In the field of analog mixed signal and RF design the term testbench is used to refer to at least one test run on a model or a design implementation. The term testbench may be used in place of regression tests. Also the testbench need not be self checking. The regression test templates may contain a template for a testbench that is not self checking where the comparison between the outputs of the model and the design implementation is done visually by the designer or the verification engineer.

An alternative to the server containing at least one processor readable storage mechanism is that the server is network connected to at least one processor readable storage mechanism. An alternative to the client containing at least one processor readable storage mechanism is that the client is network connected to at least one processor readable storage mechanism.

Many design and verification flows exist. The design and verification flow shown in is only one example. Examples of different flows are as follows. The design flow may be combined with the verification flow to form a single flow. The steps to to and to do not have to be in the same order as shown in to . The steps to to and to in to may be executed sequentially or in parallel.

Not all of the steps to in the design and verification flow need to be followed. Any amount of verification may lead to potential benefits in finding errors in the design. One example of a reduction is a flow that includes create datasheets if none available develop models for components create top level netlists if not available develop top level regression tests and run top level regression tests on models . In this flow models are created for the components. These models are then combined and tests are run on the top level. This has the potential of catching top level issues and interaction issues between the components. This reduced flow is not as comprehensive as the verification flow but still offers benefits. As the run top level regression tests on the implementation step may be expensive in time the flow may be reduced by removing this step. Other alternatives include completing this step is a mixed level fashion. Mixed level means that some of the components are simulated using the models while others are simulated using the design implementation. Multiple simulations may be conducted so that each of the components may be simulated at least once at the design implementation level. Another reduced flow is not to run regression tests on the models skipping steps and and running only on the implementation. In this way the focus is to check the specifications directly against in the implementation. This may be done if the simulations of the implementation may run fast enough.

There are two approaches to verifying the consistency between a model and a design implementation. The first as described in the Design and Verification Flow is to run regression tests on the model and then to run regression tests on the implementation . An alternative approach is to run the regression test on the model and implementation of the design simultaneously comparing the outputs from the model and the implementation to verify that the outputs are functionality consistent. To support this latter method the regression test templates would include a template that instantiates the model inside the regression test.

A user also need not work on all of the steps to at the same time. For example a user may use a client that has web browsing capabilities such as a mobile phone. Using a web browser that is on the client the user has access to many of the capabilities in the platform . For example the user may access the regression test run progress analyzer .

The design and verification flow may also be extended to add additional steps to obtain additional benefits. An example is where a netlist is required at the component level to connect the regression test and models . In this case a netlist generation step is required between steps to . Another extension is that rather than having two levels of hierarchy a component level and a top level in the design and verification flow a verification flow may have a plurality of levels of hierarchy for the components. In this case steps to are repeated for each intermediate level of hierarchy until the top level is reached. Another extension is to add a model calibration step after step where results from the regression tests are put back into the model. In this case the models are regenerated using the code and document generator using information from the simulation results . Manual extensions may also be made to the reports models regression tests netlists connect modules symbols and simulation scripts wherein said reports models regression tests netlists connect modules symbols and simulation scripts require additions to meet user needs. For example a user of a platform may not have entered a complete design specifications. In this case after the code and document generator is run the user may manually insert additions into at least one output of the code and document generator. Another extension to the design and verification flow is to utilize model templates to generate a model that includes utilizing the prepackaged assertions and and that instantiates the design. In this way assertions may be applied to the design.

Another use is that a platform need not be applied to only analog mixed signal RF integrated circuit and system design. For example the platform may also be applied to a digital only design and a system design where the output is not a final chip but an architecture.

Another use of a platform is to use the platform in a programmatic manner. Rather than utilizing a human user interface such as a web browser to access functionality and data in the platform utilize the API in a server interface . A user may write a computer program to operate the platform . In this way the user may achieve more automation and possibly increase efficiency. Computer programs may be written in a compiled language or in a scripting language.

A platform may also be used in a flow where there is no verification flow but only a design flow. For example designers commonly develop models while implementing components . Such as flow includes steps defining architecture and components checking for design feasibility implementing components and assembling the design and chip level simulations . Another example of a design only use of a platform is as a specifications management system where the goal is to primarily use the datasheet and report templates to generate datasheets.

A platform may also be used primarily for model generation in both design and verification. In this case specifications are created for the design components . Models for each component are generated in multiple languages to aid in the design and verification effort. For example Verilog may be generated for the digital verification team. Verilog A may be generated for the analog design team. Verilog AMS may be generated for the analog verification team. This leads to significant time savings as the specifications only need to be entered once and multiple models are generated.

A platform may also be used as part of other flows where the platform is treated as a tool in the context of a larger flow. For example there are many digital verification platforms and methodologies. A platform may be used as part of that.

A platform may also be applied to design for test and post manufacturing testing. Models regression tests generated and coverage analyzer may be used as part of the design for test effort. The models and regression tests generated may be applied in post manufacturing testing.

Not all design components need to follow the analog verification flow . Pre existing models may be used in place of generating ones from specifications. Instead of pre existing models the design implementation may also be used provided that the components simulated using the design implementation may simulate fast enough to complete the top level regression tests .

There may be at least one user using a platform at any given time. Users may be collaborating or be working on different designs.

Custom digital design is logic circuitry designed without the aid of automated or semi automated synthesis. As a result custom digital design is very similar to analog design in that no model abstraction is available as a result of the design process and a separate process is required to generate a behavioral model and has the same requirement that a regression test is needed to validate that the behavioral model is consistent with the design implementation. The invention described in this patent application may be applied to custom digital design.

Thus the reader will see that at least one embodiment of this invention provides methods for generating models regression tests netlists connect modules simulation launch scripts simulation launch script configuration files and schematic symbols for a design based on the specifications for that design. While the above description contains many specificities these should not be construed as limitations on the scope but rather as an exemplification of one preferred and alternative embodiments thereof. Many other variations are possible. Accordingly the scope should be determined not by the embodiments illustrated but by the appended claims and their legal equivalents.

