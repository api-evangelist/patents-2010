---

title: File kinship for multimedia data tracking
abstract: Kinship between electronic files among personal networked devices may be ascertained between the files by determining an operational relationship between the files and with a similarity measurement.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09449024&OS=09449024&RS=09449024
owner: Microsoft Technology Licensing, LLC
number: 09449024
owner_city: Redmond
owner_country: US
publication_date: 20101119
---
Today people usually possess multiple computing devices including home servers personal computers personal digital assistants PDA portable gaming systems and mobile phones. With the possibility of multiple computing devices it becomes ever easier to create multimedia content such as by taking photos with digital cameras. Also people often produce multiple versions of the same content to better serve different purposes. Further different versions of the content may flow to different targets devices folders or documents . However as time goes by and content accumulates one can easily lose track of which versions of what content are on different targets.

The present disclosure describes determining kinship between electronic files among a network of multiple personal devices. Many specific details are set forth in the following description and in to provide a thorough understanding of various implementations. One skilled in the art will understand however that the subject matter described herein may have additional implementations or that the concepts set forth may be practiced without several of the details described in the following description.

To determine the kinship between files both an operational relationship and a similarity are determined between files . The operational relationship between files may be inferred from the system operations of devices . Specifically system operations such as higher level operational commands between files are observed. The higher level commands include but are not limited to save as copy and move. The higher level commands typically comprise multiple low level file system calls and responses for each operational command. Thus by pattern matching the low level file system calls the higher level commands may be observed thus establishing an operational relationship between files wherein files may be now designated as related files . The low level file system calls include but are not limited to open create and close . Observing the file operational commands between the files also facilitates local file operations when the files are stored on a single device and remote file access when the files are stored on one or more of the devices .

Further after determining the operational relationship the similarity between files is determined when files have a similarity or strength of kinship greater than tunable parameter . Tunable parameter is set by a user. To determine the similarity between files the strength of kinship between files is quantified. The strength of kinship may be quantified via bit level analysis content level analysis or both.

Bit level analysis of files comprises obtaining a bit level similarity of files . Files regardless of the contents thereof are treated as bit streams and a bit level similarity is obtained by counting the number of bits in common between any two or more of files . Specifically files are segmented into non overlapping variable sized chunks that can tolerate a shifting effect such as insertion or deletion of a single byte with the chunk boundaries based on file contents. Therefore insertions and deletions of bits into the chunks only affect the surrounding chunks. Duplicated chunks between files are then identified and a bit level similarity is obtained by determining a percentage of duplicated chunks between files normalized against a file length of one of the files .

Content level analysis of files comprises obtaining a content level similarity of files . For example where files are associated with audio contents e.g. an audio file audio fingerprinting techniques are applied. Specifically an audio fingerprint is a condensed digital summary such as a low dimension feature vector. A distortion discriminant analysis DDA may be employed to segment the audio file into a series of fixed interval e.g. 186 milliseconds segments called frames. Each frame of data is processed such as with fast fourier transform FFT and equalization and converted to a 64 dimension vector using oriented principal component analysis OPCA . Another layer of OPCA may then be applied to the vector in a sliding window fashion with the window length equal to 32 frames to obtain the final 64 dimension fingerprint for that window. Thus to determine an audio content level similarity the Euclidean distance between the features is calculated and the distance is normalized to a range of 0 1 with an effective exponential function NEF y e with being a tunable parameter. In one implementation is set to 1 8000.

Furthermore where files are associated with image content e.g. an image file a feature vector of the image file may be extracted as a k bit hash code. The hash code may be obtained by first uniformly dividing the image into k e.g. k 8 8 subimages and the average luminance of the sub images may be calculated. Then each sub image is quantified to a binary bit by comparing its luminance against the average luminance. Thus the k bit hash code is generated. The k bit feature vectors of the image file are obtained by measuring an image content similarity by the equation

However by applying two differing similarity analyses to files two differing strengths of kinship may be obtained a bit level strength of kinship and a content level strength of kinship. In an example files have differing bit level strength of kinship and content level strength of kinship. For example under transcoding cases the content level strength of kinship may be 1.0 but the bit level strength of kinship may be 0. To that end in one example the maximum of the bit level strength of kinship or the content level strength of kinship may be used as the final strength of kinship.

In some embodiments after establishing that files have an operational relationship and before quantifying the kinship metadata filtering of the files may be employed. Metadata filtering of files reduces a number of candidate files that will have the strength of kinship similarity analysis applied thereto thus saving computational resources of devices . In a further implementation the metadata filtering may be done concurrently with the observing of the operational commands pattern matching mentioned above. The metadata of files is examined and filtered such that a subset of files comprises similar types of content e.g. files that are unlikely to have kinship are excluded from the files . For example spreadsheet files do not comprise similar content to image files. Specifically when kinship of a first file is being determined with respect to remaining files remaining files having differing extensions .jpg .dll .exe from first file may be removed from considerations of kinship with first file and thus be excluded from the similarity analysis.

Further metadata filtering includes but is not limited to excluding a subset of files relating to system processes that access the disk frequently but are rarely related to user data operations on multiple file types that are of no interest to multimedia file kinship and access to system folders.

After quantifying the strength of kinship between files the strength of kinship is compared against the tunable parameter . If the strength of kinship is greater than or equal to then kinship is established between files . However if the strength of kinship is less than kinship is not established between files . Tunable parameter is a user defined value and thus can be adjusted from 0 to 1 depending on the level of similarity desired by the user. For example if file has strength of kinship of 1 with respect to file file is an identical copy of file .

After establishing kinship between files a kinship directed graph KDG may be created representing the file kinship between files . shows an example of KDG . In KDG each node represents a file . The nodes comprise metadata of the files including but not limited to filename location either a local directory of the device or the network path of the other devices and timestamp. Connecting the nodes to one another are links representing the kinship relation between nodes files . Links have at least three properties including similarity direction i.e. the derivation relation who is derived from whom and the operation that generates link . After determining the kinship between files mentioned above any updates to the kinship and KDG is propagated within each device and between devices . The updates may comprise new files being introduced to system or modification of existing kinship links between files .

For propagating kinship updates within each device local kinship update first any new kinship with other files that are previously within the kinship graph is captured. Second the existing kinship links are re evaluated if the files have been modified. In a further implementation a file may be deleted to propagate kinship updates within each device . If the deleted file has kinship with respect to remaining files then file will be marked as a ghost node on KDG and will remain in KDG . This facilitates avoiding partitioning of KDG and hence preserves a potential kinship among related files to deleted file . Further it minimizes the operation overhead for file deletion. However if the user intends to completely remove the node file the ghost node will be deleted from KDG as well. In this occurrence all the associated kinship links to deleted file will be removed and a repair of KDG will be attempted unless deleted file is related to a sink node . Specifically if there exists a node with identical content among its parents or children all of links to that node will be reincarnated. Otherwise parents and children of node will be reconnected by inheriting the link direction and re evaluating the pair wise similarities among them to avoid partitioning KDG and hence preserve the potential kinship among files .

For propagating kinship updates across devices a cross device kinship update is employed. Specifically in one implementation each device maintains a full kinship view only for all its local files . Thus this is a partial view of the network wide kinship because each single device only contains a portion of all files . Moreover for files copied between devices there may also be choices in capturing and updating kinship depending on how far the kinship data propagates. A first choice is one hop propagation that is only file being copied between devices is introduced in the kinship. Any updates other than that file will not be propagated. The second choice is extended propagation such that when file is copied between devices its kinship to other files not necessarily also copied also propagates to the target device . Future updates to its kinship not necessarily updates on itself will be propagated as well. shows the various kinship propagation schemes. Suppose device has three files and shown as nodes A B and C respectively with kinship relation as shown in . show the resulting kinship graphs on both devices and after file is copied shown as A or B to device for one hop and extended propagation schemes. The extended propagation scheme ensures consistent kinship views on different devices . This is depicted in . This consistent view enables network wide kinship navigation but may cost more to propagate kinship updates. It is a design tradeoff between the convenience wider availability of kinship data and the system complexity.

During the local update mentioned above all kinship updates outgoing to other devices are marked and queued when devices are disconnected. A connection is then established between devices for example between device and device . Files in common between the connected devices device and are determined to define common files. Thereafter any updates to the kinship of device are propagated and merged for the common files based on the aforementioned kinship updates from device . Further any updates to the kinship of device are propagated and merged for the common files based on the aforementioned kinship updates from device .

For property updates to links the updates are propagated to replace or update the previous links . For node property updates three scenarios are differentiated. For new files being copied when a file is copied from one device e.g. device to another device e.g. device device will first update its own KDG by inserting a new node corresponding to the file on device and the corresponding cross device link. Device will then send for the common files the updated kinship graph to device . The feature set of the file is also sent to facilitate future kinship measurement on device . Note that the feature sets of other files on device are not sent.

For existing files updates either device or or both may modify a subset of files belonging to the same KDG . If the modification is made on non boundary nodes of the KDG i.e. nodes other than the two ends of a cross device kinship link the updates will be sent to the other device and merged accordingly. If one of the boundary nodes is modified then device will extract the new feature set and send it to the other device for the strength of kinship similarity analysis. After employing the strength of kinship similarity analysis the other devices will update their respective KDG by altering the strength of kinship similarity value. This update also triggers new link property updates that will propagate back to device and replace the old values. Simultaneous update of both boundary nodes is analogous to that mentioned above except that both devices need to extract new feature sets. However it may incur redundant similarity tests and link updates. This can be solved using timestamps to select the most recent to dictate the similarity test and link update.

For deletion of existing files when files corresponding to non boundary nodes of the KDG are deleted on one device the resulting kinship updates are propagated to the other devices . If a boundary node is deleted it is marked as ghost. However if a boundary node is to be removed from the KDG the cross device kinship link will be deleted. The feature sets of all children of the boundary node will be sent to the other device which will in turn re evaluate the similarity against the other boundary node. The kinship link s is thus reestablished and its direction is inherited from the deleted link. If the two boundary nodes are removed simultaneously the cross device link is deleted and the kinship graph is not repaired.

As mentioned above once files are determined to have a kinship relationship between each other information associated with one or more of files may be propagated to all remaining files having kinship thereto. In an example a user has associated a plurality of tags associated with file . Upon copying file between devices it is desired to have the plurality of tags associated with file propagate to remaining files having kinship thereto across devices . Establishing kinship between files automatically propagates tags between files . Further information that may be propagated includes ranks of files .

In a further implementation determining kinship of files is delegated to an additional computer. As mentioned above device is a smartphone a low profile device and device is a personal computer a more powerful device. Thus device has superior computing and power resources compared to device . To determine the kinship between files stored on device as a result of device having superior computing and power processing recourse device may delegate determining the kinship of files on the device to device . A delegant delegatee relationship will be established between devices and .

In a further implementation consistency between files may either be strong or weak. Strong consistency requires immediate kinship updates whenever files are modified. This may result in a larger amount of computational overhead to evaluate the strength of kinship similarity . Weak consistency updates file kinship when devices are idle or not in a power sensitive mode e.g. laptop on external power . Thus it may be desired to have a weak consistency between files to conserve power resources.

In a further implementation system may further provide Application Programming Interfaces API . A kinshipExplorer API may retrieve and optionally visualize the KDG of the files . A TagAll API may be used to propagate tags added from files to other files belonging to the same KDG.

In a further implementation files may have an asymmetrical strength of kinship e.g. the strength of kinship of file is interpreted from the standpoint of file being examined. Specifically file has a first strength of kinship with respect to file and file has a second strength of kinship with respect to file wherein the first and second strengths of kinship differ. In an example file is included in file such as embedding multiple pictures into a power point presentation. From the perspective of file the strength of kinship to file is 1 as its information is completely included with file . However from the perspective of file the strength of kinship to file is less than 1 since it also comprises other information in addition to file .

In a further implementation establishing kinship between files across devices may facilitate smart selection intelligent de duplication and data tracing. Smart selection is the ability with all files available to a user to easily pick the most proper version as determined by the user of file at the most proper device for a certain purpose as determined by the user. For example a user can readily select file having an intermediate resolution for an online picture printing service. Intelligent de duplication is the ability with all files available to the user to selectively discard files having the same content. In an example the user can safely delete a subset of files from digital camera after copying the subset of files to personal computer to make memory space for additional images. Data tracing is the ability for the user to trace where specific content files goes on what devices or is included in which documents. In an example the user may trace pictures and identify text documents and presentations that the pictures are embedded in as well as kinship of the pictures on devices .

The memory may comprise computer readable storage media CRSM . The CRSM may be any available physical media accessible by a computing device to implement the instructions stored thereon. CRSM may include but is not limited to random access memory RAM read only memory ROM electrically erasable programmable read only memory EEPROM flash memory or other memory technology compact disk read only memory CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computing device.

File system monitor component monitors the operational commands between files and feeds the detected operational commands to kinship capture engine component . The kinship capture engine component tracks the local kinship updates and determines the operational relationship between files based on the operational commands and identifies candidate files that may have potential kinship to define related files . The kinship capture engine component then triggers a post verification process to quantify the strength of kinship between related files . This quantification may include applying the bit level analysis and the content level analysis to related files to established kinship between related files based on the strength of kinship.

The kinship propagation manager component monitors the networked kinship updates by monitoring the signal channel to other devices e.g. kinship propagation manager component monitors the signal channel to device to maintain cross device kinship. For example if device is disconnected from the system such as from a disconnect of network updates to kinship across devices will be queued locally and resume upon connection to system . Specifically files that are stored on device may have kinship with files stored on device . Thus any updates to files on device such as tagging or ranking will be propagated to files on device having kinship to files on the device .

The kinship service engine component processes commands such as queries and manipulations from third party applications with respect to files relating to the kinship between related files . For example a photo editing application may query a file. The kinship database component is employed to store data relating to the kinship of files stored on respective devices . Thus the kinship related data on each device is a partial view of the total kinship across the plurality of devices . In an example the kinship database component is a Structured Query Language SQL database. In a further embodiment similar to that mentioned above device may delegate determining the kinship of files stored on device to device . The repository surrogates component of device maintains the surrogate of the delegants device kinship data.

Several processes are described below including those shown in . These processes may be implemented in the architecture described herein or in other architectures. These processes are illustrated as a collection of blocks in a logical flow graph which represent a sequence of operations that can be implemented in hardware software or a combination thereof. In the context of software the blocks represent computer executable instructions that when stored on CRSM and executed by one or more processors perform the recited operations. Generally computer executable instructions include routines programs objects components data structures and the like that perform particular functions or implement particular abstract data types. The order in which the operations are described is not intended to be construed as a limitation and any number of the described blocks can be combined in any order and or in parallel to implement the process. For discussion purposes and not by way limitation the following processes are described with reference to the architectures of .

The bit level analysis and content level analysis are shown in sequence however in other implementations these operations may be performed in parallel. In another implementation the content level analysis may be performed sequentially before the bit level analysis . Additionally in some implementations a single analysis such as the bit level analysis or the content level analysis may be applied. The process may be configured such that results from the bit level analysis or content level analysis determine when the next operation is performed. For example the bit level analysis may be performed first and when the similarity of the bit level analysis is less than 1.0 the content level analysis may be performed. Likewise when the bit level analysis indicates a similarity of 1.0 the content level analysis may be omitted.

While the two similarity analysis processes of bit level analysis and content level analysis are described herein it is understood that other analysis and operations may be used to determine kinship including manual establishment of kinship. For example in some implementations users may manually connect disconnect or otherwise adjust and modify the similarity between nodes within the KDG. At a kinship is established between related files based on the strength of kinship.

At a kinship is established between related files based on the strength of kinship. At propagating updates to the first and second kinships the propagating comprising at establishing a connection between first device and second device . At common files are determined from files in common between first device and second device . At updating the first kinship for the common files on first device based on updates from second device . At updating the second kinship for the common files on the second device based on updates from the first device.

Although embodiments for determining kinship between electronic files among a network of multiple personal devices have been described in language specific to structural features and or methods it is to be understood that the subject of the claims is not necessarily limited to the specific features or methods described. Rather the specific features and methods are disclosed as exemplary implementations for determining kinship between electronic files among a network of multiple personal devices.

