---

title: Systems and methods for implementing pixel-based reverse engineering of interface structure
abstract: Systems and methods for implementing real-time pixel-based reverse engineering of interface structures are disclosed herein. The system uses the pixels representing widgets and content of a user interface to analyze, interpret, and/or enhance the interface without requiring cooperation from the interface. The system captures pixel data and reverse engineers the composition and structure of the interface from the captured pixel data. Using the reverse engineered interface, generated based on the captured pixel data, the facility can identify and record user interactions with the interface, modify the display of the interface to meet user requirements, preferences, or customization options, or enhance the interface to provide functionality not otherwise available, etc. The system can perform these processes across a variety of interfaces regardless of their underlying implementation and without any modifications to the interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09182981&OS=09182981&RS=09182981
owner: University of Washington
number: 09182981
owner_city: Seattle
owner_country: US
publication_date: 20101123
---
This application claims priority to U.S. Provisional Application No. 61 263 747 entitled IMPLEMENTING ADVANCED BEHAVIORS USING PIXEL BASED REVERSE ENGINEERING OF INTERFACE STRUCTURE filed Nov. 23 2009 and further claims priority to U.S. Provisional Application No. 61 317 152 entitled IMPLEMENTING ADVANCED BEHAVIORS USING PIXEL BASED REVERSE ENGINEERING OF INTERFACE STRUCTURE filed Mar. 24 2010 each of which is hereby incorporated by reference in their entirety.

A graphical user interface GUI an alternative to text based or other user interfaces allows a user to interact with a computer program through the use of images. A user may interact with a GUI using for example a mouse touch screen graphics pad etc. Over time GUIs have become the primary method through which users interact with computers. Many operating systems e.g. MICROSOFT WINDOWS MAC OS X user applications including productivity software gaming software education software etc. web sites and so on allow for user interaction through a GUI. GUIs are often implemented using a GUI toolkit such as the MICROSOFT Foundation Classes APPLE s Cocoa Swing Flash the X Windows System etc. These toolkits provide libraries of common frameworks or interactive widgets such as buttons context menus check boxes drop down lists radio buttons sliders icons tooltips tabs address bars windows dialog boxes layout managers and so on. The widgets provide a simple and easy way for the user to interact with the associated software.

GUIs and their associated toolkits are often difficult if not impossible to modify or customize by developers or users without access to the underlying code of the interface or toolkit. If a developer wants to add an unsupported widget to a toolkit or customize the graphical representation or behavior of a widget in a manner that is not supported by the toolkit the developer must integrate the changes into the existing code of the toolkit which may not be available to the developer. Similarly the addition of a new widget or functionality to an application requires access to the code of the application and or cooperation on behalf of the application i.e. an exposed API or plug in architecture through which the GUI of the application can be modified or customized in ways envisioned and supported by the developer of the application . Furthermore because each GUI and toolkit is implemented differently modifications and customizations can be tedious to implement and integrate into a single GUI or toolkit let alone every relevant GUI and toolkit.

The present disclosure is directed to a facility providing systems and methods for implementing real time pixel based reverse engineering of interface structures such as the structures of a graphical user interface. In some embodiments the interface interpretation facility uses the pixels representing widgets and content of an interface to analyze interpret and or enhance the interface without requiring cooperation from the interface. The system captures pixel data e.g. a bitmap image and reverse engineers the structure and composition of the interface from the captured pixel data. Using the reverse engineered interface generated based on the captured pixel data the facility can for example identify and record user interactions with the interface modify the display of the interface to meet user or device requirements e.g. security or display requirements preferences e.g. language translation or localization or customization options e.g. color or widget style choices enhance the interface to provide functionality not otherwise available or to remove undesired functionality apply a privacy filter to sensitive information annotating interfaces etc. The facility may also enhance the functionality provided by an API associated with the interface. For example an interface API may provide methods for manipulating a widget of the interface without providing methods for retrieving the graphical representation of the widget. The facility can enhance the API by providing pixel data corresponding to the graphical representation of the widget or a portion thereof. As another example the facility can expose a widget or capability that the API does not expose such as providing support for a new type of widget that the API does not support or the ability to disable specific widgets for security or other reasons. Thus without knowledge of or access to the underlying code and libraries associated with the interface the facility can analyze and interpret the interface and enhance the user s interaction with the interface. By accessing and analyzing pixel data the facility can perform these processes across a variety of interfaces regardless of their underlying tool kit or implementation and without any modifications to the interface.

In some embodiments the facility initially captures in real time pixel data corresponding to the interface. For example the facility may perform a screen capture of an interface or portion thereof or capture interface pixel data rendered off screen e.g. to a buffer prior to the display of the pixel data. The facility can capture the pixel data as a user interacts with a user interface to record analyze and or enhance the user s experience with the interface. The facility may perform its own interactions with or manipulations of the user interface to for example construct a widget hierarchy for the interface. As another example the facility may capture pixel data of an interface from a recording of the interface such as a user s interaction with the user interface. In this manner the facility can analyze an interface even though the interface may not be directly accessible to the facility. The facility can later use this information if the interface becomes accessible to the interface or can distribute the information to other computers where the interface might be available.

The facility detects the occurrences of interface widgets within the captured pixel data by scanning the pixel data for particular arrangements of pixels or features. For example the features may represent widget components such as an arrow of a spinner widget or a thumb of a slider widget. As another example the features may correspond to pixels that define in part the shape of the widget such as collection of pixels representative of a corner of a button widget.

After identifying the interface features within the pixel data the facility compares the identified features to widget prototypes of a prototype library. Each widget prototype describes the appearance of at least a portion of a widget as an arrangement of at least one feature. For example a button prototype may consist of one feature representing all of the pixels on the perimeter of the button or may consist of multiple features such as one feature representing pixels at each corner of the button. As another example a combo box prototype may consist of three features one feature representing an arrow component on one side of the prototype and a feature for each corner on the opposite side of the prototype. The facility may include prototypes that represent widgets in different configurations such as a disabled button prototype a currently selected button prototype an enabled but currently unselected button prototype and so on. Widget prototypes may also include a specification of an area or region of the prototype that may vary from widget to widget such as the area between corners of buttons of different lengths. For example the four feature button prototype described above may include four regions one region for each edge of the button and defining the color of pixels between the corresponding corner features. In this manner a single widget prototype can be used identify rectangular buttons regardless of their size. By detecting widgets within pixel data the facility can generate an interface widget tree to represent the structure and layout of the interface represented in the pixel data. The facility can analyze and alter the tree to monitor and maintain the state of the interface or pass the tree to an interface generation agent to recreate the interface.

The facility includes detect widgets component create prototype component enhance interface component and build tree component . Detect widget component detects widgets within pixel data provided to the component such as image data corresponding to a desktop a specific window on the desktop a dialog box and so on. Create prototype component generates widget prototypes that the facility uses to identify widgets within pixel data. Enhance interface component modifies captured interface pixel data to provide features and functionality that the interface itself does not provide. Build tree component builds an interface tree comprising separate nodes for interface elements within the captured pixel data. Interface includes any graphical interface having pixel data that is accessible via the user computer such as an interface provided by an operating system an application a web page a multimedia player or any other process a video recording of an interface an archive database or directory storing a collection of images of an interface. The user interface may be remote to the user computer and accessed via a network or another connection.

Prototype store stores widget prototypes. Each widget prototype specifies an arrangement of one or more features and regions. For example a prototype for a button may specify a color and position for each of a plurality of pixels at each corner of a button. The prototype store may store prototypes for widgets of multiple interfaces as different prototype libraries e.g. MICROSOFT WINDOWS 7 MICROSOFT WINDOWS CLASSIC APPLE MAC OS X . Widget prototypes may be created by end users interface developers application developers and so on. In some cases an interface provider may provide widget prototypes with an interface or provide widget prototypes for download.

Model store stores a library of widget models. Each widget model specifies at least one constraint to be imposed on a widget prototype such as overall shape distance between features and regions height width and shape of features height width and shape of patterns associated with regions etc. without specifying an arrangement of pixels for the features and or regions. For example a model may specify that a widget consists of four features arranged in a rectangle that each of the features consists of a four by four square of pixels. A model may also specify the order in which captured pixel data is assigned to features and regions of a widget prototype associated with the model.

Remote computer includes interface which may be accessible to the facility over network via a remote connection or desktop virtualization software. The facility can capture pixel data of interface in order to analyze and interpret the interface. Furthermore the facility may provide enhancements to interface . In this manner the facility can analyze interpret and enhance a user s experience with an interface regardless of the platform operating system application or process that provides the interface.

Server computer includes prototype store configured to store a library of widget prototypes accessible to the facility. For example prototype store may act as a repository from which users can download updated widget prototypes new widget prototypes e.g. widget prototypes corresponding to a new version of MICROSOFT WINDOWS APPLE OS X LINUX MICROSOFT WORD or MOZILLA FIREFOX widget prototypes for different interface themes or skins etc. Prototype store may be supplied and updated by a system administrator or by users through a collaborative environment or exchange of user provided content. Similarly server computer includes model store which may act as a repository for widget models accessible by other computers. User computer remote computer and server computer may be connected via network . In some embodiments the environment may include multiple user computers remote computers and or server computers .

The computing devices on which the facility is implemented may include a central processing unit memory input devices e.g. keyboard and pointing devices output devices e.g. display devices and storage devices e.g. disk drives . The memory and storage devices are computer readable media that may be encoded with computer executable instructions that implement the facility which means a computer readable medium that contains the instructions. In addition the instructions data structures and message structures may be stored in a data storage medium or transmitted via a data transmission medium such as a signal on a communication link and may be encrypted. Various communication links may be used such as the Internet a local area network a wide area network a point to point dial up connection a cell phone network and so on.

Embodiments of the facility may be implemented in and used with various operating environments that include personal computers server computers handheld or laptop devices multiprocessor systems microprocessor based systems virtualized computers programmable consumer electronics digital cameras network PCs minicomputers mainframe computers computing environments that include any of the above systems or devices and so on.

The facility may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures and so on that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

As another example is a display diagram illustrating a widget prototype for a slider widget in some embodiments. In this example the widget prototype includes three features and . Features and correspond to the left end and right end respectively of a bar or trough of slider . Feature corresponds to a slider thumb of slider . Each of regions correspond to repeating patterns of pixels between either end of the bar or trough of slider and the slider thumb which vary in size as the slider thumb slides either left or right.

In some embodiments the definitions of the features that the component attempts to detect may be provided to the system or may be generated by analyzing the widget prototypes available within a prototype library and identifying all features of those widget prototypes. The prototype library may be selected for example by comparing a sampling of features associated with each library to the captured pixel data by comparing a color distribution of the captured pixel data to known color distributions for various interfaces by a user etc. For each feature to be identified the component may compare every combination of pixels from the pixel data having the same size as the feature to pixels of the feature to determine whether the feature exists in the pixel data and if so where. Alternatively for each feature to be identified the component may choose a pixel as a hotspot and construct a decision tree for determining whether a collection of pixels in pixel data of an interface match any feature represented in the decision tree by traversing the decision tree using the hotspot as a starting point. Each internal node of the decision tree specifies a horizontal offset and a vertical offset relative to the hotspot each edge of the decision tree corresponds to the color at that offset and each leaf of the decision tree corresponds to a feature. Traversal of the decision tree to a leaf tests every pixel in a feature and indicates that the component has detected a feature within the provided pixel data. If an internal node lacks an edge corresponding to the color at the specified offset then traversal ends and the pixel to which the tree is currently being applied is not the hotspot of any feature. The decision tree can be stored and evaluated against interface pixel data to locate features at runtime. The hotspot for each feature and the offset at each internal node can be chosen arbitrarily. In other words different decision trees can be constructed for a feature or features from the same arrangement of pixels. In some embodiments the component may use advanced techniques to choose hotspots to minimize decision tree depth and the length of partial traversals. For example the component may first test the hotspot then choose the offset for each internal node that maximizes information gain. As another example when choosing a hotspot for each feature in the prototype library the component may choose a pixel of a color that is least common among features in the prototype library using the distribution of colors in the features as a proxy for the distribution of colors in interfaces . Alternatively the component may detect features in the pixel data by scanning through the pixel data and comparing each combination of pixels in the pixel data to each of the features to be identified. The component may require an exact match between features and pixels in the pixel data or may allow for some differences such as deviations in pixel color or pixel position.

In block the component identifies widget prototypes that will be used to identify widgets in the pixel data by for example identifying the widget prototypes that include any of the identified features in the pixel data. In blocks the component loops through each of the identified widget prototypes and compares them to the pixel data to determine whether corresponding widgets exist in the pixel data. In block the component selects the next identified widget prototype. In decision block if the component has already selected the widget prototype the component returns the stored widget information and completes else the component continues at block . In decision block if the selected widget prototype matches a combination of identified features within the pixel data based on the features of the widget prototype and any constraints of the widget model associated with the selected widget prototype then the component continues at block else the component loops back to block to select the next identified widget prototype. For example if the component identifies four corner features corresponding to four different corners of a button but that are not in the shape of rectangle the component may reject the combination. As another example if the component identifies a slider thumb feature a slider trough left end feature and a slider trough right end feature that are in line the component may indicate that a slider widget may have been observed.

In decision block if the selected widget prototype contains one or more regions then the component continues at decision block else the component continues at block . In decision block if the corresponding pixels of the pixel data match regions of the selected widget prototype then the component continues at block else the component loops back to block to select the next identified widget prototype. Each region corresponds to a set of pixels in an area of variable size. For example while the arrangement of pixels at each corner of a particular type of button may remain relatively constant regardless of the size of the button the edges of the button may change in length as the size of the button changes. Thus rather than specifying a separate widget prototype for every button of different sizes a single widget prototype can specify a region to account for portions of the widget that can vary in size. In some embodiments each region includes a procedural definition for generating a set of pixels in an area of a variable size e.g. painting a repeating pixel a repeating pattern of pixels or a gradient . By way of example the widget prototype of specifies a region for painting each edge of button as a repeating pixel. If for example the component identifies four corner features corresponding to four different corners of a button but that do not include a repeating pixel connecting the corner features along each edge the component may reject the combination. As another example if the component identifies a slider thumb feature a slider trough left end feature and a slider trough right end feature that are in line but does not identify a repeating pattern of pixels between the thumb and the ends of the trough the component may reject the combination.

In block a widget corresponding to the selected widget prototype has been identified and the component stores information pertaining to the identified widget such as its type e.g. slider button combo box style e.g. MICROSOFT WINDOWS VISTA SWING Abstract Windows Toolkit AWT MAC OS X location state e.g. currently visible enabled disabled associated metadata e.g. the number of times a user has clicked on or otherwise interacted with the widget pixel data etc. In some embodiments the component may associate the identified widget with code that can be invoked to interact with the identified widget such as a function for simulating a user clicking a button adjusting a slider etc. The component then loops back to decision block to determine whether the selected widget prototype matches other combinations of identified features. In some embodiments the component may also store annotations or metadata pertaining to the pixel data as a whole such as keywords located within the interface that the facility can index and use to search e.g. searching a video for portions relevant to a particular keyword the date and time on which the pixel data was analyzed the name of the user that caused the analysis to be performed etc.

In block the component identifies based on the selected model pixels corresponding to features of the prototype. For example the model may specify that the prototype include four features one for each corner and that each of these features should have a height and width of four pixels each. In this example the component would identify the four by four pixel squares at each corner of the identified pixels as corner features of the prototype. As another example the model may specify that the five rightmost columns of pixels correspond to a feature of the prototype. In some embodiments pixels of the identified pixel area are assigned to features and regions by a search minimizing the number of pixels to satisfy the associated model.

In decision block if the identified feature pixels satisfy constraints of the selected model then the component continues at block else the component continues at block . For example the selected model may specify four by four pixel blocks for each corner of the prototype and further specify that the corner features must not overlap. If the identified pixel area is fewer than eight pixels in height or width then the identified pixel area cannot satisfy the model constraints. In block the component prompts the user and then returns to block to receive user input. For example the component may notify the user of an error prompt the user to select additional or alternative pixel data from the received pixel data or to select a different model. In block the component identifies based on the associated model pixels corresponding to features of the prototype. For example the model may specify for each edge a repeating pattern of pixels having a width or height of two pixels. In this example the component would identify for each edge of the prototype the two pixel wide or high pattern corresponding to each edge using for example a branch and bound search algorithm. In decision block if the identified region pixels satisfy constraints of the selected model then the component continues at block else the component continues at block . For example if the selected model specifies that a widget prototype is to have a three pixel wide repeating pattern from corner to corner on the left and right sides of a widget prototype and the identified pixel area only includes a repeating pattern of two pixels on the left and right sides the identified pixel area cannot satisfy the model constraints.

In some examples the component may match multiple candidate prototypes to an identified pixel area and select a prototype from this set of candidate prototypes based on a cost value associated with each prototype. is a display diagram illustrating costs associated with multiple candidate prototypes for an identified pixel area in some embodiments. In this example each of widget prototypes and match pixel area which is representative of a button widget without content. Typically the component will select the candidate prototype with the lowest model cost or the fewest pixels used to represent the appearance of the features and regions within the identified pixel area. In this example the features and regions within candidate prototype include 57 pixels nine pixels for each of the four corner features one pixel for the top and bottom edge regions two pixels for the left and right edge regions and 15 pixels for the center content region. Accordingly candidate prototype has a model cost of 57 pixels. Candidate prototype has a model cost of 42 pixels while candidate prototype has a model cost of 55 pixels. Thus candidate prototype is the candidate prototype with the lowest model cost.

In some embodiments the component may account for widgets having unpredictable content such pixel area representative of a button widget with text using a content cost. The content cost is the number of pixels in the identified pixel area that do not match the candidate prototype. For example candidate prototype matches pixel area at the corners along one pixel wide edges at the top and bottom of the pixel area along two pixel wide edges at the left and right sides of the pixel area and at every location within the pixel area that does not represent text. Thus the content cost associated with pixel area and candidate prototype is equivalent to the number of pixels representing the text in pixel area or pixels. As another example candidate prototype matches pixel area at the corners and along each edge but does not match in the interior sections resulting in a content cost of 1199 pixels. Candidate prototype which is similar to candidate prototype but has one pixel wide regions on its left and right sides as opposed to the two pixel wide regions on the left and right sides of candidate prototype does not match the pixels of pixel area that represent text and along one pixel wide columns on the left and right sides. In some embodiments the component may select the candidate prototype for a selected pixel area that has the lowest combined model and content cost. In the example of candidate prototype has the lowest combined cost. Alternatively the component may use a weighted sum of the model and content costs or may use the model cost and content costs individually or as part of a larger decision process.

In block the component stores the prototype as an arrangement of the identified feature pixels and region pixels and then completes.

In some embodiments the facility may identify content within the interface that does not match any feature or region of the available widget prototypes. For example a button may contain unpredictable text or an image that is not represented in a corresponding widget prototype. As another example a widget may contain another widget associated with a widget prototype to which the facility does not have access. The facility may automatically generate a widget prototype for an unidentified widget by comparing unmatched pixels to available widget models and upon finding a match storing the corresponding pixels as features and or regions of a new widget prototype. In this manner the facility can dynamically adapt to the presence of new widgets within an interface. Alternatively the facility may pass the pixels to a computer having a central repository of widget prototypes and widget models for further analysis and feature region matching.

In block the component captures pixel data associated with an interface. For example the component may perform a screen capture of a window or other interface component or may access a buffer storing interface pixel data. In decision block if the interface has not changed since pixel data of the interface was last captured then the component continues at block to modify pixel data else the component continues at block . In block the component passes the captured pixel data to a detect widgets component to detect the widgets represented in the pixel data. In block the component modifies the pixel data such as if the interface or some other input to the enhancement has changed. The modifications to the pixel data may represent user customization options e.g. how widgets are drawn shape size color position font preferences color preferences security features e.g. representing widgets as disabled or not rendering the widgets that a user is not permitted to access or adjust and ignoring any user input directed to those widgets additional interface widgets and so on. For example the component may replace all instances of a particular slider such as slider with pixel data representative of another style of slider such as such as slider to implement a user s customization preferences. As another example the component may replace the pixel data corresponding to just the thumb of a slider. Alternatively the component may replace the slider with an entirely different type of widget such as a text box widget or spinner widget where a user can enter a value corresponding to a particular slider location. As another example the component may identify content in one language and modify the corresponding pixel data to represent the content in another language.

In some examples the component may introduce additional functionality to the interface through the modification of pixel data. For example the component may add pixel data representative of a Favorites tab to a tab widget. Although the Favorites tab does not actually exist in the interface the user perceives the Favorites tab when the modified pixel data is displayed. When the user clicks on the pixel data representing the Favorites tab the component can access the interface widgets that the user most commonly uses or that the user has specified as being his favorite and add pixel data representing each of these widgets to the pixel data for display. In some cases the user s favorite widgets may exist in different tabs dialog boxes panels etc. Accordingly the component may access pixel data for each of these interface elements which may require manipulation of the underlying interface capture the appropriate pixel data and display the pixel data on the Favorites tab. This manipulation of the underlying interface to acquire appropriate pixel data may be completely hidden from the user if the underlying interface is hidden from the user in favor of the enhanced interface. In this manner manipulations of an underlying interface need not be strictly synchronous with the display of an enhanced version of the interface.

As another example the component can perform several manipulations of widgets within an interface observe the results of each of these manipulations or a series of combinations of manipulations and present an indication of these results to a user for selection. When the user selects an indication the facility can perform the associated manipulations to place the interface in the desired state. For example a user may wish to edit a photo in PHOTOSHOP using a mosaic paintbrush but not know which mosaic cell size to use to obtain the desired effect. The facility can manipulate the PHOTOSHOP interface to select mosaic cell sizes of for example 5 8 13 15 and 20 perform the mosaic edit operation for each cell size capture the five resulting images and present the captured images to the user. Upon selection by a user of one of the images the facility can manipulate the interface accordingly to produce the desired image. One skilled in the art will appreciate that the component can based on the captured pixel data of the interface and the detected widgets therein enhance the interface by modifying corresponding pixel data in any of a number of ways to alter the user s experience.

In block the component displays the modified pixel data. In decision block if the component receives user input then the component continues at block else the component loops back to block to capture pixel data of the interface such as the entire interface or the pixels that have changed since the interface was last captured.

In block the component maps the received input to a widget of the interface. For example the component may determine location coordinates associated with the user input determine whether a widget is displayed at that location in the enhanced interface and if so identify the corresponding widget of the interface. In block the component sends the input to the interface. For example the component may send an indication of the input e.g. click drag keyboard input and an indication of the widget to the process providing the interface. As another example the component may synthetically perform the appropriate action on the interface such as by causing a slider of the interface to move from one position to another based on user input received at the pixel data corresponding to the slider in the modified pixel data of the enhanced interface or by injecting code into a window associated with the interface to perform a desired action. As another example the component can manipulate multiple widgets in the interface and represent these changes as a modification to a single widget in the enhanced interface. As another example the component may automatically manipulate widgets within the interface and observe the effects of these manipulations and present a summary of these observations for the purpose of software testing scripting support macro execution or interface mashup support. For example the component may manipulate widgets corresponding to contrast and brightness values of an interface provided by image editing software observe the changes to an image caused by these manipulations and then display the results to a user for selection. The component then loops back to block to capture pixel data of the interface such as the entire interface or the pixels that have changed since the interface was last captured.

In block the component adds the created widget nodes as children nodes of containing widget nodes. For example the component can determine for each detected widget which widget contains the detected widget based on the pixels associated with the widgets and add the node for that widget as a child node of the containing widget s node. Widgets can be nested such that a widget is contained by more than one other widget. Accordingly the component may determine the appropriate structure for nested widgets based on the nesting relationship between the widgets. In some cases widgets including floating widgets may not be contained by another widget. Nodes for these widgets may be added as children nodes of the root node.

In block the component identifies content within each widget and then completes. In some embodiments the component identifies content using a post order traversal of the nodes. At each node the component tests pixels for content by comparing the pixels against a background color or content region associated with a corresponding widget prototype and then marks pixels as tested. Detected content such as text and image an unknown widget etc. is interpreted and added as a child node of the node at which the content was detected. In some embodiments the component does not check pixels that are marked as tested at subsequently analyzed nodes in order to avoid content being represented as a child node of multiple nodes. In this manner each widget and detected content is identifiable via a unique path of nodes. In some embodiments the component may assign a unique identifier to each node created for the widgets and detected content. Although in this example the relationship between the widgets is described as a tree one skilled in the art will understand that any data structure can be used to maintain the relationships or hierarchical structure between widgets such as a graph list array etc. In some embodiments the component may extract at least a portion of the structure of an interface from an API associated with the interface such as an accessibility API or a Document Object Model associated with a web page providing an interface.

In some embodiments a tree associated with an interface may change as a user or the facility interacts with the interface. For example as a user selects different tab panels from a tab widget a new branch of nodes corresponding to the selected tab panel may be constructed and added to the tree. Alternatively a tree for the entire interface may be constructed when a new portion of the interface is presented. The new tree and any other previously created trees for the interface can then be merged to form a more detailed tree for the interface. Furthermore as a user interacts with the interface widgets and content of the interface may become obscured or occluded. A widget or content may be occluded because for example it is currently covered by a modal dialog box the portion of the interface containing that widget or content has been closed e.g. a dialog box or window or hidden from view e.g. a tab panel of a tab widget that is not currently selected or a widget that has been occluded by a dropdown list . The facility may mark nodes of the tree representing hidden or occluded widgets or content as such so that the facility is aware that those portions of the interface are not currently visible when the facility needs to represent the interface or interact with the interface. In order to access occluded widgets or content the facility may store navigational commands that the facility can use to reach the occluded widget or content or cause the occluded widget or content to be displayed based on for example the cause of the occlusion. For example if a widget is occluded because it is contained by a non selected tab panel of a tab widget the facility may force the selection of the appropriate tab panel so that the widget becomes visible. As another example if content is occluded by a dialog box or dropdown list the facility may close the occluding dialog box or dropdown list. As another example the facility may navigate through a series of nested menus to cause the display of a widget contained by an interface widget that is currently closed.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims. Accordingly the disclosure is not limited except as by the appended claims.

