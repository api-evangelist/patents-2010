---

title: Rolling texture context data structure for maintaining texture data in a multithreaded image processing pipeline
abstract: A multithreaded rendering software pipeline architecture utilizes a rolling texture context data structure to store multiple texture contexts that are associated with different textures that are being processed in the software pipeline. Each texture context stores state data for a particular texture, and facilitates the access to texture data by multiple, parallel stages in a software pipeline. In addition, texture contexts are capable of being “rolled”, or copied to enable different stages of a rendering pipeline that require different state data for a particular texture to separately access the texture data independently from one another, and without the necessity for stalling the pipeline to ensure synchronization of shared texture data among the stages of the pipeline.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08405670&OS=08405670&RS=08405670
owner: International Business Machines Corporation
number: 08405670
owner_city: Armonk
owner_country: US
publication_date: 20100525
---
The invention is generally related to data processing and in particular to graphical imaging processing and rendering.

The process of rendering two dimensional images from three dimensional scenes is commonly referred to as image processing. As the modern computer industry evolves image processing evolves as well. One particular goal in the evolution of image processing is to make two dimensional simulations or renditions of three dimensional scenes as realistic as possible. One limitation of rendering realistic images is that modern monitors display images through the use of pixels.

A pixel is the smallest area of space which can be illuminated on a monitor. Most modern computer monitors will use a combination of hundreds of thousands or millions of pixels to compose the entire display or rendered scene. The individual pixels are arranged in a grid pattern and collectively cover the entire viewing area of the monitor. Each individual pixel may be illuminated to render a final picture for viewing.

One technique for rendering a real world three dimensional scene onto a two dimensional monitor using pixels is called rasterization. Rasterization is the process of taking a two dimensional image represented in vector format mathematical representations of geometric objects within a scene and converting the image into individual pixels for display on the monitor. Rasterization is effective at rendering graphics quickly and using relatively low amounts of computational power however rasterization suffers from several drawbacks. For example rasterization often suffers from a lack of realism because it is not based on the physical properties of light rather rasterization is based on the shape of three dimensional geometric objects in a scene projected onto a two dimensional plane. Furthermore the computational power required to render a scene with rasterization scales directly with an increase in the complexity of the scene to be rendered. As image processing becomes more realistic rendered scenes also become more complex. Therefore rasterization suffers as image processing evolves because rasterization scales directly with complexity.

Several alternative techniques rendering a real world three dimensional scene onto a two dimensional monitor using pixels have been developed based upon more realistic physical modeling. One such physical rendering technique is called ray tracing. The ray tracing technique traces the propagation of imaginary rays rays which behave similar to rays of light into a three dimensional scene which is to be rendered onto a computer screen. The rays originate from the eye s of a viewer sitting behind the computer screen and traverse through pixels which make up the computer screen towards the three dimensional scene. Each traced ray proceeds into the scene and may intersect with objects within the scene. If a ray intersects an object within the scene properties of the object and several other contributing factors are used to calculate the amount of color and light or lack thereof the ray is exposed to. These calculations are then used to determine the final color of the pixel through which the traced ray passed.

The process of tracing rays is carried out many times for a single scene. For example a single ray may be traced for each pixel in the display. Once a sufficient number of rays have been traced to determine the color of all of the pixels which make up the two dimensional display of the computer screen the two dimensional synthesis of the three dimensional scene can be displayed on the computer screen to the viewer.

Ray tracing typically renders real world three dimensional scenes with more realism than rasterization. This is partially due to the fact that ray tracing simulates how light travels and behaves in a real world environment rather than simply projecting a three dimensional shape onto a two dimensional plane as is done with rasterization. Therefore graphics rendered using ray tracing more accurately depict on a monitor what our eyes are accustomed to seeing in the real world.

Furthermore ray tracing also handles increases in scene complexity better than rasterization as scenes become more complex. Ray tracing scales logarithmically with scene complexity. This is due to the fact that the same number of rays may be cast into a scene even if the scene becomes more complex. Therefore ray tracing does not suffer in terms of computational power requirements as scenes become more complex as rasterization does.

One major drawback of ray tracing however is the large number of calculations and thus processing power required to render scenes. This leads to problems when fast rendering is needed. For example when an image processing system is to render graphics for animation purposes such as in a game console. Due to the increased computational requirements for ray tracing it is difficult to render animation quickly enough to seem realistic realistic animation is approximately twenty to twenty four frames per second .

With continued improvements in semiconductor technology in terms of clock speed and increased use of parallelism however rasterization becomes viable for more complex images and real time rendering of scenes using physical rendering techniques such as ray tracing becomes a more practical alternative to rasterization. At the chip level multiple processor cores are often disposed on the same chip functioning in much the same manner as separate processor chips or to some extent as completely separate computers. In addition even within cores parallelism is employed through the use of multiple execution units that are specialized to handle certain types of operations. Hardware based pipelining is also employed in many instances so that certain operations that may take multiple clock cycles to perform are broken up into stages enabling other operations to be started prior to completion of earlier operations. Multithreading is also employed to enable multiple instruction streams to be processed in parallel enabling more overall work to performed in any given clock cycle.

Irrespective of whether raster based or physical rendering is performed to render image data for a scene the increased use of parallelism presents some challenges with respect to maintaining a coherent state in a parallelized multithreaded architecture. As an example conventional graphics software Application Programming Interfaces API s which are the libraries of routines that are called by application programs to control the rendering process e.g. OpenGL and DirectX are not specifically designed to manage state data in a multithreaded environment. Single threaded graphics code from the perspective of an application program assumes a single coherent state for each operation and as such conventional graphics software API s typically expect function call execution to remain in order which in turn requires intermixed state variables function calls and drawing function calls to remain in order.

As an example a single threaded application program might make the following function calls when drawing a primitive 

In this code each vertex of a triangle which is defined by the glVertex3f function call is set to a different color by virtue of the preceding glColor function call. The first vertex is thus set to green the second vertex is set to blue and the third vertex is set to red.

In a single threaded hardware environment processing of the aforementioned code is presents no coherency problems as the first vertex will be defined after the color is set to green and the second vertex will be defined after the color has been changed to blue as a result of the preceding glColor function call. The change in state from a vertex color of green to a vertex color of blue is ensured as a result of the serial processing of the function calls in the code.

In a multithreaded hardware environment however it may be desirable to enable different function calls to be handled in parallel hardware threads to increase overall throughput desirably without requiring any specific thread management from an application program. Based on thread workload however the order in which certain function calls are completed in different threads may not be guaranteed resulting in potential coherency issues.

As a consequence in the aforementioned code the use of parallelization may provide the opportunity to define each vertex for the primitive in separate threads thus shortening the time required to define the primitive. The vertex color however represents a shared state or context since setting the color with a glColor function call sets the color used for all subsequent function calls until the color is changed by another glColor function call. Steps therefore must be taken to ensure for example that the vertex color applied to each vertex is correct according to the function calls issued by the application program. Otherwise as an example the second glColor function call that changes the vertex color from green to blue could potentially change the vertex color before the first vertex is defined by the first glVertex function call resulting in the first vertex being set to the wrong color.

Similarly it has been found that managing texture data can be difficult in a multithreaded hardware environment and that the retrieval of such data can become a performance bottleneck that limits throughput in a rendering pipeline.

While synchronization may be used to serialize operations to maintain coherent state doing so limits the potential performance gains that could otherwise be obtained as a result of parallelization particularly if a certain thread is required to wait for other threads to reach certain points before that thread is able to proceed. A need therefore exists in the art for an improved manner of maintaining coherent state and texture data in a multithreaded graphics processing architecture.

The invention addresses these and other problems associated with the prior art by providing a multithreaded rendering software pipeline architecture that utilizes a rolling texture context data structure to store multiple texture contexts that are associated with different textures that are being processed in the software pipeline. Each texture context stores state data for a particular texture and facilitates the access to texture data by multiple parallel stages in a software pipeline. In addition texture contexts are capable of being rolled or copied to enable different stages of a rendering pipeline that require different state data for a particular texture to separately access the texture data independently from one another and without the necessity for stalling the pipeline to ensure synchronization of shared texture data among the stages of the pipeline.

Therefore consistent with one aspect of the invention a circuit arrangement includes hardware logic configured to host a multithreaded rendering software pipeline using a plurality of parallel threads of execution the multithreaded rendering software pipeline including a plurality of stages configured to perform work in connection with rendering an image in a buffer. The circuit arrangement also includes a rolling texture context data structure accessible by the plurality of stages in the multithreaded rendering software pipeline the rolling texture context data structure configured to store a plurality of texture contexts each texture context configured to enable access to at least one texture and each texture context further configured to store state data for the at least one texture as work is being performed by the plurality of stages of the multithreaded rendering software pipeline the plurality of texture contexts including a first texture context used to perform first work with a first texture in the multithreaded rendering software pipeline. The circuit arrangement also includes control logic configured to in response to an attempt to modify the first texture context in connection with performing second work with the first texture in the multithreaded rendering software pipeline copy the first texture context to a second texture context and modify the second context such that the first and second work with the first texture are respectively performed in the multithreaded software pipeline using the first and second texture contexts.

These and other advantages and features which characterize the invention are set forth in the claims annexed hereto and forming a further part hereof. However for a better understanding of the invention and of the advantages and objectives attained through its use reference should be made to the Drawings and to the accompanying descriptive matter in which there is described exemplary embodiments of the invention.

Embodiments consistent with the invention utilize a multithreaded rendering software pipeline architecture with a rolling texture context data structure that is used to store multiple texture contexts that are associated with different textures that are being utilized by the software pipeline. Each texture context stores state data for a particular texture including either the texture image data itself or a pointer to the texture image data e.g. as may be stored in a cache. The usage of texture data and a coherent state therefor is maintained throughout multiple parallel stages of a rendering pipeline. Furthermore a rolling data structure is utilized to enable earlier of a rendering pipeline to modify the state for a particular texture context when performing work therewith out corrupting the state or otherwise requiring synchronization with the state seen by other stages of the rendering pipeline when performing other work with the associated texture.

Existing graphics software API s such as OpenGL expect function call execution to remain in order. Therefore intermixed state variables function calls and drawing function calls must remain in order. However maintaining such order is challenging when trying to parallelize existing single threaded graphics code.

Therefore consistent with the invention a rolling texture context data structure is used to enable high throughput in a highly threaded graphics API thereby enabling conventional single threaded graphics algorithms to realize the full potential of multithreaded architectures.

A texture context is typically associated with a texture to be used in rendering an image and is used to maintain a coherent state for the texture as an image is rendered using multiple parallel stages of a software pipeline. In some respects a texture context is similar to a render context e.g. as disclosed in U.S. patent application Ser. No. 12 046 573 filed by the same inventors as for the instant application published as U.S. Pub. No. 2009 0231349 and assigned to the same assignee as the instant application which is incorporated by reference herein. Unlike a render context however which is primarily used to enable state data to be shared between different stages along a software rendering pipeline and minimizing latency in frame to frame transitions a texture context facilitates parallelization of rendering stages in a pipeline and texture caching. In addition a texture context can cross phases e.g. for frames that share the same texture data.

A texture context is typically not streamed between stages of a pipeline but is instead retained in a shared memory that is accessible by the stages of the pipeline that require access to texture data. Moreover when texture data needs to be changed for certain work being performed with the associated texture while other work is being performed by other stages or instances of stages the texture context is rolled by copying the texture context and maintaining the original texture context for the stages that are processing the other work. The original texture context may then be discarded upon completion of the other work with processing of the current work proceeding with the copied texture context. In contrast with conventional pipeline architectures a change to texture data would typically require a pipeline to be stalled until processing of the work that relies on such data was completed whereby the texture data could then be changed for the upcoming work. For example in some instances stages processing different frame or stage instances processing different regions of a scene in the same frame may require different state date associated with a texture. Thus the work performed in connection with the different stages or stage instances can be performed concurrently using different texture contexts as appropriate.

In addition in contrast with conventional pipeline architectures where texture data is treated as global shared data the use of rolling texture contexts enables texture data to be partitioned for individual use by different hardware threads enabling those hardware threads to locally cache the texture data they require to perform their local operations. Doing so reduces thrashing in the local caches for the hardware threads or the cores within which such threads reside since changes to texture data for one thread would not necessarily be required to be propagated to other threads that use the same texture data.

The state data that may be maintained in a texture context typically includes any information that a stage in a rendering pipeline requires to effectively use an associated texture as well as additional information that may be required to manage the rolling texture context data structure e.g. by a Host Interface Processor HIP discussed supra . For example the state data may include the actual image data for a texture or alternatively a pointer to a location in memory where the image data is stored or an offset in a texture cache. If a texture is procedure based the texture context may alternatively include the code for the procedure or a pointer to the same. A texture context may also include state data such as a color map mode or other information describing the associated texture algorithm selection information such as anti aliasing information. Additional state data that may be maintained in a texture context for the purposes of managing the data structure includes an identifier to uniquely identify the context an in use indicator a cached indicator that indicates whether the associated texture is currently cached tracking information such as a least recently used LRU indicator that may be used to manage texture contexts. This list is not exhaustive and as such the invention should not be limited to the particular attributes described herein.

Other variations and modifications will be apparent to one of ordinary skill in the art. Therefore the invention is not limited to the specific implementations discussed herein.

Now turning to the drawings wherein like numbers denote like parts throughout the several views illustrates exemplary automated computing machinery including an exemplary computer useful in data processing consistent with embodiments of the present invention. Computer of includes at least one computer processor or CPU as well as random access memory RAM which is connected through a high speed memory bus and bus adapter to processor and to other components of the computer .

Stored in RAM is an application program a module of user level computer program instructions for carrying out particular data processing tasks such as for example word processing spreadsheets database operations video gaming stock market simulations atomic quantum process simulations or other user level applications. Also stored in RAM is an operating system . Operating systems useful in connection with embodiments of the invention include UNIX Linux Microsoft Windows XP AIX IBM s i5 OS and others as will occur to those of skill in the art. Operating system and application in the example of are shown in RAM but many components of such software typically are stored in non volatile memory also e.g. on a disk drive .

As will become more apparent below embodiments consistent with the invention may be implemented within Network On Chip NOC integrated circuit devices or chips and as such computer is illustrated including two exemplary NOCs a video adapter and a coprocessor . NOC video adapter which may alternatively be referred to as a graphics adapter is an example of an I O adapter specially designed for graphic output to a display device such as a display screen or computer monitor. NOC video adapter is connected to processor through a high speed video bus bus adapter and the front side bus which is also a high speed bus. NOC Coprocessor is connected to processor through bus adapter and front side buses and which is also a high speed bus. The NOC coprocessor of may be optimized for example to accelerate particular data processing tasks at the behest of the main processor .

The exemplary NOC video adapter and NOC coprocessor of each include a NOC including integrated processor IP blocks routers memory communications controllers and network interface controllers the details of which will be discussed in greater detail below in connection with . The NOC video adapter and NOC coprocessor are each optimized for programs that use parallel processing and also require fast random access to shared memory. It will be appreciated by one of ordinary skill in the art having the benefit of the instant disclosure however that the invention may be implemented in devices and device architectures other than NOC devices and device architectures. The invention is therefore not limited to implementation within an NOC device.

Computer of includes disk drive adapter coupled through an expansion bus and bus adapter to processor and other components of the computer . Disk drive adapter connects non volatile data storage to the computer in the form of disk drive and may be implemented for example using Integrated Drive Electronics IDE adapters Small Computer System Interface SCSI adapters and others as will occur to those of skill in the art. Non volatile computer memory also may be implemented for as an optical disk drive electrically erasable programmable read only memory so called EEPROM or Flash memory RAM drives and so on as will occur to those of skill in the art.

Computer also includes one or more input output I O adapters which implement user oriented input output through for example software drivers and computer hardware for controlling output to display devices such as computer display screens as well as user input from user input devices such as keyboards and mice. In addition computer includes a communications adapter for data communications with other computers and for data communications with a data communications network . Such data communications may be carried out serially through RS 232 connections through external buses such as a Universal Serial Bus USB through data communications data communications networks such as IP data communications networks and in other ways as will occur to those of skill in the art. Communications adapters implement the hardware level of data communications through which one computer sends data communications to another computer directly or through a data communications network. Examples of communications adapters suitable for use in computer include modems for wired dial up communications Ethernet IEEE 802.3 adapters for wired data communications network communications and 802.11 adapters for wireless data communications network communications.

For further explanation sets forth a functional block diagram of an example NOC according to embodiments of the present invention. The NOC in is implemented on a chip that is on an integrated circuit. NOC includes integrated processor IP blocks routers memory communications controllers and network interface controllers grouped into interconnected nodes. Each IP block is adapted to a router through a memory communications controller and a network interface controller . Each memory communications controller controls communications between an IP block and memory and each network interface controller controls inter IP block communications through routers .

In NOC each IP block represents a reusable unit of synchronous or asynchronous logic design used as a building block for data processing within the NOC. The term IP block is sometimes expanded as intellectual property block effectively designating an IP block as a design that is owned by a party that is the intellectual property of a party to be licensed to other users or designers of semiconductor circuits. In the scope of the present invention however there is no requirement that IP blocks be subject to any particular ownership so the term is always expanded in this specification as integrated processor block. IP blocks as specified here are reusable units of logic cell or chip layout design that may or may not be the subject of intellectual property. IP blocks are logic cores that can be formed as ASIC chip designs or FPGA logic designs.

One way to describe IP blocks by analogy is that IP blocks are for NOC design what a library is for computer programming or a discrete integrated circuit component is for printed circuit board design. In NOCs consistent with embodiments of the present invention IP blocks may be implemented as generic gate netlists as complete special purpose or general purpose microprocessors or in other ways as may occur to those of skill in the art. A netlist is a Boolean algebra representation gates standard cells of an IP block s logical function analogous to an assembly code listing for a high level program application. NOCs also may be implemented for example in synthesizable form described in a hardware description language such as Verilog or VHDL. In addition to netlist and synthesizable implementation NOCs also may be delivered in lower level physical descriptions. Analog IP block elements such as SERDES PLL DAC ADC and so on may be distributed in a transistor layout format such as GDSII. Digital elements of IP blocks are sometimes offered in layout format as well. It will also be appreciated that IP blocks as well as other logic circuitry implemented consistent with the invention may be distributed in the form of computer data files e.g. logic definition program code that define at various levels of detail the functionality and or layout of the circuit arrangements implementing such logic. Thus while the invention has and hereinafter will be described in the context of circuit arrangements implemented in fully functioning integrated circuit devices and data processing systems utilizing such devices those of ordinary skill in the art having the benefit of the instant disclosure will appreciate that circuit arrangements consistent with the invention are capable of being distributed as program products in a variety of forms and that the invention applies equally regardless of the particular type of computer readable or signal bearing media being used to actually carry out the distribution. Examples of computer readable or signal bearing media include but are not limited to physical recordable type media such as volatile and non volatile memory devices floppy disks hard disk drives CD ROMs and DVDs among others and transmission type media such as digital and analog communication links.

Each IP block in the example of is adapted to a router through a memory communications controller . Each memory communication controller is an aggregation of synchronous and asynchronous logic circuitry adapted to provide data communications between an IP block and memory. Examples of such communications between IP blocks and memory include memory load instructions and memory store instructions. The memory communications controllers are described in more detail below with reference to . Each IP block is also adapted to a router through a network interface controller which controls communications through routers between IP blocks . Examples of communications between IP blocks include messages carrying data and instructions for processing the data among IP blocks in parallel applications and in pipelined applications. The network interface controllers are also described in more detail below with reference to .

Routers and the corresponding links therebetween implement the network operations of the NOC. The links may be packet structures implemented on physical parallel wire buses connecting all the routers. That is each link may be implemented on a wire bus wide enough to accommodate simultaneously an entire data switching packet including all header information and payload data. If a packet structure includes 64 bytes for example including an eight byte header and 56 bytes of payload data then the wire bus subtending each link is 64 bytes wide 512 wires. In addition each link may be bi directional so that if the link packet structure includes 64 bytes the wire bus actually contains 1024 wires between each router and each of its neighbors in the network. In such an implementation a message could include more than one packet but each packet would fit precisely onto the width of the wire bus. In the alternative a link may be implemented on a wire bus that is only wide enough to accommodate a portion of a packet such that a packet would be broken up into multiple beats e.g. so that if a link is implemented as 16 bytes in width or 128 wires a 64 byte packet could be broken into four beats. It will be appreciated that different implementations may used different bus widths based on practical physical limits as well as desired performance characteristics. If the connection between the router and each section of wire bus is referred to as a port then each router includes five ports one for each of four directions of data transmission on the network and a fifth port for adapting the router to a particular IP block through a memory communications controller and a network interface controller.

Each memory communications controller controls communications between an IP block and memory. Memory can include off chip main RAM memory connected directly to an IP block through a memory communications controller on chip memory enabled as an IP block and on chip caches. In NOC either of the on chip memories for example may be implemented as on chip cache memory. All these forms of memory can be disposed in the same address space physical addresses or virtual addresses true even for the memory attached directly to an IP block. Memory addressed messages therefore can be entirely bidirectional with respect to IP blocks because such memory can be addressed directly from any IP block anywhere on the network. Memory on an IP block can be addressed from that IP block or from any other IP block in the NOC. Memory attached directly to a memory communication controller can be addressed by the IP block that is adapted to the network by that memory communication controller and can also be addressed from any other IP block anywhere in the NOC.

NOC includes two memory management units MMUs illustrating two alternative memory architectures for NOCs consistent with embodiments of the present invention. MMU is implemented within an IP block allowing a processor within the IP block to operate in virtual memory while allowing the entire remaining architecture of the NOC to operate in a physical memory address space. MMU is implemented off chip connected to the NOC through a data communications port . The port includes the pins and other interconnections required to conduct signals between the NOC and the MMU as well as sufficient intelligence to convert message packets from the NOC packet format to the bus format required by the external MMU . The external location of the MMU means that all processors in all IP blocks of the NOC can operate in virtual memory address space with all conversions to physical addresses of the off chip memory handled by the off chip MMU .

In addition to the two memory architectures illustrated by use of the MMUs data communications port illustrates a third memory architecture useful in NOCs capable of being utilized in embodiments of the present invention. Port provides a direct connection between an IP block of the NOC and off chip memory . With no MMU in the processing path this architecture provides utilization of a physical address space by all the IP blocks of the NOC. In sharing the address space bi directionally all the IP blocks of the NOC can access memory in the address space by memory addressed messages including loads and stores directed through the IP block connected directly to the port . The port includes the pins and other interconnections required to conduct signals between the NOC and the off chip memory as well as sufficient intelligence to convert message packets from the NOC packet format to the bus format required by the off chip memory .

In the example of one of the IP blocks is designated a host interface processor . A host interface processor provides an interface between the NOC and a host computer in which the NOC may be installed and also provides data processing services to the other IP blocks on the NOC including for example receiving and dispatching among the IP blocks of the NOC data processing requests from the host computer. A NOC may for example implement a video graphics adapter or a coprocessor on a larger computer as described above with reference to . In the example of the host interface processor is connected to the larger host computer through a data communications port . The port includes the pins and other interconnections required to conduct signals between the NOC and the host computer as well as sufficient intelligence to convert message packets from the NOC to the bus format required by the host computer . In the example of the NOC coprocessor in the computer of such a port would provide data communications format translation between the link structure of the NOC coprocessor and the protocol required for the front side bus between the NOC coprocessor and the bus adapter .

In NOC of each memory communications controller includes a plurality of memory communications execution engines . Each memory communications execution engine is enabled to execute memory communications instructions from an IP block including bidirectional memory communications instruction flow between the network and the IP block . The memory communications instructions executed by the memory communications controller may originate not only from the IP block adapted to a router through a particular memory communications controller but also from any IP block anywhere in NOC . That is any IP block in the NOC can generate a memory communications instruction and transmit that memory communications instruction through the routers of the NOC to another memory communications controller associated with another IP block for execution of that memory communications instruction. Such memory communications instructions can include for example translation lookaside buffer control instructions cache control instructions barrier instructions and memory load and store instructions.

Each memory communications execution engine is enabled to execute a complete memory communications instruction separately and in parallel with other memory communications execution engines. The memory communications execution engines implement a scalable memory transaction processor optimized for concurrent throughput of memory communications instructions. Memory communications controller supports multiple memory communications execution engines all of which run concurrently for simultaneous execution of multiple memory communications instructions. A new memory communications instruction is allocated by the memory communications controller to a memory communications engine and memory communications execution engines can accept multiple response events simultaneously. In this example all of the memory communications execution engines are identical. Scaling the number of memory communications instructions that can be handled simultaneously by a memory communications controller therefore is implemented by scaling the number of memory communications execution engines .

In NOC of each network interface controller is enabled to convert communications instructions from command format to network packet format for transmission among the IP blocks through routers . The communications instructions may be formulated in command format by the IP block or by memory communications controller and provided to the network interface controller in command format. The command format may be a native format that conforms to architectural register files of IP block and memory communications controller . The network packet format is typically the format required for transmission through routers of the network. Each such message is composed of one or more network packets. Examples of such communications instructions that are converted from command format to packet format in the network interface controller include memory load instructions and memory store instructions between IP blocks and memory. Such communications instructions may also include communications instructions that send messages among IP blocks carrying data and instructions for processing the data among IP blocks in parallel applications and in pipelined applications.

In NOC of each IP block is enabled to send memory address based communications to and from memory through the IP block s memory communications controller and then also through its network interface controller to the network. A memory address based communications is a memory access instruction such as a load instruction or a store instruction that is executed by a memory communication execution engine of a memory communications controller of an IP block. Such memory address based communications typically originate in an IP block formulated in command format and handed off to a memory communications controller for execution.

Many memory address based communications are executed with message traffic because any memory to be accessed may be located anywhere in the physical memory address space on chip or off chip directly attached to any memory communications controller in the NOC or ultimately accessed through any IP block of the NOC regardless of which IP block originated any particular memory address based communication. Thus in NOC all memory address based communications that are executed with message traffic are passed from the memory communications controller to an associated network interface controller for conversion from command format to packet format and transmission through the network in a message. In converting to packet format the network interface controller also identifies a network address for the packet in dependence upon the memory address or addresses to be accessed by a memory address based communication. Memory address based messages are addressed with memory addresses. Each memory address is mapped by the network interface controllers to a network address typically the network location of a memory communications controller responsible for some range of physical memory addresses. The network location of a memory communication controller is naturally also the network location of that memory communication controller s associated router network interface controller and IP block . The instruction conversion logic within each network interface controller is capable of converting memory addresses to network addresses for purposes of transmitting memory address based communications through routers of a NOC.

Upon receiving message traffic from routers of the network each network interface controller inspects each packet for memory instructions. Each packet containing a memory instruction is handed to the memory communications controller associated with the receiving network interface controller which executes the memory instruction before sending the remaining payload of the packet to the IP block for further processing. In this way memory contents are always prepared to support data processing by an IP block before the IP block begins execution of instructions from a message that depend upon particular memory content.

In NOC of each IP block is enabled to bypass its memory communications controller and send inter IP block network addressed communications directly to the network through the IP block s network interface controller . Network addressed communications are messages directed by a network address to another IP block. Such messages transmit working data in pipelined applications multiple data for single program processing among IP blocks in a SIMD application and so on as will occur to those of skill in the art. Such messages are distinct from memory address based communications in that they are network addressed from the start by the originating IP block which knows the network address to which the message is to be directed through routers of the NOC. Such network addressed communications are passed by the IP block through I O functions directly to the IP block s network interface controller in command format then converted to packet format by the network interface controller and transmitted through routers of the NOC to another IP block. Such network addressed communications are bi directional potentially proceeding to and from each IP block of the NOC depending on their use in any particular application. Each network interface controller however is enabled to both send and receive such communications to and from an associated router and each network interface controller is enabled to both send and receive such communications directly to and from an associated IP block bypassing an associated memory communications controller .

Each network interface controller in the example of is also enabled to implement virtual channels on the network characterizing network packets by type. Each network interface controller includes virtual channel implementation logic that classifies each communication instruction by type and records the type of instruction in a field of the network packet format before handing off the instruction in packet form to a router for transmission on the NOC. Examples of communication instruction types include inter IP block network address based messages request messages responses to request messages invalidate messages directed to caches memory load and store messages and responses to memory load messages etc.

Each router in the example of includes routing logic virtual channel control logic and virtual channel buffers . The routing logic typically is implemented as a network of synchronous and asynchronous logic that implements a data communications protocol stack for data communication in the network formed by the routers links and bus wires among the routers. Routing logic includes the functionality that readers of skill in the art might associate in off chip networks with routing tables routing tables in at least some embodiments being considered too slow and cumbersome for use in a NOC. Routing logic implemented as a network of synchronous and asynchronous logic can be configured to make routing decisions as fast as a single clock cycle. The routing logic in this example routes packets by selecting a port for forwarding each packet received in a router. Each packet contains a network address to which the packet is to be routed.

In describing memory address based communications above each memory address was described as mapped by network interface controllers to a network address a network location of a memory communications controller. The network location of a memory communication controller is naturally also the network location of that memory communication controller s associated router network interface controller and IP block . In inter IP block or network address based communications therefore it is also typical for application level data processing to view network addresses as the location of an IP block within the network formed by the routers links and bus wires of the NOC. illustrates that one organization of such a network is a mesh of rows and columns in which each network address can be implemented for example as either a unique identifier for each set of associated router IP block memory communications controller and network interface controller of the mesh or x y coordinates of each such set in the mesh.

In NOC of each router implements two or more virtual communications channels where each virtual communications channel is characterized by a communication type. Communication instruction types and therefore virtual channel types include those mentioned above inter IP block network address based messages request messages responses to request messages invalidate messages directed to caches memory load and store messages and responses to memory load messages and so on. In support of virtual channels each router in the example of also includes virtual channel control logic and virtual channel buffers . The virtual channel control logic examines each received packet for its assigned communications type and places each packet in an outgoing virtual channel buffer for that communications type for transmission through a port to a neighboring router on the NOC.

Each virtual channel buffer has finite storage space. When many packets are received in a short period of time a virtual channel buffer can fill up so that no more packets can be put in the buffer. In other protocols packets arriving on a virtual channel whose buffer is full would be dropped. Each virtual channel buffer in this example however is enabled with control signals of the bus wires to advise surrounding routers through the virtual channel control logic to suspend transmission in a virtual channel that is suspend transmission of packets of a particular communications type. When one virtual channel is so suspended all other virtual channels are unaffected and can continue to operate at full capacity. The control signals are wired all the way back through each router to each router s associated network interface controller . Each network interface controller is configured to upon receipt of such a signal refuse to accept from its associated memory communications controller or from its associated IP block communications instructions for the suspended virtual channel. In this way suspension of a virtual channel affects all the hardware that implements the virtual channel all the way back up to the originating IP blocks.

One effect of suspending packet transmissions in a virtual channel is that no packets are ever dropped. When a router encounters a situation in which a packet might be dropped in some unreliable protocol such as for example the Internet Protocol the routers in the example of may suspend by their virtual channel buffers and their virtual channel control logic all transmissions of packets in a virtual channel until buffer space is again available eliminating any need to drop packets. The NOC of therefore may implement highly reliable network communications protocols with an extremely thin layer of hardware.

The example NOC of may also be configured to maintain cache coherency between both on chip and off chip memory caches. Each NOC can support multiple caches each of which operates against the same underlying memory address space. For example caches may be controlled by IP blocks by memory communications controllers or by cache controllers external to the NOC. Either of the on chip memories in the example of may also be implemented as an on chip cache and within the scope of the present invention cache memory can be implemented off chip also.

Each router illustrated in includes five ports four ports A D connected through bus wires to other routers and a fifth port connecting each router to its associated IP block through a network interface controller and a memory communications controller . As can be seen from the illustrations in the routers and the links of the NOC form a mesh network with vertical and horizontal links connecting vertical and horizontal ports in each router. In the illustration of for example ports A C and are termed vertical ports and ports B and D are termed horizontal ports.

IU also includes a dependency issue logic block dedicated to each hardware thread and configured to resolve dependencies and control the issue of instructions from instruction buffer to XU . In addition in the illustrated embodiment separate dependency issue logic is provided in AXU thus enabling separate instructions to be concurrently issued by different threads to XU and AXU . In an alternative embodiment logic may be disposed in IU or may be omitted in its entirety such that logic issues instructions to AXU .

XU is implemented as a fixed point execution unit including a set of general purpose registers GPR s coupled to fixed point logic branch logic and load store logic . Load store logic is coupled to an L1 data cache dCACHE with effective to real translation provided by dERAT logic . XU may be configured to implement practically any instruction set e.g. all or a portion of a 32b or 64b PowerPC instruction set.

AXU operates as an auxiliary execution unit including dedicated dependency issue logic along with one or more execution blocks . AXU may include any number of execution blocks and may implement practically any type of execution unit e.g. a floating point unit or one or more specialized execution units such as encryption decryption units coprocessors vector processing units graphics processing units XML processing units etc. In the illustrated embodiment AXU includes a high speed auxiliary interface to XU e.g. to support direct moves between AXU architected state and XU architected state.

Communication with IP block may be managed in the manner discussed above in connection with via network interface controller coupled to NOC . Address based communication e.g. to access L2 cache memory may be provided along with message based communication. For example each IP block may include a dedicated in box and or out box in order to handle inter node communications between IP blocks.

Embodiments of the present invention may be implemented within the hardware and software environment described above in connection with . However it will be appreciated by one of ordinary skill in the art having the benefit of the instant disclosure that the invention may be implemented in a multitude of different environments and that other modifications may be made to the aforementioned hardware and software embodiment without departing from the spirit and scope of the invention. As such the invention is not limited to the particular hardware and software environment disclosed herein.

Turning now to NOC may be used in some embodiments to implement a software based pipeline. In particular illustrates an exemplary processing unit incorporating a thread pipelined software engine that may be used to implement and execute one or more software pipelines on top of an NOC architecture. Each pipeline is typically allocated one or more data structures in a shared memory to enable different stages of a pipeline to exchange data. Furthermore an interrupt mechanism is provided to enable stages of a pipeline to notify one another of pending work to be performed.

One or more host interface processors HIP s are also provided in engine to handle the issue of work to software pipelines . One or more push buffers are provided to interface each HIP with a software application and driver which are resident outside of the engine. In order to initiate work in a pipeline a software application issues requests through an appropriate driver in the form of API calls which then generates appropriate requests for the HIP and stores the requests in a push buffer . The HIP for the relevant pipeline pulls work requests off of push buffer and initiates processing of the request by the associated pipeline.

In the illustrated embodiment and as implemented on a NOC a software pipeline implements a function that is segmented into a set of modules or stages of computer program instructions that cooperate with one another to carry out a series of data processing tasks in sequence. Each stage in a pipeline is composed of a flexibly configurable module of computer program instructions identified by a stage ID with each stage executing on a thread of execution on an IP block of a NOC . The stages are flexibly configurable in that each stage may support multiple instances of the stage so that a pipeline may be scaled by instantiating additional instances of a stage as needed depending on workload. Because each stage is implemented by computer program instructions executing on an IP block of a NOC each stage is capable of accessing addressed memory through a memory communications controller . At least one stage moreover is capable of sending network address based communications among other stages where the network address based communications maintain packet order.

The network address based communications for example may be implemented using inboxes in each stage that receive data and or commands from preceding stages in the pipeline. The network address based communications maintain packet order and are communications of a same type which are able to flow through the same virtual channel as described above. Each packet in such communications is routed by a router in the manner described above entering and leaving a virtual channel buffer in sequence in FIFO order thereby maintaining strict packet order and preserving message integrity.

Each stage implements a producer consumer relationship with a next stage. The first stage receives work instructions and work piece data through a HIP carries out its designated data processing tasks on the work piece produces output data and sends the produced output data to the next stage in the pipeline which consumes the produced output data from the first stage by carrying out its designated data processing tasks on the produced output data from the first stage thereby producing output data that is subsequently sent on to a next stage in the pipeline. This sequence of operations continues to the last stage of the pipeline which then stores its produced output data in an output data structure for eventual return through the HIP to the originating application .

The arrangement of stages in a pipeline may vary in different embodiments as well as for performing different functions in different applications. for example illustrates an exemplary software pipeline including a plurality of stage instances also separately designated as instances A I each of which representing a thread of execution implemented on an IP block in NOC . The stage instances are arranged in pipeline into five stages a first stage with instance A a second stage with instances B and C a third stage with instances D E and F a fourth stage with instances G and H and a fifth stage with instance I. As can be seen from instances may have a one to one a one to many and or a many to one relationship with other instances in the pipeline. Instances may operate collectively with one another in a particular stage to perform parallel tasks and share the workload thus improving the overall throughput of the stage in performing the task. Instances in a stage may also perform different tasks from one another to enable the parallel performance of different tasks. Instances can supply data to more than one instance while other instances may collect data and process data from multiple instances.

In the illustrated embodiment each instance of each stage of a pipeline is typically implemented as an application level module of computer program instructions executed on a separate IP block on a NOC and each stage is assigned to a thread of execution on an IP block of a NOC. Each stage is assigned a stage ID and each instance of a stage is assigned an identifier. HIP typically sets up the pipeline by configuring each stage with a desired number of instances with the network location of each instance of each stage provided to other instances of other stages to enable each instance to send its resultant workload to the proper instance in the next stage. earlier and or later stage 3 to which an instance of stage 2 is authorized to send its resultant workload. Multiple instances may be assigned to a particular stage to provide additional processing resources relative to other stages e.g. so work flows through the pipeline as efficiently as possible and no single stage presents a bottleneck to performance. It will also be appreciated that workload monitoring may be performed during runtime and that instances may be dynamically added or removed from a stage as needed for balancing the load among the stages of the pipeline.

Each stage is configured with a stage ID for each instance of a next stage which may also include the number of instances in the next stage as well as the network location of each instance of that. Configuring a stage with IDs for instances of a next stage provides the stage with the information needed to carry out load balancing across stages. Such load balancing can be carried out for example by monitoring the performance of the stages and instantiating a number of instances of each stage in dependence upon the performance of one or more of the stages. Monitoring the performance of the stages can be carried out by configuring each stage to report performance statistics to a separate monitoring application that in turn is installed and running on another thread of execution on an IP block or HIP. Performance statistics can include for example time required to complete a data processing task a number of data processing tasks completed within a particular time period and so on as will occur to those of skill in the art. Instantiating a number of instances of each stage in dependence upon the performance of one or more of the stages can be carried out by instantiating by an HIP a new instance of a stage when monitored performance indicates a need for a new instance.

Now turning to this figure illustrates an implementation of processing unit configured to implement a multithreaded rendering pipeline architecture consistent with the invention. In particular illustrates a multithreaded rendering pipeline incorporating a grouper stage with one or more grouper units a geometry engine stage with one or more geometry engines a post geometry engine Post GE stage including one or more post GE units a rasterizer stage including one or more rasterizers and pixel shading stage including one or more pixel shaders .

Each processing element or unit is desirably implemented within an IP block in a node in NOC with each such unit assigned at least one dedicated hardware thread. Each unit is typically disposed on a separate node although in other embodiments multiple units may be disposed in a single node. Moreover each unit may be allocated multiple threads of execution in some embodiments. Time slice based software multithreading may also be implemented in some embodiments although it is desirable in the illustrated embodiment that multiple units not be wholly implemented on the same hardware based thread.

Each grouper unit is used to group data for streaming down the pipeline e.g. by pulling related vertices from an object array. Each geometry engine is typically used to perform object transformations and generate the geometric primitives while each post GE unit is configured to perform post processing of the geometric primitives such as perspective divides culling sorting breaking up geometry etc.

Each rasterizer is configured to operate as a pixel fragment generator to generate a stream of pixel fragment data sets that characterize one pixel a fraction of one pixel or more than one pixel from a primitive input to the rasterizer. Among other operations each rasterizer typically performs a scan line conversion of coordinates in a primitive to u v texture coordinates in a texture to be applied to the primitive. Each pixel shader in turn takes the pixel fragment data sets and applies or updates the colors of one or more pixels in a frame buffer typically using texture filtering and other shading techniques. It will be appreciated that the specific operations performed by units and in terms of implementing a raster based rendering pipeline that renders image data for a scene may incorporate any number of known rendering techniques enhancements and algorithms and that the implementation of such techniques in the appropriate units would be well within the abilities of one of ordinary skill in the art having the benefit of the instant disclosure. It will also be appreciated that other rendering algorithms e.g. using physical rendering techniques such as ray tracing or photon mapping may also be implemented in a multithreaded pipeline consistent with the invention and that such techniques may rely on different and or additional pipeline stages not illustrated in . Therefore the invention is not limited to the particular raster based rendering pipeline architecture represented in .

Commands and data may be passed from stage to stage in pipeline while some data including shared context or state data is not passed directly from stage to stage but is instead maintained in shared memory and accessed by each stage as needed. Among this shared data may be included a rolling context data structure implemented in as a render context table and which is described in greater detail in the aforementioned 573 application.

Furthermore the data in shared memory may also include a texture context table which functions as a rolling texture context data structure. As shown in one implementation of texture context table incorporates a plurality of entries each including a key or index field one or more attribute fields an inUse field a cached field an LRU field and an ID field . Key or index field provides a unique identifier for its respective entry and in the illustrated embodiment field stores an integer index such that a texture context cursor may point to a particular entry via an integer value. In some embodiments field may be omitted e.g. where each entry is of fixed size such that the index for each entry is implied based upon its position in memory. It will also be appreciated that other identifiers may be used to identify an entry in table and the invention is not limited to the use of an integer index to identify an entry in a table.

Each field stores attribute data associated with a particular texture context represented by the respective entry . A fixed or variable number of fields may be provided in each entry and each field may store attribute data directly and or pointers to other data structures containing relevant attribute data. For the purpose of texture data the types of data that may be retained in a texture context table entry may include but are not limited to pointers or offsets to texture image data texture image data procedural texture code or pointers thereto color map mode anti aliasing data texture filtering algorithm selection how color values should combined with other preexisting object colors transparency alignment information on how a texture should be aligned to objects color space format illumination etc.

The inUse field for each entry is used to represent whether or not a particular entry is currently in use or is free for modification and or use in storing a different texture context. Various manners of representing the status of an entry may be used consistent with the invention including a single bit or flag or another numerical value. In addition a separate data structure could be used to store the status of each entry in table .

Cached field for each entry is used to represent whether or not the associated texture for an entry is currently cached in a texture cache. A texture cache for example may be implemented as a separate dedicated hardware memory structure such as a hardware texture cache or may be a region of a shared memory structure such as an L1 or L2 cache. LRU field for each entry is used to represent whether or not the entry is the least recently used entry in the table. Fields may be used for table management purposes e.g. to determine what entries and textures should be pulled into a cache and or what entries and textures should be discarded and or deleted from a cache.

ID field which is optional may be used as a higher level software construct identifier e.g. to identify the entry back to a process that generated it or to a particular functional call.

An in use entry in table is typically pointed to by one or more texture context cursors . A texture context cursor is typically maintained by any stage instance using a texture context and for which it is desirable to maintain a particular state. Where each entry is identified by an integer for example a texture context cursor may store an integer value from a circular index that is incremented for each new texture context and that rolls over to point to the first entry whenever the last entry in the table is reached. As will be discussed in greater detail below whenever a new state is required and a new entry is placed in use a texture context cursor is set to point to the new entry and may be returned to the stage instance using the new entry. Thus for each stage that shares a common state a separate texture context cursor is maintained in order to provide a mechanism for accessing the state. It will be appreciated that a texture context cursor may be represented in a number of manners and may be streamed along with streaming data or stored in shared memory in different embodiments of the invention. Furthermore instead of a circular index which naturally discards the oldest created entry LRU fields may be used to discard entries that were the least recently used as opposed to least recently created.

It will be appreciated that texture context table is but one of an innumerable number of different data structures that may be used to concurrently store multiple snapshots of texture data used in a multithreaded software pipeline. The invention is therefore not limited to the particular implementation illustrated in .

In the illustrated embodiment the illustrated steps in are performed by HIP however in other embodiments some or all of the steps may be performed by other logic e.g. in a particular stage in multithreaded rendering software pipeline . Moreover as illustrated in block HIP may also perform background management operations e.g. to discard unused texture contexts in addition to processing commands from device driver .

In general the addition or removal of a texture context occurs under the direction of a user application. For removal the request to remove a texture context however may be scheduled by a HIP at a frame boundary so that the texture context is removed when processing of a frame is complete.

Now turning to routine a command is received by HIP from device driver in block . A determination is made in block as to whether the command will modify the current texture context. A command that will modify a texture context is typically a command that changes some state data associated with the associated texture e.g. to change an anti aliasing mode for the texture context.

If the command will modify the current texture context control passes to block to determine whether the current texture context is currently in use e.g. by checking the inUse field for the texture context table entry pointed to by the texture context cursor associated with the pipeline stage associated with the command . In the event that the current texture context is determined to not be in use control passes to block to modify the texture context based upon the command. If the current texture context is not in use the modification of the texture context may also incorporate resetting the data and or initializing the data in the associated texture context table entry . Routine then completes processing of the command as shown at block .

Setting a texture context in use is performed in response to a command that attempts to use a texture context. Thus returning to block if the command will not modify the current texture context control passes to block to determine whether the command will use the texture context. If so control passes to block to mark the texture context in use by setting the inUse field in the table entry pointed to by the texture context cursor then processing of the command continues at block .

Returning to block if a command will modify the current texture context and that texture context is currently in use block passes control to block to replicate the current texture context e.g. by copying the data in the current texture context table entry to the next unused texture context table entry in table . Block then updates the texture context cursor associated with the current command to point to the new texture context and control passes to block to modify the new texture context as appropriate for the command. As a result the original texture context in use by other stages of the pipeline retains its original state and a new modified state is created for the stage associated with the current command. It will be appreciated that in some embodiments the use of a new texture context may not require the current texture context to be copied into the new texture context. It will also be appreciated that whenever a last texture context entry in table is reached when searching for an unused texture context the search will roll over to the first entry in the table. In addition in some embodiments an attempt to modify a texture context may be processed by modifying the existing texture context after replicating that texture context to create a new texture context.

It will be appreciated that from the standpoint of a multithreaded rendering software pipeline the operation of routine in processing commands from device driver will ensure that different work may be routed to different stages and instances of stages in the pipeline without a concern that the processing of other work will change the texture context or state used for such work. Different work can therefore be processed in parallel and in many instances without concern for completion order thereby maximizing throughput through the pipeline and minimizing serialization and contention conflicts. Routine and the hardware upon which the routine is implemented therefore functions as control logic that associates work with a texture context in the texture context table such that state data in a first context that is associated with first work is unaltered responsive to a change made to state data in a second context that is associated with second work during processing of the second work by the multithreaded rendering software pipeline.

Returning to block of if a command does not use or modify a texture context control passes to block to determine whether a texture context should be freed or released. If so control passes to block to mark the relevant texture context table entry unused whereby control then proceeds to block .

In order to free or release texture contexts a number of techniques may be used. For example a specific command may be generated to release a texture context when it is known that texture context will no longer be used. Such a command may be explicitly generated as a result of a function call by an application or in the alternative the fact that a texture context will no longer be used may be detected and used to automatically free the texture context. For example HIP may detect that a later command will modify the current texture context and tag a current command to indicate that the command will be the last command to use the current texture context. For example blocks and of may be implemented within a particular stage in pipeline e.g. in each rasterizer unit such that upon detecting a command that is flagged by the HIP to be the last command that will use the current texture context the rasterizer unit will automatically free the texture context in the manner described above. In the alternative rasterizer unit may detect a later command that changes the texture context. As another alternative the HIP may send a flush packet down the pipeline to free a particular texture context. It will also be appreciated that other stages may have responsibility for freeing unused texture contexts although in many instances it is desirable to free texture contexts in the last stage in which the state data represented by a texture context could be used.

As another alternative one or more counters may be used to track the usage of each texture context. For example a HIP may increment a used count whenever a texture context is used by a command while each rasterizer unit may increment a free count whenever a command that uses the texture context has completed. Each rasterizer unit may then compare the used and free counts and automatically free a texture context whenever the two counts are equal. In other embodiments a single counter incremented when a command uses the texture context and decremented when a command that uses the texture context completes may be used in lieu of separate counts. Other mechanisms for detecting and freeing unused texture contexts will be apparent to one of ordinary skill in the art having the benefit of the instant disclosure.

Returning to block if no texture context should be freed block passes control to block to determine whether a new texture context should be added. If so the new texture context is created in block whereby control then proceeds to block . Otherwise block passes control to block to determine whether the command is a query command which requests information from a texture context. If so control passes to block to return the requested texture context data otherwise block bypasses block and returns control to block .

The manner in which texture contexts may be selected for removal or replacement e.g. when new texture contexts are added or existing texture contexts are rolled may vary in different embodiments. For example a circular search algorithm may be used to search sequentially for the next unused texture context or if no texture contexts are unused for the earliest created texture context. Alternatively the LRU fields may be updated as texture contexts are accessed and used to select for removal a texture context entry that is least recently used. Furthermore cached field may be used in the removal algorithm as it may be desirable to avoid removing texture contexts for which the associated texture data is currently cached.

Various modifications may be made consistent with the invention. For example multiple texture context data structures e.g. tables may be used in some embodiments. Different texture context tables for example may be used for different areas of a scene being rendered in order to localize memory accesses for different pipeline stages working on different areas of a scene. Texture context tables may be cached in some embodiments to accelerate access thereto.

In addition various other modifications may be made without departing from the spirit and scope of the invention. Therefore the invention lies in the claims hereinafter appended.

