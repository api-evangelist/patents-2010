---

title: Method frame aggregation for latest user-defined class loader identification
abstract: Class loader changes from at least one user-defined class loader to a bootstrap class loader are determined by a stack processing module during de-serialization of a serialized data object. A reference to each user-defined class loader is stored separately from a thread method frame stack in response to each determined change from the at least one user-defined class loader to the bootstrap class loader. For each user-defined class load operation of a user-defined class associated with the de-serialization of the serialized data object, a latest user-defined class loader (LUDCL) is identified using the stored reference and the user-defined class is loaded using the identified LUDCL.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08661426&OS=08661426&RS=08661426
owner: International Business Machines Corporation
number: 08661426
owner_city: Armonk
owner_country: US
publication_date: 20101231
---
The present invention relates to identification of a latest user defined class loader. More particularly the present invention relates to method frame aggregation for latest user defined class loader identification.

Serialization or marshaling is a process of decomposing an instantiated object into a data format that may be transmitted or transferred via a message. De serialization or un marshaling is a process of reconstructing an instantiated object at a receiving device in response to receipt of a message including an object formatted as serialized marshaled data.

A method includes determining via a stack processing module during de serialization of a serialized data object class loader changes from at least one user defined class loader to a bootstrap class loader storing in response to each determined change from the at least one user defined class loader to the bootstrap class loader a reference to each user defined class loader separately from a thread method frame stack and for each user defined class load operation of a user defined class associated with the de serialization of the serialized data object identifying a latest user defined class loader LUDCL using the stored reference and loading the user defined class using the identified LUDCL.

A system includes a memory and a processor programmed to determine during de serialization of a serialized data object class loader changes from at least one user defined class loader to a bootstrap class loader store in response to each determined change from the at least one user defined class loader to the bootstrap class loader a reference to each user defined class loader separately from a thread method frame stack within the memory and for each user defined class load operation of a user defined class associated with the de serialization of the serialized data object identify a latest user defined class loader LUDCL using the stored reference and load the user defined class using the identified LUDCL.

A computer program product comprising a computer readable storage medium including computer readable program code where the computer readable program code when executed on a computer causes the computer to determine during de serialization of a serialized data object class loader changes from at least one user defined class loader to a bootstrap class loader store in response to each determined change from the at least one user defined class loader to the bootstrap class loader a reference to each user defined class loader separately from a thread method frame stack and for each user defined class load operation of a user defined class associated with the de serialization of the serialized data object identify a latest user defined class loader LUDCL using the stored reference and load the user defined class using the identified LUDCL.

The examples set forth below represent the necessary information to enable those skilled in the art to practice the invention and illustrate the best mode of practicing the invention. Upon reading the following description in light of the accompanying drawing figures those skilled in the art will understand the concepts of the invention and will recognize applications of these concepts not particularly addressed herein. It should be understood that these concepts and applications fall within the scope of the disclosure and the accompanying claims.

The subject matter described herein provides method frame aggregation for latest user defined class loader LUDCL identification. The present subject matter operates by aggregating method frames of methods for classes loaded by a bootstrap loader within a thread s stack to expedite identification of a LUDCL thereby reducing processing cycles and improving performance of stack walk procedures during identification of a LUDCL. The present subject matter further improves performance where stack frames of methods belonging to classes loaded by user defined class loaders within a given stack thread are interleaved with stack frames of methods belonging to classes loaded by bootstrap null class loaders. While the examples that follow illustrate use of the present subject matter during de serialization un marshaling the present subject matter may be utilized in other situations as appropriate for a given implementation. Accordingly all such implementations are considered within the scope of the present subject matter.

An example situation where the present subject matter may be utilized is during de serialization un marshaling of objects received as serialized marshaled data in association with a message. Such a situation may occur when storing instantiated data objects to an object database or transfer of an object from one system to another. Using Java programming language as an example the bootstrap null class loader is a parent of all other class loaders including the Java development kit s JDK s application class loader. The bootstrap class loader loads system classes that are a part of JDK class libraries. The bootstrap class loader is also referred to herein as a null class loader. For purposes of the examples described herein reference to a user defined method means stack frames of methods belonging to a class loaded by a user defined class loader. However it should be understood that in certain implementations user defined classes may be loaded by a bootstrap loader. Additionally it should be noted that certain implementations e.g. other than current Java may provide support for more than one native class loader similar to the one bootstrap loader currently utilized within Java . Further hierarchies of bootstrap loaders may be supported. As such the term bootstrap loader as used herein also includes a multiple and or hierarchical class loaders that are native to a given environment as appropriate for a given implementation. Accordingly the present subject matter also applies to programs and systems similar to the Java Virtual Machine JVM that provide mechanism s for multiple parallel executing native class loader implementations and their hierarchies similar to the current bootstrap class loader implementation in the JVM. It should further be noted that while the examples described herein are directed to de serialization of a serialized data object the present subject matter may also be utilize in other implementations. For example where a diagnostic tool is utilized to print method frames from a thread method frame stack the present subject matter may be utilized to limit a number of method frames that are printed. Many other implementations are possible and all are considered within the scope of the present subject matter.

Examples of JDK classes that are loaded by a bootstrap loader are classes in packages such as java.lang java.io java.util and other packages. The application class loader supplied with the JDK and all of its sub classes e.g. those that inherit attributes or functionality from the java.lang.ClassLoader class are referred to herein as user defined class loaders. These user defined class loaders are also referred to herein as non null class loaders. As such if at least one method of a stack is a part of a class that is loaded by a user defined class loader then the LUDCL is considered non null. 

The first non null class loader that was used to load the class of a method in the current thread stack from the top of the stack is referred to as latest user defined class loader LUDCL . If all of the methods of the stack are a part of classes that are loaded by the bootstrap null class loader then the LUDCL is considered null. In a multi threaded environment where each thread performs de serialization on its own and independent from others the respective LUDCL is looked up from the corresponding thread s own method frame stack.

During an un marshaling de serialization process a new instance of an object is created from a serialized data object such as a serialized data object received within a message. As such at least one corresponding class associated with the object has to be loaded if not already loaded. Certain of the examples described herein refer to the Common Object Request Broker Architecture CORBA architecture and specification though it is understood that the present subject matter is not limited to CORBA compliant systems. The CORBA specification mandates that the class loading at first should be attempted using the LUDCL. Use of an LUDCL may fail for various reasons such as there is no LUDCL in the current thread stack because all methods in the stack are defined in classes loaded by the bootstrap null loader. If identification use of an LUDCL fails for any reason the present subject matter attempts to load a given class using alternative mechanisms such as use of another class loader e.g. a class loader called Remote Method Invocation RMI class loader etc. . By use of the method frame aggregation for latest user defined class loader LUDCL identification described herein the present subject matter operates to reduce computational requirements for identification of the LUDCL or selection of a new UDCL where an LUDCL does not exist within a given stack frame.

Obtaining the LUDCL for a particular thread is performed by invocation of certain virtual machine application programming interfaces APIs and this occurs during every de serialization un marshaling of a CORBA message. Using an example of several enterprise applications extensive central processing unit CPU time may be spent in the Java virtual machine JVM and just in time JIT collectively JVM JIT procedures that assist in thread stack walk to identify the LUDCL. For conventional systems the CPU time may further be increased in cases where the payload is deeply nested and the nested container objects are loaded by the bootstrap class loader. However the present subject matter provides operations to improve CPU usage for LUDCL identification.

The present subject matter obtains the LUDCL from a given thread stack by aggregating method frames corresponding to methods of classes loaded by the bootstrap class loader. Such an approach isolates optimization to de serialization un marshaling code path and as a result does not compromise performance of other components or modules of Java JVM. The present subject matter also reduces CPU utilization by the stack walk procedures of JVM JIT and complies with the Java JVM and CORBA specification.

The method frame aggregation for latest user defined class loader LUDCL identification described herein may operate at a development kit level such as within a Java development kit JDK within a system or at an application level. API routines may be defined for use at either the development kit or application level for marking and unmarking aggregations of bootstrap null method frames for use in identifying the LUDCL and for other management activities as described in more detail below. The method frame aggregation for latest user defined class loader LUDCL identification operates by identifying a class loader associated with each class about to be invoked. A stack processing module may implement the present functionality either at the JDK level or at the application level or may be a stand alone or modular component for a hardware implementation. For a hardware implementation API invocations may be implemented as register based operations or otherwise as appropriate for a given implementation.

De serialization or un marshaling may result in a recursive invocation of methods and a recursive exiting of methods for reconstruction of an instantiated object. It should be noted that in addition to changes between user defined class loaders and the bootstrap loader where a LUDCL is not capable of loading a particular class the user defined class loader may also change thereby resulting in a new LUDCL. Such a transition between user defined class loaders may occur with or without intervening bootstrap loader method invocations. There are scenarios in de serialization when the program execution e.g. control flow goes out of the JDK CORBA source code into the application code and returns to the JDK CORBA source code. When the control goes to the application the application is free to invoke a method and hence create a stack frame on the current thread stack whose class is loaded by a user defined class loader. This changes the LUDCL. As such the present subject matter performs checks to accommodate such circumstances as described in more detail below to determine class loader changes between a bootstrap class loader and at least one user defined class loader. Further sequences of methods loaded by the bootstrap class loader within a method frame stack may be aggregated based upon the determined class loader changes to form an aggregated method frame stack. While reconstructing a serialized object during de serialization the latest user defined class loader LUDCL may be identified using the aggregated method frame stack and the identified LUDCL may be used to load the corresponding class type of the object under construction.

As an example of identification of a class loader associated with a given method class the following pseudo code may be used to determine identify whether a given method is associated with the bootstrap class loader or a user defined class loader.

As can be seen from the above pseudo code the conditional statement determines whether a class loader is associated with the bootstrap class loader e.g. is null or a user defined class loader e.g. is non null . It should be noted that while the present pseudo code example performs a print line function assignment of a value indicative of the respective class loader may be performed and utilized for additional processing such as invocation of additional APIs as described below.

Further while the examples that follow reference the JDK it is understood that the present subject matter may be utilized in any implementation where an object that has been serialized into a data stream or message must be reconstructed on a destination platform e.g. a database or other system . As such the present subject matter may be applied to other environments systems where de serialization or reconstruction of objects is performed. Current examples of such systems include but are not limited to a .NET framework a javascript object notation json framework platform or other platforms. Accordingly the present subject matter and examples described herein may be modified as appropriate for a given implementation without departure from the scope of the present subject matter.

The loader may be either a bootstrap null class loader associated with the development kit or a user defined class loader. In response to determining that a method that is about to be invoked changes the class loader either from the bootstrap null class loader to a user defined class loader or between user defined class loaders the stack processing module may perform certain actions as described in more detail below to identify the class loader transition change.

Certain application programming interfaces APIs may be utilized to assist with the processing described herein. For example an API routine method called LUDCLMarkFrame may be defined and used to mark the current stack frame as the point at which to terminate the latest user defined class loader LUDCL search. The method marks the current frame and returns the previous mark information. The marked method frame provides an indication that an end of a bootstrap loader aggregation is associated with the current method frame and that the stack walk may end with the marked frame.

It should be noted that the LUDCL may or may not have changed in the subsequent method calls above the marked frame in the particular thread stack from the marked method frame. As such during the stack walk if a method frame is found whose class is loaded by a non null user defined loader before the marked method frame is encountered then that non null loader may be returned as the LUDCL. Otherwise null may be returned indicating that the LUDCL has not changed since the last mark. In such a situation for implementations that utilize a separate LUDCL stack where the LUDCL has not changed the class loader identified in the top of stack in the separate LUDCL stack may be used and identified as the LUDCL.

Alternatively it should be noted that the stack walk occurs from a start of a new aggregation to an end of the previous aggregation. As such if the first frame read is a marked frame this may also indicate that the LUDCL has not changed. As such the stack walk may be terminated and the user defined loader present on the top of the LUDCL stack during de serialization may be used and identified as the LUDCL. Accordingly in response to a determination that the LUDCL stack does not include the LUDCL reference the thread method frame stack may be walked until the first encountered user defined class loader that loaded a class associated with a method in the thread method frame stack is found. If the LUDCL is not found until the base of the thread method frame stack is encountered it is concluded that a user defined class loader does not exist in the current thread method frame stack and as such the system proceeds to employ an alternate class loader object for the class loading operation.

Additionally an API routine method called LUDCLUnmarkFrame long previousValue may be defined and used to restore the previous marked frame state to the respective thread. This method uses the returned value from the LUDCLMarkFrame method to restore the previous state of the mark values.

Further an API routine method called GetLatestUserDefinedLoader may be used to walk method frames within a given stack until the LUDCL a method frame marked using the LUDCLMarkFrame API or the base of the stack is found. If a marked frame or the base of the stack is found the method may return with a null return value.

It should further be noted that the GetLatestUserDefinedLoader API operates to provide information for two portions of the processing described herein. The first associated information provided by use of the GetLatestUserDefinedLoader API may be associated with a start of aggregation e.g. a detected transition from a user defined class loader to the bootstrap loader . This invocation of the GetLatestUserDefinedLoader API may initiate a walk of the thread stack e.g. search until a method belonging to a class loaded by a user defined class loader is identified where the LUDCL may be identified in association with the method or alternatively until the bottom of the stack is identified where in the latter case there is no LUDCL . In response to identifying an LUDCL a Push LUDCL operation to push a reference e.g. value to a current UDCL onto the separate LUDCL stack is performed. As such in response to a first and subsequent identification of a UDCL the LUDCL stack will include a reference to the respective user defined class loader. For purposes of the present subject matter the reference to the UDCL that is pushed onto the LUDCL stack may be any form of reference to the UDCL as appropriate for a given implementation. For example the reference to the UDCL may include a pointer address a class name or any other form of reference appropriate for a given implementation. The operation to Push the LUDCL is performed each time when the LUDCL has changed at a start of aggregation before re entry into the method. Otherwise the actual push operation to the LUDCL stack will not occur even where the API call to GetLatestUserDefinedLoader is invoked.

The second associated information provided by use of the GetLatestUserDefinedLoader API may be for retrieval of the LUDCL in response to a class load operation for a user defined class during the de serialization of a serialized data object from either from the LUDCL stack where the LUDCL stack includes at least one UDCL or by walking the thread method frame stack until a user defined method or the bottom of the stack is identified. The Get LUDCL functionality is used while attempting to load a given class during de serialization un marshaling of a serialized object received within a message. This operation occurs while the class load sub operation is underway during the de serialization operation.

The operations performed to find the LUDCL in the former case and to check if the LUDCL has changed in the latter case are the same by calling a GetLatestUserDefinedLoader method. However this method GetLatestUserDefinedLoader improves efficiency by checking determining whether the current method on the thread stack is marked or not before walking further to the next frame. As described above where a marked frame is encountered the stack walk may be terminated. It should be noted that the thread stack may include only method frames defined in classes loaded by the null bootstrap loader and that no UDCL has been invoked during certain processing intervals.

It should further be noted that for implementation of the Get LUDCL functionality the present subject matter may perform a peek operation as described in more detail below to retrieve a reference to the LUDCL from the LUDCL stack and in certain situations to retrieve the LUDCL without requiring a stack walk of the method frames on the thread stack. However it should be noted that since the LUDCL is pushed to the LUDCL stack in response to determinations of class loader changes from user defined class loaders to a bootstrap class loader the LUDCL may have changed since a last push of the LUDCL onto the LUDCL stack. As such the stack walk described above may be performed even where a value is found on the LUDCL stack. Such a stack walk may be terminated in response to identifying a marked frame as described above and in more detail below. As also described in more detail below using a peek operation rather than a pop operation on the LUDCL stack may prevent corruption of the LUDCL stack during de serialization un marshaling operations. The actual references stored on the LUDCL stack may then be popped from the LUDCL stack as methods are exited as described in more detail below.

In such a situation where the peek operation is used to identify the LUDCL the GetLatestUserDefinedLoader makes certain that there are no null entries pushed on to the LUDCL stack and that that LUDCL stack is not empty prior to performing an assignment of an LUDCL from the LUDCL stack for use during class loading for de serialization un marshaling of an object. As such a null value will not be used for the LUDCL and where the LUDCL stack does not include an LUDCL reference a stack walk procedure may be used in conjunction with aggregated bootstrap null loader invoked methods to further improve efficiency for identification of the LUDCL if a UDCL has been previously used to load at least one other user defined class. As such for the Get LUDCL functionality there is no need to walk the thread stack unless the LUDCL stack is empty and the LUDCL may be identified using a peek operation on the LUDCL and the returned LUDCL if one is returned may be used where at least one valid UDCL reference is located on the LUDCL stack by the peek operation.

The following pseudo code examples represent processing that may be performed to determine whether the LUDCL stack includes any entries. The first example pseudo code below represents a relevant portion of a load class procedure for assigning the LUDCL as the class loader to be used to attempt to load subsequent classes during de serialization un marshaling of a serialized data object along with an attempt to load the class using a class loader returned from the LUDCL stack.

As can be seen from the example pseudo code above the LUDCL stack is queried with the peek method to retrieve the reference of the LUDCL if at least one reference exists on the LUDCL stack. If there is no LUDCL reference on the LUDCL stack the thread frame stack is walked to identify LUDCL. Finally the identified LUDCL from either the LUDCL stack or the thread frame stack walk operation is used to attempt to load Object1 class. It is understood that where the identified LUDCL is not capable of loading the class a default class loader capable of loading the method may then be retrieved. For purposes of the present example the RMI class loader associated with the JDK may be used. However it is understood that each platform may define a default class loader that may be used in such a situation as appropriate for a given implementation.

As can be seen from the above example pseudo code the new operator is used to create a stack. The created stack is assigned as the LUDCL stack.

The following example pseudo code represents one possible implementation of the peek method utilized above with the first example pseudo code of the present set of pseudo code examples.

As can be seen from the above example pseudo code the LUDCL stack is examined to determine whether it is empty. If the LUDCL stack is empty the peek method returns null. If the LUDCL stack is not empty the reference to the LUDCL is returned without requiring an actual pop operation on the LUDCL stack. As such processing for removing UDCL references from the LUDCL stack may be performed as methods exit during the de serialization un marshaling process and the operations to Get the LUDCL do not corrupt the stack.

Using the above mentioned APIs programs such as the JDK may aggregate methods that are known to belong to classes loaded by the null bootstrap class loader. When a method that may potentially alter the LUDCL is about to be invoked the program marks the current method frame using LUDCLMarkFrame API. Later when the LUDCL has to be obtained from the stack the GetLatestUserDefinedLoader API may be invoked to identify the LUDCL. This API will terminate the stack walk when the marked frame is encountered and return a null.

As a further optimization the program may invoke the GetLatestUserDefinedLoader API in the first method where the next aggregation of methods begins instead of the place where the LUDCL is finally used during class loading . Since the LUDCL search procedure is invoked at the start of an aggregation the possibility of finding a user defined loader immediately and without walking a lot of method frames increases.

If a non null value is returned by the GetLatestUserDefinedLoader API the return value the new LUDCL may be stored in a separate LUDCL Stack data structure and this process may recursively be performed at every level of nesting in a deeply nested object. When the system returns after reading an object at a certain level of nesting in the deeply nested object it pops from the LUDCL Stack data structure and invokes the LUDCLUnmarkFrame API to remove a mark from a previously marked frame. In this way the number of stack frames that are walked for every invocation of GetLatestUserDefinedLoader may be reduced.

The method frame aggregation for latest user defined class loader LUDCL identification described herein may be performed in real time to allow prompt identification of the LUDCL within a given stack. For purposes of the present description real time shall include any time frame of sufficiently short duration as to provide reasonable response time for information processing acceptable to a user of the subject matter described. Additionally the term real time shall include what is commonly termed near real time generally meaning any time frame of sufficiently short duration as to provide reasonable response time for on demand information processing acceptable to a user of the subject matter described e.g. within a portion of a second or within a few seconds . These terms while difficult to precisely define are well understood by those skilled in the art.

Further with reference to the description above the terms serialize or serializing and marshal or marshaling respectively may be used interchangeably within the description of the examples that follow for readability. Further the terms de serialize or de serializing and un marshal or un marshaling respectively may be used interchangeably within the description of the examples that follow for readability.

As such for purposes of the present example the client  through the client N may instantiate objects and serialize the generated objects for storage via the database server within the object database . The serialized objects may be sent within one or more messages to the database server via any protocol appropriate for a given implementation. In response to receipt of one or more messages including a serialized data object the database server may de serialize the object and instantiate the object for storage within the object database .

Additionally the database server may retrieve instantiated objects from the object database in response to requests for objects received from one or more of the client  through the client N . The database server may serialize the retrieved objects for transmission to the respective one or more of the client  through the client N . The serialized objects may be sent within one or more messages to the respective one or more of the client  through the client N via any protocol appropriate for a given implementation. In response to receipt of one or more messages including a serialized data object the respective one or more of the client  through the client N may de serialize the object and instantiate the object.

As such the client  through the client N and the database server may each serialize and de serialize objects. Further the messaging and functionality within the system may comply with any appropriate standard for a given implementation such as the CORBA specification. Additionally while the present example utilizes certain devices for purposes of description it should be understood that the present subject matter is not limited to implementation in association with the devices described. The present subject matter may be implemented within any system where de serialization un marshaling of an object is appropriate. As such the present examples are for ease of illustration purposes and impose no limitation on the applicability of the present subject matter.

As will be described in more detail below in association with through each of the client  through the client N and the database server provides automated method frame aggregation for latest user defined class loader LUDCL identification. The automated method frame aggregation for LUDCL identification is based upon aggregation of method frames associated with a bootstrap loader to improve efficiency for stack walk processing for de serialization of data objects. The automated method frame aggregation for LUDCL identification may further be based upon storage of LUDCL references within a separate LUDCL stack to further improve performance of de serialization within certain implementations.

It should be noted that any of the client  through the client N and the database server may be a portable computing device either by a user s ability to move the respective device to different locations or by the respective device s association with a portable platform such as a plane train automobile or other moving vehicle. It should also be noted that the devices described herein may be any computing device capable of processing information as described above and in more detail below. For example the client  through the client N and the database server may include devices such as a personal computer e.g. desktop laptop etc. or a handheld device e.g. cellular telephone personal digital assistant PDA email device music recording or playback device etc. or any other device capable of processing information as described in more detail below.

The network may include any form of interconnection suitable for the intended purpose including a private or public network such as an intranet or the Internet respectively direct inter module interconnection dial up wireless or any other interconnection mechanism capable of interconnecting the respective devices.

The database server may include any device capable of providing data for consumption by a device such as the client  through the client N via a network such as the network . As such the database server may include a web server or other data server device. Additionally the client  through the client N may include any device capable of generating data objects for storage within the object database .

The display may include any display device such as a cathode ray tube CRT liquid crystal display LCD light emitting diode LED projection touchscreen or other display element or panel. The input device may include a computer keyboard a keypad a mouse a pen a joystick or any other type of input device by which the user may interact with and respond to information on the display .

It should be noted that the display and the input device are illustrated with a dashed line representation within to indicate that they may be optional components for the core processing module for certain implementations. Accordingly the core processing module may operate as a completely automated embedded device without user configurability or feedback. However the core processing module may also provide user feedback and configurability via the display and the input device respectively.

A communication module provides interconnection capabilities that allow the core processing module to communicate with other modules within a system such as the system . The communication module may include any electrical protocol and protocol conversion capabilities useable to provide the interconnection capabilities. Though the communication module is illustrated as a component level module for ease of illustration and description purposes it should be noted that the communication module may include any hardware programmed processor s and memory used to carry out the functions of the communication module as described above and in more detail below. For example the communication module may include additional controller circuitry in the form of application specific integrated circuits ASICs processors antennas and or discrete integrated circuits and components for performing communication and electrical control activities associated with the communication module . Additionally the communication module may include interrupt level stack level and application level modules as appropriate. Furthermore the communication module may include any memory components used for storage execution and data processing for performing processing activities associated with the communication module . The communication module may also form a portion of other circuitry described without departure from the scope of the present subject matter.

A memory includes a thread stack storage area that stores thread stacks for storage of method frames for one or more threads operating in association with the core processing module . The memory also includes an LUDCL stack storage area that stores references to user defined class loaders as the user defined class loaders are identified for example during de serialization operations.

It is understood that the memory may include any combination of volatile and non volatile memory suitable for the intended purpose distributed or localized as appropriate and may include other memory segments not illustrated within the present example for ease of illustration purposes. For example the memory may include a code storage area an operating system storage area a code execution area and a data area without departure from the scope of the present subject matter.

A stack processing module is also illustrated. The stack processing module provides stack management capabilities for the core processing module as described above and in more detail below. The stack processing module implements the automated method frame aggregation for latest user defined class loader LUDCL identification of the core processing module .

Though the stack processing module is illustrated as a component level module for ease of illustration and description purposes it should be noted that the stack processing module may include any hardware programmed processor s and memory used to carry out the functions of this module as described above and in more detail below. For example the stack processing module may include additional controller circuitry in the form of application specific integrated circuits ASICs processors and or discrete integrated circuits and components for performing communication and electrical control activities associated with the respective devices. Additionally the stack processing module may include interrupt level stack level and application level modules as appropriate. Furthermore the stack processing module may include any memory components used for storage execution and data processing for performing processing activities associated with the module.

It should also be noted that the stack processing module may form a portion of other circuitry described without departure from the scope of the present subject matter. Further the stack processing module may alternatively be implemented as an application stored within the memory . In such an implementation the stack processing module may include instructions executed by the CPU for performing the functionality described herein. The CPU may execute these instructions to provide the processing capabilities described above and in more detail below for the core processing module . The stack processing module may form a portion of an interrupt service routine ISR a portion of an operating system a portion of a browser application or a portion of a separate application without departure from the scope of the present subject matter. Additionally the stack processing module may form a portion of a JDK or application level process without departure from the scope of the present subject matter.

The CPU the display the input device the communication module the memory and the stack processing module are interconnected via an interconnection . The interconnection may include a system bus a network or any other interconnection capable of providing the respective components with suitable interconnection for the respective purpose.

While the core processing module is illustrated with and has certain components described other modules and components may be associated with the core processing module without departure from the scope of the present subject matter. Additionally it should be noted that while the core processing module is described as a single device for ease of illustration purposes the components within the core processing module may be co located or distributed and interconnected via a network without departure from the scope of the present subject matter. For a distributed arrangement the display and the input device may be located at a point of sale device kiosk or other location while the CPU and memory may be located at a local or remote server. Many other possible arrangements for components of the core processing module are possible and all are considered within the scope of the present subject matter. Accordingly the core processing module may take many forms and may be associated with many platforms.

The following several pseudo thread method frame stacks are presented to provide an example of aggregation of method frames of classes loaded by the bootstrap loader within a thread stack. It is understood that the following pseudo thread method frame stacks may be stored in a memory location such as the thread stack storage area of the memory . The ellipsis dots in the following pseudo thread method frame stacks show that additional method frames may be stored within the respective pseudo thread method frame stack.

The following first example pseudo thread method frame stack provides an example of aggregation of bootstrap loader methods on a thread method frame stack.

Within the first example pseudo thread method frame stack above it is assumed that the method frame MainMethod1 belongs to a class loaded by a non null user defined class loader. As such the class that loaded the MainMethod1 may be considered an LUDCL and may be identified as described in more detail below.

As described above and in more detail below the present subject matter may track determine class loader changes from user defined class loaders to a bootstrap class loader. As such the method frame StartAggregation1 represents a detected transition from thread stack methods belonging to classes loaded by user defined class loader s to methods belonging to classes loaded by the bootstrap class loader. The method StartAggregation1 is the first method in the execution control flow of the current thread that belongs to a class that is loaded by the bootstrap null class loader. The method frame StartAggregation1 also represents a point at which to begin walking the stack to identify the LUDCL and cache the LUDCL e.g. a reference to the class loader object that loaded the class that contains the method MainMethod1 within the LUDCL stack as described above. The stack walk ends at the frame MainMethod1 and the class loader that loaded the MainMethod1 method s class is pushed onto the LUDCL stack.

The method frame EndAggregation1 represents the last frame loaded by the bootstrap loader. As such the EndAggregation1 method frame is marked within the first example pseudo thread method frame stack such as by using the LUDCLMarkFrame API described above to identify an aggregated set of bootstrap loader method frames within the first example pseudo thread method frame stack. As such a stack walk that may be initiated from a subsequent frame later during the de serialization process in order to find the latest user defined class loader will be terminated at this point in response to detection of the marked frame. Termination of the stack walking implies that there is no change to the previously cached LUDCL. As such it is understood that the LUDCL continues to be the class loader that loaded the class containing the MainMethod1 method.

The present subject matter may also identify a transition from methods belonging to classes loaded by a bootstrap class loader to a user defined class loader during the de serialization process and then subsequently identify a re transition back from methods belonging to classes loaded by user defined class loaders to methods belonging to classes loaded by the bootstrap class loader. The second example pseudo thread method frame stack below builds upon the first example pseudo thread method frame stack described above.

As can be seen from the second example pseudo thread method frame stack above the bottom five 5 method frames are identical to the frames described in association with the first example pseudo thread method frame stack above. There are several additional frames shown on the second example pseudo thread method frame stack.

It should be noted that it is assumed for purposes of the present example that the method frame OutsideAggregation1Method1 belongs to a class loaded by a non null user defined class loader different from the user defined class loader that loaded the class that the MainMethod1 method belongs to. It is further assumed that the methods corresponding to the method frame StartAggregation2 until EndAggregation2 belong to classes loaded by the bootstrap class loader.

As with the first example pseudo thread method frame stack above upon transitioning back to method frames corresponding to methods of classes loaded by the bootstrap class loader a stack walk is initiated at the StartAggregation2 method. This second stack walk identifies a new LUDCL at the stack frame corresponding to the OutsideAggregation1Method1 method. The class loader that loaded the class containing the method OutsideAggregation1Method1 is returned as the LUDCL by the stack walk and the new LUDCL is pushed on top of the LUDCL stack.

It should be noted that if the class containing the method OutsideAggregation1Method1 is loaded by the bootstrap class loader whether it is a user defined method or other method then the stack walk initiated at StartAggregation2 would not terminate at the OutsideAggregation1Method1 method. In either situation the stack walk would continue further until a user defined class loader or a marked method frame is identified detected. Within the present example the stack walk would terminate at the EndAggregation1 method frame. Additionally since there is no change to the LUDCL the LUDCL stack top would not change and it would continue to point to the reference of the class loader of the class containing the MainMethod1 method.

The method frame EndAggregation2 represents the last frame loaded by the bootstrap loader for the current aggregation. As such the EndAggregation2 method frame is also marked within the second example pseudo thread method frame stack such as by using the LUDCLMarkFrame API as described above in association with the EndAggregation1 method frame.

The process of de serialization may then proceed further for reconstruction recreation of an object instance from the serialized data object. Creation of instances of classes involve loading of the respective class type. In order to perform the class loading operation the latest user defined class loader is used. The third example pseudo thread method frame stack below illustrates processing for identification of the LUDCL.

As can be seen from the third example pseudo thread method frame stack the GetLatestUserDefinedLoader method frame has been invoked and is at the top of the third example pseudo thread method frame stack. Otherwise the third example pseudo thread method frame stack is identical to the second example pseudo thread method frame stack described above. In response to invocation of the GetLatestUserDefinedLoader method the LUDCL stack is first looked up e.g. identified . If the LUDCL stack is not empty a peek operation on the LUDCL stack is performed to get the LUDCL. The peek operation in the present example will return the loader of the class containing the method OutsideAggregation1Method1 as the LUDCL since this LUDCL is found on the top of the LUDCL stack.

The following example pseudo LUDCL stack depicts a representation of what an LUDCL stack may include in response to processing through the second example pseudo thread method frame stack described above. It is understood that the following example pseudo LUDCL stack may be stored in a memory location such as the LUDCL stack storage area of the memory .

As can be seen from the example pseudo LUDCL stack above only two references to user defined class loaders are stored on the pseudo LUDCL stack. The first reference stored e.g. the bottom reference represents a reference to the UDCL that loaded the MainMethod1 method frame. The second reference stored e.g. the top reference represents a reference to the UDCL that loaded the OutsideAggregation1Method1 method frame. Again as described above the reference to the UDCL that is pushed on the LUDCL stack may be any form of reference to the UDCL as appropriate for a given implementation. For example the reference to the UDCL may include a pointer address a class name or any other form of reference appropriate for a given implementation.

As such at block the process starts object de serialization. At decision point the process makes a determination as to whether a transition has been detected from a user defined class loader to the bootstrap loader. Such a transition as described above represents a start of aggregation within a thread stack. In response to determining that a start of aggregation has been detected the process searches for the LUDCL in the current thread stack at block . As such the process searches from a top of the aggregated method frame stack for a first one of a marked end of an aggregated sequence of methods belonging to classes loaded by the bootstrap class loader and a method frame belonging to a class loaded by one of the at least one user defined class loader.

At decision point the process makes a determination as to whether a non null value has been returned from the thread stack search e.g. via a peek operation which indicates that a user defined class loader has been identified. In response to determining that a non null value has been returned from the thread stack search the process pushes a reference to the LUDCL on the LUDCL stack at block . As such the process stores in response to first finding the method frame belonging to a class loaded by one of the at least one user defined class loader a reference to the at least one user defined class loader on a separate LUDCL stack as the LUDCL and as such identifies in response to a non null reference returned from the peek operation the non null reference as the LUDCL. Within the present example the reference represents an address of the user defined class loader. However any other form of reference may be used as appropriate for a given implementation.

In response to either pushing the reference on the LUDCL stack at block determining at decision point that a non null value has not been returned from the thread stack search or determining at decision point that a start of aggregation has not been detected the process makes a determination at decision point as to whether the current iteration involves de serialization execution. In response to determining that the current iteration involves de serialization execution the process loads a class for the user defined object at block . Detailed processing associated with block will be described below in association with . At block the process instantiates the respective object using the loaded class.

In response to instantiating the respective object at block or in response to determining at decision point that the current iteration does not involve de serialization execution the process makes a determination as to whether an end of aggregation is detected at decision point . As described above detection of an end of aggregation represents detecting a transition from a method belonging to a class loaded by a bootstrap loader to a method belonging to a class loaded by a user defined class loader. In response to determining that an end of aggregation has been detected the process invokes the markFrame API at block . As such the process marks a last method frame belonging to class loaded by the bootstrap loader within the aggregated method frame stack where the marked last method frame belonging to the class loaded by the bootstrap loader identifies an end of an aggregated sequence of methods loaded by the bootstrap class loader. In response to either invoking the markFrame API at block or determining at decision point that an end of aggregation has not been detected the process makes a determination as to whether further recursion is needed to de serialize the received serialized data object at decision point . In response to determining that further recursion is needed to de serialize the received serialized data object the process returns to block and iterates as described above for each such recursion. In response to determining at decision point that no further recursion is needed to de serialize the received serialized data object e.g. that de serialization of the received serialized data object is completed the process determines that de serialization of the serialized data object is completed and begins recursively exiting each entered method by automatically invoking processing to exit all invoked methods used for de serialization of the object beginning with decision point .

At decision point the process makes a determination as to whether to pop an LUDCL reference from the LUDCL stack. For example the process may determine relative to a pending exit from a method that pushed an LUDCL reference on the LUDCL stack to pop the pushed LUDCL reference from the stack. In response to determining to pop an LUDCL from the LUDCL stack the process invokes the popLUDCL API at block . In response to completion of the invocation of the popLUDCL API at block or in response to a determination at decision point not to pop an LUDCL from the LUDCL stack the process makes a determination at decision point as to whether to unmark the current method frame. As such the process determines whether each method frame represents a marked method frame to be unmarked.

In response to determining to unmark the current method frame at decision point the process invokes the unMarkFrame API at block . As such the process iterates to unmark each method frame determined to include the marked method frame. It should be noted that if a method invokes the markFrame API the unMarkFrame API is invoked during exit of the method. In response to completion of the unMarkFrame API at block or in response to determining not to unmark the current method frame at decision point the process returns from the method at block . At decision point the process makes a determination as to whether an end of recursion has been detected. In response to determining that additional nested method invocations are present and that an end of recursion has not been detected the process returns to decision point and iterates as described above. In response to determining that an end of recursion has been detected at decision point the process returns to decision point to await a new message for de serialization.

The process starts at in response to entry into block of . At decision point the process makes a determination as to whether the LUDCL stack is empty. In response to determining that the LUDCL stack is not empty the process performs a peek operation on the LUDCL stack to retrieve a reference to the LUDCL stored on the LUDCL stack at block . In response to determining that the LUDCL stack is empty at decision point the process walks the thread method frame stack to identify the LUDCL at block . At block the identified LUDCL from the respective processing at one of block and is returned.

At decision point the process makes a determination as to whether the returned LUDCL is null. In response to determining that the returned LUDCL is not null the process uses the returned LUDCL to load the class at block . At decision point the process makes a determination as to whether the class load operation was successful. In response to determining that the class load operation was successful at decision point the process ends at and returns to the processing associated with block of .

In response to determining that the class load operation was not successful at decision point or in response to determining that the returned LUDCL was null at decision point the process utilizes the default class loader e.g. the RMI class loader for purposes of the present example to load the class at block . At decision point the process makes a determination as to whether the class load operation utilizing the default class loader was successful. In response to determining that the class load operation utilizing the default class loader was not successful the process throws an exception e.g. error indication at block . In response to either throwing the exception at block or in response to determining that the class load operation utilizing the default class loader was successful at decision point the process ends at and returns to the processing associated with block of .

As described above in association with through the example systems and processes provide method frame aggregation for latest user defined class loader LUDCL identification. Many other variations and additional activities associated with method frame aggregation for latest user defined class loader LUDCL identification are possible and all are considered within the scope of the present subject matter.

Those skilled in the art will recognize upon consideration of the above teachings that certain of the above examples are based upon use of a programmed processor such as the CPU . However the invention is not limited to such example embodiments since other embodiments could be implemented using hardware component equivalents such as special purpose hardware and or dedicated processors. Similarly general purpose computers microprocessor based computers micro controllers optical computers analog computers dedicated processors application specific circuits and or dedicated hard wired logic may be used to construct alternative equivalent embodiments.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention have been described with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable storage medium that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable storage medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the currently available types of network adapters.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

