---

title: Auditing authorization decisions
abstract: The auditing of authorization decisions is facilitated by integrating or coupling an audit policy to access control decisions. In an example implementation, an audit policy of an auditing scheme is coupled to a semantic framework of an access control scheme such that the audit policy is specified using at least a portion of the semantic framework. In another example implementation, audit policy rules include audit content rules that specify what audit information from any of the inputs, the outputs, or the internal data of authorization decisions is to be included in an audit record. In yet another example implementation, a semantic of an audit trigger rule comports with a semantic framework of an access request and of a logical evaluation for an authorization decision.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08225378&OS=08225378&RS=08225378
owner: Microsoft Corporation
number: 08225378
owner_city: Redmond
owner_country: US
publication_date: 20101012
---
This application is a continuation of and claims the benefit of priority of U.S. patent application Ser. No. 11 530 439 filed on Sep. 9 2006 the disclosure of which is incorporated by reference herein.

Computers and other electronic devices are pervasive in the professional and personal lives of people. In professional settings people exchange and share confidential information during project collaborations. In personal settings people engage in electronic commerce and the transmission of private information. In these and many other instances electronic security is deemed to be important.

Electronic security paradigms can keep professional information confidential and personal information private. Electronic security paradigms may involve some level of encryption and or protection against malware such as viruses worms and spyware. Both encryption of information and protection from malware have historically received significant attention especially in the last few years.

However controlling access to information is an equally important aspect of securing the safety of electronic information. This is particularly true for scenarios in which benefits are derived from the sharing and or transferring of electronic information. In such scenarios certain people are to be granted access while others are to be excluded.

Access control has been a common feature of shared computers and application servers since the early time shared systems. There are a number of different approaches that have been used to control access to information. They share a common foundation in combining authentication of the entity requesting access to some resource with a mechanism of authorizing the allowed access. Authentication mechanisms include passwords Kerberos and x.509 certificates. Their purpose is to allow a resource controlling entity to positively identify the requesting entity or information about the entity that it requires.

Authorization examples include access control lists ACLs and policy based mechanisms such as the eXtensible Access Control Markup Language XACML or the PrivilEge and Role Management Infrastructure PERMIS . These mechanisms define what entities may access a given resource such as files in a file system hardware devices database information and so forth. They perform this authorization by providing a mapping between authenticated information about a requestor and the allowed access to a resource.

As computer systems have become more universally connected over large networks such as the Internet these mechanisms have proven to be somewhat limited and inflexible in dealing with evolving access control requirements. Systems of geographically dispersed users and computer resources including those that span multiple administrative domains in particular present a number of challenges that are poorly addressed by currently deployed technology.

The auditing of authorization decisions is facilitated by integrating or coupling an audit policy to access control decisions. In an example implementation an audit policy of an auditing scheme is coupled to a semantic framework of an access control scheme such that the audit policy is specified using at least a portion of the semantic framework. In another example implementation audit policy rules include audit content rules that specify what audit information from any of the inputs the outputs or the internal data of authorization decisions is to be included in an audit record. In yet another example implementation a semantic of an audit trigger rule comports with a semantic framework of an access request and of a logical evaluation for an authorization decision.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. Moreover other method system scheme apparatus device media procedure API arrangement protocol etc. implementations are described herein.

In a described implementation security scheme can be overlaid and or integrated with one or more devices which can be comprised of hardware software firmware some combination thereof and so forth. As illustrated d devices with d being some integer are interconnected over one or more networks . More specifically device device device . . . device are capable of communicating over network .

Each device may be any device that is capable of implementing at least a part of security scheme . Examples of such devices include but are not limited to computers e.g. a client computer a server computer a personal computer a workstation a desktop a laptop a palm top etc. game machines e.g. a console a portable game device etc. set top boxes televisions consumer electronics e.g. DVD player recorders camcorders digital video recorders DVRs etc. personal digital assistants PDAs mobile phones portable media players some combination thereof and so forth. An example electronic device is described herein below with particular reference to .

Network may be formed from any one or more networks that are linked together and or overlaid on top of each other. Examples of networks include but are not limited to an internet a telephone network an Ethernet a local area network LAN a wide area network WAN a cable network a fibre network a digital subscriber line DSL network a cellular network a Wi Fi network a WiMAX network a virtual private network VPN some combination thereof and so forth. Network may include multiple domains one or more grid networks and so forth. Each of these networks or combination of networks may be operating in accordance with any networking standard.

As illustrated device corresponds to a user that is interacting with it. Device corresponds to a service that is executing on it. Device is associated with a resource . Resource may be part of device or separate from device .

User service and a machine such as any given device form a non exhaustive list of example entities. Entities from time to time may wish to access resource . Security scheme ensures that entities that are properly authenticated and authorized are permitted to access resource while other entities are prevented from accessing resource .

As illustrated device A includes two security related components a security token and an application . Security token includes one or more assertions . Device B includes five security related components an authorization context a resource guard an audit log an authorization engine and a security policy . Security policy includes a trust and authorization policy an authorization query table and an audit policy .

Each device may be configured differently and still be capable of implementing all or a part of security scheme . For example device A may have multiple security tokens and or applications . As another example device B may not include an audit log or an audit policy . Other configurations are also possible.

In a described implementation authority issues security token having assertions to entity . Assertions are described herein below including in the section entitled Security Policy Assertion Language Example Characteristics . Entity is therefore associated with security token . In operation entity wishes to use application to access resource by virtue of security token .

Resource guard receives requests to access resource and effectively manages the authentication and authorization process with the other security related components of device B . Trust and authorization policy as its name implies includes policies directed to trusting entities and authorizing actions within security environment . Trust and authorization policy may include for example security policy assertions not explicitly shown in . Authorization query table maps requested actions such as access requests to an appropriate authorization query. Audit policy delineates audit responsibilities and audit tasks related to implementing security scheme in security environment .

Authorization context collects assertions from security token which is are used to authenticate the requesting entity and security policy assertions from trust and authorization policy . These collected assertions in authorization context form an assertion context. Hence authorization context may include other information in addition to the various assertions.

The assertion context from authorization context and an authorization query from authorization query table are provided to authorization engine . Using the assertion context and the authorization query authorization engine makes an authorization decision. Resource guard responds to the access request based on the authorization decision. Audit log contains audit information such as for example identification of the requested resource and or the algorithmic evaluation logic performed by authorization engine .

In a described implementation entity authenticates itself to resource guard with a token security token . Resource guard forwards the token assertions to authorization context . These token assertions are assertions of of security token . Security policy provides the authorization query table to resource guard . The authorization query table derives from authorization query table module . The authorization query table sent to resource guard may be confined to the portion or portions directly related to the current access request.

Policy assertions are extracted from trust and authorization policy by security policy . The policy assertions may include both trust related assertions and authorization related assertions. Security policy forwards the policy assertions to authorization context . Authorization context combines the token assertions and the policy assertions into an assertion context. The assertion context is provided from authorization context to authorization engine as indicated by the encircled A .

An authorization query is ascertained from the authorization query table. Resource guard provides the authorization query auth. query to authorization engine . Authorization engine uses the authorization query and the assertion context in an evaluation algorithm to produce an authorization decision. The authorization decision auth. dcn. is returned to resource guard . Whether entity is granted access to resource by resource guard is dependent on the authorization decision. If the authorization decision is affirmative then access is granted. If on the other hand the authorization decision issued by authorization engine is negative then resource guard does not grant entity access to resource .

The authorization process can also be audited using semantics that are complementary to the authorization process. The auditing may entail monitoring of the authorization process and or the storage of any intermediate and or final products of e.g. the evaluation algorithm logically performed by authorization engine . To that end security policy provides to authorization engine an audit policy from audit policy . At least when auditing is requested an audit record having audit information may be forwarded from authorization engine to audit log . Alternatively audit information may be routed to audit log via resource guard for example as part of the authorization decision or separately.

Generally a device may represent any computer or processing capable device such as a client or server device a workstation or other general computer device a PDA a mobile phone a gaming platform an entertainment device one of the devices listed above with reference to some combination thereof and so forth. As illustrated device includes one or more input output I O interfaces at least one processor and one or more media . Media include processor executable instructions .

In a described implementation of device I O interfaces may include i a network interface for communicating across network ii a display device interface for displaying information on a display screen iii one or more man machine interfaces and so forth. Examples of i network interfaces include a network card a modem one or more ports and so forth. Examples of ii display device interfaces include a graphics driver a graphics card a hardware or software driver for a screen or monitor and so forth. Printing device interfaces may similarly be included as part of I O interfaces . Examples of iii man machine interfaces include those that communicate by wire or wirelessly to man machine interface devices e.g. a keyboard a remote a mouse or other graphical pointing device etc. .

Generally processor is capable of executing performing and or otherwise effectuating processor executable instructions such as processor executable instructions . Media is comprised of one or more processor accessible media. In other words media may include processor executable instructions that are executable by processor to effectuate the performance of functions by device .

Thus realizations for security related implementations may be described in the general context of processor executable instructions. Generally processor executable instructions include routines programs applications coding modules protocols objects components metadata and definitions thereof data structures application programming interfaces APIs schema etc. that perform and or enable particular tasks and or implement particular abstract data types. Processor executable instructions may be located in separate storage media executed by different processors and or propagated over or extant on various transmission media.

Processor s may be implemented using any applicable processing capable technology. Media may be any available media that is included as part of and or accessible by device . It includes volatile and non volatile media removable and non removable media and storage and transmission media e.g. wireless or wired communication channels . For example media may include an array of disks flash memory optical media for longer term mass storage of processor executable instructions random access memory RAM for shorter term storing of instructions that are currently being executed link s on network for transmitting communications e.g. security related data and so forth.

As specifically illustrated media comprises at least processor executable instructions . Generally processor executable instructions when executed by processor enable device to perform the various functions described herein including those actions that are illustrated in the various flow diagrams. By way of example only processor executable instructions may include a security token at least one of its assertions an authorization context module a resource guard an audit log an authorization engine a security policy e.g. a trust and authorization policy an authorization query table and or an audit policy etc. some combination thereof and so forth. Although not explicitly shown in processor executable instructions may also include an application and or a resource .

This section describes example characteristics of an implementation of a security policy assertion language SecPAL . The SecPAL implementation of this section is described in a relatively informal manner and by way of example only. It has an ability to address a wide spectrum of security policy and security token obligations involved in creating an end to end solution. These security policy and security token obligations include by way of example but not limitation describing explicit trust relationships expressing security token issuance policies providing security tokens containing identities attributes capabilities and or delegation policies expressing resource authorization and delegation policies and so forth.

In a described implementation SecPAL is a declarative logic based language for expressing security in a flexible and tractable manner. It can be comprehensive and it can provide a uniform mechanism for expressing trust relationships authorization policies delegation policies identity and attribute assertions capability assertions revocations audit requirements and so forth. This uniformity provides tangible benefits in terms of making the security scheme understandable and analyzable. The uniform mechanism also improves security assurance by allowing one to avoid or at least significantly curtail the need for semantic translation and reconciliation between disparate security technologies.

A SecPAL implementation may include any of the following example features 1 SecPAL can be relatively easy to understand. It may use a definitional syntax that allows its assertions to be read as English language sentences. Also its grammar may be restrictive such that it requires users to understand only a few subject verb object e.g. subject verb phrase constructs with cleanly defined semantics. Finally the algorithm for evaluating the deducible facts based on a collection of assertions may rely on a small number of relatively simple rules.

 2 SecPAL can leverage industry standard infrastructure in its implementation to ease its adoption and integration into existing systems. For example an extensible markup language XML syntax may be used that is a straightforward mapping from the formal model. This enables use of standard parsers and syntactic correctness validation tools. It also allows use of the W3C XML Digital Signature and Encryption standards for integrity proof of origin and confidentiality.

 3 SecPAL may enable distributed policy management by supporting distributed policy authoring and composition. This allows flexible adaptation to different operational models governing where policies or portions of policies are authored based on assigned administrative duties. Use of standard approaches to digitally signing and encrypting policy objects allow for their secure distribution. 4 SecPAL enables an efficient and safe evaluation. Simple syntactic checks on the inputs are sufficient to ensure evaluations will terminate and produce correct answers.

 5 SecPAL can provide a complete solution for access control requirements supporting required policies authorization decisions auditing and a public key infrastructure PKI for identity management. In contrast most other approaches only manage to focus on and address one subset of the spectrum of security issues. 6 SecPAL may be sufficiently expressive for a number of purposes including but not limited to handling the security issues for Grid environments and other types of distributed systems. Extensibility is enabled in ways that maintain the language semantics and evaluation properties while allowing adaptation to the needs of specific systems.

As illustrated at the top row of assertion format an example assertion at a broad level includes a principal portion a says portion and a claim portion . Textually the broad level of assertion format may be represented by principal says claim.

At the next row of assertion format claim portion is separated into example constituent parts. Hence an example claim portion includes a fact portion an if portion n conditional factportions . . . and a c portion . The subscript n represents some integer value. As indicated by legend c portion represents a constraint portion. Although only a single constraint is illustrated c portion may actually represent multiple constraints e.g. c . . . c . The set of conditional fact portions . . . and constraints . . . on the right hand side of if portion may be termed the antecedent.

Textually claim portion may be represented by fact if fact . . . fact c. Hence the overall assertion format may be represented textually as follows principal says fact if fact . . . fact c. However an assertion may be as simple as principal says fact. In this abbreviated three part version of an assertion the conditional portion that starts with if portion and extends to c portion is omitted.

Each fact portion may also be further subdivided into its constituent parts. Example constituent parts are an e portion and a verb phrase portion . As indicated by legend e portion represents an expression portion. Textually a fact portion may be represented by e verbphrase.

Each e or expression portion may take on one of two example options. These two example expression options are a constant and a variable . Principals may fall under constants and or variables .

Each verb phrase portion may also take on one of three example options. These three example verb phrase options are a predicate portion followed by one or more eportions . . . a can assert portion followed by a fact portion and an alias portion followed by an expression portion . Textually these three verb phrase options may be represented by predicate e. . . e can assert fact and alias e respectively. The integer n may take different values for facts . . . and expressions . . . .

Generally SecPAL statements are in the form of assertions made by a security principal. Security principals are typically identified by cryptographic keys so that they can be authenticated across system boundaries. In their simplest form an assertion states that the principal believes a fact is valid e.g. as represented by a claim that includes a fact portion . They may also state a fact is valid if one or more other facts are valid and some set of conditions are satisfied e.g. as represented by a claim that extends from a fact portion to an if portion to conditional fact portions . . . to a c portion . There may also be conditional facts . . . without any constraints and or constraints without any conditional facts . . . .

In a described implementation facts are statements about a principal. Four example types of fact statements are described here in this section. First a fact can state that a principal has the right to exercise an action s on a resource with an action verb . Example action verbs include but are not limited to call send read list execute write modify append delete install own and so forth. Resources may be identified by universal resource indicators URIs or any other approach.

Second a fact can express the binding between a principal identifier and one or more attribute s using the possess verb. Example attributes include but are not limited to email name common name group name role title account name domain name server service DNS name internet protocol IP address device name application name organization name service name account identification identifier ID and so forth. An example third type of fact is that two principal identifiers can be defined to represent the same principal using the alias verb.

 Qualifiers or fact qualifiers may be included as part of any of the above three fact types. Qualifiers enable an assertor to indicate environmental parameters e.g. time principal location etc. that it believes should hold if the fact is to be considered valid. Such statements may be cleanly separated between the assertor and a relying party s validity checks based on these qualifier values.

An example fourth type of fact is defined by the can assert verb. This can assert verb provides a flexible and powerful mechanism for expressing trust relationships and delegations. For example it allows one principal A to state its willingness to believe certain types of facts asserted by a second principal B . For instance given the assertions A says B can assert fact0 and B says fact0 it can be concluded that A believes fact0 to be valid and therefore it can be deduced that A says fact0 .

Such trust and delegation assertions may be i unbounded and transitive to permit downstream delegation or ii bounded to preclude downstream delegation. Although qualifiers can be applied to can assert type facts omitting support for qualifiers to these can assert type facts can significantly simplify the semantics and evaluation safety properties of a given security scheme.

In a described implementation concrete facts can be stated or policy expressions may be written using variables. The variables are typed and may either be unrestricted e.g. allowed to match any concrete value of the correct type or restricted e.g. required to match a subset of concrete values based on a specified pattern .

Security authorization decisions are based on an evaluation algorithm e.g. that may be conducted at authorization engine of an authorization query against a collection of assertions e.g. an assertion context from applicable security policies e.g. a security policy and security tokens e.g. one or more security tokens . Authorization queries are logical expressions which may become quite complex that combine facts and or conditions. These logical expressions may include for example AND OR and or NOT logical operations on facts either with or without attendant conditions and or constraints.

This approach to authorization queries provides a flexible mechanism for defining what must be known and valid before a given action is authorized. Query templates e.g. from authorization query table form a part of the overall security scheme and allow the appropriate authorization query to be declaratively stated for different types of access requests and other operations actions.

Auditing is desirable in modern computing systems including distributed systems. Distributed systems in particular usually involve complex interactions between multiple entities. They also have many potential failure points. Auditing provides a mechanism for collecting information about those interactions so that one can later review authorized interactions attempts to engage in unauthorized interactions malicious attacks against the system combinations thereof and so forth.

With existing auditing approaches a deficiency is that they are designed and implemented independently from access control policies. In fact existing approaches to access control policy such as ACLs XACML REL etc. fail to define any way to specify audit behaviors. Furthermore they do not address what information is to be logged.

The result is that conventional ad hoc audit systems define their own policy mechanism. This is typically based solely on the end result of some authorization decision. There is therefore little if any interface or insight into the specifics of the authorization decision process which limits the granularity of the audit collection.

Similarly how audit information is to be collected is specified independently from the access control policy. This has two negative impacts First the audit system is unaware of all the information that is actually used in reaching the authorization decision and may therefore not accurately collect it. Second the audit information is independent of the authentication and authorization process. It therefore requires semantic translation with an attendant possible loss of information from the authenticated data and policies that are input into the authorization decision process.

In contrast certain implementations as described herein address these problems by coupling access control mechanisms and audit mechanisms based on the same semantics. More specifically a described auditing scheme enables the specification of an audit policy including audit triggers and collected audit content in a manner that is integrated with an access control scheme by utilizing the same or similar semantics.

In an example implementation a security authorization paradigm provides a mechanism for specifying an audit policy that is tightly coupled to an access control policy. First it enables audit instructions to be expressed in a manner that reflects the scope of the access control policy. For example the audit instructions can be expressed in terms of resources the access rights to those resources and so forth. Second it enables the specification of what information is to be logged in terms of for example the authenticated inputs the input trust and authorization policy the internal logical deductions upon which an authorization decision is based and so forth.

In a described implementation auditing scheme is integrated with access control scheme via a coupling between them at the semantic level. More specifically audit policy is coupled to semantic framework as indicated by coupling arrow .

Semantic framework represents the semantics of an access control scheme and or language such as the implementations described herein above. Accordingly semantic framework includes at least assertions and authorization queries . Although not explicitly shown in semantic framework may include other aspects beyond the illustrated two such as resource names potential actions resource specific operations and so forth.

Assertions may be token assertions policy assertions and so forth. They can form the basis of security tokens e.g. security token of trust and authorization policies e.g. trust and authorization policy and so forth. Authorization queries may be authorization queries that indicate when how to what extent etc. a resource may be accessed if certain matching authenticated assertions are valid. They can be located in a query table e.g. authorization query table .

Audit policy specifies auditing instructions using the same semantic as semantic framework . These auditing instructions are referred to generally as audit policy rules . Accordingly audit trigger rules T and audit content rules C both utilize at least in part the same semantic as semantic framework . More generally the semantics of audit policy rules may be considered to comport with semantic framework of access control scheme . Although not explicitly shown in audit policy may include other audit rule types beyond the illustrated two.

Audit trigger rules T are rules that specify when an audit record should be generated they utilize a semantic that comports with semantic framework of access control scheme . In other words audit trigger rules T are rules that trigger auditing. Audit content rules C are rules that specify what audit information should be included in an audit record. Audit content rules C make this specification utilizing semantic framework . Additionally the resulting generated audit record is returned with audit information that also comports with semantic framework .

Authorization decision result T is a rule that specifies that auditing is to be triggered when a particular authorization decision is made. The authorization decision may be yes no some other specialized decision and so forth. For instance auditing may be triggered each time an access request is denied but not necessarily when an access request is granted. Targeted resource T is a rule that specifies that auditing is to be triggered when a particular resource is targeted for access by an access request. For instance a particular resource may be especially important so access requests to it are instructed to trigger an audit regardless of any other relatively innocuous parameters of the access request. To comport with semantic framework the targeted resource is specified in the same manner e.g. with an identical naming mechanism as how it is specified in access control scheme .

Requested action T is a rule that specifies that auditing is to be triggered when a particular action is requested. For instance all write requests or all attempts to execute a program may be set to trigger an audit because they are considered especially risky or dangerous. To comport with semantic framework the requested action is specified in the same manner as how it is specified in access control scheme . Operation on resource T is a rule that specifies that auditing is to be triggered when a particular operation is requested on a particular resource. For instance auditing may be set to be triggered whenever a risky operation is requested to be performed on an especially important or vulnerable resource. To comport with semantic framework the resource specific operation is specified in the same manner as how it is specified in access control scheme .

These four or any other trigger mechanisms enable an author of an audit policy to specify when audit information is recorded. They may also be combined in any manner. For example authorization decision result trigger T may be combined with any of the other three illustrated audit triggers to specify flexible auditing rules that are responsive to whether or not a particular access request is or is not authorized.

An author of an audit policy can specify what audit information is included in an audit record using audit content rules C . The returned audit information comports with semantic framework by being for example any of the same information that is used as part of access control scheme . The capability to specify the audit information to be logged may be accomplished by referencing specific types of information used in making an access control decision.

Hence audit content rules C may specify token e.g. authenticated assertions C and or policy assertions C . Audit content rules C may also specify requested authorization decision C . For example the incoming access request and or the corresponding authorization query used in the logical evaluation may be returned as part of the audit information.

Audit content rules C may also specify that logical deduction data C is to be included in the returned logical deduction data. Logical deduction data is the data operated on and produced when performing a logical evaluation including a logical evaluation algorithm of an authorization engine of . It can include initial and intermediate logical deduction data as well as final logical deduction data. It can also indicate logical deduction paths or links in a logical chain of deductions that lead to an authorization decision result. An example of logical deduction data is described herein below with reference to .

The audit information specified by audit content rules C may be supplemented with a fixed set of general information about the decision environment. Examples of such general information include but are not limited to the date and time a decision is made a device where the decision is made an application identity of the decision enforcer and so forth. To ensure administrators are alerted to critical security events an additional communication mechanism may be implemented. This communication related mechanism is for indicating where audit events are to be logged and or whether they are to generate events that administrators may subscribe to.

In a described implementation security policy includes audit policy and audit policy rules . Security policy module provides audit policy rules to authorization engine . As shown audit policy rules can include one or more audit trigger rules T and or one or more audit content rules C .

Authorization engine includes assertion context authorization query evaluation algorithm and authorization decision . With reference also to authorization engine receives assertion context from authorization context . Assertion context may include token assertions and or policy assertions. Additionally authorization engine receives authorization query from resource guard . Authorization query is extracted from authorization query table responsive to an access request e.g. after being translated into a resource specific operation .

Evaluation algorithm performs a logical evaluation or analysis on authorization query in conjunction with assertion context . Inputs to evaluation algorithm thus include assertion context and authorization query . During the logical analysis evaluation algorithm produces logical deduction data . Logical deduction data can include original assertions intermediate deductive assertions e.g. deductions final deductions and so forth.

Evaluation algorithm produces a TRUE or FALSE result e.g. optionally represented as a set of variables satisfying the logical analysis on authorization query . The result is converted to an authorization decision that indicates whether the requested access should be granted or denied. Authorization decision is output from authorization engine and forwarded to resource guard .

In accordance with audit policy rules authorization engine generates an audit record and forwards audit record to audit log . Audit record is generated responsive to detection of any audit triggers specified in audit trigger rules T . The audit information included in audit record is based on audit content rules C . The audit information may be recorded constantly and provided as audit record only when a trigger is detected or audit information may only be recorded when a trigger is detected.

In a described implementation at block audit trigger rules are specified. For example audit trigger rules T may be accepted from a user as part of an audit policy of security policy and provided to authorization engine . At block audit content rules are specified. For example audit content rules C may be accepted from a user as part of an audit policy of security policy and provided to authorization engine .

At block an access request is received. For example an access request from a requesting entity may be received at resource guard . Based on this access request including an identified targeted resource any authenticated assertions and or a local trust and authorization policy an assertion context and an authorization query are provided to authorization engine .

At block a logical evaluation of an authorization query is performed in conjunction with an assertion context to derive an authorization decision. The logical evaluation produces or otherwise includes logical deduction data. For example an evaluation algorithm of authorization engine may perform a logical evaluation of authorization query in conjunction with assertion context to derive authorization decision . The logical evaluation may include logical deduction data which can include input assertion s intermediate deduction s and final deduction s .

At block it is determined if a trigger is detected responsive to the audit trigger rules. For example authorization engine may determine if any of audit trigger rules T are satisfied by e.g. match the current evaluation situation including the access request assertions query result and so forth. If not then a next access request is awaited at block .

If on the other hand it is determined at block that a trigger is detected then at block an audit record is generated based on the audit content rules. For example an audit record may be generated based on audit content rules C . At block the audit record is forwarded to an audit log. For example audit record may be forwarded from authorization engine to audit log where it may be reviewed by a user. Alternatively or additionally an event may be generated that is transmitted to one or more event subscribers. The event may be confined to notification that an audit record has been generated or it may include all or a portion of the audit record. The next access request is awaited at block .

A logical deduction chain is indicated at least in part by directed edges which represent links in the logical deduction chain. The direction of the edge indicates a dependency relationship between the nodes. Directed edge and directed edge point from node and from node respectively to node . Thus directed edges and indicate that assertion 3 is deduced from assertions 1 and 2 . Example assertions 1 2 and 3 are provided below to describe the concepts behind proof graph more concretely.

In a described implementation generally a proof graph represents the logical reasoning over an authorization context that led to an authorization decision e.g. so as to satisfy an authorization query . The root nodes e.g. nodes and of the proof graph are the assertions originating from within the assertion context. Nodes are added to the graph for each deduced assertion. Nodes are connected by directed edges e.g. directed edges and indicating which assertions led to a deduced assertion. A node which contributes to no deductions is referred to as a terminal node. Although not shown in a proof graph may also include one or more intermediate levels having at least one intermediate node apiece.

As a relatively simple example the following assertion context containing two assertions is presented 

The following authorization query is given A says C read foo.txt. To prove this authorization query it is noted that from assertions 1 and 2 it can be deduced that the following assertion 3 is valid 

The example assertions 1 2 and 3 above may be mapped to nodes and respectively of proof graph . If there were other assertions in the assertion context they would not have contributed to the proof of the authorization query and would therefore not be part of the proof graph showing that the authorization query can be satisfied.

When included as part of an audit record a proof graph may be rendered for example in textual form or in another serialized form allowing for compact storage or application of widely used search technology. For instance a proof graph may be rendered as serialized XML. More specifically a proof graph element may have one or more proof nodes each of which corresponds to an individual assertion. These nodes jointly contain the collection of assertions that lead to the conclusion that the authorization query is satisfied.

Each node also contains a set of child proof nodes that led to the conclusion that the assertion corresponding to the node is valid. Each of those child proof nodes in turn contains the nodes used to deduce its validity unless it represents a root node. In effect the XML can encode the proof graph in an inverted tree structure. A tree structure facilitates identification of the assertions that prove the authorization query is satisfiable and an understanding of why those assertions are valid.

Duplication of information in a single proof graph may be reduced by referencing to a proof node that appears multiple times within the single proof graph e.g. because a single assertion can contribute to multiple deductions . When the logical analysis of evaluation algorithm is undertaken using a different format from the original semantic of the input assertions authorization queries etc. a conversion back to the original semantic may be performed prior to the outputting of the audit record to the audit log. This enables the semantic framework of the access control policy to be faithfully reproduced in the audit log without requiring an external translation that risks corrupting or otherwise altering the desired audit information.

The devices actions aspects features functions procedures modules data structures protocols components etc. of are illustrated in diagrams that are divided into multiple blocks. However the order interconnections interrelationships layout etc. in which are described and or shown are not intended to be construed as a limitation and any number of the blocks can be modified combined rearranged augmented omitted etc. in any manner to implement one or more systems methods devices procedures media apparatuses APIs protocols arrangements etc. for auditing authorization decisions.

Although systems media devices methods procedures apparatuses mechanisms schemes approaches processes arrangements and other implementations have been described in language specific to structural logical algorithmic and functional features and or diagrams it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

