---

title: Access to a target object with desired functionality
abstract: A system and method provide access to a target object associated with a desired functionality. This is accomplished by creating an instance of a pre-existing object, replacing one or more functions of a table shared by all objects of the object's class, and triggering a call that ultimately causes the replacement functions to be called to allow access to the target object. The system includes software portions for enabling the method.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08225328&OS=08225328&RS=08225328
owner: Google Inc.
number: 08225328
owner_city: Mountain View
owner_country: US
publication_date: 20100105
---
This application is a continuation of U.S. patent application Ser. No. 11 057 322 now U.S. Pat. No. 7 644 416 entitled Access to a Target Object with Desired Functionality filed on Feb. 10 2005 which is incorporated herein by reference.

This invention relates generally to accessing software objects with a desired functionality and more specifically to accessing software objects to enable deskbands.

In environments that rely on object oriented systems some software objects may not be directly accessible. However one may want to access certain functionality associated with target objects that are not directly accessible to implement enable or otherwise make use of such functionality. For some such functionality mechanisms for indirectly accessing the target objects may be unknown or obfuscated.

An example of one such desired functionality is the enablement of deskbands on graphical user interfaces GUIs . A deskband is a type of taskbar object which is dockable on the taskbar or floats on the screen and includes one or more deskband objects. A taskbar is a visual device on the desktop that typically shows the user which applications tasks are currently active and running Clicking on one type of deskband object launches the application or file associated with the object. Another types of deskband allows text entry as part of a search. One advantage of using deskbands for applications or files is that they take up very little GUI space. In addition deskbands may be displayed regardless of whether another application program is running making them continuously accessible.

Creating deskbands for applications generally requires the end user to participate in the installation process. The installation process requires for example implementation of several interfaces and a special registration procedure. However the steps involved in the installation process may be confusing to the user. In the Microsoft Windows 2000 operating system a component object model COM interface exists for creating deskband objects however no known mechanism exists to get to the implementation of this interface without user interaction.

Prior deskband installations have attempted to remedy this problem by providing text or animated instructions for the user. However such instructions require significant user involvement and time. Prior attempts to install deskbands without direct user interaction have included on screen simulations of user actions. Such simulations have a substantial likelihood of failure due to inadvertent user interference with the process. In addition these simulations create a flicker on the screen that is visible to the user during installation.

Thus what is desired is a method that helps overcome one or more of the above described limitations to provide access to objects associated with a desired functionality for example enablement of deskbands.

The present invention enables programmatic access to a target object where there is otherwise no or limited access due to the design or implementation of the host operating system. Target objects include for example deskband objects widgets controls and any other type of programmatic entity. In one embodiment access to a target object is provided by creating an object of the same class as a pre existing object. The pre existing object s behavior is made up of functions in various procedure tables that store references to procedures of the object. The procedure tables are shared with all other class members including the newly created object. At least one of the shared tables is modified by replacing one or more of the existing procedure references to an alternative procedure that provides access to the target object. From there a call can be made to execute the alternative procedure to allow access to the target object.

In one embodiment of the invention a method and system for accessing an object associated with enabling a deskband includes creating an object of the same class as a pre existing object. The method also includes modifying one or more tables shared by the created object and the pre existing object by replacing one or more entries with alternative procedures that provide access to the target object. Further the method includes triggering a call that executes the alternative procedures to allow access to the object associated with enabling a deskband.

In one embodiment of the invention a method and system for accessing a target object includes modifying one or more tables shared by the created object and the pre existing object by replacing one or more entries with alternative procedures that emulate user actions to provide access to the target object. The method also includes triggering a call that executes the alternative procedures to allow access to the target object.

The figures depict a preferred embodiment of the present invention for purposes of illustration only. One skilled in the art will readily recognize from the following discussion that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles of the invention described herein.

Next a function table associated with the newly created object is modified . A function table stores references e.g. handles pointers memory addresses to methods or procedures of the class. Every class has associated with it one or more function tables that store these function references. When a new instance of a class is created it holds a reference to at least one of the function tables such function tables are called shared tables. Other function tables may be specific to an individual object. In one embodiment the modification includes the replacement of an existing function reference in a shared function table with an alternative procedure also known as a hook. In one embodiment the replaced function is peripheral to the main functionality provided by the shared table. However even a main function may be used in which case the alternative procedure also would call the original function to minimize any side effects of the replacement. In one embodiment the first few bytes of the implementation itself are patched rather than patching a shared table. In this example the first five bytes are modified to include a jump instruction that sends control to an alternative procedure.

The alternative procedure may include multiple functions. The alternative procedure receives a direct or indirect reference to the target object thereby allowing access to the target object where none was previously available. In one embodiment the alternative procedure invokes a pointer it has received to allow direct access to the target object. In this example the target object may be the original object. In another embodiment the alternative procedure invokes a pointer to the original object and uses a method e.g. the IUnknown QueryInterface method to get a second pointer to another target object. In yet another embodiment the alternative procedure also directs a navigation of a contextual menu to programmatically emulate user actions e.g. to simulate the user s actions in using the target object .

Because the original object and the newly created object are of the same class they share the modified function table. Thus calls to either the original or newly created objects will utilize the modified table including the alternative procedure. In one embodiment the shared table is a vtable i.e. a structure in the header of every class object that contains the memory addresses of the actual code associated with the properties and methods implemented by the class. In one embodiment an additional table also may be modified to include an alternative procedure for example an import address table IAT . After the shared function table is modified a call is triggered to execute the alternative procedure of the table. In one embodiment the trigger occurs in the form of a message sent to the original existing object which causes the existing object to read the shard table invoking the alternative procedure. In another embodiment the message also programmatically initiates a context menu for the target object that includes selections related to the desired functionality this will subsequently allow the end user to access specific methods and data associated with the target object. In yet another embodiment the trigger causes the return of a command identifier of a function or access to a menu. In any of these methods any pointer command identifier or access obtained may be stored in memory.

After the alternative procedure is executed and provides access to the target object the target object or the methods of the object may then be accessed . For example a method in an interface implemented by the target object may be invoked. Additional finishing steps may be made at this time as well such as restoring tables to their initial state and or unsubclassing windows if any.

As a preliminary step a dynamic load library DLL implementation is injected into the Explorer.exe process in the Windows operating system e.g. Windows 2000 . This step can be accomplished by any of several means known in the art for example using CreateRemoteThread SetWindowsHookEx or Explorer specific methods such as SHLoadInProc. Next a tray window is found that is known to include key functionality in this example a tray window necessary to enable deskbands. The tray window then is subclassed . Subclassing a window in this example means altering an existing window instance so that messages sent to the existing instance are first processed by the subclassed window which delegates those messages is does not need to handle to the existing instance.

An object or instance of the same class as an existing object or instance is created next. In this example the class is associated with enabling a deskband. Then a table associated with the newly created object or instance is modified or patched such that one of the functions in the table is replaced with an alternative procedure. In this embodiment the table is a vtable shared by the objects of the class including the original object or instance. Thus by replacing a function with an alternative procedure to patch the vtable of one instance of the object all instances will use the alternative procedure.

Next a call is triggered that causes the table to be read. The trigger comes in the form of a WM CONTEXTMENU message sent to the tray window programmatically notifying the window that a right mouse button click has occurred in the window although no click actually occurred. The message causes the existing object to read the shared table invoking the alternative procedure which returns access to an IBandSite object instance associated with deskband enablement. In this embodiment the concept of aggregation and the QueryInterface method of the IUnknown interface are used to get access to the IBandSite object. The first parameter to the alternative procedure function is the this pointer to the object on which the function is being invoked the existing object . Next the alternative procedure calls QueryInterface on the this pointer to get to the IBandSite object. A reference to the IBandSite object which is the target object in this example is then stored . In additional steps the IBandSite object or the methods of the object may then be accessed for the purposes of enabling a deskband e.g. by calling IDeskBand AddBand . Finally the table may be restored to its original state and the window unsubclassed. However because access to the target object was stored the target object remains accessible.

The user devices each include a processor an operating system and a memory . In one embodiment a user device includes a random access memory RAM coupled to the processor . The processor executes computer executable program instructions stored in memory . Such processors may include a microprocessor an ASIC state machines or other processors and can be any of a number of suitable computer processors such as processors from Intel Corporation of Santa Clara Calif. and Motorola Corporation of Schaumburg Ill. Such processors include or may be in communication with code modules of which store instructions that when executed by the processor cause the processor to perform the steps described herein.

User devices may be coupled to a network . User devices also may include a number of external or internal devices such as a mouse a CD ROM DVD a keyboard a display device or other input or output devices. Examples of user devices are personal computers digital assistants personal digital assistants cellular phones mobile phones smart phones pagers digital tablets laptop computers Internet appliances and other processor based devices. In one embodiment the user devices may be any type of processor based platform that operates on any suitable operating system such as Microsoft Windows or Linux and that are capable of executing one or more user application programs. For example the user device can include a personal computer executing user application programs.

Through the user devices users can communicate over the network with each other and with other systems and devices coupled to the network . As shown in a server device can be coupled to the network . The server device can include a server executing a search engine application program such as the Google search engine. In other embodiments the server device can include a related information server or an advertising server. Similar to the user devices the server device can include a processor coupled to a computer readable memory . Server device depicted as a single computer system may be implemented as a network of computer processors. Examples of a server device are servers mainframe computers networked computers a processor based device and similar types of systems and devices. The server processor can be any of a number of computer processors such as processors from Intel Corporation of Santa Clara Calif. and Motorola Corporation of Schaumburg Ill. In another embodiment the server device may exist on a client device. In still another embodiment there can be multiple server devices .

It should be noted that other embodiments of the present invention may include systems having different architecture than that which is shown in .

The modules may be provided to user device on computer readable media such as a CD ROM diskette or by electronic communication over a network from software distributors for installation and execution thereon. Alternatively some modules can be hosted on a server device and accessed over the network by the user for example using a browser interface. Thus the memory dotted line is for illustration purposes only and the modules may be stored in the memories of the user device server device or some combination thereof. In one embodiment the modules are installed in memory of the user device upon the initiation of a download of an executable process over a network .

Specifically the code modules and memory storage areas include an inject module a preparation module a create instance module a modify table module an activation module a store module an access module and a restore module . The code modules and memory storage areas may be communicatively coupled to each other.

The inject module executes logic for injecting code into the Explorer.exe process by any of the methods described above for that purpose. The preparation module executes logic for locating and subclassing a window useful for the desired functionality of the method according to one embodiment of the present invention.

The create instance module executes logic for creating an object or instance of the same class as any existing object or instance. The modify table module executes logic for modifying a table associated with an object. In one embodiment the modification includes the replacement of an existing function in the table with an alternative procedure. In one embodiment more than one table may be modified with more than one alternative procedure.

The activation module executes logic for triggering a call that causes the alternative procedure of the table to execute initiate or otherwise activate. For example the trigger may come in the form of a message that initiates a read of a table and an invocation of the alternative procedure or activates a contextual menu.

The store module executes logic for storing access to objects and menus. The access module executes logic for accessing objects and methods of objects. The restore module executes logic for restoring windows and tables to a previous state. For example an alternative procedure may be removed from a table and or a window may be unsubclassed.

The above software portions need not be discrete software modules. The configuration shown is meant only by way if example other configurations are anticipated by and within the scope of the present invention.

The example implementation begins with a client object that wants to enable a particular deskband. Initially a dynamic load library DLL implementation is injected into the Explorer.exe process in the Windows operating system using any of the methods described herein for that purpose or any other well known method. Next a tray window is found that is known to include key functionality for enabling deskbands. In one embodiment the tray window includes an inner and outer IBandSite object. The IBandSite outer object allows deskband enablement. In this example the tray window class is Shell TrayWnd. The tray window then is subclassed . Next an instance of the IBandSite inner object is created . In one embodiment the instance is cocreated which means that a single unitialized object of the class associated with a specific CSLID is created. In this example the inner object is found in browseui.dll and the CSLID is ECD4FC4D 521C 11D0 B792 00A0C90312E1 Shell Rebar Band Site .

Next the vtable is patched by replacing one of the functions in the vtable of the instance with an alternative procedure or hook. By creating a patch in the vtable of one instance of the object the shared vtable is patched for all objects of the class. In one embodiment the IBandSite EnumBands method is replaced with the alternative procedure. The EnumBands method is used to enumerate the bands in a bandsite is used in this example but other methods could be used as well. The patch establishes an IBandSite hook as the alternative procedure now is included in the vtable shared by all IBandSite instances. A WM CONTEXTMENU message then is sent via a SendMessage or PostMessage function to the tray window. A WM CONTEXTMENU message is a message that notifies a window in this example the tray window that the user clicked the right mouse button right clicked in the window.

As a result of receiving the WM CONTEXTMENU message Explorer.exe creates a context menu that it intends to show. To populate the context menu it needs to call the IBandSite EnumBands function. It retrieves the pointer to this function from a specific position in the IBandSite vtable. Because the pointer in this position in the vtable has been replaced with a pointer to the alternative procedure it instead receives a pointer to the alternative procedure which it then calls. The first parameter is the this pointer as described above. The this pointer is a pointer to the inner IBandSite object which the QueryInterface method can be called on to retrieve the IUnknown interface. In one embodiment the outer and inner IBandSite objects have a containment delegation relationship. The outer object is said to contain the inner object. Thus when methods of the outer object are called the outer object delegates the implementation to the inner object s methods. In addition the relationship between the inner and outer objects is a specialized case of containment and delegation known as aggregation in which the outer object exposes interfaces from the inner object as if they were its own. Due to the rules of COM aggregation QueryInterface on an inner aggregated object will always return the pointer to the IUnknown interface of the outer object from which any other COM interface implemented by the outer object can be retrieved including in this case IBandSite. Therefore the function that is invoked with respect to the outer object is redirected to the inner object. The replaced function of the inner object then uses the QueryInterface method of the IUnknown interface to get a pointer to the outer object. Specifically the inner object acts as a client to the outer object and calls QueryInterface to ask the outer object for an interface for the desired operations. Assuming the outer object accepts the request it returns a new pointer to the requested object. The reference to the outer IBandSite object then is stored .

In one embodiment the tray window then causes Explorer to call TrackPopupMenu function to the Win32 System in response to the WM CONTEXTMENU message. The Win32 system is the Windows programming platform implemented by Windows 95 and later and Windows NT 3.51 and later. In this example TrackPopupMenu is used which displays a shortcut menu at the specified location and tracks the selection of items on the menu. The menu is then cancelled in the tray window subclass when activated. In one embodiment this is accomplished by handling the WM ENTERMENULOOP message which informs the window procedure that a menu modal loop has been entered. The subclass then calls the EndMenu function to end the calling thread s active menu and SendMessage returns indicating that the window procedure has processed the message. The tray window then may be unsubclassed and the shared table unpatched .

The example implementation begins with a client object that wants to enable a particular deskband. The basic premise of this example implementation is to use the known object that implements the Desktop and QuickLaunch deskbands which are always present in the shell s context menu to create a new deskband. Initially a dynamic load library DLL implementation is injected into Explorer.exe as described in conjunction with . Next an instance of the Desktop deskband object is created using CoCreateInstance.

The vtable associated with the instance is then patched by replacing one of its functions with an alternative procedure or hook . In one embodiment the IDeskBand SetSite method is replaced with the first hook function. This step intercepts the method and places the first hook function into all instances of the Desktop deskband object. Next a second hook is created on a TrackPopupMenu function using an Import Address Table IAT . An IAT is a table of jump instructions with each entry instructing the processor to jump to the actual implementation of the function. A WM CONTEXTMENU message then is sent via a SendMessage or PostMessage function to the tray window. Next Explorer attempts to call TrackPopupMenu however the IAT patch directs a jump to the TrackPopupMenu hook rather than a jump to the original function. Then the command identifier of the Desktop deskband is returned to the tray window .

As a result Explorer will create and initialize the Desktop deskband object. As part of the initialization process the IDeskBand SetSite method is called is provided with either a null pointer or a pointer to Explorer s IBandSite instance . The result depends on whether the Desktop deskband is initially enabled null or disabled the band site . The status of the Desktop deskband is unknown the function is initially called. If a null pointer is supplied the following steps outlined by dotted box occur. First the IDeskBand SetSite null is redirected due to the IDeskBand SetSite hook . Then the SendMessage returns indicating that the window procedure has processed the message. Next HavePointer is called and returns false . A WM CONTEXTMENU message is sent a second time and the IAT patch directs a jump to the TrackPopupMenu hook as above. Then the command identifier of the Desktop deskband is returned to the tray window a second time.

If instead the Desktop deskband was disabled initially or following the above steps for a null result the IDeskBand SetSite method is called and a pointer to Explorer s IBandSite instance is provided as one of its parameters . As in step the IDeskBand SetSite the band site result then redirects . The pointer to Explorer s IBandSite instance is stored in a BandSite cache .

The SendMessage again returns indicating that the window procedure has processed the second WM CONTEXTMENU message. Next HavePointer again is called and this time returns true . The vtable and IAT are then unpatched restoring them to their original state. Finally if the Desktop deskband was disabled initially and a null result never returned the Desktop deskbar is disabled to return it to its previous state. This step is accomplished using a IBandSite HideBand method. This disable step does not occur if the Desktop deskband was enabled initially.

The example implementation begins with a client object that wants to enable a particular deskband. This implementation works in part by programmatically emulating user actions and in part by hooking standard Win32 APIs. Initially a dynamic load library DLL implementation is injected into Explorer.exe. Next a first hook is created on a TrackPopupMenu function by patching an Import Address Table IAT . This hook allows a change in the return value of the function so that it returns the identifier of the item desired to toggle enable or disable . Then a second hook is created on an InsertMenuW function by again patching the IAT. The InsertMenuW function inserts a new menu item into a menu moving other items down the menu. This hook allows the item identifier to be seen when Explorer dynamically inserts it in a submenu of the popup menu.

Next the tray window is subclassed that is the owner of the popup dialog used to manually enable and disable deskbar items. A WM CONTEXTMENU message then is sent to the tray window via a SendMessage or PostMessage function to cause it to show the popup menu. As a result the TrackPopupMenu function is called and redirected due to the TrackPopoupMenu Hook . The popup menu is then initialized using a WM INITMENU message.

Next keypresses are programmatically simulated to expand all submenus. For example a DOWN keypress is used to navigate down the menu a RIGHT keypress is used to navigate into menu items that are submenus. In one embodiment every time a RIGHT keypress is sent a message is posted via PostMessage and control is returned to Explorer. When the posted message is received a left keypress is sent to close the submenu and continue navigating the menu until the entire top level menu has been traversed. This step forces Explorer to populate the submenus which it does using InsertMenuW thus triggering the InsertMenuW hook with the identifier of the deskband menu of the deskband being enabled. As a result the command identifier of the item to toggle is returned. This menu identifier is stored .

Then the original TrackPopupMenu returns . Finally the new deskband s menu identifier is returned assuming the menu identifier was found. This causes Explorer to toggle the display state of the new deskband e.g. enabling it. However if the store menu identifier was not found by the InsertMenuW hook function the value of the original TrackPopupMenu function is returned in step .

In one embodiment the process begins when a user accesses a website for example over network to install an executable process to install a deskband. After agreeing to a set of terms the user clicks an icon on his screen to begin a download of the executable. This step causes an installation program to run installing software modules e.g. as described in conjunction with . In this example the installation program executes an implementation for example as illustrated in .

After some preliminary steps such as injecting code into Explorer.exe as described in conjunction with the IBandSite tray window is found and subclassed to create subclass as shown in . Then an object or instance is created of the same class as inner object or instance . The vtable of inner object instance is then modified to replace the EnumBands function with an alternative procedure.

Then a call via message to outer object is redirected to inner object causing the vtable to be read . Note that because inner object instance and the other instance of the inner object are of the same class they share the vtable . The read results in activation of the alternative procedure which has received a this pointer to the inner object and using IUnknown QueryInterface of the pointer a pointer to the outer object . Additional steps may occur as well such as storing a reference to the outer object restoring the vtable to its previous state and unsubclassing the tray window . As a result of these steps the reference to the target object can be used to install a deskbar by calling IDeskBand AddBand causing the new deskband to display on the user s device.

The present invention has been described in particular detail with respect to one possible embodiment. Those of skill in the art will appreciate that the invention may be practiced in other embodiments. First the particular naming of the components capitalization of terms the attributes data structures or any other programming or structural aspect is not mandatory or significant and the mechanisms that implement the invention or its features may have different names formats or protocols. Also the particular division of functionality between the various system components described herein is merely exemplary and not mandatory functions performed by a single system component may instead be performed by multiple components and functions performed by multiple components may instead performed by a single component.

Some portions of above description present the features of the present invention in terms of algorithms and symbolic representations of operations on information. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. These operations while described functionally or logically are understood to be implemented by computer programs. Furthermore it has also proven convenient at times to refer to these arrangements of operations as modules or by functional names without loss of generality.

Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system memories or registers or other such information storage transmission or display devices.

Certain aspects of the present invention include process steps and instructions described herein in the form of an algorithm. It should be noted that the process steps and instructions of the present invention could be embodied in software firmware or hardware and when embodied in software could be downloaded to reside on and be operated from different platforms used by real time network operating systems.

The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored on a computer readable medium that can be accessed by the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards application specific integrated circuits ASICs or any type of media suitable for storing electronic instructions and each coupled to a computer system bus. Furthermore the computers referred to in the specification may include a single processor or may be architectures employing multiple processor designs for increased computing capability.

The algorithms and operations presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may also be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will be apparent to those of skill in the art along with equivalent variations. In addition the present invention is not described with reference to any particular programming language. It is appreciated that a variety of programming languages may be used to implement the teachings of the present invention as described herein and any references to specific languages are provided for disclosure of enablement and best mode of the present invention.

The present invention is well suited to a wide variety of computer network systems over numerous topologies. Within this field the configuration and management of large networks comprise storage devices and computers that are communicatively coupled to dissimilar computers and storage devices over a network such as the Internet.

Finally it should be noted that the language used in the specification has been principally selected for readability and instructional purposes and may not have been selected to delineate or circumscribe the inventive subject matter. Accordingly the disclosure of the present invention is intended to be illustrative but not limiting of the scope of the invention which is set forth in the following claims.

