---

title: Directory oplock
abstract: Current file systems may implement opportunistic locks on files that allow clients to locally cache file data, while promoting data consistency when multiple clients read/write the same file. Unfortunately, when a client locally caches directory content of a directory, the file system may lack a mechanism for notifying the client of changes to the directory that would render the cached directory content “stale”. Accordingly, one or more systems and/or techniques for managing a directory oplock are disclosed herein. A directory oplock may be generated based upon an oplock request comprising a first target key and a first parent key. Subsequent access requests for access to the directory or objects therein may be compared with the directory oplock to determine whether to break the directory oplock, and notify the client (e.g., directory oplock is broken if the client submitting the access request is different than the client owning the directory oplock).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08965862&OS=08965862&RS=08965862
owner: Microsoft Corporation
number: 08965862
owner_city: Redmond
owner_country: US
publication_date: 20100917
---
Opportunistic locks oplocks are used by file systems to provide clients such as local and or remote applications with the ability to cache file data while providing a mechanism for promoting data consistency when multiple clients read write the same file. Additionally an oplock provides an application with the ability to back off from accessing a file so that the application does not interfere with another application s access to the file. In one example a first application may negotiate an oplock on a text file stored on a file system. The first application may locally cache data corresponding to the text file to reduce network traffic and or access requests in accessing such data e.g. multiple writes may be performed locally to the cached data . If a second application attempts to access the text file on the file system then the file system may break the oplock by sending notification to the first application to update changes on the text file back to the file system. In this way the text file may remain consistent between the first application the second application and the file system. Unfortunately oplocks are currently available for files but not directories. Thus if a first application locally caches directory contents from a file system and a second application changes the directory on the file system then the first application s locally cached directory contents may be stale because the first application is not notified of the second application s changes to the directory.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Among other things one or more systems and or techniques for managing a directory oplock are disclosed herein. A directory oplock may be interpreted as an opportunistic lock on a directory e.g. a file folder a mapped disk drive a directory located on a remote server etc. . An oplock request for a directory oplock on a directory may be received from a client e.g. a file management application a Save as dialogue box a search indexer service a virus scanner and or other clients . It may be appreciated that in one example a client may be interpreted as comprising one or more applications executing either locally e.g. on the same device such as a laptop desktop etc. or remotely e.g. on a different separate device such as a server etc. in relation to the directory e.g. the device s upon which the directory resides . The oplock request may comprise a first target key and a first parent key. The first target key may specify a unique identifier corresponding to the directory and the client requesting the directory oplock. The first parent key may specify a unique identifier corresponding to a parent directory comprising the directory and the client requesting the directory oplock. The directory oplock key may be generated based upon the oplock request.

The client that requested and was granted the directory oplock may locally cache directory content of the directory e.g. directory metadata a listing of files and sub directories of the directory etc. . It will be appreciated that network traffic may be reduced because the client can perform I O operations on the locally cached directory content without directly accessing the directory across a network for example. Similarly a number of access requests may be reduced by allowing a client such as a local application to cache its own copy of the directory. In this way the client may assume that the locally cached directory content is up to date. Additionally the client may be notified of attempts to access the directory and or objects within the directory which may render the locally cached directory content stale e.g. the cached directory content may comprise a listing of 5 files within the directory however another client may add 3 more files to the directory that would not be reflected in the cached directory content .

In particular an access request for access to an object within the directory may be received e.g. a second client may be attempting to modify a file object within the directory the client corresponding to the directory oplock may be attempting to delete a file object within the directory etc. . It may be appreciated that the access request may comprise a request to perform operations upon the directory e.g. rename or delete the directory . The access request may comprise a second target key and a second parent key. The second target key may specify a unique identifier corresponding to the object within the directory and a client requesting the access request. The second parent key may specify a unique identifier corresponding to the directory e.g. the directory is the parent of the target object and the client requesting the access request.

The second parent key corresponding to the directory may be compared with the first target key corresponding to the directory to determine whether the second parent key and the first target key match. That is the second parent key and the first target key may match if the client owning the directory oplock is the same client attempting to access objects within the directory because the respective keys are based upon the same client. Otherwise the second parent key and the first target key may not match if the client attempting the access objects within the directory is different than the client owning the directory oplock because the respective keys are based upon different clients.

If the second parent key matches the first target key then the directory oplock is not broken because the client owning the directory oplock is the same client attempting to access objects within the directory. Such a client may know to update its locally cached directory content with its own changes. In contrast if the second parent key does not match the first target key then the directory oplock is broken because the client owning the directory oplock is different than the client attempting to access objects within the directory. The client owning the directory oplock may have locally cached directory content that may become stale when the other client accessing objects within the directory make changes affecting the directory data. Thus the client owning the directory oplock is notified of the break such that the client may take appropriate action to promote data consistency between itself the other client and the original directory data.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances structures and devices are illustrated in block diagram form in order to facilitate describing the claimed subject matter.

Since the advent of network computing and multitasking directories and files are often shared amongst multiple clients such as applications within a computing environment or computers within a network environment. In one example a file server system may provide network devices with access to shared directories and files. In another example a local client application may attempt to access a local directory in order to cache contents of the local directory. However network bandwidth resource utilization e.g. CPU usage system bus storage etc. and or data consistency issues arise when multiple clients whether across a network or within a single computing environment access the same data. Accordingly opportunistic locks oplocks may be implemented to allow clients to locally cache file data. That is a client may request an oplock on file data such that the client may assume the file data has not been changed so long as the oplock has not been broken by another client s attempt to access and or alter the actual file data. The client may read write to the locally cached file data without generating network traffic to access the actual file data that may be stored across a network for example. When finished the client may update the actual file data with the locally cached file data with a single update. If a second client attempts to access the file data then the oplock may be broken and the second client waits while the client owning the oplock may be notified of the break. In this way the client may update the actual file data with the locally cached file data and provide acknowledgement of the break so that the second client may access the updated file data unaware of the interaction with the first client.

Unfortunately oplocks are currently available for file data but not for directory data. The lack of oplocks for directory data may lead to unnecessary access requests stale cached directory data and or the inability to delete a directory because a client e.g. a search indexer virus scanner etc. may be unaware that another client is attempting to delete the directory and or its contents. In one example a client that locally caches directory content of a directory may have to implement a refresh mechanism in an attempt to keep the locally cached directory content up to date with potential changes to the actual directory from other clients. The refresh mechanism may perform unnecessary refreshes because the actual directory has not changed. Additionally there may be a period of time when the locally cached directory content is stale because another client changed the actual directory and the locally cached directory content has not been refreshed.

Accordingly one or more systems and or techniques for managing a directory oplock are provided herein. In particular a directory oplock for a directory may be created for a first client based upon an oplock request comprising a first target key and a first parent key. The first client may locally cache directory content of the directory to reduce network traffic. To promote data consistency and mitigate stale cached directory content notifications e.g. immediate notification without reliance upon a timer may be provided to the first client when a second client attempts to access the directory. In this way the first client may flush back changes to the directory so that the second client may access an up to date version of the directory. Additionally the first client may be notified to refresh the locally cached directory content from the actual directory because the cached content may be stale if the second client makes changes to the actual directory and or objects within the actual directory. The directory oplock may be broken if the second client is not the same client as the first client. However if the second and first clients are the same client then the directory oplock may not be broken because the client may be aware of its own changes to the directory.

The cached directory content locally stored on client may become stale between the time a change occurs to the Entertainment folder directory by another client and a refresh of the cached directory content e.g. an out of date view of the Entertainment folder directory . For example a client may delete the Music Playlist file on the server . However notification may not be provided to the client of the delete that may affect the correctness of the cached directory content locally stored on client until a refresh is performed because there is no directory oplock on the Entertainment folder directory. That is if a directory oplock had been provided to client on the Entertainment folder directory then notification e.g. immediate notification may have been provided to client of client s requested access corresponding to the delete .

One embodiment of managing a directory oplock is illustrated by an exemplary method in . At the method starts. At an oplock request for a directory oplock on a directory is received for example from a first client. The oplock request may comprise a first target key and or a first parent key. The first target key may specify a unique identifier corresponding to the first client and the directory. The first parent key may specify a unique identifier corresponding to the first client and a parent directory comprising the directory.

At a directory oplock may be generated based upon the oplock request. In one example a read caching directory oplock may be generated so that the first client may locally cache directory content that is read from the directory. In another example a read handle caching directory oplock may be generated so that the first client may locally cache directory content that is read from the directory and open handles on the directory. In another example a read write handle caching directory oplock may be generated so that the first client may locally cache the creation deletion and or modification of files in the directory e.g. modification of an attribute such as read only file size etc. . In this way the directory oplock may be managed for the first client. In particular the first client may be notified of a break of the directory oplock because a second client different from the first client is attempting to access modify the directory and or objects within the directory that may change the current state of the directory e.g. a second client may add a file object to the directory such that the current state of the directory may comprise a larger overall size and the added file object or the first client has made changes to the directory that have to be flushed back before the second client can be aware of them. The notification of the break may put the first client on notice that the locally cached directory content may be stale or that changes made by the first client are to be flushed from its local cache back to the file system.

At an access request for access to an object within the directory may be received. For example a second client who may be the same or different client as the first client may request access to perform I O operations e.g. modify add delete etc. on files and or sub directories within the directory. It may be appreciated that the access request may comprise a request to perform operations upon the directory e.g. rename or delete the directory . The access request may comprise a second target key and or a second parent key. The second target key may specify a unique identifier corresponding to the second client and the object within the directory. The second parent key may specify a unique identifier corresponding to the second client and the directory e.g. the directory is the parent of the object because the directory comprises the object . It may be appreciated that the second parent key may have the same identifier as the first target key if the first client and the second client are the same client e.g. the second parent key specifies the client the directory the first target key specifies the client the directory .

At the directory oplock is broken if the second parent key does not match the first target key. For example the second parent key may not match the first target key where the first client owning the directory oplock is different than the second client attempting to access objects within the directory. The first client may be notified of the directory oplock break so that the first client may be on notice that the locally cached directory content may have become stale . If the access request corresponds to a request by the second client to perform an operation upon the directory e.g. delete the directory a set disposition operation rename the directory etc. then notification may be sent to the second client originating the access request to wait until acknowledgement of the break by the first client.

At the directory oplock is not broken if the second parent key does match the first target key. That is the second parent key matches the first target key because the first client owning the directory oplock is the second client originating the access request. In this way the directory oplock is not broken when the client owning the directory oplock is the client accessing objects within the directory. The client should know of the changes that it makes to the directory and thus should be able to update the locally cached directory content without a notification of a directory oplock break.

In one example a search indexer may originate the oplock request. The directory oplock for the directory may be generated and assigned to the search indexer. A second client such as a file management application may originate the access request to delete the directory. Without a notification of the attempted delete the search indexer may continue to access the directory which may cause the deletion of the directory to fail. For example a user may attempt to delete a directory that the search indexer is currently indexing. However the delete may fail if the delete is issued while the search indexer has the directory open. Thus the user may continue to see the directory and or may be unable to reuse the directory name e.g. because the directory has not yet been deleted . Accordingly the directory oplock created by the search indexer may be broken if the second parent key does not match the first target key. In this way the search indexer may be notified to back out of the directory so that the user may delete the directory. At the method ends.

One embodiment of generating a directory oplock is illustrated by an exemplary method in . At the method starts. At a directory oplock corresponding to a directory and a client is generated. That is the directory oplock is an opportunistic lock on a directory e.g. a file folder as opposed to a file. At the method ends.

The oplock generator may generate the directory oplock based upon the oplock request . In one example the directory oplock may comprise a read caching oplock. In another example the directory oplock may comprise a read handle caching oplock. The oplock generator may send a directory oplock granted notification to the first client . In this way the first client may locally store directory content within cached directory content . The first client may efficiently perform I O operations on the cached directory content without generating unnecessary network traffic to access the actual directory.

The oplock manager may be configured to receive an access request for access to an object within the directory. For example the access request may be received from a second client requesting access to the directory a file with the directory and or a sub directory within the directory. The access request may comprise a second target key and or a second parent key. The second target key may specify a unique identifier corresponding to the second client and the object within the directory. The second parent key may specify a unique identifier corresponding to the second client and the directory. It may be appreciated that the first client and the second client may be the same or different clients which may affect whether the directory oplock is broken by the access request .

The oplock manager may be configured to perform a matching operation to determine whether the first target key matches the second parent key. The oplock manager may be configured to not break the directory oplock if the second parent key matches the first target key because the match indicates that the first client and the second client are the same client and thus it may be unnecessary to notify the client of its own access to the directory.

The oplock manager may be configured to break the directory oplock if the second parent key does not match the first target key. The oplock manager may send a directory oplock break notification to the first client . The directory oplock break notification may notify the first client that the cached directory content may be stale . If the access request corresponds to an operation upon the directory then the oplock manager may send notification to the second client to wait until acknowledgement of the break by the first client before accessing the directory.

In one example the oplock manager may be configured to receive a directory delete access request e.g. access request comprising an I O request to perform a directory delete on the directory. The oplock manager may notify the first client associated with the directory oplock to back out of the directory so that the second client originating the directory delete access request may delete the directory.

In one example the oplock generator may be configured to generate an atomic oplock in response to a directory access request to access the directory. The oplock generator may generate the atomic oplock spanning a timeframe between the directory access request and the oplock request for the directory oplock on the directory. For example the first client may perform an initial directory access request before performing an oplock request. There may be a time period between the initial directory access request and the generating of the directory oplock where the first client is unprotected because the directory oplock has not been generated but the directory may already be open. The atomic oplock may mitigate sharing violations during this time period.

The remote file server may be configured to allow local and or remote clients to access directories and files within the file structure . Opportunistic locks may be available for directories and or files. In one example an oplock request for a directory oplock on the Entertainment folder directory may be received from a first client. In particular the first client may be requesting a directory oplock for the Entertainment folder directory so that the first client may locally cache directory content corresponding to the Entertainment folder directory. The oplock request may comprise a first target key and a first parent key. The first target key may specify a unique identifier corresponding to the first client and the Entertainment folder directory. The first parent key may specify a unique identifier corresponding to the first client and the Applications folder e.g. the parent directory of the target Entertainment folder directory . In this way the directory oplock may be generated for the first client. The first client may locally cache the directory content. For example the first client may cache metadata associated with the Entertainment folder directory and or a listing of the files sub folders within the Entertainment folder directory such as the Music folder the Images folder the Music Playlist file the Music Player file the Image Viewer file the Image Editor file and or other objects.

It may be appreciated that a first client may own a directory oplock on the Entertainment folder directory e.g. . In one example a second client different than the first client owning the directory oplock may request access to the Music Playlist file . The second client may send an access request comprising a second target key and a second parent key. The second target key may specify a unique identifier corresponding to the second client and the Music Playlist file . The second parent key may specify a unique identifier corresponding to the second client and the Entertainment folder directory e.g. the parent directory of the target Music Playlist file . The directory oplock may be broken because the second parent key may not match the first target key because the respective keys are based upon different clients e.g. the first target key is based upon the first client while the second parent key is based upon the second client different than the first client . The first client may be sent notification of the directory oplock break in order to prevent the first client from maintaining a stale cache of the Entertainment folder directory. For example the second client may modify or delete the Music Playlist file which would not be reflected in the first client s stale cache.

It may be appreciated that a first client may own a directory oplock on the Entertainment folder directory e.g. . In one example a second client may request access to the Music Playlist file . It may be appreciated that the first client and the second client are the same client in example and are referred to as the client for purposes of simplicity. That is the first client owning the directory oplock is the same client as the second client requesting access to the Music Playlist file .

It may be advantageous to detect that the same client owning the directory oplock is the same client requesting access so that the directory oplock is not broken by such access. The client may send an access request comprising a second target key and a second parent key. The second target key may specify a unique identifier corresponding to the client and the Music Playlist file . The second parent key may specify a unique identifier corresponding to the client and the Entertainment folder directory e.g. the parent directory of the target Music Playlist file . The directory oplock may not be broken because the second parent key may match the first target key because both keys are based upon the same client and the same Entertainment folder directory. In this way the directory oplock is not broken because it may be unnecessary to provide notification to the client that the client itself is access the Entertainment folder directory. Such notification may be unnecessary because the client should know of its access to the directory and should be able to take proper action with regard to any corresponding cached directory content.

Still another embodiment involves a computer readable medium comprising processor executable instructions configured to implement one or more of the techniques presented herein. An exemplary computer readable medium that may be devised in these ways is illustrated in wherein the implementation comprises a computer readable medium e.g. a CD R DVD R or a platter of a hard disk drive on which is encoded computer readable data . This computer readable data in turn comprises a set of computer instructions configured to operate according to one or more of the principles set forth herein. In one such embodiment the processor executable computer instructions may be configured to perform a method such as the exemplary method of and exemplary method of for example. In another such embodiment the processor executable instructions may be configured to implement a system such as the exemplary system of for example. Many such computer readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 1394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via a network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Various operations of embodiments are provided herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein.

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

