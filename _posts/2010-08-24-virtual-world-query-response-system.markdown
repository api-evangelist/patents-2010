---

title: Virtual world query response system
abstract: The illustrative embodiments provide a computer implemented method and computer program product for a virtual world query response system. A set of virtual world entry points in a virtual world database that is responsive to a query is identified. A virtual world entry point is a location within a virtual world. A free shard from a set of free shards is identified. A shard is a virtual world hosted on a server. Custom content associated with the set of virtual world entry points is generated. The custom content is added to the selected free shard to form a custom shard responsive to the query. An entry point of the custom shard is returned to the client.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08458209&OS=08458209&RS=08458209
owner: International Business Machines Corporation
number: 08458209
owner_city: Armonk
owner_country: US
publication_date: 20100824
---
The present invention is related generally to a data processing system and in particular to a method and computer program product for a virtual world query server. More particularly the present invention is directed to a computer implemented method and computer usable program code for managing virtual world queries and virtual world query responses.

A virtual world also referred to as a virtual universe metaverse or 3D Internet is a computer based simulated environment hosted on a server over the Internet. Examples of virtual universes include without limitation Second Life Entropia Universe The Sims Online EverQuest Ultima Online Lineage and World of Warcraft . Virtual worlds are typically represented using three dimensional 3 D graphics and landscapes.

Virtual worlds are multiuser environments. Thousands of users may populate a virtual world simultaneously. When a virtual world server becomes too busy due to the number of users accessing a virtual world hosted on the server the virtual world server may be able to spawn a copy of that virtual world on a second server. This copy of the virtual world on the second server is referred to herein as a shard . The virtual world server may then transfer some of the users of the virtual world to the shard on the second server. Typically the number of servers and the maximum number of shards that may be made available to users is fixed.

The illustrative embodiments provide a computer implemented method and computer program product for a virtual world query response system. In one embodiment a set of virtual world entry points that is responsive to a virtual world query is identified in a virtual world database. A virtual world entry point is a location within a virtual world. A free shard from a set of free shards is identified. A shard is a virtual world hosted on a server. Custom content associated with the set of virtual world entry points is generated. The custom content is added to the selected free shard to form a custom shard responsive to the virtual world query. An entry point within the custom shard is returned to the client.

In another embodiment a virtual world query is received from a client associated with an immersive virtual world environment. A shard database is searched for a custom shard having content responsive to the virtual world query. The shard database comprises an entry for each custom shard in use. The entry for the each custom shard in use comprises a description of content associated with the each custom shard and identification of a set of clients connected to the custom shard. In response to identifying the custom shard having content responsive to the virtual world query in the shard database an entry point within the custom shard is returned to the client.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

With reference now to the figures and in particular with reference to exemplary diagrams of data processing environments are provided in which illustrative embodiments may be implemented. It should be appreciated that are only exemplary and are not intended to assert or imply any limitation with regard to the environments in which different embodiments may be implemented. Many modifications to the depicted environments may be made.

In the depicted example server and server connect to network along with storage unit . In addition clients and connect to network . Clients and may be for example personal computers or network computers. In the depicted example server provides data such as boot files operating system images and applications to clients and . Clients and are clients to server in this example. Network data processing system may include additional servers clients and other devices not shown.

Program code located in network data processing system may be stored on a computer recordable storage medium and downloaded to a data processing system or other device for use. For example program code may be stored on a computer recordable storage medium on server and downloaded to client over network for use on client .

In the depicted example network data processing system is the Internet with network representing a worldwide collection of networks and gateways that use the Transmission Control Protocol Internet Protocol TCP IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high speed data communication lines between major nodes or host computers consisting of thousands of commercial governmental educational and other computer systems that route data and messages. Network data processing system also may be implemented as a number of different types of networks such as for example an intranet a local area network LAN or a wide area network WAN . is intended as an example and not as an architectural limitation for the different illustrative embodiments.

Processor unit serves to execute instructions for software that may be loaded into memory . Processor unit may be a set of one or more processors or may be a multi processor core depending on the particular implementation. Further processor unit may be implemented using one or more heterogeneous processor systems in which a main processor is present with secondary processors on a single chip. As another illustrative example processor unit may be a symmetric multi processor system containing multiple processors of the same type.

Memory and persistent storage are examples of storage devices. A storage device is any piece of hardware that is capable of storing information either on a temporary basis and or a permanent basis. Memory in these examples may be for example a random access memory or any other suitable volatile or non volatile storage device. Persistent storage may take various forms depending on the particular implementation and may contain one or more components or devices. For example persistent storage may be a hard drive a flash memory a rewritable optical disk a rewritable magnetic tape or some combination of the above. The media used by persistent storage also may be removable. For example a removable hard drive may be used for persistent storage .

Communications unit in these examples provides for communications with other data processing systems or devices. In these examples communications unit is a network interface card. Communications unit may provide communications through the use of either or both physical and wireless communications links.

Input output unit allows for input and output of data with other devices that may be connected to data processing system . For example input output unit may provide a connection for user input through a keyboard and mouse. Further input output unit may send output to a printer. Display provides a mechanism to display information to a user.

Instructions for the operating system and applications or programs are located on persistent storage . These instructions may be loaded into memory for execution by processor unit . The processes of the different embodiments may be performed by processor unit using computer implemented instructions which may be located in a memory such as memory . These instructions are referred to as program code computer usable program code or computer readable program code that may be read and executed by a processor in processor unit . The program code in the different embodiments may be embodied on different physical or tangible computer readable media such as memory or persistent storage .

Program code is located in a functional form on computer readable media that is selectively removable and may be loaded onto or transferred to data processing system for execution by processor unit . Program code and computer readable media form computer program product in these examples. In one example computer readable media may be in a tangible form such as for example an optical or magnetic disc that is inserted or placed into a drive or other device that is part of persistent storage for transfer onto a storage device such as a hard drive that is part of persistent storage . In a tangible form computer readable media also may take the form of a persistent storage such as a hard drive a thumb drive or a flash memory that is connected to data processing system . The tangible form of computer readable media is also referred to as computer recordable storage media. In some instances computer recordable media may not be removable.

Alternatively program code may be transferred to data processing system from computer readable media through a communications link to communications unit and or through a connection to input output unit . The communications link and or the connection may be physical or wireless in the illustrative examples. The computer readable media also may take the form of non tangible media such as communications links or wireless transmissions containing the program code.

In some illustrative embodiments program code may be downloaded over a network to persistent storage from another device or data processing system for use within data processing system . For instance program code stored in a computer readable storage medium in a server data processing system may be downloaded over a network from the server to data processing system . The data processing system providing program code may be a server computer a client computer or some other device capable of storing and transmitting program code .

The different components illustrated for data processing system are not meant to provide architectural limitations to the manner in which different embodiments may be implemented. The different illustrative embodiments may be implemented in a data processing system including components in addition to or in place of those illustrated for data processing system . Other components shown in may be varied from the illustrative examples shown.

As one example a storage device in data processing system is any hardware apparatus that may store data. Memory persistent storage and computer readable media are examples of storage devices in a tangible form.

In another example a bus system may be used to implement communications fabric and may be comprised of one or more buses such as a system bus or an input output bus. The bus system may be implemented using any suitable type of architecture that provides for a transfer of data between different components or devices attached to the bus system. Additionally a communications unit may include one or more devices used to transmit and receive data such as a modem or a network adapter. Further a memory may be for example memory or a cache such as found in an interface and memory controller hub that may be present in communications fabric .

The embodiments recognize that when a user immersed within the environment of a first virtual world wants to navigate to a different second virtual world web site the user leaves the immersion of the first virtual world to navigate to the second virtual world. The embodiments further recognize the problem that user s may be unable to identify entry points of virtual worlds and or navigate to virtual worlds of potential interest to the user s without leaving the immersion of a virtual world environment.

Moreover the user may only be able to navigate to specific virtual worlds already known to the user. The embodiments recognize that because there are currently no search engines or databases that enable the user to search for content and entry points of virtual worlds that may be of interest to the user. The embodiments also recognize the problem that users may not be able to identify and navigate to virtual world servers of potential interest to the user if the user does not already know about the virtual world content and or address.

The embodiments further recognize the problem that users may be unable to navigate to other virtual worlds as a group within an immersive environment. The illustrative embodiments recognize that there is a need for a virtual world query server and or a searchable database and or index of virtual world entry points that enable a user to search and obtain entry points to virtual worlds previously unknown to the user and or virtual worlds covering similar subject matter that may not have been known to the user.

Therefore the illustrative embodiments provide a virtual world database that contains the addresses and or entry points of virtual worlds. The virtual world database entries contain descriptive data that can be searched. The descriptive data is compared to the search criteria specified in the virtual world query to produce the set of matching entry points. Descriptive data may include without limitation at least one of a name textual description rating a tag or any other type of search parameter or search criteria.

As used herein the term at least one of followed by a list of items means that different combinations of one or more of the items may be used and only one of each item in the list may be needed. For example at least one of item A item B and item C may include for example and without limitation item A only item C only item A and item C or item A and item B. This example may also include all of item A item B and item C. In one embodiment a virtual world query server identifies a set of virtual world entry points in a virtual world database. As used herein an entry point is a location within a virtual world. An exemplary entry point may be without limitation SLurl.com secondlife Here 54 105 47 .

The term set refers to a null set having no members as well as a set having one or more members unless defined otherwise herein. The set of virtual world entry points is a set that may have no virtual world entry points as well as one or more virtual world entry points that match the criteria used to search the virtual world database. If there are no virtual worlds matching the criteria the set of virtual world entry points is an empty set having no entry points in the set.

The virtual world query server selects a free shard from a set of free shards. A shard is a virtual world hosted on a server. A free shard does not contain any virtual world content. In other words a free shard is a shard that is unallocated or empty. A free shard may be populated with virtual world content for utilization by a client. A free shard is a shard that has no clients connected to the shard and or has no virtual world content.

The virtual world query server generates custom content associated with the set of virtual world entry points. As used herein custom content includes without limitation the set of virtual world entry points that are responsive to the virtual world query and or content that dynamically constructs a virtual world that contains a portal corresponding to each virtual world entry point in the set of virtual world entry points. A portal is a virtual world representation of an entry point.

The virtual world query server adds the custom content to the selected free shard to form a custom shard that is responsive to the virtual world query. In other words the custom shard hosts a virtual world having portals corresponding to each entry point for each virtual world having content that is responsive to the virtual world query sent by the client. The virtual world query server returns an entry point of the custom shard to the client. The client uses the entry point to connect to the custom shard and permit a user associated with the client to interact with the virtual world associated with the customs shard.

The virtual world associated with the custom shard comprises a set of portals corresponding to each entry point in the set of virtual world entry points. Each portal leads to a location in a virtual world that is of potential interest to the user based on the virtual world query response. Thus the user at the client may utilize the portals in the virtual world query response system hosted on the custom shard to navigate to one or more different virtual worlds of potential interest to the user from the immersion of the virtual world query response system hosted on the custom shard.

In another embodiment a virtual world query is received from a client associated with an immersive virtual world environment. A shard database is searched for a custom shard having content responsive to the virtual world query. The shard database comprises an entry for each custom shard in use. The entry for the each custom shard in use comprises a description of content associated with the each custom shard including the clients currently using the custom shard. The identification of clients connected to the shard permits a first user to search for a particular avatar or second user even if the first user does not know the exact search terms used by that second user. In other words the entry information identifying clients connected to each custom shard permits users to search by client details such as the user s real name or the name of the user s avatar.

An avatar is a virtual world representation of a user. For example a user might search for the virtual world for Avatar Fred or search for the virtual world to which a user named Fred Jones is currently connected. The shard database comprises an entry for each custom shard in use.

In response to identifying the custom shard having content responsive to the virtual world query in the shard database the entry point of the custom shard is sent to the client.

Client is a data processing system associated with a user. Client may be implemented using any type of computing device such as without limitation client in or data processing system in . A user interacts with virtual world query response system via client . In this example but without limitation the user may be interacting with an immersive virtual world environment displayed on client . The user sends query to query server via client .

Query is a virtual world query requesting virtual worlds of potential interest to the client. In other words query requests information associated with virtual world s having content associated with key words tags subject matter or other criteria specified in query .

Query may be implemented as without limitation a textual string message a uniform resource locator URL style string an extended markup language XML style document a pre defined query or any other type of query. A textual string query may be a text string containing one or more letters numbers symbols terms tags and or phrases. A URL style string may be any type of URL for example but without limitation server query t old masters r1 G rh MA . An XML query document may contain additional information pertaining to the query such as but without limitation a preference tag a group identifier or other information.

A pre defined query is a query that is wholly or partially pre generated such as without limitation a canned query selected from a pre generated set of queries. Pre defined queries may be without limitation stored at client on a server or on any type of data storage device. A pre defined query may be created by the user by a programmer or by any other third party for utilization by the user at client .

The user may select one or more predefined queries from a set of predefined queries using any type of input device such as but without limitation a mouse a keyboard a touch screen a voice recognition system a controller or any other type of input device that is currently available or that may become available in the future. The set of predefined queries may include no queries a single predefined query as well as two or more predefined queries.

Thus the user may generate an original query select a pre defined query from a set of queries to form query combine two or more pre defined queries to form query or modify one or more pre defined queries to form query .

The user may optionally generate query while interacting with a virtual world at client . This includes queries embedded within or generated by objects within the virtual world the client is interacting with at Client .

Client sends query to query server in set of servers . Set of servers is a set of one or more servers such as but without limitation query server and or local shard server . Set of servers may contain a single query server as well as two or more query servers. Set of servers may be located on a single physical computing device. Set of servers may also optionally include one or more servers located at different physical locations that are capable of sending and receiving data over a network connection. Thus all the servers in set of servers may be at the same location as query server . Likewise one or more servers in set of servers may be located at one or more different remote locations from query server .

In this embodiment at least one server in set of servers performs the role of a virtual world query server and at least one server performs the function of a shard server. Here query server is a different server than the server performing the function of shard server . However the server performing the function of query server may be the same server as the server performing the role of shard server . In yet another embodiment a virtual machine within shard server runs a query server program to perform the functions of query server instead of running a custom shard program.

Query server is a server that directs users to shard servers hosting virtual worlds that are responsive to their queries. The responsive shard may be an existing shard an updated shard or a newly constructed shard. If an existing shard having content that is responsive to a particular virtual world query does not exist query server constructs a custom shard by populating a shard with content that is responsive to query .

A shard server such as but without limitation local shard server and or remote shard server is a server hosting one or more shards. A shard server runs or controls virtual world shards hosted on the shard server. The shard server mediates interactions between users and the virtual worlds supported on the shard server.

Set of servers may optionally include one or more local shard servers such as local shard server . However set of servers is not required to include a local shard server at the same location as virtual world query server . In other words set of servers may include no local shard servers a single local shard server as well as two or more local shard servers. In an embodiment in which set of server includes no local shard server virtual world query server may utilize one or more shard servers located remotely to virtual world query server such as remote shard server .

Virtual world query server creates and or identifies shards that are responsive to a virtual world query using virtual world query database to locate virtual world entry points responsive to the virtual world query. Virtual world query database is a query database containing entries describing virtual worlds virtual world entry points content associated with each virtual world entry point and content of virtual worlds.

Virtual world database comprises at least one entry point for each virtual world identified in virtual world database . In other words virtual world database contains one or more different entry points for one or more different virtual worlds. Virtual world database may contain thousands of entry points for a plurality of different virtual worlds. Each entry in virtual world database for a virtual world entry point is accompanied by a description of what is found in that portion or location of the virtual world associated with the entry point.

For example virtual world database may contain an entry for a virtual world museum that mirrors the real world version of the museum. This museum virtual world may have multiple entry points such as but without limitation an entry point for main entrance a meeting place an entry point for first gallery old masters an entry point for second gallery impressionists an entry point for courtyard modern sculpture and so forth. The virtual world database entry for the museum virtual world includes a brief description of the type of art found in each area of the museum associated with each entry point. The description may be without limitation a name textual description a tag or any other type of description.

Query server searches entries in virtual world database to generate set of virtual worlds responsive to query . A virtual world is responsive to query if without limitation the virtual world description content and or tags associated with the virtual world correspond to search terms and or tags in query .

Set of virtual worlds may be a null set having no virtual worlds responsive to query a set with only a single responsive virtual world or a set having two or more virtual worlds. Assuming set of virtual worlds is a non null set containing at least one virtual world entry query server selects a free shard.

Shard database is a database of entries identifying all free shards and or entries identifying custom shards in use . Shard database may be used by a single shard server as well as two or more shard servers. In other words shard database may be but without limitation updated by one or more shard servers and queried by one or more virtual world query servers such as query server as well as other query servers not shown in .

Free shards on shard database is a database listing or catalog of entries for free shards that are not currently hosting a virtual world. Free shards may contain entries identifying no free shards an entry identifying a single free shard as well as entries identifying two or more free shards.

Query server selects a free shard from set of free shard . Set of free shards on local shard server may be a null set that includes no free shards a set having only a single free shard as well as a set of two or more free shards. Shards in set of free shards on local shard server are maintained by local shard server as a chain or stack rather than as an unlinked set.

Thus when query server requires a free shard query server sends a request to the shard server for a free shard. The shard server makes the next free shard at the top of the stack in set of free shards available to query server to form the selected free shard. In this example the selected free shard is hosted on local shard server however the free shard may also be selected from a remote virtual world shard server such as remote shard server .

Set of free shards on local shard server may be a null set that includes no free shards a set having only a single free shard as well as a set of two or more free shards. Shards in set of free shards on local shard server are maintained by local shard server as a chain or stack rather than as an unlinked set.

In this example if there are no free shards on local shard server remote shard server or any other available shard server and query server is unable to map query to a shard already in use that is responsive to query as discussed below the request to query server fails and no shard details are returned to client . In response to query server selecting a free shard from set of free shards query server updates free shard entries in shard database to reflect that the selected free shard is no longer free and or the selected free shard has been removed from the chain of free shards in set of free shards .

Query server creates custom content associated with set of virtual worlds retrieved from virtual world database . Query server sends the custom content to the selected free shard to form custom shard in set of custom shards . Set of custom shards may include no custom shards a single custom shard as well as two or more custom shards.

The selected free shard is then populated with the custom content to form custom shard responsive to query . The shard server uses the custom content associated with set of virtual worlds to dynamically construct a customized virtual world having a portal for each of the virtual world entry points returned by query server .

Query server returns an entry point within custom shard responsive to query to client for utilization by the user associated with client . The user utilizes client to interact with the virtual world content hosted on custom shard .

Query server optionally updates entries for custom shards in use in shard database to indicate that the selected free shard populated with the custom content to form custom shard is now a custom shard in use. Entries for custom shards in use may contain an entry indicating that there are currently no custom shards in use an entry indicating that there is only a single custom shard in use as well as entries identifying two or more custom shards in use.

Database entries for custom shards in use may include information describing the contents of each custom shard in use such as but not limited to an identification of all clients currently connected to each custom shard in use a subject matter identification for the custom content a rating for the content an identification of virtual world entry points group identifiers as well as any other virtual world information.

Each query server in set of servers utilizing shard database updates shard database to identify free shards custom shards in use the contents of each custom shard clients currently connected to each shard hosted on shard database and or when a shard is returned to the pool of free shard so that free shards may be obtained in an uninterruptable operation and multiple query servers do not attempt to obtain the same free shard. This prevents a situation from arising in which two different query servers attempt to populate the same shard with different information to create different custom shards.

In response to client disconnecting from custom shard query server removes the custom content from custom shard and returns custom shard to the pool of free shards. Query server updates free shards to show that custom shard is now a free shard and or updates custom shards in use to reflect that custom shard is no longer in use or available for clients to utilize. Thus shards are recycled when the users that they were created for are done with them.

In another embodiment when client sends query to query server query server searches custom shards in use in shard database to determine if a custom shard is already in use that is responsive to a query identical or equivalent to query . In other words query server determines whether a pre existing matching custom shard was created for utilization by a different user that made the exact same query or a query that is equivalent to query . If a matching custom shard responsive to query is found query server returns this matching shard to client instead of generating custom content and constructing a new custom shard.

In yet another embodiment when query server receives query from client query server searches virtual world database for set of virtual worlds responsive to query . Query server then searches set of custom shards in use in shard database to determine whether an overlapping custom shard is in use that was constructed with the same virtual worlds as set of virtual worlds . In other words query server searches set of custom shards in use to determine whether a pre existing overlapping custom shard contains all of the virtual worlds in set of virtual worlds .

For example given a first query for Disney and a second query for Epcot a result of the second Epcot query may contain virtual world entries that are a subset of the virtual world entries in the response to the first Disney query. In another example a first virtual world query for Disney World Space Centre and Disney World Epcot may result in identical results and or overlapping lists of virtual world entry points responsive to the two queries.

Query server may also automatically filter the queries received from clients for terms that make no significant difference to the result of the virtual world query. For example a query containing the terms Dallas Fort Worth metroplex and Dallas Ft. Worth may return the same list of virtual worlds. The term metroplex is redundant as it does not affect the outcome of the search. The user requesting Dallas Fort Worth metroplex may be sent to the matching shard already in use for the query Dallas Ft. Worth even though the queries are not exactly the same.

In another example a first query for theme parks and a second query for amusement parks may result in the same response list of virtual worlds. Query server may direct the users that made these different queries to the same custom shard rather than creating a separate custom shard for each different user.

In still another embodiment query server searches the tags and descriptions of virtual world content for each shard in set of custom shards in use . This is a comparison process in which query server compares query with the entries in set of custom shards for each custom shard already in use. If query server finds a match query server returns the matching custom shard already in use to client rather than constructing a new custom shard for the user.

In another embodiment query server may optionally include lexical analyzer . Lexical analyzer analyzes virtual world queries received from clients and normalizes the query to use a reduced dictionary of keywords and or tags. A normalized query is a query that has been reduced to a set of normalized tags by lexical analyzer.

Lexical database is a database of normalized tags. Lexical database contains set of normalized tags used within virtual world database . Each normalized tag in set of normalized tags in lexical database has a list of terms associated with that tag. For example a normalized tag ELVIS PRESLEY may be associated with a list of terms such as but without limitation elvis presley king pres and so forth.

In this example the normalization of the descriptive material in virtual world database produces set of normalized tags in lexical database . Lexical database in this embodiment but without limitation is specific to virtual world database .

When query server receives query lexical analyzer executes a lexical reduction algorithm over query to normalize query to a simplified subset of tags such as set of normalized tags . If query contains the text Elvis in the movies lexical analyzer may analyze and reduce the query text to the normalized tag string ELVIS PRESLEY movies . In another example a query such as the king s fun houses may be reduced to KING ELVIS PRESLEY fun houses . In other words the query is normalized into two tags the first tag is KING and the second tag is ELVIS PRESLEY . The tag KING is added in this example because the query terms the king s is not a guaranteed reference to Elvis.

In one embodiment when a new entry point is added to virtual world database information is added to virtual world database for that virtual world entry point such as but not limited to a name textual description and or a set of tags. The normalization process is applied to these textual elements to eliminate superfluous words and symbols such as without limit and or but a and the . The words that are not eliminated are mapped to normalized tags. For example the textual description for an entry point The Kings Hall of Fame may be mapped to the tags ELVIS PRESLEY KING and HALL OF FAME .

If lexical analyzer cannot map one or more words in the textual description for an entry point to a known normalized tag lexical analyzer prompts a user to either discard the unmapped word s and or provide a normalized tag for the unmapped word s .

For example if lexical analyzer does not recognize the words resting place in a textual description lexical analyzer may prompt the user to enter alternate words or discard the phrase resting place from the description. If the user adds the terms grave and tomb then lexical analyzer may search known normalized tags for a tag associated with the words grave or tomb . If a matching tag is found that normalized tag is used. However if a matching tag is not found lexical analyzer may create a new normalized tag RESTING PLACE associated with the additional words resting place grave and tomb entered by the user.

In another example if lexical analyzer is unable to map word s in a textual description to normalized tag s lexical analyzer may consult an electronic dictionary and or thesaurus for additional terms and phrases associated with the unmapped word s . Lexical analyzer dynamically generates a new normalized tag based on the results of the thesaurus and or dictionary search results.

In this embodiment when query server receives query lexical analyzer is run against query to normalize query . Query server searches shard database using the normalized query tags to determine if a custom shard having the same tags as the normalized query is in use. If an entry is found that matches all terms of normalized query then the shard associated with the matching entry is returned to client instead of creating a new customized shard. For example if the normalized query tags are dog and Cavalier then a custom shard with the exact same dog and Cavalier tags will be a matching custom shard.

If an entry for a shard is found that is a superset of the normalized query tags that shard is also a matching shard. For example if the query has tags dog and Cavalier a matching virtual world entry may have a superset tags including dog puppies Cavalier and King Charles Spaniel . The matching custom shard tags are a superset of the query tags having additional tags not found in the normalized query but the tags are still a match for the tags found in the normalized query.

In this manner query server is able to more efficiently locate relevant virtual world entries and or identify relevant custom shards responsive to a given query. Query server utilizing normalized tags to search shard database for matching custom shards in use may result in a net reduction in work and reduction in utilization of data processing system resources by short cutting the search and comparison algorithm.

In yet another embodiment virtual worlds identified in virtual world database are described with textual tags. In this example virtual world database contains entries identifying virtual worlds virtual world entry points and attributes describing the contents of the virtual world at the entry point including without limitation tags describing the destination. The tags in virtual world database describing a virtual world may be provided by a user provided by an owner or creator of the virtual world provided in a database of tags or otherwise input into virtual world database from any other source of information describing the virtual world

In one example a user provides lexical analyzer with a string of textual tags that describe a virtual world. Lexical analyzer runs a lexical reduction algorithm over the string of textual tags describing each virtual world in virtual world database to normalize the tags to a simplified subset of terms.

Lexical analyzer may query the user for clarification or simplification of any tags that lexical analyzer does not recognize Lexical analyzer updates lexical database associated with lexical analyzer if the user provides a simplification or updated definition for a new textual tag.

Lexical analyzer generates a list of normalized tags which are stored in virtual world database . In one embodiment virtual world database stores the list of normalized tags for a given virtual world in the virtual world database entry associated with the given virtual world.

The utilization of normalized tags in the queries and or normalized tags describing virtual worlds in virtual world database improves the likelihood that query server will identify a matching custom shard already in use and or identify relevant virtual world entries in virtual world database . The normalized tags also increase the number of identical and similar queries that query server is able to recognize and group together in a common shard. Likewise the normalized tags makes it easier for query server to recognize multiple sets of identical and or similar query responses.

In still another embodiment when query server receives query from client query server obtains set of virtual worlds that is responsive to query . In this example rather than create a new custom shard hosting a customized virtual world responsive to query query server searches set of custom shards in shard database for a custom shard that has a threshold degree of overlap with set of virtual worlds responsive to query . A threshold degree of overlap may be any number of virtual world entries in an existing custom shard in use that corresponds to virtual world entries in set of virtual worlds .

For example and without limitation if set of virtual worlds contains five virtual world entries a threshold degree of overlap may require that an existing custom shard in use have at least one of the five virtual world entries at least two of the five virtual world entries three of the five virtual world entries or even require at least four of the five entries in set of virtual worlds .

In another example the threshold degree of overlap may be without limitation a percentage. The threshold degree of overlap may be without limitation thirty percent of the responsive virtual worlds in set of virtual worlds fifty percent of the responsive virtual worlds seventy percent of the responsive virtual worlds or any other percentage. In the example above in which set of virtual worlds contains five virtual world entries a threshold degree of overlap of fifty percent or more overlap requires an existing custom shard have three or more of the virtual world entries found in set of virtual worlds to qualify as an overlapping shard.

The overlap threshold may also be a user defined threshold selected by a user at client a system administrator or other programmer. The overlap threshold may also be a dynamic threshold that changes depending on the number of shards available the number of users and or the number of queries. In still another embodiment the overlap threshold degree of overlap is implemented as a predefined threshold.

If a custom shard contains the threshold degree or greater of overlap query server selects the overlapping custom shard and updates the overlapping custom shard to include the additional results. Query server may update the overlapping custom shard to include additional results by identifying the virtual world entries that are missing from the selected shard and generating custom content associated with these missing virtual world entries to form the additional results. Query server then populates the overlapping custom shard with the virtual world content for the additional results.

For example and without limitation if a first user sends a London places of interest query the first user s custom shard generated for this first user may include virtual worlds for restaurants museums and zoos. If a second user sends a query for European museums the links for the London museums sites overlaps with some of the links for the second user s query response. Query server may use the virtual world responsive to the first query as an overlapping shard. Query server adds virtual world content for any virtual world links for museums missing from the first user s response to the overlapping shard responsive to the first user s query to complete the response to the second user s query. The first user s overlapping custom shard is then returned to the second user. In this way both the first user and the second user are able to utilize the same shard due to the overlap in their query responses.

An entry point within the overlapping custom shard is then returned to second user. Other users of the overlapping custom shard are able to see the shard content change as the overlapping custom shard is updated with the additional results to the second user s query. If an overlapping shard is not found because all the pre existing custom shards fall below the threshold degree of overlap query server generates a new custom shard responsive to the second user s query and returns an entry point within the newly generated custom shard to client .

In another embodiment the recycling of custom shards that no longer have any users connected to them may be delayed permitting them to be reused if a new query should exceed the overlap threshold. The optional delay may be set by the client the system administrator may be a hard coded constant or dynamically determined based upon the demand for recycled shards.

In still another embodiment an empty shard may be kept as a custom shard in use until a request for a free shard is received without any free shards available to respond to the request. An empty shard is a custom shard with no clients connected to the shard. If no free shard is available in this example the oldest un recycled empty shard is recycled and returned as the free shard in response to the request for a free shard.

In one embodiment virtual world database may optionally include a set of common queries . In some cases query server may be able to determine which queries are the most popular and or determine which queries are likely to become the most popular in the near future. Set of common queries is a set of the most common queries received over a given time period. For example and without limitation set of common queries may be but without limitation the top ten most frequently received queries in the last twenty four hours the most common twenty queries received over the last eight hours the most popular one hundred queries received during the last two days or any other combination of queries received over a given time period.

For each query in set of common queries query server identifies a custom shard in set of custom shards in use corresponding to the query in set of common queries . If the query in set of common queries is not associated with a corresponding custom shard in use that is responsive to the common query query server generates a custom shard having content responsive to the common query to form a focused shard for that common query. If a query in set of common queries does have a custom shard in use query server updates the custom shard with any custom content that is necessary to complete the query responses to the common query to form a focused shard.

In one embodiment a focused shard is generated for each query in the set of common queries. In another embodiment the set of virtual world entry points responsive to each query in the set of common queries are analyzed to determine if there is sufficient overlap between them for the same focused shard to be utilized for two or more of the common queries. In other words two or more queries from the set of common queries may be mapped to the same focused shard if there is significant overlap between the sets of virtual world entry points responsive to both of the queries. The threshold for determining significant overlap may without limitation be hard coded set by the user or administrator or dynamically determined by the system.

Query server updates shard database with entries in set of custom shards in use to reflect the focused shards corresponding to set of common queries . The focused shards which are responsive to queries in set of common queries are not recycled if there are no clients connected to them. The focused shards are only recycled when the corresponding common query associated with the focused shard ceases to be popular such that the common query is removed from set of common queries .

Query server sends users making the same or similar query to the same shard. This enables users to travel through the search engine associated with query server as a group and enables more efficient use of system resources. Query server reuses custom shards to reduce the amount of resources used by query server to search virtual world database and construct custom shards to reduce the overhead and limit the resources of the system consumed by each client. Moreover when clients make identical queries more clients may be accommodated with the same number of shards. Thus fewer servers may be used to serve greater numbers of clients.

In this embodiment set of servers may contain one or more virtual world query servers. Thus there may be without limitation multiple virtual world query servers working with the same virtual world database shard database and or shard servers.

In another embodiment a free shard in set of free shards may have a preference tag. A preference tag is a marker or tag associated with a shard that indicates the shard should be used with requests from one or more particular query servers the shard should preferentially be used with one or more types of queries or the shard should be used with one or more preferred clients or client types. The preference tag may also be implemented as a restriction prohibiting utilization of the shard by one or more identified query servers shard servers and or clients.

For example if the next free shard in set of free shards has a preference tag indicating the free shard is restricted from utilization by query server and or there is a preference for utilization of the shard by a different query server the restricted free shard is passed over and the next unrestricted free shard in the chain is utilized.

In other words query server searches down the chain of free shards in set of free shards until a free shard without a preference tag identifying restriction s and or preference s that would prevent the shard being utilized to respond to query is found. In such a case one or more restricted shards may have to be skipped over before a free shard in the chain without prohibitive restriction s is identified.

In still another embodiment query may include a preference tag. A preference tag indicates which shard server a user prefers to respond to a query. For example a user may have a preference for their queries to be sent to shard servers that gave the users a good response time. In another example a user in the United States may wish to include a preference tag in their queries indicating that the queries should only be sent to shard servers in the United States rather than a server in a different country. This geographic proximity of the shard server and the client may contribute to improved response times.

In this case when query server receives query query server checks for a preference tag. If a preference tag is included in query indicating one or more preferred shard server s query server searches shard database for free shards overlapping shards or existing custom shards responsive to query that are hosted on a preferred shard server s .

In another embodiment virtual world query response system may include one or more third party shard servers owned by a different entity than the entity that owns or controls query server . In other words a third party organization may provide shard server s that work with query server . In such a case the shard server owned by the third party may be located either remotely or locally to query server .

Remote shard server may also be a third party shard server that is part of a global resource pool. In this example shard database maintains entries for all free shards and or custom shards in use located on all shard servers that are part of the global resource pool. When a user sends query to query server query server searches shard database for a matching shard that is responsive to query an overlapping shard that may be updated to be responsive to query or a free shard that may be used to generate a new custom shard responsive to query .

If query server identifies a matching custom shard in use responsive to query in set of shards hosted on remote shard server query server sends an entry point within the matching custom shard to client . If query server identifies an overlapping shard that may be updated with additional content to be responsive to query query server sends the additional content to remote shard server with a directive to add the additional custom content to the overlapping shard to form an updated custom shard. Query server sends an entry point within the updated custom shard to client .

If a custom shard or an overlapping shard is not located query server sends a directive to shard database to identify a free shard. If a free shard is located on the third party server query server then directs the remote third party shard server to generate a responsive custom shard by populating the free shard with the custom content results of the query to form a new custom shard. Query server sends an entry point to the new custom shard on remote shard server to client . If there are no unrestricted free shards available and query server is unable to map query to a matching shard or overlapping shard the request to query server fails and no shard details are returned to client .

In another embodiment query may include a group identifier. A group identifier is a tag or marker identifying clients in a group of clients. When query server receives query accompanied by a group identifier query server searches shard database for a custom shard in use associated with the group identifier. If a custom shard associated with the group identifier is found query server returns an entry point of the custom shard associated with the group identifier to the user. The group identifier permits all clients in the group to connect to the same custom shard and navigate the virtual world content associated with the custom shard as a group.

If query identifies a group identifier with query but does not locate a custom shard in use or an overlapping shard associated with the group identifier query server selects a free shard and generates a new custom shard responsive to query . Query server updates an entry in shard database to identify the new custom shard with the group identifier.

In this example shard database and virtual world database are described as separate components. However in another embodiment shard database and virtual world database may be implemented in a single database component.

Each entry in entries contains information associated with a virtual world web site such as but without limitation an address of the virtual world subject matter of the virtual world content of areas of the virtual world one or more entry points of the virtual world users connected to the virtual world group identifiers associated with the virtual world and or any other information associated with a virtual world. Entries in the shard database are updated to indicate changes to the information associated with a virtual world web site such as without limitation changes in content of a virtual world web site and or changes in client s connecting to or disconnecting from a shard currently in use.

In this example entry and entry are entries identifying two free shards having no virtual world content or clients connected to the shard. Free shard entries and do not contain any content description or client identification.

Entry identifies a custom shard populated with general audience G rated content. The shard database entry optionally identifies a list of user clients that are connected to the G rated custom shard such as but without limitation user 1 user 2 user 3 and group 1. The client group 1 may be a group of one or more users traversing the G rated virtual world shard content as a group. Entry also identifies but without limitation a set of four virtual world entry points world ep1 world ep2 world ep3 and world ep4. The four entry points may be four locations in a single virtual world or entry points for locations in two or more virtual worlds that are responsive to the query.

Entry identifies without limitation a mature audience MA rated custom shard having content associated with Elvis . Entry identifies four clients connected to the shard hosting the Elvis virtual world content two groups associated with the Elvis shard and three entry points for locations within one or more virtual worlds associated with the MA rated Elvis virtual world content on the shard.

Referring now to a flowchart illustrating a process for creating a customized shard in response to a virtual world query is depicted in accordance with an illustrative embodiment. The process in is implemented by a server that responds to virtual world queries such as query server in .

The process begins by receiving a query from a client step . The query is a virtual world query. The query server normalizes the query step . The query server identifies a set of virtual world entry points that are responsive to the query step using a virtual world database. The query server selects a free shard from a set of free shards step . The query server generates custom content associated with the set of virtual world entry points responsive to the query step . The query server adds the custom content to the selected free shard to form a custom shard step .

The query server returns an entry point within the custom shard to the client step . The query server updates the shard database step with the process terminating thereafter.

In one embodiment if the set of virtual world entry points responsive to the query returned at step is an empty set having no responsive virtual world entry points the process returns an indication to the user that the process has failed such as but without limitation returning a not found code.

In another embodiment updating the shard database at step may include without limitation identifying the custom shard as a shard in use identifying the custom shard as a shard that is no longer a free shard identifying the contents of the custom shard identifying a set of clients currently connected to the custom shard describe the content of the custom shard identifying the subject matter of the custom shard identifying tags associated with the custom shard and or identifying any group identifiers associated with the custom shard.

In this embodiment the query server updates the shard database at step . However the update of the shard database may occur at any point from steps . For example when a free shard is selected at step the shard database may be updated to indicate that the selected free shard is no longer free and available for utilization to generate a response to a different query. Likewise when custom content is added to the free shard the shard database may be updated to identify and or describe the content and subject matter being added to the shard.

Turning now to a flowchart illustrating a process for responding to virtual world queries is shown in accordance with an illustrative embodiment. The process in is implemented by a server that responds to virtual world queries such as query server in .

The process begins by receiving a query from a client step . The query is a virtual world query. The query server normalizes the query step . The query server searches a shard database using a set of terms in the query step for a custom shard matching the normalized query. The query server makes a determination as to whether an entry in the shard database matching all terms in the set of terms in the query is found step . If yes the query server identifies the shard associated with the entry matching all the terms in the query step . The query server returns an entry point within the matching shard to the client step with the process terminating thereafter.

Returning now to step if an entry for a matching shard is not found the query server queries a virtual world database for a set of virtual worlds responsive to the query step . The query server generates a new shard having the set of virtual worlds responsive to the query step to form a new custom shard. The query server then returns an entry point within the new shard to the client step with the process terminating thereafter.

The process begins by receiving a query from a client step . The query is a virtual world query. The query server normalizes the query step . The query server identifies a set of virtual world entry points responsive to the query in a virtual world database step . The query server searches a shard database for a custom shard in use that has a set of virtual world entry points matching a threshold number of entries in the set of virtual world entry points to form an overlapping shard step .

The query server makes a determination as to whether an overlapping shard is found step . If no the query server creates a new customized shard responsive to the query step . The query server returns an entry point within the new customized shard to the client step with the process terminating thereafter.

Returning to step if an overlapping shard is found the query server makes a determination as to whether the set of virtual world entry points associated with the overlapping shard contains all the entries in the set of virtual world entries step . If no the process identifies virtual world entry points that are absent from the overlapping shard to form a set of additional entries step . The process adds custom content associated with the set of additional entries to the overlapping shard step . The process returns an entry point within the overlapping shard to the client step with the process terminating thereafter.

Returning to step if the set of virtual world entry points associated with the overlapping shard contains all the entries in the set of virtual world entries the process returns an entry point within the overlapping shard to the client step with the process terminating thereafter.

In one embodiment an overlapping shard is identified at step by searching for a custom shard already in use that has a set of virtual world entries matching a threshold number of entries in the set of virtual world entries. In another embodiment the overlapping shard is identified by searching for a custom shard in use that has a given number of virtual world entries matching entries in the set of virtual world entries that exceeds the overlap threshold. In other words an overlapping shard is a shard already in use that has virtual world entries matching a given number of entries in the set of virtual world entries that is equal to or greater than the overlap threshold. The overlap threshold may be a user defined threshold value a dynamic threshold value a user selected predefined threshold value or a default value.

Referring now to a flowchart illustrating a process for creating a set of focused shards is shown in accordance with an illustrative embodiment. The process in is implemented by a server for responding to virtual world queries such as query server in .

The process begins by receiving a query from a client step . The query is a virtual world query. The query server normalizes the query step . The query server records the query in a set of queries in a query database step . The query server analyzes the set of queries to identify a set of common queries step . The query server identifies a set of focused shards responsive to the set of common queries to form a set of focused shards step with the process terminating thereafter.

In one embodiment the set of focuses shards responsive to the set of common queries comprises a virtual world shard for each query in the set of common queries. In another embodiment a single virtual world shard in the set of focused shards may be responsive to two or more of the queries in set of common queries. In other words a shard in the set of focused shards may be an overlapping or a matching shard having content that is responsive to two or more of the queries in the set of common queries.

In one embodiment identifying the set of focused shards comprises identifying existing custom shards in use that are responsive to each of the common queries. In another embodiment if the process does not identify a shard in use that is responsive to a given common query or any matching or overlapping custom shards that my be wholly or partially responsive to the common query the process generates a new shard with content that is responsive to the common query to form a focused shard for that common query.

The process in may optionally be implemented in addition to the query response system processes discussed in above. In other words in one embodiment when a query is received the query is recorded in a query database for analysis and generation of a set of focused shards in accordance with the process in in addition to responding to the query as described in above.

The process begins by receiving a set of descriptive data associated with a virtual world step . The set of descriptive data may include without limitation a name text a textual description and or a set of tags. The lexical analyzer normalizes the set of descriptive data step . In one embodiment normalizing the set of descriptive data in step includes mapping terms in the set of descriptive data to known normalized tags to generate a set of matching normalized tags.

The lexical analyzer makes a determination as to whether there is an unmapped new term in the set of descriptive data step that the lexical analyzer is unable to map to a known normalized tag. If no the process terminates.

Returning to step if there is a new term in the set of descriptive data the lexical analyzer requests additional input associated with the new term from the user step . The lexical analyzer updates a lexical database step with the additional input and the process terminates thereafter.

The process in is implemented to update the list of normalized tags for a virtual world entry in a virtual world database. In this embodiment the lexical database may not be updated when a new query is received and normalized even when the query contains a set of completely unrecognized terms words and or symbols. Incoming queries are normalized using known terms and known normalized tags in the lexical database associated with the virtual world database being searched.

In one embodiment updating the lexical analyzer in step comprises creating a new normalized tag based on the additional input and updating the lexical database by adding the new normalized tag to the set of normalized tags identified in the lexical database.

In another embodiment updating the lexical analyzer in step comprises updating a known normalized tag by adding some or all of the additional input. In other words updating the lexical database may include adding additional terms to the definition of an already existing normalized tag in the lexical database.

The process begins by receiving a query that includes a group identifier step . The query is a virtual world query. The query server searches a shard database for an entry for a custom shard associated with the group identifier step . The query server makes a determination as to whether a matching entry is found step . If yes the query server returns an entry point within the custom shard associated with the group identifier to the client step with the process terminating thereafter.

Returning to step if a matching entry is not found the query server generates a custom shard step responsive to the query. The query server updates the shard database with an entry for the custom shard having the group identifier step with the process terminating thereafter.

Turning now to a flowchart illustrating a process for utilizing preference tags is depicted in accordance with an illustrative embodiment. The process in is implemented by a server for responding to virtual world queries associated with a preference tag such as query server in .

The process begins by identifying a preference tag in a query received from a client step . The process identifies a set of preferred shard servers step corresponding to the preferences indicated by the preference tag. The process selects a free shard hosted on a preferred shard server step with the process terminating thereafter.

In this example the preference tag in the query expresses a preference as to which shard server should be used to create a new custom shard in response to the query. This preference applies when querying the shard database to find a free shard. In one embodiment if no free shard is found on a preferred shard server the query may be re driven without the preference value to obtain a free shard that could be returned to the user even if the free shard is not a preferred shard. In another embodiment if a preferred shard is not found the query server returns an error notification to the client.

The illustrative embodiments provide a computer implemented method apparatus and computer program product for a virtual world query response system. In one embodiment a set of virtual world entry points that is responsive to a query is identified in a virtual world database. A virtual world entry point is a location within a virtual world. A free shard from a set of free shards is identified. A shard is a virtual world hosted on a server. Custom content associated with the set of virtual world entry points is generated. The custom content is added to the selected free shard to form a custom shard responsive to the query. An entry point of the custom shard is returned to the client.

In another embodiment a shard database is searched for a custom shard having content responsive to the query. The shard database comprises an entry for each custom shard in use or unallocated. The entry for the each custom shard in use comprises a description of content associated with the each custom shard. In response to identifying the custom shard having content responsive to the query in the shard database the entry point of the custom shard to the client.

The virtual world query response system allows multiple users to be sent to the same shard without requiring the users to type in exactly identical queries. The virtual world query system also enables creation of a custom virtual world for a user that contains entry points to different virtual worlds containing content of potential interest to the user based on the user s virtual world query. In other words the customized virtual world hosted on the custom shard provides portals to one or more different virtual worlds with information related to the topics or subject matter in the user s query. This enables a user to traverse different virtual worlds of interest to the user without leaving the immersion of the customized virtual world.

The query server may utilize normalized query tags and virtual world description tags to make connections between queries and virtual world entries in virtual world database that are not immediately obvious in the absence of these tags. The normalized tags further increases the number of queries that produce identical sets of results increasing the number of users query response system can concurrently support and further reducing the requirement on users to type identical queries to end up in the same shard.

The group identifier query tags and virtual world tags enable the query system to group together users making the same or similar queries. Users making the same query are directed to the same virtual world. This enables users to travel through the virtual world search engine as a group. This also provides the ability for a group of users to formulate a search so the groups of users are directed to the same custom shard. Thus the virtual world database and shard database allows the query server to combine more queries and concurrent users into the same shard. The work and resources required to search the virtual world database and construct custom shards can be reused with different clients making the same or similar queries to reduce the overhead of responding to each client query.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any tangible apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk millipede storage technology Magneto resistive random access memory MRAM or phase change memory also known as PCM PRAM Ovonic Unified Memory and Chalcogenide RAM C RAM . Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

