---

title: Systems and methods for automatic installation and execution of a client-side acceleration program
abstract: The present invention is directed towards systems and methods for dynamically deploying and executing acceleration functionality on a client to improve the performance and delivery of remotely accessed applications. The acceleration program of the present invention is automatically installed and executed on a client in a manner transparent to and seamless with the operation of the client. An appliance may intercept a request of the client to establish a communication session or connection with a server, and transmit the acceleration program to the client. In some cases, the appliance determines whether the application being accessed by the client can be accelerated and only provides the acceleration program if the application can be accelerated. Upon receipt of the acceleration program, the client automatically performs a silent installation of the acceleration program and executes the acceleration program upon completion of the installation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08856777&OS=08856777&RS=08856777
owner: Citrix Systems, Inc.
number: 08856777
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20100902
---
This present application claims the benefit of and priority to U.S. Provisional Patent Application No. 60 640 464 entitled SYSTEM AND METHOD FOR DYNAMIC ACCELERATION OF REMOTELY ACCESSED APPLICATIONS filed Dec. 30 2004 which is incorporated by reference in its entirety. This application is also a continuation of co pending U.S. application Ser. No. 11 324 203 entitled SYSTEMS AND METHODS FOR AUTOMATIC INSTALLATION AND EXECUTION OF A CLIENT SIDE ACCELERATION PROGRAM filed Dec. 30 2005 which is incorporated herein by reference.

The present invention generally relates to data communication networks. In particular the present invention relates to systems and methods for automatically deploying installing and executing a client side acceleration program.

Enterprises are increasingly being asked to provide access to applications to employees partners and service provides located outside the perimeter of the enterprise network. However congested wide area network WAN links heavily loaded servers and low bandwidth remote connections can impede access to and slow performance of remotely accessed applications. These factors can substantially impact and reduce employee productivity and the return on investment in enterprise application software and infrastructure. Furthermore these factors can also frustrate and alienate users from using remotely accessed application. To obtain a satisfactory return on investment from these applications enterprises need to ensure that all users regardless of location can use the applications quickly and effectively.

One approach for improving the performance of remotely accessed applications is to install an appliance within the enterprise network that performs certain functions to accelerate application performance. The appliance is typically installed as a gateway between the WAN on a pubic network and the enterprise servers on a private data network and processes data passing between the two. When such an appliance is dedicated to performing acceleration functions it is often referred to as an accelerator. Because the accelerator is deployed within the enterprise network it is more effective at reducing latency on the enterprise network itself and in reducing the load on the enterprise servers. However it is less effective at addressing delays due to problems arising outside the enterprise network such as congested WAN links and low bandwidth remote connections.

In another approach some companies offer application acceleration solutions for the client side of the WAN or the client side LAN. These solutions typically fall into two main categories 1 network appliances that can be installed as a gateway between the client and the WAN and that perform application acceleration functions and 2 application acceleration servers residing on a client side LAN. However installing and maintaining accelerator servers or appliances on the client side LAN consumes time expense and resources. In many cases an enterprise network can be accessed from many different remote sites such as from many different branch offices. To deploy client side acceleration for all remote clients the enterprise would have to install and maintain an appliance based or server based accelerator at each remote site. Additionally if the need to access applications from a remote site is sporadic the time expense and resources of installing and maintaining such an accelerator on the client side LAN at the site may exceed the benefit.

Furthermore a solution of an appliance or server based accelerator on the client side LAN can be a confining one because it limits acceleration of client side LANs to locations having server based or appliance based accelerators. With users having access to multiple computing devices at different remote locations coupled with the ubiquity of mobile computing devices and the increasing availability of wireless network access a user may access a network from a wide range of remote access points at any point in time. For example during the course of a user roaming between access points a user may be able to access the enterprise network from an office desktop computer a smartphone or personal digital assistant a laptop computer a home office computer or a computer at a remote office location such as at a customer or client office. As such the user may desire to access remote applications via the enterprise network at any remote location and on any one of multiple computers available to the user. Each of the remote access point and or multiple computing devices available to the user may have a different client side LAN connection to the enterprise network. The enterprise may not have the time expense and resources to deploy a client side LAN solution at all the possible remote access points or for all the possible computing devices or to continually install and maintain such solutions with the increasing number of remote access points and computing devices of the user. Additionally the user may access the enterprise network from a public network private network or a client side LAN not accessible to or under the control or management of the enterprise. As such an enterprise may not be able to deploy a client side LAN accelerator to all these access points.

What is desired then are systems and methods that provide client side acceleration capabilities for improving the performance of remotely accessed applications. The desired systems and methods should not require the installation and maintenance of a network appliance or a server running acceleration software between the client and the WAN. To further improve the performance of remotely accessed applications it would also be desired if accelerator functions could be implemented both on the client side and the enterprise network side of the WAN.

The present invention is directed towards systems and methods for dynamically deploying and executing acceleration functionality on a client to improve the performance and delivery of remotely accessed applications. The client side acceleration functionality is provided by an acceleration program that performs a plurality of the following acceleration techniques in an integrated and efficient manner 1 multi protocol compression 2 transport control protocol pooling 3 transport control protocol multiplexing 4 transport control protocol buffering and 5 caching. In one aspect the acceleration program of the present invention is automatically installed and executed on a client in a manner transparent to and seamless with the operation of the client. An appliance may intercept a request of the client to establish a communication session or connection with a server and transmit the acceleration program to the client. In some cases the appliance determines whether the application being accessed by the client can be accelerated and only provides the acceleration program if the application can be accelerated. Upon receipt of the acceleration program the client automatically performs a silent installation of the acceleration program and executes the acceleration program upon completion of the installation.

In one aspect the present invention is related to a method for dynamically providing an acceleration program to a client to automatically install and execute. The acceleration program accelerates access by the client to a remotely accessed application. The method includes the steps of receiving by an appliance a request by a client to establish a communication session with a server and transmitting by the appliance to the client an acceleration program comprising a network driver for performing on the client acceleration of a client s access to an application provided via the server. Upon receipt of the acceleration program the client automatically performs a silent installation of the network driver to storage of the client. Upon installation of the network driver the client automatically executes the network driver in memory allocated to the network stack of the client.

In one embodiment of the present invention the method includes transmitting by the appliance the acceleration program to the client upon establishment of the communication session with the server. In another embodiment the method includes establishing by the acceleration program the communication session with the server. In some embodiments the acceleration program is installed on the client without a reboot of the client or an interaction by a user of the client. In other embodiments the installation and execution of the acceleration program is performed on the client transparently to a user of the client an application of the client or the server. In some embodiments the network driver of the present invention comprises a filter device driver interfaced to a transport layer of the network stack. In one embodiment the acceleration program provides client side accelerated access to an application on the server transparently to a network layer a session layer or application layer of the network stack.

In another embodiment the method of the present invention includes transmitting by the appliance a first program to the client. The first program includes the acceleration program. Upon receipt of the first program the client automatically executes the first program to install and execute the acceleration program. In some embodiments the first program includes executable instructions provided to and executed on a browser.

In some embodiments of the present invention the method includes receiving by the appliance a request from the client to access an application on the server and transmitting by the appliance a message to the client communicating to the acceleration program to perform at least one acceleration technique on communications between the client and the server. In a further embodiment the appliance determines whether the application is capable of being accelerated and transmits the message to the client if the application is capable of being accelerated.

In some embodiments the acceleration program executes on the client one of the following acceleration techniques 1 compression 2 decompression 3 Transmission Control Protocol connection pooling 4 Transmission Control Protocol connection multiplexing 5 Transmission Control Protocol buffering and 6 caching. In another embodiment the acceleration program performs encryption or decryption of communications between the client and the server. In one embodiment the network driver establishes a virtual private network connection with the appliance or the server. The appliance may include a cache a gateway a server a firewall a proxy a router a switch or a bridge.

In another aspect the present invention is related to a method for dynamically providing an acceleration program to a client for accelerating access by the client to a remotely accessed application. The method includes receiving by an appliance a request from a client to access an application via a server and determining by the appliance the application is capable of being accelerated. The method further includes transmitting by the appliance an acceleration program to the client for automatic installation and execution on the client. In one embodiment the method of the present invention includes automatically executing and installing by the client the acceleration program receipt of the acceleration program from the appliance. In some embodiments the client receives installs and or executes the acceleration program transparently to an application on the client a user on the client or the server.

In another embodiment the appliance determines the application is not capable of being accelerated and forwards the request to the server. In some embodiments the appliance determines the application is capable of being accelerated by one of the following acceleration techniques compression 1 compression 2 decompression 3 Transmission Control Protocol connection pooling 4 Transmission Control Protocol connection multiplexing 5 Transmission Control Protocol buffering and 6 caching. The appliance may transmit an acceleration program configured to provide the acceleration technique determined by the appliance to be capable of accelerating the application. The acceleration program may perform or execute one of these acceleration techniques. In some embodiments the acceleration program provides a virtual private network to the appliance or the server. The appliance may include a cache a gateway a server a firewall a proxy a router a switch or a bridge.

In some aspects the present invention is related to an appliance for dynamically providing an acceleration program to a client for accelerating access by the client to a remotely accessed application. The appliance may includes a means for receiving a request from a client to access an application via a server determining the application is capable of being accelerated and transmitting an acceleration program to the client. The acceleration program may be configured for automatic installation and execution on the client.

In some embodiments the appliance may also include a means for determining by the appliance the application is not capable of being accelerated and forwarding the request to the server. In other embodiments the appliance includes a means for determining by the application the application is capable of being accelerated by one of the following acceleration techniques 1 compression 2 decompression 3 Transmission Control Protocol connection pooling 4 Transmission Control Protocol connection multiplexing 5 Transmission Control Protocol buffering and 6 caching. In one embodiment the appliance has a means for transmitting by the appliance the acceleration program configured to provide the acceleration technique determined by the appliance to be capable of accelerating the application. The appliance may also establish a virtual private network with the acceleration program. The appliance may include a cache a gateway a server a firewall a proxy a router a switch or a bridge.

The details of various embodiments of the invention are set forth in the accompanying drawings and the description below.

The features and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings in which like reference characters identify corresponding elements throughout. In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements.

The illustrative embodiments of the present invention are directed towards the deployment and execution of client side acceleration techniques in a network environment to improve the performance of communications between a client and a server such as for a remotely accessed application. In one illustrative embodiment the present invention is directed towards the automatic installation and execution of a client side acceleration program on a client in a manner transparent to and seamless with the operation of the client. In another illustrative embodiment the present invention is directed towards dynamically providing by an appliance device the client side acceleration program to the client upon determination of the device that the client s access to a server or remote application can be accelerated. In another illustrative embodiment the present invention is directed towards an acceleration program performing one or more of the following acceleration techniques on the client 1 multi protocol compression 2 transport control protocol pooling 3 transport control protocol multiplexing 4 transport control protocol buffering and 5 caching. In one illustrative embodiment the present invention performs these acceleration techniques in an integrated and efficient manner at the transport layer using a kernel level data structure. In yet another illustrative embodiment the client side acceleration program performs proxy redirection techniques to automatically bypass any intermediary devices to continuously provided access by the client to the server or a remotely accessed application.

The client side acceleration program and functionality of the present invention may be deployed and executed on any type and form of computing device such as a computer network device or appliance capable of communicating on any type and form of network and performing the operations of the present invention described herein. depict block diagrams of a computing device useful for practicing an embodiment of the present invention. As shown in each computing device includes a central processing unit and a main memory unit . As shown in a typical computing device may include a visual display device a keyboard and or a pointing device such as a mouse. Each computing device may also include additional optional elements such as one or more input output devices generally referred to using reference numeral and a cache memory in communication with the central processing unit .

The central processing unit is any logic circuitry that responds to and processes instructions fetched from the main memory unit . In many embodiments the central processing unit is provided by a microprocessor unit such as those manufactured by Intel Corporation of Mountain View Calif. those manufactured by Motorola Corporation of Schaumburg Ill. those manufactured by Transmeta Corporation of Santa Clara Calif. the RS 6000 processor those manufactured by International Business Machines of White Plains N.Y. or those manufactured by Advanced Micro Devices of Sunnyvale Calif. The computing device may be based on any of these processors or any other processor capable of operating as described herein.

Main memory unit may be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by the microprocessor such as Static random access memory SRAM Burst SRAM or SynchBurst SRAM BSRAM Dynamic random access memory DRAM Fast Page Mode DRAM FPM DRAM Enhanced DRAM EDRAM Extended Data Output RAM EDO RAM Extended Data Output DRAM EDO DRAM Burst Extended Data Output DRAM BEDO DRAM Enhanced DRAM EDRAM synchronous DRAM SDRAM JEDEC SRAM PC100 SDRAM Double Data Rate SDRAM DDR SDRAM Enhanced SDRAM ESDRAM SyncLink DRAM SLDRAM Direct Rambus DRAM DRDRAM or Ferroelectric RAM FRAM . The main memory may be based on any of the above described memory chips or any other available memory chips capable of operating as described herein. In the embodiment shown in the processor communicates with main memory via a system bus described in more detail below . depicts an embodiment of a computing device in which the processor communicates directly with main memory via a memory port . For example in the main memory may be DRDRAM.

In the embodiment shown in the processor communicates with various I O devices via a local system bus . Various busses may be used to connect the central processing unit to any of the I O devices including a VESA VL bus an ISA bus an EISA bus a MicroChannel Architecture MCA bus a PCI bus a PCI X bus a PCI Express bus or a NuBus. For embodiments in which the I O device is a video display the processor may use an Advanced Graphics Port AGP to communicate with the display . depicts an embodiment of a computer in which the main processor communicates directly with I O device via HyperTransport Rapid I O or InfiniBand. also depicts an embodiment in which local busses and direct communication are mixed the processor communicates with I O device using a local interconnect bus while communicating with I O device directly.

The computing device may support any suitable installation device such as a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive tape drives of various formats USB device hard drive or any other device suitable for installing software and programs such as any acceleration software or portion thereof related to the present invention.

The computing device may further comprise a storage device such as one or more hard disk drives or redundant arrays of independent disks for storing an operating system and other related software and for storing application software programs such as any program related to the acceleration program of the present invention. Optionally any of the installation devices could also be used as the storage device . Additionally the operating system and the software can be run from a bootable medium for example a bootable CD such as KNOPPIX a bootable CD for GNU Linux that is available as a GNU Linux distribution from knoppix.net.

Furthermore the computing device may include a network interface to interface to a Local Area Network LAN Wide Area Network WAN or the Internet through a variety of connections including but not limited to standard telephone lines LAN or WAN links e.g. 802.11 T1 T3 56 kb X.25 broadband connections e.g. ISDN Frame Relay ATM wireless connections or some combination of any or all of the above. The network interface may comprise a built in network adapter network interface card PCMCIA network card card bus network adapter wireless network adapter USB network adapter modem or any other device suitable for interfacing the computing device to any type of network capable of communication and performing the operations described herein.

A wide variety of I O devices may be present in the computing device . Input devices include keyboards mice trackpads trackballs microphones and drawing tablets. Output devices include video displays speakers inkjet printers laser printers and dye sublimation printers. The I O devices may be controlled by an I O controller as shown in . The I O controller may control one or more I O devices such as a keyboard and a pointing device e.g. a mouse or optical pen. Furthermore an I O device may also provide storage and or an installation medium for the computing device . In still other embodiments the computing device may provide USB connections to receive handheld USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry Inc. of Los Alamitos Calif.

In some embodiments the computing device may comprise or be connected to multiple display devices which each may be of the same or different type and or form. As such any of the I O devices and or the I O controller may comprise any type and or form of suitable hardware software or combination of hardware and software to support enable or provide for the connection and use of multiple display devices by the computing device . For example the computing device may include any type and or form of video adapter video card driver and or library to interface communicate connect or otherwise use the display devices . In one embodiment a video adapter may comprise multiple connectors to interface to multiple display devices . In other embodiments the computing device may include multiple video adapters with each video adapter connected to one or more of the display devices . In some embodiments any portion of the operating system of the computing device may be configured for using multiple displays . In other embodiments one or more of the display devices may be provided by one or more other computing devices such as computing devices and connected to the computing device for example via a network. These embodiments may include any type of software designed and constructed to use another computer s display device as a second display device for the computing device . One ordinarily skilled in the art will recognize and appreciate the various ways and embodiments that a computing device may be configured to have multiple display devices 

In further embodiments an I O device may be a bridge between the system bus and an external communication bus such as a USB bus an Apple Desktop Bus an RS 232 serial connection a SCSI bus a FireWire bus a FireWire bus an Ethernet bus an AppleTalk bus a Gigabit Ethernet bus an Asynchronous Transfer Mode bus a HIPPI bus a Super HIPPI bus a SerialPlus bus a SCI LAMP bus a FibreChannel bus or a Serial Attached small computer system interface bus.

A computing device of the sort depicted in typically operate under the control of operating systems which control scheduling of tasks and access to system resources. The computing device can be running any operating system such as any of the versions of the Microsoft Windows operating systems the different releases of the Unix and Linux operating systems any version of the Mac OS for Macintosh computers any embedded operating system any real time operating system any open source operating system any proprietary operating system any operating systems for mobile computing devices or any other operating system capable of running on the computing device and performing the operations described herein. Typical operating systems include WINDOWS 3.x WINDOWS 95 WINDOWS 98 WINDOWS 2000 WINDOWS NT 3.51 WINDOWS NT 4.0 WINDOWS CE and WINDOWS XP all of which are manufactured by Microsoft Corporation of Redmond Wash. MacOS manufactured by Apple Computer of Cupertino Calif. OS 2 manufactured by International Business Machines of Armonk N.Y. and Linux a freely available operating system distributed by Caldera Corp. of Salt Lake City Utah or any type and or form of a Unix operating system among others.

In other embodiments the computing device may have different processors operating systems and input devices consistent with the device. For example in one embodiment the computer is a Treo 180 270 300 600 or 650 smart phone manufactured by Palm Inc. In this embodiment the Treo smart phone is operated under the control of the PalmOS operating system and includes a stylus input device as well as a five way navigator device. Moreover the computing device can be any workstation desktop computer laptop or notebook computer server handheld computer mobile telephone any other computer or other form of computing or telecommunications device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein.

In one aspect the present invention is related to a client side acceleration program for performing one or more acceleration techniques to accelerate enhance or otherwise improve a client s communications with and or access to a server such as accessing an application provided by a server. Referring now to a client having the acceleration program of the present invention is depicted. In brief overview the client operates on computing device having an operating system with a kernel mode and a user mode and a network stack with one or more layers . The client may have installed and or execute one or more applications . In some embodiments one or more applications may communicate via the network stack to a network. One of the applications N may also include a first program for example a program which may be used in some embodiments to install and or execute the acceleration program .

The network stack of the client may comprise any type and form of software or hardware or any combinations thereof for providing connectivity to and communications with a network. In one embodiment the network stack comprises a software implementation for a network protocol suite. The network stack may comprise one or more network layers such as any networks layers of the Open Systems Interconnection OSI communications model as those skilled in the art recognize and appreciate. As such the network stack may comprise any type and form of protocols for any of the following layers of the OSI model 1 physical link layer 2 data link layer 3 network layer 4 transport layer 5 session layer 6 presentation layer and 7 application layer. In one embodiment the network stack may comprise a transport control protocol TCP over the network layer protocol of the internet protocol IP generally referred to as TCP IP. In some embodiments the TCP IP protocol may be carried over the Ethernet protocol which may comprise any of the family of IEEE wide area network WAN or local area network LAN protocols such as those protocols covered by the IEEE 802.3. In some embodiments the network stack comprises any type and form of a wireless protocol such as IEEE 802.11 and or mobile internet protocol.

In view of a TCP IP based network any TCP IP based protocol may be used including Messaging Application Programming Interface MAPI email File Transfer Protocol FTP HyperText Transfer Protocol HTTP Common Internet File System CIFS protocol file transfer Independent Computing Architecture ICA protocol Remote Desktop Protocol RDP Wireless Application Protocol WAP Mobile IP protocol and Voice Over IP VoIP protocol. In another embodiment the network stack comprises any type and form of transport control protocol such as a modified transport control protocol for example a Transaction TCP T TCP TCP with selection acknowledgements TCP SACK TCP with large windows TCP LW a congestion prediction protocol such as the TCP Vegas protocol and a TCP spoofing protocol. In other embodiments any type and form of user datagram protocol UDP such as UDP over IP may be used by the network stack such as for voice communications or real time data communications.

Furthermore the network stack may include one or more network drivers supporting the one or more layers such as a TCP driver or a network layer driver. The network drivers may be included as part of the operating system of the computing device or as part of any network interface cards or other network access components of the computing device . In some embodiments any of the network drivers of the network stack may be customized modified or adapted to provide a custom or modified portion of the network stack in support of any of the techniques of the present invention described herein. In other embodiments the acceleration program is designed and constructed to operate with or work in conjunction with the network stack installed or otherwise provided by the operating system of the client .

The network stack comprises any type and form of interfaces for receiving obtaining providing or otherwise accessing any information and data related to network communications of the client . In one embodiment an interface to the network stack comprises an application programming interface API . The interface may also comprise any function call hooking or filtering mechanism event or call back mechanism or any type of interfacing technique. The network stack via the interface may receive or provide any type and form of data structure such as an object related to functionality or operation of the network stack . For example the data structure may comprise information and data related to a network packet or one or more network packets. In some embodiments the data structure comprises a portion of the network packet processed at a protocol layer of the network stack such as a network packet of the transport layer. In some embodiments the data structure comprises a kernel level data structure while in other embodiments the data structure comprises a user mode data structure. A kernel level data structure may comprise a data structure obtained or related to a portion of the network stack operating in kernel mode or a network driver or other software running in kernel mode or any data structure obtained or received by a service process task thread or other executable instructions running or operating in kernel mode of the operating system.

Additionally some portions of the network stack may execute or operate in kernel mode for example the data link or network layer while other portions execute or operate in user mode such as an application layer of the network stack . For example a first portion of the network stack may provide user mode access to the network stack to an application while a second portion of the network stack provides access to a network. In some embodiments a first portion of the network stack may comprise one or more upper layers of the network stack such as any of layers . In other embodiments a second portion of the network stack comprises one or more lower layers such as any of layers . Each of the first portion and second portion of the network stack may comprise any portion of the network stack at any one or more network layers in user mode kernel mode or combinations thereof or at any portion of a network layer or interface point to a network layer or any portion of or interface point to the user mode and kernel mode .

The acceleration program of the present may comprise software hardware or any combination of software and hardware. In some embodiments the acceleration program comprises any type and form of executable instructions constructed and designed to execute or provide the functionality and operations of the present invention as described herein. In some embodiments the acceleration program comprises any type and form of application program service process task or thread. In one embodiment the acceleration program comprises a driver such as a network driver constructed and designed to interface and work with the network stack . The logic functions and or operations of the executable instructions of the acceleration program may perform one or more of the following acceleration techniques of the present invention 1 multi protocol compression 2 transport control protocol pooling 3 transport control protocol multiplexing 4 transport control protocol buffering and 5 caching via a cache manager which will be described in further detail below. Additionally the acceleration program may perform encryption and or decryption of any communications received and or transmitted by the client . In some embodiments the acceleration program also performs tunneling between the client and another computing device such as a server. In other embodiments the acceleration program provides a virtual private network connection to a server.

In some embodiments the acceleration program operates at one or more layers of the network stack such as at the transport layer. In one embodiment the acceleration program comprises a filter driver hooking mechanism or any form and type of suitable network driver interface that interfaces to the transport layer of the network stack such as via the transport driver interface TDI . In some embodiments the acceleration program interfaces to a first protocol layer such as the transport layer and another protocol layer such as any layer above the transport protocol layer for example an application protocol layer. In one embodiment the acceleration program may comprise a driver complying with the Network Driver Interface Specification NDIS or a NDIS driver. In another embodiment the acceleration program may comprise a min filter or a mini port driver. In one embodiment the acceleration program or portion thereof operates in kernel mode . In another embodiment the acceleration program or portion thereof operates in user mode . In some embodiments a portion of the acceleration program operates in kernel mode while another portion of the acceleration program operates in user mode . In other embodiments the acceleration program operates in user mode but interfaces to a kernel mode driver process service task or portion of the operating system such as to obtain a kernel level data structure . In further embodiments the acceleration program is a user mode application or program such as application 

The acceleration program may operate at or interface with a protocol layer in a manner transparent to any other protocol layer of the network stack . For example in one embodiment the acceleration program operates or interfaces with the transport layer of the network stack transparently to any protocol layer below the transport layer such as the network layer and any protocol layer above the transport layer such as the session presentation or application layer protocols. This allows the other protocol layers of the network stack to operate as desired and without modification for using the acceleration program of the present invention. As such the acceleration program can interface with the transport layer to accelerate any communications provided via any protocol carried by the transport layer such as any application layer protocol over TCP IP.

Furthermore the acceleration program may operate at or interface with the network stack in a manner transparent to any application a user of the client and any other computing device such as a server in communications with the client . The acceleration program may be installed and or executed on the client in a manner such as the acceleration program may accelerate any communications of an application without modification of the application . In some embodiments the user of the client or a computing device in communications with the client are not aware of the existence execution or operation of the acceleration program . As such in some embodiments the acceleration program is installed executed and or operated transparently to an application user of the client another computing device such as a server or any of the protocol layers above and or below the protocol layer interfaced to by the acceleration program .

In some embodiments the acceleration program performs one or more of the acceleration techniques in an integrated manner or fashion. In one embodiment the acceleration program comprises any type and form of mechanism to intercept hook filter or receive communications at the transport protocol layer of the network stack . By intercepting a network packet of the client at the transport layer and interfacing to the network stack at the transport layer via a data structure such as a kernel level data structure the acceleration program can perform transport layer related acceleration techniques on the network packet such as transport control protocol TCP buffering TCP pooling and TCP multiplexing. Additionally the acceleration program can perform compression on any of the protocols or multiple protocols carried as payload of network packet of the transport layer protocol

In one embodiment the acceleration program uses a kernel level data structure providing access to any portion of one or more network packets for example a network packet comprising a request from a client or a response from a server. In one embodiment the kernel level data structure may be used by the acceleration program to perform the desired acceleration technique. In one embodiment the acceleration program is running in kernel mode when using the kernel level data structure while in another embodiment the acceleration program is running in user mode when using the kernel level data structure . In some embodiments the kernel level data structure may be copied or passed to a second kernel level data structure or any desired user level data structure. Although the acceleration program is generally depicted in as having a first portion operating in user mode and a second portion operating in kernel mode in some embodiments any portion of the acceleration program may run in user mode or kernel mode . In some embodiments the acceleration program may operate only in user mode while in other embodiments the acceleration program may operate only in kernel mode .

Furthermore by intercepting at the transport layer of the network stack or obtaining access to the network packet via a kernel level data structure the acceleration program can perform or apply the plurality of acceleration techniques of the present invention at a single interface point or at a single point of execution or time of executing any executable instructions of the acceleration program . For example in one embodiment in a function or set of instructions of the acceleration program a plurality of the acceleration techniques may be executed such as by calling a set of executable instructions constructed and designed to perform the acceleration technique. In some embodiments the acceleration program at one interface point place of execution or in a set of instructions call one or more application programming interfaces APIs to any program service process task thread or executable instructions designed and constructed to provide 1 multi protocol compression 2 transport control protocol pooling 3 transport control protocol multiplexing 4 transport control protocol buffering and 5 caching via a cache manager and in some embodiments encryption .

By executing the plurality of acceleration techniques at one place or location in executable instructions of the acceleration program or at one protocol layer of the network stack such as the transport layer the integration of these acceleration techniques is performed more efficiently and effectively. In one aspect the number of context switches between processes may be reduced as well as reducing the number of data structures used or copies of data structures in memory needed or otherwise used. Additionally synchronization of and communications between any of the acceleration techniques can be performed more efficiently such as in a tightly coupled manner in a set of executable instructions of the acceleration program . As such any logic rules functionality or operations regarding the order of acceleration techniques which techniques to perform and data and information to be shared or passed between techniques can be performed more efficiently. The acceleration program can intercept a TCP packet at the transport layer obtain the payload of the TCP packet via a kernel level data structure and then perform desired acceleration techniques in a desired order. For example the network packet may be first compressed and then cached. In another example the compressed cached data may be communicated via a buffered pooled and or multiplexed TCP connection to a server.

In some embodiments and still referring to a first program may be used to install and or execute the acceleration program automatically silently transparently or otherwise. In one embodiment the first program comprises a plugin component such an ActiveX control or Java control or script that is loaded into and executed by an application . For example the first program comprises an ActiveX control loaded and run by a web browser application such as in the memory space or context of the application . In another embodiment the first program comprises a set of executable instructions loaded into and run by the application such as a browser. In one embodiment the first program comprises a designed and constructed program to install the acceleration program . In some embodiments the first program obtains downloads or receives the acceleration program via the network from another computing device. In another embodiment the first program is an installer program or a plug and play manager for installing programs such as network drivers on the operating system of the client .

In other embodiments the first program may comprise a portion of the functionality operations and logic of the acceleration program to facilitate or perform any of the functionality operations and logic of the acceleration program described herein such as any of the acceleration techniques. In some embodiments the first program is used to establish a connection such as a transport layer connection or a communication session with an appliance or a server such as a Secure Socket Layer SSL communication session. In one embodiment the first program is used to establish or facilitate the establishment of a virtual private network connection and communication session.

The cache manager of the acceleration program or the client as depicted in may comprise software hardware or any combination of software and hardware to provide cache access control and management of any type and form of content such as objects or dynamically generated objects served by the servers . The data objects or content processed and stored by the cache manager may comprise data in any format such as a markup language or communicated via any protocol. In some embodiments the cache manager duplicates original data stored elsewhere or data previously computed generated or transmitted in which the original data may require longer access time to fetch compute or otherwise obtain relative to reading a cache memory element. Once the data is stored in the cache memory element future use can be made by accessing the cached copy rather than refetching or recomputing the original data thereby reducing the access time. In some embodiments the cache memory element may comprise a data object in memory of the client . In other embodiments the cache memory element may comprise memory having a faster access time than memory otherwise used by the client . In another embodiment the cache memory element may comprise any type and form of storage element of the client such as a portion of a hard disk. In yet another embodiment the cache manager may use any portion and combination of memory storage or the processing unit for caching data objects and other content.

Furthermore the cache manager of the present invention includes any logic functions rules or operations to perform any embodiments of the techniques of the present invention described herein. For example the cache manager includes logic or functionality to invalidate objects based on the expiration of an invalidation time period or upon receipt of an invalidation command from a client or server . In some embodiments the cache manager may operate as a program service process or task executing in the kernel space and in other embodiments in the user space . In one embodiment a first portion of the cache manager executes in the user space while a second portion executes in the kernel space . In some embodiments the cache manager can comprise any type of general purpose processor GPP or any other type of integrated circuit such as a Field Programmable Gate Array FPGA Programmable Logic Device PLD or Application Specific Integrated Circuit ASIC .

The encryption engine of the acceleration program or the client comprises any logic business rules functions or operations for handling the processing of any security related protocol such as SSL or TLS or any function related thereto. For example the encryption engine encrypts and decrypts network packets or any portion thereof communicated by the client . The encryption engine may also setup or establish SSL or TLS connections on behalf of the client . As such the encryption engine provides offloading and acceleration of SSL processing. In one embodiment the encryption engine uses a tunneling protocol to provide a virtual private network between a client and another computing device such as a server

Still referring to the multi protocol compression engine of the acceleration program or the client comprises any logic business rules function or operations for compressing one or more protocols of a network packet such as any of the protocols used by the network stack of the client . For example multi protocol compression may include compression and decompression utilities comprising GZip compression and decompression differential compression and UnCompression or any other proprietary or publicly available utility for compressing and decompressing data to be transmitted over a network. In one embodiment multi protocol compression engine compresses bi directionally between the client and another computing device such as a servers any TCP IP based protocol including Messaging Application Programming Interface MAPI email File Transfer Protocol FTP HyperText Transfer Protocol HTTP Common Internet File System CIFS protocol file transfer Independent Computing Architecture ICA protocol Remote Desktop Protocol RDP Wireless Application Protocol WAP Mobile IP protocol and Voice Over IP VoIP protocol. In other embodiments multi protocol compression engine provides compression of Hypertext Markup Language HTML based protocols and in some embodiments provides compression of any markup languages such as the Extensible Markup Language XML . As such the multi protocol compression engine of the present invention accelerates performance for users accessing applications via desktop clients e.g. Microsoft Outlook and non Web thin clients such as any client launched by enterprise applications like Oracle SAP and Siebel and even mobile clients such as the Pocket PC.

The acceleration program of the present invention also performs transport protocol layer acceleration techniques of buffering pooling and multiplexing as will be described in further detail below. As such the acceleration program comprises any type and form of executable instructions having logic rules functions and operations to perform any of these techniques as described herein. The acceleration program intercepts controls and manages at the transport layer of the network stack any transport layer application programming interface API calls made by an applications via the network stack . The acceleration program responds to any requests of the client in a transparent manner such that the client receives a response as expected from the transport protocol layer of the network stack . For example in one embodiment the acceleration program intercepts in the network stack of the client a request to establish a transport layer connection with another computing device such as a server and may use a pool of one or more transport layer connections established by the acceleration program to respond to the request. In another embodiment the acceleration program multiplexes a request from a first application via an established transport layer connection used by a second application

In some embodiments the acceleration program comprises a mechanism for buffering or holding communications of the client at the client before transmitting on a network. For example the rate of consumption by the client of received communications from a network such as from a server may be less than the rate of production of communications transmitted by the client on the network. As such the client may be sending more requests to a server at a rate greater than by which the client can consume and process responses from such requests. The acceleration program can intercept a communication and determine if a rate of consumption and or rate of production of the client is below a predetermined threshold such as a threshold configured by a user the client or another computing device. If the determined rate is below the desired threshold the acceleration program stores the intercepted communication to a memory element of the client until the performance of the client increases the rate of consumption and or production to a rate equal to or higher than the predetermined or desired threshold. At that point the acceleration program communicates the client s communications on the network. As such the present invention provides a client side mechanism to throttle communications of the client based on performance of consumption and or production of communications by the client .

The application depicted in can be any type and or form of application such as any type and or form of web browser web based client client server application a thin client computing client an ActiveX control or a Java applet or any other type and or form of executable instructions capable of executing on client or communicating via a network . The application can use any type of protocol and it can be for example an HTTP client an FTP client an Oscar client or a Telnet client. In some embodiments the application uses a remote display or presentation level protocol. In one embodiment the application is an ICA client developed by Citrix Systems Inc. of Fort Lauderdale Fla. In other embodiments the application includes a Remote Desktop RDP client developed by Microsoft Corporation of Redmond Wash. In other embodiments the application comprises any type of software related to VoIP communications such as a soft IP telephone. In further embodiments the application comprises any application related to real time data communications such as applications for streaming video and or audio.

Referring now to a network environment for practicing the acceleration program of the present invention is depicted. In brief overview the environment comprises clients in communication with one or more servers via a network . The servers may provide or execute one or more applications for use by the clients . The servers may also include the acceleration program to provide to a client for installation and execution. For example in one embodiment the server in response to receipt of a request from the client to access the server such as upon a request to establish a connection or communication session with the server transmits the acceleration program to the client 

The network can be any type and form of network. The network can be a local area network LAN such as a company Intranet a metropolitan area network MAN or a wide area network WAN such as the Internet or the World Wide Web. The topology of the network may be a bus star or ring network topology. The network and network topology may be of any such network or network topology capable of supporting the operations of the present invention described herein. The clients and servers can connect to one or more networks through a variety of connections including standard telephone lines LAN or WAN links e.g. T1 T3 56 kb X.25 SNA DECNET broadband connections ISDN Frame Relay ATM Gigabit Ethernet Ethernet over SONET and wireless connections or any combination thereof. Connections can be established using a variety of communication protocols e.g. TCP IP IPX SPX NetBIOS Ethernet ARCNET Fiber Distributed Data Interface FDDI RS232 IEEE 802.11 IEEE 802.11a IEEE 802.11b IEEE 802.11g and direct asynchronous connections .

In some embodiments the server may run an application which for example may be an application server providing email services such as Microsoft Exchange manufactured by the Microsoft Corporation of Redmond Wash. a web or Internet server or a desktop sharing server or a collaboration server. In some embodiments any of the application may comprise any type of hosted service such as GoToMeeting.com provided by Citrix Systems Inc. of Ft. Lauderdale Fla. WebEx.com provided by WebEx Inc. of Santa Clara Calif. or LiveMeeting.com provided by Microsoft Corporation of Redmond Wash.

In another embodiment any of the clients may communicate via the network to a server farm or server network which is a logical group of one or more servers that are administered as a single entity. The server farm may be running one or more applications such as an application providing a thin client computing or remote display presentation application. In one embodiment the server or server farm executes as an application any portion of the Citrix Access Suite by Citrix Systems Inc. such as the MetaFrame or Citrix Presentation Server and or any of the Microsoft Windows Terminal Services manufactured by the Microsoft Corporation. In some embodiments any one of the servers comprises a gateway firewall router switch or bridge for connecting the clients to any server . In one embodiment a server comprises a proxy. In another embodiment the server comprises a load balancer. In some embodiments the clients may communicate to the server via an appliance.

The appliance comprises any type of computing or networking device. In some embodiments the appliance comprises a gateway a proxy a SSL VPN device a bridge a router or a switch. In one embodiment the appliance provides a virtual private connection from a client on network to a server on network . In some embodiments the appliance may establish a first transport layer connection with a client on network and a second transport layer connection with a server on network . In some embodiments the appliance provides for the acceleration of communications and remotely accessed applications such as applications between the clients and the servers . As with the client side acceleration program the logic functions and or operations of the executable instructions of the appliance may perform one or more of the following acceleration techniques of the present invention 1 multi protocol compression 2 transport control protocol pooling 3 transport control protocol multiplexing 4 transport control protocol buffering and 5 caching via a cache manager. Additionally the appliance may perform encryption and or decryption of any communications received and or transmitted by the client . In some embodiments the appliance also performs tunneling between to the server such for a client 

The appliance comprises an application acceleration determination mechanism and a client side acceleration program . The application acceleration determination mechanism comprises software hardware or any combination of hardware and software. In some embodiments the application acceleration determination mechanism comprises any type and form of executable instructions such as a program services process task or thread having logic function rules or operations for determining whether an application executing on a client and or server can be accelerated or whether access or communications between a client and a server can be accelerated. In one embodiment a database is used by the application acceleration determination mechanism to determine whether an application can be accelerated. For example the database may associate an application with one or more acceleration techniques capable of accelerating the application and may be further based on user type form location processing capability and other characteristics of the client and or server . In some embodiments the application acceleration determination mechanism uses a look up table file data structure or object in memory comprising information identifying if an application by name type or category can be accelerated by an acceleration technique. In other embodiments the appliance and or application acceleration determination mechanism includes a configuration mechanism such as a user interface graphical command line or otherwise to receive user input to identify specify or configure whether an application or access to a server can be accelerated.

In some embodiments the application acceleration determination mechanism requests from the server information identifying whether an application may be accelerated and in further embodiments by what acceleration technique s and for what type and form of clients . In yet another embodiment the application acceleration determination mechanism comprises a database of historical information regarding the performance of an application between a client and a server with and without one or more client side acceleration techniques to provide a database of comparative and heuristic information about where the application is accelerated or capable of being accelerated using any client side acceleration techniques of the present invention. For example the appliance may capture network related performance information related to the performance of the application from the client . As such the determination of whether an application is capable of being accelerated may be adapted to based on or influenced by changing operational and performance characteristics of the network .

In one aspect an application may either not be capable of being accelerated or may be capable of being accelerated but the acceleration would not be effective or would otherwise be minimal. In one embodiment the type and form of application may not use a protocol or may not communicate in a manner suitable for use with an acceleration technique. In another embodiment the protocol or manner in which the application communicates may allow for performing an acceleration technique but based on any of the operational or performance characteristics of the client appliance or server the acceleration technique would not be effective or otherwise would provide minimal acceleration. As such the application acceleration determination mechanism may determine the application is not desired to be accelerated based on whether the application is able to be accelerated or whether the acceleration would meet a desired pre determined threshold of performance improvement.

In another aspect the appliance stores a client side acceleration program in a storage or memory element of the appliance such as storage or memory provided by the hardware layer of the appliance. In one embodiment the appliance dynamically determines via the application acceleration determination mechanism an application to be used or being used by the client can be accelerated by the acceleration program executing on the client and transmits or otherwise communicates the acceleration program from storage or memory of the appliance to the client . In another embodiment the appliance determines communications between the client and a server can be accelerated by the acceleration program executing on the client and communicates the acceleration program to the client . In some embodiments the appliance receives downloads or obtains the acceleration program from another computing device such as a server 

As shown in the hardware layer includes a processing unit for executing software programs and services a memory for storing software and data network ports for transmitting and receiving data over a network and an encryption processor for performing functions related to Secure Sockets Layer processing of data transmitted and received over the network. In some embodiments the central processing unit may perform the functions of the encryption processor in a single processor. Additionally the hardware layer may comprise multiple processors for each of the processing unit and the encryption processor . Although the hardware layer of appliance is generally illustrated with an encryption processor processor may be a processor for performing functions related to any encryption protocol such as the Secure Socket Layer SSL or Transport Layer Security TLS protocol. In some embodiments the processor may be a general purpose processor GPP and in further embodiments may be have executable instructions for performing processing of any security related protocol.

Although the hardware layer of appliance is illustrated with certain elements in the hardware portions or components of appliance may comprise any type and form of elements hardware or software of a computing device such as the computing device illustrated and discussed in conjunction with . In some embodiments the appliance may comprise a cache a server gateway router switch bridge or other type and form of computing or network device and have any hardware and or software elements associated therewith.

The operating system of appliance allocates manages or otherwise segregates the available system memory into kernel space and user space . In example software architecture the operating system may be any type and or form of UNIX operating system although the invention is not so limited. As such the appliance can be running any operating system such as any of the versions of the Microsoft Windows operating systems the different releases of the Unix and Linux operating systems any version of the Mac OS for Macintosh computers any embedded operating system any network operating system any real time operating system any open source operating system any proprietary operating system any operating systems for mobile computing devices or network devices or any other operating system capable of running on the appliance and performing the operations described herein.

The kernel space is reserved for running the kernel including any device drivers kernel extensions or other kernel related software. As known to those skilled in the art the kernel is the core of the operating system and provides access control and management of resources and hardware related elements of the application . In accordance with an embodiment of the present invention the kernel space also includes a number of network services or processes working in conjunction with a cache manager . sometimes also referred to as the integrated cache the benefits of which are described in detail further herein. Additionally the embodiment of the kernel will depend on the embodiment of the operating system installed configured or otherwise used by the appliance .

In one embodiment the appliance comprises one network stack such as a TCP IP based stack for communicating with the client and or the server . In one embodiment the network stack is used to communicate with a first network such as network and a second network . In some embodiments the appliance terminates a first transport layer connection such as a TCP connection of a client and establishes a second transport layer connection to a server for use by the client e.g. the second transport layer connection is terminated at the appliance and the server . The first and second transport layer connections may be established via a single network stack . In other embodiments the appliance may comprise multiple network stacks for example and and the first transport layer connection may be established or terminated at one network stack and the second transport layer connection on the second network stack . For example one network stack may be for receiving and transmitting network packet on a first network and another network stack for receiving and transmitting network packets on a second network. In one embodiment the network stack comprises a buffer for queuing one or more network packets for transmission by the appliance .

As shown in the kernel space includes the cache manager a high speed layer integrated packet engine an encryption engine a policy engine and multi protocol compression logic . Running these components or processes and in kernel space or kernel mode instead of the user space improves the performance of each of these components alone and in combination. Kernel operation means that these components or processes and run in the core address space of the operating system of the appliance . For example running the encryption engine in kernel mode improves encryption performance by moving encryption and decryption operations to the kernel thereby reducing the number of transitions between the memory space or a kernel thread in kernel mode and the memory space or a thread in user mode. For example data obtained in kernel mode may not need to be passed or copied to a process or thread running in user mode such as from a kernel level data structure to a user level data structure. In another aspect the number of context switches between kernel mode and user mode are also reduced. Additionally synchronization of and communications between any of the components or processes and can be performed more efficiently in the kernel space .

In some embodiments any portion of the components and may run or operate in the kernel space while other portions of these components and may run or operate in user space . In one embodiment the present invention uses a kernel level data structure providing access to any portion of one or more network packets for example a network packet comprising a request from a client or a response from a server . In some embodiments the kernel level data structure may be obtained by the packet engine via a transport layer driver interface or filter to the network stack . The kernel level data structure may comprise any interface and or data accessible via the kernel space related to the network stack network traffic or packets received or transmitted by the network stack . In other embodiments the kernel level data structure may be used by any of the components or processes and to perform the desired operation of the component or process. In one embodiment a component and is running in kernel mode when using the kernel level data structure while in another embodiment the component and is running in user mode when using the kernel level data structure. In some embodiments the kernel level data structure may be copied or passed to a second kernel level data structure or any desired user level data structure.

As with the client side acceleration program the appliance may also perform caching for any communications between the client and the servers . In some embodiments the cache memory element may comprise a data object in memory of appliance . In other embodiments the cache memory element may comprise memory having a faster access time than memory . In another embodiment the cache memory element may comprise any type and form of storage element of the appliance such as a portion of a hard disk. In some embodiments the processing unit may provide cache memory for use by the cache manager of the present invention. In yet further embodiments the cache manager may use any portion and combination of memory storage or the processing unit of the appliance for caching data objects and other content. Furthermore the cache manager of the present invention includes any logic functions rules or operations to perform any embodiments of the techniques of the present invention described herein. For example the cache manager includes logic or functionality to invalidate objects based on the expiration of an invalidation time period or upon receipt of an invalidation command from a client or server . In some embodiments the cache manager may operate as a program service process or task executing in the kernel space and in other embodiments in the user space . In one embodiment a first portion of the cache manager executes in the user space while a second portion executes in the kernel space . In some embodiments the cache manager can comprise any type of general purpose processor GPP or any other type of integrated circuit such as a Field Programmable Gate Array FPGA Programmable Logic Device PLD or Application Specific Integrated Circuit ASIC .

The policy engine as depicted in may include for example an intelligent statistical engine or other programmable application s . In one embodiment the policy engine provides a configuration mechanism to allow a user to identify specify define or configure a caching policy. Policy engine in some embodiments also has access to memory to support data structures such as lookup tables or hash tables to enable user selected caching policy decisions. In other embodiments the policy engine may comprise any logic rules functions or operations to determine and provide access control and management of objects data or content being cached by the appliance in addition to access control and management of security network traffic network access compression or any other function or operation performed by the appliance . In some embodiments the acceleration program receives downloads or obtains policy information from the policy engine of the appliance . In other embodiments the acceleration program executes and operates a policy engine either independently of or in conjunction with the policy engine of the appliance .

In a similar manner as the client side acceleration program and still referring to the appliance includes an encryption engine which comprises any logic business rules functions or operations for handling the processing of any security related protocol such as SSL or TLS or any function related thereto. For example the encryption engine encrypts and decrypts network packets or any portion thereof communicated via the appliance . The encryption engine may also setup or establish SSL or TLS connections on behalf of the client server or appliance . As such the encryption engine provides offloading and acceleration of SSL processing. In one embodiment the encryption engine uses a tunneling protocol to provide a virtual private network between a client and a server . In some embodiments the encryption engine is in communication with the encryption processor . In other embodiments the encryption engine comprises executable instructions running on the Encryption processor .

Also as with the client side acceleration program the appliance may include a multi protocol compression engine which comprises any logic business rules function or operations for compressing one or more protocols of a network packet such as any of the protocols used by the network stack of the appliance . In one embodiment multi protocol compression engine compresses bi directionally between clients and servers any TCP IP based protocol including Messaging Application Programming Interface MAPI email File Transfer Protocol FTP HyperText Transfer Protocol HTTP Common Internet File System CIFS protocol file transfer Independent Computing Architecture ICA protocol Remote Desktop Protocol RDP Wireless Application Protocol WAP Mobile IP protocol and Voice Over IP VoIP protocol. In other embodiments multi protocol compression engine provides compression of Hypertext Markup Language HTML based protocols and in some embodiments provides compression of any markup languages such as the Extensible Markup Language XML . In one embodiment the multi protocol compression engine provides compression of any high performance protocol such as any protocol designed for appliance to appliance communications. In another embodiment the multi protocol compression engine compresses any payload of or any communication using a modified transport control protocol such as Transaction TCP T TCP TCP with selection acknowledgements TCP SACK TCP with large windows TCP LW a congestion prediction protocol such as the TCP Vegas protocol and a TCP spoofing protocol.

As such the multi protocol compression engine of the present invention accelerates performance for users accessing applications via desktop clients e.g. Microsoft Outlook and non Web thin clients such as any client launched by popular enterprise applications like Oracle SAP and Siebel and even mobile clients such as the Pocket PC. In some embodiments the multi protocol compression engine by executing in the kernel mode and integrating with packet processing engine accessing the network stack is able to compress any of the protocols carried by the TCP IP protocol such as any application layer protocol.

High speed layer integrated packet engine depicted in also generally referred to as a packet processing engine or packet engine is responsible for managing the kernel level processing of packets received and transmitted by appliance via network ports . The high speed layer integrated packet engine may comprise a buffer for queuing one or more network packets during processing such as for receipt of a network packet or transmission of a network packer. Additionally the high speed layer integrated packet engine is in communication with one or more network stacks to send and receive network packets via network ports . The high speed layer integrated packet engine works in conjunction with encryption engine cache manager policy engine and multi protocol compression logic . In particular encryption engine is configured to perform SSL processing of packets policy engine is configured to perform functions related to traffic management such as request level content switching and request level cache redirection and multi protocol compression logic is configured to perform functions related to compression and decompression of data.

The high speed layer integrated packet engine includes a packet processing timer . In one embodiment the packet processing timer provides one or more time intervals to trigger the processing of incoming i.e. received or outgoing i.e. transmitted network packets. In some embodiments the high speed layer integrated packet engine processes network packets responsive to the timer . The packet processing timer provides any type and form of signal to the packet engine to notify trigger or communicate a time related event interval or occurrence. In many embodiments the packet processing timer operates in the order of milliseconds. For example in some embodiments the packet processing timer provides time intervals or otherwise causes a network packet to be processed by the high speed layer integrated packet engine at a 10 ms time interval while in other embodiments at a 5 ms time interval and still yet in further embodiments at a 1 and or 2 ms time interval. The high speed layer integrated packet engine may be interfaced integrated or in communication with the encryption engine cache manager policy engine and multi protocol compression engine during operation. As such any of the logic functions or operations of the encryption engine cache manager policy engine and multi protocol compression logic may be performed responsive to the packet processing timer and or the packet engine . Therefore any of the logic functions or operations of the encryption engine cache manager policy engine and multi protocol compression logic may be performed at the granularity of time intervals provided via the packet processing timer for example at a time interval of less than or equal to 10 ms. For example in one embodiment the cache manager may perform invalidation of any cached objects responsive to the high speed layer integrated packet engine and or the packet processing timer . In another embodiment the expiry or invalidation time of a cached object can be set to the same order of granularity as the time interval of the packet processing timer such as at every 10 ms.

In other embodiments the packet engine or portion thereof may be operated on the client such as part of the acceleration program . As such the acceleration program may operate on the client in accordance with the packet processing timer as described above. In one aspect the acceleration program may perform integrated acceleration techniques in one point in execution and responsive to the granular time intervals provided by the pack processing timer .

In contrast to kernel space user space is the memory area or portion of the operating system used by user mode applications or programs otherwise running in user mode. A user mode application may not access kernel space directly and uses service calls in order to access kernel services. As shown in user space of appliance includes a graphical user interface GUI a command line interface CLI shell services health monitoring program and daemon services . GUI and CLI provide a means by which a system administrator or other user can interact with and control the operation of appliance such as via the operating system of the appliance and either is user space or kernel space . The GUI may be any type and form of graphical user interface and may be presented via text graphical or otherwise by any type of program or application such as a browser. The CLI may be any type and form of command line or text based interface such as a command line provided by the operating system. For example the CLI may comprise a shell which is a tool to enable users to interact with the operating system. In some embodiments the CLI may be provided via a bash csh tcsh or ksh type shell. The shell services comprises the programs services tasks processes or executable instructions to support interaction with the appliance or operating system by a user via the GUI and or CLI .

Still referring to health monitoring program is used to monitor check report and ensure that network systems are functioning properly and that users are receiving requested content over a network. Health monitoring program comprises one or more programs services tasks processes or executable instructions to provide logic rules functions or operations for monitoring any activity of the appliance . In some embodiments the health monitoring program intercepts and inspects any network traffic passed via the appliance . In other embodiments the health monitoring program interfaces by any suitable means and or mechanisms with one or more of the following the encryption engine cache manager policy engine multi protocol compression logic packet engine daemon services and shell services . As such the health monitoring program may call any application programming interface API to determine a state status or health of any portion of the appliance . For example the health monitoring program may ping or send a status inquiry on a periodic basis to check if a program process service or task is active and currently running. In another example the health monitoring program may check any status error or history logs provided by any program process service or task to determine any condition status or error with any portion of the appliance .

In a similar fashion and in other embodiments the health monitoring program may check and determine the status error or history of any client side acceleration program on any client in communication with the appliance or to which the appliance transmitted the acceleration program . In some embodiments the health monitoring program or a portion thereof executes on the client 

Daemon services are programs that run continuously or in the background and handle periodic service requests received by appliance . In some embodiments a daemon service may forward the requests to other programs or processes such as another daemon service as appropriate. A daemon service may run unattended to perform continuous or periodic system wide functions such as network control or to perform any desired task. In some embodiments one or more daemon services run in the user space while in other embodiments one or more daemon services run in the kernel space .

Referring now to an embodiment of a method of the present invention for dynamically providing by the appliance an acceleration program and automatically installing and executing the acceleration program by the client is depicted. In brief overview at step the appliance intercepts a request from a client to establish a communication session with the server. At step the appliance transmits the acceleration program to the client for the client to automatically install and execute. At step upon receipt of the acceleration program the client automatically executes or performs a silent installation of the acceleration program . At step upon completion of installation of the acceleration program the client automatically executes the acceleration program in the network stack to intercept communications between the client and the server . At step the acceleration program performs any of the plurality of acceleration techniques and may encrypt and or decrypt communications.

In further detail at step the appliance may intercept or otherwise receive by any suitable means and mechanisms a request from the client to establish a communication session with the server . In one embodiment the packet engine of the appliance intercepts communications from the client . In other embodiments the appliance establishes a first transport layer connection with the client for example with the acceleration program and a second transport layer connection with the server on behalf of the client . As such the appliance may receive intercept or otherwise obtain any of the client s communications transmitted to the server . In some embodiments the appliance intercepts a request for the client to establish a transport layer connection with the server . In other embodiments the appliance intercepts a request to establish a communication session via any protocol layer above the transport layer connection such as an application layer protocol of HTTP. This embodiment of the method of the present invention may be practiced with a request to establish a communication session at any protocol layer of the network stack of the client .

At step the appliance transmits the acceleration program to the client . The appliance may transmit the acceleration program at any point before during or after establishing the communication session requested by the client . In one embodiment the appliance transmits the acceleration program to the client in response to intercepting the client request. In another embodiment the appliance forwards the request to the server and transmits the acceleration program to the client . In some embodiments the appliance establishes the communication session with the server and upon establishment of the communication session the appliance transmits the acceleration program . In yet another embodiment the appliance performs authentication and or authorization of the client or the user of the client and if the authenticated user or client is so authorized the appliance transmits the acceleration program to the client . In one embodiment the appliance forwards the client s request to the server for authentication and or authorization and if the server authenticates and or authorizes the client s request the appliance transmits the acceleration program to the client .

In some embodiments the appliance transmits the acceleration program from storage or memory of the appliance . In other embodiments the appliance requests the acceleration program from the server and forwards the received acceleration program to the client . In another embodiment the server transmits the acceleration program to the client . In one embodiment the appliance transmits a Uniform Resource Locator URL to the client for the client to obtain download or receive the acceleration program. In some embodiments the URL identifies a location of the acceleration program in storage or memory of the appliance while in other embodiments the URL identifies the acceleration program on a server such as a web server providing the acceleration program for download. In one embodiment the acceleration program is stored on the client and the appliance transmits a key such as an encryption or license key to the client for the client to install and make use of the acceleration program stored on the client . In some embodiments the appliance transmits to the client any files configuration data or other information to be used to install and execute the acceleration program on the client .

In one embodiment the acceleration program is designed and constructed to be automatically installed and executed by the client . The acceleration program may include any files entries configuration data or instructions to cause the acceleration program to be registered or recognized by the operating system of the client in accordance with the type and form of operating system. In one embodiment another computing device such as a server or an appliance transmits the acceleration program to the client and the client automatically installs and executes the acceleration program . In one embodiment the acceleration program is designed and constructed to be a plug and play PnP device to be added to a running computing device . In some embodiments the acceleration program is a self installed executable such as an executable including an installer program and the acceleration program . In other embodiments the acceleration program may include a plurality of files for example an installation package or installation download such as files necessary to register and install the acceleration program in the operating system of the client . For example the acceleration program may comprise an .inf file and a .sys file. An .inf file provides Windows Setup in Microsoft Windows family of operating systems with the information required to set up a device such as a list of valid logical configurations for the device and the names of driver files associated with the device. In some embodiments the .inf file may comprise an autorun .inf file which is a configuration file that tells or informs the operating system which executable to start and any configuration information related to starting the executable. In one embodiment the .sys file is the driver file comprising the acceleration program or a portion thereof.

At step the client automatically installs the acceleration program . The acceleration program may be installed in any suitable manner in accordance with the operating system of the client . In one embodiment the client installs the acceleration program upon receipt of the acceleration program . In some embodiments the client automatically performs or executes a silent installation of the acceleration program . In one embodiment the silent installation is performed transparently to a user or application of the client . In other embodiments the silent installation of the acceleration program does not require a reboot or restart of the client . In another embodiment the silent installation does not require interaction by the user to start and or complete the installation. In other embodiments the silent installation of the acceleration program occurs while the client is running and transparently to a network layer session layer and or application layer of the network stack . In some embodiments the acceleration program is a self installed executable that is executed by the client . In other embodiments the client uses a plug and play manager to install the acceleration program . In one embodiment the client comprises an installation manager which receives and installs the acceleration program . In another embodiment the acceleration program transmitted by the appliance also includes an installation program that installs the acceleration program .

In another embodiment the acceleration program is automatically installed via a silent installation. In one embodiment a silent installation comprises an installation unattended by a user. In another embodiment a silent installation comprises an installation not requiring or having interaction by the user to start and or complete the installation. In some embodiments the installation is silent in that the installation process does not display information regarding a status or progress of the installation. In one embodiment the installation is silent in that it is transparent to the user. In other embodiments the installation is silent because the installation of the acceleration program does not require a reboot or restart of the client . In another embodiment the installation is silent in that the installation occurs seamlessly during operation of the client without interruption or disruption to the client s operation. As such the acceleration program can be installed in a manner that is transparent to the user or an application of the client by not requiring a reboot and not displaying any information to the user related to the installation.

In order to prevent or avoid a reboot or restart of the client in some embodiments the client such as the operating system of the client has a plug and play manager to install and configure drivers such as a network driver in one embodiment of the acceleration program for Plug and Play devices while the operating system is running. In one embodiment the plug and play manager is not instructed to reboot or restart the client based on the configuration of the installation package of the acceleration program . In another embodiment the .inf file does not comprise an instruction to reboot or restart the computer. In one embodiment the acceleration program can be implemented as a side by side component instead of replacing shared in use dynamic link libraries DLLs . In other specific embodiments for a network driver of the acceleration program the acceleration program uses the INetCfgPnpReconfigCallback network driver API so that a user will not be required to reboot the operating system to cause configuration changes to take effect in the driver. Additionally the acceleration program may have a notify object that calls the SendPnpReconfig API within its implementation of the ApplyPnpChanges method of the INetCfgComponentControl to send configuration information to the driver of the network component that owns the object. The SendPnpReconfig API provides the notify object with a mechanism to send data to the driver and in some embodiments is used to avoid requiring a user to reboot the operating system before configuration changes take effect.

At step upon completion of installation of the acceleration program automatically silently transparently or otherwise the acceleration program is automatically executed on the client . In some embodiments the installation program that installs the acceleration program starts or executes the acceleration program . In some embodiments the installer program for the acceleration program makes a system call to load or execute the acceleration program in memory of the client . In one embodiment the installation of the acceleration program comprises an instruction command or directive to start the acceleration program . In one embodiment the acceleration program includes an automatic run configuration such as an autorun.inf file that notifies the client to automatically run the acceleration program . In other embodiments a plug and play manager or the operating system of the client automatically executes the acceleration program upon installation. In one embodiment the acceleration program comprises a service process thread or task that is started by the client . In some embodiments the acceleration program is a service of the operating system that is configured to automatically start. In one embodiment the acceleration program comprises a network driver loaded in the memory of the network stack of the operating system of the client

In another embodiment the acceleration program comprises a network driver that is loaded into memory of the client . In some embodiments the acceleration program is loaded into memory allocated to the network stack . In some cases the acceleration program is loaded and executed in a memory area or space that allows the acceleration program to access a protocol layer of the network stack such as the transport layer. In other cases the acceleration program is loaded and executed in a memory that allows the acceleration program to access a kernel level data structure . In other embodiments the acceleration program is loaded into memory of an application . In another embodiment the acceleration program executes independently in its own memory space or context. In one embodiment the acceleration program runs in the memory space or context of an application . In some embodiments the acceleration program is loaded into user mode memory or memory allocated to the user mode while in other embodiments the acceleration program is loaded into kernel mode memory or memory allocated to the kernel mode

In some embodiments the acceleration program is loaded into memory and or executed on the client transparently to a user of the client an application of the client the appliance or the server . In other embodiments the acceleration program executes to interface with the transport layer of the network stack and executes transparently to any protocol layer above the transport layer such as a session or application layer and any protocol layer below the transport layer such as the network layer. In one embodiment the acceleration program executes transparently to any transport layer connection of the client or the transport layer itself.

At step the loaded started or otherwise executing acceleration program performs any of the plurality of acceleration techniques of the acceleration program such as any techniques provided by 1 multi protocol compression 2 transport control protocol pooling 3 transport control protocol multiplexing 4 transport control protocol buffering and 5 caching via a cache manager . The acceleration program may also perform any encryption and or decryption of communications between the client and the server . In one embodiment the acceleration program performs multi protocol compression. In another embodiment the acceleration program performs transport control protocol pooling and in a further embodiment the acceleration program performs multiplexing via the pooled transport layer connection. In one embodiment the acceleration program performs transport control protocol buffering. In some embodiments the acceleration program performs caching. In other embodiments the acceleration program performs caching and compression. In one embodiment the acceleration program performs caching with transport layer pooling and multiplexing. In another embodiment the acceleration program performs multi protocol compression with transport layer pooling and multiplexing. In another embodiment the acceleration program performs caching and or compression with TCP buffering and in a further embodiment with TCP pooling and multiplexing.

As such the client side acceleration program of the present invention is dynamically provided by the appliance and automatically installed and executed on the client in a silent manner or transparent to the user or application of the client to perform one or more client side acceleration techniques to communications between the client and a server . The acceleration program may perform these acceleration techniques transparently to any protocol layer of the network stack and transparently to a user of the client application of the client appliance or server.

In another aspect the present invention is related to the appliance determining if an application requested to be accessed by the client can be accelerated and providing the acceleration program to the client if the application can be accelerated. Referring now to another embodiment of a method of the present invention is depicted. The present invention may be practiced upon requests to establish a connection or communication session as well as requests to access an application on a server. In brief overview of method at step the appliance intercepts a request from a client requesting access to an application on a server . At step the appliance determines if the application is capable of being accelerated. At step if the application cannot be accelerated then the application forwards the request to the server at step . At step if the application can be accelerated then the appliance determines if the acceleration program is installed on the client or has been previously transmitted to the client . If the acceleration program has not yet been provided to the client then the method continues at step of the method described above to transmit install and execute the acceleration program. If the acceleration program has been installed and is executing on the client then the appliance at step sends a message to the acceleration program on the client to accelerate the application . At step of method the acceleration program performs a plurality of acceleration techniques on the communications for the application and may encrypt and or decrypt such communications.

In further detail at step the appliance may intercept by any suitable means and mechanisms a request from the client to access an application provided by the server . In one embodiment the packet engine of the appliance intercepts communications from the client . In other embodiments the appliance establishes a first transport layer connection with the client for example with the acceleration program and a second transport layer connection with the server on behalf of the client . As such the appliance may receive intercept or otherwise obtain any of the client s communications transmitted to the server . In some embodiments the appliance intercepts a request for the client to access an application via an established transport layer connection with the server . In other embodiments the appliance intercepts a request to establish a communication session via any protocol layer above the transport layer connection such as an application layer protocol of HTTP. In one embodiment the appliance intercepts a request from the client to display and provide an application from the server via a remote display protocol such as ICA or RDP.

At step the appliance determines whether the application requested by the client can be accelerated. In some embodiments the appliance identifies extracts or otherwise processes an application identifier from the intercepted client request that identifies the application by name type or category. In one embodiment the application acceleration determination mechanism is used by the appliance to determine if or whether the application can be accelerated. In some embodiments the application acceleration determination mechanism performs a query or lookup in a database lookup table or other structured source of data in memory or storage such as a data structure or object to determine if the application can be accelerated. In another embodiment the appliance sends a communication such as request to a server to determine whether the application can be accelerated.

In other embodiments the appliance has a performance log or history to determine if the application has been accelerated before and whether the acceleration had improvement on the performance and operation of the application . As such the appliance may determine that an application can be accelerated if such acceleration meets a predetermined threshold of improvement to performance or operations of the application . In yet another embodiment the appliance provides heuristic rules based on the current operation and performance of the network client or server . In one embodiment the application may be determined to be capable of being accelerated if the client has certain performance and operational characteristics or capabilities for example a certain speed processor or a minimum amount of memory. In some embodiments the application may be determined to be capable of being accelerated based on a configured policy or rule such as in the policy manager of the appliance . For example an application to be communicated between a remote user with a certain type of client accessing a certain type of application and or server may be accelerated. In other embodiments the application may be determined to be capable of acceleration based on an authentication and authorization of the user or the client . In yet another embodiment the application may be determined to not be desired to be accelerated. For example the application is of a type that is infrequently used.

At step if the application is determined not to be capable of being accelerated or otherwise it is desired not to apply acceleration techniques to the application on the client the appliance forwards the intercepted client request to the server at step and does not transmit or provide the acceleration program to the client . In one embodiment the appliance may perform or provide appliance based acceleration of the appliance . In other embodiments the appliance does not perform acceleration of the application on the appliance . In yet another embodiment the appliance may perform some acceleration techniques and not others for the application if the appliance determines the application is not capable of or otherwise desired to be accelerated.

At step if the application is determined to be capable of being accelerated or otherwise it is desired to apply acceleration techniques to the application on the client the appliance determines if the acceleration program has been provided to the client . In one embodiment the appliance determines if the acceleration program has been installed on the client or is executing on the client . In some embodiments the appliance sends a communication to the acceleration program on a client to determine if the acceleration program is running on the client . In other embodiments the appliance checks a log file or history file to determine if the acceleration program has been transmitted to the client . In another embodiment the appliance checks with a health monitoring program of the appliance or the client to determine if the acceleration program is executing on the client .

If the appliance determines the acceleration program has not been transmitted installed and or executed on the client the appliance will provide the acceleration program in accordance with the steps of method described in conjunction with . For example the appliance transmits the acceleration program to the client which the client upon receipt automatically installs and executes. In one embodiment upon performance of the suitable steps of the embodiment of method the appliance may communicate at step a message to the acceleration program to apply one or more of the accelerations techniques to the application . In other embodiments if the acceleration program is already installed and executing then at step the appliance communicates a message to the acceleration program to apply one or more of the accelerations techniques to the application .

In some embodiments the acceleration program performs any of the acceleration techniques available by the acceleration program to the identified application . In other embodiments the appliance indicates to the acceleration program which of the acceleration techniques to perform for the application . In one embodiment the acceleration program may apply the desired acceleration techniques for the application on a per session basis. That is the message from the appliance to the acceleration program only informs the acceleration program to perform acceleration techniques for this instance or session of the application . In other embodiments once the acceleration program receives a message from the appliance to apply acceleration techniques for the identified application the acceleration program applies the acceleration techniques for any instances or sessions of the application or until the client is rebooted or restarted or the appliance is rebooted or restarted.

In one embodiment the message from the appliance at step is not application specific. For example the message informs the acceleration program to execute one or more of the acceleration techniques for any application of the client . In some embodiments the message sent to the client informs the acceleration program to stop using any one or more of the acceleration techniques for the application or for all applications . In another embodiment the appliance communicates a message to the acceleration program to ignore certain applications . In yet another embodiment the appliance communicates a message to the acceleration program to provide configuration data or information to the acceleration program such as an update to an acceleration technique or application of a new acceleration technique.

At step the acceleration program performs any of the plurality of acceleration techniques of the acceleration program for the application such as any techniques provided by 1 multi protocol compression 2 transport control protocol pooling 3 transport control protocol multiplexing 4 transport control protocol buffering and 5 caching via a cache manager . The acceleration program may also perform any encryption and or decryption of communications of the application between the client and the server . In one embodiment the acceleration program performs multi protocol compression of application related data. In another embodiment the acceleration program performs transport control protocol pooling and in a further embodiment the acceleration program performs multiplexing via the pooled transport layer connection. In one embodiment the acceleration program performs transport control protocol buffering. In some embodiments the acceleration program performs caching. In other embodiments the acceleration program performs caching and compression. In one embodiment the acceleration program performs caching with transport layer pooling and in a further embodiment also with multiplexing. In another embodiment the acceleration program performs multi protocol compression with TCP buffering and in a further embodiment with transport layer pooling and in yet a further embodiment also with multiplexing. In another embodiment the acceleration program performs caching with compression and in a further embodiment with TCP pooling and in yet a further embodiment with multiplexing.

As such the appliance of the present invention dynamically determines whether to the accelerate an application or whether the application can be accelerated and communicates to the client side acceleration program of the present invention to perform on the client any one or more of the acceleration techniques for the application . Furthermore in some embodiments a plurality of acceleration programs may be dynamically delivered to the client by the appliance and automatically installed and executed by the client . For example an acceleration program may be provided in accordance with the techniques and methods of the present invention for each connection to a server or each communication session with an application . As such the client may automatically install and execute a plurality of acceleration programs to handle and perform acceleration for each server or each application 

In one aspect the present invention is related to performing a plurality of the acceleration techniques by the acceleration program in an efficient integrated manner. The acceleration program intercepts network packets at the transport layer of a transport control protocol connection and uses a kernel level data structure to obtain information and data such as payload data of a network packet to apply the plurality of acceleration techniques at a single interface point or place of execution in the acceleration program . Referring now to an embodiment of a method for performing a plurality of acceleration techniques in an integrated manner is depicted. In brief overview at step the acceleration program intercepts at the transport layer a network packet of a communication between the client and server via a transport layer connection. At step the acceleration program accesses at the transport layer the network packet via a kernel level data structure for example a data structure provided via an API to the network stack of the client . At step the acceleration program performs a plurality of the acceleration techniques in an integrated manner using the kernel level data structure at an interface point or point of execution in the acceleration program .

In further detail at step the acceleration program intercepts by any suitable means and mechanism a network packet of a communication between the client and the server via a transport layer connection. In one embodiment the acceleration program intercepts a network packet of or related to a request by the client or a response thereto to establish a transport layer connection between the client and the server . In another embodiment the acceleration program intercepts a network packet of or related to a request or a response thereto to access or use an application via the transport layer connection between the client and the server . In one embodiment the acceleration program intercepts the network packet at the transport protocol layer via a transport driver interface or otherwise a network driver interfaced at a transport protocol layer of the network stack . In another embodiment the acceleration program intercepts the network packet at the transport protocol layer or any other protocol layer of the network stack via a Network Driver Interface Specification NDIS driver or a mini port driver or a mini filter driver. In some embodiments the acceleration program intercepts the network packet at the transport layer via a hooking or filtering mechanism.

At step the acceleration program accesses or otherwise obtains information and data of the network packet intercepted at the transport layer via a kernel level data structure . By using the kernel level data structure the acceleration program can obtain information and data on the payload s or the one or more protocols carried or transported by the network packet at the transport layer. In some embodiments using a kernel level data structure to represent the network packet at the layers of the network stack at and or above the transport layer enables the acceleration program to perform or operate the plurality of acceleration techniques at the transport layer and for protocol layers carried by the transport layer network packet. In one embodiment using a single kernel level data structure prevents or avoids copying and memory allocation along with context switching from using multiple data structures at various protocol layers of the network stack . In one embodiment the acceleration program copies the kernel level data structure to a second data structure which may comprise another kernel level data structure or a user level data structure.

At step the acceleration program performs executes or operates the plurality of acceleration techniques at single interface point or location in the program or in a set of executable instructions or one point of execution of the program . The acceleration program performs any of the plurality of acceleration techniques of the acceleration program such as any techniques provided by 1 multi protocol compression 2 transport control protocol pooling 3 transport control protocol multiplexing 4 transport control protocol buffering and 5 caching via a cache manager . The acceleration program may also perform any encryption and or decryption of communications of the application between the client and the server at the same point in execution of the acceleration techniques of the acceleration program .

In one embodiment the acceleration program performs in a set of executable instructions such as function call or one place or location any desired plurality of the acceleration techniques subsequent to each other. For example the acceleration program obtains the intercepted network packet via a kernel level data structure and then executes instructions representing the logic function rules or operation of the acceleration techniques subsequent to each other. As such information and data of the network packet can be extracted or obtained once via the kernel level data structure and used as input parameters arguments and conditions for any of instructions of the acceleration program representing the acceleration techniques. Although the network packet carries higher level protocol data and information the acceleration program in some embodiments processes the network packet and the higher level protocol data and information at one point and at one time during execution. Additionally the acceleration program may perform each of a plurality of acceleration techniques in any desired order in an integrated manner such as compression data stored to the cache manager or compressing uncompressing data retrieved from the cache.

In one embodiment the acceleration program performs multi protocol compression and caching subsequently to each other. In another embodiment the acceleration program performs subsequent to each other operations related transport control protocol pooling and multiplexing via the pooled transport layer connection. In one embodiment the acceleration program performs transport control protocol buffering subsequently to compression and caching or to TCP pooling and or multiplexing. In some embodiments the acceleration program performs caching. In one embodiment the acceleration program performs caching subsequently with transport layer pooling and multiplexing. In another embodiment the acceleration program performs multi protocol compression subsequently with transport layer pooling and multiplexing. In another embodiment the acceleration program performs caching and or compression subsequently with TCP buffering and in a further embodiment subsequently with TCP pooling and multiplexing.

Although the acceleration program is generally described as subsequently performing the acceleration techniques subsequent execution may also include other logic functions and operations not related to acceleration but integrated and executed in between each acceleration technique. The acceleration program still obtains operational and performance efficiency with such integration as the executable instructions for the acceleration techniques and any other operations or function are executed at a single interface point or point of execution in the acceleration program. Furthermore the acceleration techniques for protocol layers carried or above the transport protocol layer are processed at one time and or at one location at the transport layer. As such acceleration techniques for these higher level protocols do not need to be applied again as the network packet traverses and gets processed in these higher levels of the network stack or at a later point in the network stack .

In other aspects the present invention can be practiced using a first program and the acceleration program or also referred to as the second program in this embodiment . In one embodiment the first program along with the second program can be used to facilitate and establish a virtual private network connection with a server such as via appliance over which the client side acceleration techniques of the present invention may be applied. In another embodiment the first program is used to install and execute the second program or the acceleration program . Referring now to an embodiment of a method for practicing this aspect of the present invention is depicted. In brief overview at step the client logs in and establishes a communication session with the appliance . At step the appliance sends the first program to the client . At step the client installs and executes the first program which in turns installs and executes the acceleration program i.e. the second program. At step the client communicates with and accesses resources on a private network via an established encrypted data communication session. At step the client logs out from the appliance and terminates the communication session with the appliance .

At step of method the client performs a log in procedure and establishes an encrypted data communication session with appliance via network . In one embodiment the encrypted data communication session is used as a tunnel to bridge traffic from client to any of servers which reside behind appliance in private data communication network . In an embodiment client uses a web browser such as Microsoft Internet Explorer or Netscape Navigator to log in and establish a data communication session with appliance using Secure Sockets Layer SSL or other encryption methods such as IPSec and Transport Layer Security TLS . In another embodiment a protocol such as Hypertext Transfer Protocol over Secure Sockets Layer HTTPS may be used to initiate the encrypted data communication session.

At step in response to log in and establishment of the encrypted data communication session appliance sends a first program to client over network . The first program is designed and constructed or otherwise configured to act as a tunnel endpoint for communication over the encrypted data communication session. In one embodiment the first program comprises a plug in application that is automatically installed and executed by the browser of the client . For example the first program may comprise an ActiveX control that is provided as a plug in to be executed by a Microsoft Internet Explorer Web browser. In another embodiment the first program may comprise a Java applet that is provided as a plug in to be executed by a Netscape Navigator Web browser or another control or programming component that works across network environments.

At step client installs and executes the first program wherein executing the first program comprises installing a second program on client . In one embodiment the first program may be automatically installed and executed such as using any of the techniques discussed in conjunction with method and . In some embodiments the first program obtains downloads or receives the second program or the acceleration program from the appliance . In another embodiment the first program comprises a installer or install manager for the second program such as the acceleration program to automatically install and execute the second program such as by way of a silent installation or an installation transparent to a user of the client application of the client the appliance or the server .

In one embodiment the second program is configured in part to intercept communications from applications running on client that are destined for resources on network and to provide the intercepted communications to the first program for sending to appliance via the encrypted data communication session. The second program may also be configured to provide intranet network name resolution service and optionally split network traffic. By splitting the traffic an embodiment of the present invention is able to determine what traffic is channeled to an SSL tunnel or encryption tunnel of the first program and what traffic is permitted or allows to continue along for processing by the transport layer of the network stack under normal routine or typical operations of the client . In an embodiment the second program comprises a dynamic interceptor for instance a filter device driver that is inserted as a hook into an operating system of client . For example the second program may comprise a filter device driver that is attached to the transport layer stack of the client operating system such as the transport layer stack of a Microsoft Windows operating system.

At step once the first and second programs have been installed applications running on client may communicate with and access resources such as applications and data on private data communication network via the established encrypted data communication session. The manner in which this communication occurs will be discussed in more detail below with respect to . Note that in an one embodiment the functions of the first program and second program as described above are performed by a single control or programming component that is automatically installed and executed by client such as the acceleration program of the present invention. In addition to providing a virtual private network connection and communications the first program and or second program such as the acceleration program may perform any of the acceleration techniques described herein on communications of the client via the virtual private network connection e.g. the encrypted tunnel or bridge to appliance .

At step client performs a log out procedure to disconnect from network which terminates the encrypted data communication session with appliance . In one embodiment at time of logging out the first program automatically cleans up the modifications made to the operating system of the client to return the operating system to a state prior to the installation of the first program and or second program. In one embodiment the first program and or second program also includes an uninstaller or uninstall instructions to remove the first and second programs from the operating system of the client or from further operation on the client in a non intrusive manner to the continued operations of the client . In yet another embodiment the first program and or the acceleration program removes any files such an temporary files or cookies used by applications of the client during any communication connections or sessions provided using the present invention.

At step an application of a client makes a new connection or resolves a domain name via the transport protocol layer of the network stack of the client . In one embodiment the application may request to establish a transport layer connection between the client and a server or between the client and the appliance . In another embodiment the application or the client may request access to an application provided by the server . For example the server may provide for server based computing or thin client computing by transmitting a remote display protocol of ICA or RDP representing output of an application executing on the server . In another embodiment the client may request access to resources of a server such as files or directories or email services. In some embodiments the client may be on a public network and the server on a private network . In other embodiments the client and server may be on different private networks.

At step the second program executes one or more functions automatically or otherwise before any transport layer functions are initiated. In some embodiments the second program is or otherwise comprises the acceleration program of the present invention. In one embodiment the second program intercepts or otherwise receives the client request of step . In some embodiments the application of the client makes API calls to the network stack which are intercepted by the second program. Prior to any API calls being processed by the transport layer of the network stack the second program is hooked into or otherwise interfaced to the network stack to execute logic rules functions or operations prior to the communication being transmitted or processed for transmission via a transport layer connection.

At step the second program intercepts communications from the client such as by any application on client that are destined for resources on network and re routes them to the first program which in an embodiment comprises an ActiveX control plug in a Java applet or other control or programming component that works across network environments. The second program may access read or otherwise obtain destination information from the network packet or packets providing the intercepted communications to determine the communication is destined for network such as a private network behind appliance . For example the second program may extract or interpret the destination IP address and or port from the network packet. Upon determination an intercepted communication is destined for network the second program communicates the intercepted communication to the first program via any suitable interface means and mechanism such as via any inter process communication interface or an API call. In one embodiment the intercepted communication is sent to the first program as is or in other embodiments the intercepted communication is pre processed by the second program prior to sending to the first program . For example the second program may remove the payload from the intercepted communication and forward the payload to the first program .

At step each intercepted communication is terminated or proxied by the first program and the first program prepares the intercepted communication for transmission via the established encrypted data communication session. In one embodiment the first program separates out the payload and encapsulates the payload for delivery via the established encrypted data communication session. In another embodiment the first program encapsulates the intercepted communicated as received from the second program. In some embodiment the payload is a TCP payload and is encapsulated into a new TCP connection between the client and the server such as via appliance .

At step the first program sends the intercepted communications over network to appliance in network via the pre established encrypted data communication session. In some embodiments the first program encrypts the intercepted communications and sends the encrypted intercepted communications to appliance . In one embodiment encryption is carried out in accordance with SSL protocols. In another embodiment encryption is TLS based. Any type and form of encryption and or decryption may be used by either first program or the acceleration program .

At step appliance acts as a proxy terminating the connection sent by the first program . The appliance decrypts the communications received from the first program and forwards the decrypted communications onto the appropriate destination resource on network via a second connection that the appliance has established with the destination resource on network . In one embodiment decryption is carried out in accordance with SSL protocols or other applicable encryption and decryption protocols. In some embodiments the appliance performs one or more acceleration techniques on the communication forwarded to the destination resource such as one or more of the following techniques provided by 1 multi protocol compression 2 transport control protocol pooling 3 transport control protocol multiplexing 4 transport control protocol buffering and 5 caching via a cache manager .

At step the destination resource processes the decrypted communications. In one embodiment the decrypted communications is a request to establish a connection or communication session. In another embodiment the decrypted communications is a request to start or access an application on behalf of the client . In other embodiments the decrypted communications is a request for a web page such as a HTTP request to receive a web page from a web server .

At step if the decrypted communications include a request for which there is a response then the destination resource sends out responsive communications to appliance . In some embodiments the response includes an acknowledgement of establishing a connection or communication session as requested by the client . In other embodiments the response includes an error message. In one embodiment the response includes an authentication request or a challenge response mechanism. In some embodiments the response includes an acceleration program to be used by the client . In another embodiment the response includes HTML such as a web page to be displayed by the client . In other embodiments the response includes an object such as a dynamically generated object.

At step appliance sends the responsive communications over network to the first program on client via the pre established encrypted data communication session. In one embodiment the appliance encrypts the responsive communications and sends the encrypted responsive communications to the first program . In some embodiments encryption is carried out in accordance with SSL protocols or other applicable encryption and decryption protocols. Furthermore the appliance may perform any of the acceleration techniques of the present invention on communications to the client such as multi protocol compression caching or TCP buffering .

At step the first program decrypts the responsive communications and forwards the communication to the appropriate application via the second program. The first program may use any suitable interface means and mechanism to communicate to the second program such as via any type and form of inter process communication mechanism or an API call. The second program provides the responsive communication via the network stack of the client to the application . As such the application transparently receives the responsive communication without any changes or modification to the application .

In accordance with another embodiment of the present invention client performs additional processing of the intercepted communications before sending the communications over the network at step . Because an embodiment of the present invention provides a VPN solution that acts as a proxy terminating connections at the client before encrypting such data the additional processing can be performed more effectively. Such processing can include Domain Name Service DNS name resolution of the intercepted communications in order to enable client applications to use whatever IP addresses they choose as well as dynamically change those addresses at run time. Such additional processing permits embodiments of the present invention to be effectively integrated with other technologies such as global service load balancing to achieve greater availability and greater efficiency among distributed gateways or servers. The additional connection processing can also enable the keeping of detailed logs and statistics regarding the intercepted communications.

In another embodiment of the present invention appliance terminates communications received from the first program on client and further processes one or more requests included therein rather than forwarding the communications to a destination on network as shown at step . This further processing can include back end encryption wherein communications are re encrypted by appliance before delivery to the appropriate destination on network thereby providing end to end network security. The destination will thereafter decrypt the traffic and respond appropriately. Further such processing can permit appliance to serve responses out of a cache rather than requiring additional work by a destination server perform local network load balancing global service load balancing and or compression on the communications to enhance the efficiency and responsiveness of network .

In accordance with the above described methods a VPN based on an encrypted data communication session is established between client and network . For example in an embodiment a secure VPN is established via HTTPS. Thereafter all communications from client to network are routed via the first program to appliance and vice versa through this encrypted data communication session. It should be noted that although the encrypted data communication session may be established using HTTPS the communications that are passed through the encrypted data communication session need not be HTTPS packet data or even HTTP packet data. For example the communications may also comprise Transmission Control Protocol User Datagram Protocol TCP UDP or Internet Control Message Protocol ICMP packet data although these examples are not intended to be limiting. Furthermore although the method described in reference to describes a request response type communication between an application on client and a resource on network encrypted communications in accordance with the present invention need not be request response based. Rather the communications can be of any type. Thus any client application that can establish a connection or communication session such as a UDP session can send and receive encrypted communications in accordance with an embodiment of the present invention.

In another aspect the present invention is related to the acceleration program dynamically bypassing from the client any intermediary device to connect or communicate with a server . For example a client may connection with a server via one or more intermediaries such as the appliance of the present invention. For one reason or another an intermediary may no longer be available for use by the client to communicate with the server for example the appliance may be down for maintenance or may be in the process of rebooting or restarting. The acceleration program of the present invention determines the intermediary is not available and automatically establishes a different connection or communication session path with the server . This may occur transparently to the user or application of the client such that the connection and or communication session does not appear to have changed or otherwise has been disrupted.

Referring now to an embodiment of a method of the present invention for automatically bypassing an intermediary is depicted. In brief overview at step the acceleration program establishes a transport layer connection between the client and server via an intermediary such as appliance . At step the acceleration program determines the intermediary is not useable for communicating by the client to the server via the established transport layer connection. At step the acceleration program intercepts on the client a communication from the client to the serve . At step the acceleration program establishes a second transport layer connection between the client and the server and as a result bypasses the intermediary determines as not useable for the client s communications to the server . At step the acceleration program transmits the intercepted communication of the client to the server via the second transport layer connection.

In further detail at step the acceleration program establishes a transport layer connection between the client and the server via an intermediary. In one embodiment the intermediary comprises an appliance . In other embodiments the intermediary comprises one of the following a cache a server a gateway a firewall a bridge a router a switch a hub a proxy or any software application or program acting as or providing the functionality and operations of any of these types and forms of intermediaries. In one embodiment the intermediary may operate on the server . In some embodiments the transport layer connection is established via a plurality of intermediaries of the same type and form or of a different types and forms. In another embodiment the transport layer connection comprises of the connection of a pool of transport layer connection either established as the client or at the appliance in accordance with the operations of the present invention described herein.

At step the acceleration program determines the intermediary is not available or otherwise is not useable for communicating by the client to the server via the established transport layer connection. The acceleration program may determine the status or availability of the intermediary by any suitable means and or mechanism. In one embodiment the acceleration program determines the intermediary is not available by receiving an error message or failure reply associated with a transmission to the intermediary. For example the acceleration program may receive a failed transport layer communication response when transmitting a communication from the client via the established transport layer connection. In another embodiment the acceleration program may transmit a ping command to the intermediary on a predetermined frequency to monitor the status and availability of the intermediary. If the acceleration program does not receive a reply from the intermediary or in some embodiments receives a delayed reply or a reply with a longer than desired latency the acceleration program may determine the intermediary is not available or useable by the client . In other embodiments a server appliance or the intermediary may send a message to the client or acceleration program providing information identifying the intermediary is not available or otherwise is not useable by the client . In some embodiments the established transport layer connection is disrupted or interrupted or in other embodiments is closed.

At step the acceleration program intercepts a communication from the client to the server destined to travel via the intermediary through the established transport layer connection. The acceleration program may intercept the communication at any point and at any protocol layer in the network stack . In one embodiment the acceleration program intercepts the communication at the transport protocol layer prior to transmission on the established transport layer connection. For example in some embodiments the acceleration program comprises a network driver having a transport driver interface or otherwise interfaced to the transport protocol layer. In other embodiments the present invention is practiced with a first program and the acceleration program as a second program as discussed in conjunction with in which either the first program or the acceleration program intercepts the communication.

At step the acceleration program establishes a second transport layer connection to the server for the client in order to bypass the intermediary determined to be unavailable or not useable by the client at step . In one embodiment the acceleration program establishes a second transport layer connection directly to the server for example when the client and server are on the same network or on different networks routable between the client and the server . In another embodiment the acceleration program establishes the second transport layer connection with a second intermediary such as a second appliance . In some embodiments the acceleration program requests the appliance to establish another transport layer connection with the server . In one embodiment the appliance uses a second transport layer connection of a pool of transport layer connections to the server . In another embodiment the acceleration program request the server to establish the second transport layer connection. In some embodiments the acceleration program uses a second transport layer connection from a pool of transport layer connections established by the acceleration program with the server in accordance with the operations of the present invention described herein.

In one embodiment the acceleration program establishes the second transport layer connection at step transparently to a user or application of the client or in some embodiments transparently to any protocol layer above or below the transport layer. In some aspects the second transport layer connection is established automatically for the client upon determination at step that the intermediary is not available or should not be used by the client . In other embodiments the second transport layer connection is established automatically upon failure of transmission of the intercepted communication to the server e.g. the first attempt to transmit the communication. In some embodiments the second transport layer connection is established automatically upon failure of one or more retried transmissions of the communication or upon exhausting a predetermined number of retries. In another embodiment the second transport layer connection is established upon determination the intermediary is delaying the rate of transmit or receipt of network packets causing latency or otherwise affecting the use of the transport layer connection in an undesired manner. In one embodiment the acceleration program performs load balancing and establishes a second transport layer connection bypassing the intermediary to offload any processing or operations of the intermediary to the client and or second intermediary.

At step the acceleration program transmits the intercepted communication of the client to the server via the second transport layer connection. In one embodiment the acceleration program transmits the intercepted communication directly to the server . In other embodiments the acceleration program transmits the intercepted communication via a second intermediary such as a second appliance . By using the second transport layer connection the acceleration program bypasses the intermediary and continues the operations of an application of the client with the server . In one embodiment an application of the client continues with operations and communications with the server as if the application was continuing to use the previously or first established transport layer connection. As such the acceleration program prevents avoids or circumvents any communication interruption disruption latencies delays or other operational or performance issues that may occur if the intermediary was not bypassed by the acceleration program . In another aspect this technique of the present invention automatically provides the client continuous access to a server or remotely accessed application even if there is an issue with or disruption in access from an intermediate device.

Moreover the redirection and bypassing techniques of the present invention described above can be used to perform load balancing and traffic management on the client to access one or more servers providing applications or other content and functionality to the client . For example in one embodiment an intermediary or appliance used by the client to access a server may be overloading with increasing transport layer connections and decreasing rate of responses performance or other operations. Upon determination of decreasing performance of the intermediary or appliance the acceleration program can redirect the client to another intermediary or appliance or server to bypass any performance bottlenecks in the client s end to end connectivity to the server.

In other aspects the present invention is related to client side acceleration techniques related to or performed at the transport protocol layer of the network stack of the client. The acceleration program may comprises executable instructions to perform any one or more of 1 transport control protocol TCP buffering 2 TCP connection pooling and 3 TCP multiplexing . In some embodiments as the acceleration program transparently processes communications intercepted at the transport protocol layer of the client s network stack the acceleration program can control and manage the TCP connections of the client and the use and transmission over the connections by applications of the client . depicts an embodiment of method of practicing the TCP buffering techniques of the present invention while depicts an embodiment of the TCP connection pooling technique of the present invention and and the TCP multiplexing technique.

In brief overview of an embodiment of method depicted in at step the acceleration program intercepts a communication from the client to the server such as a request to access the server by the client . At step the acceleration program determines whether a difference between a rate of consumption of received server responses and a rate of production of requests transmitted by the client falls below a predetermined threshold. If at step the difference in product and consumption rates does not fall below the predetermined threshold the acceleration program forwards the communication to the server at step . If at step the difference in rates is below the predetermined threshold then at step the acceleration program stores the communication in memory of the client . At step the acceleration program determines if the difference in rates has changed to above the predetermined threshold and if so forwards the stored communication to the server . Otherwise the acceleration program maintains the communication in memory of the client until a point in time the difference in rates change at step to above the predetermined threshold. For example if the client is transmitting requests to the server at a greater rate than by which the client can consume the generated responses the acceleration program of the present invention holds further transmission until a future point in time at which the difference in the rates haves changed.

In further detail at step the acceleration program intercepts a communication from the client to the server . The acceleration program may intercept the communication at any point and at any protocol layer in the network stack . In one embodiment the acceleration program intercepts the communication at the transport protocol layer prior to transmission on the established transport layer connection. For example in some embodiments the acceleration program comprises a network driver having a transport driver interface or otherwise interfaced to the transport protocol layer. In other embodiments the present invention is practiced with a first program and the acceleration program as a second program as discussed in conjunction with in which either the first program or the acceleration program intercepts the communication. In one embodiment the communication comprises a request by the client to use or otherwise access a resource of the server such as an application .

At step the acceleration program determines whether a difference between a rate of consumption and a rate of production of the client falls below a predetermined threshold. In one embodiment the acceleration program counts and tracks the number of requests transmitted by the client to the server and in another embodiment the acceleration program counts and tracks number of responses received by the client from the server . In some embodiments the client tracks responses transmitted and requests received on a per application basis. The responses and requests may be tracked at any protocol layer of the network stack . In one embodiment the number of requests transmitted by the client or application is counted and tracked from the point of submission to the transport layer or to a transport layer connection between the client and server . Likewise in another embodiment the number of responses received by the client or application from the server is counted and tracked from the point of receipt at to the transport layer or from the transport layer connection between the client and server and or at the point the response is provided to a protocol layer such as an application layer above the transport layer of the network stack .

In some embodiments the acceleration program accesses inspects or otherwise obtains information and data about the send and receive TCP buffers of the transport layer connection established by the acceleration program between the client and server . For example the acceleration program may determine the default and maximum size of any TCP IP buffer and the currently used portions of the buffer to determine a difference in rates between sending and receiving of network packets from the client to the server . In other embodiments the acceleration program uses any type and form of congestion algorithm to determine if there is congestion causes by a difference in consumption and product of network packets from the client to the server . In another embodiment the acceleration program interfaces with or obtains information or data from a congestion algorithm uses by the transport layer connection such as by a network driver or TCP service provider. For example in one embodiment the acceleration program determines information and data regarding the congestion window used by the connection.

The predetermined threshold can be configured specified defined or identified by any suitable means and mechanism of the acceleration program . In one embodiment the threshold may be specified as a percentage relative absolute or otherwise between the production rate and consumption rate of the client and or application . The rates for consumption and or product may be identified by a number of consumed receipts and produced transmissions respectively over any time period at any granularity. In some embodiments the threshold may be specified as a quantity difference between the rate of production and consumption of the client and or application and in some embodiments a quantity difference over a time period. For example the threshold may be specified as the point in time the client has produced 100 requests more than the client has consumed. In another example the threshold may be specified as the point in time when the client is producing 10 requests per time period to the server more than the requests consumed by the client during the same time period.

At step if the difference in product and consumption rate of the client and or application is not below the predetermined threshold the acceleration program forwards the communication to the server at step . In some embodiments the acceleration program performs any of the acceleration techniques of the present invention for the communication. For example the communication may be forwarded to the server via a pooled multiplexed transport layer connection and additionally may be compressed. In other embodiments the client may forward the communication to an appliance providing a connection for the client to the server .

At step if the difference in product and consumption rate of the client and or application is below the predetermined threshold the acceleration program at step stores the communication in memory of the client . In some embodiments the memory may be memory of the kernel mode of the client while in other embodiments the memory may be in user mode of the client . In one embodiment the acceleration program may store the communication in cache via the cache manager . In other embodiments the acceleration program may use an object data structure or other data element accessible by the acceleration program to buffer hold or otherwise store the intercepted communication. In one embodiment the intercepted communication may be stored in a compressed manner in memory. In another embodiment the acceleration program sends the intercepted communication to a first program to store or hold in memory for transmission at a later point in time.

At step the acceleration program determines when to transmit the stored communication to the server . In one embodiment the acceleration program performs steps and to determine if the difference in production and consumption rates of the client are above the threshold upon which the acceleration program forwards the stored communication to the server at step . In some embodiments the acceleration program compares the difference in production and consumption rates on a regular or predetermined frequency or on a polling or event basis and when the difference rises above the predetermined threshold the acceleration program forwards the communication to the server . In other embodiments the acceleration program sets or configures a timer to determine how long to store the intercepted communication. Upon expiration of the timer the acceleration program transmits the stored communication to the server . In another embodiment the acceleration program checks the number of server responses consumed by the client since storing the intercepted communication. If the number of consumed responses is greater than a predetermined number the acceleration program releases the intercepted communication from the memory buffer or storage and submits the communication for transmission to the server .

If at step the acceleration program determines the rates of production or consumption have not changed in a suitable manner the acceleration program holds or maintains the intercepted communication in memory until a suitable point of time is reached. In one embodiment the acceleration program forwards the communication to the server at step even if the production and or consumption rates do not change. For example after a period of time waiting for the production and or consumption rate to change and the rates do not change the acceleration program forward the communication to the server .

Although the TCP buffering technique of the present invention is generally discussed in relation to an intercepted communication or request the embodiments of the method of the present invention may be practiced subsequently nearly simultaneously or concurrently for multiple intercepted communications of the client to the server . Additionally in another embodiment the method of the present invention may be practiced on the client regarding communications from the client to multiple servers . For example a first instance of method may be practiced between the client and a first server and a second instance of method may be practiced between the client and a second server . Furthermore in some embodiments the method may be practiced for a first application and also for a second application using the respective production and consumption rates of each application. In other embodiments the method may be practiced for a first application but not a second application

According to another aspect of the present invention the client side acceleration program reduces the processing load of servers and or appliance caused by repeatedly opening and closing connections of the client clients by opening one or more connections with each server and maintaining these connections to allow repeated data accesses by applications of the client to the server . This technique is generally referred to herein as connection pooling. In brief overview of method at step the acceleration program intercepts an application s request to access a server and at step determines the identity of the server associated with the request. At step the acceleration program determines if the acceleration program has an established transport layer connection to the server free for use by the application . If there is not a transport layer connection to the server free for use by the application the acceleration program establishes at step a transport layer connection to the server for use by the client . At step if there is a transport layer connection available for use by the application at step the acceleration program translates the application s request for transmission or communication via the available transport layer connection.

In further overview at step the acceleration program receives the response to the request from the server and at step translates the response into a response to the application . At step the acceleration program may maintain or keep the transport layer connection open for use by any of the applications of the client . By maintaining on the client open transport layer connections with the servers and by opening and closing connections with the applications as needed the acceleration program frees the servers of TCP connection loading problems associated with serving the client over the network such as the Internet. At step the acceleration program at some point closes the transport layer connection if the connection is determined no longer used by one or more application of the client to access the server .

In further detail at step the acceleration program intercepts a request by any application of the client to access a server . In some embodiments the request is intercepted at the transport protocol layer before establishing or transmitting the request via a transport layer connection. In other embodiments the request is intercepted at any protocol layer above the transport layer or a transport layer connection. In one embodiment the request of the application is a request to open or establish a transport layer connection with the server . In some embodiments in response to the request the acceleration program establishes a first transport layer connection of a pool of transport layer connections for use by applications of the client . In another embodiment the application request is a request to access the server via an established transport layer connection of the client .

At step the acceleration program determines the identity of the server from the request by any suitable means and mechanism. In some embodiments the domain name or internet protocol address of the server is identified or otherwise referenced by the contents of the request for example a text string of the request may identify the domain name of a server . In one embodiment the identity of the server is determined by the header information of a TCP packet such as the destination internet protocol address and port number. In another embodiment the server is associated with the application and the acceleration program looks up or queries the association in a database or other structured information storage.

At step the acceleration program determines if there is a transport layer connection available for use or is otherwise free to use by the application . In one embodiment the acceleration program may have not yet established a transport layer connection with the server and as such there is not a transport layer connection available for the application to use. In another embodiment the acceleration program may have a previously established transport layer connection with the server but determines that another application is currently actively using the connection. As will be discussed in further detail below the acceleration program determines if an established transport layer connection is available for use by another application or can be shared by applications based on the length of a message being received from the server for the application such as a response to a request and or if the communications between the server and application are currently idle.

At step if the acceleration program determines a transport layer connection is not available for use by the application the acceleration program establishes a transport layer connection with the server . In some embodiments the transport layer connection established at step is the first transport layer connection with the server and in other embodiments the transport layer connection is a second transport layer connection of a plurality of transport layer connections to the server . In yet another embodiment the acceleration program waits for an already established transport layer connection to become available or free to communicate the application s request to the server . For example the acceleration program may determine a first application may be shortly completing a transaction with the server via an established connection.

At step the acceleration program translates the application s request to be transmitted via the transport layer connection to the server . In some embodiments the acceleration program uses one port number for the transport layer connection communication for all applications of the client sharing the connection. In some cases the acceleration program tracks the requests and outstanding responses for the requests on an application by application basis. As such the acceleration program recognizes which application is transmitting and receiving network packets via the transport layer connection to the server at any given point in time. In one embodiment only one application at a time is sending and receiving on the transport layer connection and thus the acceleration program understands which application is using the connection. In some embodiments the acceleration program associates a process id of the application with the request. In other embodiments the acceleration program provides and associates a port number with the application and modifies the port number in the TCP network packet to be transmitted to application s assigned port number. In another embodiment the port number is provided by the application and the acceleration program changes or otherwise provides the port number accordingly in the TCP network packet.

At step the acceleration program receives a response to the application s request from the server . In one embodiment the server does not respond to the request. In another embodiment the server responds with an error or failure message. In some embodiments the server responds with multiple responses. In other embodiments the server responds with a response comprising multiple network packets or multiple TCP segments. In another embodiment the server responds with one or more network packets identifying the source port number associated with or assigned to the application . In one embodiment the server responds with one or more network packets identifying a source port number of the transport layer connection and used for multiple applications of the client .

At step the acceleration program translates or otherwise processes the response from the server in a manner responsive to the application . In one embodiment the acceleration program replaces the source port number of the received network packet or packets with the port number of the application . In another embodiment the acceleration program determines via a tracking mechanism the application currently using the transport layer connection and passes the response to the application via the network stack . In one embodiment the response is not altered and passed for processing via the protocol layers of the network stack above the transport layer of the connection. In some embodiments the acceleration program waits for multiple portions such as TCP segments of the response to be received before processing and forwarding the response to the application . In one embodiment the acceleration program passes the response to a first program which interfaces with and provides the response to the application .

At step the acceleration program maintains or keeps the transport layer connection open in a pool of one or more transport layer connections from the client to the server . In one embodiment the acceleration program or a transport layer driver of the network stack includes a keep alive mechanism that periodically probes the other end of a connection when the connection is otherwise idle for example where when there is no data to send. The keep alive mechanism may send this message in order to receive a response to confirm the connection is still active although the connection may be idle. The keep alive message and corresponding response. may include any type and form of format command directive or communication. As such in some embodiments the acceleration program transmits or causes to transmit via a transport layer driver a keep alive message to the transport layer connection. In some embodiments the acceleration program sets a frequency for the keep alive messages and in other embodiments changes the frequency of the keep alive messages based on the behavior or activity of the applications using the connection.

In some embodiments the acceleration program intercepts any RST and or FIN commands i.e. TCP IP commands to reset and or terminate the TCP connection received over the transport layer connection. In one embodiment the acceleration program ignores takes no action on or otherwise drops deletes or flushes the intercepted RST and or FIN command. In another embodiment the acceleration program intercepts and receives a RST and or FIN commands but sends a message to the other end of the connection to keep or maintain the connection open. In other embodiments the acceleration program establishes a new transport layer connection in response to a closing of an established transport layer connection due to processing of a RST and or FIN command.

In other embodiments the acceleration program inserts an instruction command or directive in an intercepted communication of the client to direct the server to keep the connection open or to otherwise not close the connection unless the client sends a command to do so. For example in one embodiment the acceleration program intercepts a communication of a GET request of the HTTP protocol such as protocol version 1.0 and inserts a keep alive header e.g. Connection Keep Alive into the communication to the server . In other embodiments a GET request or other HTTP command may include the keep alive header. In these embodiments the acceleration program may intercept the communication and check for the keep alive header and then forward the communication to the server . In some embodiments version 1.1 or greater of HTTP is used by which the keep alive mechanism is implicit such that the server keeps the connection open until the client requests to the close the connection. In other embodiments the acceleration program keeps the transport layer connection open to the server until the client is rebooted or restarted the network becomes unavailable or the client is disconnected from the network or the server is rebooted or restarted.

At step the acceleration program may close any one or more of the transport layer connections between a client and a server at any desired point in time. In some embodiments the acceleration program closes a transport layer connection upon the termination of the one or more applications on the client using the connection. In other embodiments the acceleration program closes a transport layer connection upon expiration of a time out period for any application to use the connection. For example the acceleration program may configure set or provide a timer to expire upon a predetermined time period and if the connection is or remains idle during the time period the acceleration program closes the connection. In some embodiments the server may be rebooted restarted or the connection disrupted or interrupted and the acceleration program closes the connection. In some embodiments the acceleration program transmits or causes to be transmitted a RST and or FIN command to close connection upon completion of sending requests to and receiving all the data of responses from the server . In other embodiments the transport layer connection or pool of transport layer connections are closed upon restart or reboot of the client disconnection to the network or unavailability of the network or restart or reboot of the server .

In some embodiments a first transport layer connection to the server is kept open while a second transport layer connection to the server is closed as the acceleration program determines only the first transport layer connection is needed for sharing a connection to the server by one or more applications of the client . In other embodiments the acceleration program maintains a pool of one transport layer connection to any server and establishes a second or a plurality of connections to a given server based on increased requests communications or transport layer connection usage of the applications on the client

Although an embodiment of method is generally discussed in relation to a pool of one or more transport layer connections from the client to a server the acceleration program may establish subsequently nearly simultaneously or concurrently a pool of transport layer connections between the client and each of a plurality of servers . As such a first application and a second application may be using a first pool of one or more transport layer connections to server and a third application and a fourth application using a second pool of one or more transport layer connection to server . Furthermore each of the steps of an embodiment of the method can be performed in different instances and at different frequencies. In some embodiments multiples instances of the acceleration program may be used to handle each pool of one or more transport layer connections to each server 

Once the transport layer connection is established the acceleration program intercepts a GET request from application specifying a path name of sales forecast.html as shown by step . Because no free transport layer connection is open between acceleration program and server or appliance acceleration program opens a transport layer connection. In one embodiment acceleration program maps the request of the application to a second network address of network address which specifies server as shown by step . For example the acceleration program performs network address translation to modify the destination IP address and or destination port to a server requested by the application or to another server that can also handle or respond to the request. In another embodiment the acceleration program sends the request to the server or appliance as received or as generated by the application

Acceleration program also passes the GET request to that server or appliance as shown by step . In one embodiment the appliance forwards the request to the server and in a further embodiment the appliance forwards the request via a pooled or pooled and multiplexed transport layer connections between the appliance and the server . In some embodiments the server responds with the requested web page as shown by step . Acceleration program forwards the web page to application as shown by step . In one embodiment the transport layer connection between the acceleration program and the server or appliance is closed as shown by step . In other embodiments the acceleration program intercepts the close request and ignores the request leaving the transport layer connection open. According to the TCP IP protocol closing a network connection can involve a multi stage process. Therefore the flow line of step is shown as bidirectional. In other embodiments and in accordance with the techniques of the pooling aspect of the present invention the transport layer connection established for and used by the first application is kept open or otherwise maintained to accommodate further data steps from the same application or a different application such as the second application

At step the acceleration program intercepts a request from the second application to the server or appliance . If there is a free transport layer connection open and or useable by the second application such as the transport layer connection established at step for the first application the acceleration program uses this previously established transport layer connection. As such a second transport layer connection does not need to be opened at step . Otherwise the acceleration program establishes a second transport layer connection to the server or appliance . At step the acceleration program intercepts a request from the second application for example requesting the Web page sales forecast.html and transmits the request to the server or appliance at step . Because a free connection is already open between the acceleration program and server it is unnecessary for the acceleration program to burden the server with the processing load of opening a further connection. At step the acceleration program intercepts or receives a response from the server such as via appliance from the transport layer connection and forwards the response to second application . At step the acceleration program intercepts a close request from the second application and in some embodiments closes the connection while in other embodiments ignores the request and keeps the connection to accommodate further data requests from the first application the second application or yet another application of the client .

There are a number of scenarios that result in the acceleration program closing the connection with server or application at step . For example the client or acceleration program may initiate a FIN finish command upon determination that the client has retrieved all the requested data for applications and or upon termination shutting down or exiting applications and . In some embodiments the client or acceleration program may also initiate a RST reset command under similar conditions. In addition to closing the connection between the acceleration program and the server or the appliance the RST command results in a number of housekeeping operations being performed to keep the server side connection in good order. In particular the TCP protocol guarantees that the RST command will have the right SEQ sequence number so that the server will accept the segment. However the RST command is not guaranteed to have the right ACK acknowledge number. To take care of this scenario the acceleration program keeps track of the bytes of data sent by the server or appliance and the bytes acknowledged by the client . If the client has not yet acknowledged all the data by the server the acceleration program calculates the unacknowledged bytes and sends an ACK to the server .

Furthermore although not shown in the server or appliance can also close a connection between itself and the client . The server or appliance would send a FIN command to the client . In response in some embodiments the acceleration program closes the connection and a further embodiment re establishes another connection with the server or appliance .

Moreover although an embodiment of method of and the example flow diagram of are generally discussed as pooling one or more transport layer connections for use by a plurality of applications the pooling technique of the present invention can be applied to a single application that requests or initiates a plurality of transport layer connections and requests via these connections. For example in an embodiment of HTTP protocol a transport layer connection may be established for each HTTP request from an application. Using the techniques of the present invention a pool of one or more transport layer connections can be used by the application without opening and closing transport layer connections for each request.

In another aspect the present invention is related to techniques for multiplexing application requests via the same or shared transport layer connection such as a transport layer connection established via the pooling techniques described in conjunction with . In some embodiments the present invention determines the availability of an established transport layer connection and multiplexes requests from a plurality of application via the connection by checking whether the content of a response from the server to an application s requests has been completely received. As will be discussed in further detail below the present invention uses in one embodiment the content length parameter of a response and in another embodiment a chunked transfer encoding header of a response to check if all the data of a response has been received. In one aspect the present invention checks whether all the data from a response has been received to determine if a pooled connection is currently free for use by an application and or whether to establish another transport layer connection to the pool of connections to the server such at steps and of method depicted in . In another embodiment the technique of checking the content length for a response is used as a technique for multiplexing requests from a plurality of applications via the same transport layer connection.

Referring now to an embodiment of a method for multiplexing requests via a single transport layer connection from the client to the server is depicted. In brief overview at step the acceleration program establishes a transport layer connection between the client and server . At step the acceleration program intercepts a first request of a first application to the server . At step the acceleration program determines whether the transport layer connection is currently being used by another application or is otherwise idle. At step if the transport layer connection is available to use by the application then at step the acceleration program transmits the request to the server. Otherwise at step if the transport layer connection is not available to use by the application then the acceleration program at step either waits for a time period and returns to step or establishes a second transport layer connection for use by the application . At step the acceleration program receives a response to the application s request from the server. At step the acceleration program intercepts a second request by a second application and proceeds at step to determine if the transport layer connection is available for use by the second application . In some embodiments the acceleration program intercepts the request of the second application at step prior to receiving the response of the first request at step or prior to receiving all of the data of the response. As discussed further herein in some embodiments the acceleration program uses content length checking technique to determine when the transport layer connection is idle or an application has received all the data to a response to a request.

In further detail at step the acceleration program establishes a transport layer connection between the client and server . In some embodiments the acceleration program establishes the transport layer connection with or via the appliance or an intermediary. In one embodiment the acceleration program establishes the transport layer connection as a pool of transport layer connection to the server . As such in some embodiments the transport layer connection may comprise a second or a third transport layer connection to the server . In other embodiments the acceleration program may establish the transport layer connection via a first program as previously discussed herein. In some embodiments the acceleration program established the transport layer connection in response to a request by a first application of the client .

At step the acceleration program intercepts a first request by a first application to access the server . In some embodiments the request is intercepted at the transport protocol layer before establishing or transmitting the request via the transport layer connection. In other embodiments the request is intercepted at any protocol layer above the transport layer or above the transport layer connection. In some embodiments the request is intercepted by a first program . In one embodiment the request of the application is a request to open or establish a transport layer connection with the server . In another embodiment the application request is a request to access the server via the established transport layer connection or via the appliance .

At step the acceleration program determines whether the transport layer connection is idle or available for use by the first application or to communicate the first request of the first application . In some embodiments the acceleration program determines from a pool of one or more transport layer connections which transport layer connection in the pool is idle or free to use by the first application . In one embodiment the acceleration program determines the transport layer connection is idle because the acceleration program established the transport layer connection in response to the request or immediately prior to the request. In some embodiments the acceleration program may have not received any requests from any application and recognizes this request as the first request to be intercepted and processed by the acceleration program . In another embodiment the acceleration program tracks the number of outstanding responses for any requests transmitted on the transport layer connection and if there are no outstanding responses the acceleration program recognizes the transport layer connection is available for use by the first application . In yet another embodiment the acceleration program recognizes the transport layer connection is currently idle. For example the acceleration program may be initiating keep alive requests to the server to keep the connection open. In some embodiments the transport layer connection is idle as the last transaction has been completed but the server and or client has not yet transmitted a RST and or FIN command.

In some embodiments the acceleration program may check the content length of a response to determine if the response from the server to the first request of the first application is complete or otherwise the acceleration program has received all the data to the response. As mentioned above these techniques in some embodiments are also used to determine to establish another connection for the pooling technique of the present invention. In regards to this technique of the present invention will be used to describe checking the content length parameter of a response in one embodiment or in another embodiment a chunked transfer encoding header of a response to determine whether all the data of a response has been received. depicts a TCP portion of a TCP packet referred to as a TCP segment . The TCP segment includes a TCP header and a body . The body comprises among other data and information a HTTP header and message in an embodiment wherein the TCP packet carries an application layer protocol of HTTP. In some embodiments a content length parameter is located found or referenced by or in the HTTP header. In one embodiment the acceleration program of the present invention uses the content length parameter to determine if all the data for a response is received.

The chunk size field A G are linked together or otherwise referenced or associated as illustrated in . The chunk size field A indicates the length of the message in the chunk message data A the chunk size field C indicates the length of the message in the chunk message data C and so forth. The last chunk size field G comprises the length value zero indicating that there are no more chunks or any more of the message to follow. In another embodiment the acceleration program of the present invention determines via the chunk size fields whether the client has received all the data to a response.

Although generally describes a technique for checking whether all the data for a response to a request has been received these techniques are applicable to a server or appliance sending an asynchronous message or communication to the client . Furthermore although these techniques are generally described in conjunction with for an HTTP protocol these techniques can be used for any protocol at any protocol layer that provided an indication of the length of data to be transmitted or received by the client . As such in some embodiment the acceleration program accesses extracts inspects analyzes or otherwise processes any portion of the network packet including at any protocol layer to determine if all the data has yet been received in association with a request response or communication between the client and the server or appliance. In yet another embodiment the acceleration program tracks the numbers of bytes transmitted received and acknowledged between the client and server to determine if any bytes are outstanding between the client and server for an application .

By using the content length techniques described above the acceleration program of the present invention can reuse the same transport layer connection to the server previously used or in the process of use by any other application of the client .

At step the acceleration program determines if the transport layer connection is available to transmit the first request and if so at step transits the request to the server . Otherwise at step the acceleration program may wait until all the data is received for an outstanding request of an application. For example the acceleration program may set a timer for example to a short time period and proceed to step . In some embodiments the acceleration program checks if the all the data has been received responsive to a packet processing timer of the network stack of the client . In another embodiments at step the acceleration program establishes another transport layer connection to transmit the first request of the first application

At step the acceleration program may track which application currently has an outstanding request or response on the connection or is currently using the connection. For example only one application at a time may transmit a request and receive a response on the connection. As such the acceleration program understands which application is using the connection. In some embodiments the acceleration program uses one port number for the transport layer connection communication for all applications of the client sharing the connection. In some cases the acceleration program tracks the requests and outstanding responses for the requests on an application by application basis. In some embodiments the acceleration program associates a process id of the application with the request. In yet another embodiment the acceleration program transmits the request of the first application with a request of the second application in the same network packet or packets TCP segment or segments. In other embodiments the acceleration program transmits a plurality of requests of applications via the same transport layer connection as part of a series of TCP segments of one or more TCP segment windows.

In other embodiments the acceleration program uses a port numbering mechanism and or scheme to track and recognize which response or message received is for which application . In other embodiments the acceleration program provides and associates a port number with the application and modifies the port number in the TCP network packet to be transmitted to the application s assigned port number. In another embodiment the port number is provided by the application and the acceleration program changes or otherwise provides the port number accordingly in the TCP network packet. As such in some embodiments the acceleration program may interweave requests from a plurality of applications of the client such that applications may use the transport layer connection at the same time.

At step the acceleration program receives a response to the first request of the first application from the server such as via appliance and provides the response to the first application . In some embodiments the acceleration program provides the response to the first application via the network stack such as allowing or initiating the processing of the response by the protocol layers above the transport layer of the connection. In another embodiment the first program provides the response to the first application . In other embodiments the acceleration program may provide the response to the first application via an inter process communication mechanism or an interface such as an API. In some embodiments the acceleration program only receives a portion of the response such as a first chunk in a multi chunk message as described in .

At step the acceleration program intercepts a request of a second application to access the server . In some embodiments the acceleration program intercepts the request of the second application prior to step . In other embodiments the acceleration program intercepts the request of the second application during receipt of the response at step . In another embodiment the acceleration program intercepts the request of the second application prior to the client or acceleration program receiving all the data for a response of the first request of the first application . Upon interception of the request of the second application the acceleration program proceeds to step in an embodiment of the present invention to determine whether to multiplex the second request via the transport layer connection or whether to establish another transport layer connection such as another connection in a pool of connections. In other embodiments the acceleration program transmits the request of the second application via the same connection as the first application while the first application has an outstanding response or has not received all the data from the response of the first request. In another embodiment the acceleration program transmits the request of the second application after the first application has received the response and prior to any generated RST and or FIN commands are generated in connection with the first application

Although the acceleration program has generally been discussed in relation to the client side implementation and execution of acceleration techniques the acceleration program interfaces and works in conjunction with the appliance which also implements and executes appliance side acceleration techniques. In one embodiment the client side acceleration program and the appliance may work in conjunction with each other to perform a plurality of the acceleration techniques of the present invention on communications between the clients and the servers . In some embodiments the client side acceleration program and the appliance both provide TCP pooling and multiplexing such as to provide a cascading or end to end pooling and multiplexing mechanism between clients and servers . For example the acceleration program may provide a first pooled transport layer connection to the appliance which in turns provides a second pooled transport layer connection to the server . In another example the acceleration program may multiplex an application request via a first pooled transport layer connection on the client which in turns is multiplexed by the appliance via the second pooled transport layer connection to the server . In some embodiments the acceleration program provides a throttling mechanism for transmitting requests from the client while the appliance provides a throttling mechanism for transmitting responses from the servers to the clients . In another embodiment the acceleration program performs client side caching for the client while the appliance provides caching of objects such as dynamically generated objects for the client along with other clients 

In some embodiments in addition to or in conjunction with performing acceleration techniques on the client and or appliance the acceleration program and the appliance may provide a virtual private network connection and communications between the client and a network access via the appliance . In another embodiment the acceleration program may compress data communicated from an application and the appliance may decompress the compressed data upon receipt thereof. Conversely appliance may compress data communicated from an application on the server on a private data communication network and the acceleration program may decompress the compress data upon receipt thereof. Also the acceleration program and appliance may act as endpoints in an encrypted data communication or tunneling session in which the acceleration program encrypts data communicated from an application and appliance decrypts the encrypted data upon receipt thereof. In a similar manner appliance encrypts data communicated from an application on private data communication network and the acceleration program may decrypt the data upon receipt thereof.

In view of the structure function and operations of the client side acceleration deployment and execution techniques described herein the present invention provides a plurality of acceleration techniques on the client deployed efficiently and also executed in an efficient and transparent manner on the client. In some embodiments the present invention avoids the installation of an appliance based or server based accelerator between the client and a public data communication network. Furthermore because the acceleration program is dynamically provided to client and automatically installed and executed on the client upon a network acceleration can be achieved on any client machine. Also because the acceleration program is stored and dynamically downloaded from the appliance or a server upgrades and or maintenance to the acceleration program can be done once and deployed dynamically and automatically to clients as they access the network. Additionally the present invention works in conjunction with an appliance side accelerator to perform end to end acceleration from client to appliance to server.

While various embodiments of the present invention have been described above it should be understood that they have been presented by way of example only and not limitation. Thus it will be understood by those skilled in the relevant art s that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined in the appended claims. Accordingly the breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

