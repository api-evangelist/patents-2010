---

title: Managing copy-on-writes to snapshots
abstract: An attempt to write to a block of data in a main volume of data is detected. An indicator associated with the block of data is accessed before a copy-on-write operation to a snapshot volume is performed for the block of data. The indicator is used to determine whether the copy-on-write operation is to be performed for the block of data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09176853&OS=09176853&RS=09176853
owner: Symantec Corporation
number: 09176853
owner_city: Mountain View
owner_country: US
publication_date: 20100129
---
Snapshots are used to record and preserve the state of a volume of data at any given moment. There are many scenarios where a consumer application e.g. a backup or replication application takes a volume snapshot to create a consistent point in time image of the stored information in order to read blocks of data without interfering with another application e.g. a database application that is also making use of that information. These snapshots are most of the time solely for the purpose of the consumer application. The duration of the backup replication task is also the lifetime of the snapshot. Depending upon the amount of data to be processed from the snapshot this lifetime can be quite long especially if the backup replication application requires persisting the snapshot during the processing.

For the lifetime of the snapshot there will be a copy on write overhead associated with every first write to a block in the volume of data even for those blocks that have already been read by the consumer application. That is even though a block in the volume has already been read by the consumer application and a point in time image of the data in that block is no longer needed for that purpose the data in the block will still be copied from the volume to the snapshot if data is to be written to that block unnecessarily incurring a copy on write overhead.

In one embodiment an attempt to write to a block of data in a main volume of data is detected. An indicator associated with the block of data is accessed before a copy on write operation to a snapshot volume is performed for the block of data. The indicator is used to determine whether the copy on write operation is to be performed for the block of data.

In another embodiment a main volume comprising blocks of data is accessed. A subset of the blocks of data is designated as blocks that are not of interest. A copy on write to a snapshot of a block of data included in the subset is prevented a copy on write to the snapshot of a block of data not included in the subset is allowed.

In yet another embodiment a first application can write data to a main volume comprising blocks of data. A snapshot driver can create a snapshot for the main volume. A second application can read data from the main volume and from the snapshot. The second application designates a subset of the blocks of data as blocks that are not of interest. Advantageously a copy on write of a block of data in the subset is not performed if the first application initiates a write to the block of data.

In the above embodiments a block of data may be replicated backed up before that block is copy on written in which case a copy on write is therefore not performed for that block of data. Alternatively the snapshot volume may be for a portion of the main volume that does not include a particular block of data in which case a copy on write is therefore not performed for that block of data. Then again the snapshot volume may be for a file that spans a subset of the blocks that does not include a particular block of data in which case a copy on write is therefore not performed for that block of data.

In one embodiment a first bitmap of the main volume is maintained to track which blocks in the main volume can be copy on written. A second bitmap of the main volume which tracks the blocks that have been written to the snapshot volume may also be used.

According to embodiments of the present disclosure potential copy on writes for certain blocks are avoided reducing the number of copy on writes and the associated overhead.

These and other objects and advantages of the various embodiments of the present disclosure will be recognized by those of ordinary skill in the art after reading the following detailed description of the embodiments that are illustrated in the various drawing figures.

Reference will now be made in detail to the various embodiments of the present disclosure examples of which are illustrated in the accompanying drawings. While described in conjunction with these embodiments it will be understood that they are not intended to limit the disclosure to these embodiments. On the contrary the disclosure is intended to cover alternatives modifications and equivalents which may be included within the spirit and scope of the disclosure as defined by the appended claims. Furthermore in the following detailed description of the present disclosure numerous specific details are set forth in order to provide a thorough understanding of the present disclosure. However it will be understood that the present disclosure may be practiced without these specific details. In other instances well known methods procedures components and circuits have not been described in detail so as not to unnecessarily obscure aspects of the present disclosure.

Some portions of the detailed descriptions that follow are presented in terms of procedures logic blocks processing and other symbolic representations of operations on data bits within a computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. In the present application a procedure logic block process or the like is conceived to be a self consistent sequence of steps or instructions leading to a desired result. The steps are those utilizing physical manipulations of physical quantities. Usually although not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated in a computer system. It has proven convenient at times principally for reasons of common usage to refer to these signals as transactions bits values elements symbols characters samples pixels or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions it is appreciated that throughout the present disclosure discussions utilizing terms such as accessing writing detecting determining performing maintaining updating replicating creating storing designating setting or the like refer to actions and processes e.g. flowcharts and of respectively of a computer system or similar electronic computing device or processor e.g. system of . The computer system or similar electronic computing device manipulates and transforms data represented as physical electronic quantities within the computer system memories registers or other such information storage transmission or display devices.

Embodiments described herein may be discussed in the general context of computer executable instructions residing on some form of computer readable storage medium such as program modules executed by one or more computers or other devices. By way of example and not limitation computer readable storage media may comprise computer storage media and communication media. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or distributed as desired in various embodiments.

Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to random access memory RAM read only memory ROM electrically erasable programmable ROM EEPROM flash memory or other memory technology compact disk ROM CD ROM digital versatile disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that can be used to store the desired information and that can accessed to retrieve that information.

Communication media can embody computer executable instructions data structures program modules or other data in a modulated data signal and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media. Combinations of any of the above can also be included within the scope of computer readable media.

In overview embodiments according to the present disclosure include systems that allow a snapshot driver to be aware of what blocks of data in a volume are of interest to applications which are consumers of a snapshot e.g. backup or replication applications and to use that knowledge to reduce the number of copy on writes COWs . In one embodiment the snapshot driver maintains a bitmap for the blocks in the volume and implements an application programming interface API that the consumer application can call to set the bits in that bitmap. The consumer application can use the API to set a bit whenever the corresponding block in the volume is successfully read backed up replicated . The snapshot driver in turn can refer to the bitmap before performing a potential copy on write for a block and proceeds with the copy on write if the corresponding bit is not set.

Embodiments according to the present disclosure also provide methods for reducing copy on writes in a backup replication operation using snapshots by making the snapshot driver aware of what blocks the backup replication application the consumer of the snapshot is interested in at a particular point in time. In one embodiment this awareness is implemented through a bitmap for blocks in the volume. The bitmap can be maintained by the snapshot driver and consulted when writes are about to happen to the main volume. The snapshot driver exposes an API that the consumer application can use to set the bits in this bitmap. The consumer application can set a bit when it is no longer interested in the corresponding block which can happen for at least two reasons.

When a write is scheduled for a block if the corresponding bit is set in the bitmap the snapshot driver will not perform a copy on write for that block. Snapshot drivers may use such a bitmap to mark the bit for a block for which a copy on write is done once so that next time a write happens to the same block another copy on write is avoided. The same infrastructure can be leveraged so that embodiments according to the present disclosure do not increase overhead during a potential copy on write.

A separate thread in the driver can handle API calls by the consumer application. The API can be written in such a way so that multiple bits can be set using a single call. Note that no locks and such are necessary for the bitmap or the main volume so that even if the snapshot driver happens to read an unset bit before the consumer application is able to set it this will only result in an unnecessary copy on write there is no data corruption or loss as far as the consumer application is concerned.

In effect the bitmap is maintained in such a way that at any given point in time it represents only blocks that are of interest to the consumer application by having bits corresponding to those blocks unset in the bitmap. The snapshot driver in turn avoids potential copy on writes for blocks corresponding to the bits set in this bitmap.

In the example of the network includes servers A B . . . N. Collectively the server nodes may be referred to as a server cluster. The server nodes may be data servers that communicate with metadata servers not shown or the server nodes may be data servers that perhaps incorporate the functionality of a metadata server.

The clients . . . M can access the servers A B . . . N via a local area network LAN storage area network SAN or wide area network WAN . Also the client nodes may communicate with each other and the server nodes may communicate with each other via the LAN SAN or WAN.

In the example of the computer system includes a bus which interconnects major subsystems of the computer system. These subsystems include a central processor a system memory an input output controller an external audio device such as a speaker system via an audio output interface an external device such as a display screen via display adapter serial ports and a keyboard interfaced with a keyboard controller a storage interface a floppy disk drive operative to receive a floppy disk a host bus adapter HBA interface card A operative to connect with a Fibre Channel network an HBA interface card B operative to connect to a Small Computer System Interface SCSI bus alternatives to SCSI include Integrated Development Environment IDE and Serial Advanced Technology Attachment SATA and an optical disk drive operative to receive an optical disk . Also included are a mouse or other point and click device coupled to bus via serial port a modem coupled to bus via serial port and a network interface coupled directly to bus . The modem network interface or some other method can be used to provide connectivity to the network of .

The bus of allows data communication between the central processor and system memory which may include ROM or flash memory and RAM not shown as previously noted. The RAM is generally the main memory into which the operating system and application programs are loaded. The ROM or flash memory can contain among other code the Basic Input Output System BIOS which controls basic hardware operation such as the interaction with peripheral components.

Applications resident in the computer system are generally stored on and accessed via a computer readable storage medium such as a hard disk drive e.g. the fixed disk an optical drive e.g. the optical drive a floppy disk unit or other storage medium. Applications can be in the form of electronic signals modulated in accordance with the application and data communication technology when accessed via the network modem or the interface .

Continuing with reference to storage interface as with the other storage interfaces of computer system can connect to a standard computer readable storage medium for storage and or retrieval of information such as a fixed disk drive . The fixed disk drive may be a part of the computer system or it may be separate and accessed through other interface systems. The modem may provide a direct connection to a remote server via a telephone link or to the Internet via an internet service provider ISP . The network interface may provide a direct connection to a remote server via a direct network link to the Internet via a POP point of presence . The network interface may provide such a connection using wireless techniques including digital cellular telephone connection Cellular Digital Packet Data CDPD connection digital satellite data connection or the like.

Many other devices or subsystems not shown in may be connected in a similar manner e.g. document scanners digital cameras and so on . Conversely all of the devices shown in need not be present to practice the present disclosure. The devices and subsystems can be interconnected in different ways from that shown in .

The operation of a computer system such as that shown in is readily known in the art and is not discussed in detail in this application. Code to implement the present disclosure can be stored in computer readable storage media such as one or more of the system memory fixed disk optical disk or floppy disk . The operating system provided on the computer system may be MS DOS MS WINDOWS OS 2 UNIX Linux or another known operating system.

Moreover regarding the signals described herein those skilled in the art will recognize that a signal can be directly transmitted from a first block to a second block or a signal can be modified e.g. amplified attenuated delayed latched buffered inverted filtered or otherwise modified between the blocks. Although the signals of the above described embodiment are characterized as transmitted from one block to the next other embodiments of the present disclosure may include modified signals in place of such directly transmitted signals as long as the informational and or functional aspect of the signal is transmitted between blocks. To some extent a signal input at a second block can be conceptualized as a second signal derived from a first signal output from a first block due to physical limitations of the circuitry involved e.g. there will inevitably be some attenuation and delay . Therefore as used herein a second signal derived from a first signal includes the first signal or any modifications to the first signal whether due to circuit limitations or due to passage through other circuit elements which do not change the informational and or final functional aspect of the first signal.

With reference to a volume manager operates as a subsystem between an operating system and one or more volumes of data blocks of data that are stored in a data storage system see for examples . The data storage system may include physical storage devices such as an array of physical disks LUNs SCSI logical units or other types of hardware that are used to store data. The volume manager overcomes restrictions associated with the physical storage devices by providing a logical volume management layer that allows data to be spread across multiple physical disks within a disk array not shown in a manner that is transparent to the operating system in order to distribute and or balance input output I O operations across the physical disks. Each of the volumes can retrieve data from one or more of the physical storage devices and the volumes are accessed by file systems databases and other applications in the same way that physical storage devices are accessed. The operation of the volume manager in the manner just described is well known.

A volume of data includes one or more blocks of data including a block . The volume is analogous to the volume of . The volume may also be referred to as the first volume the primary volume or the main volume.

A snapshot is associated with the volume and provides a consistent point in time image of the information stored in the volume . In the example of the snapshot is created by the snapshot driver for use by the consumer application . The consumer application may be a backup or replication application. The snapshot allows the consumer application to read one or more blocks of data without interfering with another application e.g. first application that is also making use of that information e.g. reading writing a block . The consumer application can also read from the volume as described further below.

In general a block of data e.g. block is copied from the volume to the snapshot only if there is a write to that block of data hence the snapshot is referred to as a copy on write snapshot. According to embodiments of the present disclosure potential copy on writes for certain blocks are avoided reducing the number of copy on writes and the associated overhead. For blocks of data in the volume that have not changed the snapshot merely contains a pointer to the volume . As such the snapshot may be referred to as a space optimized copy on write snapshot.

In one embodiment a data structure e.g. bitmap is associated with the volume . In general the bitmap is used to track which blocks in the volume have been copy on written to the snapshot . In one embodiment the bitmap is also used by the snapshot driver to indicate the blocks in the volume that are of interest and or are not of interest to the consumer application at a particular point in time.

In one embodiment the consumer application advantageously sets the bit for a block that is not of interest to that application. The consumer application may not be interested in a given block if for example the snapshot was taken for an incremental backup and the given block is not one of the candidate blocks. In other words the snapshot may correspond to only a subset of the blocks in the volume and the given block may not be in that subset.

Also the consumer application may not be interested in a given block if for example the given block is not part of a file or files included in a selection list for backup. In other words the snapshot may correspond to a particular file that spans multiple blocks in the volume and the given block may not be part of that file.

In the examples just described the consumer application can set bits corresponding to the blocks that the application is not interested in at the start of its task e.g. at the start of a backup replication task and or when the snapshot is created.

The consumer application may also not be interested in a given block if that block was successfully read e.g. successfully backed up replicated by the consumer application. In this instance the consumer application will set the corresponding bit as and or when the read happens. As used herein successfully means that the block of data was correctly and completely read and or copied this can be verified using for example a checksum or some other well known technique.

In one embodiment the snapshot driver exposes an API that the consumer application can use to set the bits in the bitmap . The consumer application can set a bit which may be referred to generally as an indicator via the snapshot driver when that application is no longer interested in the corresponding block the bits remain set for the lifetime of the snapshot . The bitmap is thus maintained by the snapshot driver which consults the bitmap prior to a write to a block in the volume before performing a potential copy on write for the block. The copy on write proceeds if the corresponding bit is not set when the bit is not set it indicates that the consumer application is interested in the corresponding block but has not yet read that block in which case the copy on write proceeds so that the consumer application will have access to the original data in the block. Conversely if the consumer application is not interested in a block or is no longer interested in the block then a copy on write of that block is not necessary accordingly the corresponding bit is set and the copy on write is not performed.

The snapshot driver can use the same bitmap to track both blocks of interest to the consumer application and copy on writes as follows 

In one embodiment instead of using one bitmap as just described a second bitmap not shown in is also used one bitmap may be used to track blocks of interest to the consumer application and the second bitmap may be used to track copy on writes. Also although a bitmap is described the invention is not so limited. For example instead of a bitmap or bitmaps a map implemented as a series of bits that represent multiple states can be used one bit per block can be used to track copy on writes and another bit per block can be used to track blocks of interest to a consumer application and other bits per block can be used to track blocks of interest to other consumer applications . In general any type of data structure can be used to accomplish the functionality of the bitmap s described above.

Note that the above discussion is in the context of a snapshot created for a particular consumer application. Other snapshots may be created for other applications and may exist in parallel with the snapshot and copy on writes to those other snapshots can continue to occur.

After the block is successfully read the snapshot driver specifically the API sets a corresponding bit in the data structure which may be the bitmap of . In the example of the bit corresponding to the block is set to a value of one 1 . When a bit is not set e.g. has a value of zero it indicates that the consumer application is interested in the corresponding block but has not yet read that block. Conversely if the consumer application is not interested in a block or is no longer interested in the block then a copy on write of that block is not necessary accordingly the corresponding bit is set and the copy on write is not performed. Once the corresponding bit is set in the data structure e.g. bitmap then a subsequent attempt to write data to the block will not result in that block being copy on written to the snapshot .

A similar process is performed when other blocks of data in the volume are to be read by the consumer application . If there is an overhead associated with doing this for each block the API can be called once a threshold number of blocks are read. The API can be written in such a way so that multiple bits can be set using a single call.

Note that locks and the like are not necessary for the volume because if the snapshot driver happens to read an unset bit before the consumer application is able to set it this will only result in an unnecessary copy on write.

As opposed to conventional approaches embodiments according to the present disclosure use the consumer application to provide information to the snapshot driver as to which blocks the consumer application is interested in at a given point in time. Accordingly point in time consistency need not be continually maintained for a snapshot associated with the consumer application.

For example the consumer application may be performing only an incremental backup of the volume that is only a portion of the volume e.g. blocks A B and C is to be backed up replicated. Accordingly the snapshot may only be for blocks A B and C in which case the bits for blocks A B and C are not set and the bits for the other blocks in the volume are set as shown in . When a bit is not set it indicates that the consumer application is interested in the corresponding block but has not yet accessed that block.

Thus as shown in an attempt to write to any of the blocks A B and C before the consumer application has a chance to access read backup replicate the data in that block will result in a copy on write of the block to the snapshot . After the copy on write is completed the corresponding bit in the data structure e.g. bitmap is set as shown in so that subsequent attempts to write to that block in the volume will not trigger another copy on write.

As another example the consumer application may be backing up a file that may span multiple blocks e.g. blocks A B and C . In a manner similar to that just described the snapshot may only may include blocks A B and C in which case the bits for blocks A B and C are not set and the bits for the other blocks in the volume are set as shown in . As shown in an attempt to write to any of the blocks A B and C before the consumer application has a chance to access read backup replicate the data in that block will result in a copy on write of the block to the snapshot . After the copy on write is completed the corresponding bit in the data structure e.g. bitmap is set as shown in .

In block of with reference also to an attempt to write to a block of data in a first volume of data e.g. volume is detected. A copy on write snapshot volume is associated with the first volume but the snapshot volume does not include a copy of the block of data.

In block an indicator e.g. a bit in a bitmap associated with the block of data is accessed before a copy on write operation to the snapshot volume is performed for the block of data.

In block the value of the indicator is used to determine whether or not to perform a copy on write operation for the block of data as previously described herein. Thus even though a block of data is not in the snapshot and the block may be overwritten with new data in some cases such as those described above the block is not copy on written to the snapshot. As such the number of copy on writes is advantageously reduced. In other words a copy on write that would occur conventionally may not occur according to embodiments of the present disclosure.

In block of with reference also to a volume of data e.g. volume comprising multiples blocks of data is accessed. A copy on write snapshot is associated with the volume.

In block a subset of the blocks is designated as blocks not of interest to a consumer application. In one embodiment a respective bit per block is set to indicate blocks that are not of interest. The snapshot does not include a copy of blocks of data in the subset.

In block a copy on write to the snapshot of a block of data included in the subset is prevented while a copy on write to the snapshot of a block of data not included in the subset is allowed. Again if a block is not of interest to the consumer application then that block is not copy on written to the snapshot even though that block is not in the snapshot and may be overwritten. Thus the number of copy on writes can be reduced.

The foregoing description for purpose of explanation has been described with reference to specific embodiments. However the illustrative discussions above are not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain the principles of the invention and its practical applications to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as may be suited to the particular use contemplated.

For example embodiments according to the present disclosure can also be used to good effect if the consumer application has some information about the order in which writes happen to a volume and is able to make use of this information to read e.g. back up or replicate blocks in a specific order and thus avoid the necessity to copy on write a block that is going to be written to in the near future. This would work even if the backup destination at least the immediate destination is disk memory.

More specifically with reference back to blocks are generally read in sequential order. As such the first application can inform the snapshot driver of an impending write to a block in the volume . The consumer application can also be informed of the impending write so that the consumer application can also read the block before the write occurs. As a result the bit can be set for that block so that the block does not have to be copy on written to the snapshot for the purposes of the consumer application .

Also although embodiments according to the present disclosure are explained in the context of snapshots at the volume level they can be used for snapshots at all levels where copy on writes are performed. Also note that even though only backup and replication applications are mentioned embodiments according to this invention can be used with other types of applications that are consumers of a copy on write snapshot.

Embodiments according to the present disclosure are useful for reducing copy on writes for incremental as well as full reads of a snapshot and are particularly significant for full backup replication operations. Embodiments are also useful in scenarios in which a snapshot is persisted such as when a failed job is retried where some data is already used by the consumer application and there is a delay before the remaining data is used.

Embodiments according to the invention are thus described. While the present disclosure has been described in particular embodiments it should be appreciated that the invention should not be construed as limited by such embodiments but rather construed according to the below claims.

