---

title: Determining liveness of protocols and interfaces
abstract: The liveness of routing protocols can be determined using a mechanism to aggregate liveness information for the protocols. The ability of an interface to send and receive packets and the forwarding capability of an interface can also be determined using this mechanism. Since liveness information for multiple protocols, the liveness of interfaces, the forwarding capability of interfaces, or both, may be aggregated in a message, the message can be sent more often than could individual messages for each of the multiple protocols. This allows fast detection of failures, and sending connectivity messages for the individual protocols, such as neighbor “hellos,” to be sent less often.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09166901&OS=09166901&RS=09166901
owner: Juniper Networks, Inc.
number: 09166901
owner_city: Sunnyvale
owner_country: US
publication_date: 20100720
---
This application is a continuation of U.S. patent application Ser. No. 10 775 486 referred to as the 486 application and incorporated herein by reference filed on Feb. 10 2004 now U.S. Pat. No. 7 769 885 titled DETERMINING LIVENESS OF PROTOCOLS AND INTERFACES and listing Kireeti KOMPELLA as the inventor which is based upon and claims the benefit of U.S. Provisional Application No. 60 472 859 entitled DETERMINING LIVENESS OF MULTIPLE PROTOCOLS AND OR INTERFACES filed on May 23 2003 and listing Kireeti KOMPELLA as the inventor. The utility and provisional applications are expressly incorporated herein by reference. The scope of the invention is not limited to any requirements of the specific embodiments in that application.

The invention concerns detecting errors in connections protocols data plane components or any combination of these.

The description of art in this section is not and should not be interpreted to be an admission that such art is prior art to the invention.

A protocol is a specific set of rules procedures or conventions relating to the format and timing of data transmission between two devices. Accordingly a protocol is a standard set of procedures that two data devices use to work with each other. Nodes such as routers in communications networks may use protocols to exchange information. For example routers may use routing protocols to exchange information used to determine routes. illustrates two nodes coupled via communications link . Node includes various interfaces and supports protocols . Interface terminates communications link . Similarly node includes interfaces and supports protocols . Interface terminates communications link . Node and node can be considered neighbors or adjacencies since they each terminate communications link . As indicated by the dashed lines an instance of protocol A and an instance of protocol B at node may communicate with another instance of protocol A and another instance of protocol B respectively at node . Although not shown the communications between the protocols actually occur via interfaces and communications link .

Conventional routing protocols may include some form of liveness detection. For example the intermediate system intermediate system protocol IS IS and the open shortest path first protocol OSPF include a hello mechanism that lets a router running IS IS or OSPF know whether nodes sharing a communications link with the router are still up. Some protocols such as a border gateway protocol BGP use the underlying transport to determine the liveness of their neighbors. In the case of BGP transmission control protocol TCP keepalives are used. Other protocols such as routing information protocols RIP have intrinsic liveness mechanisms. In most cases once an adjacency with a neighbor node running the same protocol is established with an initial hello message subsequent hello messages don t need to carry a lot of information.

In most if not all of these liveness detection mechanisms the time needed to conclude that one s neighbor is down ranges from seconds to tens or even hundreds of seconds. For example with IS IS hellos are normally sent every nine 9 seconds. A node determines a neighbor to be down only after three 3 consecutive hellos have been unanswered. Accordingly a node running IS IS normally needs at least 27 seconds before it determines that a neighbor node is down. Similarly with the point to point protocol PPP hellos are normally sent every ten 10 seconds. A node determines a neighbor to be down only after three 3 consecutive hellos have been unanswered. Accordingly a node running PPP normally needs at least 30 seconds before it determines whether a neighbor node is down.

Since routers and other nodes on the Internet are predominantly used for communicating data for applications such as e mail that are tolerant of some delay or packets received out of sequence the conventional liveness detection schemes are acceptable. However as more demanding applications such as voice over IP use the Internet or other packet switched networks there are instances where detecting that a neighbor is down in a few tenths of a second or even hundredths of a second may be necessary. Such fast liveness detection is needed for example where failover needs to occur quickly so that an end user doesn t perceive or at least isn t unduly annoyed by the failure of an adjacency e.g. due to any one of a node failure a link failure or a protocol failure .

One approach to determining liveness faster is to allow faster e.g. sub second protocol hello timers. This is feasible for some protocols but might require changes to the protocol. Implementing these protocol changes on new nodes and propagating these protocol changes to nodes previously deployed in a communications network is not trivial. Moreover for some other protocols faster protocol hello timers are simply not feasible.

Even if all protocols could implement fast protocol hello timers at least two additional issues make such a simple brute force change unattractive. First routers often implement multiple routing protocols each having its own liveness detection mechanism. Consequently updating each routing protocol to enable fast detection can lead to a considerable amount of work. Second hello messages often carry more than just liveness information and can therefore be fairly large and require non trivial computational effort to process. Consequently running fast liveness detection between a pair of neighbor nodes each running multiple protocols can be expensive in terms of communications and computational resources required to communicate and process the frequent lengthy messages for liveness detection.

Additionally it is desirable to check interface forwarding liveness i.e. the ability to forward data over an interface . Forwarding liveness may be a function of various components in the data plane of a data forwarding device such as a router. For example data plane components may include a forwarding table sometimes referred to as a forwarding information base switch fabric forwarding lookup engine traffic scheduler traffic classifier buffers segmenters reassemblers resequencers etc. Such components may be embodied as memory processors ASICs etc.

In view of the foregoing there is a need to detect liveness faster that conventional liveness detection schemes. It is desirable that such liveness detection i have minimal impact on existing protocols ii not waste communications resources and iii not be computationally expensive.

Apparatus data structures and methods consistent with the principles of the invention provide a routing protocol independent mechanism for fast liveness detection more accurately deadness detection . At least some embodiments consistent with the principles of the invention require no changes to the packets sent or received by any routing protocol. Embodiments consistent with the principles the invention need not supercede the existing hello functionality of protocols such as routing and forwarding protocols if any . This aspect may be important in instances where existing mechanisms carry much more information than just liveness.

In one embodiment consistent with the principles of the present invention a sending node may a accept status information from at least two protocols b compose a message including the status information and c send the message towards a neighbor node. In at least one embodiment the sending node may further d maintain a first timer for tracking a send time interval such that the acts of composing a message and sending the message are performed after expiration of the first timer and e restart the first timer after the message is sent.

In one embodiment consistent with the principles of the present invention a receiving node may a receive a message including status information for each of at least protocols of a neighbor node and a time interval and b update the neighbor node protocol status information using the message. In at least one embodiment the receiving node may update neighbor node protocol status information by a setting a first timer to the time interval and starting the first timer b if the first timer expires setting the status of each of the protocols of the neighbor node to down and c if a further message is received then resetting the first timer to the new time interval and restarting the first timer.

Elements apparatus systems computer implemented code data structures and methods consistent with the principles of the invention permit the liveness of protocols interfaces or both to be monitored. The following description is presented to enable one skilled in the art to make and use the invention and is provided in the context of particular applications and their requirements. Various modifications to the disclosed embodiments will be apparent to those skilled in the art and the general principles set forth below may be applied to other embodiments and applications. Thus the invention is not limited to the embodiments shown and the inventor regards his invention as the following disclosed methods apparatus and data structures and any other patentable subject matter.

An exemplary environment in which the invention may operate is described in 4.1. Then elements apparatus systems computer implemented code methods and data structures that may be used to perform operations and store information in manners consistent with the principles of the invention are described in 4.2. An example illustrating operations performed by an exemplary embodiment of the invention is then provided in 4.3. Finally some conclusions regarding the invention are set forth in 4.4.

The invention may be used in communication systems including nodes for forwarding data such as packets. Such nodes may be routers. For example the invention may be used to quickly detect a down connection e.g. a down link node or interface protocol or both. The invention may be used in conjunction with a fast reroute technique a graceful or hitless restart technique or some other failover technique.

The invention can be used in an exemplary communications environment such as the one illustrated in . Referring to suppose node and node are routers and that protocol A is IS IS and protocol B is resource reservation protocol RSVP . Suppose further that node and node have established an IS IS adjacency and one or more RSVP sessions. Consistent with the principles of the invention both nodes may be configured with a time interval referred to as the dead interval in which to send a hello. If the IS IS dead interval for node is 27 seconds then node will declare its IS IS adjacency with node dead if it doesn t receive an IS IS hello from node within 27 seconds of the previous hello. Typically node will send hellos more frequently than once every 27 seconds so that even if a hello or two are lost the adjacency stays up.

Once node and node have established various routing protocol sessions between themselves they can begin exchanging aggregated protocol and or forwarding liveness APFL hellos in a manner consistent with the principles of the invention. In one embodiment of the invention an APFL hello contains a list of protocols that it is reporting on in this case IS IS and RSVP as well as the status of those protocols e.g. up or down . The APFL hello message may also contain a dead interval. Node is essentially saying If I don t send you an APFL hello within the dead interval of my previous APFL hello declare all protocols reported in the last received APFL hello as dead. 

Note that the regular IS IS hellos should also be running. Thus node will declare its IS IS adjacency with node dead if any of the following occur 

Moreover Node may include means for monitoring forwarding liveness for each of one or more of its interfaces . Similarly Node may include means for monitoring forwarding liveness for each of one or more of its interfaces and . Forwarding liveness refers to the ability to forward traffic over an interface.

Exemplary methods elements apparatus systems and data structures for performing APFL operations will now be described.

APFL operations use hello interval information protocols interfaces or both using aggregated liveness dead interval neighbor node pair information and APFL neighbor information to determine liveness of various peer protocols forwarding liveness of interfaces of various neighbor nodes or both. Configuration operations may be used to configure hello interval information protocols interfaces or both using aggregated liveness and dead interval neighbor node pair information .

Returning to block if a lost hello timer has expired the last received protocol status for each protocol in the last received protocol registration is set to down and the protocol is notified Loop including . The lost hello timer is then stopped and the method is left .

Again referring back to block if APFL information such as a packet is received from another node it is determined whether or not to discard the information. This determination may be based on configuration or rate limiting . If it is decided to discard the APFL information the APFL information is discarded and the method is left and . If on the other hand it is decided to not discard the APFL information the contents of the APFL packet may be checked for sanity such as self consistency as well as consistency with previously received APFL packets . If sanity check fails the APFL information should be discarded . Stored neighbor information described below with reference to is checked for a match and . If a match is not found the APFL information is discarded or a new entry in the stored neighbor information is created before the method is left and . If a match is found it is determined whether the received information is newer than the matching information already stored. . If not the information is stale and is therefore discarded and the method is left and . If on the other hand the received information is newer than the matching information already stored it may be determined whether the new protocol registration is the same as a last received protocol registration and . More specifically if the received protocol registration is the same as the last received protocol registration then the liveness information may have been aggregated from the same set of protocols. Otherwise liveness information may be provided for a newly added protocol or no longer provided from a removed protocol.

If the new protocol registration is the same as the last protocol registration it is determined whether or not the status of any of the protocols has changed Loop . For each protocol with a changed status it is determined whether the status of the protocol is up or down . If the status of the protocol changed to down the last received protocol status for the protocol is set to down and the local instance of the protocol is notified . If on the other hand the status of the protocol changed to up the last received protocol status for the protocol is set to up and the local instance of the protocol is notified . After any protocols with changed status are processed the last received sequence number is set to the sequence number in the received information . The lost hellos timer is set to the dead interval and the method is left .

Referring back to block if the new protocol registration is not the same as the last received protocol registration i.e. if the status for each of one or more protocols has been added and or removed processing is performed for each newly added protocols if any and for each deleted protocol if any. More specifically for each added protocol Loop the last received status for the protocol is set to down and it is determined whether the status of the new protocol is up or down . If the status of the new protocol is determined to be up the last received protocol status for the protocol is set to up and the local instance of the protocol is notified . If on the other hand the status of the new protocol is determined to be down the last received protocol status for the protocol is set to down and the local instance of the protocol is notified . For each deleted or removed protocol Loop the last received protocol status is set to down and the local instance of the protocol is notified . Once processing is performed for each newly added protocol if any and for each deleted protocol if any as described above the last received sequence number is set to the sequence number in the received information . The lost hellos timer is set to the dead interval and the method is left .

Although the foregoing description referred to aggregated protocol status the aggregated protocol status may include forwarding liveness status. Such forwarding liveness status may be tracked per interface. Thus the forwarding liveness of an interface may be treated as just another protocol. Consistent with the principles of the invention some embodiments may simply track forwarding liveness status yet have utility even without tracking any protocol status information.

APFL information processed as described above may be carried in a packet such as an Internet protocol IP packet. illustrates an exemplary data structure referred to as an APFL message which may be used to communicate protocol status information in a manner consistent with the principles of the invention. An APFL message may include one or more APFL packets. In one embodiment consistent with the principles of the invention APFL packets are IP version 4 or version 6 packets with a new protocol identifier. This new protocol identifier may be defined by a standard body such as the Internet Assigned Numbers Authority IANA . An alternative to defining a new IP protocol identifier for APFL is to use a user datagram protocol UDP header and a well defined port for APFL. Either of these techniques let a node receiving the packet know that the packet is carrying APFL information. Alternative techniques for accomplishing this are possible. Apart from the header the packet format may be identical for both IPv4 and IPv6. Packets are sent to one or more neighbors. When the neighbors are directly attached the source IP address is the sender s address on that interface if any. Otherwise the source IP address is the sender s router ID. The destination IP address is an ALL ALP ROUTERS multicast address defined by standards body by such as IANA or the ALL ROUTERS multicast address. When the APFL neighbor is not directly attached the IP source address is the sender s router ID and the destination address is a routable address belonging to the neighbor. The IP time to live TTL value should be set to 255 or some other predetermined value so that a receiving node can check that an APFL packet came from an adjacent node and not from a node multiple hops away.

In one exemplary embodiment all APFL packets contain a single APFL message and each APFL message may include a common header a message and extensions . The total length of the APFL message i.e. the sum of the lengths of all sections may be provided in common header . Each section may be zero padded so that its length is a multiple of four octets. Common header has a length of 12 octets. The length of message section may be fixed for each message type. The length of extensions section may be inferred as the length of the APFL message minus the lengths of the other sections and . It is expected that APFL messages will be small enough so as not to require fragmentation. However fragmentation and re assembly should be supported. Naturally the APFL information may be carried in ways other than the described APFL message in an APFL packet.

An exemplary format of common header has the following structure. An R bit indicates whether the APFL message is being sent to a directly attached node R 0 or to a remote node R 1 . A Version field 7 bits indicates an APFL version number. A Message Type field 8 bits may include the following values 

A Length field 16 bits indicates the combined lengths of common header message and extensions if any in octets. A Router ID field 32 bits is set to the sender s four octet router ID. APFL messages sent to directly attached neighbors R 0 are associated with an interface. If the interface is numbered i.e. configured with a unique IP address an Interface Index field 32 bits may be set to zero and the interface identified by the source IPv4 or IPv6 address in the IP header. Otherwise Interface Index field is set to the index allocated by the sending node for this interface and the source IP address is an address identifying the sender. For APFL messages sent to a node not directly attached R 1 Interface Index field is set to zero and the source IPv4 or IPv6 address is a routable address identifying the sending node.

An exemplary format of the message section has the following structure. A Session field 8 bits can be used to identify several independent APFL sessions between a pair of nodes. Dead Interval field 24 bits is specified in microseconds. A node sending a Hello with a Dead Interval of N tells its APFL neighbor node to consider all the protocols that the node is reporting on as dead if the neighbor node doesn t receive another Hello from the sending node in N microseconds. Recall e.g. and of . A Sequence Number field 64 bits is a monotonically increasing number with the first 4 octet word being the higher order word and the second being the lower order word. One possible implementation of sequence numbers is to use a 32 bit time of day in seconds for the first word and a monotonically increasing counter that resets to zero when the time of day changes for the second word. One use of Sequence Number field is to foil replay attacks in the context of some means of signing APFL messages. Providing Sequence Number in the Hello message might be less desirable if an alternative security mechanism is provided. A Protocol Registry field is a 32 bit vector that indicates the protocols for which liveness reports will be sent in Hello messages. Recall e.g. of . The semantics for the bit positions bit being the Most Significant Bit of an exemplary Protocol Registry field are as follows 

Notice that the forwarding liveness of an interface i.e. the ability of a node to forward packets received on that interface to other interfaces or to forward packets received on other interfaces to that interface may be indicated consistent with the principles of the invention. Forwarding liveness may include the ability to receive and process packets from an interface the integrity and correct operation of forwarding route lookup tables and the ability to rewrite and send packets on the interface.

Although message segment data structure is compact and permits a short simple message the use of separate a protocol registry field and a separate protocol status field conveys three states i not reporting ii reporting and up and iii reporting and down for each protocol using two bits. In an alternative embodiment two bits are provided per protocol to indicate one of four not only three possible states. These four states are i not reporting ii reporting and up iii reporting and down iv reporting and up but in restart mode. This fourth state can be used with so called graceful restart techniques such as those described in U.S. patent application Ser. No. 10 095 000 entitled GRACEFUL RESTART FOR USE IN NODES EMPLOYING LABEL SWITCHED PATH SIGNALING PROTOCOLS filed on Mar. 11 2002 and listing Kireeti Kompella Manoj Leelanivas Ping Pan and Yakov Rekhter as inventors incorporated herein by reference . More specifically under some graceful restart techniques a protocol may restart but the node may continue forwarding data using existing forwarding information. If the restart of the protocol is not complete within a certain time however the forwarding information may be considered too stale to be used. The fact that a node is restarting is known by a peer e.g. an adjacent node but is generally not distributed beyond peers so that the rest of the network is not aware that a node is restarting. This prevents a large number of nodes from updating network topology information re computing routes and re computing forwarding information when doing so may be unnecessary.

An exemplary format of extensions section includes a list of type length value TLV triplets. Each TLV may include a Flags field a Type field a Length field and a Value field . Each message type defines the set of types it supports in Type field . That is the message is parsed first in order to interpret Type. Each type defines its own flags found in Flags field . That is Type field is parsed first in order to interpret Flags field . Length field indicates the length of Value field in octets. Value field is padded with octets of zero so that the total length of TLV is a multiple of four octets.

Extensions section can have multiple TLV fields. If parsing the TLVs occurs beyond the end of message as defined by Length field in common header it is assumed that the APFL message has been corrupted and is to be discarded. Recall e.g. of 

Although the APFL packet and APFL message may be used to carry APFL information alternatives are possible. Such alternatives may convey the status of multiple protocols in a compact form. In yet another alternative the information may include interface forwarding liveness status information without any protocol status information. In at least one embodiment interface forwarding liveness status information may only convey whether the interface can forward data or not. In another embodiment interface forwarding liveness status information may convey additional information such as i the integrity and correct operation of forwarding route lookup tables ii the integrity and correct operation of switch fabric iii the integrity and correct operation of a forwarding lookup engine iv the integrity and correct operation of a traffic scheduler v the integrity and correct operation of a traffic flow classifier vi the integrity and correct operation of buffers in the data plane vii the integrity and correct operation of packet segmentation modules viii the integrity and correct operation of packet reassembly modules ix the integrity and correct operation of packet re sequencing modules x whether or not a node is restarting xi whether or not the forwarding plane is congested xii the integrity and correct operation of fragmentation modules xiii bit error rate at a link interface xiv clock synchronization at a link interface and or xv various quantitative values reflecting some quality of forwarding or qualitative information derived therefrom. Alternatively or in addition interface forwarding liveness status information may convey when a data plane component is operating in a particular manner such as at a predetermined capacity e.g. buffers 75 full N packets outstanding the switch fabric etc. Additional bits may be used to convey quantitative forwarding plane status information. Alternatively or in addition forwarding liveness status information may convey whether or not a link terminated by the interface can forward data or whether or not the link can forward data under certain conditions.

Recall from of that received APFL information is checked against stored neighbor APFL information. Further recall from and of that such neighbor APFL information may be updated based on the expiration of a lost hello timer or based on newly received APFL information. illustrates an exemplary data structure which may be used to store neighbor or peer information in a manner consistent with the principles of the invention. The neighbor or peer information may include a number of entries. Each entry may include a session field for storing session information a neighbor node identifier field for storing router ID information an interface index field for storing interface index information a last received sequence field for storing sequence number information from the last received APFL message a last received protocol registration field for storing protocol registry information from the last received APFL message a last received protocol status field for storing protocol status information from a last received APFL message and a lost hellos timer field for storing the dead interval in the last received or newest APFL message.

Machine may be a router for example. In an exemplary router processor may include a microprocessor a network processor e.g. custom integrated circuits or any combination of these. In the exemplary router storage device may include one or more ROM RAM SDRAM SRAM SSRAM DRAM flash drive hard disk drive flash card other types of memory or any combination of these. Storage device may include program instructions defining an operating system OS a protocol module e.g. daemon other modules or any combination of these. In one embodiment methods of the invention may be performed by processor executing stored program instructions e.g. defining a part of the protocol module or daemon . At least a portion of the machine executable instructions may be stored temporarily or more permanently on storage device may be received from an external source via an input output interface unit or both. Finally in the exemplary router input output interface unit input device and output device may include interfaces to terminate communications links.

Operations consistent with the principles of the invention may be performed on systems other than routers. Such other systems may employ different hardware different software or both. Exemplary machine may include other elements in addition to or in place of the elements listed in without departing from the principles of the invention. For example there could be one or more additional processors input devices storage devices etc. The components may be included on a single unit or may be distributed over more than one unit.

Recall from that each of a number of protocol operations may employ check status operations down callback operations and up callback operations for purposes of hooking APFL operations with the protocols . Basically one or more of protocol operations may provide its status to APFL operations Recall e.g. of and receive information about the status of each of its peers from APFL operations Recall e.g. and of .

In one embodiment of the invention each of operations take two arguments the protocol P and the APFL neighbor Y. One exemplary status check operation Status Check P Y normally returns up regardless of the current state of protocol P s adjacency with Y. Status Check P Y only returns down when protocol P is not configured to run with neighbor Y or if P is planning to go down shortly graceful shutdown . If protocol P doesn t respond in a timely fashion to the Status Check query APFL operations may declare the status of protocol P as down. In one exemplary down callback operations a call Down P Y should be treated by protocol P as if its regular hellos if any timed out. In one exemplary up callback operations a call Up P Y is generally ignored. The following sections provide protocol specific details that may be implemented.

BGP should treat a Down BGP Y callback just as if the Hold Timer of the session with neighbor Y had expired See Section 6.5 of Rekhter Y. and T. Li Editors A Border Gateway Protocol 4 BGP 4 1771 March 1995 incorporated herein by reference . Following a Down BGP Y call BGP may re establish peers as usual. BGP should ignore Up BGP Y callbacks.

IS IS OSPF v2 and OSPF v3 should treat a Down P Y callback where P is one of IS IS OSPFv2 or OSPFv3 just as they would loss of hellos from neighbor Y. Following a Down P Y callback IS IS OSPF v2 and OSPF v3 should re establish adjacencies as usual. IS IS OSPF v2 and OSPF v3 should ignore Up callbacks.

RIP should respond to a Down P Y callback where P is one of RIPv1 RIPv2 or RIP ng by immediately deleting all RIP routes received from Y as if the timeout timer in Section 3.8 of Malkin G. RIP Version 2 STD 56 2453 November 1998 or section 2.3 of Malkin G. RIPng for IPv62080 January 1997 both incorporated herein by reference expired for all those routes. RIP should ignore Up callbacks.

RSVP should respond to a Down RSVP Y callback just as it would loss of hellos from neighbor Y or some other indication that either Y or the interface to Y is no longer working. Following a Down RSVP Y callback RSVP should attempt to re establish the state that it had held for neighbor Y by following its normal protocol operation. RSVP should ignore Up callbacks.

As described earlier APFL can be used to communicate to a neighbor one s ability to forward packets from or to a given interface and to learn about a neighbor s ability for the same. An interface receiving a Down P Y callback where P is forwarding liveness should inform all modules such as routing protocols interested in the forwarding capability status of neighbor Y that Y is no longer capable of forwarding packets received over the communication link attached to that interface. An interface receiving an Up P Y callback should inform the modules interested in the forwarding capability status of neighbor Y that Y can forward packets received over the communication link attached to that interface.

Without any protocols registered APFL operations can act as an interface liveness protocol for interfaces. Thus the principles of the invention may be applied to test the liveness of interfaces that don t have layer 2 liveness mechanisms such as Ethernet and other interfaces whose layer 2 liveness mechanisms may be considered too slow for some purposes such as the point to point protocol PPP for example. Recall from that each of a number of interface operations may employ check status operations down callback operations and up callback operations for purposes of hooking aggregated liveness determination operations with the interfaces .

For PPP interfaces a Down Layer 2 Y callback should be ignored unless the PPP is in state 9 opened for the interface. If the Down callback is received while in state 9 the following actions should be taken i declare This Layer Down ii send a Configure Request and iii transition to state 6 in the notation of Section 4.1 of Simpson W. Editor The Point to Point Protocol PPP STD 51 1661 July 1994 incorporated herein by reference. Up Layer 2 Y callbacks should be ignored on PPP interfaces.

Ethernet interfaces are a bit more complicated since they are multipoint interfaces. A Down Layer 2 Y callback should tell all modules interested in the layer 2 status of the interface such as routing protocols SNMP agents etc. that neighbor Y is no longer reachable and appropriate action should be taken. For example a routing protocol may recompute routing information to no longer use this interface. An implementation may declare that the Ethernet interface is itself down however this behavior should be configurable. An Up Layer 2 Y callback should tell all modules that neighbor Y is again reachable or that the Ethernet interface is up .

Although forwarding liveness can be thought of as a protocol to be included in the protocol registration and status bit vectors interface forwarding liveness status may be tracked and communicated independently of protocol status information. Such interface forwarding liveness status information may be used to communicate to a neighbor one s ability to forward packets from or to a given interface and to learn about a neighbor s ability for the same. As was the case when this forwarding liveness status information is included with status information of protocols an interface receiving a Down P Y callback where P is forwarding liveness should inform all modules such as routing protocols interested in the forwarding capability status of neighbor Y that Y is no longer capable of forwarding packets received over the communication link attached to that interface. An interface receiving an Up P Y callback should inform the modules interested in the forwarding capability status of neighbor Y that Y can forward packets received over the communication link attached to that interface.

Recall from that configuration operations may be used to set a hello interface a dead interval neighbor node pair and protocols interfaces or both using the aggregated liveness determination operations . In one exemplary implementation of the invention the number of Hellos sent every Dead Interval is limited. This limit should override any of what follows. Also the Hello Interval time and Dead Interval can be set subject to some minimum limits. For example in some implementations although Hello Intervals and Dead Intervals may defined in microseconds it may be desirable to set minimum limits of about 100 milliseconds at least until there is sufficient operational experience to indicate that smaller intervals e.g. 10 milliseconds are scalable for the particular application in which the invention is used. One useful consequence of APFL operations is that the times of normal hellos that is hellos still used by the underlying protocols can be made longer. The hello time should be no longer than the dead interval and may be one third one fourth or less of the dead time interval.

If the Hello Interval or Dead Interval change APFL operations may issue a Hello before hello timer T expires. If the protocols interfaces using aggregated liveness to be reported on are changed such that the new set of protocols interfaces or both to be reported on is a superset of the old APFL operations may issue a Hello before hello timer T expires. However if there is any other change in the protocols interfaces using aggregated liveness to be reported on APFL operations should issue a Hello as soon as is reasonable. Moreover multiple copies of this Hello should be issued to improve the chances of the neighbors receiving it correctly.

Configuration operations should also permit authorized users to turn off reporting on any given protocol. Configuration operations may also allow users to turn off running APFL operations over any given interface or to any given neighbor node.

If APFL operations can register to be notified by a protocol when the protocol s status changes on receiving such a notification with a status transition from up to down APFL operations should rebuild the Hello with the latest values and send it out as soon as is reasonable. If the status transition is down to up APFL operations may rebuild and send out a Hello before the timer T expires.

 4.2.8 Aggregating Protocol Liveness Determinations with Protocols Supporting and or Running Graceful Restart

Graceful Restart See e.g. Sangli S. Y. Rekhter R. Fernando J. Scudder and E. Chen Graceful Restart Mechanism for BGP work in progress Berger L. Editor Generalized Multi Protocol Label Switching GMPLS Signaling Resource ReserVation Protocol Traffic Engineering RSVP TE Extensions RFC 3473 Shand M. Restart signaling for ISIS work in progress. Leelanivas M. Y. Rekhter and R. Aggarwal Graceful Restart Mechanism for LDP work in progress Farrel A. Editor Fault Tolerance for the Label Distribution Protocol LDP work in progress and Moy J. P. Pillay Esnault and A. Lindem Hitless OSPF Restart work in progress all incorporated herein by reference also known as Hitless Restart allows a protocol to restart while leaving the forwarding path undisturbed. If a node X and its neighbors can restart gracefully it is not quite as urgent for X s neighbors to learn when X goes down. However the principles of the invention can be used to assist the graceful restart process by for example pinpointing the time that the restarting protocol of node X goes down more accurately. This information can be used for example to begin restart procedures and to permit more precise estimates of when to declare that the protocol restarting on node X is beyond recovery.

APFL messages should be authenticated because spoofing or replaying APFL messages may deceive a router about the state of all its protocol peers. Encrypting the contents of APFL messages is not as important although doing so may be useful in certain applications. In any event since the invention mainly serves to provide more frequent liveness information e.g. via more frequent hellos a part of which is achieved by minimizing processing overhead adding strong authentication systems may impose severe processing burdens.

In the following example it is assumed that liveness operations on node A sends liveness information about protocols S and T to node B . Thus node A acts as a sender and node B acts as a receiver. Of course when node B acts as a sender node A will act as the receiver. It is assumed that the liveness operation can access the protocol status of the protocols and interfaces that it has been configured to report on as well as report back to the protocols any received change of state.

Recall that the left branch of illustrated an exemplary implementation of APFL sender processing. Suppose liveness operation is configured to run with neighbor node B with Dead Interval D microseconds Hello Time H microseconds and to report on protocols S T . . . . Note that H is local to a node this value is not transmitted to APFL neighbors. Also H should be at most D. Typically however H would be D 3 or D 4. Node B is a directly attached neighbor to node A as indicated by interface A B . In this example an exemplary implementation consistent with the principles of the invention may operate as follows.

 Step 1 Liveness operation creates a Common Header with R field set to 0 if node B is directly attached else 1. Version field is set to 1. Length field is set to 28. Message Type field is set to 1 Hello . Interface Index field is set to . Common Header will not change unless the interface index of interface A B changes.

 Step 2 Liveness operation creates a protocol registry vector PRV that consists of the bits corresponding to the configured protocols S T . . . set and the leaves the rest unset. Liveness operation queries each configured protocol for its status with neighbor node B and creates a protocol status vector PSV. Finally liveness operation creates a Hello message with Session field set to 0 Dead Interval field set to D Sequence Number field set to protocol registry field set to PRV protocol status field set to PSV builds an APFL packet with common header and Hello message and sends it to the ALL APL ROUTERS multicast address. Recall e.g. the left branch in . 

 Step 3 Liveness operation then sets a timer T to expire in H microseconds and goes to sleep Recall e.g. of . When timer T expires liveness operation goes back to Step 1. Every time liveness operation sends a Hello it restarts the timer T with the latest value of H .

Recall that the middle and right branches of illustrated an exemplary implementation of APLF receiver processing. In the following it is assumed that liveness operation receives an APFL message from node B . Liveness operation maintains a table of APFL neighbors keyed by and that contains.

 Step 1 Identify the APFL neighbor B by looking up the key in a table. Recall e.g. of . If no entry is found liveness operation may either discard the packet or create a new entry for the key with initial values as in the table above. Recall e.g. of . 

 Step 2 Liveness operation may then check that the received Sequence Number is larger than the Last Received Sequence Number for this key Recall e.g. of . If not it discards the packet Recall e.g. . Otherwise it updates Last Received Sequence Number sets New Registry to the received Protocol Registry and sets New Status to the received protocol status.

 Step 3 If New Registry Last Received Protocol Registry go to Step 4 below. Otherwise for each protocol P that is in New Registry and not in Last Received Protocol Registry added protocol 

 Recall e.g. loop of . For each protocol P that is in Last Received Protocol Registry and not in New Registry deleted protocol 

 Step 5 Set Last Received Sequence Number received Sequence Number Last Received Protocol Registry New Registry. Recall of 

If the Lost Hello Timer fires call Down P B for each protocol P that is set in Last Received Protocol Registry for node B Recall e.g. loop of and stop the timer. Recall e.g. of 

Down P B invokes protocol P s Down callback and sets Last Received Protocol Status P to down. Up P B invokes protocol P s Up Callback. The number of times this callback is actually propagated to the protocol should be subject to some maximum limit. If Up P B is sent to protocol P then liveness operation sets Last Received Protocol Status P to up.

As can be appreciated from the foregoing disclosure the principles of the invention may comprise elements apparatus systems data structures computer implemented code and methods for permitting the liveness of various protocols to be determined quickly in a scalable manner e.g. in terms of message size total message frequency and processing overhead . By providing a small number of bits per protocol which relay a simple set of information such as up down not reporting restarting etc. a compact simple message may be used for conveying liveness related information. Since the messages are small and can aggregate information from more than one protocol they can be sent frequently. Normal operations of the protocols such as normal hellos are not affected but may be relaxed i.e. run less frequently . Moreover the APFL messages and processing of such messages are not subject to the constraints of the protocols being monitored. Furthermore interface forwarding liveness status information may be included with the protocol status information or may be provided independent of protocol status information.

The foregoing description of embodiments consistent with the principles of the invention provides illustration and description but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. For example although a series of acts may have been described with reference to a flow diagram the order of acts may differ in other implementations when the performance of one act is not dependent on the completion of another act. Further non dependent acts may be performed in parallel.

No element act or instruction used in the description should be construed as critical or essential to the invention unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. The scope of the invention is defined by the claims and their equivalents.

