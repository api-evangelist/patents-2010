---

title: Presenting availability statuses of synchronized objects
abstract: The objects of an on object set may be synchronized across many clients (e.g., various devices may synchronize files of a mirrored filesystem). However, the synchronization of an object may be complicated, and an object may not yet be synchronized in the object set of a client for many reasons, such as an incomplete reception of the object, an unavailability of the object from currently reachable hosts, and a versioning conflict with a different version of the same object in the object set. In order to inform a user of the availability of an object in the object set, an analysis of the availability status of the object may be performed (e.g., by tracking metadata stored in object descriptors of respective objects of the object set, and later examining the metadata of respective objects), and a selected availability status may be presented to the user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09560130&OS=09560130&RS=09560130
owner: Microsoft Technology Licensing, LLC
number: 09560130
owner_city: Redmond
owner_country: US
publication_date: 20100930
---
Within the field of computing many scenarios involve a synchronization of objects in an object set such as files in a filesystem records in a database or email messages in an email mailbox. Synchronization may be utilized e.g. to promote uniformity among multiple copies of the object set such as filesystems on multiple devices storing a mirrored set of files or records in a redundantly deployed database. Some such object sets may be centrally managed among a set of distributed clients such as a set of devices comprising a mesh that is managed by a mesh host that stores a canonical descriptor of the object set e.g. a master copy of a data structure identifying the objects in the object set and the locations thereof that directs the synchronization of objects among the clients e.g. when a first client creates a new object in the object set the mesh host may notify other clients storing the portion of the object set of the existence of the new object and may facilitate the transmission of the object from the first client to the other clients and or that mediates versioning conflicts e.g. by evaluating multiple versions of an object to determine priority and select an authoritative version of the object .

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Within scenarios involving a synchronized object set the synchronization of a particular object may be a comparatively complex process. For example an object may not yet exist in a synchronized state for many reasons. For example the object may be in the process of being received from a remote device may have been fully received but may be awaiting the completion of a processing task such as an integrity check a virus scan or a release of a lock on a prior version of the object or may have encountered a versioning conflict with a different version of the object already existing in the object set. This complexity may be frustrating for a user who may be unable to determine why a particular object does not exist in a synchronized state on a particular client. For example a file may exist in a filesystem of a first device but may not exist in the filesystem of a second device mirroring the filesystem because it may be in transmission because the second device cannot contact the first device or because a lock or versioning conflict is obstructing the relocation of a fully received version of the file to the proper location in the filesystem of the second device.

Presented herein are techniques for promoting the presentation to a user of the status of an object in an object set that is synchronized among two or more clients such as synchronization services operating on two or more devices connected via a network . These techniques involve an analysis of the status of an object in view of a range of possible synchronization states. When a user requests information about synchronization state of an object the client may evaluate the object to determine its state and may present to the user an informative availability status such as an available status a searching status a receiving status a relocating status and a lost status. In some embodiments this evaluation may be facilitated through the tracking of metadata for respective objects in the object set such as the storage of availability status information in an object descriptor representing an object. The availability status may be updated in response to various events e.g. identifying and contacting one or more clients hosting an object receiving a portion of the object from a host receiving the final portion that completes the object and moving the object to a canonical position in the object set and this metadata may be utilized to identify and inform the user of the reason for the synchronization state of the object.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

Within the field of computing many scenarios involve a synchronized object set comprising a set of objects wherein two or more clients each store at least a portion of the object set e.g. a subset of objects and wherein an addition or change to one or more objects by a first client results in an automated propagation of such new or updated objects to the other clients. For example two devices may each store identical copies of a filesystem and when one device adds modifies or deletes an object the filesystem of the other device is automatically updated to reflect the changes to the filesystem. This synchronization may be performed e.g. by a synchronization service operating on each device that sends notification of changes to corresponding synchronization services operating on the other device s and that upon receiving such a notification of a change on another device negotiates to receive and apply appropriate data to update the locally stored version of the object set.

The synchronization of objects in an object set may be useful in many scenarios. For example the computing environment of a user may include a set of applications such as an operating system an office productivity suite a web browser an email client and one or more media applications a set of media objects e.g. photos music and movies and a set of documents and other files created acquired altered and or consumed by the user. The computing environment may also include other types of data and computing concepts that may be useful to the user such as configuration settings of one or more applications bookmarks of various locations on a network such as the internet that may be of interest to the user security credentials such as authenticating certificates that may be used by the user to assert his or her identity or to verify the identity of another individual or cryptographic keys that may be used to exchange encrypted data with other users and with security oriented websites. The computing environment may also involve various concepts such as a set of one or more users having access to the computer environment and or ownership of data or objects and a representation of one or more devices that may be operated by the user e.g. a workstation device holding a filesystem a portable computer such as a notebook that stores a mirrored portion of the same filesystem and a cellphone device and a portable music player that each store a portion of the filesystem relevant to the capabilities of each device . In order to facilitate this computing environment an object set may be devised that represents a broad and diverse set of objects such as files data objects database records email mailboxes applications application settings of various applications contacts in an address book user accounts of various users devices through which the computing environment may be accessed bookmarks identity authentication credentials cryptographic keys etc. All of these diverse types of objects may be modeled in an object set and relevant portions of the object set may be deployed to various devices through which the user accesses the computing environment e.g. a mesh of devices . This scenario may promote a uniform computing environment across devices. As a first example a device may be aware of all other devices of the mesh of the user that are represented in the computing environment and may be able to communicate therewith in a convenient manner. Moreover if each device is configured to utilize the same object set a more uniform computing experience may be achieved across devices e.g. each device provide access to the same set of applications configured in the same manner and exposes the same set of user accessible data objects.

However within this and other scenarios involving a synchronization of objects in an object set the synchronization of a particular object may be a comparatively complex process. While it may be desirable to present a user with a set of objects that are fully synchronized the complexities of the synchronization process may delay the discovery of some objects or changes thereto or the receipt of discovered objects upon a particular device. For example when an object is created on a first device in the computing environment e.g. the mesh of devices operated by a user the first device may have to notify the object server and may then have to transmit the object to the object server over a network which may be low bandwidth or intermittent . The object server may then have to notify a second device represented in the computing environment of the creation of the object . This notification may not occur promptly e.g. the object server may only periodically notify devices of changes to the object set in order to economize network and computing resources. Additionally the object server may have to transmit the object to the second device and again this transmission may also occur over a low bandwidth or intermittent network . Alternatively the object may simply be represented within the computing environment but the object server may indicate to the second device that the object is stored on the first device and the second device may promptly or in an ad hoc manner e.g. when the object is used by the user endeavor to contact the first device to retrieve the object . Moreover the second device may receive the object in a temporary data area such as a working folder of a filesystem and may have to process the received object e.g. by verifying the integrity of the object and or performing a malware scan on the object . Finally the second device may have to relocate the object from the temporary data area to a canonical location in the object set . Until this potentially lengthy process is completed the second device may not present the object in the object set or may present the object but may be unable to grant access to the object e.g. the object may appear as a file within the filesystem of the second device but the second device may be unable to allow the user to access the object until it is fully received and processed . For these and other reasons the synchronization of an object from a first device to a second device may not occur promptly and may involve a noticeable delay.

Additionally some complexities of this process may cause the synchronization to fail and or to necessitate the attention of the user to resolve particular issues. As a first example an object may exist on the first device but the second device may have difficulty contacting the first device over a network. This difficulty may arise e.g. due to firewall restrictions a network partitioning into a first network portion servicing the first device and a second network portion servicing the second device or a network disconnection of the first device . As a second example an object may exist on the first device but before the object may be fully received by the second device the representation of the first device may be removed from the object set such that the second device cannot contact the first device to retrieve the object . As a third example the second device may be able to contact the first device to request the object but the first device may be temporarily unable to send the object e.g. if the object is exclusively locked by a user of the first device and cannot be read for a while. As a fourth example the second device may fully retrieve the object but may upon attempting to relocate the object from a temporary data area to a canonical location in the object set e.g. to a location in a filesystem where the object is to exist the second device may find an existing object stored in the canonical location in a locked manner e.g. a file may be in use by a user such that the second device cannot overwrite the existing object with the newly received object . As a fifth example the second device may discover that the object cannot be relocated to the canonical location e.g. due to a lack of storage space or insufficient access e.g. the user may not have access privileges to write the object to the canonical location on the second device . As a sixth example the second device may fully retrieve the object in a particular version but upon attempting to relocate the object to the canonical location in the object set may find that an alternative version of the object already exists that causes a versioning conflict e.g. a first user may edit the object on the first device while a second user concurrently edits the object on the second device and the second device may be unable to determine which version of the object to keep without the intervention of the user. For these and other reasons the synchronization of an object may fail or may be unable to be completed in a safe manner without the involvement of the user.

In view of these complexities of the synchronization process it may be appreciated that the synchronization of a particular object may be delayed may fail and or may necessitate the intervention of the user. However it may be difficult for the user to determine the synchronization state of a particular object . For example the device may simply present to the user the currently existing set of fully synchronized objects and objects that are not yet fully synchronized may simply not be visible within the computing environment or may exist in older versions e.g. a first object version of an object may be presented to the user within the computing environment until a second object version is fully received and processed by the device . However the user may know that a particular object exists in the object set e.g. the object may be visible on another device or exists within a different version but the object or object version may not appear to the user within the computing environment of the device until the synchronization process is complete and the user may be unable to determine why this synchronization process has not yet completed. Additionally if the device is unable to complete the synchronization process e.g. due to a file lock the user may be unable to determine why the synchronization has not completed and may not be able to intervene to resolve the failure without this information. These deficiencies may lead to undesirable inconsistencies in the presentation of the object set across the devices of the mesh of the user.

As a third example of synchronization complexity illustrated in the exemplary scenario of the first object may have completed transmission from the first client to the third client which may have stored the first object in the data store and may have completed the processing of the first object . However when the third client endeavors to relocate the first object to its canonical location in the object set the third client may find that while the received first object exists in a particular version e.g. a version A an alternative version of the first object e.g. a version B exists at the canonical location. The third client may be unable to select which version has priority e.g. if version A was created by a first user while version B was created by a second user and a version conflict may therefore arise that cannot be resolved by the third client without the intervention of the user. As a fourth example the second object may have completed transmission from the first client to the third client which may have stored the second object in the data store and may have completed the processing of the second object . However when the third client endeavors to relocate the second object to its canonical location in the object set the third client may find that a previous version of the second object exists at the canonical location but is locked against writing. Even if the first object version of the second object may be safely overwritten with the second object version the third client may be unable to perform this overwriting due to the locking of the first object version of the objet at the canonical location resulting in a locked file failure .

For the reasons illustrated in the exemplary scenario of and various other reasons the synchronization of the objects may fail. However in all four cases the second client and the third client may be configured to present to the user only the objects and versions thereof for which synchronization has completed. The first object and the second object may therefore not appear to the user in the object sets of the second client and the third client or may appear as older versions of such objects and the user may be unable to determine the reasons for the inconsistently presented object sets among the clients of the computing environment.

Presented herein are techniques for presenting to a user an availability status of an object of an object set . These techniques involve evaluates the object to determine whether the object is available and has been fully synchronized and if not the reasons for the lack of synchronization. This evaluation may include an evaluation of the connection state and availability of other clients e.g. via a communication network or interprocess communication channel communication with the object server and or the state of the data store of the device hosting the client .

The availability statuses of various objects of the object set may then be presented to the user e.g. as a list or as a property of one or more selected objects.

Within this exemplary scenario of the user may request a presentation of the synchronization states of all objects stored by the device and synchronized with other clients or of a subset of these objects e.g. recently synchronized objects . The user may also specify a particular object or set of objects such as a particular file or a set of files comprising an application and may request the availability statuses thereof. In accordance with the techniques presented herein the client may perform an analysis of the object such as an examination of the object set to determine the availability of the object an examination of the data store to determine the presence of the object e.g. the receipt of an object that has not yet been fully processed and that is not yet available in the object set and the existence of a versioning conflict among two versions of the object . The analysis of the object may also include an examination of the object descriptor of the object which may include information relevant to the availability status of the object and that may not be determined by examining the object itself. This information may therefore be included in a presentation to the user of the availability statuses of the objects .

For example in the exemplary scenario of six objects are represented as existing in the object set . A first object may be available in the object set . The client may have received a notification of the existence of a second object but may be in the process of contacting another client that is storing the second object e.g. by sending to the other client a request to transmit the second object . A third object may be in the process of being transmitted from another client to the client e.g. over a network and although the client may not represent the third object as available in the object set the client may be storing the received portion of the third object in the data store e.g. in a temporary location where data from pending downloads may be temporarily stored . A fourth object may have been fully received by the client but may be in the process of being relocated to a canonical location in the object set e.g. a moving of data from a first storage device where the data of the fourth object was stored during transmission to a second storage device where the fourth object belongs according to the object set . A fifth object may have been fully received and may be stored in the data store but upon endeavoring to relocate the fifth object to a canonical location the client may have encountered a locking problem such as a presence of an earlier version of the fifth object at the canonical location that in use by the user and that therefore is locked against overwriting. Similarly a first object version of a sixth object e.g. version A may also have been fully received and may exist in the file store but upon endeavoring to move the sixth object to a canonical location in the object set the client may have encountered a versioning conflict such as the presence of an alternative version of the sixth object e.g. version B at the canonical location where the versioning priority of the different versions cannot be automatically determined. For example the user may have been modifying an initial version of the sixth object to generate the first object version while another user may have been modifying the initial version of the sixth object to generate the second object version. It may be difficult for the client to reconcile the concurrent changes and resulting versions of the sixth object in an automated manner particularly if such changes are mutually exclusive e.g. where the first object version alters a paragraph of a document and the second object version deletes the paragraph .

In this exemplary scenario and in accordance with the techniques presented herein the client may present the availability statuses of respective objects by examining various factors of the object that are determinant of the availability status . For example the client may examine the availability of the object in the data store and or the object set the representation in the computing environment of one or more clients storing the object and whether or not the object is currently being received from one or more hosts. The client may also determine whether various conflicts exist such as a locking conflict or a versioning conflict. In some such embodiments and in this exemplary scenario the client may monitor events that are associated with these availability statuses for respective objects and upon detecting such an event for an object may store corresponding information in the object descriptor of the object . When the user requests the availability status of one or more objects the client may examine the object descriptors of the objects in addition to other properties of the object in order to determine the availability statuses . The client may then generate a presentation for the user featuring the availability statuses . In this manner the client may fulfill the query of the user which may satisfy the curiosity of the user allow the user to anticipate the availability of an object and or resolve conflicts that may interfere with the availability of an object .

Still another embodiment involves a computer readable medium comprising processor executable instructions configured to apply the techniques presented herein. An exemplary computer readable medium that may be devised in these ways is illustrated in wherein the implementation comprises a computer readable medium e.g. a CD R DVD R or a platter of a hard disk drive on which is encoded computer readable data . This computer readable data in turn comprises a set of computer instructions configured to operate according to the principles set forth herein. In one such embodiment the processor executable instructions may be configured to perform a method of presenting a user an availability status of objects in an object set such as the exemplary method of . In another such embodiment the processor executable instructions may be configured to implement a system for presenting a user an availability status of objects in an object set such as the exemplary system of . Some embodiments of this computer readable medium may comprise a non transitory computer readable storage medium e.g. a hard disk drive an optical disc or a flash memory device that is configured to store processor executable instructions configured in this manner. Many such computer readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.

The techniques discussed herein may be devised with variations in many aspects and some variations may present additional advantages and or reduce disadvantages with respect to other variations of these and other techniques. Moreover some variations may be implemented in combination and some combinations may feature additional advantages and or reduced disadvantages through synergistic cooperation. The variations may be incorporated in various embodiments e.g. the exemplary method of and the exemplary system of to confer individual and or synergistic advantages upon such embodiments.

A first aspect that may vary among embodiments of these techniques relates to the scenarios wherein such techniques may be utilized. presents a first exemplary scenario wherein these techniques may be utilized to present the synchronization and availability of objects in an object set managed by an object server among a set of devices comprising a mesh. Such devices may communicate exclusively with the object server or with each other in a client server protocol and or a peer to peer exchange protocol. However other scenarios may also be suitable for application of the techniques presented herein. For example the techniques may utilized to present the availability of objects synchronized among two or more devices without an object server such as objects shared over a peer to peer exchange protocol or objects stored by a first client that are mirrored by one or more other clients e.g. in a redundant data storage or file service scenario . As a second example the availability of many types of object may be presented in this manner including files in a filesystem database records in a distributed and or mirrored database object oriented objects in an object system such as CORBA and email messages in an email sharing system. As a third example many types of clients may be involved in such synchronization including a hardware driver configured to manage the data store an operating system component configured to manage the synchronization of objects or an application configured to mange and or present synchronized objects in the object set . Such clients may also include multiple software processes operating on the same device . As a fourth example the objects may be synchronized among clients through many types of networks including a device to device communication channel such as an infrared communication channel a wired or wireless local area network a personal area network such as a Bluetooth network a regional network such as a cellular network a wide area network such as the internet a virtual network among two or more clients an interprocess communication channel and a hardware bus. Those of ordinary skill in the art may devise many scenarios wherein the techniques presented herein may be utilized.

A second aspect that may vary among embodiments of these techniques relates to the types of availability statuses that may be presented. In accordance with several embodiments of these techniques a client may be configured to send availability statuses including an available status a relocating status a requesting status and a receiving status. However some embodiments may also be configured to detect additional availability statuses of various objects that may provide additional details about an object which may facilitate the user in determining when an object may become available why the object is not currently available and or actions that may be taken to alleviate the unavailability of the object . As a first example the requesting status of an object may include additional details about the requesting of the object . For instance a client may determine that an object is stored on a host represented within the computing environment e.g. a device that is represented within a mesh of devices operated by the user and may therefore present a requesting status as a searching status indicating that the client is searching for the host . Alternatively or additionally a client may determine that no host within he computing environment stores the object and may therefore present to the user a lost status indicating that the object is only available from one or more hosts that have been removed from the mesh. Moreover in an additional embodiment a searching status indicating that an object is available from at least one host represented in the computing environment may indicate the progress of the client in contacting the host . For instance upon determining that the hosts storing the object are unreachable e.g. are represented within the mesh but are not currently accessible such as due to a network disconnection or a powered down device the client may present to the user a host unavailable status but if at least one host is reachable e.g. via a communication network the client may present to the user a host connecting status indicating that the client is endeavoring to connect to the host .

As a second example of this second aspect an embodiment of these techniques may be configured to detect various types of conflicts that interfere with the relocation of the object . A first such conflict involves a locking conflict. For example an object exists in the object set as a first object version and a superseding object version of the object may have been fully received and stored in the data store but when the client endeavors to relocate the superseding object version of the object to the object set by overwriting the first object version the client may discover that the first object version has been locked against overwriting e.g. the user may be viewing the first object version such as the locked file failure in the exemplary scenario of . This locking conflict may interfere with the deployment of the subsequent object version of the object to the object set but the user may not understand the nature of this interference. Therefore upon detecting a locking conflict for an object for which an availability status has been requested by the user the client may present to the user a locking conflict status. A second such conflict involves a versioning conflict wherein the object exists in the object set as a first object version and wherein a second object version object of the object is received and stored in the data store but where the client cannot automatically determine which object version of the object supersedes the other object version such as in the version conflict in the exemplary scenario of . Accordingly this version conflict may interfere with the deployment of the second object version of the object to the object set which the user may regard as a superseding object version but which the client may be unable to resolve automatically and the user may not understand the nature of this interference. Therefore upon detecting a versioning conflict for an object for which an availability status has been requested by the user the client may present to the user a versioning conflict status. Those of ordinary skill in the art may devise many types of availability statuses describing an object of the object set while implementing the techniques presented herein.

A third aspect that may vary among embodiments of these techniques relates to the manner of evaluating the object to select an accurate availability status . Some embodiments of these techniques may perform the evaluation entirely on an ad hoc basis e.g. by fully examining all of the causes relating to the availability of each object and reporting corresponding availability statuses . However this evaluation may be complicated so such embodiments may be undesirably slow particularly if the availability statuses of many objects may be requested. Therefore instead of a fully ad hoc evaluation of the availability of respective objects embodiments of these techniques may be configured to detect events relating to the availability of respective objects during the ordinary operation of the client to record the occurrence of such events for respective objects and to use the recorded information to expedite the evaluation of availability of the objects in response to a subsequently received request to report the availability statuses thereof. For example for respective objects of the object set an embodiment may store an object descriptor featuring at least one object metadatum relating to the availability of the object e.g. an array of flags that may be set or cleared for the object based on the detection of various events affecting the availability of the object . The embodiment may utilize these object metadata to detect some or all aspects of the availability status of the object . In different embodiments of these techniques these object metadata may be sufficiently informative to identify any availability status of the object such that the evaluation of the availability of the object may be entirely performed based on the object descriptor of the object while in other embodiments the examination of the object descriptor may be combined with other evaluative techniques to identify the availability status of the object .

A first example of this third aspect relates to scenarios involving an object server that manages the availability of objects on the client e.g. a mesh host that manages the availability of an object set among a set of devices . In such scenarios the object server may be configured to send an object descriptor to the client when an object or a new version of an existing object is created in the object set either by the same client or by another client . The object descriptor may indicate e.g. the canonical location of the object one or more hosts that may be storing the object e.g. one or more devices in a mesh that may currently store the object integrity checking information relating to the object such as a hashcode and or versioning information for the object that may be helpful in detecting and or resolving versioning conflicts. Moreover the object server may send the object descriptor to the client upon detecting the creation of the object even if the object has not yet been transmitted to the client and or the object server and the transmission of the object or object version thereof to the client may be subsequently initiated e.g. when the client has idle processing time and or spare bandwidth or when the object is accessed by a user . The client may therefore be configured to upon receiving an object descriptor from the object server store the object descriptor in the data store .

Several variations of this first example of this third aspect may be devised. In a first such variation various events relating to the receipt of an object as directed by the object server may be detected and stored in the object descriptor and later used to identify an accurate availability status of the object . For example the client may receive from the object server an object descriptor of an object that is unavailable in the data store and where the object descriptor identifies at least one host that is storing the object . An embodiment may be configured to upon receiving the object descriptor request the object from one or more hosts and store a requesting metadatum in the object descriptor . Upon receiving at least one object portion of the object from a host the embodiment may be configured to replace the requesting metadatum in the object descriptor of the object with a receiving metadatum indicating that the object is currently being received. These metadata may then be used to determine the availability status of the object upon request of a user e.g. upon identifying the object as unavailable in the data store the embodiment may determine whether or not the object is currently being received from at least one host by identifying in the object descriptor of the object respectively a receiving metadatum or a requesting metadatum. As a further level of detail in the determination of availability statuses the requesting of the object from a host may involve upon first receiving the object descriptor from the object server endeavor to contact at least one host and may concurrently store a searching metadatum in the object descriptor indicating that the client is searching for a host but has not yet succeeded in requesting the object from a host and upon contacting at least one host and requesting the object from the host the embodiment may replace the searching metadatum in the object descriptor with a requesting metadatum. Accordingly if the availability status of the object is requested in the interim the embodiment may be configured to upon identifying a searching metadatum in the object descriptor of an object for which an availability status has been requested present to the user a searching status indicating that the client is searching for one or more hosts from which to request the object .

As a second variation of this first example of this third aspect the object descriptor may store information relating to the accessibility of hosts storing an object . For example when a host is removed from the object set e.g. when a device is removed from a mesh the object server may be configured to send the clients a host removal notification. Upon receiving such a notification an embodiment of these techniques may be configured to identify objects in the object set that are unavailable in the data store and that are no longer stored by any host represented in the object set . For such objects the embodiment may store in the object descriptor of the object a lost metadatum indicating that the object is no longer available and upon identifying a lost metadatum in the object descriptor of an object for which an availability status has been requested the embodiment may present to the user a lost status.

A third variation of this first example of this third aspect relates to the particular scenario of false negative results that may arise within the synchronization scenario. In some scenarios a new or updated object version of an object may be reported as unavailable until being receiving the object or object version from a host but where the object or object version is in fact already available in the object set . This scenario may arise e.g. where a user synchronizes an object independently of the client such as by copying a new or updated version of an object to the data store at the canonical location of the object within the object set outside the synchronization process such that the synchronization process is not informed of the copying and availability. Thus the client may subsequently receive an object descriptor for the object from the object server and may continue to report the object as unavailable until receipt. In accordance with this third variation such inaccuracies may be reduced by verifying each object descriptor upon receipt such as by checking the availability of the object in the object set before reporting the object as unavailable. Moreover until an object descriptor is verified the object or updated object version may be ignored by the client . Accordingly an embodiment of these techniques may be configured to upon receiving an object descriptor of an object from the object server store in the object descriptor of the object an unverified object metadatum indicating that the object descriptor has not yet been verified. Upon subsequently verifying that the object is unavailable in the data store the embodiment may replace the unverified object metadatum in the object descriptor of the object with an unavailable metadatum but upon determining the object is available in the data store the embodiment may replace the unverified object metadatum in the object descriptor of the object with an available metadatum. However if an availability status of the object is requested in the interim the embodiment may simply disregard the existence of unverified object descriptors and may report that the object or object version does not exist in the file system. In this manner an inaccurate reporting of unavailability of objects within the object set may be reduced by verifying the object descriptors upon receipt and by ignoring such object descriptors in the interim.

A second example of this third aspect relates to the manner of using the object descriptors of objects to identify various availability statuses such as a requesting status a receiving status and an available status. For example an embodiment of these techniques may be configured to upon receiving an object descriptor of an object store in the object descriptor of the object a requesting metadatum. The embodiment may be further configured to upon receiving an object portion of an object for which at least one missing object portion is still missing e.g. where the object has been only partially received replace the searching metadatum in the object descriptor of the object with a receiving metadatum and upon receiving an object portion of an object having no missing object portions e.g. a fully received object replace the receiving metadatum in the object descriptor of the object with an available metadatum. The embodiment may also be configured to evaluate the availability status of the object as receiving requesting or available by detecting in the object descriptor of the object respectively a receiving metadatum a requesting metadatum or an available metadatum. In a further embodiment an additional level of availability detail may be added e.g. by upon receiving the object portion of the object having no missing object portions store in the object descriptor of the object a relocating metadatum and upon inserting the object into the object set replacing the relocating metadatum in the object descriptor of the object with an available metadatum and determining that the object is available in the data store but unavailable in the object set by identifying in the object descriptor of the object a relocating metadatum. In this manner an embodiment of these techniques may detect and record events relating to the availability of objects and or may inform the user as part of the availability status of the process of requesting and receiving an object from one or more hosts .

As a third example of this third aspect the object descriptor may be involved in the detection presentation and or resolution of versioning conflicts among object versions of an object . A versioning conflict may arise e.g. if an object of the object set is modified both by a first user to generate a first object version and a second user to generate a second object version. In such scenarios a client may be unable to determine how to resolve the versioning conflict such as whether either object version supersedes the other object version whether the modifications are to be merged etc. In the context of the objects of a synchronized object set such a versioning conflict may be detected when a first object version of an object is received by a client and stored in the data store but when the client attempts to relocate the object to a canonical location within the object set a second object version of the object is found to exist at the canonical location. In such scenarios an embodiment of these techniques may store in the object descriptor of the object a versioning conflict metadatum indicating the existence of a versioning conflict of the object and upon being requested to present an availability status of the object an embodiment may upon identifying a versioning conflict metadatum in the object descriptor of the object present a conflict status with regard to the object . The versioning conflict may be detected e.g. by comparing one or more object version identifiers that may be indicative of the object version of each object . An object version identifier set of such object version identifiers may be available and may include e.g. an object hashcode an object modification date and an object version indicator e.g. a version number stored in or associated with the object . The embodiment may therefore identify the versioning conflict by detecting one or more object version identifiers in the first object version of the object and then comparing these object version identifiers with corresponding object version identifiers in the second object version of the object . Moreover the object version identifiers that differ between the versions may be presented to the user along with the availability status of the object e.g. the conflict status .

As a further third example of this third aspect a further embodiment of these techniques may assist in the resolution of the versioning conflict. For example the embodiment may allow the user to select one object version of the object a selected object version to supersede the other object version of the object an unselected object version . If the user selects the object version available in the data store but not in the object set e.g. the recently received object version the embodiment may be configured to resolve the versioning conflict by copy the selected object version over the unselected object version. Conversely if the user selects the object version available in the object set the embodiment may resolve the versioning conflict by simply deleting the unselected object version that has been recently received. In either case upon resolving the versioning conflict the embodiment may replace the conflict metadatum in the object descriptor of the objet with an available metadatum to indicate the resolution of the versioning conflict. Alternatively or additionally the embodiment may simply notify the user of the versioning conflict and upon detecting a version resolution of the object e.g. achieved manually by the user or automatically by an application the embodiment may replace the conflict metadatum with an available metadatum. In this manner embodiments of these techniques may track report and assist in the resolution of versioning conflicts of the objects of the object set . Those of ordinary skill in the art may devise many ways of detecting and tracking the availability of objects and reporting the availability statuses thereof to the user while implementing the techniques presented herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 1394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Various operations of embodiments are provided herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein.

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

