---

title: Method and system for creating, applying, and removing a software fix
abstract: Embodiments of the present disclosure involve a method for creating, applying, and removing a software fix for an application without terminating the application. To create the fix, the system converts an unresolved internal reference in a source code section to an external imported reference, generates a header file which includes a re-definition of the external imported reference, and generates a binary representation for the fix by compiling the source code section using the generated header file and linking the complied object. To apply the fix, the system loads the binary representation into a virtual address space, places a long jump operator in a compiler-generated padding prior to the start of an affected function, and replaces a no-operation prologue at the start of the function with a short jump operator in an atomic write operation. To remove the fix, the system replaces the short jump operator with the no-operation prologue, removes the long jump operator, and unloads the software fix.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09378008&OS=09378008&RS=09378008
owner: ORACLE INTERNATIONAL CORPORATION
number: 09378008
owner_city: Redwood Shores
owner_country: US
publication_date: 20101220
---
The present disclosure relates software fixes. More specifically the present invention relates to a method and system for creating applying and removing a software fix.

Often times publicly released software applications contain errors that negatively affect usability of the software. These software errors can be corrected by applying software fixes. Conventionally creating a software fix involves re compiling and re linking all effected software application components. Moreover the application of a software fix in the Microsoft Windows operating system environment typically requires termination or suspension of the execution of the software application prior to replacing the effected software components with new versions containing the software fix. Furthermore these new versions of application components with the software fix generally cannot be removed without terminating or suspending the application execution. The need to terminate the application execution is especially problematic for software applications requiring 24 7 availability such as database servers web server transaction monitors etc.

Embodiments of the present disclosure provide a system and method for creating applying and removing a software fix for an application without terminating or suspending the execution of the application. One embodiment of the present disclosure provides a system that converts an unresolved internal reference in a source code section containing the fix to an external imported reference. The unresolved internal reference refers to another source code section which does not contain the fix. The system then generates a header file which includes a definition of the external imported reference. The system also generates a binary representation for the fix by compiling the source code section containing the fix using the header file and linking the compiled code.

In a variation of this embodiment the system recognizes a thread local storage TLS variable when compiling the source code section. The system also generates a new source file that includes a pragma section. The pragma section defines a custom TLS segment in the software fix. The system places an entry associated with the TLS variable in the custom TLS segment at an offset that is identical to the offset associated with the corresponding TLS variable in a TLS segment in the binary code to be fixed. The system next compiles the new source file.

In a variation of this embodiment the system further encapsulates the binary representation with metadata in a secure format. The metadata comprises information on how the application is to be modified to apply the software fix without being terminated or suspended.

In another embodiment of the present disclosure the system generates an export table in a virtual address space. The export table includes an external export reference which can be used by a binary representation for the fix. Moreover the binary representation for the fix contains a corresponding external import reference. The system then loads the binary representation for the fix into the virtual address space and modifies an existing binary code of a function in the running application which is affected by the fix. In one embodiment the system modifies the binary code of the function by placing a long jump operator at the start of the function while storing the existing instructions thereby transferring the execution to an address in the virtual address associated with the corresponding fixed function.

In a variation of this embodiment the system places in a compiler generated prologue at the start of the function a short jump operator directed to the virtual address space location for the long jump operator in a compiler generated padding wherein the placement of the short jump operator corresponds to a thread safe atomic operation and thereby does not require terminating or suspending the application s running threads.

In another variation of the embodiment the system copies an existing export table in the virtual address space and modifies the copy of the export table to include the external export reference.

In a further variation the system assigns the value of a thread local storage index variable as found in a binary code of the relevant module of the running application to a corresponding thread local storage index variable in the binary representation for the fix.

In a further variation the system replaces the long jump operator at the beginning of the function with the originally stored instructions.

In a further variation the system replaces the short jump operator which is directed at the long jump operator at the beginning of the function with a no operation prologue in an atomic write operation.

In another variation the system determines whether any application thread is executing within or returns to a virtual address space occupied by the software fix. If not the system unloads the software fix from the virtual memory address space.

In another variation of the embodiment the system determines that no application thread is executing within or returns to the virtual address space occupied by the software fix by examining a set of logical gates at entry points and exit points of the software fix.

The following description is presented to enable any person skilled in the art to make and use the invention and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present invention. Thus the present invention is not limited to the embodiments shown but is to be accorded the widest scope consistent with the claims.

In embodiments of the present invention the problem of creating applying and removing a software fix in a running software application without interfering with the execution of the application and without using any additional hardware resources is solved.

Specifically during the creation of the software fix the present system converts unresolved internal references to another source code section into external imported references the definition of which is included in a newly generated header file. The system compiles only the source code section containing the fix using the generated header file and links the compiled code to create a binary representation for the software fix.

To apply the software fix the present system expands an export table of the relevant module in the running application to include entries for external export references which corresponds to the external imported references defined in the generated header file. The system loads the binary representation of the software fix into a virtual memory space of the running application. The system then modifies the binary code of the application by 1 placing a long jump operator which is directed to the location of the software fix in the virtual memory space in a compiler generated padding before an affected function of the application and 2 placing a short jump operator which is directed at the long jump operator to replace a complier generated no operation prologue in the binary code of the affected function.

To remove the software fix the present system replaces the short jump operator at the start of the affected function with a no operation prologue in an atomic write operation. The system unloads the software fix from the virtual memory address space after determining that no application thread is executing within or returns to a virtual address space occupied by the software fix.

A software application typically comprises several modules which are contained in multiple object files. Programming code in different modules in different object files may cross reference each other by means of symbols. There are three common types of reference symbols in an object file local symbols export symbols and import symbols. Local symbols are used internally to reference another function or variable defined within the same object file and cannot be referenced by functions in another object file. Export symbols also known as defined symbols allow a function or variable to be referenced by a function defined in another object file. Import symbols also known as undefined symbols or unresolved symbols allow reference to a function or variable not defined within the same object file.

In a conventional non shared static library sections of code are simply added to the calling program when its executable is built at the linking phrase. Thus if two programs use the same routine the code corresponding to the routine would be included in the binary files of both programs.

With dynamic linking resolving undefined or unresolved symbols is postponed until runtime. Thus the executable code would still contain undefined or unresolved symbols that refer to functions and variables defined in another module. The executable code would also include a list of shared libraries that provide definitions for these unresolved symbols such that the software application can dynamically load the share libraries into its virtual memory address space at runtime.

Conventional software fixes include all source codes in an affected module even though some source codes do not involve any code change at all. Unlike conventional software fixes a software fix in accordance to embodiments of the present disclosure is created through compilation and linking of only source code files containing the fix or code changes. presents a diagram illustrating the creation of a software fix in accordance with one embodiment of the present disclosure. The software fix includes one or more header files converted source files and generated header files . The conversion of source files and generation of header files are explained in details below.

Because not all source codes are re compiled and re linked some internal references will become unresolved references. Specifically these unresolved internal references include references from a source code section in the changed source files which is included in the software fix to another source code section in the unchanged source files which is not included in the fix. During creation of the software fix all unresolved internal references are automatically converted into external imported references. The external import references treat reference symbols as unresolved symbols from external modules and allow these symbols to be resolved at runtime rather than at compilation.

The conversion is performed by creating new definitions for all such unresolved internal references and placing the new definitions in an automatically generated header file . Note that the new definition changes the definition from a variable e.g. foo1  to a pointer to the variable e.g. foo1  . The pointer to the variable points to a location in a virtual memory address space of the software application after the fix function is loaded in the virtual memory address space. The generated header file is then used to compile and link the source code containing the fix into binary form e.g. a DLL.

Furthermore header file supersedes all other header files in the source code of the software fix. This assures that the new definitions in header file take priority over all other definitions for the same references in the compile phase. Thus the linker will not attempt to link to other object files having these reference definitions and corresponding to unchanged source codes. To supersede other header files a programmer of the software fix may use a compiler option such as the force include FI option provided by a C C compiler. Alternatively converted source file e.g. myfix.cpp of the software fix may be automatically modified to place generated header file e.g. foo.h prior to all other header files e.g. myfix.h . The binary representation of the software fix is then encapsulated with the pertinent metadata in a secure format.

Creating the software fix in Microsoft Windows environment introduces additional complexity when support for thread local storage TLS variables is required. All threads of a process share its virtual memory address space. The local variables of a function are unique to each thread that runs the function. However the static and global variables are shared by all threads in the process. Thread local storage TLS variables store thread specific data that the process can access using a global index.

In a natively multi threaded Microsoft Windows environment TLS variables can be instantiated on a per thread basis either at compile time via  declspec thread optional qualifier or at run time via TLS Windows Application Programming Interface TLS API . In order to support TLS any software fix referencing a TLS variable must be able to access the correct instance of the TLS variable in each of the software application s execution threads. TLS variables created through the use of TLS API do not require special handling in the software fix because to the operating system a call to a TLS API function made from the software fix is indistinguishable from a call made from the original binary file containing the effected function that is fixed by the software fix.

However the more commonly used  declspec thread qualifier requires special handling when the software fix is created. presents a diagram illustrating a thread local storage segment in a software application. A TLS segment includes TLS variables such as  TLS VARIABLE A  TLS VARIABLE B  TLS VARIABLE C . . .  TLS VARIABLE F etc. Note that different TLS variables are placed at different offsets within the TLS segment. For example  TLS VARIABLE A is placed at offset position in segment and  TLS VARIABLE C is placed at offset position in segment .

To resolve TLS variables during loading time of the software fix TLS segment is aliased to TLS segment . The  tls index variable in the software fix is assigned the same value of the corresponding  tls index variable from the relative module of the software application. Therefore all references to TLS variables in the software fix are de referenced to their correct locations in the virtual memory address space of the application. With this approach the resolution of TLS variables during the application of the fix is instantaneous and has no adverse impact on system performance.

The system generates a header file containing re definitions for converted external imported references operation . Furthermore the system ensures that the generated header file supersedes all other header files operation .

Continuing on the system then determines whether source files in the software fix contain reference to TLS variables operation . As discussed above only TLS variables instantiated via the  declspec thread optional qualifier during compilation require special handling during the creation of the software fix. If such TLS variables are referenced in the source files the system creates a custom TLS segment in the software fix operation . Note that the TLS variables in the custom TLS segment of the software fix are placed in the same order and at the same offset as their corresponding TLS variables in the TLS segment of the software application. The system then links the object file using the generated header file to generate a binary representation operation and encapsulates the binary representation with metadata to create the software fix operation . The metadata comprises information on how the application is to be modified to apply the software fix without being terminated or suspended.

To apply the fix to a running application the binary representation of the fix and its associated metadata are extracted from secure encapsulation. Based on the extracted metadata the running application is modified so that the export table of the relevant module contains all references in the generated header file. An export table contains the name of every function that the executable module DLL or EXE exports to other executables. These functions are the entry points into the executable module. Thus only the functions in the exports table can be accessed by other executables. Any other functions in the executable module are private to the executable module.

In order to implement the extension described above the system determines whether the relevant executable module to which the fix is to be applied in the running application has an existing export table. If so the system can copy the existing export table to another location in the virtual address space and extends the copy to include the additional export table entries. If the relevant executable module in the running application does not have an export table the system can create a new export table in the virtual address space of the application containing the necessary export entries for the executable module.

The system then installs the software fix and loads the binary representation of the software fix into the virtual address space. The TLS variable resolution is finalized by assigning the value of  tls index variable referenced in the relevant module of the running application to the  tls index variable in the software fix. Thus all references to TLS variables in the custom TLS segment from source code sections within the software fix are now redirected to their correct virtual memory locations.

The software fix can be applied by modifying the existing binary code of the running functions affected by the fix so that upon entering any such function the execution is immediately transferred via a long jump operator directed to an address in the virtual memory address space into which the software fix is loaded. This address corresponds to the entry point of the function modified by the software fix. However such modification requires instantaneous suspension of the execution of all running application threads. To alleviate this problem in some embodiments of the present disclosure the system modifies the binary executable code by placing a short jump operator in the 2 byte no operation prologue.

The data structures and code described in this detailed description are typically stored on a non transitory computer readable storage medium which may be any device that can store code and or data for use by a computer system. This includes but is not limited to volatile memory non volatile memory magnetic and optical storage devices such as disk drives magnetic tape CDs compact discs DVDs digital versatile discs or digital video discs or other media capable of storing computer readable media now known or later developed.

The methods and processes described in the detailed description section can be embodied as code and or data which can be stored in a non transitory computer readable storage medium as described above. When a computer system reads and executes the code and or data stored on the non transitory computer readable storage medium the computer system performs the methods and processes embodied as data structures and code and stored within the non transitory computer readable storage medium.

Furthermore the methods and processes described below can be included in hardware modules. For example the hardware modules can include but are not limited to ASICs FPGAs and other programmable logic devices now known or later developed. When the hardware modules are activated the hardware modules perform the methods and processes included within the hardware modules.

The foregoing descriptions of embodiments of the present disclosure have been presented for purposes of illustration and description only. They are not intended to be exhaustive or to limit the present disclosure to the forms disclosed. Accordingly many modifications and variations will be apparent to practitioners skilled in the art. Additionally the above disclosure is not intended to limit the present disclosure. The scope of the present disclosure is defined by the appended claims.

