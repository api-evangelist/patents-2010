---

title: Highly reusable test frameworks and tests for web services
abstract: Systems and methods for incrementally building tests and test frameworks may enable cost reduction and/or code sharing between teams testing various products (or features thereof) in different domains or of different product types. Test frameworks may be layered into standalone sub-framework packages that build on each other and whose object classes inherit object classes of lower layers. Sub-framework packages may provide generic utilities, domain-specific testing operations, application-specific testing operations, or operations for specific application types (e.g., web services). Test clients may plug into test frameworks at any layer to exercise features of a product under test. Tests may be built from components at multiple levels of abstraction, and may include test operations, test steps that include multiple test operations, and tests that include multiple test steps. Implementation details of products to be tested may only be visible to, and/or exercised by, the lowest-level elements of the tests (e.g., test operations).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08904353&OS=08904353&RS=08904353
owner: Amazon Technologies, Inc.
number: 08904353
owner_city: Reno
owner_country: US
publication_date: 20101108
---
A test framework is a system that provides utilities that enable users to build test cases on top of the test framework in order to test a target product. Typically the test framework provides general purpose functionality such as logging error checking data generation etc. Some test frameworks also include wrappers around a target product s features. Many custom test frameworks built by many independent engineers provide similar functionality.

Test frameworks are usually monolithic packages that provide wrappers around the functions of a specific product. In a large company test development teams often do not share test frameworks and instead re implement common functionality in many individual and largely custom test frameworks. On the other end of the spectrum teams are sometimes forced to leverage a large complex framework that does considerably more than they need it to do simply because it offers them 80 of the functionality they do need. In such cases teams may need to force fit the remaining 20 of the functionality that they need into a test framework that was not designed to provide that functionality.

Often test frameworks are built using assumptions about implementation details of the product to be tested that affect the code high up in the test architecture hierarchy. Such test frameworks typically must undergo heavy refactoring when the features API or UI of the target product change. For example in such test frameworks tasks such as migrating the tests from using one network protocol or client package to another are very difficult to do.

While embodiments are described herein by way of example for several embodiments and illustrative drawings those skilled in the art will recognize that the embodiments are not limited to the embodiments or drawings described. It should be understood that the drawings and detailed description thereto are not intended to limit embodiments to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application the word may is used in a permissive sense i.e. meaning having the potential to rather than the mandatory sense i.e. meaning must . Similarly the words include including and includes mean including but not limited to.

The systems and methods described herein may be used to build highly reusable test frameworks and highly reusable test components for testing a variety of products including web services. The techniques described herein may in some embodiments be used to incrementally build abstracted object oriented test frameworks with an architecture that allows for increased code sharing among teams in a large organization with varying projects provides increased framework flexibility and reduces code duplication when compared to traditional approaches for developing test frameworks and product tests. The architectures described herein may also be conducive to the abstraction of test operations and objects for implementing those test operations allowing low level details of tests to be pushed down to the lowest possible layer of the test framework. In some embodiments this may allow testers using the framework to respond to high churn in the implementation details of a product e.g. a web services application being tested without requiring a large number of changes in the higher layers of the framework hierarchy.

The techniques described herein may in some embodiments result in greatly reduced startup and maintenance costs and successful code sharing between different teams including teams that are testing products in different application domains and or of different application types. For example in some embodiments they may allow code sharing between teams developing tests and test frameworks for a variety of web services such as relational databases services data storage services cloud computing services third party marketplace services payment services for e commerce or website application hosting services. In various embodiments the techniques described herein may be used to very quickly develop and launch a highly effective test framework for testing any given product or product type that is general enough to allow development teams to share both the framework concepts and resulting code.

In some embodiments many of the issues described above in reference to traditional test frameworks may be resolved or at least mitigated by layering the test framework into more manageable standalone sub framework packages that build on top of each other. For example the first layer in the test framework may include a package of objects that provide fairly generic test routines and functions. An intermediate layer in the test framework may include a package of objects that provide test routines and or functions that are applicable for testing features of products in a given application domain or in applications of a particular application type. The objects in this intermediate layer may inherit the test routines and or functions of the generic objects of the first layer. Another layer in the test framework e.g. one built on top of a domain specific intermediate layer or an intermediate layer for a particular application type may include objects that provide routines for testing specific features of a particular application. The objects in this layer may inherit the test routines and or functions of the generic objects of the first layer and the test routines and or functions of the objects in the intermediate layer.

In various embodiments clients may be able to plug into the test framework at any given point of the test framework architecture i.e. at any layer in the test framework hierarchy without necessarily needing to access higher layers in the hierarchy. For example if one or more features of a given product can be tested using the generic test routines of the first layer a test team may plug into the test framework at that layer to access the objects that provide those routines. Since these test routines are generic teams testing different types of products may plug into this layer in the test framework to access objects providing these test routines. If a feature of a given product can be tested using a test routine provided by an object in an intermediate layer of the test framework hierarchy the test team may plug into the test framework at the intermediate layer to access that object. Other teams testing products in the same domain or of the same type may also be able to plug into the test framework at this layer to invoke one or more of the test routines provided by the objects in the intermediate layer. In order to test some of the specific features of a given product the test team may need to plug into an application specific layer in the test framework to invoke test routines provided by objects in a sub framework package that are specific to the application. Other teams may plug into different sub framework packages packages of objects that provide test routines specific to different applications at this layer in the test framework hierarchy.

In some embodiments in addition to layering sub framework packages of function and utilities in the test framework itself further improvements in costs and code sharing may be realized by developing tests that are composed in multiple levels of abstraction. For example in some embodiments a test for a given product may include test steps that abstract away the implementation details of the given product and or the low level test operations needed to exercise them . In such embodiments only the low level test operations may need to be modified if the product changes while at the highest level of abstraction the test may remain the same. Techniques for building tests using multiple levels of abstraction are described in more detail later.

One embodiment of a test framework built by layering standalone sub framework packages on each other is illustrated in . In this example test framework includes layers represented in by layers and . As illustrated in various teams developing tests for the same or different products can plug into test framework at different levels in the test framework hierarchy in order to take advantage of the functions and or utilities provided by objects in the corresponding sub framework packages. A given team may not need access to all of the layers of the test framework and may not be burdened by a requirement to maintain understand or include in their testing the extraneous routines provided by any sub framework package s they do not use. For example teams E and F shown as and may plug into layer shown as team C shown as may plug into layer shown as teams B and D shown as and may plug into another intermediate layer in the hierarchy shown as and team A shown as may plug into the nth top layer of test framework shown as . In some embodiments teams may not need to understand or even be aware of any sub framework packages other than the one s they plug into. Test framework architectures that include this layering of sub framework packages are describe in more detail below according to various embodiments.

As noted above traditional test frameworks must typically undergo heavy code refactoring when the features application programming interface API and or user interface UI of the target application e.g. a product being tested changes. In some embodiments of the test systems described herein in addition to the layering structure in the test framework described above tests developed in the system may include a second dimension of layering hierarchy in the tests themselves. For example in some embodiments the low level details of each testing function are abstracted in an operations layer. Tests may include one or more intermediate layers that describe taking one or more steps . In some embodiments each such test step may be composed of one or many test operations in a logical grouping an upper more English like layer may be used to describe a test and each test may be composed of one or many test steps. In some embodiments by abstracting the test design in this manner most of the refactoring introduced by changes to the application code may be isolated to the lowest layer a much smaller amount of refactoring may need to be applied at the next layer at one or more intermediate layers and few if any changes may be needed in the upper most layer of the test. In addition verification checks may be built at the level of the functionality that is being checked rather than at a higher level of abstraction in the test .

In some embodiments the test architecture described herein may use multiple layers of abstraction that build on top of each other. For example in some embodiments tests designed for use with the test framework architectures described herein may include three layers of abstraction that build on each other. These layers of abstraction may build on each other using composition i.e. as building blocks rather than using inheritance as in the inheritance in an object oriented programming language . In such an architecture when there is a clearly defined application program interface API for the problem space i.e. for a product or group of products to be tested the operations layer may be required to stay in step with any changes in the API or elements thereof while there may be fewer situations in which the test steps or the test level code need to be modified.

As previously noted in some embodiments tests may be designed using the following three levels of abstraction 

One embodiment of a method for developing tests using the abstractions described above is illustrated in . As illustrated at in this example such a method may include developing operations level wrappers around elements of a product API to be tested. In some embodiments if the product to be tested is a web service each test may run as a client application that exercises the components of the web service by calling different functions provided to users through an exposed API. In such embodiments operations level wrappers may be developed to abstract an API of a web services application or another feature exposed by a user interface of a web services application such as those described above. As illustrated at in the method may include developing one or more low level verification checks for each of these operations. A verification check developed at the operations level may check a response returned after exercising a particular API to determine whether it produced the expected result may check the status of an operation or may check a value stored at a target of the API following the exercising of the API. For example for the Select File Save operation described above an operations level verification check may be developed to determine whether the appropriate dialog box opened in response to invocation of this feature. The operations level verification check may be configured to invoke the Select File Save API using input parameter values specified for the operation check to see whether the appropriate dialog box was opened and return a response that indicates success or failure with or without including other response parameter values . In this example other operations level verification checks may be developed for testing the Type Filename in Save Box operation and or the Click Save operation described above.

As illustrated at in this example the method may include developing one or more test steps each of which is composed of any number of operations. Using the example above a test step for testing all of the activities that would be performed in order to save a file may include the three test operations described above e.g. Select File Save Type Filename in Save Box and Click Save . As the file saving test step executes each of these operations their operations level verification checks will be automatically performed since they are part of the code for those operations. Therefore the test step itself may not need to include any operations level checks. However as illustrated at the method may include developing one or more mid level verification checks for each test step to verify the correctness of any result of this combination of test operations that is not already verified by the verification checks in the test operations making up the test step.

The test development method described herein may include developing a particular test for a product e.g. a web services application which may be used to exercise one or more high level features of the product by combining any number of test steps into the particular test as in . Using the example above a given test may exercise the file saving feature above as part of an exercise designed to exercise all of the functions provided through the user interface of a web services application or to exercise all of the functions provided through the file menu portion of a web services application. As illustrated at in additional test level verification checks may be developed to verify the correctness of a result of the combination of features or functions tested by the test steps of the test or operations thereof that will not be automatically checked by any of the low level verification checks performed at the operations level or by any of the mid level verification checks performed the step level when the test is executed.

As illustrated in once a test has been developed it may be executed as in to exercise and verify the targeted product features. If any low mid or test level verification checks fail shown as the positive exit from the test may fail as in . If none of the low mid or test level verification checks fail shown as the negative exit from the test may pass as in . Note that in some embodiments if any low mid or test level verification checks fail the test may not complete normally but may instead be terminated early. In other embodiments if any low mid or test level verification checks fail the test may complete normally even though it may return a response or store result data indicating a failing result.

As noted above this test architecture i.e. a test architecture in which tests are built using multiple levels of abstraction may make it easier to modify tests when implementation details of the product being tested change. For example using this approach it may only be necessary to modify the code at one of the lower levels of abstraction in a test in response to a product change without having to modify the code at any higher levels of abstraction in the test. This may be especially true when low level implementation details of the product change e.g. when there are changes to the API or to an underlying communication protocol. illustrates one embodiment of a method for modifying a test built using the abstractions described above in response to a change in the product being tested. As illustrated in this example such a method may include developing a test for one or more features of a given product e.g. a web service as a collection of test steps each built as a collection of test operations as in . At some point one or more changes may be made in the given product as in . In response to that change the test developer may need to modify the test in some way. If there is a change is to one or more high level collections of product features shown as the positive exit from the method may include modifying the code at the test level e.g. by modifying one or more calls and or one or more test level verification checks as in . Using the example above if the test is directed to testing all of the functions provided by a file menu and the menus are changed the test developer may need to modify the test to call different test steps than before the change and or may need to modify a test level verification to take into account any different or additional checks that should be made at the test level to verify the functionality of the changed file menu.

If a change is made to a mid level product function shown as the positive exit from the method may include modifying the mid level code e.g. by modifying one or more calls and or one or more mid level verification checks as in . Using the example above if the product is changed such that saving a file involves different operations than the Select File Save Type Filename in Save Box and Click Save operations described above the test developer may need to modify the test step to call different test operations than before the change and or may need to modify one or more mid level verification checks to take into account any different or additional checks that should be made at the step level to verify the functionality of the changed combination of operations for the step. In this case the test developer may not need to change anything at the test level since the high level feature saving a file still exists in the product and needs to be tested. Since the implementation details for this feature are abstracted away at the test level changes below this level may not affect any verification checks at the test level.

If a change is made to one or more product APIs shown as the positive exit from the method may include modifying the low level code including one or more calls and or low level verification checks e.g. operations level verification checks as in . Using the example above if the product is changed such that one or more of the Select File Save Type Filename in Save Box and or Click Save operations described above should be implemented using new or modified code new or modified request or response parameters or a new or modified communications protocol the test developer may need to modify the code appropriately and or modify one or more low level verification checks to take into account any different or additional checks that should be made at the operations level to verify the functionality of the new or modified operation code. In this case the test developer may not need to change anything at the test level since the high level feature saving a file still exists in the product and needs to be tested. Similarly the test developer may not need to change anything at the step level e.g. in the mid level calls and verification checks since the modified operations may be automatically called by the step and their new low level verification checks may be automatically applied. Since the implementation details for these operations are abstracted away at the test level and at the step level changes made below these levels may not affect the verification checks that need to be performed at these higher levels of abstraction. Once any of the above changes are made the modified product test may be ready for use as in .

The techniques described above may be further illustrated by the following detailed example. Suppose that a provider of web based e commerce services has a system that allows third party merchants which may be referred to herein as sellers to create their own marketplaces accessible through its web service. In this example inside each marketplace the seller can create releases. In this example the term release may refer to a group of configuration files e.g. in a markup language such as HTML or XML that will be read by a service provider which may be referred to as a service owner when operating on this marketplace. In this example the XML code in the configuration files may need to conform to schemas uploaded by service owners and these schemas may match the path of the configuration files but may be in a different partition of the web service that is handling this release.

In this example in order to test a seller s ability to upload a configuration from scratch the seller may need to develop a test that tests the following steps expressed below in plain English 

When using the test architectures described herein it may be possible to have a straightforward mapping between such an English description and the test steps taken in a test written to test their combination. In this example the code at the test level may look similar to the pseudo code below. As shown in this example code at the test level may include little or no specification or indication of the low level implementation details 

In this example serviceOwners and sellers are the test steps objects. Note that in this example no error checking is necessary at the test level. Instead the test steps and or test operations thereof are responsible for determining if the test operations and or test steps have passed and to throw an exception or error indication if they have not. Therefore in this example there may be no need to have complicated error checking logic in the test layer that would have to be refactored later if things changed such as 

The use of multiple levels of abstraction used in this example and the use of these techniques in general may imply that it is up to the objects that perform the test operations to understand what it means for the operation to succeed or fail . However in some embodiments in order to provide for flexibility of tests some or all steps and or operations may offer overrides that take an extra parameter. For example if the test developer expects a given method to fail based on the input conditions and or parameters an extra parameter may be used to specify the kind of failure that is expected and the operation may succeed if the method fails in the expected manner.

As illustrated in the example above a test step may consist of any number of test operations. For example the createMarketplace test step may include test operations for verifying the correct operation of the following functions authenticating a new session requesting creation of a marketplace in an asynchronous manner waiting until the status of the marketplace changes from Pending to Created and then returning the marketplace Id for the newly created marketplace. As shown in this example at the test level the code does not need to know that all of these test operations need to be performed it simply needs to include the higher level test steps needed to create a marketplace. Therefore the logic for actually implementing the steps necessary to create a marketplace may be pushed down to the intermediate level of abstraction i.e. the test step layer . In this example the logic for implementing the test step createMarketplace may be similar to that included in the example pseudo code below. Note that in the example pseudo code below operation objects are not reused e.g. to simplify multithreading and a new instance of an operation may be created per operation. In other embodiments operation objects may be reused.

Note that in this example the code at this level still does not include the actual implementation details of the operations themselves. However the code does include a breakdown of what it means to create a marketplace in this example i.e. there must be an authentication a creation must be started asynchronously then the code must wait until the status of the marketplace changes from Pending to Created or until a specified timeout period has passed .

As shown in this example the test operations may have the actual low level knowledge of how to perform a specific task. For example in a RESTful implementation of a target product a StartCreateMarketplace operation might need to perform a POST to a specific endpoint with a specific path with an authentication string in the headers and perhaps with a body that describes the type of marketplace to be created. The StartCreateMarketplace operation may then expect the HTTP response code from the RESTful request to be 201 Created . In this example the StartCreateMarketplace operation may expect to find the marketplace Id in the location header of the HTTP response or it may find the marketplace Id by parsing the response body. In this example only the StartCreateMarketplace operation may need to worry about these details. In the test steps all the code may need to care about is that it is initiating a request to create a marketplace. Furthermore the StartCreateMarketplace operation may have the responsibility for throwing an exception if the web server was unavailable if it did not return a response code or if it did not return a location Id for the marketplace that was created. Again these are low level details that belong in the operations layer and no higher in this example.

Note that an additional benefit that comes out of this layering of building blocks into multiple levels of abstraction within a test is that even the low level test operations may choose different implementation paths such as various paths that employ REST or SOAP or a custom client package depending on the value of a switch or other test parameter without affecting the test steps in which they are composed or the tests in which the test steps are composed. The same test step and or test may be used while varying the test operation implementation for one or more of the test operations included in a given test or test step thereof increasing code coverage. In some embodiments different paths may be taken at runtime using an inversion of control type switch or a similar technique without even needing to recompile the code.

As described above each test may include multiple test steps. As in the previous example the test Test.uploadConfigFromScratch includes a collection of four test steps including one service owner step uploadSchema and three seller steps createMarketplace createRelease and uploadConfig . As described above each test step in a test may include multiple test operations. In this example createMarketplace step includes three operations authenticateNewSession StartCreateMarketplace and GetMarketplaceStatus . In this example createMarketplace step includes additional code shown at that checks the status returned by GetMarketplaceStatus operation and loops at this point in the test until the status is no longer Pending e.g. until the status is Created as described above. In this example code to perform a step level verification check may be added to the step not shown . For example a step level verification check could be configured to return an error code if the status is not changed to Created before a pre determined timeout period expires. Note that any or all of the operations illustrated as part of the createMarketplace step e.g. authenticateNewSession StartCreateMarketplace or GetMarketplaceStatus may include operations level verification checks that would be performed each time the test and thus this step is executed.

As previously noted in order to be able to share test framework utilities across a large organization testing a diverse number of applications in some embodiments the test framework described herein may be built using an orthogonal multi tier architecture that splits the layers of abstraction of the tests described above and that therefore offers one or more stand alone sub framework packages that anyone in an organization can plug into at any level.

In some embodiments the test framework architecture described herein may include a parent layer which may be referred to as the TestFramework layer which may provide the generic objects and utilities needed by any test framework regardless of what is being tested e.g. a UI a web front end a web back end a console application etc . Functionality that is generally applicable in any testing situation such logging verification configuration test data fetching performance counters etc may be provided at this layer. In some embodiments the heart of the test framework may be a TestOperation class. Objects of the TestOperation class may receive a TestOperationRequest as input and may include a call function that returns a TestOperationResponse. For example the call function of an object of this class may invoke an API or other low level functional element of a product being tested in order to exercise its features. In some embodiments an instance of a TestOperation may be created for every operation that is executed making its use inherently thread safe.

Note that for some tests or test domains a client to the test framework sometimes referred to herein as a test client may choose to plug into the test framework hierarchy at this lowest level. For example if a given test does not need to test functions at any level higher than this level there may be no need to bring in additional functionality or APIs of other levels that would be extraneous or that could potentially pollute the problem space. In such cases the test client may plug into a standalone sub framework package i.e. one that is an executable entity distinct from any other sub framework packages of the test framework hierarchy that includes objects of the TestOperation class.

In some embodiments in order to incrementally build the test framework one or more other packages may be derived from the sub framework package that includes objects of the TestOperation class. These derived sub framework packages may include object of classes that are more specific to the target domain. For example one such package a UITestFramework package may include operations that wrap objects of the TestOperation class in order to access features of the target product through its user interface elements. Another example may be an HttpTestFramework package that wraps low level operations objects of the TestOperaton class with operations that communicate with the target product using HTTP requests and responses. In some embodiments an advantage of this layering approach may be that the generic test framework routines of the TestOperation class objects do not need to be reinvented for the UlTestFramework or the HttpTestFramework. Instead they may simply be inherited. Since the generic test routines of the TestOperation class objects may be shared across multiple test frameworks code duplication may often be avoided. In addition multiple testing teams may benefit from any bug fixes applied to the generic routines which may reduce overall test maintenance costs within a large organization. In some cases the use of the layering techniques described herein may also result in much smaller incremental test framework deployments. For example in embodiments in which each sub framework may be deployed as a standalone binary the overall test framework binary may not need to be changed very often.

In some embodiments sub framework packages at a domain specific or application type specific operations layer may offer Web utilities such as a variety of RESTful drivers HTML and XML parsing utilities etc. Such a package may wrap around the packages of objects of operation classes in a previous layer of the test framework hierarchy e.g. an HttpTestFramework package .

In some embodiments an application domain specific sub framework package such as the HttpTestFramework package described above may be inherited by either another intermediate layer of test framework hierarchy or by an application specific sub framework. In this way multiple test frameworks built for testing web services may use these routines again avoiding code duplication befitting from bug fixes in shared routines and or resulting in smaller incremental deployments . As with the previous layer in the test framework hierarchy for some test domains a test client to the framework may choose to plug into the test framework hierarchy at the application domain specific level or at the application specific level. If a given test does not need to test functions at any level higher than this level there may be no need to bring in additional functionality or APIs of other levels that would be extraneous or that could potentially pollute the problem space. In such cases the test client may plug into a standalone sub framework package i.e. one that is an executable entity distinct from any other sub framework packages of the test framework hierarchy that includes objects of one such application domain specific operation class such as the HttpTestFramework package described above or an application specific sub framework package. An application specific framework may in some embodiments be shared by any number of applications of a similar type e.g. to provide utilities such as specific functional tests load generation etc .

Note that while the detailed example described above includes only three layers of inheritance within a test framework hierarchy TestOperation to HttpTestOperation to MyAppOperation in other embodiments a test framework may be designed using any number of such layers. In embodiments that include additional layering each of the stand alone layers may offer no more and no less functionality than the next level of test applications requires.

As illustrated at the method may include deriving one or more packages of objects for one or more object classes at a second layer in the test framework hierarchy. For example the method may include deriving a package of objects for an application specific sub framework and or deriving a package of objects for a domain specific sub framework such as the packages for UI testing and or HTTP testing described above any of which may wrap a generic TestOperation object class and any of which may be accessed at the second layer in the test framework hierarchy by a given test to implement an operation thereof . As previously noted object classes derived from the TestOperation object class may inherit the functionality characteristics and or behaviors of the TestOperation object class. For example objects in these classes may inherit the generic test framework routines of the TestOperation class.

If any sub framework packages are needed for any additional layers in the test framework hierarchy shown as the positive exit from the method may include deriving one or more packages of objects for one or more object classes specific to a sub framework at a next layer in the test framework hierarchy as in . Note that in various embodiments any number of standalone sub framework packages may be included at each one of any number of layers in the test framework hierarchy not shown . At each additional layer in the test framework hierarchy the additional object packages may be application specific or application type specific such as a sub framework package specific to testing web services and the objects of these packages may inherit generic routines of the test framework e.g. the routines provided by objects at the TestOperation layer of a second layer e.g. routines of objects in a sub framework package targeted to a given domain and of any other intermediate layers in the test framework hierarchy.

If no additional sub framework packages are needed or once any needed sub framework packages have been developed the sub framework packages of the test framework hierarchy may be ready to be accessed by one or more test clients as in . As described herein each test client may plug into the test framework hierarchy at any layer in the hierarchy e.g. to access an appropriate sub framework package dependent on the application application type domain scope of testing etc. as in . Note that additional sub framework packages may be added to the test framework hierarchy at a later time e.g. on an as needed basis.

Again note that illustrates a test framework built by layering standalone sub framework packages on each other as described above and also illustrates that various teams may plug into that test framework at any of the layers. Using the example above test framework may include a sub framework package at a given layer that includes objects of MyAppOperation class and these objects may be used to implement test operations that are generic or reusable for testing a particular type of application e.g. web services . In this example a StartCreateMarketplace operation as described above may be built on this application specific sub framework and may inherit one or more generic routines of the MyAppOperation class.

As described herein a test operation may be implemented using one or more objects of a test framework that includes object packages at any of multiple layers of the test framework hierarchy. As described herein objects in different packages may wrap objects of other packages at a lower layer in the test framework hierarchy. For example a test client may access one or more objects of a sub framework package at a TestOperation layer a domain specific operation layer an application type specific layer an application specific operation layer etc. depending on which layer in the test framework hierarchy is appropriate for the application application type domain scope of testing etc. As illustrated at in the method may include the test operation sending an operation request to the test framework and the request may include an operation name and one or more request parameter values. Using the examples above the test operation may send an operation request targeting a method of an object of a TestOperation class such as TestOperationRequest of an operation request targeting a method of an object of an HttpTestOperation class such as HttpTestOperationRequest of or an operation request targeting a method of an object of an application specific test operation class such as MyAppOperationRequest of . The method illustrated in for executing a test may include the test operation receiving an operation response from one or more test framework object s in one of two or more sub framework packages that were used implementing the named operation as in . Using the previous example it may receive a response from an object of a TestOperation class shown as TestOperationResponse in an object of an HttpTestOperation class shown as HttpTestOperationResponse in or an object of an application specific test operation class shown as MyAppOperationResponse in .

If there are more test operations in the test step shown as the positive exit from the method may include repeating the operations illustrated at for each of those test operations as shown in by the feedback to . Similarly if there are more test steps in the test shown as the positive exit from the method may include repeating the operations illustrated at for each of the remaining test steps as shown in by the feedback to . Once all of the test steps and their test operations have been executed shown as the negative exit from the testing of the product by this test may be complete as in . Note that in some cases one or more parameter values returned by the test framework e.g. in the response returned at may cause a verification check at the test operations level the test step level or the top level of the executing test to fail not shown . In some embodiments if this occurs the test may not complete normally but may instead be terminated early e.g. without completing all of the loops from to or from to that are illustrated in . For example an operation named in one of the operation requests sent to the test framework may throw an exception under certain conditions and or may return an error code. A verification check of a test operation or test step or even at the test level may recognize the error code or exception as one from which the test cannot recover and may cause the test to be aborted. In other embodiments the test may be configured to continue executing all of the loops from to or from to until testing is complete even if an error is observed by a verification check or an exception is thrown by one or more methods invoked by the test framework to exercise various features of the product e.g. through its APIs . In such embodiments the effects of any exceptions taken and or any error codes returned may be handled and or analyzed following the completion of the test.

As illustrated at in this example the object in the given sub framework object package may execute the named operation e.g. by calling its function . For example the object may invoke a method corresponding to the named operation that exercises a corresponding feature of a product under test e.g. through one of its APIs . The object in the sub framework object package may then return a response to the test client as in . As described herein the response may include one or more response parameter values. illustrate various examples of responses that may be received from different layers in a test framework hierarchy including TestOperationResponse in HttpTestOperationResponse in and MyAppOperationResponse in . Other operation responses may include values of more fewer or different response parameters than those illustrated in .

Note that while many examples of the use of the test layering and test framework layering described herein are directed to tests and test frameworks for testing web services these systems and techniques may be generally applicable for building and deploying tests and test frameworks for testing a variety of other types of products or features thereof including hardware products software products and products that are implemented using a combination of hardware and software elements. Note also that while in some embodiments the techniques described herein for developing tests that include functionality and or verification checks at multiple levels of abstraction may access routines in a test framework that is built using a hierarchy of standalone sub framework packages such as those described herein in other embodiments tests written using the techniques described herein may access routines of a test framework that does not employ these sub framework layering techniques. In still other embodiments a test framework may employ the sub framework layering techniques described herein but may be accessed by tests that are not built using multiple levels of abstraction as described herein e.g. they may be accessed by flat tests or by tests that exhibit a different type of hierarchical structure .

Note that in some cases mid or high level verification checks may need access to low level information in order to verify the correct operation of test step or collection of test steps in a test. In some embodiments in order to accommodate this need tests may include one or more observer pattern designs. For example in some embodiments an observer pattern may be used to specify a list of observer objects that are dependent on a subject object. Such observer patterns may be included in code for any level of the test framework hierarchy and may apply to a single object instance in which case it may be referred to herein as a singleton or it may apply to all instances of a given object or to all of the objects in a given class e.g. all objects of a given sub framework package. illustrates an example observer pattern for an HttpTestFramework e.g. for the objects in a sub framework package at the HTTP domain layer in a test framework hierarchy according to one embodiment. As illustrated in a list of observers may be maintained using register and unregister methods such as those illustrated in .

When the state of the subject object changes e.g. when the state of an object in the HttpTestFramework package changes such as when it completes the registered observers may be notified by calling one of their methods. In the example illustrated in calling a notifyObservers method of the observer pattern may cause a notify method to be called in each of the observers currently registered for objects in the HttpTestFramework package as in . In this example the code for an object in the HttpTestFramework package may include a call to a register method for an HttpThrottlingObserver shown in as registerObserver HttpThrottlingObserver . In this example the code also includes calls to register and then to unregister a second observer HttpFrameworkObserverB . In this example a call to a notifyObservers method is the last thing in the pattern and may be called after any other methods of the HttpTestFramework objects have been called. This may indicate that this method is called only once for each object in this class i.e. after completing all of its work using other methods. In other observer patterns a notifyObservers method may be called at different points by an object or may be called multiple times by an object or any of its methods e.g. at state changes other than a change to the completion state .

In some embodiments a base operation constructor in the test framework may take an array with any number of observers. Following the observer pattern observers may be attached to or detached from operations at any given time. These observers may be notified in real time when the operation completes executing and can take any action desired according to the methods provided in the corresponding observers. For example observers may be configured to monitor and or track various state changes parameter values operation responses or other information collected at one level in the test framework hierarchy and may store log or otherwise make the collected information available to objects at other levels in the test framework hierarchy. In some cases and for certain types of information the collected information may be rolled up and aggregated as it goes up the inheritance chain.

As described herein observer patterns may be used in some embodiments to provide higher level objects with access to lower level objects while keeping them generally decoupled. Otherwise the lower level objects may need to expose information that may run counter to good object oriented design practices. The use of observer patterns may open up a variety of test design possibilities as higher levels of the frameworks can create observers e.g. often singleton observers to keep track of specific statistics. For example a singleton HttpThrottlingObserver at the HttpTestFramework level may in some embodiments be used to keep track of the percentages of throttled requests. Such an observer may be notified of the result of each HTTP operation at the end of the operation. If the response code is for example the observer could count this HTTP operation as a throttled operation otherwise it could count this HTTP operation as a non throttled operation. In this example the observer may be configured to increment a counter when it determines that an HTTP operation was throttled. Another object at any level in the test or test framework hierarchy may query this counter in order to determine the number of throttled operations e.g. at the end of a test run . In this example the test may pass or fail depending on whether a pre determined threshold on the allowable percentage of throttled operations is exceeded. Other observers may keep track of latency data uploaded data created or other statistics for example by updating a counter a variable or another data structure or by other means for recording observed data or state information and or cost performance or other execution related metrics.

In some embodiments the test framework architectures describe herein or test configuration systems thereof may be designed to allow test data to be stored independently from the test code and or the test framework code so that a given test can be executed using multiple data sets. In some embodiments the test configuration system may follow the layering concepts described herein. For example in one embodiment test data may be stored in XML format and may include any number of parent XML files. In some embodiments the behaviors or values of parent XML files may be overridden.

As illustrated in this example in some embodiments a param element may be used to define a test parameter. In this example the name attribute may contain its name and the value parameter may contain its value. In some embodiments such as the one illustrated above an include element may contain a reference to another data file. In such embodiments a location attribute may contain the location of that file relative to the location of the current file i.e. the file that references it . This may provide a mechanism for the reuse of existing data files. In some embodiments parameters that are common to many tests such as a service s endpoint URL or port may be stored in a separate file that may then be included in the data for any test through the use of such an include element.

In some embodiments tests may use a configuration class that may also be layered according to the test framework hierarchy e.g. into TestConfiguration HttpTestConfiguration and MyAppHttpTestConfiguration classes to access the data stored in the files. Objects of this class may know how to find the target data files. In some embodiments these objects may open the data files and read the children elements of a root configuration element in each file e.g. using a config method in the order in which they appear. In some embodiments every time the object finds a param element it may store the parameter s value in a hash table using the parameter s name as the key. In some embodiments if there is a name collision a value read later may override any previous value for a given parameter name key . Each time the object finds an include element it may recursively process the included file at the location indicated by its location attribute. In some embodiments such a configuration class may be accessible to all the classes in the test framework hierarchy. Objects of the configuration class may expose a getParam method for the framework to use to fetch the specific data needed to run a given test from the hash table built by its config method. This data may include operation data such as a target web endpoint overall test parameters such as the number of iterations to run a particular test test input data e.g. a set of values for input parameters of a given operation or any other parameterized data required to run a given test.

As illustrated in this example if the configuration class object encounters an include element specifying a file name shown as the positive exit from the configuration class object may recursively process the included file as in . For example the method may include the configuration class object reading all the children elements of the root element in the included file may store parameter values found in the included file in the hash table and may recursively process any files included within the included file itself. As long as there are more children elements to read shown as the positive exit from the method may include repeating the operations illustrated at until all of the children elements have been read from this file. This is shown in as the feedback from to . Once all children elements have been read and any included files have been recursively processed the data set has been loaded into a hash table and is ready for access by the test as in . For example the test may access the data in the hash table by calling the getParam method of the configuration class object that loaded the hash table and specifying a key that corresponds to a particular test parameter. The getParam method may use the key to look up the value of the test parameter in the hash table and return it to the test. Note that in some embodiments the same test may be subsequently run with different test data since the test data is not included in the test code but is stored external to the test itself. For example the test may include a call to a configuration class object specifying a different data file. The configuration class object may repeat the operations illustrated in to load a hash table with the data found in this other file and in any files indicated as included files in the other file . The test may call the getParam method to fetch these new values of the test parameters from the corresponding hash table.

The methods described herein for implementing a test framework and developing tests using the techniques described herein may be implemented on a wide variety of computing systems using any number of underlying system configurations and or data storage architectures in different embodiments. For example in some embodiments the test framework described herein may be implemented on one or more computing nodes coupled to each other to computing nodes hosting a web service to be exercised by one or more tests e.g. a pre release version of the web service and or to various client computing nodes through wired and or wireless interfaces according to one or more standard communication protocols. The components making up such a system e.g. client libraries tests test frameworks or sub framework packages thereof data sets or storage for data sets hash tables counters or other data structures used by the tests or test framework administrative servers gateway processes database servers subscriber applications shared computing resources or other components configured to implement the functionality of these components as described herein may be resident on a single computing node or may be distributed across multiple nodes whether in a single location or at multiple sites in different embodiments.

One computing node that may be suitable for implementation of the test framework and test development techniques described herein is illustrated in . As noted above computing node may include functionality to provide any or all of the components of various computing systems described herein or multiple computing nodes similar to or different from computing node may collectively provide this functionality in different embodiments. For example in one embodiment one or more computing nodes that implement client application servers e.g. to provide access to a web service under test may also be configured to provide libraries of various operation objects functions or utilities e.g. for use by test developers and or test framework developers while in other embodiments one or more computing nodes configured to provide client application servers e.g. to provide access to a web service under test may also provide the test framework itself. In still other embodiments the test framework web service under test and client tests may be executed on different ones of a plurality of computing nodes . In some embodiments that include multiple computing nodes all of the computing nodes may include the same or similar hardware components software components and functionality while in other embodiments the computing nodes comprising a computing system configured to implement the functionality described herein may include a wide variety of hardware components software components and functionality.

In the illustrated embodiment computing node includes one or more processors coupled to a system memory via an input output I O interface . Computing node further includes a network interface coupled to I O interface and one or more input output devices . As noted above in some embodiments a given node may implement the functionality of more than one component of a computing system providing a test framework web service under test and or test client as described herein. In various embodiments a computing node may be a uniprocessor system including one processor or a multiprocessor system including several processors e.g. two four eight or another suitable number . Processors may be any suitable processor capable of executing instructions. For example in various embodiments processors may be general purpose or embedded processors implementing any of a variety of instruction set architectures ISAs such as the x86 PowerPC SPARC or MIPS ISAs or any other suitable ISA. In multiprocessor systems each of processors may commonly but not necessarily implement the same ISA. Similarly in a distributed computing system such as that described herein each of the computing nodes may implement the same ISA or individual nodes and or replica groups of nodes may implement different ISAs.

System memory may be configured to store program instructions and or data accessible by processor . In various embodiments system memory may be implemented using any suitable memory technology such as static random access memory SRAM synchronous dynamic RAM SDRAM nonvolatile Flash type memory or any other type of memory. In the illustrated embodiment program instructions and data implementing desired functions such as those described above are shown stored within system memory as program instructions and data storage respectively. For example program instruction may include any or all of client libraries tests test frameworks or sub framework packages thereof administrative servers gateway processes database servers subscriber applications shared computing resources or other components configured to implement the functionality of these components as described herein. Program instructions may also include program instructions configured to implement additional functionality of a computing system not described herein.

Data storage may in various embodiments include one or more test data sets hash tables counters or other data in other data structures used by the components of the test framework tests and or web service under test. In other embodiments program instructions and or data as described herein for implementing a test framework a web service under test and or various tests may be received sent or stored upon different types of computer readable media or on similar media separate from system memory or computing node including various types of non transitory computer readable media. Generally speaking a non transitory computer readable storage medium may include storage media or memory media such as magnetic or optical media e.g. disk or CD DVD ROM coupled to computing node via I O interface . Program instructions and data stored on a computer readable storage medium may be transmitted to a computing node for execution by a processor by transmission media or signals such as electrical electromagnetic or digital signals which may be conveyed via a communication medium such as a network and or a wireless link such as may be implemented via network interface .

In one embodiment I O interface may be configured to coordinate I O traffic between processor system memory and any peripheral devices in the computing node including network interface or other peripheral interfaces such as input output devices . In some embodiments I O interface may perform any necessary protocol timing or other data transformations to convert data signals from one component e.g. system memory into a format suitable for use by another component e.g. processor . In some embodiments I O interface may include support for devices attached through various types of peripheral buses such as a variant of the Peripheral Component Interconnect PCI bus standard or the Universal Serial Bus USB standard for example. In some embodiments the function of I O interface may be split into two or more separate components such as a north bridge and a south bridge for example. Also in some embodiments some or all of the functionality of I O interface such as an interface to system memory may be incorporated directly into processor .

Network interface may be configured to allow data to be exchanged between computing node and other devices attached to a network such as other computer systems or between other nodes in a system providing shared computing services. In various embodiments network interface may support communication via wired or wireless general data networks such as any suitable type of Ethernet network for example via telecommunications telephony networks such as analog voice networks or digital fiber communications networks via storage area networks such as Fibre Channel SANs or via any other suitable type of network and or protocol.

Input output devices may in some embodiments include one or more display terminals keyboards keypads touchpads scanning devices voice or optical recognition devices or any other devices suitable for entering or retrieving data by one or more computing nodes . Multiple input output devices may be present in computing node or may be distributed on various nodes of a shared resource system or grid computing system. In some embodiments similar input output devices may be separate from computing node and may interact with one or more nodes of a shared resource system through a wired or wireless connection such as over network interface .

Users may interact with a computing system providing a test framework web service under test and or test client in various ways in different embodiments such as to develop and or store tests to develop and or store sub framework packages to store one or more data sets to exercise a web service under test using various tests and or sub framework packages and or to receive results of test exercises. For example some users e.g. web service developers test developers and or test framework developers may have physical access to computing node and if so may interact with various input output devices to provide and or receive information. Alternatively other users may use client computing systems to access the system such as remotely via network interface e.g. via the Internet and or the World Wide Web . In addition some or all of the computing nodes of a system providing the service may provide various feedback or other general types of information to users via one or more input output devices .

Those skilled in the art will appreciate that computing node is merely illustrative and is not intended to limit the scope of embodiments. In particular the computing system and devices may include any combination of hardware or software that can perform the indicated functions including computers network devices internet appliances PDAs wireless phones pagers etc. Computing node may also be connected to other devices that are not illustrated in some embodiments. In addition the functionality provided by the illustrated components may in some embodiments be combined in fewer components or distributed in additional components. Similarly in some embodiments the functionality of some of the illustrated components may not be provided and or other additional functionality may be available.

Those skilled in the art will also appreciate that while various items are illustrated as being stored in memory or on storage while being used these items or portions of them may be transferred between memory and other storage devices for purposes of memory management and data integrity. Alternatively in other embodiments some or all of the software components may execute in memory on another device and communicate with the illustrated computing system via inter computer communication. Some or all of the system components or data structures may also be stored e.g. as instructions or structured data on a non transitory computer readable storage medium or a portable article to be read by an appropriate drive various examples of which are described above. In some embodiments instructions stored on a computer readable storage medium separate from computing node may be transmitted to computing node via transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as a network and or a wireless link. Various embodiments may further include receiving sending or storing instructions and or data implemented in accordance with the foregoing description upon a computer readable storage medium. Accordingly different embodiments may be practiced with other computer system configurations.

Those skilled in the art will appreciate that in some embodiments the functionality provided by the methods discussed above may be provided in alternative ways such as being split among more software modules or routines or consolidated into fewer modules or routines. Similarly in some embodiments illustrated methods may provide more or less functionality than is described such as when other illustrated methods instead lack or include such functionality respectively or when the amount of functionality that is provided is altered. In addition while various operations may be illustrated as being performed in a particular manner e.g. in serial or in parallel and or in a particular order those skilled in the art will appreciate that in other embodiments the operations may be performed in other orders and in other manners. Those skilled in the art will also appreciate that the data structures discussed above may be structured in different manners such as by having a single data structure split into multiple data structures or by having multiple data structures consolidated into a single data structure. Similarly in some embodiments illustrated data structures may store more or less information than is described such as when other illustrated data structures instead lack or include such information respectively or when the amount or types of information that is stored is altered. The various methods as depicted in the figures and described herein represent illustrative embodiments of methods. The methods may be implemented in software in hardware or in a combination thereof in various embodiments. Similarly the order of any method may be changed and various elements may be added reordered combined omitted modified etc. in various embodiments.

From the foregoing it will be appreciated that although specific embodiments have been described herein for purposes of illustration various modifications may be made without deviating from the spirit and scope of the appended claims and the elements recited therein. In addition while certain aspects are presented below in certain claim forms the inventors contemplate the various aspects in any available claim form.

For example while only some aspects may currently be recited as being embodied in a computer readable storage medium other aspects may likewise be so embodied. Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended to embrace all such modifications and changes and accordingly the above description to be regarded in an illustrative rather than a restrictive sense.

