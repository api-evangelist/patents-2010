---

title: Systems, methods, and apparatus for accessing object representations of data sets
abstract: In one embodiment, markup representation of a data set is requested at a relational data store. The data set has a first portion stored at a first table structure of the relational data store and a second portion stored at a second tale structure of the relational data store. The markup representation of the data set is received from the relational data store and an object representation of the data set is generated based on the markup representation of the data set. The object representation of the data set includes a first element having a value of the first portion and a second element having a value of the second portion.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09129035&OS=09129035&RS=09129035
owner: Hewlett-Packard Development Company, L.P.
number: 09129035
owner_city: Houston
owner_country: US
publication_date: 20101005
---
Object based application modules operate on objects that represent data sets stored at relational data stores. Because data sets represented as objects are stored within a memory of an application module differently as compared to the storage of those data sets within a relational data store an impedance or format mismatch exists between objects and storage of data sets within relational data stores. For example data sets represented as objects are typically stored hierarchically and data sets within a relational data store are typically stored in flat tables. This mismatch can be referred to as an object relational impedance mismatch. Thus the data sets as stored at the relational data store are converted to objects before such data sets are useful at object based application modules.

Due to complications in converting data sets stored at relational data stores to objects that arise from the object relational impedance mismatch and tradeoffs between data consistency storage space efficiency and access performance at relational data stores various strategies have been employed to improve the performance of object relational mapping software modules or object mapping modules that convert data sets from a native format of a relational data store to a native format of object. For example data caching and lazy fetching i.e. delaying requests for some elements of an object stored at a relation data store until access for those specific elements of the objects is requested have been employed to mitigate the effects of object relational impedance mismatch and tradeoffs between storage space efficiency and access performance at a relational data store.

Such strategies however are often ineffective for application modules in which an object is not frequently accessed or a complete representation of the object is required when the object is initially requested as in for example a web services application. Moreover such strategies can be ineffective within environments in which multiple applications that access separate caches store and or modify data stored within a relational data store. Because object based application modules are becoming increasingly common efficient object mapping modules are desirable.

Computing devices that provide application modules often rely on data objects or objects to manage data and functionality. In other words software modules that implement application modules are frequently object based or object oriented.

Application modules are software modules stored at a memory and executed at a processor of a computing device that provide a service such as a data processing service a data presentation service and or a data storage service. For example an application module can be a word processing application network service such as a web server web application remote data storage remote data processing and or other service available via a network such as the Internet a client application of a network service such as an electronic mail client or Internet browser application or some other software module.

Objects are data sets that are organized within a memory of a computing device and can typically be referred to and or operated on as a single unit. Furthermore objects can include nested or embedded or encapsulated objects. Said differently objects are typically hierarchical and therefore store nested or subordinate or child elements such as other objects. Thus an object can include elements such as data values method values that implement or reference implementations of various functionalities other objects references to other objects and or other data. That is an object can encapsulate such data.

Data stores such as databases at which application modules store data sets are typically organized according to a relational model or schema. Such data stores can be referred to as relational data stores. Said differently relational data stores store together related groups of data from a data set. For example a relational data store can define a group of tables where each table is associated with an element or the data type or information stored at that element of an object. In other words when an object is stored at a relational data store the elements or values of the elements of that object are typically stored in separate tables. This architecture of relational data stores reduces data redundancy within relational data stores which improves utilization of storage space and data consistency within the database e.g. to update information within the relational data store by accessing a minimal number of rows and columns in a minimal number of tables . Thus each table at which elements of that object are stored is queried to access the object as represented within the relational data store. Said differently the tables storing elements of the object are each queried to reconstruct the object.

Storage of an object within a relational data store is further complicated if that object the nesting object includes a nested object because the values of the elements of the nesting object are distributed across multiple tables within the relation data store and the values of the elements of the nested object are similarly distributed across multiple tables. Thus to reconstruct or access all the elements of the nesting object each table that stores an element of the nesting object and each table that stores an element of the nested object are accessed to retrieve the values for those elements.

Such storage of objects or the elements of objects distributed across multiple tables within a relational data store increases the amount of time to access all the data encapsulated in an object such as a nesting object i.e. data in the table for the nesting object and data in the table for the nested object . More specifically a software module in communication with a relational data store issues a separate access request to the relational data store for each of the elements of the nesting object and separate access requests to the relational data store for each of the elements of the nested object. The relational data store sends the requested rows and columns to the software module in response to each access request. This strategy can be referred to as select fetching. Furthermore each access request from the software module to the relation data store can be referred to as a round trip. Thus multiple round trips are employed to access all the data encapsulated within the nesting object.

Alternatively some relational data stores include a join operation or functionality capable of joining multiple tables and returning a result that includes data from multiple tables. Thus a software module in communication with the relational data store can issue a request to the relational data store for the elements of the nesting object and the elements of the nested object following a join of the table for the nesting object and a the table for the nested object. The relational data store sends the requested rows and columns to the software module in response to the access request. This strategy can be referred to as join fetching.

Accordingly it is possible in a join fetching strategy to employ only a single round trip to access all the data encapsulated within the nesting object. However in practice a join fetching strategy is typically used together with a select fetching method because the number of rows produced within the relational data store in response to the join operation is the product of the rows in each table that is joined. For tables with large numbers of rows such as those in typical relational data stores access performance of the relational data store can be so severely adversely affected due to both the memory requirements of storing large number of rows produced in response to the join operation and the processing resources to effect the join operation that a combination of select fetching and join fetching strategies are typically employed to access data sets within the relational data store.

Additional complications arise in providing the data set in rows and columns to the object mapping module. For example columns that are included in the table for the nesting object and the table for the nested object are included in the result of the join operation. Thus duplicate columns that have redundant information can exist within a join result. Because each column in each row is sent from the relational data store to the object mapping module such redundant column data adds processing and transmission overhead to transfer of the data to the object mapping module. Furthermore per column metadata e.g. information about data type and or length and other information related to columns is typically provided by the relational data store with the requested data. Such metadata also adds transmission overhead to transfer of the data to the object mapping module. Moreover the per column metadata is accessed within the relational data store before the data is sent to the object mapping module. Such accesses increase processing overhead to provide the data to the object mapping module.

A further complication of storing objects at a relation data store is often referred to as the object relational impedance mismatch. The object relational impedance mismatch refers to the flat storage of data sets within a relational data store at rows and columns of tables and the hierarchical storage of data sets encapsulated within objects. In other words when a software module receives rows and columns of data values representing elements of an object from a relational data store the software module parses the rows and columns and stores the data values at the elements of the object. Said differently the native format of storage at the relational data store differs from the native format of storage at an object.

Embodiments discussed herein can improve the performance of object mapping modules by introducing an additional representation of a data set i.e. an intermediate data format or representation between the native format of storage at the relational data store and the native format of storage at objects. In other words despite additional conversion to and from the intermediate data representation performance of object mapping modules can be improved by employing the intermediate data format. More specifically performance of object mapping modules can be improved by converting data sets stored in rows and columns at a relational data store to a markup representation of the data sets before the data sets are provided to the object mapping modules. The object mapping module can then convert the markup representation of the data set to an object representation of the data set i.e. an object . Additionally an object mapping module can provide the markup representation of the data set directly to for example an application module that communicates with clients using markup representations of data sets rather than object representations of data sets.

As a specific example an object mapping module receives a request for an object representation of a data set from a network service. In response to the request the object mapping module requests a markup e.g. Extensible Markup Language XML representation of the data set in a format specified in the request from a relational data store. More specifically the object mapping module requests that the data set be sent to the object mapping module from the relational data store in the markup representation. Said differently rather than provide a collection of rows and columns to the object mapping module in response to a request for a data set the relational data store first converts the data set from the native format i.e. rows and columns of the relational data store to a markup representation and provides the markup representation as a single column result to the object mapping module i.e. the markup representation of the data set is provided to the object mapping module as a single column of data from the relational data store . The object mapping module then converts the markup representation to an object representation and provides the object representation to the network service.

Although the inclusion of additional data in a markup representation of a data set e.g. the markups or tags of the markup representation suggests decreased performance due to additional processing and or transmission overhead providing the data set to the object mapping module in a markup representation can result in more rapid and efficient access to the data set. For example tags of the markup representation can be compact or abbreviated to reduce the transmission and or processing overhead associated with the markup representation. Additionally because fewer columns are transferred when using the markup representation i.e. a single column for the markup representation rather than multiple columns for the native rows and columns format of the relation data store less per column metadata is accessed and transferred. Indeed when a data set is requested from a relational data store in a markup representation using compact tags data processing at the relational data store and data transmission from the relational data store to the object mapping module can be greatly reduced as compared to a request for the same data set in the native rows and columns format of the relation data store.

Furthermore a markup representation of a data set is typically of a hierarchical structure. Similarly an object representation of a data set is typically of a hierarchical structure. Because the markup representation and the object representation share a hierarchical structure conversion at an object mapping module of the markup representation of a data set to the object representation of the data set can be more efficient than conversion of the data set in the native rows and columns format of a relational data store to the object representation. Thus because the markup representation can reduce processing and transmission overhead at the relational data store and because conversion from the markup representation to the object representation can be efficient employing an intermediate format can improve performance of an object mapping module despite introducing an additional representation of data sets between the object mapping module and the relational data store.

As used in this specification the singular forms a an and the include plural referents unless the context clearly dictates otherwise. Thus for example the term object mapping module is intended to mean one or more object mapping modules or a combination of object mapping modules. Additionally as used herein the term module refers to circuitry and or software firmware programming machine or processor readable instructions commands or code that are stored at a memory and executed or interpreted at a processor.

A markup representation of a data set is requested at a relational data store at block . A particular format specifying identifiers of tags and or attributes for example of the markup representation can be requested. More specifically the request can define element identifiers e.g. identifiers of tags and or attributes and specify which values from data tables e.g. values stored at rows and columns of the data tables of a relational data store should be stored at elements with particular identifiers. In other words the request for a markup representation can specify a markup format or schema of the markup representation and at which elements of that markup format values from the data set will be stored in the markup representation. For example an object mapping module can generate a request for a markup representation of a data set based on XML extensions of the Structured Query Language SQL XML at a SQL relational database in response to a request for an object representation of the data set and send the generated request to the SQL relational database. Alternatively the markup representation of the data set can be requested using another request format such as Microsoft SQLXML.

The markup representation of the data set is then received at block from the relational data store. In some embodiments the request for the markup representation can be a request for markup representations of multiple data sets. Accordingly markup representations of multiple data sets can be received at block .

An object representation of the data set is then generated from the markup representation of the data set at block . For example elements of the markup representation of the data set identified by tags of the markup representation i.e. identifiers of the elements or data values of the data set within the markup representation can be copied or inserted into elements of the object representation of the data set. In some embodiments the markup representation of the data set and the object representation of the data set can share a common hierarchical structure. The object representation of the data set generated at block is then sent to an application module at block .

In some embodiments the object representation of the data set can be a Java object and the markup representation of the data set can be an XML document. The Java object can be generated at block from the XML document using the Java Architecture for XML Binding JAXB or another framework hardware module and or software module stored at a memory and executing at a processor in communication with the memory to unmarshall the XML document to a Java object i.e. to convert the XML document to the Java object . In other embodiments the object representation can be another object and the markup representation can be an XML document or be based on some other markup format.

Process can include blocks in addition to those illustrated in . For example an object mapping module can request a compact or abbreviated format of the markup representation and process can include a block for expanding or unabbreviating the compact format e.g. abbreviated tags to an expanded or unabbreviated or full format e.g. unabbreviated or full tags . Similarly an object mapping module can receive a representation selector or selector from an application module indicating that a markup representation rather than an object representation is requested and block can be removed from process such that the markup representation is provided to the network service. Additionally one or more blocks can be rearranged. Furthermore although process is discussed above with reference to an object mapping module process is applicable within other environments.

Client device is a computing device such as for example a personal computer a portable computer a mobile device such as a personal digital assistant PDA or a smartphone or some other computing device. is a schematic block diagram of a computing device according to an embodiment. illustrates a schematic block diagram of a computing device according to an embodiment. As illustrated in computing device includes communications interface processor and memory . Processor is operatively coupled to communications interface and memory . Typically as illustrated in memory includes instructions or codes e.g. computer codes or object codes defining software modules that are executed by processor during operation of computing device . For example memory includes instructions that define operating system device drivers and applications e.g. software application programs . In other words operating system device drivers applications and other software modules stored as instructions not shown at memory and executed at processor are hosted at computing device .

Additionally objects or object representations of data sets can be stored at memory . As discussed above an object is a data set that is organized within a memory of a computing device and can typically be referred to and or operated on as a single unit. Furthermore objects can include nested or embedded objects. Thus an object can include elements such as data values methods that implement or reference implementations of various functionalities other objects references to other objects and or other data. That is an object can encapsulate such data.

As illustrated in memory includes object and object . Object encapsulates variable method object reference and object . Variable method object reference and object can be referred to as elements of object . Object reference is a reference or pointer to object which includes variable and method . In other words object reference refers to or identifies the location within memory or memory location at which object is stored. Nested object includes variable and method . Thus a software module such as application hosted at computing device can access a value stored at variable by referencing variable within object within object . In a C language or Java style notation variable can be referenced as follows 

Communications interface is an interface accessible to processor to communicate with i.e. transmit symbols representing data to and receive such symbols from other processors and or computing devices via a communications link. In other words communications interface can receive data from processor and transmit symbols representing that data via a communications link. Moreover communications interface can receive symbols from other communications interfaces via a communications link and send data represented by those symbols to processor . For example communications interface can be a telephone network interface a twisted pair network interface a coaxial network interface a fiber optic network interface a wireless network interface such as a wireless local area network WLAN or a cellular network and or some other network or communications interface.

Referring to communications link can include any connector and or system that allow client device network services object mapping module and relational data store to communicate e.g. exchange signals or symbols representing data one with another. For example communications link can be one or more of a cable e.g. telecommunication cable twisted pair cable coaxial cable or fiber optic cable wireless link or connection e.g. radio frequency link wireless optical link or infrared link or any other connector or system that supports transmission of communications symbols. Additionally communications link can include a communications network or combination of communications networks capable of transmitting information e.g. symbols or signals representing data such as for example an Ethernet network a fiber optic network a wireless network an intranet and or the Internet.

In some embodiments communications link can include multiple communications links and or communications networks operatively coupled one to another by for example bridges routers switches hubs and or gateways. For example client device can be operatively coupled to a cellular network not shown and a network service from network services can be operatively coupled to a fiber optic network not shown . The cellular network and fiber optic network can each be operatively coupled one to another via one or more network bridges routers switches and or gateways such that the cellular network and the fiber optic network are operatively coupled to form a communications link. Alternatively the cellular network and fiber optic network can each be operatively coupled one to another via one or more additional networks. For example the cellular network and the fiber optic network can each be operatively coupled to the Internet such that the cellular network the fiber optic network and the Internet are operatively coupled to form a communications link. Furthermore communications link can include one or more direct connections between client device network services object mapping module and or relational data store . For example relational data store can be directly coupled to object mapping module .

Each of network services is a service accessible to client device via communications link . For example a network service from network services can be a data storage service a data processing service an electronic mail service and or a web service such as a web server or web application. Each of network services can be a hardware module a software module stored at a memory and executed at a processor in communication with the memory and or a combination of one or more hardware modules and or software modules. In some embodiments network services can be virtual machines or virtual appliances hosted at one or more computing devices.

Object mapping module receives requests for example from network services for representations of data sets stored at relational data store accesses markup representations of the data sets stored at relational data store and provides the requested representations of the data sets to network services . Object mapping module can be a hardware module a software module e.g. an application program a software library such as a dynamically loadable library or operating system service stored at a memory and executed at a processor in communication with the memory and or a combination of one or more hardware modules and or software modules. In some embodiments object mapping module can be a virtual machine or virtual appliance hosted at a computing device.

For example a network service from network services can be a virtual machine including a Java based web application that operates on Java objects. Although this example will be discussed with reference to a single network service from network services object mapping module can receive and process requests for representations of data sets e.g. request markup representations from one or more relational data stores such as relational data store and generate the requested representations based on the markup representations from multiple network services from network services . As illustrated in client device can request information from the network service from network services along communication path . Communication paths and are logical and do not necessarily indicate each physical computing device or network device traversed by the data symbols or data signals transmitted along the communication paths.

In response to the request from client device the network service from network services can request a Java object based representation of a data set stored at multiple tables within relational data store from object mapping module along communication path . Object mapping module then requests a markup representation of the data set from relational data store along communication path . Relational data store accesses the multiple tables at which the requested data set is stored and provides the markup representation of the data set to object mapping module along communication path .

Relational data store stores data in tables also referred to as relations and . Data sets stored in each of tables and are related to the other data sets stored at that table. For example a relational data store typically defines a group of tables each having a number of rows also referred to as tuples and columns also referred to as attributes . Data sets with data values that represent common attributes are stored as rows within each table. The data sets are arranged within the rows of a table such that values within each row that represent a common attribute are stored in the column associated with that attribute.

For example as illustrated in table includes rows and and columns and . Table includes rows and and columns and . Table includes rows and and columns and . As an example table can store data sets related to files. A filename or another identifier of a file can be stored at column a number of bytes in a file can be stored at column and a description of a file or other metadata can be stored at column . Thus a data set related to a first file can be stored at row such that the filename of the first file is stored at column within row the number bytes in the first file is stored at column within row and a description of the first file is stored at column within row . A data set related to a second file can be stored at row such that the filename of the second file is stored at column within row the number bytes in the second file is stored at column within row and a description of the second file is stored at column within row . A data set related to a third file can be stored at row such that the filename of the third file is stored at column within row the number bytes in the third file is stored at column within row and a description of the third file is stored at column within row . A data set related to a fourth file can be stored at row such that the filename of the fourth file is stored at column within row the number bytes in the fourth file is stored at column within row and a description of the fourth file is stored at column within row .

Referring to after receiving the markup representation of the data set object mapping module then generates the Java object based representation of the data set by mapping the markup representation of the data set to the Java object based representation of the data set. In other words object mapping module can allocate a portion of a memory accessible to object mapping module for a Java object and can store values included at the markup representation of the data set at corresponding elements of the Java object. Said differently object mapping module can instantiate a Java object and initialize that Java object with values from the markup representation of the data set.

The Java object is then sent to the network service from network services along communication path . The network service from network services then sends the requested information to client device along communication path . For example the network service from network services can access one or more elements of the Java object and send the values of those elements to client device along communication path . In some embodiments the network service from network services can send the Java object to client device along communication path .

Although illustrated separately in the network service from network services object mapping module and or relational data store can be hosted at a single or common computing device. For example object mapping module and relational data store can be implemented as virtual machines hosted at a common computing device and communication link includes a virtual network connection between object mapping module and relational data store .

Markup representation illustrates a markup representation of the first data set and the second data set. More specifically markup representation includes object element variable element object element variable element and variable element . As illustrated in markup representation includes multiple tags that delineate the elements of markup representation . For example markup representation includes opening tags related to objects and variables and respectively and closing tags related to objects and variables and respectively . Additionally markup representation includes variable values VARIABLE VALUE . In other embodiments other opening and or closing tags can be included within a markup representation of a data set. The opening and closing tags and values define the elements of markup representation . For example element includes the opening tag the value VARIABLE VALUE and the closing tag . Additionally an element of markup representation can encapsulate other elements that are included between the opening tag and closing tag for that element. For example element encapsulates elements and .

Object representation illustrates an object representation of the first data set and the second data set. Object representation includes variable element and object element . Object element includes variable element and variable element . Object representation also includes mechanisms for accessing e.g. reading and writing values from and to respectively variable . More specifically object representation includes get method to read a value of variable and set method to store a value to variable . Similarly object includes get methods and and set methods and to access variables and respectively.

The first data set and the second data set are represented in the markup representation by storing the value of column C within row R at variable element. In other words VARIABLE VALUE at element is the value of column C within row R. Similarly the value of column C within row R is stored at variable element and the value of column C within row R is stored at variable element . Additionally the value of column C within row R is related to object element . For example the value of column C within row R can be a reference to row R or a value that is stored at another column not shown within row R of table T that is used to identify the second data set from the first data set.

Furthermore the first data set and the second data set are represented in object representation by storing the value of element at variable element the value of element at variable element and the value of element at variable element . Thus each of markup representation and object representation can represent the first data set and the second data set and object representation can be derived from markup representation .

Environment is an execution context for application module and object mapping module such as runtime environment an operating system and or a virtual machine. Environment defines or provides a communication interface not shown via which application module and object mapping module are operatively coupled. For example environment can define a shared memory interface a message passing interface a system call interface a method call or invocation interface and or some other interface via which application module and object mapping module can communicate one with another.

In some embodiments environment can be an application module. That is environment can be an application module and application module and object mapping module can be portions of that application module. For example application module can be a group of routines and or classes that collectively receive requests for object representations of data sets from other portions of environment or from external clients such as network clients at client interface process e.g. interpret and or manipulate object representations of data sets and or provide those object representations via client interface . Object mapping module can also be a group of routine and or classes within environment . For example object mapping module can be a framework a statically linked library and or a dynamic link library DLL associated with or linked to application module and or other portions of environment . In some embodiments environment can be a Java virtual machine and object mapping module can be a collection of classes such as Java classes that are callable by application module and or other portions of environment .

Application module includes client interface module and object interface module . Client interface module is a mechanism via which application module can communicate with clients or users of application module . Such clients can be environment other application modules of environment and or clients that are external to environment such as clients to which application module is accessible via a communications link. An interface is a mechanism for interaction between two or more modules and can include a hardware module a software module hosted at a computing device and or a combination of hardware modules and or software modules. For example client interface module can be a shared memory interface a message passing interface a system call interface a method call or invocation interface and or some other interface via which application module with other portions of environment .

In some embodiments client interface can include an Ethernet communications interface module including a physical Ethernet port i.e. a physical connector and an Ethernet software stack hosted at application module . For example client interface module can be a Hypertext Transport Protocol HTTP interface module. Object interface module is a mechanism via which application module can communicate with object mapping module using object representations of data sets.

Object mapping module includes object interface module and markup interface module . Object interface module is a mechanism via which object mapping module can communicate with application module using object representations of data sets. Markup interface module is a mechanism via which object mapping module can communicate with relational data store using markup representations of data sets. Object mapping module maps or converts markup representations of data sets to object representations of data sets. For example object mapping module can include a JAXB functionality to convert XML document representations of data sets to Java objects.

Relational data store stores data sets within tables and includes relational interface module and markup interface module . Relational interface module is a mechanism via which relational data store can communicate data sets stored at tables of relational data store to clients of relational data store by sending tabular representations of data sets i.e. data sets represented in rows and columns to those clients. Markup interface module is a mechanism via which relational data store can communicate data sets stored at tables of relational data store to clients of relational data store by sending markup representations of data sets to those clients. For example markup interface module can be an SQL XML interface module or a Microsoft SQLXML interface module.

As illustrated by communication path in application module can request an object representation of a data set a relational data store via object interface module and object interface module . Object mapping module requests a markup representation of that data set via markup interface module and markup interface module . In some embodiments object mapping module can request that the markup representation of that data set have a particular format. For example object mapping module can specify the names of elements or tags of the markup representation of the data set. Furthermore in some embodiments object mapping module can specify the names if any of attributes e.g. XML attributes of the markup representation of the data set within the request for the markup representation.

Relational data store generates or defines a markup representation according to the format if any specified by object mapping module and sends the markup representation of the data set to object mapping module via markup interface module and markup interface module . Object mapping module maps or converts the markup representation of the data set to an object representation of the data set and sends the object representation of the data set to application module via object interface module and object interface module . Application module then provides some requested service and or information to a client or user of application module via client interface module .

Object mapping module can receive requests for object representations and markup representations of data sets and request markup representations of those data sets from relational data store . Object mapping module can receive the markup representations of the data sets and convert the markup representations of the data sets that were requested via object interface module to object representations and forward those object representations to application module via object interface module and object interface module . If the request for a data set was received via markup interface module object mapping module can forward the markup representation received from relational data store unaltered to application module via markup interface module and markup interface module . That is the interface at which a request for a data set was received can be a representation selector that indicates whether a markup representation of the requested data set or an object representation of the requested data set should be provided to an application module. Alternatively for example a request for a markup representation of a data set and a request for an object representation of a data set can be received at a common interface of an object mapping module and each request can include a representation selector such as a parameter or argument i.e. a value that is associated with a markup representation of a data set or an object representation of a data set.

In some embodiments application module can request that the markup representation of a data set have a particular format. For example application module can specify the names of elements or tags of the markup representation of the data set. Furthermore in some embodiments application module can specify the names if any of attributes e.g. XML attributes of the markup representation of the data set. Object mapping module can request the markup representation from relational data store in the format requested by application module . In some embodiments object mapping module can request the markup representation of the data set in a compact or abbreviated format. For example tags elements and or attributes of the markup representation can be abbreviated. Object mapping module can receive the markup representation in the compact format and can expand the markup representation to have the format requested by application module . As an example object mapping module can request a markup representation of a data set in which all textual tag identifiers specified by application module are abbreviate to the minimum characters to preserve uniqueness of those tag identifiers. After receiving the markup representation from relational data store object mapping module can expand the tag identifier to the full tag identifiers specified by application module .

Similar to communication path discussed in relation to communication path illustrates access to a markup representation of a data set stored within tables at relational data store . Application module can request a markup representation of a data set a relational data store via markup interface module and markup interface module . Object mapping module requests a markup representation of that data set via markup interface module and markup interface module . In some embodiments object mapping module can request that the markup representation of that data set have a particular format. For example object mapping module can specify the names of elements or tags of the markup representation of the data set in the request for the markup representation. Furthermore in some embodiments object mapping module can specify the names if any of attributes e.g. XML attributes of the markup representation of the data set.

Relational data store generates or defines a markup representation according to the format if any specified by object mapping module and sends the markup representation of the data set to object mapping module via markup interface module and markup interface module . Object mapping module determines that a markup representation of the data set should be sent to application module e.g. because the request for the data set was received via markup interface module and sends the markup representation of the data set to application module via markup interface module and markup interface module . Application module then provides some requested service and or information to a client or user of application module via client interface module .

Although illustrate a single application module in communication with an object mapping module multiple application modules can request representations of data set from an object mapping module. For example multiple application modules can request object representations of data sets from an object mapping module. In some embodiments some application modules request object representations of data sets from an object mapping module and other application modules request markup representations of data from the object mapping module. In some embodiments multiple application modules request object representations of data sets and markup representations of data sets from an object mapping module. Furthermore application modules can communicate with multiple clients or users .

A request for a data set is received at block . A request for a markup representation of the data set is generated at block in response to the request received at block . The request for the markup representation of the data set is for a compact format of the markup representation. For example the markup representation of the data set can be an XML document and the request for the markup representation can be a request conforming to SQL XML or Microsoft SQLXML in which tags and or attributes are abbreviated identifiers. For example an object mapping module can request that tags of the XML document at which filenames will be included be labeled fname rather than a more verbose filename. The request for the markup representation can then be sent to for example a relational data store.

The compact format markup representation of the data set is received e.g. from a relational data store at block . At block an object mapping module for example determines if the request received at block is for an object representation of the data set. For example the request can be for an object representation if the request was received via an object interface. Alternatively a representation selector or selector or indicator associated with an object representation can be provided to the object mapping module at block or before or after block to indicate that the request is for an object representation or for another representation of the data set such as a markup representation.

If the request is not for an object representation at block the compact or abbreviated format markup representation received at block can be transformed at block to a full or unabbreviated format markup representation of the data set. In other words abbreviated tags attributes and or other portions of a markup representation can be unabbreviated at block . The data set is then sent at . If the request received at block was not for an object representation of the data set the markup representation of the data set generated at block is sent at block .

If the request is for an object representation at block an object representation of the data is generated from the markup representation of the data set at block . For example an object representation of the data set can be instantiated and initialized or populated with values of the data set from the markup representation of the data set. The data set is then sent at . If the request received at block was for an object representation of the data set the object representation of the data set generated at block is sent at block .

Process can include blocks in addition to those illustrated in . Additionally one or more blocks can be rearranged. For example the request for a data set received at block can be a request for multiple data sets and process can be repeated for each data set or multiple data sets can be requested at block received at block and send at block . Additionally the request for the markup representation of the data set at block can be for a full format of the markup representation and block can be removed. Thus in some embodiments the markup representation received at block can be sent unaltered or unmodified at block . Furthermore although process is discussed above with reference to an object mapping module process is applicable within other environments.

A request for a data set is received at block . At block an object mapping module for example determines if the request received at block is for an object representation of the data set. For example the request can be for an object representation if the request was received via an object interface. Alternatively a representation selector or selector or indicator associated with an object representation can be provided to the object mapping module at block or before or after block to indicate that the request is for an object representation or for another representation of the data set such as a markup representation.

If the request is not for an object representation at block a request for a markup representation of the data set is generated at block in response to the request received at block . The request for the markup representation of the data set is for a full format of the markup representation. For example the markup representation of the data set can be an XML document and the request for the markup representation can be a request conforming to SQL XML or Microsoft SQLXML in which tags and or attributes are unabbreviated identifiers. The request for the markup representation can then be sent to for example a relational data store. The full format markup representation of the data set is received e.g. from a relational data store at block . The full format markup representation of the data set is then sent e.g. to a network service at block .

If the request is for an object representation at block an object representation of the data is generated. A request for a markup representation of the data set is generated at block in response to the request received at block . The request for the markup representation of the data set is for a compact format of the markup representation. For example the markup representation of the data set can be an XML document and the request for the markup representation can be a request conforming to SQL XML or Microsoft SQLXML in which tags and or attributes are abbreviated identifiers. The request for the markup representation can then be sent to for example a relational data store.

The compact format markup representation of the data set is received at block . An object representation of the data is generated from the markup representation of the data set at block . For example values of the data set from the markup representation of the data set can be stored at memory locations included within an object representation at a memory of a computing device. The object representation of the data set generated at block is sent e.g. to a network service at block .

Process can include blocks in addition to those illustrated in . Additionally one or more blocks can be rearranged. For example a full format markup representation of the data set can be requested at block . Furthermore although process is discussed above with reference to an object mapping module process is applicable within other environments.

As a specific example of generating an object representation of a data set is a flowchart of a process to generate a Java object representation of a data set using an SQL XML select request according to an embodiment. Process can be implemented as a hardware module and or a software module. For example process can be implemented as application specific circuitry or as a software module including instructions stored at a memory and executed at a processor in communication with the memory. As a specific example process can be implemented at an object mapping module.

A request for a data set is received at block . For example a request for a data set can be received via a communications interface operatively coupled to a communications link. Alternatively for example a request for a data set can be received via an application programming interface API defined by an object mapping module. For example the object mapping module can be a library such as a dynamically loadable library or a static library that defines software modules that implement the object mapping module and are accessible via an API.

In some embodiments the request for the data set can include a representation selector or selector or indicator related to a Java object representation or an XML representation of the data set. For example if the request includes a value that is associated with a Java object such as a plain old Java object POJO and a POJO will be returned to the requestor e.g. a client of an object mapping module . If however the request includes a value that is associated with an XML representation of the data set an XML document can be returned to the requestor. Alternatively an object mapping module can include a Java object interface and an XML document interface for requests for data sets. If a request is received via the Java object interface a POJO will be returned to the requestor. If a request is received via the XML document interface an XML document will be returned to the requestor

An SQL XML select statement is generated at block . The SQL XML statement includes instructions or directives that define the format of the XML document that will be generated in response to the SQL XML statement. In other words the SQL XML defines which data elements of which tables within a relational data store are requested e.g. should be accessed and the format e.g. placement within an XML document and identifiers or names of the XML elements and or attributes of that XML document of those data elements within the requested XML document.

The SQL XML statement can be generated or constructed in various ways. For example a template can be used. The template can include XML statements to obtain an object representation from the relational data store is provided verbatim to the object mapping module in a configuration file. Entire SQL XML statements or fragments of SQL XML can be thus provided and combined as needed at runtime e.g. when a request for a data set is received . For example SQL application programming interfaces such as Java Database Connectivity JDBC and Open Database Connectivity ODBC provide mechanisms for parameter values to be provided as placeholders in a template file that can be replaced with other values just prior to issuance or execution of the statement.

As an example of an SQL XML select statement is a flowchart of a process to generate a Java object representation of a data set using an SQL XML select request according to an embodiment. illustrates an SQL XML select statement according to an embodiment. Syntactically SQL XML select statement uses the syntax of the XML extensions to SQL. Functionally SQL XML select statement defines the tags or data element identifiers of an XML document and describes which data elements of the tables within a relational data store should be associated with those tags within the XML document. More specifically SQL XML select statement requests data elements from a relational data store related to a purchase order and that the result of that request i.e. a select operation within the relation data store be returned or provided as an XML document having a format or structure described by the SQL XML select statement.

The SQL XML statement is then issued or sent to the relational data store at block . Said differently the XML representation defined in the SQL XML statement is request at block . The relational data store accesses the requested data elements within the tables to the relational data store and defines an XML document based on the SQL XML statement and sends that XML document to the object mapping module. As an example of an XML document based on an SQL XML select statement is a representation of an XML document based on the SQL XML select statement of according to an embodiment. In other words XML document includes the tags defined by SQL XML statement and data elements from a relational data store requested or identified by SQL XML statement .

At block the XML document i.e. the XML representation of the data set is received at the object mapping module. If an XML representation of the data was not requested i.e. a Java object was requested at block at block process proceeds to block and the XML document received at block is unmarshalled using JAXB to a POJO. In other words a POJO is generated or defined from the XML document. The POJO is then returned to the requestor at block . is a representation of a Java class including JAXB annotations related to the XML document of according to an embodiment. In other words Java class includes JAXB annotations that can be used to generate a POJO from an XML document based on the JAXB framework. Said differently the JAXB annotations of Java class can be used by a JAXB compliant software module to unmarshall XML document into a POJO including the values of the data element of XML document .

If an XML representation of the data was requested i.e. an XML document was requested at block at block process proceeds to block and the XML document received at block is returned or forwarded to the requestor at block . In some embodiments a format of the XML document can be altered before that XML document is forwarded or returned to a requestor. For example the data elements or tags of the XML document can be specified in the SQL XML select statement to be abbreviated or shortened and those tags can be replaced with full e.g. unabbreviated tags before the XML document is returned to the requestor.

Process can include blocks in addition to those illustrated in . Additionally one or more blocks can be rearranged. For example a POJO can be stored at a cache memory before or after that POJO is returned to a requestor. Moreover the cache memory can be accessed to determine whether a POJO exists for a requested data set before that data set is requested from the relation data store. Furthermore although process is discussed above with reference to an object mapping module process is applicable within other environments.

Some embodiments include a processor and a related processor readable medium having instructions or computer code thereon for performing various processor implemented operations. Such a processor can be a general purpose processor or an application specific process and can be implemented as a hardware module and or a software module. A hardware module can be for example a microprocessor a microcontroller an application specific integrated circuit ASIC a programmable logic device PLD such as a field programmable gate array FPGA and or other electronic circuits that perform operations. A software module can be for example instructions commands and or codes stored at a memory and executed at another processor. Such a software module can be defined using one or more programming languages such as Java C C an assembly language a hardware description language and or another suitable programming language. For example a processor can be a virtual machine hosted at a computer server including a microprocessor and a memory.

In some embodiments a processor can include multiple processors. For example a processor can be a microprocessor including multiple processing engines e.g. computation algorithmic or thread cores . As another example a processor can be a computing device including multiple processors with a shared clock memory bus input output bus and or other shared resources. Furthermore a processor can be a distributed processor. For example a processor can include multiple computing devices each including a processor in communication one with another via a communications link such as a computer network.

Examples of processor readable media include but are not limited to magnetic storage media such as a hard disk a floppy disk and or magnetic tape optical storage media such as a compact disc CD a digital video disc DVDs a compact disc read only memory CD ROM and or a holographic device magneto optical storage media non volatile memory such as read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electronically erasable read only memory EEPROM and or FLASH memory and random access memory RAM . Examples of computer code include but are not limited to micro code or micro instructions machine instructions such as produced by a compiler and files containing higher level instructions that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Additional examples of computer code include but are not limited to control signals encrypted code and compressed code.

As an example of a system including one or more processors and processor readable storage media is a schematic block diagram of system including a processor and storage media according to an embodiment. As illustrated in system includes one or more processors operatively coupled to storage medium storage medium and storage medium . One or more processors can access instructions or code at storage medium storage medium and storage medium . Storage media and can be any processor readable media and or related devices to access processor readable media. For example storage medium can be a hard disk drive including a magnetic storage medium storage medium can be an optical drive such as a DVD drive and can accept DVD storage media on which processor readable instructions can be stored and storage medium can be a FLASH memory drive with a Universal Serial Bus USB interface. In some embodiments storage media and or can be local to e.g. coupled to a common computing device one or more processors . In some embodiments storage media and or can be remote from e.g. coupled to a separate computing device one or more processors and in communication with one or more processors via communications link. Furthermore one or more of storage media and or can be local to one or more processors and one or more of the remaining of storage media and or can be remote from one or more processors .

As a more specific example one or more processors can be included within a computing device having a hard disk drive represented by storage medium and a DVD drive including DVD media represented by storage medium . The computing device can also include a USB host controller to communicate with a FLASH memory drive represented by storage medium . One or more processors can access processor readable instructions such as processor readable instructions that implement an operating system software application and or one or more processes at any of storage media and or . Said differently one or more processors can interpret or execute instructions at processor readable media via storage medium storage medium and or storage medium . In some embodiments system can include one or more memories such as RAM that function as a cache between one or more of storage medium storage medium and or storage medium and one or more processors for instructions or code stored or accessible at one or more of storage medium storage medium and or storage medium .

While certain embodiments have been shown and described above various changes in form and details may be made. For example some features of embodiments that have been described in relation to one application module such as a network service and or a related process can be useful to other application modules. In other words processes features and or properties of various embodiments described in relation to one embodiment can be related to another embodiment. Furthermore it should be understood that the systems and methods described herein can include various combinations and or sub combinations of the components and or features of the different embodiments described. Thus features described with reference to one or more embodiments can be combined with other embodiments described herein.

