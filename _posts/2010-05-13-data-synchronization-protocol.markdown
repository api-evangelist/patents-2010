---

title: Data synchronization protocol
abstract: Among other things, techniques and systems are disclosed for syncing data between a client device and a server. Synchronizing data includes initiating a sync session by negotiating a sync mode between a client device and a server for each of one or more dataclasses. A status code is generated based on a result of the negotiating. Based on the generated status code, the client device and the server exchanges one or more data items to be updated for the one or more dataclasses using the negotiated sync mode for each dataclass. The exchanged one or more data items are updated at the client device or the server The updated one or more data items are committed at the client or the server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08046498&OS=08046498&RS=08046498
owner: Apple Inc.
number: 08046498
owner_city: Cupertino
owner_country: US
publication_date: 20100513
---
This application is a continuation and claims the benefit of priority under 35 USC 120 of U.S. application Ser. No. 12 042 283 filed Mar. 4 2008 now U.S. Pat. No. 7 747 784. The disclosure of the prior application is considered part of and is incorporated by reference in the disclosure of this application.

Data synchronizing between a client and a server can be performed using synchronization protocols such as Open Mobile Alliance Data Synchronization protocol OMA DS SyncML formerly known as the SyncML protocol . The OMS DA SyncML is a sync protocol that enables serial synchronization of dataclasses and can require 5 or more roundtrips per dataclass.

Among other things techniques and systems are disclosed for syncing data between a client device and a server.

In one aspect synchronizing data includes receiving a request to initiate a sync session. The request includes a proposed sync mode for each of one or more dataclasses and one or more changes to the one or more dataclasses. One or more status codes are generated to indicate whether the proposed sync mode for each dataclass is accepted. Based on the generated status code the accepted sync mode is used for each dataclass to selectively update one or more data items associated with the one or more changes to the one or more dataclasses. The updated one or more data items are selectively committed at the server.

Implementations can optionally include one or more of the following features. Generating one or more status codes can include accessing information saved from a previous sync session to determine whether to use the proposed sync mode to synchronize the one or more data items. Receiving the request can include receiving the proposed sync mode for two or more dataclasses in parallel. Also receiving the request can include receiving the proposed sync mode that includes a fast sync mode a slow sync mode or a reset sync mode. Further receiving the request can include receiving a fast sync mode that enables exchange of data items to be updated only. The sync session can be completed in one round trip that includes two messages. When the sync session is interrupted a fast sync can be reaccepted. The proposed sync mode and the one or more changes to the one or more dataclasses can be received in a single message from a client device. The updated one or more data items can be selectively committed at the server when the client device sends a command to commit the updated one or more data items. In addition the proposed sync mode can be rejected and the received request can be responded to with a different sync mode.

In another aspect a computer program product embodied on a computer readable medium is operable to cause a data processing apparatus to perform various operations. The computer program product is operable to cause a data processing apparatus to receive a request to initiate a sync session. The request includes a proposed sync mode for each of one or more dataclasses and one or more changes to the one or more dataclasses. The computer program product is operable to cause a data processing apparatus to generate a status code indicative of whether the proposed sync mode for each dataclass is accepted. The computer program product is operable to cause a data processing apparatus to based on the generated status code use the accepted sync mode for each dataclass is used to selectively update one or more data items associated with the one or more changes to the one or more dataclasses. In addition the computer program product is configured to cause a data processing apparatus to selectively commit the updated one or more data items at a server.

Implementations can optionally include one or more of the following features. The computer program product can cause a data processing apparatus to generate the one or more status codes based on information saved from a previous sync session. The computer program product can cause a data processing apparatus to receive the proposed sync mode for two or more dataclasses in parallel. The computer program product can cause a data processing apparatus to receive the proposed sync mode that includes a fast sync mode a slow sync mode or a reset sync mode. The computer program product can cause a data processing apparatus to receive a fast sync mode that enables exchange of data items to be updated only. Update operations on a data item may 1 create a new item add 2 modify properties of an existing item modify or 3 delete an existing item delete . The computer program product can cause a data processing apparatus to complete the sync session in one round trip that includes two messages. The computer program product can cause a data processing apparatus to reaccept a fast sync mode when the sync session is interrupted. The computer program product can cause a data processing apparatus to receive the proposed sync mode and the one or more changes to the one or more dataclasses in a single message. The computer program product can cause a data processing apparatus to selectively commit the updated one or more data items at the server when the client device sends a command to commit the updated one or more data items. In addition the computer program product can case a data processing apparatus to reject the proposed sync mode and respond to the received request with a different sync mode.

In another aspect a server for syncing data includes a processor configured to operate a transport protocol that enables opening of one or more connections to one or more client devices. The processor is also configured to operate a sync protocol that enables data synchronization between the server and the one or more client devices over the opened one or more connections. The sync protocol enables the server to receive a request to initiate a sync session. The request includes a proposed sync mode fore each of one or more dataclasses and one or more changes to the one or more dataclasses. The sync server also enables the server to generate one or more status codes to indicate whether the proposed sync mode for each dataclass is accepted. The sync protocol also enables the server to based on the generated status code use the accepted sync mode for each dataclass to selectively update one or more data items associated with the one or more changes to the one or more dataclasses. The sync protocol further enables the updated one or more data items to be selectively committed at the server.

Implementations can optionally include one or more of the following features. The processor can be configured to access a data repository to update one or more data items based on the received one or more changes. The processor can be configured to operate the sync protocol to accept or reject the proposed sync mode for each dataclass based on information saved from a previous sync session. The processor can be configured to operate the sync protocol to received the proposed sync mode for two or more dataclasses in parallel. Also the processor can be configured to operate the sync protocol to receive the proposed sync mode that includes a fast sync mode a slow sync mode or a reset sync mode. The processor can be configured to operate the sync protocol to receive the proposed sync mode that includes a fast sync mode that enables the one or more client devices to send data items to be updated only. The processor can be configured to operate the sync protocol to receive request to reinitiate a fast sync when the sync session is interrupted. The processor can be configured to operate the sync protocol to complete the sync session in one round trip that includes two messages. The processor can be configured to operate the sync protocol to receive the proposed sync mode and the one or more changes to the one or more dataclasses in a single message from at least one of the one or more client devices. The processor can be configured to operate the sync protocol to selectively commit the updated one or more data items at the server when one of the one or more client devices sends a command to commit the updated one or more data items. Further the processor can be configured to operate the sync protocol to rejecting the proposed sync mode and responding to the request with a different sync mode.

In another aspect synchronizing data includes sending a request to a server to initiate a sync session. The request includes a proposed sync mode for each of one or more dataclasses and one or more changes to the one or more dataclasses. One or more status codes are received to indicate whether the proposed sync mode for each dataclass has been accepted by the server. Based on the received status code the accepted sync mode for each dataclass is used to receive from the server additional changes to the one or more dataclasses. Further at a client device the additional changes received from the server are committed.

Implementations can optionally include one or more of the following features. The one or more status codes can indicate that the proposed sync mode for at least one of the one or more data classes has been rejected by the server. Another request that includes a different sync mode than the rejected sync mode can be sent to the server. Also the proposed sync mode and the one or more changes can be sent in a single message to the server. The proposed sync mode for two or more dataclasses can be sent in parallel. In addition a different proposed sync mode can be sent for each of the two or more dataclasses in parallel. For example a proposed fast sync mode can be sent for one of the dataclasses and a proposed slow sync mode for another of the dataclasses. After the sync session is interrupted the sync session can be reinitiated using the accepted sync protocol.

In another aspect a computer program product embodied on a computer readable medium is operable to cause a data processing apparatus to perform one or more operations. The computer program product is operable to cause a data processing apparatus to send a request to a server to initiate a sync session. The request includes a proposed sync mode for each of one or more dataclasses and one or more changes to the one or more dataclasses. The computer program product is operable to cause a data processing apparatus to receive one or more status codes that are indicative of whether the proposed sync mode for each dataclass has been accepted by the server. Based on the received status code the computer program product is operable to use the accepted sync mode to receive from the server additional changes to the one or more dataclasses and commit at a client device the additional changes received from the server.

Implementations can optionally include one or more of the following features. The computer program product can be operable to cause a data processing apparatus to perform operations that includes receiving the one or more status codes that indicate that the proposed sync mode for at least one of the one or more data classes has been rejected by the server and sending another request that includes a different sync mode than the rejected sync mode. The computer program product can be operable to cause a data processing apparatus to send the proposed sync mode and the one or more changes in a single message to the server. The computer program product can be operable to cause the data processing apparatus to send the proposed sync mode for two or more dataclasses in parallel. The computer program product can be operable to cause the data processing apparatus to send a different proposed sync mode for each of the two or more dataclasses in parallel. The computer program product can be operable to cause the data processing apparatus to send a proposed fast sync mode for one of the dataclasses and a proposed slow sync mode for another of the dataclasses. The computer program product can be operable to cause the data processing apparatus to reinitiate the sync session using the accepted sync protocol after the sync session is interrupted.

In another aspect a client device includes a processor configured to operate a transport protocol that enables opening of one or more connections to a server and a sync protocol that enables data synchronization between the client device and the server over the opened one or more connections. The sync protocol enables the client device to send a request to a server to initiate a sync session. The request includes a proposed sync mode for each of one or more dataclasses and one or more changes to the one or more dataclasses. The sync protocol also enables the client device to receive one or more status codes indicative of whether the proposed sync mode for each dataclass has been accepted by the server. Based on the received status code the sync protocol enables the client device to use the accepted sync mode to receive from the server additional changes to the one or more dataclasses. Further the sync protocol enables the client device to commit at a client device the additional changes received from the server.

Implementations can optionally include one or more of the following features. The processor can be configured to operate the sync protocol to receive the one or more status codes that indicate that the proposed sync mode for at least one of the one or more data classes has been rejected by the server and send another request that includes a different sync mode than the rejected sync mode. The processor can be configured to operate the sync protocol to send the proposed sync mode and the one or more changes in a single message to the server. The processor can be configured to operate the sync protocol to send the proposed sync mode for two or more dataclasses in parallel. The processor can be configured to operate the sync protocol to send the proposed sync mode for two or more dataclasses in parallel comprising sending a different proposed sync mode for each of the two or more dataclasses in parallel. The processor can be configured to operate the sync protocol to send a proposed fast sync mode for one of the dataclasses and a proposed slow sync mode for another of the dataclasses. The processor can be configured to operate the sync protocol to reinitiate the sync session using the accepted sync protocol after the sync session is interrupted.

Techniques and systems according to the present specification can be implemented to potentially provide various advantages. The sync protocol as described in this specification can reduce the number of round trips the number of back and forth messages exchanged to complete a sync session. The sync protocol as described in this specification can complete a sync session in one round trip for example. The sync protocol as described in this specification enables sync mode negotiation for each of multiple dataclasses in parallel. Thus a request for sync mode negotiation can be sent for multiple dataclasses in one message. Further the sync protocol as described in this specification enables field level differencing and record level differencing.

The synchronization protocol as described in this specification is simpler than conventional protocols such as SyncML. The set of commands available for the synchronization protocol is simple and yet extensible. Unlike SyncML the synchronization protocol as described in this specification represents each message as a text or binary property list files plist . In addition the synchronization protocol as described in this specification is efficient and robust. For example a sophisticated anchor logic is provided on the server. Further the synchronization protocol is tolerant of unreliable network. Even when the network connection is interrupted the anchor logic ensures efficient synchronization once reconnected. Further the synchronization protocol can maintain relatively small message size.

The synchronization protocol as described in this specification is rich. For example the synchronization protocol enables exchange of device information between the client device and the server. Also the synchronization protocol provides convenient yet rich data representation.

Techniques and systems are disclosed for enabling over the air OTA synchronization between a client device and a server. In particular a wireless structured data synchronization protocol can enable a client device to interface with a server to synchronize various data. Such protocol can be used to synchronize Mac Operating System X OS X SyncServices data between a handheld device such as the iPhone and a server such as the .Mac server for example.

The OTA synchronization protocol as described in this specification relies upon the underlying network transport to perform authentication and or authorization and message security encryption using transport layer security TLS for example. The synchronization protocol can enable these data transport using hypertext transfer protocol HTTP transport protocol or other similar transport protocols which are capable of exchanging synchronization protocol messages between the device and server.

The synchronization protocol can enable exchange of protocol messages over the transport such as HTTP transport. The each message exchanged over the transport includes a header element and a body element. The body element can include a sequence of command and or command response elements. The synchronization protocol assigns a unique label to each message command and command response to ensure proper ordering and loss detection. For example the label can include a sequence of numbers for ordering the messages commands and command responses. Using the label the synchronization protocol instead of the transport e.g. HTTP ensures proper ordering and loss detection even when the network protocol does not enforce message ordering.

The synchronization protocol is simpler than conventional protocols such as Synchronization Markup Language SyncML . The set of commands available for the synchronization protocol is simple and yet extensible. For example three flexible primitive commands are available for manipulating resources. In addition four sync family commands are available for data synchronization. Further commands may be split across message boundaries. Unlike SyncML the synchronization protocol as described in this specification represents each message as a text or binary property list files plist . In the Mac OS X Cocoa NeXTSTEP and GNUstep programming frameworks plists are files that store serialized objects. The plists are often used to store a user s settings similar to the function of the Windows registry on Microsoft Windows . Property list files are also used to store information about bundles and applications. A plist is easy to generate and parse using standard operating system OS features such as NSPropertyListSerialization class. Also the synchronization protocol as described in this specification uses simple sync state machine.

The synchronization protocol as described in this specification is efficient and robust. For example a sophisticated anchor logic is provided on the server. An anchor is a tag or label used to keep track of the synchronization state. Also the synchronization protocol can sync multiple dataclasses in parallel. The synchronization protocol is tolerant of unreliable network. Even when the network connection is interrupted the anchor logic ensures efficient synchronization once reconnected with minimal retransmission of data. Further the synchronization protocol can maintain relatively small message size.

The synchronization protocol as described in this specification is rich. For example the synchronization protocol enables exchange of device information between the client device and the server. Also the synchronization protocol provides convenient yet rich data representation.

The client device interfaces with the server using a transport protocol such as HTTP transport protocol to complete a secure data connection. Through the transport protocol a synchronization protocol enables data synchronization between the connected client device and the server. Synchronized data can include various data classes such as contacts e.g. addresses and phone numbers calendar etc. Data synchronization can be performed over the network that includes various wired and wireless networks such as local area network LAN wide area network WAN Ethernet Internet etc.

The processor can operate the transport protocol to open transport connections to one or more client devices . The processor can operate the sync protocol over the opened transport connections to enable data synchronization between the server and the client devices . The transport protocol and the sync protocol can be loaded and running on the memory to be executed or operated by the processor . For example as described with respect to below the processor can operate the sync protocol to receive a request from the client devices to initiate a sync session.

The processor can operate the transport protocol to open transport connections to one or more servers . The processor can operate the sync protocol over the opened transport connections to enable data synchronization between the client devices and the server . The transport protocol and the sync protocol can be loaded and running on the memory to be executed or operated by the processor . For example as described with respect to below the processor can operate the sync protocol to send a request to the server to initiate a sync session.

Synchronization is a process of maintaining consistency between two distinct datastores by periodically comparing the changes which have occurred to each since the last time the datastores were known to be consistent. The datastores can include a client device on one side and a server on the other side. To synchronize with each other the datastores are configured with various capabilities. For example each datastore is configured to supply all data when requested. In addition each datastore is configured to identify and supply changes since the time of the last synchronization. Each datastore is configured to agree on the schema to be kept in sync. Each datastore is configured to agree on the supported data representations. Each datastore is configured to agree on the semantics of synchronization primitives i.e. add update delete . Further each datastore is configured to rollback to a previous state should a problem occur during a sync to avoid corrupting the datastores.

The synchronized data follows the relational model E R and is divided into schemas or dataclasses which group definitions of structured data types entities Entities within a given dataclass may refer to one another via relationships . Relationships between entities in discrete dataclasses is forbidden and thus each dataclass is wholly independent of other dataclasses. From a user s perspective dataclasses may appear to be managed from separate dedicated applications. For example the contacts dataclass can be managed primarily by an address book application while the calendars dataclass can be managed by a calendar application.

The synchronization protocol enables various synchronization modes including slow reset and fast. The first time a client device and a server sync all data for a dataclass are exchanged to match existing data items that are considered identical. To optimize syncing and network bandwidth usage for subsequent sync operations the client device and server should exchange only the data which has changed since the last time the pair synchronized. Thus each entity i.e. client device or server should be capable of determining what local changes should be sent to the other entity. In addition each entity should be able to detect whether a situation has occurred which require exchanging more data before fast syncing can be resumed.

The slow sync mode may be required when the client device and server sync for the first time to establish a common baseline for subsequent difference only data exchange. During a slow sync the client device sends all data for a dataclass to the server . The server attempts to match these data items with those that are already known to the server . Failure to perform proper identity matching can result in duplicated data. The server then responds with data items missing at the client device .

The reset sync mode is used to reset all data for the dataclass on the client device with the server s data. This can occur when the data structure has been pushed to the device or if the server or device determine that the device s local data is corrupt. The device sends no data and the server responds with the complete data structure for the dataclass.

The fast sync mode is the most efficient mode especially when using a limited bandwidth connection. The client device sends only those data that have changed since the last sync with the server . The server responds with only those data that have changed external to the client device .

A synchronization session can follow a distinct set of phases including negotiation pull mingle push and commit. The terms pull and push can be defined relative to the server process. The client device sends its local changes to the server during the pull phase and receives updates during the server s push phase.

During the negotiation phase both sides client device and server can exchange information from the previous sync session to determine what sync mode they agree to use for the current session. To help identify and organize the sync sessions a sync anchor is assigned to each sync session. If the client device has previously synced with the server the client device likely expects a specific sync mode. The client device may believe that it can fast sync with the server but the server may desire to reset the device. When the requested sync mode is accepted by both sides synchronization can proceed to the pull phase.

During the pull phase the client device sends its changed records or if the sync mode is slow all records to the server . Invalid changes may be rejected by the server .

Once all changes have been received the server enters the mingle phase and merges any pending updates in its database with the changes from the client device . The result of mingling is a set of conflicting changes and a set of updates which should be pushed to the client device . The server can automatically resolve all conflicts using a heuristic algorithm. In some implementations it may be desirable for the client device to resolve certain conflicts. The synchronization protocol can be designed to allow for conflicts to be represented and transmitted from the server to the client device . The synchronization protocol can be designed to enable conflicts to be resolved on the client device by the user to be transmitted to the sync server .

During the push phase updates from the server are sent to the client device . When all updates have been received by the client device the commit phase is entered. Both sides client device and server may agree that the sync was successful persist their current sync anchors and commit the exchanged data to their respective data stores.

At any point during a sync either side may decide to cancel the sync and rollback any changes to the local datastore. Cancellation may occur explicitly in response to one or more of the following events when unexpected or invalid data is sent when the expected transitions in the sync state machine are not followed when communications between the client device and server are interrupted or when some other problems occur.

The difference in data can be synced in various granularities. When exchanging synchronization data the client device and the server may send the complete data for each changed record for a record level differencing RLD . Alternatively just the changed fields of each changed record can be sent for a field level differencing FLD . FLD may be preferred over RLD especially when data records include many fields or contain large amounts of data such as the images in the contact dataclass.

The server can dynamically support both RLD and FLD representations of data received from the client device . The data representation for the changes indicates whether the client device is using RLD or FLD for a given dataclass. This provides client device datastore implementation with maximum flexibility when the complexity of maintaining meta information to support FLD is unreasonable.

When receiving RLD changes the server internally converts the changes to FLD for processing storage and communication efficiency. The server expects an RLD client device to send complete records. Data fields that are supported by the client device and are missing from the client device s data record are assumed to have been cleared deleted by the client device . However a mechanism can be provided to enable the client device to indicate that certain data field exceptional values are unchanged without sending the values.

Identification ID mapping is another basic synchronization concept. Every synced datum has an universal unique record ID or UUID. For efficiency sake the server can use the UUIDs of the SyncService on Mac OS X. Alternatively an application on the client device can use its local unique IDs LUIDs for data to promote local datastore efficiency for example.

The server enables the client device datastores to use their own LUID to refer to data items as needed. In this case the server maintains a LUID to UUID mapping to enable the client device to transparently reference global records by using its own local IDs. The server reestablishes new mappings when a slow or reset sync mode is accepted for the dataclass.

The synchronization protocol includes a sequence of messages exchanged between the server and the device using a transport protocol such as HTTP. The synchronization protocol includes the messages exchanged on the transport protocol . The roles of the client device and server in the synchronization protocol are distinct from their roles in the communications transport protocol. For example for the HTTP transport the device is always a client with respect to the transport and thus the device makes requests only. However in the message protocol of the synchronization protocol both the client device and server may issue message commands to each other.

The transport protocol manages the exchange of messages between the server and client device . The transport protocol can include HTTP transport or other suitable transports such as Extensible Messaging and Presence Protocol XMPP . The transport protocol layer handles authentication and thus the synchronization protocol does not need to handle security authentication processing. This enables the synchronization protocol to function more efficiently and require few number of roundtrips. For example Transport Layer Security TLS may be used to ensure security of the transmitted data if desired. Also the transport protocol may perform message chunking. The transport protocol need not guarantee delivery or message ordering as the synchronization protocol has the necessary information to do so and to detect message loss.

The HTTP defines eight methods or verbs that indicate actions to be performed on a resource. The HTTP methods includes HEAD GET POST PUT DELETE TRACE OPTIONS and CONNECT. When using HTTP as the transport protocol the POST method is to be used. The POST method submits data to be processed such as data from an HTML form to the identified resource. The data is included in the body of the request. The result of the POST method may result in the creation of a new resource or the updates of existing resources or both.

For example the server can provide the OTA sync service on a URL such as http sync.mac.com ota . When using text plist representation the Content Type header should be text xml . When using binary plist representation the Content Type header must be present and must be application octet stream . The Content Length header must indicate the size of the message. The User Agent string is used to identify the client protocol implementation. The User Agent string should be of the form Mobile A . Alternatively DeviceInfo method can be used to determine the device implementation version.

A session consists of an exchange of a number of protocol messages between the client device and the server . The HTTP transport implementation can use cookies to maintain a session with the server . Either the client device or the server may indicate that the session is complete by setting a flag in a message header. Each message contains a series of commands that can be processed by the recipient. The client device may be designated as the party that initiates the connection to the server .

The messages exchanged using the synchronization protocol is represented as UTF 8 encoded OS X property lists i.e. a dictionary. This representation facilitates creation serialization and parsing on both the client device and the server . The synchronization protocol can support both Extensible Markup Language XML and binary representations of plists. Binary plists can be 60 to 80 more compact than XML plists. When using XML plist representation any binary data transmitted are serialized as base 64 encoded NSData objects and the text data are XML escaped according to RFC 3076. Each protocol message consists of two root elements the header and the body.

The header element can identify the entity e.g. client device or server sending the message and can contain certain session control information. The header element is a required element of the message and the value of the header element is a dictionary. Elements in the header can indicate the source entity deviceid and target service service target account userid and message sequence number sequence for example. Also the version element can indicate the synchronization protocol version being used. For example shows in the description column that the current version is 1.0 . These elements should all be present in the message.

The value of the service element is a string that identifies the name of the target service such as the sync server. The value for userid element is a string that indicates the target account for the message. The userid element can identify the principal that authenticated with the server on the transport layer . The deviceid for the client device is a string that uniquely identifies the device hardware. For iPhone and iPod touch devices the deviceid element can be the Integrated Circuit Card ICCID value. Client devices with a GSM radio may also send the msisdn element to indicate the phone number of the currently installed active Security Information Management SIM card. The msisdn value may change from one session to the next for example when the user replaces the SIM card without affecting synchronization behavior.

The final element is present in the header when the sender e.g. the client device considers its side of the session to be complete. The final element is a Boolean with a value being TRUE. When final element flag is present the session is considered complete. The sender may then free any session related resources and the recipient is not required to send another message. The recipient may send another message to return outstanding command responses. However the recipient should not send any further command requests. The values for the userid and service elements should be constant for all messages in a given session. The values for the deviceid element should remain constant for the sending entity. In other words while the server and the client device may have different values those values may not change.

The result element may be present in the header of a message to indicate the overall status for a message. For protocol brevity an S OK status is implied for any message without a header status. When detected that a message was not accepted the result element is present in the header. The message may not be accepted when the data is malformed or when the recipient encounters a session fatal condition. A non OK status value indicates that the preceding message body was not processed none of the message s commands were performed and the session should be terminated. For example a header status value of E BadRequest indicates that the previous message was malformed. A header status value of E LimitExceeded indicates that the previous message size exceeded the recipient s capability. Also header status values of E ServiceBusy E ServiceUnavailable and E RetryLater indicate that the server is experiencing difficulties in processing the request.

The body of the message includes an array of command requests and or command responses to be processed by the recipient. The body element is a required element of the message and the value of the body is represented as an array of command or command response dictionaries. The body element may be empty when the sender has no commands to send. Commands in the body are processed in command sequence order.

Both the device and the server may send command requests and responses within the same message. This may depend on the state of the current session.

The commands in the synchronization protocol can fall into two general categories 1 commands that affect the state of the sender the recipient and the processing of other commands in the message or the session and 2 commands that do not. Whether a given stateless command successfully executes may not implicitly affect other commands in the message. Stateful commands begin with a command family prefix e.g. sync for all data synchronization commands . The command family prefix also provides a useful command namespace mechanism that allows the server to support an arbitrary set of services for different client devices . In a given message the commands in a given command family are processed in series and if any command returns a nonsuccess status subsequent commands in that family may not be processed at all. For example a command response with a status code that indicates that the command has not been processed e.g. E CommandNotProcessed can be returned in this case.

The recipient of a non final message includes one or more command responses for each command in the session s next message. The recipient of a final message includes one or more command responses for each command when the final message was sent on a transport layer request i.e. a transport response is expected. The recipient of a final message may include one or more command responses for each command when the final message was sent on a transport layer response.

Three stateless primitive commands can be defined get put and delete . These stateless commands may be used to implement arbitrary object exchange or Representational State Transfer RESTful semantics within the synchronization protocol . This can be used for example to perform management actions to transfer device settings or capabilities or to reference binary large objects or other meta data without requiring the server to perform data synchronization operations.

When detected that the data for a given command or command response is a priori too large the sender may split it into multiple fragments which are sent in consecutive messages. A given command may be split for various reasons and or constraints including memory constraints transport constraints etc.

Similar to the messages the commands can assign an integral value to the sequence element that monotonically increases for each session. For example the integral value can start at 1 and monotonically increase for each session. Based on the detected value of the sequence element the recipient processes the commands in the sequence order.

The name element is a required element that indicates the command s name. The value of the name element is a string.

Command requests use the params element to pass the parameters for the command to the recipient. The params element is a required element having a value that includes a dictionary. Specific parameter elements and values may vary depending on the specific command as shown in .

The more element is required to be in the command when the sender needs to indicate that the command is split into fragments. Each fragment reuses the original command s sequence value. When present the value of the more element is the Boolean value TRUE .

The third column of the table shows whether the command response elements are required. In addition for each command response a short description is presented in the fourth column of the table. For example the name element describes the name of the command such as get. Also the sequence element for a command response corresponding to a command request should have an identical sequence value as the parent command request. Similar to the command the params element is used by the command response to pass the parameters for the command response to the recipient. The params element is a required element having a value that includes a dictionary. Specific parameter elements and values may vary depending on the specific command response as shown in . In addition the command responses use the same parameter values as their associated command requests.

The response element indicates that a message body item is a command response. Absence of the response element indicates that the body is a command request. The value of the response element is a Boolean with the value TRUE .

Command responses use the sequence element assigned with integral values. As described above the values assigned to the sequence element correspond to a command sequence previously sent by the recipient. The recipient processes the command responses in sequence order based on the sequence values. Normally the sender sends exactly one command response per command received in a given message. However if the status for the command response is S NotCompleted indicating that processing of the command has not yet completed the sender may send another command response for the command in a subsequent message. Alternatively one command response can be sent per command fragment if the command was split into various fragments.

The result element is a required element included in the command responses. The value of the result element is an array of one or more status items indicating the results of the command request. When a command could not be completed in a timely manner for example before the client s transport request times out the recipient may return a status such as S NotCompleted to indicate that the command was not completed. This status does not indicate success or failure of the command but instead informs the sender of the command that results will be available later in the session. When the session terminates before a final status is received a failure status such as E Failed staus is assumed. Unknown command requests result in an unknown status value such as E UnknownCommand . Also unexpected commands for stateful commands result in a state error value such as E StateError .

When the recipient encounters an error while processing a stateful command subsequent stateful commands for the same command family in the message may not be processed at all. In this case the status such as E CommandNotProcessed is returned for these commands to indicate that the commands were not processed. Depending on the situation the sender may reattempt those commands.

The commands listed in and are stateless commands that can modify an arbitrary resource on the recipient. The available stateless commands include get put and delete . These stateless commands can implement object exchange or RESTful semantics within the synchronization protocol . Each command can include one or more parameters such as uri value item type items idmap userid authtype auth version anchors etc. Some of these parameters are required while others are optional.

For example the uri parameter is a required parameter with a string value assigned. The uri parameter can specify the desired resource to access. The synchronization protocol does not specify whether the uri parameter represents an actual resource on the client device or server for example a file system path or a virtual resource. The type of the value parameter is determined by the client device and the server . In addition the type of the value parameter is not specified by the synchronization protocol . The logical type of the value parameter may be explicitly specified using the item type parameter. Regardless the representation of the value parameter must be a valid property list type.

The recipient may use the message s userid as the authorized principal for the purposes of limiting access to the indicated URI. If the session authorization is insufficient the userid authtype and auth elements may optionally be included in the command.

The commands listed in and are stateful commands. The synchronization protocol also provides stateful sync family commands and command responses. The stateful command includes sync start sync changes sync commit and sync cancel. These stateful commands enable structured data synchronization between the protocol client device and server . Each of the stateful commands and command responses include the uri parameter to identify a dataclass state machine to be affected by a given command.

The table also includes a description for each parameter. For example the uri parameter indicates the dataclass names such as the string com.apple.Contacts for contacts or the string com.apple.Calendars for calendars. When detected that the recipient does not support the dataclass the status E NotSupported is returned. When detected that the dataclass is not enabled the status E NotAllowed returned. In both these cases the status param name element should be present and should have the value uri to indicate that the uri parameter was the cause of the returned status. The anchors parameter contain information used during the sync negotiation phase. The information can include the requested sync mode mode the datastore versions device version serverversion and sync anchors last device anchor next device anchor last server anchor next serveranchor . The device version parameter for the anchor element describes the version of the client device . The server version parameter for the anchor element describes the version of the server process . The anchors parameter can include device server filter and reset anchors. The anchors can be used to request a sync mode. The default sync mode is the fast sync mode. The anchors can be used to specify a sync direction. The default sync direction is twoway which indicates that changes will be sent from the client device to the server process as well as from the server process to the client device .

When the recipient is willing to sync using the submitted information the recipient returns a OK status S OK with the sync start command response. When the recipient is willing to sync with adjusted parameters e.g. using a different sync mode than the client requested the recipient returns a failed negotiation status such as E NegotiationFailed . When the recipient does not support the supplied sender s version e.g. device version the recipient returns a status such as the E VersionNotSupported status to indicate that the version is not supported. When the recipient does not support the desired sync direction e.g. direction the recipient returns a status such as the E NotSupported to indicate that desired sync direction is not supported. In all these cases the status includes the param name parameter with the value anchors indicating that elements in the anchors parameter of the command were the cause of the unsuccessful status. In addition the recipient can indicate the desired sync mode and anchors in the command response s params dictionary.

When the client device wishes to sync multiple dataclasses in parallel the client device sends a separate sync start command request for each dataclass as shown in below. These commands are included in the same message to enable the server to process the commands within the same sync job. When the server accepts the sync start command received from the client device the client device begins sending sync changes commands. Sending the sync start command during a session which has already started syncing results in a state error status such as E StateError status.

When syncing multiple dataclasses in a single session commands for each dataclass operate on distinct state machines. Usually the server waits until all dataclasses have completed the pull phase or cancelled before mingling the changed data.

The sync changes command enables the client device to send changes to the server . Alternatively the server can send updates to the client device . The uri parameter indicates the dataclass of the data items to be updated or changed. The type of data item being sent is indicated by the itemtype parameter. The itemtype parameter can indicate that the item parameter represents either full records records or field level changes changes . When detected that the client device requires id mapping data items are keyed by the device LUID in the items parameter. The format of the dictionaries for the items parameter depends on the item type. The values of the items parameter are of homogeneous item type. The items parameter can be an empty array to indicate that no more items need to be sent. For example the empty array can indicate that there are no changes or there are no records.

When detected that there are no device changes or the sync mode is reset the client device sends a sync changes command with an empty array for the items parameter. The more Boolean flag element is also included if all appropriate data items for the dataclass are not included in the command params. The more Boolean flag element can be used to break up large amounts of synchronization data into smaller chunks. This is useful when the size of the data to be exchanged is larger than the capability of the recipient. For example the recipient may have message size limitations. Alternatively the more Boolean flag element can enable exchange of multiple item types for a given dataclass in a single session. When the server has received the last sync changes chunk for all dataclasses from the client device the server synchronizes all supplied data with the central database. Then the client server roles within the protocol session become reversed.

At this point the client device begins processing commands from the server . The client device can also return command responses to the server . Any synchronization data updates from the server are then sent in sync changes commands. When no updates are needed the server sends a sync changes command with an empty array for the items parameter. While processing sync changes command requests from the server the client device responds to these commands and includes any required mapping information for add transactions in the command response s params using the idmap parameter. The idmap parameter is sent in a sync changes command from the client device to update existing mappings. For example id mappings may be updated independent of the server changing the data entities. Sending the sync changes command during a session before the sync start or after the sync commit or the sync cancel results in an error status such as the E StateError status. The device may omit sending sync changes command response and defer sending the idmap parameter until the sync changes command of the subsequent sync session. This may be done in order to reduce the number of transport roundtrips necessary to complete the sync session.

The table also shows the parameter type for the parameters. The uri parameter is a string type and the anchors parameter is a dictionary. The table also shows the descriptions of the parameters. The uri parameter indicates the dataclass to commit the sync changes. The anchors parameter is used by the client device to send next device anchor for the server to store. In response the server sends the next server anchor to the device in the sync commit command. In addition the sync mode to use in the next sync is indicated and returned in the sync commit command. Sending the sync commit command during a session before the final sync changes or after sync commit or sync cancel results in an error status such as E StateError error status.

The status resulting from the processing of a given command or message is represented by the status element. A single status element may appear in the message header. When the message was not processed the corresponding status element is included in the message header. An array of status elements is included in the results parameter of command responses.

Status elements indicate the results of a command request. A status item is a Dictionary. The dictionary may contain the status element and contain the code elements to indicate the result status of the corresponding command request. The value for the status element is a string. The value for the code element includes an integer string or an integer. The description element is an optional element that may be present in the command. The value of the description element is a string. The description element is purely informational and has no effect on the processing of the command.

The param name param key and param index elements MAY be present. They are used to provide multi status responses for certain commands. The param name value MUST be a String and indicates to which parameter in the command request this Status item corresponds. The param index value MUST be either a String or an Integer. It MUST be present if the param name element is present and it s value in the command request was an Array. The value of the param index indicates the index of the param name item in the command request to which this Status item corresponds. Index values are zero based. The param key value MUST be a String. It MUST be present if the param name element is present and it s value in the command request was a Dictionary. The value of the param key indicates the value of the key of the param name item in the command request to which this Status item corresponds.

The param name param key and param index elements may also be present. They are not required elements and can be used to provide multi status responses for certain commands. The value of the param name status element is a string that indicates to which parameter in the command request this status element corresponds. The value of the param index element can be either a string or an integer. The param index status element is included in the status dictionary when the param name status element is present and the value of the parameter matching the value of the param name status element in the command request was an array. The value of the param index status element indicates the index in the array parameter item for the parameter whose name corresponds to the value of the param name status element in the command request to which the status element corresponds. The value of the index status element is zero based. The value of the param key element is a string that indicates to which parameter in the command request this status element corresponds. The value of the param key status element is a string. The param key status element is included in the status dictionary when the param name status element is present and the value of the parameter matching the value of the param name status element in the command request was a dictionary. The value of the param index status element indicates the key in the dictionary parameter item for the parameter whose name corresponds to the value of the param name status element in the command request to which the status element corresponds.

The indices in a status refer to the index of the param which resulted in the status if the original param was an Array. Indices start counting from a zero basis. This zero basis mechanism enables the a sparse array of statuses to be returned. For example consider a command named examplecommand shown below that has a parameter items which is an array. Suppose that all but two of the items in the command are well formed with the second and fifth items having values bad .

This shows that there are multiple statuses to be returned for the command with all but the ones indicated being successful. However the value supplied for the param items at index 1 counting from zero so the second item in the command list was a bad value status code . The same case for the 5th item index . This mechanism enables non reporting of statuses for every other item that succeeded. This mechanism can significantly decrease the bandwidth usage requirement when numerous items are sent to the server and only a few fail.

When multiple statuses need to be returned in a single command response a sparse array of statuses may be represented by including a status such as S MultiStatus as the first element of the status array. Subsequent status elements may then indicate the parameter index value and a distinct status for any failed parameter elements for which the parameter type was an array. Alternatively subsequent status elements may indicate the parameter key value and distinct status for any failed parameter elements for which the parameter type was a dictionary.

Status codes in a certain range such as the status code range can be reserved for general statuses. Status codes in another range such as the range can be reserved for errors returned by the server and generally lead to termination of the current session.

The table describes success statuses and error statuses. In the example shown in the S OK status is assigned the code to indicate a success. The parent element may be a message header or command response. The other success status is the S MultiStatus status assigned to code to indicate a success with multi valued statuses. The parent element is a command response.

The error statuses include the E NotCompleted status assigned to code to indicate that command processing for the command has not yet completed. The parent element is a command response. The E NotFound error status is assigned to code to indicate that the indicated data object or URI was not found. The parent element is a command response. The E NotAllowed error status is assigned to code to indicate that the operation is not permitted that may be due to insufficient access rights for example. The parent element is a command response. The E MissingParam error status is assigned to code to indicate that the command was missing a required parameter. The E ParamError error status is assigned to code to indicate that a supplied parameter was incorrect. The parent element is a command response. The E BadValue error status is assigned to code to indicate that a bad value was supplied. The parent element is a message header or command response. The E UnknownCommand is assigned to code to indicate that an unknown command was issued and ignored. The parent element is a command response. The E CommandNotProcessed error status is assigned to code to indicate that a command was not processed due to errors processing a previous command. The parent element is a command response. The E StateError is an error status assigned to code to indicate that an unexpected command was received based on the command family s current state machine. The parent element is a command response. The E LimitExceeded error status is assigned to code to indicate that too many items were supplied. The parent element is a command response. The E VersionNotSupported error status is assigned to code to indicate that the protocol or command version is not supported. The parent element is a message header or command response. The E NegotiationFailed error status is assigned to code to indicate that the sync mode negotiation failed. The parent element is a command response. The E NotSupported error status is assigned to code to indicate that an unsupported or unimplemented operation was attempted. The parent element is a message header or command response. The E Failed error status is assigned to code to indicate a generic failure. The parent element is a message header or command response. The E Canceled error status is assigned to code to indicate that the current state machine has been cancelled. The parent element is a command response. The E ServiceBusy error status is assigned to code to indicate that the server is too busy and could not process the message. This status code also indicates that the device should retry the command again soon. The parent code is a message header. The E ServiceUnavailable error status is assigned to code to indicate that the serve is unavailable and could not process the message. This status code also indicates that the device should retry again soon. The parent element is a message header. The E ServiceError error status is assigned to code to indicate that the server had an internal error. The parent element is a message header or command response. The E BadRequest error status is assigned to code to indicate that the server could not understand the message. The parent element is a message header. The E RetryLater error status is assigned to code to indicate that the server needs the client device to retry at a later time. The parent element is a message header.

The effect of receiving the E NotFound error status is a failure for the get put and delete commands. For the sync start sync changes sync cancel and sync commit commands the dataclass state machine is terminated. The effect of receiving the E NotAllowed error status is a failure for the get put and delete commands. For the sync start sync changes sync cancel and sync commit commands the dataclass state machine is terminated. The effect of receiving the E MissingParam error status is a failure for the get put and delete commands. For the sync start sync changes sync cancel and sync commit commands the dataclass state machine is terminated. In addition the message is not processed. The effect of receiving the E ParamError error status is a failure for the get put and delete commands. For the sync start sync changes sync cancel and sync commit commands the dataclass state machine is terminated. The effect of receiving the E BadValue error status is a failure for the get put and delete commands. For the sync start sync changes sync cancel and sync commit commands the dataclass state machine is terminated. In addition the message is not processed. The effect of receiving the E UnknownCommand is a failure for the get put and delete commands. For the sync start sync changes sync cancel and sync commit commands the dataclass state machine is terminated. The effect of receiving the E CommandNotProcessed error status is a failure for the get put and delete sync start sync changes sync cancel and sync commit commands. The effect of receiving the E StateError error status is that for the sync start sync changes sync cancel and sync commit commands the dataclass state machine is terminated. The effect of receiving the E LimitExceeded error status is a failure for the get put and delete commands. For the sync start sync changes sync cancel and sync commit commands the dataclass state machine is terminated. In addition the message is not processed. The effect of receiving the E VersionNotSupported error status is a failure for the get put and delete commands. For the sync start sync changes sync cancel and sync commit commands the dataclass state machine is terminated. In addition the session will terminate. The effect of receiving the E NegotiationFailed error status is a failure for the sync start command. The effect of receiving the E NotSupported error status is a failure for the get put and delete commands. For the sync start sync changes sync cancel and sync commit commands the dataclass state machine is terminated. The effect of receiving the E Failed error status is a failure for the get put and delete commands. For the sync start sync changes sync cancel and sync commit commands the dataclass state machine is terminated. In addition the session will terminate. The effect of receiving the E Canceled error status is that the dataclass state machine is terminated for the sync start sync changes sync cancel and sync commit commands. The effect of receiving the E ServiceBusy error status is that the session will be terminated. The effect of receiving the E ServiceUnavailable error status is that the session will be terminated. The effect of receiving the E ServiceError error status is that the session will be terminated for all commands. The effect of receiving the E BadRequest error status is that the session will be terminated. The effect of receiving the E RetryLater error status is that the session will be terminated.

Synchronization state information such as the sync mode sync direction agent versions and sync anchors are exchanged between the device and server at various times. The anchors element included in the commands and command responses as shown in is used to bundle this information. The anchors element is implemented as a Dictionary.

The direction key represents the desired or negotiated sync direction. The value of the direction key can optionally be present in the anchors element. When present the value of the direction key is implemented as a String and the string value can include to server to device or twoway . Thus these values indicate the sync direction as syncing from the device to the server syncing from the server to the device or both. When the value of the direction key is not present the receiver infers the value as twoway .

The device version key is sent by the device and represents the device datasource agent version. When present the value of the device version key is implemented as a String. This information can be used by the server to infer behaviors or capabilities specific to a given version of the device software. The server can determine that synchronization is not permitted with a given device agent version for example.

The server version key is sent by the server and represents the server s datasource agent version. When present the value of the server version key is implemented as a String. This information can be used by the device to infer behaviors or capabilities specific to a given version of the server software. The device can determine that synchronization is not permitted with a given server agent version for example.

The actual anchors are exchanged using the keys last device anchor next device anchor lastserveranchor and next serveranchor . The value for each of these keys can be present in the anchors dictionary. When present the value for each of these keys is implemented as a String. When not present the recipient infers the last known value for the keys.

The values of the keys for the anchors element are considered opaque and an entity should not attempt to decode or infer meaning from another entity s anchor keys. For example a client device should not make any assumptions regarding the next server anchor or the last server anchor .

When the client device sends the differences i.e. the changed deleted or new data to the server the client device indicates whether record level differences RLD or field level differences FLD is used via the item type parameter of the sync changes command. The value change in the item type parameter indicates FLD while the value record indicates RLD. Devices that support RLD send the entire data set for a given changed record for a particular dataclass. In contrast devices that support FLD send only the changed properties for changed records in the data set for the dataclass.

An optimization is supported for RLD which enables the client device to send a special value such as no change indicating that a given property has not changed and has not been deleted. This helps to avoid sending large data items such as contacts images that have not changed.

When detecting that the datastore in the client device for example for a dataclass wishes to use id mapping the idmap parameter can be included in the command or the command response for a sync changes command from the server . The value of the idmap parameter is a dictionary that maps server universal unique identifications UUIDs to client device local unique identifications LUIDs . Thereafter the server refers to the mapped entity using the client device LUID.

Broken sessions can cause message packet loss for wireless communications. The synchronization protocol enables recovery from broken sessions without falling out of fast sync. By maintaining fast sync even in the event of a broken session the number of communication round trips are reduced. The reduced number of roundtrips can reduce or minimize message packet loss.

The synchronization protocol is designed to minimize the number of transport messages HTTP request response roundtrips in normal circumstances. The ability to remain in fast sync mode can minimize the bandwidth usage and effort for each sync process by exchanging smaller amounts of data. Moreover frequent fast syncs mean the device server pair never drift much from one another. In other words the device and the server remain more in sync than possible without fast sync. Also this wireless trickle syncing can yield a better user experience.

Certain events can cause a fast syncing pair e.g. client device and server pair to resort to a less efficient sync mode e.g. slow sync mode . These events can include device data corruption interrupted sync sessions failure to agree on consistent sync anchors data structure reset e.g. when a user pushed an entirely new data set for the dataclass from another machine . The synchronization protocol can avoid being pessimistic and minimize ore eliminate the need to fall back to slow sync whenever a problem occurs.

The synchronization protocol implements various techniques to optimize data sync between the client device and the server . For example optimization techniques include sync phase compression that enables optimistic negotiation and commit implementing multiple dataclass state machines in parallel using sync anchor checkpoints and enable session robustness.

In the example shown in the sync server compresses the push and commit phases by sending its sync changes and sync commit commands for a given dataclass in the same message. In response to sync start and sync change commands the server replies with a sync start command response OK dataclass anchors and sync change command response OK dataclass in the second message . In addition the server can include a sync changes command dataclass changes and a sync commit command dataclass anchors in the second message to complete one round trip. Thus the optimistic approach can complete data synchronization in a single HTTP roundtrip.

A data sync can be completed in two roundtrips when the client device responds to the server s sync changes command in the second message with an optional message for id mapping in the second round trip . The client device can also send a sync commit response in the optional message.

In some implementations the client device may defer sending id mappings to the server until a subsequent session and may omit sending the sync commit response since the server can infer that the commands were received and processed by comparing the sync anchors sent in the subsequent session. shows an example data synchronization between a client and a server where the device omits sending the command response to sync changes or sync commit when the server s previous message was final. In that case any pending id mappings if necessary is sent to the server in the subsequent sync session.

In the first message the client device compresses the negotiation and pull phases as described with respect to . In response the server sends a second message with the push and commit phases compressed as described with respect to . The first session is completed in one round trip.

A second sync session is initiated by the client device with the pull and negotiation phases compressed in the third message . In addition the pending id mappings leftover from the first session is sent to the server . The server responds in the fourth message with sync changes and sync commit commands.

In this slow sync mode the client device sends a sync start command with the dataclass anchors and the slow sync mode identified in the first message . The server responds in the second message with a sync start response. In the third message second round trip the client device sends a sync changes command for a dataclass. The server responds in the next message by including a sync changes response OK dataclass sync changes command dataclass and sync commit command dataclass anchors . In the third round trip the client device sends a sync changes response OK dataclass idmap and a sync commit response OK .

In the example shown in multiple dataclasses such as contacts calendars and bookmarks are synced in parallel. In the first message the client device sends sync start commands for these dataclasses in parallel. In the same message the client device also sends sync changes command for the multiple dataclasses. The server sends a response with sync start responses and sync changes responses for the multiple dataclasses. For example the sync start response from the server states that the calendars dataclass is reset on the server due to a failed negotiation. In addition the sync changes response for the calendars states that the changes have not been processed for the calendars dataclass. The sync start commands for contacts and bookmarks are successful as shown by the OK status of the sync start response. The sync changes commands for contacts and bookmarks have not completed as shown by the S NotCompleted status of the sync changes responses.

In the next message the client device sends another sync start command requesting a reset sync the sync mode requested by the server in the previous calendars sync start command response and sync changes command for the calendar dataclass with an empty items parameter. The server responds in the next message with a sync start response and a sync changes response for the contacts calendars and bookmarks dataclasses a sync changes response for the contacts and bookmarks sync changes command for calendars indicating that more changes are pending and sync commit command for contacts and bookmarks. These two message and make up the second round trip.

The third round trip begins with a message from the client device with sync changes response for contacts calendars and bookmarks. The message includes sync commit responses for the contacts and bookmarks. To complete the third round trip the server sends a sync changes command for dataclasses and sync commit commands to the client device in the next message . Thus in just three transport protocol roundtrips multiple dataclasses syncing sync mode renegotiation calendars were reset on the server and split sync changes calendar changes from the server were sent in message and message can be completed.

An optional fourth roundtrip can be implemented to enable the client device to send a sync changes response for the calendars with idmap and a sync commit response to the server .

The server does not perform the mingle phase until all dataclasses have completed the pull phase i.e. upon receipt of the third message . This enables the server to perform all work in a single sync job. The server sends S NotCompleted for the dataclasses other dataclasses until all the client changes for all dataclasses has been received by the server .

The synchronization protocol uses the sync anchors parameter in the commands and command responses to organize and maintain trackable sync sessions. The server can manage the anchors in the commands and the command responses vis vis its internal versioning methods.

Sync anchors are opaque data that the client device and the server exchange during the sync process. The anchors can be exchanged during the negotiation phase to determine the sync session s sync mode. Then during the commit phase a new set of anchors can be exchanged and persisted for use during the following sync sessions. By comparison other sync protocols use the anchors at the beginning of the sync session and the anchors are updated only when the sync session completes successfully or are rolled back if the session is cancelled or terminates unexpectedly.

Any discrepancy between expected and actual anchors during negotiation known as anchor mismatch can result in a slow sync or at the very least retransmission of all data from the failed sync session. On an unreliable data network this can lead to a situation where no progress can be made and synchronization with the server is effectively blocked from successfully completing a sync until external conditions change. Unexpected session failures can also lead to anchor mismatches on the next sync session.

The OTA synchronization protocol enables the server to optionally return updated anchors at various checkpoints during a sync session. The anchor parameter may be present in any sync family command or command response. A checkpoint anchor contains the next server anchor element and may contain the mode element. This enables fine grained updating of sync anchors to reduce the likelihood and impact of anchor mismatches. Each server anchor is encoded with information that provides the server with precise information regarding the internal server state at the time the anchor was generated. For example the server anchor can be encoded with information on whether the changes requested from the client device have been mingled with the central database. The server anchor can also be encoded with information on which updates have been accepted by the client device . Further the server anchor can be encoded with information on whether the sync session was completed normally. Other internal server states can be encoded in the server anchor.

Example anchor checkpoints can include the end of server mingle phase in response to the client device s final sync changes command. The anchor checkpoints can also include the point during a split sync changes and the commit phase among others.

The server can intelligently decide the time and location to add the checkpoint anchors. When the checkpoint anchors are placed in a sync changes command the checkpoint anchors guarantee that the received data set enforces the data integrity requirements of the dataclass s schema. For example the data integrity requirements can include having no references to unknown entities in a check pointed data set. After the pull phase is complete the most recent checkpoint anchors may be saved by the client device even if the sync session is cancelled.

The sync server will expire the checkpoint anchors when they are no longer needed or when the server needs to release associated server side resources used to maintain the checkpoint state. When the client device supplies an unknown or expired checkpoint anchor the sync session will still fall into slow sync mode.

During the next sync session s negotiation phase the sync start command the client device sends its last saved anchors to the server . The server uses the information encoded in these anchors to start a sync session from the most recent saved checkpoint even if the previous sync session terminated unexpectedly or a sync commit command response was not explicitly returned to the server . When the client device receives such anchors during a sync session the client device retains the most recent anchor from the server and save its value to send in the sync start command for the next sync session.

Upon receiving and processing each message containing an anchors element from the sync server the client device updates its anchor. When the sync session become interrupted or a message lost the client device supplies the last anchor it successfully processed in the sync start command of the next session. Depending on which anchor value is received the sync server can infer which actions must be taken to complete the previous sync as necessary. Thus incremental synchronization progress can be made even on extremely fragile wireless networks or when large data sets need to be sent.

The synchronization protocol provides a mechanism for the server to dynamically request device settings and capabilities. The get and put commands may be used to exchange information. At anytime the server may send a get command with the uri parameter having the value deviceinfo to request device settings and capabilities for example. Alternatively the client device may send a put command with the same uri parameter to the server . The value of the uri parameter is a dictionary containing various key value pairs. When present the value for userid represents the authenticating principle and is implemented as a String. When present the value for authtype represents the authentication scheme and is implemented as a String. When present the value for auth represents the authentication credential and is represented as a String. When the recipient is willing to perform the operation the recipient returns a success status such as status S OK . When the requested URI is unknown the recipient returns a status such as the status E NotFound to indicate the URI was not found and is unknown. When the requested operation is not permitted for example the authorized principle is not allowed to delete the URI the recipient returns a status such as the status E NotAllowed to indicate that the requested operation is not permitted. When the requested operation could not be performed because the supplied data was incorrect the recipient returns a status such as the status E BadValue to indicate that the requested operation could not be performed. When the requested operation could not be performed because the supplied itemtype was incorrect the recipient returns a status such as the status E NotSupported to indicate that the requested operation is not supported.

When the client device first syncs with the server the server requests for device information by sending a get command. Thereafter when the device information changes the client device sends the changed device information to the server by sending a put command.

Filtering is the ability to constrain a set of data items synchronized with the client device based on the values in the data items. For example a user may want to sync only the contacts contained within a certain set of groups or the calendar events within a certain time window surrounding the current date.

In a data sharing managing application such as iTunes filter settings are enforced by the computer during cable syncing to constrain or filter the set of data items sent to the client device such as iPhone . The synchronization protocol provides similar filtering functionality in a wireless sync solution. The same filter settings from iTunes is enforced by the server without requiring any user action. Thus the filtering can be performed automatically. Alternatively a user interface UI on the client device can be presented to the user to enable the user to display and edit the filter settings to be enforced.

The synchronization protocol enables the filter settings to be exchanged between the client device and the server using primitive commands. The filter information is specified using a uri parameter of the form dataclass filter . The value of the filter information is a dictionary.

The default container key describes the identification LUID of the container entity such as the group ID for contacts and calendar ID for events. The constrain containers key describes the set of LUIDs of container entities to include such as the set of Groups to include. The discard after days key describes the number of days after which events older than the described number of days should be deleted.

In the second message the server responds by sending a sync start command response with the status S OK to indicate a successful negotiation for the contacts dataclass. In addition anchors are used to indicate the checkpoint. Also the server sends a sync changes command for the contacts dataclass with the more Boolean flag indicate that not all appropriate data items for the dataclass are included in the command params. Further the second message can be include a put command response with a S OK status indicating a successful put.

In the third message the client device includes a sync changes command response with the S OK status for the contacts dataclass indicated by the uri parameter. Also idmap is included to provide GUID LUID mapping for example. In the fourth message the server sends a sync changes command with the uri parameter indicating the contacts dataclass. Also the more Boolean is included to indicate that more data will follow. In the fifth message the client device sends a sync changes command response with a status S OK to indicate a successful update for the contacts dataclass. In the sixth message the server sends a sync changes command and a sync commit command for the contacts dataclass. The client device responds in the seventh message with a sync changes command response indicating a successful update. The client device also includes a sync commit response OK to indicate the client device has committed the changes. The last message has an empty message body to indicate a sync session s final message.

The server responds to the negotiation phase by sending a message to the client device with a sync start command response. A determination is made on whether the negotiation is a success. The dataclass indicated by the uri parameter is detected and analyzed to determine whether the server supports and enables the dataclass. When detected that the dataclass is not supported an error status such as E NotSupported is generated . The generated error status can be included in the sync start command response to indicate that the dataclass is not supported. When detected that the server does not enable the dataclass an error status such as E NotAllowed is generated . The generated status is included in the sync start command response to indicate that the dataclass is not enabled. When detected that the dataclass is supported and enabled a success status such as S OK is generated . The generated status is included in the sync start command response to indicate that the server supports and enables the dataclass.

When the anchors parameter of the sync start command includes a requested sync mode the requested sync mode is analyzed to determine whether the server accepts the sync mode. When the sync mode is not accepted by the server an error status such as E NegotiationFailed is generated . The generated status is included in the sync start command response to indicate that the requested sync mode is not accepted. The server may decide whether to suggest a different sync mode to use. When the server is willing to sync in a different mode the suggested different mode is included in the anchors parameter in the sync start command response.

When the requested sync mode is accepted a success status such as S OK is generated . The generated success status is included in the sync start command response.

When detected that the negotiation is successful as indicated by the S OK status the sync session proceeds to a pull phase. When the sync mode is fast the client device sends the changed records to the server . When the sync mode is slow all records are sent to the server . The changes are sent using the sync changes stateful commands. The server responds to the sync changes command with the corresponding sync changes command response to indicate whether the changes have been accepted. The success status S OK indicates that the changes have been accepted.

When all changes have been received the server proceeds to the mingle phase. When syncing multiple dataclasses in a single session the sync changes commands for each dataclass will have distinct state machines. However the server waits until all dataclasses have completed the pull phase or cancelled before proceeding to the mingling phase. Any detected invalid changes may be rejected by the server .

During the mingle phase the server decides whether any conflicts exists for the dataclass. When detected that conflicts exist the server decides whether to resolve the conflicts itself or whether to let the user or client device resolve the conflicts. When the server resolves the conflicts the server can rely on heuristics to resolve the conflicts. For example the client device initiating the most recent sync may be selected as the winner.

For some instances such as the dataclass and or data item the user client device may be selected as the one to resolve the conflicts. Then the detected conflicts are sent to the client device to enable the client device to resolve the conflicts. Also the detected conflicts can be presented to the user by displaying the conflicts on a display unit on the client device for example. The user can resolve the conflict manually. The result of the conflict resolution may then be sent from the device to the server during the next sync session.

The changes from the server recipient can be sent to the client device during the push phase . The server can send a message to the client device with sync changes commands to push the changes to the client device .

Finally once all updates have been received the commit phase is entered 4416. Both sides agree that the sync was successful persist their current sync anchors and commit the exchanged data to their respective data stores. In the commit phase messages are sent with sync commit commands and command responses.

Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structures disclosed in this specification and their structural equivalents or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer program products i.e. one or more modules of computer program instructions encoded on a tangible program carrier for execution by or to control the operation of data processing apparatus. The tangible program carrier can be a propagated signal or a computer readable medium. The propagated signal is an artificially generated signal e.g. a machine generated electrical optical or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a computer. The computer readable medium can be a machine readable storage device a machine readable storage substrate a memory device a composition of matter effecting a machine readable propagated signal or a combination of one or more of them.

The term data processing apparatus encompasses all apparatus devices and machines for processing data including by way of example a programmable processor a computer or multiple processors or computers. The apparatus can include in addition to hardware code that creates an execution environment for the computer program in question e.g. code that constitutes processor firmware a protocol stack a database management system an operating system or a combination of one or more of them.

A computer program also known as a program software software application script or code can be written in any form of programming language including compiled or interpreted languages or declarative or procedural languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data e.g. one or more scripts stored in a markup language document in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus can also be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. However a computer need not have such devices. Moreover a computer can be embedded in another device.

Computer readable media suitable for storing computer program instructions and data include all forms of non volatile memory media and memory devices including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user embodiments of the subject matter described in this specification can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example input from the user can be received in any form including acoustic speech or tactile input.

Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described is this specification or any combination of one or more such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN e.g. the Internet.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

While this specification contains many specifics these should not be construed as limitations on the scope of any invention or of what may be claimed but rather as descriptions of features that may be specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover although features may be described above as acting in certain combinations and even initially claimed as such one or more features from a claimed combination can in some cases be excised from the combination and the claimed combination may be directed to a subcombination or variation of a subcombination.

Similarly while operations are depicted in the drawings in a particular order this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order or that all illustrated operations be performed to achieve desirable results. In certain circumstances multitasking and parallel processing may be advantageous. Moreover the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.

Only a few implementations and examples are described and other implementations enhancements and variations can be made based on what is described and illustrated in this application.

