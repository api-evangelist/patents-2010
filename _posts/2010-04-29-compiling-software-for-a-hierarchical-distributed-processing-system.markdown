---

title: Compiling software for a hierarchical distributed processing system
abstract: Compiling software for a hierarchical distributed processing system including providing to one or more compiling nodes software to be compiled, wherein at least a portion of the software to be compiled is to be executed by one or more other nodes; compiling, by the compiling node, the software; maintaining, by the compiling node, any compiled software to be executed on the compiling node; selecting, by the compiling node, one or more nodes in a next tier of the hierarchy of the distributed processing system in dependence upon whether any compiled software is for the selected node or the selected node's descendants; sending to the selected node only the compiled software to be executed by the selected node or selected node's descendant.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08621446&OS=08621446&RS=08621446
owner: International Business Machines Corporation
number: 08621446
owner_city: Armonk
owner_country: US
publication_date: 20100429
---
This invention was made with Government support under Contract No. B554331 awarded by the Department of Energy. The Government has certain rights in this invention.

The field of the invention is data processing or more specifically methods apparatus and products for compiling software for a hierarchical distributed processing system.

The development of the EDVAC computer system of 1948 is often cited as the beginning of the computer era. Since that time computer systems have evolved into extremely complicated devices. Today s computers are much more sophisticated than early systems such as the EDVAC. Computer systems typically include a combination of hardware and software components application programs operating systems processors buses memory input output devices and so on. As advances in semiconductor processing and computer architecture push the performance of the computer higher and higher more sophisticated computer software has evolved to take advantage of the higher performance of the hardware resulting in computer systems today that are much more powerful than just a few years ago.

Distributed computing is an area of computer technology that has experienced advances. Distributed computing generally refers to computing with multiple semi autonomous computer systems that communicate through a data communications network. The semi autonomous computer systems interact with one another in order to achieve a common goal. A computer program or application that executes in a distributed computing system may be referred to as a distributed program. Distributed computing may also refers to the use of distributed computing systems to solve computational problems. In distributed computing a problem may be divided into many tasks each of which may be solved by one of the semi autonomous computer systems.

Some distributed computing systems are optimized to perform parallel computing. Parallel computing is the simultaneous execution of the same task split up and specially adapted on multiple processors in order to obtain results faster. Parallel computing is based on the fact that the process of solving a problem usually can be divided into smaller tasks which may be carried out simultaneously with some coordination.

Parallel computers execute parallel algorithms. A parallel algorithm can be split up to be executed a piece at a time on many different processing devices and then put back together again at the end to get a data processing result. Some algorithms are easy to divide up into pieces. Splitting up the job of checking all of the numbers from one to a hundred thousand to see which are primes could be done for example by assigning a subset of the numbers to each available processor and then putting the list of positive results back together. In this specification the multiple processing devices that execute the individual pieces of a parallel program are referred to as compute nodes. A parallel computer is composed of compute nodes and other processing nodes as well including for example input output I O nodes and service nodes.

Parallel algorithms are valuable because it is faster to perform some kinds of large computing tasks via a parallel algorithm than it is via a serial non parallel algorithm because of the way modern processors work. It is far more difficult to construct a computer with a single fast processor than one with many slow processors with the same throughput. There are also certain theoretical limits to the potential speed of serial processors. On the other hand every parallel algorithm has a serial part and so parallel algorithms have a saturation point. After that point adding more processors does not yield any more throughput but only increases the overhead and cost.

Parallel algorithms are designed also to optimize one more resource the data communications requirements among the nodes of a parallel computer. There are two ways parallel processors communicate shared memory or message passing. Shared memory processing needs additional locking for the data and imposes the overhead of additional processor and bus cycles and also serializes some portion of the algorithm.

Message passing processing uses high speed data communications networks and message buffers but this communication adds transfer overhead on the data communications networks as well as additional memory need for message buffers and latency in the data communications among nodes. Designs of parallel computers use specially designed data communications links so that the communication overhead will be small but it is the parallel algorithm that decides the volume of the traffic.

Many data communications network architectures are used for message passing among nodes in parallel computers. Compute nodes may be organized in a network as a torus or mesh for example. Also compute nodes may be organized in a network as a tree. A torus network connects the nodes in a three dimensional mesh with wrap around links. Every node is connected to its six neighbors through this torus network and each node is addressed by its x y z coordinate in the mesh. In such a manner a torus network lends itself to point to point operations. In a tree network the nodes typically are connected into a binary tree each node has a parent and two children although some nodes may only have zero children or one child depending on the hardware configuration . Although a tree network typically is inefficient in point to point communication a tree network does provide high bandwidth and low latency for certain collective operations message passing operations where all compute nodes participate simultaneously such as for example an allgather operation. In computers that use a torus and a tree network the two networks typically are implemented independently of one another with separate routing circuits separate physical links and separate message buffers.

Methods apparatus and products for compiling software for a hierarchical distributed processing system including providing to one or more compiling nodes software to be compiled wherein at least a portion of the software to be compiled is to be executed by one or more other nodes compiling by the compiling node the software maintaining by the compiling node any compiled software to be executed on the compiling node selecting by the compiling node one or more nodes in a next tier of the hierarchy of the distributed processing system in dependence upon whether any compiled software is for the selected node or the selected node s descendants sending to the selected node only the compiled software to be executed by the selected node or selected node s descendant receiving by a selected node compiled software determining whether the compiled software is for the selected node or one of its descendants if the compiled software is for the selected node maintaining the software by the selected node for execution and if the compiled software is for one of the descendants selecting another node in a next tier of the hierarchical distributed processing system in dependence upon a descendant for the compiled software and sending the compiled software to the selected another node.

The foregoing and other objects features and advantages of the invention will be apparent from the following more particular descriptions of exemplary embodiments of the invention as illustrated in the accompanying drawings wherein like reference numbers generally represent like parts of exemplary embodiments of the invention.

Exemplary methods apparatus and products for compiling software for a hierarchical distributed processing system in accordance with embodiments of the present invention are described with reference to the accompanying drawings beginning with . illustrates an exemplary distributed computing system for compiling software for a hierarchical distributed processing system according to embodiments of the present invention. The system of includes a parallel computer non volatile memory for the computer in the form of data storage device an output device for the computer in the form of printer and an input output device for the computer in the form of computer terminal . Parallel computer in the example of includes a plurality of compute nodes .

The compute nodes are coupled for data communications by several independent data communications networks including a Joint Test Action Group JTAG network a global combining network which is optimized for collective operations and a torus network which is optimized point to point operations. The global combining network is a data communications network that includes data communications links connected to the compute nodes so as to organize the compute nodes as a tree. Each data communications network is implemented with data communications links among the compute nodes . The data communications links provide data communications for parallel operations among the compute nodes of the parallel computer. The links between compute nodes are bi directional links that are typically implemented using two separate directional data communications paths.

In addition the compute nodes of parallel computer are organized into at least one operational group of compute nodes for collective parallel operations on parallel computer . An operational group of compute nodes is the set of compute nodes upon which a collective parallel operation executes. Collective operations are implemented with data communications among the compute nodes of an operational group. Collective operations are those functions that involve all the compute nodes of an operational group. A collective operation is an operation a message passing computer program instruction that is executed simultaneously that is at approximately the same time by all the compute nodes in an operational group of compute nodes. Such an operational group may include all the compute nodes in a parallel computer or a subset all the compute nodes. Collective operations are often built around point to point operations. A collective operation requires that all processes on all compute nodes within an operational group call the same collective operation with matching arguments. A broadcast is an example of a collective operation for moving data among compute nodes of an operational group. A reduce operation is an example of a collective operation that executes arithmetic or logical functions on data distributed among the compute nodes of an operational group. An operational group may be implemented as for example an MPI communicator. 

 MPI refers to Message Passing Interface a prior art parallel communications library a module of computer program instructions for data communications on parallel computers. Examples of prior art parallel communications libraries that may be improved for use with systems according to embodiments of the present invention include MPI and the Parallel Virtual Machine PVM library. PVM was developed by the University of Tennessee The Oak Ridge National Laboratory and Emory University. MPI is promulgated by the MPI Forum an open group with representatives from many organizations that define and maintain the MPI standard. MPI at the time of this writing is a de facto standard for communication among compute nodes running a parallel program on a distributed memory parallel computer. This specification sometimes uses MPI terminology for ease of explanation although the use of MPI as such is not a requirement or limitation of the present invention.

Some collective operations have a single originating or receiving process running on a particular compute node in an operational group. For example in a broadcast collective operation the process on the compute node that distributes the data to all the other compute nodes is an originating process. In a gather operation for example the process on the compute node that received all the data from the other compute nodes is a receiving process. The compute node on which such an originating or receiving process runs is referred to as a logical root.

Most collective operations are variations or combinations of four basic operations broadcast gather scatter and reduce. The interfaces for these collective operations are defined in the MPI standards promulgated by the MPI Forum. Algorithms for executing collective operations however are not defined in the MPI standards. In a broadcast operation all processes specify the same root process whose buffer contents will be sent. Processes other than the root specify receive buffers. After the operation all buffers contain the message from the root process.

In a scatter operation the logical root divides data on the root into segments and distributes a different segment to each compute node in the operational group. In scatter operation all processes typically specify the same receive count. The send arguments are only significant to the root process whose buffer actually contains sendcount N elements of a given data type where N is the number of processes in the given group of compute nodes. The send buffer is divided and dispersed to all processes including the process on the logical root . Each compute node is assigned a sequential identifier termed a rank. After the operation the root has sent sendcount data elements to each process in increasing rank order. Rank receives the first sendcount data elements from the send buffer. Rank receives the second sendcount data elements from the send buffer and so on.

A gather operation is a many to one collective operation that is a complete reverse of the description of the scatter operation. That is a gather is a many to one collective operation in which elements of a datatype are gathered from the ranked compute nodes into a receive buffer in a root node.

A reduce operation is also a many to one collective operation that includes an arithmetic or logical function performed on two data elements. All processes specify the same count and the same arithmetic or logical function. After the reduction all processes have sent count data elements from computer node send buffers to the root process. In a reduction operation data elements from corresponding send buffer locations are combined pair wise by arithmetic or logical operations to yield a single corresponding element in the root process s receive buffer. Application specific reduction operations can be defined at runtime. Parallel communications libraries may support predefined operations. MPI for example provides the following pre defined reduction operations 

In addition to compute nodes the parallel computer includes input output I O nodes coupled to compute nodes through the global combining network . The compute nodes in the parallel computer are partitioned into processing sets such that each compute node in a processing set is connected for data communications to the same I O node. Each processing set therefore is composed of one I O node and a subset of compute nodes . The ratio between the number of compute nodes to the number of I O nodes in the entire system typically depends on the hardware configuration for the parallel computer. For example in some configurations each processing set may be composed of eight compute nodes and one I O node. In some other configurations each processing set may be composed of sixty four compute nodes and one I O node. Such example are for explanation only however and not for limitation. Each I O nodes provide I O services between compute nodes of its processing set and a set of I O devices. In the example of the I O nodes are connected for data communications I O devices through local area network LAN implemented using high speed Ethernet.

The parallel computer of also includes a service node coupled to the compute nodes through one of the networks . Service node provides services common to pluralities of compute nodes administering the configuration of compute nodes loading programs into the compute nodes starting program execution on the compute nodes retrieving results of program operations on the computer nodes and so on. Service node runs a service application and communicates with users through a service application interface that runs on computer terminal .

In the example of one of the compute nodes has installed upon it a hierarchical distributed compiler a module of automated computing machinery capable of compiling software for a hierarchical distributed processing system according to embodiments of the present invention. The hierarchical distributed compiler includes computer program instruction for compiling by the compiling node the software maintaining by the compiling node any compiled software to be executed on the compiling node selecting by the compiling node one or more nodes in a next tier of the hierarchy of the distributed processing system in dependence upon whether any compiled software is for the selected node or the selected node s descendants sending to the selected node only the compiled software to be executed by the selected node or selected node s descendant. Each of the other compute nodes of are also capable of receiving compiled software determining whether the compiled software is for that node or one of its descendants if the compiled software is for that node maintaining the software for execution and if the compiled software is for one of the descendants selecting another node in a next tier of the hierarchical distributed processing system in dependence upon a descendant for the compiled software and sending the compiled software to the selected another node.

The arrangement of nodes networks and I O devices making up the exemplary system illustrated in are for explanation only not for limitation of the present invention. Data processing systems capable of compiling software for a hierarchical distributed processing system according to embodiments of the present invention may include additional nodes networks devices and architectures not shown in as will occur to those of skill in the art. Although the parallel computer in the example of includes sixteen compute nodes readers will note that parallel computers capable of compiling software for a hierarchical distributed processing system according to embodiments of the present invention may include any number of compute nodes. In addition to Ethernet and JTAG networks in such data processing systems may support many data communications protocols including for example TCP Transmission Control Protocol IP Internet Protocol and others as will occur to those of skill in the art. Various embodiments of the present invention may be implemented on a variety of hardware platforms in addition to those illustrated in .

Compiling software for a hierarchical distributed processing system according to embodiments of the present invention may be generally implemented on a parallel computer that includes a plurality of compute nodes. In fact such computers may include thousands of such compute nodes. Each compute node is in turn itself a kind of computer composed of one or more computer processors or processing cores its own computer memory and its own input output adapters. For further explanation therefore sets forth a block diagram of an exemplary compute node useful in a parallel computer capable of compiling software for a hierarchical distributed processing system according to embodiments of the present invention. The compute node of includes one or more processing cores as well as random access memory RAM . The processing cores are connected to RAM through a high speed memory bus and through a bus adapter and an extension bus to other components of the compute node . Stored in RAM is an application program a module of computer program instructions that carries out parallel user level data processing using parallel algorithms.

Also stored in RAM is a messaging module a library of computer program instructions that carry out parallel communications among compute nodes including point to point operations as well as collective operations. Application program executes collective operations by calling software routines in the messaging module . A library of parallel communications routines may be developed from scratch for use in systems according to embodiments of the present invention using a traditional programming language such as the C programming language and using traditional programming methods to write parallel communications routines that send and receive data among nodes on two independent data communications networks. Alternatively existing prior art libraries may be improved to operate according to embodiments of the present invention. Examples of prior art parallel communications libraries include the Message Passing Interface MPI library and the Parallel Virtual Machine PVM library.

Also stored in RAM is a hierarchical distributed compiler a module of automated computing machinery capable of compiling software for a hierarchical distributed processing system according to embodiments of the present invention. The hierarchical distributed compiler includes computer program instruction for compiling by the compiling node the software maintaining by the compiling node any compiled software to be executed on the compiling node selecting by the compiling node one or more nodes in a next tier of the hierarchy of the distributed processing system in dependence upon whether any compiled software is for the selected node or the selected node s descendants sending to the selected node only the compiled software to be executed by the selected node or selected node s descendant. Each of the other compute nodes in a parallel computer are also capable of receiving compiled software determining whether the compiled software is for that node or one of its descendants if the compiled software is for that node maintaining the software for execution and if the compiled software is for one of the descendants selecting another node in a next tier of the hierarchical distributed processing system in dependence upon a descendant for the compiled software and sending the compiled software to the selected another node.

Also stored in RAM is an operating system a module of computer program instructions and routines for an application program s access to other resources of the compute node. It is typical for an application program and parallel communications library in a compute node of a parallel computer to run a single thread of execution with no user login and no security issues because the thread is entitled to complete access to all resources of the node. The quantity and complexity of tasks to be performed by an operating system on a compute node in a parallel computer therefore are smaller and less complex than those of an operating system on a serial computer with many threads running simultaneously. In addition there is no video I O on the compute node of another factor that decreases the demands on the operating system. The operating system may therefore be quite lightweight by comparison with operating systems of general purpose computers a pared down version as it were or an operating system developed specifically for operations on a particular parallel computer. Operating systems that may usefully be improved simplified for use in a compute node include UNIX Linux Microsoft XP AIX IBM s i5 OS and others as will occur to those of skill in the art.

The exemplary compute node of includes several communications adapters for implementing data communications with other nodes of a parallel computer. Such data communications may be carried out serially through RS 232 connections through external buses such as Universal Serial Bus USB through data communications networks such as IP networks and in other ways as will occur to those of skill in the art. Communications adapters implement the hardware level of data communications through which one computer sends data communications to another computer directly or through a network. Examples of communications adapters useful in systems that for compiling software for a hierarchical distributed processing system according to embodiments of the present invention include modems for wired communications Ethernet IEEE 802.3 adapters for wired network communications and 802.11b adapters for wireless network communications.

The data communications adapters in the example of include a Gigabit Ethernet adapter that couples example compute node for data communications to a Gigabit Ethernet . Gigabit Ethernet is a network transmission standard defined in the IEEE 802.3 standard that provides a data rate of 1 billion bits per second one gigabit . Gigabit Ethernet is a variant of Ethernet that operates over multimode fiber optic cable single mode fiber optic cable or unshielded twisted pair.

The data communications adapters in the example of include a JTAG Slave circuit that couples example compute node for data communications to a JTAG Master circuit . JTAG is the usual name used for the IEEE 1149.1 standard entitled Standard Test Access Port and Boundary Scan Architecture for test access ports used for testing printed circuit boards using boundary scan. JTAG is so widely adapted that at this time boundary scan is more or less synonymous with JTAG. JTAG is used not only for printed circuit boards but also for conducting boundary scans of integrated circuits and is also useful as a mechanism for debugging embedded systems providing a convenient back door into the system. The example compute node of may be all three of these It typically includes one or more integrated circuits installed on a printed circuit board and may be implemented as an embedded system having its own processor its own memory and its own I O capability. JTAG boundary scans through JTAG Slave may efficiently configure processor registers and memory in compute node for use in compiling software for a hierarchical distributed processing system according to embodiments of the present invention.

The data communications adapters in the example of includes a Point To Point Adapter that couples example compute node for data communications to a network that is optimal for point to point message passing operations such as for example a network configured as a three dimensional torus or mesh. Point To Point Adapter provides data communications in six directions on three communications axes x y and z through six bidirectional links x x y y z and z .

The data communications adapters in the example of includes a Global Combining Network Adapter that couples example compute node for data communications to a network that is optimal for collective message passing operations on a global combining network configured for example as a binary tree. The Global Combining Network Adapter provides data communications through three bidirectional links two to children nodes and one to a parent node .

Example compute node includes two arithmetic logic units ALUs . ALU is a component of each processing core and a separate ALU is dedicated to the exclusive use of Global Combining Network Adapter for use in performing the arithmetic and logical functions of reduction operations. Computer program instructions of a reduction routine in parallel communications library may latch an instruction for an arithmetic or logical function into instruction register . When the arithmetic or logical function of a reduction operation is a sum or a logical or for example Global Combining Network Adapter may execute the arithmetic or logical operation by use of ALU in processor or typically much faster by use dedicated ALU .

The example compute node of includes a direct memory access DMA controller which is computer hardware for direct memory access and a DMA engine which is computer software for direct memory access. The DMA engine of is typically stored in computer memory of the DMA controller . Direct memory access includes reading and writing to memory of compute nodes with reduced operational burden on the central processing units . A DMA transfer essentially copies a block of memory from one location to another typically from one compute node to another. While the CPU may initiate the DMA transfer the CPU does not execute it.

For further explanation illustrates an exemplary Point To Point Adapter useful in systems capable of compiling software for a hierarchical distributed processing system according to embodiments of the present invention. Point To Point Adapter is designed for use in a data communications network optimized for point to point operations a network that organizes compute nodes in a three dimensional torus or mesh. Point To Point Adapter in the example of provides data communication along an x axis through four unidirectional data communications links to and from the next node in the x direction and to and from the next node in the x direction . Point To Point Adapter also provides data communication along a y axis through four unidirectional data communications links to and from the next node in the y direction and to and from the next node in the y direction . Point To Point Adapter in also provides data communication along a z axis through four unidirectional data communications links to and from the next node in the z direction and to and from the next node in the z direction .

For further explanation illustrates an exemplary Global Combining Network Adapter useful in systems capable of compiling software for a hierarchical distributed processing system according to embodiments of the present invention. Global Combining Network Adapter is designed for use in a network optimized for collective operations a network that organizes compute nodes of a parallel computer in a binary tree. Global Combining Network Adapter in the example of provides data communication to and from two children nodes through four unidirectional data communications links . Global Combining Network Adapter also provides data communication to and from a parent node through two unidirectional data communications links .

For further explanation sets forth a line drawing illustrating an exemplary data communications network optimized for point to point operations useful in systems capable of compiling software for a hierarchical distributed processing system in accordance with embodiments of the present invention. In the example of dots represent compute nodes of a parallel computer and the dotted lines between the dots represent data communications links between compute nodes. The data communications links are implemented with point to point data communications adapters similar to the one illustrated for example in with data communications links on three axes x y and z and to and fro in six directions x x y y z and z . The links and compute nodes are organized by this data communications network optimized for point to point operations into a three dimensional mesh . The mesh has wrap around links on each axis that connect the outermost compute nodes in the mesh on opposite sides of the mesh . These wrap around links form part of a torus . Each compute node in the torus has a location in the torus that is uniquely specified by a set of x y z coordinates. Readers will note that the wrap around links in the y and z directions have been omitted for clarity but are configured in a similar manner to the wrap around link illustrated in the x direction. For clarity of explanation the data communications network of is illustrated with only 27 compute nodes but readers will recognize that a data communications network optimized for point to point operations for use in compiling software for a hierarchical distributed processing system in accordance with embodiments of the present invention may contain only a few compute nodes or may contain thousands of compute nodes.

For further explanation sets forth a line drawing illustrating an exemplary data communications network optimized for collective operations useful in systems capable of compiling software for a hierarchical distributed processing system in accordance with embodiments of the present invention. The example data communications network of includes data communications links connected to the compute nodes so as to organize the compute nodes as a tree. In the example of dots represent compute nodes of a parallel computer and the dotted lines between the dots represent data communications links between compute nodes. The data communications links are implemented with global combining network adapters similar to the one illustrated for example in with each node typically providing data communications to and from two children nodes and data communications to and from a parent node with some exceptions. Nodes in a binary tree may be characterized as a physical root node branch nodes and leaf nodes . The root node has two children but no parent. The leaf nodes each has a parent but leaf nodes have no children. The branch nodes each has both a parent and two children. The links and compute nodes are thereby organized by this data communications network optimized for collective operations into a binary tree . For clarity of explanation the data communications network of is illustrated with only 31 compute nodes but readers will recognize that a data communications network optimized for collective operations for use in systems for compiling software for a hierarchical distributed processing system in accordance with embodiments of the present invention may contain only a few compute nodes or may contain thousands of compute nodes.

In the example of each node in the tree is assigned a unit identifier referred to as a rank . A node s rank uniquely identifies the node s location in the tree network for use in both point to point and collective operations in the tree network. The ranks in this example are assigned as integers beginning with 0 assigned to the root node 1 assigned to the first node in the second layer of the tree 2 assigned to the second node in the second layer of the tree 3 assigned to the first node in the third layer of the tree 4 assigned to the second node in the third layer of the tree and so on. For ease of illustration only the ranks of the first three layers of the tree are shown here but all compute nodes in the tree network are assigned a unique rank.

For further explanation sets forth a further exemplary distributed computing system for compiling software for a hierarchical distributed processing system according to embodiments of the present invention in which the distributed computing system is implemented as a hybrid computing environment. A hybrid computing environment as the term is used in this specification is a computing environment in that it includes computer processors operatively coupled to computer memory so as to implement data processing in the form of execution of computer program instructions stored in the memory and executed on the processors. The hybrid computing environment of includes one compute node that represents a small separate hybrid computing environment which when taken with other similar compute nodes together make up a larger hybrid computing environment.

The example compute node of may carry out principal user level computer program execution accepting administrative services such as initial program loads and the like from a service application executing on a service node connected to the compute node through a data communications network. The example compute node may also be coupled for data communications to one or more input output I O nodes that enable the compute node to gain access to data storage and other I O functionality. The I O nodes and service node may be connected to the example compute node to other compute nodes in the larger hybrid computing environment and to I O devices through a local area network LAN implemented using high speed Ethernet or a data communications fabric of another fabric type as will occur to those of skill in the art. I O devices useful in a larger hybrid computing environment that includes the compute node may include non volatile memory for the computing environment in the form of data storage device an output device for the hybrid computing environment in the form of printer and a user I O device in the form of computer terminal that executes a service application interface that provides to a user an interface for configuring compute nodes in the hybrid computing environment and initiating execution by the compute nodes of principal user level computer program instructions.

The compute node in the example of is illustrated in an expanded view to aid a more detailed explanation of a hybrid computing environment that may be combined with other hybrid computing environments such as the other compute nodes to form a larger hybrid computing environment. The compute node in the example of includes a host computer . A host computer is a host in the sense that it is the host computer that carries out interface functions between a compute node and other components of the hybrid computing environment external to any particular compute node. That is it is the host computer that executes initial boot procedures power on self tests basic I O functions accepts user level program loads from service nodes and so on.

The host computer in the example of includes a computer processor operatively coupled to computer memory Random Access Memory RAM through a high speed memory bus . The processor in each host computer has a set of architectural registers that defines the host computer architecture.

The example compute node of also includes one or more accelerators . An accelerator is an accelerator in that each accelerator has an accelerator architecture that is optimized with respect to the host computer architecture for speed of execution of a particular class of computing functions. Such accelerated computing functions include for example vector processing floating point operations and others as will occur to those of skill in the art. Each accelerator in the example of includes a computer processor operatively coupled to RAM through a high speed memory bus . Stored in RAM of the host computer and the accelerators is an operating system . Operating systems useful in host computers and accelerators of hybrid computing environments according to embodiments of the present invention include UNIX Linux Microsoft XP Microsoft Vista Microsoft NT AIX IBM s i5 OS and others as will occur to those of skill in the art. There is no requirement that the operating system in the host computers should be the same operating system used on the accelerators.

The processor of each accelerator has a set of architectural registers that defines the accelerator architecture. The architectural registers of the processor of each accelerator are different from the architectural registers of the processor in the host computer . The architectural registers are registers that are accessible by computer program instructions that execute on each architecture registers such as an instruction register a program counter memory index registers stack pointers and the like. With differing architectures it would be uncommon although possible for a host computer and an accelerator to support the same instruction sets. As such computer program instructions compiled for execution on the processor of an accelerator generally would not be expected to execute natively on the processor of the host computer and vice versa. Moreover because of the typical differences in hardware architectures between host processors and accelerators computer program instructions compiled for execution on the processor of a host computer generally would not be expected to execute natively on the processor of an accelerator even if the accelerator supported the instruction set of the host. The accelerator architecture in example of is optimized with respect to the host computer architecture for speed of execution of a particular class of computing functions. That is for the function or functions for which the accelerator is optimized execution of those functions will proceed faster on the accelerator than if they were executed on the processor of the host computer.

Examples of hybrid computing environments include a data processing system that in turn includes one or more host computers each having an x86 processor and accelerators whose architectural registers implement the PowerPC instruction set. Computer program instructions compiled for execution on the x86 processors in the host computers cannot be executed natively by the PowerPC processors in the accelerators. Readers will recognize in addition that some of the example hybrid computing environments described in this specification are based upon the Los Alamos National Laboratory LANL supercomputer architecture developed in the LANL Roadrunner project named for the state bird of New Mexico the supercomputer architecture that famously first generated a petaflop a million billion floating point operations per second. The LANL supercomputer architecture includes many host computers with dual core AMD Opteron processors coupled to many accelerators with IBM Cell processors the Opteron processors and the Cell processors having different architectures.

In the example of the host computer and the accelerators are adapted to one another for data communications by a system level message passing module SLMPM and two data communications fabrics of at least two different fabric types. A data communications fabric is a configuration of data communications hardware and software that implements a data communications coupling between a host computer and an accelerator. Examples of data communications fabric types include Peripheral Component Interconnect PCI PCI express PCIe Ethernet Infiniband Fibre Channel Small Computer System Interface SCSI External Serial Advanced Technology Attachment eSATA Universal Serial Bus USB and so on as will occur to those of skill in the art. In the example of the host computer and the accelerators are adapted to one another for data communications by a PCIe fabric through PCIe communications adapters and an Ethernet fabric through Ethernet communications adapters . The use of PCIe and Ethernet is for explanation not for limitation of the invention. Readers of skill in the art will immediately recognize that hybrid computing environments according to embodiments of the present invention may include fabrics of other fabric types such as for example PCI Infiniband Fibre Channel SCSI eSATA USB and so on.

An SLMPM is a module or library of computer program instructions that exposes an application programming interface API to user level applications for carrying out message based data communications between the host computer and the accelerator . Examples of message based data communications libraries that may be improved for use as an SLMPM according to embodiments of the present invention include 

In this example to support message based data communications between the host computer and the accelerator both the host computer and the accelerator have an SLMPM so that message based communications can both originate and be received on both sides of any coupling for data communications.

The SLMPM in this example operates generally for data processing in a hybrid computing environment by monitoring data communications performance for a plurality of data communications modes between the host computer and the accelerators receiving a request to transmit data according to a data communications mode from the host computer to an accelerator determining whether to transmit the data according to the requested data communications mode and if the data is not to be transmitted according to the requested data communications mode selecting another data communications mode and transmitting the data according to the selected data communications mode. In the example of the monitored performance is illustrated as monitored performance data stored by the SLMPM in RAM of the host computer during operation of the compute node .

A data communications mode specifies a data communications fabric type a data communications link and a data communications protocol . A data communications link is data communications connection between a host computer and an accelerator. In the example of a link between the host computer and the accelerator may include the PCIe connection or the Ethernet connection through the Ethernet network . A link between the host computer and the accelerator in the example of may include the PCIe connection or the Ethernet connection through the Ethernet network . Although only one link for each fabric type is illustrated between the host computer and the accelerator in the example of readers of skill in the art will immediately recognize that there may any number of links for each fabric type.

A data communications protocol is a set of standard rules for data representation signaling authentication and error detection required to send information from a host computer to an accelerator . In the example of the SLMPM may select one of several protocols for data communications between the host computer and the accelerator. Examples of such protocols include shared memory transfers SMT executed with a send and receive operations and direct memory access DMA executed with PUT and GET operations .

Shared memory transfer is a data communications protocol for passing data between a host computer and an accelerator into shared memory space allocated for such a purpose such that only one instance of the data resides in memory at any time. Consider the following as an example shared memory transfer between the host computer and the accelerator of . An application requests a transmission of data from the host computer to the accelerator in accordance with the SMT protocol. Such a request may include a memory address allocated for such shared memory. In this example the shared memory segment is illustrated in a memory location on the accelerator but readers will recognize that shared memory segments may be located on the accelerator on the host computer on both the host computer and the accelerator or even off the local compute node entirely so long as the segment is accessible as needed by the host and the accelerator. To carry out a shared memory transfer the SLMPM on the host computer establishes a data communications connection with the SLMPM executing on the accelerator by a handshaking procedure similar to that in the TCP protocol. The SLMPM then creates a message that includes a header and a payload data and inserts the message into a message transmit queue for a particular link of a particular fabric. In creating the message the SLMPM inserts in the header of the message an identification of the accelerator and an identification of a process executing on the accelerator. The SLMPM also inserts the memory address from the request into the message either in the header or as part of the payload data. The SLMPM also inserts the data to be transmitted in the message as part of the message payload data. The message is then transmitted by a communications adapter across a fabric to the SLMPM executing on the accelerator where the SLMPM stores the payload data the data that was transmitted in shared memory space in RAM in accordance with the memory address in the message.

Direct memory access DMA is a data communications protocol for passing data between a host computer and an accelerator with reduced operational burden on the computer processor . A DMA transfer essentially effects a copy of a block of memory from one location to another typically from a host computer to an accelerator or vice versa. Either or both a host computer and accelerator may include DMA controller and DMA engine an aggregation of computer hardware and software for direct memory access. Direct memory access includes reading and writing to memory of accelerators and host computers with reduced operational burden on their processors. A DMA engine of an accelerator for example may write to or read from memory allocated for DMA purposes while the processor of the accelerator executes computer program instructions or otherwise continues to operate. That is a computer processor may issue an instruction to execute a DMA transfer but the DMA engine not the processor carries out the transfer.

In the example of only the accelerator includes a DMA controller and DMA engine while the host computer does not. In this embodiment the processor on the host computer initiates a DMA transfer of data from the host to the accelerator by sending a message according to the SMT protocol to the accelerator instructing the accelerator to perform a remote GET operation. The configuration illustrated in the example of in which the accelerator is the only device containing a DMA engine is for explanation only not for limitation. Readers of skill in the art will immediately recognize that in many embodiments both a host computer and an accelerator may include a DMA controller and DMA engine while in yet other embodiments only a host computer includes a DMA controller and DMA engine.

To implement a DMA protocol in the hybrid computing environment of some memory region is allocated for access by the DMA engine. Allocating such memory may be carried out independently from other accelerators or host computers or may be initiated by and completed in cooperation with another accelerator or host computer. Shared memory regions allocated according to the SMA protocol for example may be memory regions made available to a DMA engine. That is the initial setup and implementation of DMA data communications in the hybrid computing environment of may be carried out at least in part through shared memory transfers or another out of band data communications protocol out of band with respect to a DMA engine. Allocation of memory to implement DMA transfers is relatively high in latency but once allocated the DMA protocol provides for high bandwidth data communications that requires less processor utilization than many other data communications protocols.

A direct PUT operation is a mode of transmitting data from a DMA engine on an origin device to a DMA engine on a target device. A direct PUT operation allows data to be transmitted and stored on the target device with little involvement from the target device s processor. To effect minimal involvement from the target device s processor in the direct PUT operation the origin DMA engine transfers the data to be stored on the target device along with a specific identification of a storage location on the target device. The origin DMA knows the specific storage location on the target device because the specific storage location for storing the data on the target device has been previously provided by the target DMA engine to the origin DMA engine.

A remote GET operation sometimes denominated an rGET is another mode of transmitting data from a DMA engine on an origin device to a DMA engine on a target device. A remote GET operation allows data to be transmitted and stored on the target device with little involvement from the origin device s processor. To effect minimal involvement from the origin device s processor in the remote GET operation the origin DMA engine stores the data in an storage location accessible by the target DMA engine notifies the target DMA engine directly or out of band through a shared memory transmission of the storage location and the size of the data ready to be transmitted and the target DMA engine retrieves the data from storage location.

Monitoring data communications performance for a plurality of data communications modes may include monitoring a number of requests in a message transmit request queue for a data communications link . In the example of each message transmit request queue is associated with one particular data communications link . Each queue includes entries for messages that include data to be transmitted by the communications adapters along a data communications link associated with queue.

Monitoring data communications performance for a plurality of data communications modes may also include monitoring utilization of a shared memory space . In the example of shared memory space is allocated in RAM of the accelerator. Utilization is the proportion of the allocated shared memory space to which data has been stored for sending to a target device and has not yet been read or received by the target device monitored by tracking the writes and reads to and from the allocated shared memory. In the hybrid computing environment of shared memory space any memory in fact is limited. As such a shared memory space may be filled during execution of an application program such that transmission of data from the host computer to an accelerator may be slowed or even stopped due to space limitations in the shared memory space.

In some embodiments of the present invention the hybrid computing environment of may be configured to operate as a parallel computing environment in which two or more instances the application program executes on two or more host computers in the parallel computing environment. In such embodiments monitoring data communications performance across data communications modes may also include aggregating data communications performance information across a plurality of instances of the application program executing on two or more host computers in a parallel computing environment. The aggregated performance information may be used to calculate average communications latencies for data communications modes average number of requests in data communications links of a particular fabric type average shared memory utilization among the plurality of host computers and accelerators in the parallel computing environment and so on as will occur to those of skill in the art. Any combination of such measures may be used by the SLMPM for both determining whether to transmit the data according to requested data communications mode and selecting another data communications mode for transmitting the data if the data is not to be transmitted according to the requested data communications mode.

The SLMPM of receives from an application program on the host computer a request to transmit data according to a data communications mode from the host computer to the accelerator . Such data may include computer program instructions compiled for execution by the accelerator such as an executable file of an accelerator application program work piece data for an accelerator application program files necessary for execution of an accelerator application program such as libraries databases drivers and the like. Receiving a request to transmit data according to a data communications mode may include receiving a request to transmit data by a specified fabric type receiving a request to transmit data through a specified data communications link from the host computer to the accelerator or receiving a request to transmit data from the host computer to the accelerator according to a protocol.

A request to transmit data according to a data communications mode may be implemented as a user level application function call through an API to the SLMPM a call that expressly specifies a data communications mode according to protocol fabric type and link. A request implemented as a function call may specify a protocol according to the operation of the function call itself. A dacs put function call for example may represent a call through an API exposed by an SLMPM implemented as a DACS library to transmit data in the default mode of a DMA PUT operation. Such a call from the perspective of the calling application and the programmer who wrote the calling application represents a request to the SLMPM library to transmit data according to the default mode known to the programmer to be default mode associated with the express API call. The called function in this example dacs put may be coded in embodiments with multiple fabric types protocols and links to make its own determination whether to transmit the data according to the requested data communications mode that is according to the default mode of the called function. In a further example a dacs send instruction may represent a call through an API exposed by an SLMPM implemented as a DACS library to transmit data in the default mode of an SMT send operation where the called function dacs send is again coded in embodiments with multiple fabric types protocols and links to make its own determination whether to transmit the data according to the requested mode.

An identification of a particular accelerator in a function call may effectively specify a fabric type. Such a function call may include as a call parameters an identification of a particular accelerator. An identification of a particular accelerator by use of a PCIe ID for example effectively specifies a PCI fabric type. In another similar example an identification of a particular accelerator by use of a media access control MAC address of an Ethernet adapter effectively specifies the Ethernet fabric type. Instead of implementing the accelerator ID of the function call from an application executing on the host in such a way as to specify a fabric type the function call may only include a globally unique identification of the particular accelerator as a parameter of the call thereby specifying only a link from the host computer to the accelerator not a fabric type. In this case the function called may implement a default fabric type for use with a particular protocol. If the function called in the SLMPM is configured with PCIe as a default fabric type for use with the DMA protocol for example and the SLMPM receives a request to transmit data to the accelerator according to the DMA protocol a DMA PUT or DMA remote GET operation the function called explicitly specifies the default fabric type for DMA the PCIe fabric type.

In hybrid computing environments in which only one link of each fabric type adapts a single host computer to a single accelerator the identification of a particular accelerator in a parameter of a function call may also effectively specify a link. In hybrid computing environments where more than one link of each fabric type adapts a host computer and an accelerator such as two PCIe links connecting the host computer to the accelerator the SLMPM function called may implement a default link for the accelerator identified in the parameter of the function call for the fabric type specified by the identification of the accelerator.

The SLMPM in the example of also determines in dependence upon the monitored performance whether to transmit the data according to the requested data communications mode. Determining whether to transmit the data according to the requested data communications mode may include determining whether to transmit data by a requested fabric type whether to transmit data through a requested data communications link or whether to transmit data according to a requested protocol.

In hybrid computing environments according to embodiments of the present invention where monitoring data communications performance across data communications modes includes monitoring a number of requests in a message transmit request queue for a data communications link determining whether to transmit the data according to the requested data communications mode may be carried out by determining whether the number of requests in the message transmit request queue exceeds a predetermined threshold. In hybrid computing environments according to embodiments of the present invention where monitoring data communications performance for a plurality of data communications modes includes monitoring utilization of a shared memory space determining whether to transmit the data according to the requested data communications mode may be carried out by determining whether the utilization of the shared memory space exceeds a predetermined threshold.

If the data is not to be transmitted according to the requested data communications mode the SLMPM selects in dependence upon the monitored performance another data communications mode for transmitting the data and transmits the data according to the selected data communications mode. Selecting another data communications mode for transmitting the data may include selecting in dependence upon the monitored performance another data communications fabric type by which to transmit the data selecting a data communications link through which to transmit the data and selecting another data communications protocol. Consider as an example that the requested data communications mode is a DMA transmission using a PUT operation through link of the PCIe fabric to the accelerator . If the monitored data performance indicates that the number of requests in transmit message request queue associated with the link exceeds a predetermined threshold the SLMPM may select another fabric type the Ethernet fabric and link through which to transmit the data . Also consider that the monitored performance indicates that current utilization of the shared memory space is less than a predetermined threshold while the number of outstanding DMA transmissions in the queue exceeds a predetermined threshold. In such a case the SLMPM may also select another protocol such as a shared memory transfer by which to transmit the data .

Selecting by the SLMPM another data communications mode for transmitting the data may also include selecting a data communications protocol in dependence upon data communications message size . Selecting a data communications protocol in dependence upon data communications message size may be carried out by determining whether a size of a message exceeds a predetermined threshold. For larger messages the DMA protocol may be a preferred protocol as processor utilization in making a DMA transfer of a larger message is typically less than the processor utilization in making a shared memory transfer of a message of the same size.

As mentioned above the SLMPM may also transmit the data according to the selected data communications mode. Transmit the data according to the selected data communications mode may include transmitting the data by the selected data communications fabric type transmitting the data through the selected data communications link or transmitting the data according to the selected protocol. The SLMPM may effect a transmission of the data according to the selected data communications mode by instructing through a device driver the communications adapter for the data communications fabric type of the selected data communications mode to transmit the message according to a protocol of the selected data communications mode where the message includes in a message header an identification of the accelerator and in the message payload the data to be transmitted.

In the example of both the host computer and the accelerator one of the compute nodes have installed upon it a hierarchical distributed compiler . The hierarchical distributed compiler is shown in both the host computer and accelerator for completeness. In fact hierarchical distributed compiler according to embodiments of the present invention may be installed on either a host computer or one or more accelerators or both a host computer and one or more accelerators as will occur to those of skill in the art. The hierarchical distributed compiler of is a module of automated computing machinery capable of compiling software for a hierarchical distributed processing system according to embodiments of the present invention. The hierarchical distributed compiler includes computer program instruction for compiling by the compiling node the software maintaining by the compiling node any compiled software to be executed on the compiling node selecting by the compiling node one or more nodes in a next tier of the hierarchy of the distributed processing system in dependence upon whether any compiled software is for the selected node or the selected node s descendants sending to the selected node only the compiled software to be executed by the selected node or selected node s descendant. Each of the other compute nodes of are also capable of receiving compiled software determining whether the compiled software is for that node or one of its descendants if the compiled software is for that node maintaining the software for execution and if the compiled software is for one of the descendants selecting another node in a next tier of the hierarchical distributed processing system in dependence upon a descendant for the compiled software and sending the compiled software to the selected another node.

For further explanation sets forth an exemplary method of compiling software for a hierarchical distributed processing system according to embodiments of the present invention. Compiling is the process of transforming source code written in a computer language often a high level programming language into another typically executable computer language typically having a binary form and sometimes called object code. Compiling according to embodiments of the present invention is typically carried out with a hierarchical distributed compiler installed on compiling nodes according to the present invention. Such a hierarchical distributed compiler is typically able to compile software for use on a number of different kinds of target computers. As such a hierarchical distributed compiler may compile portions of uncompiled source software to target object code for use on computers of disparate types.

A hierarchical distributed processing system may be implemented in a number of ways such as for example implemented in a tree structure. Such a tree structure may be k ary that is of any order binary or in any other form of tree structure that will occur to those of skill in the art. Alternatively hierarchical distributed processing systems according to the present may be implemented in other forms that are not considered tree structures as will occur to those of skill in the art. The method of may be carried out in a distributed computing system similar to the example distributed computing systems described above the example parallel computers of the example hybrid computing environment of and others as will occur to those of skill in the art.

The method of includes identifying the one or more compiling nodes. As mentioned above the one or more compiling nodes transform source code written in a computer language typically a high level programming language into another often executable computer language typically having a binary form and sometimes called object code. The compiling nodes compile portions of the software to be executed on the compiling nodes themselves as well as other portions of the software to be executed on another node in the hierarchical distributed network.

Identifying the one or more compiling nodes according to the method of may be carried out by selecting one or more nodes that are computationally optimized for compiling. Selecting one or more nodes that are computationally optimized for compiling may include identifying nodes in dependence upon their I O capabilities processing capabilities and memory capabilities. Often a particular balance of these capabilities is optimal for compiling. Such an optimal balance may be different for compiling different kinds of software and as such selecting one or more nodes that are computationally optimized for compiling may include selecting one or more nodes in dependence upon the particular software to be compiled.

Identifying the one or more compiling nodes according to the method of may also be carried out by selecting one or more nodes that are optimized for compiling because of their location in the topology of the hierarchical distributed processing system. In a tree structured hierarchical data processing system for example a node that is a root node or a node having many descendants may be located in the topology such that node is optimized for compiling software for its descendents. A descendant as that term is used in this specification is a node located in tiers of the hierarchical data processing system below the compiling node and on a branch of the hierarchical processing system that includes the compiling node.

The method of also includes providing to one or more compiling nodes software to be compiled wherein at least a portion of the software to be compiled is to be executed by one or more other nodes. Providing to one or more compiling nodes software to be compiled may be carried out by sending the software to be compiled to the compiling node in a message downloading the software to the compiling node installing the software on the compiling node by a systems administrator or any other way of providing to one or more compiling nodes software to be compiled that will occur to those of skill in the art.

The method of also includes compiling by the compiling node the software. Compiling by the compiling node the software may be carried out by identifying portions of the software to be executed on the compiling node and transforming the code written in a computer language of the uncompiled software to an executable computer language for execution on the compiling node. Compiling by the compiling node the software may be carried out by identifying portions of the software to be executed on another node identifying the target execution environment of the another node and transforming the software written in the computer language of the uncompiled software to an executable computer language for execution on the another node.

The method of also includes maintaining by the compiling node any compiled software to be executed on the compiling node. Maintaining by the compiling node any compiled software to be executed on the compiling node may be carried out by storing for execution any compiled software to be executed on the compiling node.

The method of also includes selecting by the compiling node one or more nodes in a next tier of the hierarchy of the distributed processing system in dependence upon whether any compiled software is for the selected node or the selected node s descendants and sending to the selected node only the compiled software to be executed by the selected node or selected node s descendants. Selecting by the compiling node one or more nodes in a next tier of the hierarchy of the distributed processing system in dependence upon whether any compiled software is for the selected node or the selected node s descendants may be carried out by traversing a representation of the topology of the hierarchical distributed processing system to identify the location of nodes on which compiled software is to be executed determining a branch of the hierarchical data processing system upon which those nodes to execute the compiled software reside indentifying which child node of the compiling node is also on that branch of the hierarchical data processing system.

Sending to the selected node only the compiled software to be executed by the selected node or selected node s descendants may be carried out by creating a message including the portions the compiled software to be executed by the selected node or selected node s descendants and sending the message to the selected node. Sending to the selected node only the compiled software to be executed by the selected node or selected node s descendants also may be carried out by notifying the selected node of the location of the compiled software for download to the node to execute the compiled software or any other way of sending to the selected node only the compiled software to be executed by the selected node or selected node s descendants that will occur to those of skill in the art.

The selected node may or may not execute the compiled software. That is the compiled software may be executed by a node in a tier below the selected node. For further explanation therefore sets forth a flow chart illustrating another exemplary method of compiling software for a hierarchical distributed processing system according to embodiments of the present invention. The method of is similar to the method of in that the method of includes identifying the one or more compiling nodes providing to one or more compiling node software to be compiled wherein at least a portion of the software to be compiled is to be executed by one or more other nodes compiling by the compiling node the software maintaining by the compiling node any compiled software to be executed on the compiling node selecting by the compiling node one or more nodes in a next tier of the hierarchy of the distributed processing system in dependence upon whether any compiled software is for the selected node or the selected node s descendants and sending to the selected node only the compiled software to be executed by the selected node or selected node s descendants.

The method of also includes additional steps carried out by nodes below the compiling node in the hierarchical distributed processing system. The method of includes receiving by a selected node compiled software. The compiled software may be received in a message identified for download by the compiling node or received in other ways as will occur to those of skill in the art.

The method of also includes determining whether the compiled software is for the selected node or one of its descendants. Determining whether the compiled software is for the selected node or one of its descendants may be carried out by receiving from the compiling node an identification of the nodes to execute specific portions of the compiled software and determining whether the identified node is the selected node or whether the identified node is one of its descendents.

If the compiled software is for the selected node the method of includes maintaining the software by the selected node for execution. Maintaining the software by the selected node for execution may be carried out by storing for execution any compiled software to be executed on the selected node.

If the compiled software is for one of the descendants the method of includes selecting another node in a next tier of the hierarchical distributed processing system in dependence upon a descendant for the compiled software and sending the compiled software to the selected another node. Selecting another node in a next tier of the hierarchical distributed processing system in dependence upon a descendant for the compiled software may be carried out by traversing a representation of the topology of the hierarchical distributed processing system to identify the location of nodes on which compiled software is to be executed determining a branch of the hierarchical data processing system upon which those nodes to execute the compiled software reside identifying which child node of the selected node node is also on that branch of the hierarchical data processing system.

Sending the compiled software to the selected another node may be carried out by creating a message including the portions the compiled software to be executed by the selected another node or selected another node s descendants and sending the message to the selected another node. Sending the compiled software to the selected another node also may be carried out by notifying the selected another node of the location of the compiled software for download to the node to execute the compiled software or any other way of sending the compiled software to the selected another node that will occur to those of skill in the art.

For further explanation sets forth a block diagram of an exemplary use case of a system for compiling software for a hierarchical distributed processing system according to embodiments of the present invention. In the example of a compiling laptop has uncompiled software . The uncompiled software has portions of software for execution by computer portions of software and for execution by one or more Graphics Processing Unites GPUs portions of software for execution by compute nodes in the parallel computer portions of software for execution by the hybrid computing environments front end node portions of software and for execution by host computers in the hybrid computing system and portions of software and for execution by accelerators of the hybrid computing system.

In the example of the compiling laptop compiles the portion of software for computer and sends that portion of compiled software to computer for execution. In the example of the compiling laptop also compiles the portions of software and for specific GPUs and sends those portions of compiled software to computer who in turn sends the portion of compiled software to the specific GPU that will execute that portion of compiled software.

In the example of the compiling laptop compiles the portion of software and for specific compute nodes of the parallel computer and sends those portions of compiled software to I O Node of the parallel computer who in turns sends the portions of the compiled software to the root node of the compute nodes . The root node of the compute nodes then identifies which child node has descendents that will execute the portions of the compiled software and sends to each child only the portions that will be executed by that child or its descendents. Each child then receives those portions determines whether it will execute the portion or whether one of its descendants will execute the portion and sends only those portions for its descendents to a child on the same branch as the descendant. In this manner tier by tier the portions of compiled software are sent to the specific compute node to execute that compiled software.

In the example of the compiling laptop compiles the portion of software for the hybrid computing environment front end node and sends that portion of compiled software to hybrid computing environment front end node for execution. In the example of the compiling laptop also compiles the portions of software and for specific host computers and sends those portions of compiled software to hybrid computing environment front end node who in turn sends the portion of compiled software to the specific host computers that will execute that portion of compiled software. In the example of the compiling laptop also compiles the portions of software and for specific accelerators of host computers and sends those portions of compiled software to hybrid computing environment front end node who in turn sends the portion of compiled software to the specific host computers for those accelerators who in turn send the portion of compiled software to the specific accelerator that will execute that portion of compiled software.

In the examples above compiling software for a hierarchical distributed processing system has been generally discussed with a single compiling node. This is for explanation and not for limitation. In fact in many embodiments of the present invention more than one node may compile software for a hierarchical distributed processing system in accordance with the present invention.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described above with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

It will be understood from the foregoing description that modifications and changes may be made in various embodiments of the present invention without departing from its true spirit. The descriptions in this specification are for purposes of illustration only and are not to be construed in a limiting sense. The scope of the present invention is limited only by the language of the following claims.

