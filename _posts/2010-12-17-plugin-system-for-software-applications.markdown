---

title: Plug-in system for software applications
abstract: A plug-in framework is invoked within a plug-in, where the plug-in framework includes a software library configured to define, register, and configure plug-ins, where the plug-in includes a software module that extends or customizes functionality of a software application that is external to the plug-in, and where the plug-in includes a mapping name. A plug-in instance declaration is searched, by the plug-in framework, for a mapping that includes the mapping name, where the plug-in instance declaration is located within a plug-in file, and where the plug-in declaration comprises one or more mappings. When a mapping of the mapping name to the value is found, the value is returned, by the plug-in framework, to the plug-in based on the mapping. The plug-in framework also allows a plug-in provider to associate a plug-in with metadata.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08407461&OS=08407461&RS=08407461
owner: Oracle International Corporation
number: 08407461
owner_city: Redwood Shores
owner_country: US
publication_date: 20101217
---
One embodiment is directed to a computer system and more particularly to a computer system implementing plug ins.

In computing a plug in is a software module that extends or customizes functionality of a software application that is external to the plug in. A plug in can thus be used to satisfy the requirements of a specific deployment. A plug in framework such as an Open Service Gateway initiative OSGi framework allows the software application to define plug in points that are specific points in the software application where extensibility can be provided. An interface definition accompanies the plug in point and is generally identified as a plug in interface. Users of the software application can extend the plug in interface based on business requirements and register the extensions of the plug in interface with the plug in framework as plug ins.

In general plug in frameworks provide the ability to load plug ins from various sources such as a file system or a database. Furthermore certain plug in frameworks also provide a way to register multiple versions of a plug in and set one of the versions as the version to be loaded. Thus customers of the plug in framework create multiple individualized plug ins specific to one or more business requirements. This can result in a proliferation of plug ins and an increased maintenance overhead.

One embodiment is directed to a computer readable medium having instructions stored thereon that when executed by a processor cause the processor to implement a plug in system. The instructions include invoking a plug in framework within a plug in where the plug in framework includes a software library configured to define register and configure plug ins where the plug in includes a software module that extends or customizes functionality of a software application that is external to the plug in and where the plug in includes a mapping name. The instructions further include searching a plug in instance declaration by the plug in framework for a mapping that includes the mapping name where the plug in instance declaration is located within a plug in file and where the plug in declaration comprises one or more mappings. The instructions further includes when a mapping of the mapping name to the value is found returning the value by the plug in framework to the plug in based on the mapping.

One embodiment is directed to a plug in system. The plug in system allows a plug in provider to associate a plug in with metadata also identified as plug in metadata . The metadata associated with the plug in can include information used to determine whether the plug in is the correct plug in to implement for a specific business scenario. The plug in system also allows a plug in to utilize mapped values. A mapped value is a value that is determined based on a mapping. Thus a plug in that utilizes different values based on a business scenario and thus is reusable across multiple business scenarios can be created. The mapped values utilized by the plug in can also be managed through a user interface.

Certain terms commonly utilized in the art of computer systems and specifically in the art of computer programming will now be described in order to initially introduce important terms that are more fully described and explained below. As appreciated by one of ordinary skill in the art a class is a construct that is used as a template to create objects or instances of that class where the template describes the state and behavior of the objects or instances that share the class. A class generally encapsulates a state through data placeholders called attributes or variables and encapsulates a behavior through reusable modules called methods. As also appreciated by one of ordinary skill in the art an object or instance is an occurrence of a class where a compilation of attributes or variables and a compilation of methods encapsulate an entity represented by the object or instance.

Furthermore an interface is a set of methods and attributes that defines functionality for an object. As appreciated by one of ordinary skill in the art an interface generally does not restrict how the defined functionality is implemented and instead leaves the implementation details to a class that implements the interface. An implementation is a set of methods and attributes that implement the defined functionality of an interface.

In addition a software library is a collection of program modules or classes used to develop software applications as appreciated by one of ordinary skill in the art. An application programming interface API is an interface implemented by a software application that enables the software application to communicate with another software application.

A computer readable medium may be any available medium that can be accessed by processor . A computer readable medium may include both a volatile and nonvolatile medium a removable and non removable medium a communication medium and a storage medium. A communication medium may include computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and may include any other form of information delivery medium known in the art. A storage medium may include RAM flash memory ROM erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM registers hard disk a removable disk a compact disk read only memory CD ROM or any other form of storage medium known in the art.

Processor can also be operatively coupled via bus to a display such as a Liquid Crystal Display LCD . Display can display information to the user. A keyboard and a cursor control device such as a computer mouse can also be operatively coupled to bus to enable the user to interface with plug in system .

According to one embodiment memory can store software modules that may provide functionality when executed by processor . The modules can include an operating system plug in framework module as well as other functional modules . Operating system can provide an operating system functionality for plug in system . Plug in framework module can provide functionality for associating a plug in with metadata and for mapping values within a plug in as will be described in more detail below. Plug in system can also be part of a larger system. Thus plug in system can include one or more additional functional modules to include the additional functionality. For example functional modules may include modules that are part of the Oracle Identity Manager product from Oracle Corporation.

Processor can also be operatively coupled via bus to a database . Database can store data in an integrated collection of logically related records or files. Database can be an operational database an analytical database a data warehouse a distributed database an end user database an external database a navigational database an in memory database a document oriented database a real time database a relational database an object oriented database or any other database known in the art.

According to the embodiment plug in framework is a software library configured to define register and configure plug ins. As previously defined a plug in is a software module that extends or customizes functionality of a software application that is external to the plug in.

According to one embodiment a plug in includes a plug in implementation. A plug in implementation is one or more program modules or classes that provide the functionality of the plug in and implements a plug in interface. A plug in interface is an interface definition of one or more plug ins that can extend an external software application and is located in a plug in point. A plug in point is a specific point in an software application external to plug in framework where extensibility or customization of the software application can be provided by one or more plug ins. A plug in implementation can be instantiated by one or more plug in instances. A plug in instance is an instance of a plug in implementation. A plug in instance can include metadata associated with the plug in and mapped values. Metadata is described in more detail below in relation to . Mapped values are described in more detail below in relation to and .

According to one embodiment plug in framework is a software library written using the Java programming language. According to this embodiment a plug in interface and plug in implementation are an interface and implementation respectively written using the Java programming language where the interface and implementation each include one or more Java classes. Furthermore according to this embodiment a plug in instance is an instance of the plug in implementation that includes one or more Java objects.

According to an embodiment of the invention a plug in can be distributed as an archive file also identified as a plug in file where the plug in file includes a plug in implementation. An example of a plug in file is a Java archive JAR file. As one of ordinary skill in the art would readily appreciate a JAR file is a file that aggregates one or more files and is generally used to distribute Java applications or libraries in the form of classes. As one of ordinary skill in the art would also appreciate another example of a plug in file is a zip file which is another type of archive file that aggregates one or more files. According to the embodiment a plug in file can include a directory structure where the directory structure includes one or more files. The directory structure including the one or more files is contained within the plug in file. Furthermore the plug in file can be expanded where the directory structure including the one or more files can be removed from the plug in file and stored in a physical location independent of the plug in file.

In accordance with an embodiment the directory structure of the plug in file can include an extensible markup language XML file. An example of an XML file is plugin.xml. The XML file can contain metadata associated with the plug in. Metadata is described in more detail below in relation to . The XML file also includes a name of a plug in point that the plug in extends a name of a class implementing the plug in a name of the plug in and a version number of the plug in. The directory structure further includes archive files containing one or more classes implementing the plug in including any dependent library archive files and also includes one or more resources files used by the plug in.

According to the embodiment a location where a plug in file is stored is identified as a plug in storage. Furthermore a package containing one or more plug ins is called a plug in package or a plug in ZIP file. A plug in package may include support libraries used by the plug in.

According to an embodiment a plug in is implemented as a Java class. A plug in file can contain other classes as well but the class implementing the plug in may be the only class that is exposed to a software application external to plug in framework . The class or classes can be specified in the XML file of the plug in file in accordance with the embodiment. A Java class that implements a plug in is also identified as a plug in class. The plug in class can also access the resources included in the plug in file. As an example the plug in class can access the resources by invoking the following method 

According to an embodiment a plug in can be stored as a part of plug in framework or can be stored as part of a software application external to plug in framework . In the scenario where the plug in is stored as part of the software application the plug in is considered to be part of plug in framework even though the plug in is stored in a location external to plug in framework . According to the embodiment a plug in that is part of the software application can be packaged in a JAR file or zip file of the software application external to plug in framework .

Plug in framework includes plug in manager . Plug in manager is an API configured to allow a software application to register and de register plug ins of plug in framework . In the term management refers to the registration and de registration operations. According to an embodiment plug in manager validates input data transmitted by a software application and interacts with plug in store described below in greater detail in order to register or de register a plug in of plug in framework . In one embodiment plug in manager includes a plug in manager interface and corresponding plug in manager implementation. According to the embodiment plug in manager interacts with plug in framework in order to acquire an instance of plug in store . The operations performed by plug in manager are described below in greater detail in relation to .

Plug in framework also includes plug in registry . Plug in registry is an API configured to perform query and instantiation operations. More specifically plug in registry is configured to interact with plug in store through querying plug in store for available plug ins. Plug in registry is also configured to load a selected plug in and instantiate the selected plug in. In the term lookup load refers to the query and instantiation operations. According to an embodiment of the invention plug in registry implements a custom class loader to load a selected plug in. According to the embodiment separate instances of this custom class loader can be created one per plug in file. These instances of the custom class loader can be cached in plug in registry so that the custom class loader does not need to be initialized every time the plug in needs to be loaded. The operations performed by plug in registry are described below in greater detail in relation to .

According to an embodiment service client can declare one or more plug in points where each plug in point corresponds to an area of service client that can be extended or customized. A plug in point that is declared is identified as a plug in point declaration. A plug in point for service client can either be declared explicitly or implicitly in accordance with the embodiment. To declare a plug in point explicitly a plug in point is explicitly declared in a file of a package that contains service client . In one embodiment a plug in point is explicitly declared in an XML file such as pluginpoint.xml. An example of an XML file that explicitly declares a plug in point is provided below 

To declare a plug in point implicitly a plug in is declared where the plug in references a plug in point in a file of a plug in file. A plug in that is declared is identified as a plug in declaration. In one embodiment a plug in point is implicitly declared in an XML file of a plug in file such as plugin.xml. An example of an XML file that implicitly declares a plug in point is provided below 

According to an embodiment a plug in or a plug in point or both can be declared in a library that is external to both plug in framework and service client . In an embodiment where plug in framework is part of larger system such as the Oracle Identity Manager product from Oracle Corporation a plug in or a plug in point or both can be declared using an external XML file located within the larger system.

According to an embodiment when service client declares a plug in point service client can also provide runtime value mapping for a plug in. In order for plug in framework to resolve runtime mapped values of a plug in service client can provide a runtime value resolver for resolving the values at runtime. The responsibility of a runtime value resolver according to the embodiment is to return a mapped value based on a mapping name. According to an embodiment a runtime value resolver is a Java class that implements a runtime value resolver interface and implements the following method 

The entityType parameter refers to an entity type that the plug in is attempting to resolve. The method name parameter is the name of the method in the plug in attempting to resolve the values. The args parameter is the arguments of the method in the plug in attempting to resolve the values. The resolve method returns a mapping to one or more values. A runtime value resolver and runtime value mapping are both described in more detail below in relation to and .

According to an embodiment a plug in instance can be declared. This is identified as a plug in instance declaration. As previously described a plug in instance is an instance of a plug in and can include static mapping identified in this specification as simple value mapping and or dynamic mapping identified as runtime value mapping . In an embodiment where the plug in instance includes runtime value mapping service client also declares a plug in point that includes a runtime value resolver. Simple value mapping and runtime value mapping are each described in more detail below in relation to and .

According to an embodiment a plug in instance can be declared in an XML file of a plug in file such as plugin.xml. An example of such a plug in instance declaration is as follows 

The above plug in instance declaration declares a plug in instance with both simple value mapping and runtime value mapping. According to the embodiment both simple value mapping and runtime value mapping can be declared for a specific method or all methods in the plug in instance. Simple value mapping and runtime value mapping are described below in greater detail in relation to and .

According to an embodiment service client can use plug in registry to discover plug ins. An example of source code within service client that uses plug in registry to discover plug ins is as follows 

Another example of source code within service client that uses plug in registry to discover plug ins is as follows 

According to an embodiment plug in framework provides an plug in API that encapsulates the details of the plug in. Furthermore plug in framework provides a method to get an instance of the plug in as shown below in the following example 

Furthermore according to the embodiment service client can get an instance of a plug in using a plug in point name and a plug in class name as shown in the following example 

In addition according to the embodiment service client can get an instance of a plug in using a plug in point name and a plug in point identity rather than the plug in class name as shown in the following example 

The operation of accessing a plug in at runtime is described below in greater detail in relation to .

According to an embodiment metadata can be associated with each plug in that is defined in an XML file of a plug in file. Metadata is described in more detail below in relation to .

Plug in framework also includes plug in store . Plug in store is an API configured to interact with a data storage where one or more plug ins are stored. According to the embodiment plug in store is used internally within plug in framework by plug in manager and plug in registry . Plug in store is further configured to load a plug in and return the plug in to plug in registry which in turn is configured to return the plug in to service client . According to an embodiment plug in store includes a common store class that is associated with three internal components of the data storage where the three internal components are described below in greater detail. The common store class is configured to interact with all three internal components and is further configured to retrieve one or more plug ins from all three internal components and load the one or more plug ins.

The second internal component of a data storage is DB store . DB store is configured to interact with a database to store and retrieve one or more plug ins to and from the database. The database can be an operational database an analytical database a data warehouse a distributed database an end user database an external database a navigational database an in memory database a document oriented database a real time database a relational database an object oriented database or any other database known in the art. According to an embodiment DB store can interface with the database using an API such as Java Database Connectivity JDBC . According to an embodiment plug ins that are stored in the database can also be registered by plug in registry .

The third internal component of a data storage is file store . File store is configured to interact with a file system that includes a directory structure where the directory structure includes one or more computer files. File store is further configured to store and retrieve one or more plug ins to and from the file system. As previously discussed a plug in can be distributed as a plug in file. As also previously discussed a plug in file can include a directory structure where the directory structure includes one or more files. According to an embodiment file store can store a plug in to a directory of the file system either as a plug in file or as a directory structure. Plug in framework looks for a plug in under the directory of the file system using file store . Furthermore according to an embodiment additional plug in directories can also be registered. In this embodiment these additional plug in directories can be specified in a file that is stored in the file system. In one embodiment this file is an XML file such as xlconfig.xml.

According to the embodiment file store is configured to load one or more plug ins from the file system. Upon a request by service client file store can select a plug in from the file system and load the plug in. If a plug in is in a plug in file format a first class can be used to load the plug in. In an embodiment the first class is a plug in class loader. However if a plug in is in a plug in directory structure format a second class can be used to load the plug in. In an embodiment the second class is java.net.URLClassLoader.

According to an embodiment a thread can be initiated that monitors the file system. As one of ordinary skill in the art would readily appreciate a thread is a subset of a process where a process is an instance of a program module being executed. The thread is configured to monitor the one or more registered files where plug ins are stored and determine if one or more plug ins are modified. According to an embodiment the thread can be configured to check for any modifications at a specified interval. A user can configure the specified interval with which the thread checks for any modifications. A user can also configure whether the thread is initiated. In an embodiment of the invention the configuration can be done in an XML file such as oim config.xml. An example of an XML file is as follows 

According to an embodiment a plug in file can include an XML file that includes metadata associated with the plug in. The metadata can be loaded from the XML file of the plug in file and maintained in memory. In accordance with an embodiment file store upon registration can look for one or more registered directories and load the metadata associated with the one or more plug ins stored in the one or more registered directories and maintain the metadata in memory. Metadata is described in more detail below in relation to .

According to the embodiment where plug in framework is a software library written using the Java programming language plug in framework includes one or more Java classes used by a software application external to plug in framework to acquire instances of plug in manager and plug in registry . According to the embodiment plug in framework is also used by plug in manager and plug in registry internally to acquire an instance of plug in store . The one or more Java classes include all the objects of plug in manager plug in registry and plug in store as static variables and includes static methods for accessing them.

According to an embodiment of the invention Deployment Framework Client registers a plug in by first invoking a method getPluginManager of PluginFramework . Once the getPluginManager method is invoked PluginFramework returns an instance of a plug in manager i.e. PluginManager to Deployment Framework Client .

After Deployment Framework Client receives the instance of the plug in manager i.e. PluginManager Deployment Framework Client registers the plug in by invoking a method registerPlugin of PluginManager . Once the registerPlugin method is invoked PluginManager invokes a method store of PluginStore . Once the store method is invoked PluginStore stores the plug in in a storage and returns execution control to PluginManager . Once the plug in is stored and execution control is returned to PluginManager PluginManager returns execution control to Deployment Framework Client .

In accordance with an embodiment Deployment Framework Client deregisters a plug in by invoking a method deRegisterPlugin of PluginManager . Once the deRegisterPlugin method is invoked PluginManager invokes a method delete of PluginStore . Once the delete method is invoked PluginStore deletes the plug in from the storage and returns execution control to PluginManager . Once the plug in is deleted and execution control is returned to PluginManager PluginManager returns execution control to Deployment Framework Client .

According to an embodiment of the invention Service Client queries for and instantiates a plug in by first invoking a method getPluginRegistry of PluginFramework . Once the getPluginRegistry method is invoked PluginFramework returns an instance of a plug in registry i.e. PluginRegistry to Service Client .

After Service Client receives the instance of the plug in registry i.e. PluginRegistry Service Client invokes a method getAllPlugins of PluginRegistry . In invoking the getAllPlugins method Service Client passes an argument pluginPointID to PluginRegistry that includes an identity of a plug in point. PluginRegistry uses the argument pluginPointID to invoke a method getAllPlugins of PluginStore . PluginStore retrieves one or more plug ins and returns the one or more plug ins to PluginRegistry . Once PluginRegistry receives the one or more plug ins PluginRegistry returns a list of one or more plug ins to Service Client where the list includes a plug in identity of each plug in returned by PluginStore .

After Service Client receives the list of one or more plug ins Service Client invokes a method getPlugin of PluginRegistry . In invoking the getPlugin method Service Client passes two arguments pluginPointID and pluginID to PluginRegistry . As previously described the pluginPointID argument includes an identity of a plug in point. Furthermore the pluginID argument includes an identity of a plug in that Service Client wishes to instantiate. PluginRegistry uses the two arguments pluginPointID and pluginID to invoke a method getPlugin of PluginStore . PluginStore retrieves a plug in and returns the plug in to PluginRegistry . Once PluginRegistry receives the plug in PluginRegistry returns the plug in to Service Client .

After Service Client receives the plug in Service Client invokes a method getPluginInstance of PluginRegistry . In invoking the getPluginInstance method Service Client passes in an argument Plugin that includes the plug in received from PluginRegistry . PluginRegistry uses the Plugin argument to invoke a method loadPluginBytes of PluginStore . PluginStore instantiates an instance of the plug in and returns the instance of the plug in to PluginRegistry . Once PluginRegistry receives the instance of the plug in PluginRegistry returns the instance of the plug in to Service Client .

Plug in metadata will now be described in greater detail in relation to . As previously described metadata associated with a plug in can include information used to determine whether the plug in is the correct plug in to implement. As also previously described metadata can be associated with a plug in that is defined in an XML file of a plug in file.

According to the embodiment XML file includes information regarding a plug in. For example XML file includes a name of a plug in point that the plug in extends a name of a class implementing the plug in a name of the plug in and a version number of the plug in. In accordance with the embodiment XML file also includes metadata . Metadata is metadata that is associated with the plug in. In accordance with an embodiment metadata includes one or more properties. As an example a property can comprise a name value pair. The one or more properties can be viewed by a plug in framework and the plug in framework can use the one or more properties to determine if a plug in is applicable for a specific business scenario. As an example a first plug in that is applicable for generating a password comprising numbers can be associated with metadata comprising a property known as PasswordElementNum with a value of 1. As an additional example a second plug in that is applicable for generating a password comprising letters can be associated with metadata comprising a property known as PasswordElementNum but with a value of 2. Thus according to the embodiment a plug in framework can view the metadata associated with each plug in and determine that the first plug in is applicable for a business scenario requiring a password comprising numbers and that the second plug in is applicable for a business scenario requiring a password comprising letters. Therefore the plug in framework can load and instantiate the plug in that is applicable for the business scenario.

In the above example the property PasswordElementNum associated with the value of 1 is an example of plug in metadata. In addition the property Password ElementNum associated with the value of 2 is another example of plug in metadata.

At metadata is associated with a plug in. According to an embodiment metadata includes one or more properties where each property includes a name value pair. According to an embodiment associating the metadata with the plug in includes storing the metadata in an XML file of a plug in file. The metadata can be associated with the plug in by a plug in framework according to an embodiment.

At a plug in is selected and the metadata associated with the plug in is identified. According to an embodiment an external software application can request one or more plug ins from a plug in framework and the plug in framework can select a plug in from a plug in storage and identify the metadata associated with the plug in.

At it is determined whether the plug in is applicable based on the metadata associated with the plug in. According to an embodiment the metadata associated with the plug in can include information regarding the plug in that indicates whether the plug in is applicable. According to the embodiment a plug in is applicable if the plug in is the correct plug in to implement in a specific business scenario based on the functionality of the plug in. In accordance with an embodiment the metadata associated with the plug in includes one or more properties where each property includes a name value pair. The value of the name value pair can provide information regarding the functionality of the plug in and the value of the name value pair can be evaluated to determine whether the plug in is applicable. In an embodiment a plug in framework determines whether the plug in is applicable based on the metadata associated with the plug in.

At the plug in is loaded when the plug in is applicable based on the metadata associated with the plug in. According to the embodiment when the plug in framework determines that the plug in is applicable based on the metadata associated with the plug in the plug in framework loads and instantiates the plug in. The details regarding loading and instantiating the plug in are previously described in relation to .

Mapped values will now be described in greater detail in relation to and . As previously described a plug in provides functionality that extends or customizes functionality of a software application that is external to the plug in. In order to provide functionality a plug in utilizes one or more values. According to an embodiment of the invention a plug in can invoke a plug in framework in order to determine one or more values based on a mapping. These values are identified as mapped values. In accordance with an embodiment of the invention rather than including one or more values that are assigned during development of the plug in the plug in includes one or more values that can be determined by the plug in framework based on a mapping. In an embodiment of the invention the mapping is provided by the plug in and the mapping is identified as simple value mapping. This mapping is static as the mapping of one or more values is the same no matter which plug in point the plug in is extending or customizing. In an alternate embodiment the mapping is provided by a plug in point utilizing a runtime value resolver and the mapping is identified as runtime value mapping. This allows the mapping to be dynamic as the mapping of one or more values in the plug in can be determined at runtime depending on which plug in point the plug in is extending or customizing.

According to an embodiment of the invention a plug in can define its simple value mapping and or runtime value mapping in an XML file of a plug in file such as plugin.xml. In accordance with the embodiment the mappings are declared in a plug in instance declaration. As previously described a plug in instance can also be declared in an XML file of a plug in file such as plugin.xml. An example of such a plug in instance declaration that has been previously described is shown below where simple value mappings and runtime value mappings of the plug in declaration have been bolded 

The above plug instance declaration declares a plug in point with both simple value mapping and runtime value mapping. According to an embodiment simple value mapping and runtime value mapping can be declared for a specific method of the plug in or all methods of the plug in. In the above example a simple value mapping attr1 and a runtime value mapping phone are both defined for an evaluate method of the plug in. Furthermore two simple value mappings attr1 and attr2 and two runtime value mappings fname and Iname are defined for all methods of the plug in.

According to an embodiment a simple value mapping can map a mapping name to either a value or an attribute. If the simple value mapping maps a mapping name to a value this means that wherever the mapping name is utilized in the plug in a plug in framework can replace the mapping name with the mapped value. If the simple value mapping maps a mapping name to an attribute this means that wherever the mapping name is utilized in the plug in a plug in framework can use the attribute to determine a mapped value and can replace the mapping name with the mapped value. In accordance with an alternate embodiment a runtime value mapping can map a mapping name to an attribute. Similar to a simple value mapping when a runtime value mapping maps a mapping name to an attribute this means that wherever the mapping name is utilized in the plug in a plug in framework can use the attribute to determine a mapped value and can replace the mapping name with the mapped value. According to an embodiment in the case of either a simple value mapping or a runtime value mapping the mapping name that is utilized in the plug in and the mapped value that replaces the mapping name can be collectively identified as a mapped value.

In the case of a simple value mapping if the simple value mapping maps a mapping name to an attribute then the plug in framework uses the attribute as a key to look up a value in a hash map that is provided by the plug in. Furthermore according to the embodiment the mapping name and the mapped value are identified as a simple mapped value. In the case of a runtime value mapping if the runtime value mapping maps a mapping name to an attribute then the plug in framework uses the attribute as a key to look up a value in a hash map that is provided by a runtime value resolver in a plug in point. Furthermore according to the embodiment the mapping name and the mapped value are identified as a runtime mapped value. 

As previously described a runtime value resolver according to an embodiment returns a mapping of values based on provided parameters. According to an embodiment a runtime value resolver is a Java class that implements a runtime value resolver interface and implements the following method 

As also previously described the entityType parameters refers to an entity type that the plug in is attempting to resolve. The method name parameter is the name of the method in the plug in attempting to resolve the values. The args parameter is the arguments of the method in the plug in attempting to resolve the values. The resolve method implements a hash table that is used to provide mapped values to a plug in framework. When runtime value mapping maps a mapping name to an attribute the plug in framework uses the attribute as a key to look up a value in the hash map of the runtime value resolver.

According to the embodiment plug in framework uses the following logic to determine a value for simple mapped value . Plug in framework accesses a mapping name of simple mapped value and a method name of plug in from plug in as illustrated by arrow in . Plug in framework then searches the one or more simple value mappings in plug in instance declaration for the mapping name as illustrated by arrow in . If plug in instance declaration has a mapping specified for the method name with a mapping name that matches the mapping name of simple mapped value then that mapping is used. Otherwise if plug in instance declaration has a mapping specified for all methods with a mapping name that matches the mapping name of simple mapped value that mapping is used. Otherwise a NoSuchMappingException is thrown by plug in framework . Once the mapping has been selected plug in framework evaluates the mapping in plug in instance declaration to determine whether the mapping name is mapped to a value or an attribute. If the mapping name is mapped to a value then the value is returned to plug in framework as illustrated by arrow in and the value is subsequently returned to plug in as illustrated by arrow in . If the mapping name is mapped to an attribute then plug in framework uses the attribute as a key to search hash map of plug in as illustrated by arrow in . When the value that corresponds to the attribute is located in hash map the value is returned to plug in framework as illustrated by arrows and in and the value is subsequently returned to plug in as illustrated by arrow in .

According to the embodiment the following is an example on how to access a simple mapped value in a plug in 

In the above example a hash map ro is created in the plug in. A first value value is inserted into hash map ro with a key of smvalue1. A second value value2 is also inserted into hash map ro with a key of smattr2. Subsequently according to the embodiment a getMappedValue method of a plug in framework is invoked in the plug in where the plug in passes a mapping name attr1 a name of the plug in method evaluate and the hash map of the plug in ro. The plug in framework then searches the mappings of a plug in instance declaration for the mapping name. In the above example of a plug in declaration the plug in declaration includes the following simple value mapping 

The simple value mapping is specified for the evaluate method and has a mapping name of attr1. Because the method name of the simple value mapping matches the name of the plug in method passed into the plug in framework and because the mapping name of the simple value mapping matches the mapping name passed into the plug in framework the simple value mapping is selected. While the above example of a plug in declaration also includes a simple value mapping with a mapping name attr1 that is specified for all methods the simple value mapping that is specified for the evaluate method is given priority over the simple value mapping that is specified for all methods. As can be seen the simple value mapping for attr1 specified for the evaluate method maps to a value smvalue1. Therefore the value smvalue1 is returned to the plug in and is assigned to the string variable attr1. 

Subsequently according to the embodiment a getMappedValue method of a plug in framework is invoked in the plug in where the plug in passes a mapping name attr2 a name of the plug in method evaluate and the hash map of the plug in ro. The plug in framework then searches the mappings of a plug in instance declaration for the mapping name. In the above example of a plug in declaration the plug in declaration includes the following simple value mapping 

While the plug in declaration does not include a simple value mapping with a mapping name of attr2 that is specified for the evaluate method the above simple value mapping is specified for all methods and has a mapping name of attr2. Because the mapping name of the simple value mapping matches the mapping name passed into the plug in framework and because the simple value mapping is specified for all methods the simple value mapping is selected. As can be seen the simple value mapping for attr2 maps to an attribute smattr2. Because the simple value mapping maps to an attribute the plug in framework searches the hash map ro for the attribute smattr2. As can be seen from the example plug in described above the hash map include a key smattr2 that matches the attribute smattr2 and the key smattr2 references a value value2. Therefore the value value2 is returned to the plug in and is assigned to the string variable attr2. 

According to the embodiment the logic that plug in framework uses to determine a value for runtime mapped value is the same as the logic used to determine a value for a simple mapped value except that plug in does not need to provide a hash map. Instead hash map is obtained from runtime resolver of plug in point . More specifically plug in framework accesses a mapping name of runtime mapped value and a method name of plug in from plug in as illustrated by arrow in . Plug in framework then searches the one or more runtime value mappings in plug in instance declaration for the mapping name as illustrated by arrow in . If plug in instance declaration has a mapping specified for the method name with a mapping name that matches the mapping name of runtime mapped value then that mapping is used. Otherwise if plug in instance declaration has a mapping specified for all methods with a mapping name that matches the mapping name of runtime mapped value that mapping is used. Otherwise a NoSuchMappingException is thrown by plug in framework . Once the mapping has been selected plug in framework evaluates the mapping in plug in instance declaration to determine whether the mapping name is mapped to a value or an attribute. If the mapping name is mapped to a value then the value is returned to plug in framework as illustrated by arrow in and the value is subsequently returned to plug in as illustrated by arrow in . If the mapping name is mapped to an attribute then plug in framework uses the attribute as a key to search hash map of runtime value resolver of plug in point as illustrated by arrow in . When the value that corresponds to the attribute is located in hash map the value is returned to plug in framework as illustrated by arrows and in and the value is subsequently returned to plug in as illustrated by arrow in .

In the example the runtime value resolver creates a hash map attrs within an implementation of a resolve method. A first value John is inserted into hash map attrs with a key of firstname. A second value Smith is also inserted into hash map attrs with a key of lastname. A third value john.smith company.com is also inserted into hash map attrs with a key of email. The hash map is then returned by the resolve method implementation of the runtime value resolver.

According to the embodiment the following is an example on how to access a simple mapped value in a plug in 

In the above example a getMappedValue method of a plug in framework is invoked in the plug in where the plug in passes a mapping name fname and a name of the plug in method evaluate. The plug in framework then searches the mappings of a plug in instance declaration for the mapping name. In the above example of a plug in declaration the plug in declaration includes the following runtime value mapping 

While the plug in declaration does not include a runtime value mapping with a mapping name of fname that is specified for the evaluate method the above runtime value mapping is specified for all methods and has a mapping name of fname. Because the mapping name of the runtime value mapping matches the mapping name passed into the plug in framework and because the runtime value mapping is specified for all methods the runtime value mapping is selected. As can be seen the runtime value mapping for fname maps to an attribute firstname. Because the runtime value mapping maps to an attribute the plug in framework searches the hashmap attrs in the runtime value resolver of the plug in point described above for the attribute firstname. As can be seen from the example hashmap of the runtime value resolver of the plug in point described above the hash map include a key firstname that matches the attribute firstname and the key firstname references a value John. Therefore the value John is returned to the plug in and is assigned to the string variable attr1. 

Subsequently according to the embodiment a getMappedValue method of a plug in framework is invoked in the plug in where the plug in passes a mapping name Iname and a name of the plug in method evaluate. The plug in framework then searches the mappings of a plug in instance declaration for the mapping name. In the above example of a plug in declaration the plug in declaration includes the following runtime value mapping 

While the plug in declaration does not include a runtime value mapping with a mapping name of Iname that is specified for the evaluate method the above runtime value mapping is specified for all methods and has a mapping name of Iname. Because the mapping name of the runtime value mapping matches the mapping name passed into the plug in framework and because the runtime value mapping is specified for all methods the runtime value mapping is selected. As can be seen the runtime value mapping for Iname maps to an attribute lastname. Because the runtime value mapping maps to an attribute the plug in framework searches the hashmap attrs in the runtime value resolver of the plug in point described above for the attribute lastname. As can be seen from the example hashmap of the runtime value resolver of the plug in point described above the hash map include a key lastname that matches the attribute lastname and the key lastname references a value Smith. Therefore the value Smith is returned to the plug in and is assigned to the string variable attr2. 

Thus according to an embodiment a plug in can utilize metadata associated with the plug in. The metadata can be utilized to determine whether the plug in is the correct plug in to implement by a software application for a specific business scenario. Therefore a plug in user can have a greater ability to select a plug in that is applicable to a specific business scenario and that will provide the appropriate extended or customized functionality. Furthermore according to an embodiment a plug in can utilize mapped values. The mapped values utilized by the plug in allows the plug in to base the values based on a context of the plug in. Therefore a plug in will be more reusable and robust and can be used across many different contexts.

The features structures or characteristics of the invention described throughout this specification may be combined in any suitable manner in one or more embodiments. For example the usage of one embodiment some embodiments certain embodiment certain embodiments or other similar language throughout this specification refers to the fact that a particular feature structure or characteristic described in connection with the embodiment may be included in at least one embodiment of the present invention. Thus appearances of the phrases one embodiment some embodiments a certain embodiment certain embodiments or other similar language throughout this specification do not necessarily all refer to the same group of embodiments and the described features structures or characteristics may be combined in any suitable manner in one or more embodiments.

One having ordinary skill in the art will readily understand that the invention as discussed above may be practiced with steps in a different order and or with elements in configurations which are different than those which are disclosed. Therefore although the invention has been described based upon these preferred embodiments it would be apparent to those of skill in the art that certain modifications variations and alternative constructions would be apparent while remaining within the spirit and scope of the invention. In order to determine the metes and bounds of the invention therefore reference should be made to the appended claims.

