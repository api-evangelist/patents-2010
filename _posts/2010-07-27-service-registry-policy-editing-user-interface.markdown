---

title: Service registry policy editing user interface
abstract: A selection of a service domain policy definition is received in a service repository. A service policy document is created from the service domain policy definition. At least one user change to the service policy document is received in accordance with the selected service domain policy definition. The service policy document is saved in the service repository.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08707171&OS=08707171&RS=08707171
owner: International Business Machines Corporation
number: 08707171
owner_city: Armonk
owner_country: US
publication_date: 20100727
---
This application is a National Stage application of claims priority to and claims the benefit of International Application Serial No. PCT EP2010 060836 titled SERVICE REGISTRY POLICY EDITING USER INTERFACE filed Jul. 27 2010 in the European Patent Cooperation Treaty Receiving Office which further claims priority to and claims the benefit of European Patent Application Serial No. 09167208.9 titled SERVICE REGISTRY POLICY EDITING USER INTERFACE filed Aug. 4 2009 in the European Patent Office the entire contents of each application are hereby incorporated by reference as if fully set forth herein.

This invention relates to a service registry and repository. In particular this invention relates to a service registry and repository based on a triplestore database for a policy editing user interface.

Service oriented architecture SOA is a business driven IT architectural approach that supports integrating a business as linked repeatable business tasks or services. The basic building block is a service document that defines a service so that it can be managed with other services. A service document contains information about a service including the location of the service and details about the service and how to access the service. Service documents are used by analysts architects and developers during a Development Phase of the SOA life cycle to locate services to reuse and to evaluate the impact of changes to service configurations. Service documents are variously described as metadata objects descriptions entities and artefacts.

A service repository stores the service document and allows access to the service document and thereby the corresponding service. A service registry is an index of a subset of information about a service for example the location and name of service document enabling the corresponding service document to be located and accessed in a repository or even the corresponding service located at the service provider . An integrated service registry and repository allows a service operation to use both the indexed service information in the registry and the detailed service information in the repository. An example of an integrated service registry and repository is IBM WebSphere Registry and Repository WSRR .

Such an integrated service registry and repository has advantages of greater business agility and resilience through reuse than separate systems. Further advantages of looser coupling greater flexibility better interoperability and better governance arise from the integration. These advantages are addressed by separating service descriptions from their implementations and using the service descriptions across the life cycle of the service. Standards based service metadata artefacts such as Web Service Definition Language WSDL extensible mark up language XML schema policy or Service Component Architecture SCA documents capture the technical details of what a service can do how it can be invoked or what it expects other services to do. Semantic annotations and other metadata may be associated with these artefacts to offer insight to potential users of the service on how and when it may be used and what purposes it serves.

WS Policy is a World Wide Web Consortium W3C standard that specifies policy documents for web services. A WS Policy document that conforms to the W3C standard declares policies top level elements assertions rules that must be adhered to inside those policies and properties for these assertions for example an assertion may be declared to be optional within a policy . Standard types of policy document also covered by the W3C called domain policy definitions include security WS Security reliable messaging WS RM addressing WS A . Each of these domain policy definitions describes the required structure for the policy XML files in order to conform to the standard.

An example of a domain policy definition is an XML document defining what type of authentication tokens must be supplied when accessing a web service. WS Policy Attach domain policy definition specifies a standard approach by which policy attachments may be defined. In the context of a service registry environment this becomes particularly relevant as the service registry exists as a point of record for web services definitions and thus it is desirable to make these associations between policies and their subjects within the registry.

Standard tools create WS Policy and WS Policy Attach policy documents and even a text editor may be used for this purpose if the user is well versed in the various WS Policy specifications. However the structure of both the policy and the policy attachment specifications requires a high level of knowledge from the users in order to correctly specify everything. Most often errors are made by a user when creating policy documents.

A method for operating a service registry and repository based on a triplestore database includes receiving a selection of a service domain policy definition in the service repository creating a service policy document from the service domain policy definition 

receiving at least one user change to the service policy document in accordance with the selected service domain policy definition and saving the service policy document in the service repository.

A service registry and repository system based on a triplestore database includes at least one processor programmed to receive a selection of a service domain policy definition in the service repository create a service policy document from the service domain policy definition receive at least one user change to the service policy document in accordance with the selected service domain policy definition and save the service policy document in the service repository.

A computer program product includes a computer readable recording medium having computer readable code stored thereon for a service registry and repository based on a triplestore database where the computer readable code when executed on a computer causes the computer to receive a selection of a service domain policy definition in the service repository create a service policy document from the service domain policy definition receive at least one user change to the service policy document in accordance with the selected service domain policy definition and save the service policy document in the service repository.

According to one aspect of the present subject matter there is provided a service registry and repository triplestore method as described in claim .

The present subject matter proposes model based user interface editing capabilities that are used within distributed systems to help users create policy documents for instance WS Policy files and WS Policy Attach files that are relevant within their service registry environment.

The present subject matter uses software modelling techniques in order to provide a generic framework that may support a user interface for editing WS Policy documents from any domain. The user interface may take advantage of this modelling in order to impose constraints on user actions which allows valid WS Policy files to be generated that conform to the domain specification.

A triplestore database may be used to store data in a data structure comprising three pieces of information in the form subject predicate object. The purpose of triplestore is to increase performance in searching for information in a large volume of complex data and as such is well suited to the application of a service registry and repository where the number and complexity of the data is large.

The subject matter described herein provides a service registry and repository for service documents based on IBM WebSphere Service Registry and Repository. Such service documents include traditional internet services that use a range of protocols and are implemented according to a variety of programming models.

The registry offers both a registry function and a repository function for service metadata. The repository function allows users to store manage and query service metadata artefacts holding service descriptions. It not only takes good care of the documents containing service metadata by reliable persistence of the data but it also provides a fine grained representation of the content of those documents for example ports and portTypes in some service documents . The registry function provides for decorating registered service declarations and elements of the derived content models with user defined properties relationships and classifiers. The registry provides a policy editor . A client browser displays a policy for editing by a user .

A classification component allows service descriptions and parts of service definitions to be annotated with corporate vocabulary and to capture the governance state. Service classification systems are captured in web ontology language OWL documents that are loaded into the Service Registry and Repository using the administration interface . Service registry and repository entities may be classified with values from these classification systems to allow classification based queries to be performed and to allow access restrictions based on classification.

An access controller supports a fine grained access control model that allows for the definition of which user roles may perform specific types of actions on corresponding artefacts. Visibility of services may be restricted by business area and user roles may be restricted from transitioning services to certain life cycle states. This is in addition to the role based access control provided by the service registry and repository .

The administration interface supports the import and export of repository content for exchange with other repositories and provides an application programming interface API for configuration and basic administration. These support interactions with the Access Controller and with the classification component .

The user interface comprises a web interface and an Eclipse plug in interface to enable interaction with the service registry and repository . A servlet based web user interface UI may be the main way for users representing different roles to interact with the service registry and repository . The web interface supports all user roles offering lookup browse retrieve publish and annotate capabilities as well as governance activities such as import export and impact analysis. A subset of this user interface is offered as an Eclipse plug in to meet developer needs and analyst users needs that use Eclipse based tooling. The Eclipse plug in is used primarily for lookup browse retrieve and publish capabilities. The Web based user interface may also be used for performing service metadata management and governance.

The programming interface uses Java and SOAP Service Oriented Architecture Protocol APIs to interact programmatically with registry and repository core . These APIs provide basic create retrieve update and delete CRUD operations governance operations and a flexible query capability. The SOAP API is used to communicate content using XML data structures. The Java API is used to communicate content using service data object SDO graphs. Using either the user interface or the programming interface documents and concepts managed by WSRR may be created retrieved updated and deleted. However logical entities in the logical model cannot be modified and these may only be changed by updating a document that contains the logical entity. Concepts may be created retrieved and deleted.

The service registry and repository supports two application programming interfaces APIs that may be used to interact with the registry the repository the governance component and the administration interface the Java based API and the SOAP based API respectively. Both APIs support publishing creating and updating service metadata artefacts and metadata associated with those artefacts retrieving service metadata artefacts deleting metadata and querying the content of the registry and repository. The programming APIs use Service Data Objects SDO to capture the data graphs inherent in the content model allowing access to physical documents logical parts of the physical documents and concepts. The SOAP API uses XML documents to similarly represent Service Data Objects to communicate content structures in both the physical and logical model.

Referring to is a schematic of an example of an implementation of an information architecture of the present subject matter. The information architecture has entities representing service description entities and service description metadata . All artefacts have an assigned URI a name and a description. Examples of each type of artefact are shown in but are not necessarily referred to in the description.

The Service Description Entities comprises physical documents logical derivations and concepts . The Physical Documents are XML documents that are known as service metadata artefacts. The Logical derivations are the finer grained pieces of content that result when some types of physical document are shredded as they are loaded into the Registry and Repository. The Concepts are generic entities that are usually typed and represent anything that is not represented by a document in Registry and Repository . All three types of service description entities may be used in queries have service annotations applied and have relationships established from and to them.

The most elemental building blocks for the WSRR are the physical documents such as XSD WSDL SCDL or WS Policy documents. In addition any XML service metadata artefact type or binary document may be stored in the WSRR and receive the benefits of broader visibility reuse management and governance. The coarse grained model made up from registry objects that represents those documents is referred to as the physical model. Documents are versionable objects in the WSRR content model which means that in addition to a URI name and description they also have a version property.

For some of the physical document types WSRR derives logical objects and stores them in logical derivations . For instance the WSRR may shred a document upon receipt into a set of logical objects to enable users to explore WSRR content beyond the boundaries of the files stored. Logical objects are not versionable. For some physical document types the WSRR defines predefined properties and detects relationships to other physical documents. An XSD document for example has a target Namespace property and relationships with other imported XSD documents other redefined XSD documents and other included XSD documents. When an entry for a certain physical document is created in the WSRR it is inspected for relationships to other artefacts. If not already represented in the WSRR a related artefact is also added and in either case the relationship between the artefacts is recorded.

The set of logical derivations comprises the logical model of the WSRR . The logical model has entities such as portType port and message related to WSDL files and complexType or simpleType related to XSD documents. Elements of the logical model have properties and relationships reflecting a subset of their characteristics as defined in the underlying document. For example a WSDLService element has a namespace property and a relationship to the ports it contains. It should be noted that all individual results of document shredding are aggregated into one logical model that represents not only the content of individual documents but also relationships between content in different documents.

The WSRR stores other types of service metadata using the XML Document a generic document type. Documents of type XMLDocument are not decomposed into the logical model.

The WSRR uses a concept to represent anything that does not have a physical document. The concepts are used to represent a reference to content in some other metadata repository such as a portlet in a portlet catalogue or an asset in an asset repository. It may also be used to group physical artefacts together to govern them as a unit for example concepts may be versioned.

In addition to content directly related to entities the WSRR supports a number of metadata types that are used to describe entities . These metadata types are referred to as service description metadata . The WSRR supports three types of service semantic metadata types properties relationships and classifications . All three types describe physical model entities logical model entities and or concepts. For example service description metadata may be used to associate a property businessValue with a physical model entity representing a WSDL file. It might also be used to define a new relationship makesUseOf between an entity in the logical model representing a portType and an entity in the physical model representing an XML document. Furthermore one could create a classification of importantThings and associate it with a port entity in the logical model and with an entity in the physical model representing a Policy document. This enables semantic queries to target individual elements of the service metadata and enables meaningful dependency analyses to take place prior to making changes.

The properties may be name value pairs that are associated with any of the Service Description Entities . Some properties are assigned by the system such as the unique id the owner and the last time the service entity was changed. These system assigned properties may not be changed. Others are derived through the shredding of a key type service description document into its logical model. Properties of this type include name and namespace. Sometimes these system assigned values are allowed to be changed and properties may be created. Such a user defined property may be used as an unstructured and untyped extension mechanism. The properties may be used in queries and may be used to establish fine grained access control.

The relationships tie together one source service description entity to one or more target service description entities. Every relationship is given a name and a source is only allowed to have a single relationship with a given name. Some relationships are assigned by the WSRR during the shredding of key types of documents. The relationship established between XSD documents based on the importing of one into the other is one such system assigned relationship. Relationships may also be user defined. For example a user may relate a concept that represents an external object to a service using a user defined relationship relate all of the service description documents that will be governed as a unit to a governable entity and or relate a monitoring policy to a service endpoint.

A user may load classification into the registry where it may then be used to apply semantic meaning to service description entities . Classification systems are documents encoded using the Web Ontology Language OWL . The registry represents OWL Classes as classifiers and interprets the subTypeOf relationship between those Classes as establishing a classifier hierarchy. Other OWL concepts such as data or relationship representing properties or other built in OWL relationships may be ignored. A classification system is imported into the registry as a whole and updates may be made by importing a modified version of the ontology. Any class in the underlying ontology may be used as a classification the same classification may be used to classify multiple entities and an entity may be associated with multiple classifications.

The policy user interface renderer renders a policy document user interface from a policy document user interface model including user options for editing the details of the policy document.

The policy user interface factory parses a policy document e.g. A B and an associated domain policy definition e.g. A B to create a policy user interface model comprising the policy document details and user selectable options for creating removing updating or deleting the details.

The policy domains e.g. A B as shown by the dashed lines are logical domains that group relevant policy documents e.g. A B and domain policy definitions e.g. A B together.

The domain policy definitions A and B are XML documents that conform to an XML schema XSD for modelling types of policies assertions and properties that are defined in the WS Policy specification. Each domain policy definition describes the structure of valid policy documents.

In step an editing session is initialized for a new policy document the policy editor initializes a policy user interface model by reading domain policy definitions in order to find a list of supported domains.

In step the user selects a particular domain option for example in the user has selected the Multiple Supporting Token Policy . In the preferred embodiment the user is using a client application allowing remote editing of the policy document. The client application sends a message to the policy editor in the server to indicate the selection. The policy document and policy user interface model is updated to indicate the policy domain and a document node for that domain is created as a root node for the document.

In step components for the new node are read in from the appropriate domain policy definition and a list of possible options is computed from these components. The components may include rules assertions properties or further policies. The policy user interface model is modified in order to only present the user with options that are relevant to the node in the domain policy definition. For example the policy user interface model is updated to reflect the possible actions as computed by the server code. In the example of the interface model is updated to extend the node with user options of Change Policy Type Add Assertion Add WS Policy Element .

In step the user selects one of the options that are permitted by the user interface. In the example of Add Assertion is selected to the policy node and an assertion node Signed Supporting Tokens is added to the policy node.

In step a request is made for a list of components for the new node in the policy document. The policy editor consults the policy domain definition file in order to compile options for the new node and modify the user interface.

In step similar to step the user selects an option for the policy node. In the example of the user has added a Signed Supporting Tokens assertion to the Multiple Supporting Token Policy . The user can make modifications to the assertion within the constraints of the controlling user interface for instance to name the assertion.

In step the user can add another node to an existing node by selecting a node option or the root of the policy document step or can finish editing the document. In the example of the user has added a Supporting Tokens Policy policy to the Signed Supporting Tokens assertion and added to the root policy a Signed Encrypted Supporting Tokens assertion a further Supporting Tokens Policy and an Algorithm Suite assertion.

In the preferred embodiment each of these interactions is performed using AJAX Asynchronous Javascript and XML techniques to provide an improved user experience and there is no whole page refresh that causes the screen to go blank and be redrawn.

In another example embodiment the policy editor allows the policy document to be edited using a text editor. Changes to the policy document are validated against a domain policy definition and changes that are invalid are notified to the user.

It will be clear to one of ordinary skill in the art that all or part of the method of the preferred embodiments of the present invention may suitably and usefully be embodied in a logic apparatus or a plurality of logic apparatus comprising logic elements arranged to perform the steps of the method and that such logic elements may comprise hardware components firmware components or a combination thereof.

It will be equally clear to one of skill in the art that all or part of a logic arrangement according to the preferred embodiments of the present invention may suitably be embodied in a logic apparatus comprising logic elements to perform the steps of the method and that such logic elements may comprise components such as logic gates in for example a programmable logic array or application specific integrated circuit. Such a logic arrangement may further be embodied in enabling elements for temporarily or permanently establishing logic structures in such an array or circuit using for example a virtual hardware descriptor language which may be stored and transmitted using fixed media or transmittable carrier media respectively.

It will be appreciated that the method and arrangement described above may also suitably be carried out fully or partially in software running on one or more processors not shown in the figures and that the software may be provided in the form of one or more computer program elements carried on any suitable data carrier also not shown in the figures such as a magnetic or optical disk or the like. Channels for the storage and transmission of data may likewise comprise storage media of all descriptions as well as signal carrying media such as wired or wireless signal carrying media respectively.

The present invention may further suitably be embodied as a computer program product for use with a computer system. Such an implementation may comprise a series of computer readable instructions either fixed on a tangible storage medium such as a computer readable medium for example diskette CD ROM ROM or hard disk or transmittable to a computer system using a modem or other interface device over either a tangible communication medium including but not limited to optical or analogue communications lines or intangibly using wireless communication techniques including but not limited to microwave infrared or other transmission techniques. The series of computer readable instructions embodies all or part of the functionality previously described herein.

Those skilled in the art will appreciate that such computer readable instructions may be written in a number of programming languages for use with many computer architectures or operating systems. Further such instructions may be stored using any memory technology present or future including but not limited to semiconductor magnetic or optical or transmitted using any communications technology present or future including but not limited to optical infrared or microwave. It is contemplated that such a computer program product may be distributed as a removable medium with accompanying printed or electronic documentation for example shrink wrapped software pre loaded with a computer system for example on a system ROM or fixed disk or distributed from a server or electronic bulletin board over a network for example the Internet or World Wide Web.

In an alternative the present subject matter may be realized in the form of a computer implemented method of deploying a service comprising steps of deploying computer program code operable to when deployed into a computer infrastructure and executed thereon cause the computer system to perform all the steps of the method.

In a further alternative the present subject matter may be realized in the form of a data carrier having functional data thereon said functional data comprising functional computer data structures to when loaded into a computer system and operated upon thereby enable said computer system to perform all the steps of the method.

It will be clear to one skilled in the art in view of the teachings above that many improvements and modifications may be made to the foregoing exemplary embodiment without departing from the scope of the present invention.

IBM and WebSphere are registered trademarks or trademarks of International Business Machines Corporation in the United States and or other countries. Java and all Java based trademarks are trademarks of Sun Microsystems Inc. in the United States other countries or both. Eclipse is a trademark of Eclipse Foundation Inc.

