---

title: Tracking a server request
abstract: A technique includes inserting () code () into an application () as the application () is executing on a computer (). The code () causes the application () to communicate with a monitoring tool () about an inter-application message that is associated with a server request that is provided by a client (). The technique includes using the monitoring tool () to operate on a correlation token that is appended to the message to track processing of the server request.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09009729&OS=09009729&RS=09009729
owner: Hewlett-Packard Development Company, L.P.
number: 09009729
owner_city: Houston
owner_country: US
publication_date: 20100630
---
The current prevailing architectural model for server side applications is based on the reactive principle in which the server performs some work in response to receiving an external request from a requesting party and then communicates a response i.e. the result to the requesting party. A major indicator of server performance is the server request latency which is the time that elapses from the time at which the server receives the request until the time at which the server provides the response.

A performance analyst typically is interested in such factors as which particular server requests take relatively long times to execute and the internal processing details for these server requests for purposes of understanding and pinpointing the root causes of the delays.

A conventional server request may spawn several ancillary requests in that for purposes of fulfilling the request the initially contacted server may communicate additional requests to other servers. Such cross server communications typically complicate the diagnostic analysis in that many components are involved and may interject corresponding problems that contribute to the overall latency in responding to the initial server request.

Systems and techniques are disclosed herein for purposes of tracking a server request that is made by a client and is provided to a server side programming framework called the server side herein . On the server side the server request from the client may result in a multitude of requests which include an initial request that is received from client and resulting ancillary requests that are spawned on the server side in the processing of the initial request. More specifically in general the processing of a given server request from the client involves the communication of messages called inter application messages herein among different components or applications on the server side. In this regard the server side may be constructed from several layers or applications which in turn may reside on one or on multiple servers. When an application on the server side receives a request from a client the application in the course of processing the request may issue ancillary requests in the form of inter application messages to other applications and this process may continue and be recursive.

As disclosed herein for purposes of tracking the processing of the server request by the different applications on the server side a coloring or correlation token is appended to each inter application message that is communicated for purposes of fulfilling the request. As described further below a monitoring tool for example a diagnostic tool processes the correlation tokens for purposes of analyzing the execution associated with the processing of the server request even if the ultimate processing of the server request involves multiple applications on the server side. In other words the diagnostic tool uses the correlation tokens for purposes of analyzing latencies execution times etc. associated with processing across all components on the server side.

The techniques and systems that are disclosed herein permit inter application message communications to be monitored regardless of whether the inter application messages are communicated using standardized communication protocols or using legacy protocols proprietary protocols for example which do not adhere to any particular standard. Thus some server side components may be legacy applications which use restricted or unknown communication protocols. In this manner some applications that are used in the processing of a server request may have been developed several years prior or even decades in the past. The monitoring tool may still be used with such applications as the use of the correlation tokens and code snippets described below permit the monitoring of the inter application message communications regardless of the type of communication protocols that the applications employ.

As a more specific example in accordance with some embodiments of the invention the server side may be implemented on a system such as the exemplary system that is depicted in . In general the system of includes multiple physical machines exemplary machines and being depicted in that are interconnected by a network . Examples of physical machines include computers e.g. application servers storage servers web servers etc. communications modules e.g. switches routers etc. and other types of machines. The network may also include system buses or other fast interconnects. Physical machine indicates that the machine is an actual machine made up of executable program instructions and hardware.

Examples of the network include a local area network LAN a wide area network WAN the Internet any other type of communications link or combinations thereof. The physical machines may be located within one cabinet or rack or alternatively the physical machines may be located in multiple cabinets or racks or even be geographically dispersed.

The system that is depicted in may be any one of an application server a storage server farm or storage area network a web server farm a switch or router farm other type of data center and so forth. Also although three physical machines are depicted in it is noted that more than three physical machines two physical machines or one physical machine may be used in accordance with other implementations.

Although each of the physical machines is depicted in as being contained within a box it is noted that a physical machine may be a distributed machine having multiple nodes which provide a distributed and parallel processing system.

As depicted in in some implementations the physical machine may store machine executable instructions . These instructions may include one or multiple applications an operating system and one or multiple device drivers which may be part of the operating system .

The physical machine may also include hardware which includes a processor such as one or multiple central processing unit CPUs one CPU being depicted in for purposes of a non limiting example . Each CPU may have one or multiple processing cores. The hardware may also include a system memory and a network interface . In some implementations one or multiple CPUs execute the machine executable instructions . The machine executable instructions may be stored in any of various forms of machine readable media such as the memory removable media magnetic storage optical storage memory on another machine etc.

In accordance with some implementations the applications on one or multiple physical machines form all or part of the components of a particular composite server side application framework. As depicted in in addition to the components described above the executable instructions also include a monitoring tool for purposes of tracking the inter component processing of the server request on the server side such as tracking the processing of the initial request from the client processing resulting ancillary requests gathering and processing intermediate results and ultimately providing the final result to the client.

The physical machine is merely an example of a particular physical machine for a server. It is noted that the server side may be formed from multiple physical machines such as machine in combination with other physical machines such as physical machine and or physical machine for example. Thus a given server side may include one or multiple applications with the physical machine one or multiple applications with another physical machine one or multiple applications on multiple physical machines etc.

Regardless of the particular implementation for the examples that are disclosed herein a given server request originates with an initial request that is provided by a client via a physical machine not depicted in and is received by one of the applications to initiate the processing that ultimately results in a response that fulfills the client s request. The processing of the initial request from the client may spawn additional ancillary requests which propagate via inter application messages to other applications that may be located on the same physical machine and or on different physical machines .

In accordance with implementations disclosed herein for purposes of monitoring the inter application messaging associated with the request processing even when standardized and or non standardized communication protocols are used in these communications each of the applications on the server side is dynamically modified by a code snippet . In general the code snippet is program code that is inserted at a particular execution or instrumentation point in the code of the application for purposes of causing the application to perform an intended function at the instrumentation point. As a more specific example in accordance with some implementations the code snippet is derived by a program analyst who writes uncompiled program code to perform a particular function and a run time compiler compiles this uncompiled code and inserts it into the other compiled code for the application while the application is executing as described in U.S. Patent Application Publication Serial No. 20090172653 entitled Compiling And Inserting Code Snippets At Runtime which was filed on Sep. 27 2008 published on Jul. 2 2009. The use of the code snippets for a given application effectively allows automatic modification of the application to permit the communication of correlation tokens in messages that are communicated to and from the application regardless of the messaging communication protocol that is employed by the application .

In accordance with some implementations the code snippet exposes the application to application programming interfaces APIs of the monitoring tool and these APIs of the monitoring tool are configured to process and update the correlation tokens that are appended on the inter application messages. More specifically a particular code snippet may be written for purposes of inserting code at an instrumentation point of the application associated with sending inter application messages. For this example the code snippet exposes the application to APIs of the monitoring tool which are configured to attach an updated correlation token into an outgoing inter application message. As another example a particular code snippet may be written for purposes of inserting code at an instrumentation point of the application at which the application receives messages pertaining to initial and ancillary requests. Therefore when an inter application message is received the code snippet may be used to expose the application to corresponding APIs of the monitoring tool for processing the message to for example extract and parse the correlation token. As described further below this updated correlation token may include an updated topology for the message to indicate the history of the processing for the server request up to the time of the message.

In some implementations the attachment of the correlation token may be used to leverage the structure of the message being passed between the application components and the correlation token may be inserted into the message without affecting the integrity of the message structure. For example if Hypertext Transfer Protocol HTTP is used as the communication protocol additional HTTP header fields may be used for the purpose of passing the correlation token. In another example if Java Message Service JMS is used for communication between the application components a JMS message property may be used to insert the correlation token into the message.

In other implementations when the structure of the messages passed between the application components is not flexible or even is unknown the code snippet may use a wrapping technique that is create a composite message which contains the correlation token and the unmodified original message. On the receiving side another code snippet the receiving side code snippet for this example unwraps the received message and passes the extracted correlation token to the monitoring tool and for this example the receiving side code snippet also extracts the original application message and passes it to the receiving application component. In all cases the correlation tokens are attached and detached from the messages without the need to change the application or the tool source code or recompile.

Thus the extraction of the appended correlation token from an inter application message as well as the appending of the correlation token to an inter application message is independent of the communication protocol that is used to communicate the inter application message. As a result the monitoring tool may be developed without the developer or provider of the tool possessing any knowledge about the communication protocols techniques employed by the application s used by the prospective customers. Knowledge of the protocols techniques is used by a programming analyst for purposes developing the code snippets . Because the code snippets may be created any time after the application or the monitoring tool are released generic monitoring support may be provided. Therefore even if a given application uses some obscure legacy communication technique supporting this technique merely involves writing the code snippets for the application which may involve for example a relatively few lines of programming code. In accordance with implementations described herein all this happens without changing the application source code changing the monitoring tool source code or recompiling.

As a non limiting example depicts an exemplary topology associated with an exemplary server request in accordance with some implementations. Referring to for this example the topology is associated with the processing of a loan application and the server side processes the loan application on behalf of a lender or bank. In this manner a client a computer system used by the loan applicant for example initiates the server request by communicating an initial request a request containing the completed loan application for processing by the bank for example to an Internet server as a non limiting example which initiates an instance of an application see for purposes of initially processing the request . As described below the application instance may directly and indirectly generate additional ancillary requests to initiate various processing functions associated with the processing the loan application and each of these ancillary requests may in turn spawn additional ancillary requests. At a successful conclusion the application instance provides a response to the client which may be a request for more information a denial of the loan a tentative loan approval a preliminary or intermediate result associated with the processing of the loan application etc.

The application instance is exposed to APIs of an associated instance of the monitoring tool see for purposes of processing correlation tokens that are appended on inter application messages that are received by and transmitted from the instance . In this regard code snippets expose the application instance to APIs of the monitoring tool instance for purposes of extracting the correlation tokens for incoming inter application messages and generating the appropriate correlation tokens for outgoing inter application messages. Other application instances and are configured by corresponding code snippets to be exposed to APIs of associated monitoring tool instances in a similar manner.

As a non limiting example the application instance may receive the original loan application and generate an ancillary request to cause the application instance to determine whether the applicant is recognized as a customer of the bank. In this regard the application instance may for example search a database based on a social security number date of birth and or driver s license number of the applicant for purposes of determining whether the applicant is a customer of the bank. The applicant instance returns the result via response to the application instance which may then use the results of the identification determination for purposes of requesting additional services from other application instances.

For example the application instance may submit an ancillary request to the application instance for purposes of requesting that the application instance perform a criminal background search on the applicant. As another example the application instance may submit an ancillary request to the application instance for purposes of requesting that the application instance determine whether the bank has any existing mortgages with the applicant. The application instances and return the results to the application instance via respective responses .

The ancillary requests submitted by the application instance to the application instances and are examples of asynchronous ancillary requests in that the application instance may proceed with its processing which does not depend on which response is received first. Other ancillary requests are synchronous in that a response to one request e.g. a request to determine whether the applicant has any mortgages with the bank may be required before another request a request to check for liens on the identified mortgage s for example is made.

As yet another example of an ancillary request depicts that the application instance may submit an ancillary request to the application instance . As a non limiting example the application instance may use the application instance for purposes of identifying any liens on property corresponding to mortgages held by the bank.

In accordance with some implementations as non limiting example the correlation token is a string that changes with every execution of the outbound call. In general the correlation token is unique across the enterprise which means that a different outbound call on a different machine is unable to generate the same correlation token. This setup may be used for purposes of tracing i.e. connect instances of server requests. As a further non limiting example for diagnostic purposes the correlation token may further include information which allows entities to be linked together in an aggregate fashion for purposes of constructing the request topology.

Referring to to summarize a technique may generally be performed in accordance with embodiments of the invention for purposes of tracking a server request. Pursuant to the technique a code snippet is inserted into an application pursuant to block to expose the application to the APIs of a monitoring tool and thus cause the application to communicate with the monitoring tool about the inter application message. The technique includes using the monitoring tool pursuant to block to operate on a correlation token associated with a message associated with the processing of a server request provided by a client for purposes of tracking the server request.

In accordance with some implementations the code snippet may perform a technique which is depicted in for purposes of processing an inter application message that is received by an application . This code snippet may be inserted at an instrumentation point of the application which corresponds to an execution point at which the application processes a received inter process message. Pursuant to the technique the code snippet receives block the composite inter application message which contains the message body and the pendant correlation token. The code snippet by exposing the application to the monitoring tool s APIs parses block the composite message into the body and correlation token and then communicates block the message body to the application . The code snippet further communicates the correlation token to the monitoring tool pursuant to block .

In accordance with some implementations the code snippet performs a technique that is depicted in for purposes of providing a composite message to be communicated from the application . This code snippet may be inserted at an execution point at which the application communicates an outgoing inter application message. Pursuant to the technique the code snippet exposes the application to the appropriate APIs of the monitoring tool to cause the appropriate API s to receive the message body from the application pursuant to block and receive block the associated correlation token from the monitoring tool . The code snippet then executes the appropriate API s to provide the composite message to the application for transmission pursuant to block .

Referring to in accordance with some implementations a code snippet in conjunction with the APIs of the monitoring tool perform a technique for purposes of processing an incoming correlation token. Pursuant to the technique the monitoring tool receives block the correlation token from the application and extracts block the identity of the originating server request from the correlation token pursuant to block . The monitoring tool may then otherwise process the correlation token pursuant to block . Depending on its purpose the monitoring tool may analyze certain latencies identify problem points in the server application framework etc.

Referring to in accordance with some implementations a code snippet in conjunction with APIs of the monitoring tool perform a technique for purposes of processing an outgoing composite inter application message. Pursuant to the technique the monitoring tool generates a correlation token pursuant to block . In this manner in accordance with some implementations the monitoring tool updates the request topology for the outgoing inter process message and provides block this correlation token to the application .

While the present invention has been described with respect to a limited number of embodiments those skilled in the art having the benefit of this disclosure will appreciate numerous modifications and variations therefrom. It is intended that the appended claims cover all such modifications and variations as fall within the true spirit and scope of this present invention.

