---

title: Secondary index and indexed view maintenance for updates to complex types
abstract: Pursuant to receipt of a data modification command or statement, such as an Update command, it is determined which fields in a data structure, such as a UDT, computed column, indexed view, or index, for example, will be changed as a result of the command. Only those fields that are affected by the command will be changed. Thus, changes are propagated to only to those dependent data structures whose content is being modified. Tree representations are used to facilitate the determination as to whether a subfield in a hierarchy is changed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07933913&OS=07933913&RS=07933913
owner: Microsoft Corporation
number: 07933913
owner_city: Redmond
owner_country: US
publication_date: 20100715
---
The instant application is a divisional application of U.S. application Ser. No. 10 891 220 filed Jul. 14 2004 entitled Improving Secondary Index and Indexed View Maintenance for Updates to Complex Types which is incorporated by reference herein in its entirety.

The present invention relates generally to the field of information storage and retrieval and more particularly to query optimization and management.

Traditional approaches to the organization of information in computer systems have centered on the use of file folder and directory based systems file systems to organize files into directory hierarchies of folders based on an abstraction of the physical organization of the storage medium used to store the files. Typically storable data has been organized into files folders and directories at the operating system level. These files generally include the file hierarchy itself the directory embodied in a special file maintained by the file system. This directory in turn maintains a list of entries corresponding to all of the other files in the directory and the nodal location of such files in the hierarchy herein referred to as the folders . Such has been the state of the art for approximately forty years.

However while providing a reasonable representation of information residing in the computer s physical storage system a file system is nevertheless an abstraction of that physical storage system and therefore utilization of the files requires a level of interpretation between what the user manipulates units having context features and relationships to other units and what the operating system provides files folders and directories . Consequently users applications and or end users have no choice but to force units of information into a file system structure even when doing so is inefficient inconsistent or otherwise undesirable. Because most existing file systems utilize a nested folder metaphor for organizing files and folders as the number of files increases the effort necessary to maintain an organization scheme that is flexible and efficient becomes quite daunting.

Several unsuccessful attempts to address the shortcomings of file systems have been made in the past. Some of these previous attempts have involved the use of content addressable memory to provide a mechanism whereby data could be accessed by content rather than by physical address. However these efforts have proven unsuccessful because while content addressable memory has proven useful for small scale use by devices such as caches and memory management units large scale use for devices such as physical storage media has not yet been possible for a variety of reasons and thus such a solution simply does not exist. Other attempts using object oriented database OODB systems have been made but these attempts while featuring strong database characteristics and good non file representations were not effective in handling file representations and could not replicate the speed efficiency and simplicity of the file and folder based hierarchical structure at the hardware software interface system level.

Newly developed storage systems such as WinFS described further below store the directory of the files as table s in a database. Each file is represented by a row in a base table and file system operations such as enumerate all files in a directory are satisfied using queries against the database engine. Thus efficiently performing basic operations against the store involves efficiently optimizing database queries.

In such storage systems the concept of a file is extended to that of an object . Metadata about the file is stored in a managed CLR common language runtime object with a schema defined in the storage system to represent the allowable descriptive data for that object. For example a picture would have a representative CLR object that would store data such as its resolution time it was taken and location information. This object model supports data inheritance. With data inheritance it is possible to derive a type from another and add new fields. For example a sub class of the picture could be created such as DriversLicensePicture . Such a sub class would contain extra information such as a Driver s License ID field.

In these newly developed storage systems such as WinFS the exposed schemas are mapped to tables through a translation layer. Users only see a series of views of the data instead of operating on the base tables. While the exact design of this mapping is not significant it serves as the glue between the WinFS API and the underlying storage format. Users do not control or see this mapping directly.

The WinFS store also exposes the concept of querying objects based on their type as opposed to their file name as in earlier conventional file systems. Type based queries can search for an exact type or any type that derives from a given type. This latter form is called hierarchical matching and it is expected to be a common WinFS operation. WinFS also supports searching by file.

WinFS s schema model poses some new challenges to the query processor. User defined types or UDTs are used extensively and it is common to retrieve all UDTs from a table based on the UDT type. Furthermore WinFS uses UDT inheritance and it is also a requirement to retrieve all elements of a given type and also any subtype from a table. Multiple tables exist each containing a different number of UDTs types type topology and UDT distribution within that topology. Additionally searching operations may go beyond those operations seen in traditional relational database systems to include for example searching of XML documents or performing searches over all fields in an object. These properties make it difficult to make accurate cardinality and cost estimates and also make it difficult to efficiently retrieve values based on type subtype hierarchy.

Materialized views also referred to herein as indexed views have been a subject of database research for over a decade. The basic idea is to materialize or store the result of some query then use such computed result when similar queries are submitted to the database. For example it may be desirable to store the result of sales per day for example and use the result this materialized view in the future to answer several related queries such as sales in a given month or total sales in the year.

For additional flexibility applications should not need to be aware that certain views exist or are materialized. The query processor should identify matches between user queries and existing pre computed results materialized views and use such results when applicable. This is known as the view utilization problem Given a user query written over base tables as well as a collection of materialized views which materialized views can be used to answer such query And the cost based variant of the question Which of those materialized views should be used 

Materialized views are similar to indices in that they should be part of the physical design of the database and their primary purpose is to improve performance. The logical design of the database and correctness of applications should be independent of the presence or absence of materialized views. As with indices materialized views can introduce dramatic improvements in query performance.

Query optimizers are normally structured such that there is an initial simplification stage followed by exploration of alternatives and cost based selection of an execution plan as shown in .

During the simplification normalization stage some changes are made on the original query Q such as pushing selections down or rewriting a subquery as a join when possible. These modifications are aimed at obtaining a better query. Typically there is no detailed cost estimation at this stage and a single better query Q is produced as the result.

The second stage exploration and cost based selection in optimization is directed to generating multiple alternatives and using a detailed cost model to select the alternative with the cheapest estimated execution cost. Two conventional architectures for the exploration stage are bottom up dynamic programming join enumeration and transformation driven generation of alternatives. Both architectures set up a table of alternatives as is well known which compactly encodes the various possibilities for each sub expression of a query.

The SQL query language provides a user with the ability to query and modify tabular data stored using the relational data model. The relational data model dictates that each cell in a table a column of a row is a single scalar or atomic value. The structured query language SQL is an American National Standards Institute ANSI standard used to communicate with a relational database. SQL statements are used to perform tasks such as update data or retrieve data from a relational database. Although many database systems use SQL many of them also have their own additional proprietary extensions that are usually only used on their system. However the standard SQL commands such as Select Insert Update Delete Create and Drop can be used to accomplish many things that one desires to do with a relational database and are believed to be well known to those skilled in the database art.

The SQL Server database management system DBMS supports secondary indexes and indexed views built over tables to speed up certain kinds of data retrieval operations. A secondary index is a data structure organized like a tree which contains a subset of the columns belonging to the table. An indexed view is the pre computed result of a query stored into a derived table which can have secondary indexes as well. Secondary indexes and indexed views are referred to as data structures dependent on the table. Other kinds of dependent objects exist such as constraints.

When an Insert Update or Delete statement is processed the DBMS has to propagate the change from the table to the dependent structures so that they are always kept consistent which each other. This allows subsequent data retrieval queries to return the same data independently on whether they access the table a secondary index or an indexed view. Thus whenever modifications are made to the table they must be made to the secondary indexes and indexed views as well. The cost of making changes is proportional to the number of places where the change has to be made. While Insert and Delete operations need to be propagated to all the secondary indexes and indexed views Update statement processing is conventionally optimized to propagate the change only to the data structures that carry columns being modified by the statement. For example if a secondary index only contains the column C1 of a table T an update to the C2 column will not be propagated to the index because its content will be unchanged.

Both secondary indexes and indexed views can be built in SQL Server over both regular table columns and scalar expressions over table columns. For example it is possible to build a secondary index over the sum of the C1 and C2 columns. Conventionally whenever an Update statement affects one or more of the columns participating in a scalar expression the expression will be assumed to be changing and the change will be propagated to all the dependent data structures that carry this expression.

Support for complex data types has been added to SQL Server through UDTs. The syntax of the SQL Update statement allows granular updates to subfields of a UDT along with the ability to overwrite an entire column with a new value. However by using the traditional technique described above for scalar expressions a granular update to a UDT would be assumed to affect all the data structures dependent on any of its subfields and thus changes are propagated to dependent data structures whose content might not be modified by the update. This technique is inefficient and expensive. In other words conventionally granular updates to UDT columns are assumed to affect all its subfields thereby degrading performance in the presence of many dependent access paths.

For example in the prior art for an Update it is assumed that if any of the terms in the expression are being changed then the entire expression is being changed. For example in the computed column PERSON.ADDRESS.ZIP when any of PERSON s subfields are updated it is assumed that the address and zip also change so the computed column is always updated. This is a very conservative approach and not desirable.

In view of the foregoing there is a need for systems and methods that overcome the limitations and drawbacks of the prior art.

The following summary provides an overview of various aspects of the invention. It is not intended to provide an exhaustive description of all of the important aspects of the invention nor to define the scope of the invention. Rather this summary is intended to serve as an introduction to the detailed description and figures that follow.

Pursuant to receipt of a data modification command or statement such as an Update command it is determined which fields in a data structure such as a user defined type UDT computed column indexed view or index for example will be changed as a result of the command. Only those fields that are affected by the command will be changed. Thus changes are propagated to only to those dependent data structures whose content is being modified. Tree representations are used to facilitate the determination as to whether a subfield in a hierarchy is changed.

Exemplary embodiments include a method of processing a data modification statement comprising receiving a data modification statement determining which fields of a data structure are affected by the data modification statement and modifying a query plan in response to the fields of the data structure that are affected by the data modification statement.

According to aspects of the invention a tree representation for the data modification statement is determined along with operator trees representing the expressions of the secondary structures related to the involved tables. Both trees are compared to determine which secondary structures are affected by the data modification statement.

Another exemplary embodiment is directed to a system for processing a data modification statement comprising a front end that receives a data modification statement and a query optimizer that determines which fields of a data structure are affected by the data modification statement and modifies a query plan responsive to the fields of the data structure that are affected by the data modification statement.

According to aspects of the invention the front end comprises a parser and algebrizer that transforms the textual representation of the data modification statement into tree nodes. The front end may be adapted to determine a tree representation for the data modification statement and for the expressions of secondary structures. The query optimizer may be adapted to determine which secondary structures are affected by the data modification statement by comparing the tree representation for the secondary structures and the tree representation for the data modification statement.

Additional features and advantages of the invention will be made apparent from the following detailed description of illustrative embodiments that proceeds with reference to the accompanying drawings.

The subject matter is described with specificity to meet statutory requirements. However the description itself is not intended to limit the scope of this patent. Rather the inventors have contemplated that the claimed subject matter might also be embodied in other ways to include different steps or combinations of steps similar to the ones described in this document in conjunction with other present or future technologies. Moreover although the term step may be used herein to connote different elements of methods employed the term should not be interpreted as implying any particular order among or between various steps herein disclosed unless and except when the order of individual steps is explicitly described.

Numerous embodiments of the present invention may execute on a computer. and the following discussion are intended to provide a brief general description of a suitable computing environment in which the invention may be implemented. Although not required the invention will be described in the general context of computer executable instructions such as program modules being executed by a computer such as a client workstation or a server. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types.

An object is a unit of storable information accessible to a hardware software interface system that has a basic set of properties that are commonly supported across all objects exposed to an end user by the hardware software interface system shell. Objects also have properties and relationships that are commonly supported across all types including features that allow new properties and relationships to be introduced. A complex structured type consists of a set of fields properties and methods. Each field or property can be one of a scalar type a complex structure type itself or of a multiset in which each element is a complex structured type.

Those skilled in the art will appreciate that the invention may be practiced with other computer system configurations including handheld devices multiprocessor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

As shown in an exemplary general purpose computing system includes a conventional personal computer or the like including a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the personal computer such as during start up is stored in ROM .

The personal computer may further include a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM or other optical media. The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of computer readable instructions data structures program modules and other data for the personal computer .

Although the exemplary environment described herein employs a hard disk a removable magnetic disk and a removable optical disk it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks Bernoulli cartridges random access memories RAMs read only memories ROMs and the like may also be used in the exemplary operating environment.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the personal computer through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite disk scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor personal computers typically include other peripheral output devices not shown such as speakers and printers. The exemplary system of also includes a host adapter Small Computer System Interface SCSI bus and an external storage device connected to the SCSI bus .

The personal computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the personal computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the personal computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the personal computer typically includes a modem or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the personal computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

While it is envisioned that numerous embodiments of the present invention are particularly well suited for computerized systems nothing in this document is intended to limit the invention to such embodiments. On the contrary as used herein the term computer system is intended to encompass any and all devices comprising press buttons or capable of determining button presses or the equivalents of button presses regardless of whether such devices are electronic mechanical logical or virtual in nature.

As illustrated in the block diagram of a computer system can be roughly divided into three component groups the hardware component the operating system component and the applications programs component .

In certain computer systems and referring back to the hardware may comprise the central processing unit CPU the memory both ROM and RAM the basic input output system BIOS and various input output I O devices such as a keyboard a mouse a monitor and or a printer not shown among other things. The hardware component comprises the basic resources for the computer system .

The applications programs component comprises various software programs including but not limited to compilers database systems word processors business programs videogames and so forth. Application programs provide the means by which computer resources are utilized to solve problems provide solutions and process data for various users e.g. machines other computer systems and or end users .

The operating system component comprises the operating system itself and its shell and kernel. An operating system OS is a special program that acts as an intermediary between application programs and computer hardware and the purpose of an operating system is to provide an environment in which a user can execute application programs. The goal of any operating system is to make the computer system convenient to use as well as utilize the computer hardware in an efficient manner.

The operating system is generally loaded into a computer system at startup and thereafter manages all of the application programs or simply applications in the computer system. The application programs interact with the operating system by requesting services via an application program interface API . Some application programs enable end users to interact with the operating system via a user interface such as a command language or a graphical user interface GUI .

An operating system traditionally performs a variety of services for applications. In a multitasking operating system where multiple programs may be running at the same time the operating system determines which applications should run in what order and how much time should be allowed for each application before switching to another application for a turn. The operating system also manages the sharing of internal memory among multiple applications and handles input and output to and from attached hardware devices. The operating system also sends messages to each application and in certain cases to the end user regarding the status of operations and any errors that may have occurred.

An operating system s shell is the interactive end user interface to an operating system. A shell is the outer layer of an operating system that is directly accessible by application programs and even directly by end users. In contrast to a shell the kernel is an operating system s innermost layer that interacts directly with the hardware components.

As well understood by those of skill in the relevant art files are entities of information including but not limited to the operating system itself as well as application programs data sets and so forth that are capable of being manipulated as discrete storable and retrievable entities by an operating system. In modern operating systems files are the basic units of storable information e.g. data programs and so forth that are manipulated by the operating system and groups of files are organized in folders .

A storage platform for organizing searching and sharing data that can be used with the present invention is designed to be the store for all types of data. Referring to a storage platform in accordance with the present invention comprises a data store implemented on a database engine . In one embodiment the database engine comprises a relational database engine with object relational extensions. In one embodiment the relational database engine comprises the Microsoft SQL Server relational database engine.

The data store implements a data model that supports the organization searching sharing synchronization and security of data. Specific types of data are described in schemas such as schemas and the storage platform provides tools for deploying those schemas as well as for extending those schemas.

A change tracking mechanism implemented within the data store provides the ability to track changes to the data store. The data store also provides security capabilities and a promotion demotion capability . The data store also provides a set of application programming interfaces to expose the capabilities of the data store to other storage platform components and application programs e.g. application programs and that utilize the storage platform.

The storage platform of the present invention still further comprises an application programming interface API which enables application programs such as application programs and to access all of the foregoing capabilities of the storage platform and to access the data described in the schemas. The storage platform API may be used by application programs in combination with other APIs such as the OLE DB API and the Microsoft Windows Win32 API .

The storage platform of the present invention may provide a variety of services to application programs including a synchronization service that facilitates the sharing of data among users or systems. For example the synchronization service may enable interoperability with other data stores having the same format as data store as well as access to data stores having other formats. The storage platform also provides file system capabilities that allow interoperability of the data store with existing file systems such as the Windows NTFS file system . A SQL store may also be provided.

In at least some embodiments the storage platform may also provide application programs with additional capabilities for enabling data to be acted upon and for enabling interaction with other systems. These capabilities may be embodied in the form of additional services such as an Info Agent service and a notification service as well as in the form of other utilities .

In at least some embodiments the storage platform is embodied in or forms an integral part of the hardware software interface system of a computer system. For example and without limitation the storage platform of the present invention may be embodied in or form an integral part of an operating system a virtual machine manager VMM a Common Language Runtime CLR or its functional equivalent or a Java Virtual Machine JVM or its functional equivalent or other such software components in the place of or in addition to the operating system in a computer system. The purpose of a hardware software interface system is to provide an environment in which a user can execute application programs.

Through its common storage foundation and schematized data the storage platform of the present invention enables more efficient application development for consumers knowledge workers and enterprises. It offers a rich and extensible programming surface area that not only makes available the capabilities inherent in its data model but also embraces and extends the existing file system and database access methods.

In the description herein and in various ones of the figures the storage platform of the present invention may be referred to as WinFS. However use of this name to refer to the storage platform is solely for convenience of description and is not intended to be limiting in any way.

The data store of the storage platform of the present invention implements a data model that supports the organization searching sharing synchronization and security of data that resides in the store. The data model provides a mechanism for declaring objects and object extensions and for establishing relationships between objects and for organizing and categorizing objects.

The relational database engine which in one embodiment comprises the Microsoft SQL Server engine supports built in scalar types. Built in scalar types are native and simple . They are native in the sense that the user cannot define their own types and they are simple in that they cannot encapsulate a complex structure. User defined types UDTs provide a mechanism for type extensibility above and beyond the native scalar type system by enabling users to extend the type system by defining complex structured types. Once defined by a user a UDT can be used anywhere in the type system that a built in scalar type might be used.

The storage platform schemas are mapped to UDT classes in the database engine store. Data store objects are mapped to UDT classes deriving from the Base.Item type. Extensions are also mapped to UDT classes and make use of inheritance. The root Extension type is Base.Extension from which all Extension types are derived.

A UDT is a CLR class it has state i.e. data fields and behavior i.e. routines . UDTs are defined using any of the managed languages C VB.NET etc. UDT methods and operators can be invoked in T SQL against an instance of that type. A UDT can be the type of a column in a row the type of a parameter of a routine in T SQL or the type of a variable in T SQL for example.

The present invention is directed to optimizing granular updates to UDTs or other data structures in the presence of indexes or indexed views over scalar expressions that represent their subfields. Exemplary optimization comprises detecting if such indexes or indexed views over UDT subfields are affected by a data modification statement e.g. an Update command and changes are propagated only to the dependent data structures whose content is being modified. Aspects of the invention involve detecting the presence of scalar expressions representing a subfield or subfields of a UDT inside an index or indexed view definition or any other kind of dependent object matching such expressions against the representation of the granular update being run and determining whether the data structure needs to be maintained or not.

Pursuant to receipt of a data modification command or statement such as an Update command it is determined which fields in a data structure such as a UDT computed column indexed view or index for example will be changed as a result of the command. An Update command is used in the description of the exemplary embodiments described herein but it is contemplated that other types of data modification commands or statements may be used. Only those fields that are affected by the command will be changed. Thus changes are propagated to only to those dependent data structures whose content is being modified. Tree representations are used to facilitate the determination as to whether a subfield in a hierarchy is changed.

For example a computed column has a representation in tree form. This tree representation is obtained along with a tree representation of the data modification statement or command. The two tree representations are compared to determine if the computed column should be updated.

Similarly indexed views stored pre computed query results can be used in accordance with the present invention. shows a flow diagram of an exemplary method of processing a data modification statement in accordance with the present invention. At step a data modification statement is received along with a textual representation of the indexed view which may be received or determined separately . An operator tree i.e. a relational tree that defines the indexed view or whatever field of the data structure is being considered is then determined at step . At step a tree representation for the data modification statement is determined. For each of the relational operators in the tree determined at step its child scalar expressions are obtained and compared to the update tree from step to determine if the fields of the data structure being considered are being updated at step . If so the query plan is modified accordingly at step . If the fields of the data structure being considered are not to be changed or otherwise modified by the data modification command or statement then no change is made to the related portion of the query plan at step .

In particular a query processor walks the tree representation of the update trying to match subfields used in the index expressions with those being updated. If a match is found the corresponding index expression is considered to be changed and a query execution plan will be generated that propagates the update to the index. Because only the subfields that are being changed or updated by the data modification command are considered the runtime disk access is thus more efficient. Examples are provided with respect to .

Database management systems DBMS allow modification of existing table rows through Update statements or other data modification commands. For example a user may specify via a command statement the table to update called the target table the columns to modify and their respective new value s and qualify the rows to be updated through a Where clause which is similar to that in a Select statement.

An example of an Update statement is Update T set A 5 Where B 10 which means that for each row in table T where column B is 10 column A has to be set to 5. A flow diagram of exemplary steps involved when receiving this statement in this example is shown in . At step the table T is read. A filter is applied to the table at step to determine which column B s are 10 . At step the column A s corresponding to the 10 column B s are updated to be set equal to 5 .

The updating during step uses an update query plan compiled by a query optimizer described further below. The update query plan compiled by the query optimizer guarantees the preservation of data integrity after its execution. This is achieved by a proper instrumentation of the plan with actions falling in two categories either validating a constraint or maintaining a dependent data structure so that its content remains consistent with the target table. DBMSs allow redundant duplication of data in secondary data structures to allow faster processing of certain categories of queries. Maintaining consistency between the base table and its dependent secondary structures allows subsequent data retrieval queries to receive the same results independently from the data source that is chosen to implement the operation.

An Update statement can hence be seen as firing actions that were not explicitly described in the original syntax but that are implicitly used in order to preserve data integrity. These actions are performed at step . Typical implicit actions are secondary index maintenance indexed view maintenance check and referential integrity constraint validation cascading actions full text notifications and query notifications. In SQL Server the implicit update actions are desirably performed after modifying the base table and in appropriate order.

In order to identify the desired implicit actions to include in the update query plan the SQL Server query optimizer enumerates the various kinds of objects that have a dependency on the table being updated. For each object it is determined if the object is affected by the statement. If this is the case the plan is modified to include appropriate operators guaranteeing that its execution does not cause data corruption for the object. An object is considered to be affected by the statement only if referencing one or more of the columns being updated.

Avoiding maintenance of objects that do not reference columns or other data structure fields being updated is a compile time optimization that avoids processing operations guaranteed to be unnecessary by the syntax of the statement. Such optimization is desirable in order to guarantee acceptable performance. The number of dependent objects can be very high and some of the implicit actions used to maintain them can be extremely expensive.

Query processing in accordance with the present invention is implemented in the SQL Server DBMS through the interaction of the following exemplary components as shown in a front end parser and algebrizer a query optimizer a query execution component and a storage engine . The front end and query optimizer perform at compile time and the query execution component and storage engine perform during execution time.

A SQL command or data modification statement such as Update is received e.g. as text from a user . The front end receives the query statement in textual format and converts it to a tree based representation describing at the logical level what the command is meant to do. In other words a parser algebrizer transforms the textual representation of the user s commands into tree nodes. The parser provides an update operator that internally represents the update statements functionally semantically . The algebrizer provides TARGET TABLE COLUMNS NEW VALUES TYPE OF UPDATE for example.

The query optimizer explores the possible alternative ways of implementing the query statement trying to choose the most efficient. The query optimizer produces another tree that represents at the physical level the plan to implement the query statement. A query optimizer generates the physical plan by transforming the tree and finding the structural physical implementation that should be performed to implement the functionality. The optimizer determines the secondary indexes that are to be maintained i.e. partial update index maintenance . The optimizer enumerates the dependencies on the TABLE dependencies include indexed views and secondary indexes for example . For each dependent object the type of dependency is determined along with what it is based on e.g. based on a column s or an expression s based on a subfield of a UDT. If the dependency is based on a UDT expression that extracts a subfield then the syntax of the command is taken and it is determined if the dependent object is being affected by the update or not.

The query plan comprises appropriately interconnected query execution operators which function by processing the rows they receive from their inputs and passing the output of such processing to the operator that follows. The combination of the first two phases is called compilation and its output the query plan is saved to memory to be reused in case the same query is issued again in the future. Techniques like substituting constants with logical parameters in the query statement allow more frequent reuse of the same plan.

The query execution component executes the query plan generated by the query optimizer interacting with the storage engine which is the component that ultimately stores and retrieves the data. The query execution component receives subtrees for index maintenance from the optimizer and executes the physical tree built by the query optimizer. Execution is performed by a storage engine to modify the data that is stored in the indexes so that individual fields are updated.

Query execution plans for implementing Update statements in SQL Server are split in two phases. The first part is read only and responsible for determining which rows are to be updated. The second part consumes the rows provided by the first and performs the actual data modification.

It is contemplated that the invention can be used with any type of dependency and can be extended among the others to constraints over columns. Constraints may be user defined during table generation e.g. zip code is 5 digits .

When processing a regular Update statement the SQL Server query processor enumerates all the access paths dependent on the target table extracts the list of columns used inside these dependent access paths and verifies whether any of them is present in the assignment list. If this is the case the content of the access path is considered to be changing and the query execution plan is modified accordingly. For example given a table T with columns C1 C2 C3 and an index over C1 C2 an update of the form Update T Set C1 2 will result in a query execution plan that propagates the changes to the index. The plan for the statement Update T Set C3 10 will instead leave the index untouched resulting in better performance at runtime.

This functionality is improved when the table contains one or more UDT type columns with index expressions using subfields of these columns for example. A granular update is represented in the SQL Server relational algebra as a tree of special purpose scalar operators referred to herein as UdtMultiUpdate and UdtPropertySetter . These operators are desirably behind the scenes and are not known to the user the user is aware of Update but not these operators . The UdtPropertySetter scalar operator is used to set the value of a certain subfield of a UDT column or subfield. The UdtMultiUpdate scalar operator is used to group together updates to subfields of a UDT column or subfield. It can be stacked in a recursive fashion to describe updates to subfields at different levels in the UDT column.

Accessing UDT subfields in index expressions is represented by a scalar algebra tree using the scalar operator UdtFunction for example. This operator can also be stacked on top of itself to drill down into a UDT structure. The lowest node in such a tree is desirably an identifier node representing the UDT column and each UdtFunction node on top of that identifier node drills down one level in the UDT structure.

The examples below illustrate the use of both the UdtMultiUpdate UdtPropertySetter and the UdtFunction operators. As noted above when processing such a granular update statement the SQL Server query processor will walk the tree representation of the update trying to match subfields used in the index expressions with those being updated. If it finds a match the corresponding index expression is considered to be changed and a query execution plan will be generated that propagates the update to the index.

An example is directed to a multi level UDT structure and a table T has a column Person of UDT type Person . The Person type is defined as having the following structure 

As can be seen from the trees in the example the update tree drills down into a UDT hierarchy while the index expression trees represent subfields of the UDT with scalar nodes towards the bottom of the tree representing subfields higher in the hierarchy. This is why the exemplary tree matching technique walks the update tree in a top down fashion but matches subfields in the index expressions from bottom to top. An exemplary technique starts from the top of the update tree identifying that the UDT column being partially updated is person . For all the index expression trees it then looks at the bottom node and tries to match this with Person. In this case both index expressions match. Although the matching sequence of both index expression trees are described together it is noted that each index expression is considered separately to reduce the complexity of the method.

Because up to this point both index expressions might be changed by the Update the higher tree nodes in the index expression and lower tree nodes in the update tree are now processed. Thus both the Address and SSN fields are matched against the child nodes of the top level UdtMultiUpdate. In this example only Address matches and it can therefore be deduced that the first index person.ssn is not affected by this Update. The process continues for the second index and Zip is then matched against the children of the UdtMultiUpdate address node. One of these children is UdtPropertySetter zip meaning the second index should be maintained.

Another example is directed to inheritance in a UDT. This example uses the table T set forth above with an Address UDT and subtype of Address USAddress as shown 

Just like in any object oriented programming language the SQL Server UDT architecture allows for subtypes of a UDT type to be stored updated and queried over instead of that UDT base type. This means that some of the Person instances may contain a USAddress instead of the base Address. The Treat keyword is used to treat certain types as one of their subtypes.

An exemplary update scalar tree is shown in . The matching technique described above is used in processing this example as well. Note that every field in a UDT desirably has an ordinal that is unique for the whole inheritance hierarchy of that UDT. In the example above if street and city in Address have ordinal 1 and 2 respectively then zip will have ordinal 3 thus avoiding conflicts between derived classes. Subfields in the update expression are matched up with subfields in the index expressions using their ordinal numbers. This technique also allows the use of Treat in the index expressions.

The various systems methods and techniques described herein may be implemented with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the present invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers the computer will generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

The methods and apparatus of the present invention may also be embodied in the form of program code that is transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics or via any other form of transmission wherein when the program code is received and loaded into and executed by a machine such as an EPROM a gate array a programmable logic device PLD a client computer a video recorder or the like the machine becomes an apparatus for practicing the invention. When implemented on a general purpose processor the program code combines with the processor to provide a unique apparatus that operates to perform the functionality of the present invention.

While the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiments for performing the same functions of the present invention without deviating therefrom. Therefore the present invention should not be limited to any single embodiment but rather construed in breadth and scope in accordance with the appended claims.

