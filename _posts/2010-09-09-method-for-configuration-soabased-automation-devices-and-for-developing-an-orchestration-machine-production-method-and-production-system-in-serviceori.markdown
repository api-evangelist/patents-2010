---

title: Method for configuration SOA-based automation devices and for developing an orchestration machine, production method and production system in service-oriented architecture having embedded service orchestration engine
abstract: A method for configuring an automation device or simulator for controlling mechatronics components of an automation system, including: generating HLPN component models for each type of the mechatronic components of the automation system, creating a component instance model from an HLPN component model for each physically present mechatronic component, creating a layout configuration file, which describes relationships of the component instance models to be connected, composing the component instance models into a system model based on the layout configuration file, wherein logic ports of the component instance models are connected/linked to each other, generating configuration files based on a system model and device description files and WSDL files of the component instance models, loading the configuration files into the automation device or simulator containing the HLPN orchestration machine, and executing the configuration files by the HLPN orchestration machine of the automation device or the simulator.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09134726&OS=09134726&RS=09134726
owner: SCHNEIDER ELECTRIC AUTOMATION GMBH
number: 09134726
owner_city: Seligenstadt
owner_country: DE
publication_date: 20100909
---
This application is a 371 of PCT EP2010 063264 filed on Sep. 9 2010 which claims priority to German patent application number 10 2009 043 968.4 filed Sep. 9 2009 which is incorporated herein by reference.

The invention relates to a method for configuration of SOA based automation devices and for developing an orchestration machine and a production method and production system in service oriented architecture having an embedded service orchestration engine.

WO A 2009 053472 describes a method for orchestration of services of a service oriented automation system as well as an orchestration machine. System components offer their functionalities as services and are capable of querying services of other system components such that the behavior of the automation system is controlled through orchestration of the services of the system components by means of an orchestration machine. To achieve orchestration of services at the device level it is provided that the orchestration machine will use high level Petri Nets tailored to service oriented systems and that the orchestration of the services on the gate level is accomplished by interpretation and execution of various HLPN models representing the behavior of the automation system and or the system components.

WO A 2009 101212 relates to a method and a system for embedding service oriented automation components of a production shop in a flexible IT enterprise architecture. To configure flexible production shops in the form of an orchestration method and to specify elements it is provided that the service oriented automation components are coupled to the higher level via orchestration middleware and the services offered by the service oriented automation components are integrated into the higher level by using a vectorial function and a layout based on orchestration of service oriented automation components.

In addition a service oriented automation device and method for specifying a service oriented automation device are described in WO A 2009 103811. The following process steps are proposed for describing the operating performance of autonomous and collaborative automation devices and production shops with a service oriented architecture 

Original setup of the automation device including configuration explanation of services establishment of links to other automation devices and transfer of the setup to awaiting original status receipt of the results about service operations internal device interfaces generated by inputs outputs and or directly by the control unit analyzing the results received implementing the results and the change in status of the model based middleware shell wherein the system reaches the next state and is capable of receiving additional results.

Modern industrial production systems are characterized by distributed systems operators products and information. These systems must be suitable for mass production and specific adjustments on a larger scale. A large number of factors are required for effective operation of such flexible production lines including the number of product options the production sequence for the respective product the type of product the capacity of the workstations the processing time of the production processes at each workstation the material processing capacity at each workstation and the total material processing capacity. The data thereby obtained and data to be processed later may therefore be subject to constant changes regardless of the large volume of data.

Components of distributed software are already being used in the form of distributed objects function blocks and services the latter in the form of a service oriented architecture SOA and a service oriented computing SoC which is currently growing in popularity in industrial automation systems. The dominant view of the future will be based on the idea of service oriented computing which offers a way to create a new architecture and reflects the trend in components toward autonomy and heterogeneity. Its growing usability in the business world and in e commerce is seen as a step toward achieving a seamless integration of resources from different levels. Numerous efforts are currently being undertaken to research these fields more thoroughly e.g. the SOCRADES project http www.socrades.eu .

In general SoA considers the system only from the standpoint of its services whereas a lower importance is assigned to its providers and users. These entities may be automation devices software components and the like and have the special ability to encapsulate resources within services. They represent a new approach and are fundamentally different from memory programmable controllers PLC programmable logic controllers in the field of automation.

These entities have occasionally been referred to as intelligent devices and although they have also been named differently under some circumstances they are similar in the property of being service oriented autonomous control units devices actuators and sensors. Service computing and service orientation are therefore regarded not only as a form of communication but rather as a philosophy that should be assumed by the software entities by sharing their resources and expressing their requirements. This is the new design approach and style of thinking of automation technicians enterprise managers and software developers who are tasked with the job of creating important tools and methodologies. Service oriented automation software entities which are used in approaches of this type require a number of methodologies and software devoted to the specification of computer systems as well as embedded automation devices. These applications also contribute toward a shortening of development times and a reduction in the interdependence of the components so that adequate flexibility for automatic reconfiguration of production arrangements is achieved.

With regard to the technology the Device Profile for Web Services DPWS has been stipulated as the standard in this project. Since it describes only a few specific protocols a compatible framework must be used to ensure communication of the software components in a service oriented manner in the same language. One of the systems implemented is the SOA4D system Service Oriented Architecture for Devices https forge.soa4d.org which is targeted at larger computer systems e.g. PCs and embedded devices.

Against this background the problem on which the present invention is based is to further develop a method for configuration of SOA based automation devices and for developing an orchestration machine such that there will be the possibility of modeling each component of a system individually and equipping them with logic interfaces and wherein an automated composition of the models of the components to form a static overall model of the system is made possible.

In addition the object of the invention is to make available a manufacturing method and a manufacturing system based on an implemented orchestration machine that supplies conflict resolution mechanisms.

This object is achieved according to the present invention by a method for configuration of an automation device having an orchestration machine by means of the features of claim among others.

The orchestration engine OE is preferably linked to a Decision Support System DSS via the network N this Decision Support System being implemented in the Production Execution System such that decision support can be queried when conflicts occur at the conflict nodes on execution of the orchestration model and or behavior model implemented in the orchestration engine OE .

The model based service orchestration machine utilizes a Petri Net dialect as the modeling language and logic language high level Petri Net HL PN . The HL PN has been expanded by elements to map web service specific properties directly onto the HL PN model service and data contracts as well as configuration of the DPWS discovery. However the models can also be expanded by additional properties. In addition to DPWS compatible web services other message oriented and event oriented communication layers can also be configured.

Petri Nets are suitable for mapping of competing and concurrent processes with distributed resources which operate on a limited set of software and hardware resources. The fundamental approach is to model each component of a system individually and to furnish it with logic interfaces which allow automated composition of the model components to form a static overall model of the system. The model instances are interconnected according to the real topology of the system. Due to the fact that the component models supply all the interfaces the overall model contains all the sequence paths that are possible in principle. On the example of a material flow system this means that a system consisting of shipping components will contain all flow paths which enable physical conveyance of material by connecting the transport elements. In the trivial case the system may contain linear paths and thus the process may take place more or less sequentially but in more complex compositions the process might contain a few paths with multiple bifurcations and connections so that alternative sequence paths can be selected in run time. The bifurcations and connections in such complex processes are modeled as conflict nodes in the Petri Net. Conflicts in a Petri Net model may have different meanings in a real system. For example a pallet on a transport element could be transported in different directions or two subprocesses may compete for the same resource.

A few problems could be solved by simple algorithms e.g. random selection of a process path but such approaches are inefficient when seen from a global standpoint or may even be harmful for certain topologies because deadlocks occur there and the process is blocked. It is thus clear that subprocesses should not only be synchronized locally to a limited extent but should also be synchronized in an expanded context. These problems are not new and have already been solved at least in part through Enterprise Resource Planning ERP Manufacturing Execution System MES .

For the orchestration machine and an orchestrated system of services an architecture was selected that would permit a separation of the decision algorithms and the service orchestration. There is a special interface between the orchestration machine and the so called Decision Support System DSS for exchanging decision questions answers and method data for decision making. At the orchestration level so called local decisions are made which are based on simple algorithms and then intervene to resolve conflicts quickly if the higher level Decision Support System DSS has not yet made a decision. At a lower level decisions are thus made based purely on knowledge of the models and the current status of the models.

From the standpoint of orchestration bottom up the DSS encapsulates the upper systems as a service for decision making without knowing which algorithms the decision is based on.

From the standpoint of Enterprise Resource Planning ERP top down the DSS encapsulates the production system i.e. manufacturing system as a Manufacturing Execution System MES service with interfaces for receiving production orders and for monitoring production. The ERP system does not have a detailed knowledge of the automation processes but instead only has information about production orders and their status.

The central part of the transfer system units C C consists of nine transfer units C C conveyors unidirectional and or cross conveying as shown in and . The unidirectional transfer unit C has an input port and an output port PORT PORT the cross conveyor unit C C permits transfer not only in the longitudinal direction but also in the direction perpendicular to that and includes the input and output ports PORT PORT. These units have an optical sensor S and an output for a conveyor motor M. Furthermore a cross conveyor unit C C may be regarded as a combination of two devices namely first a unidirectional transfer unit C C C and a lifter L L with the possibility of executing directional transfers.

The cross conveyor units C C have two optical sensors S S to detect the presence of a pallet P and two other sensors S S to detect whether a cross connection CC is in the upper or lower position. The four outputs are used for control of motors M one for the normal conveyor motor M another motor M to lift the central directional cross connection module and two motors M M one for the directional transfer clockwise and another for the directional transfer counterclockwise.

The lower transfer units C C have the same behavior as the normal unidirectional transfer units e.g. unit C but are longer.

Lifters are identified by units L and L as shown in and . In addition to their function as an interface between the upper and lower parts of the system they are also responsible for the transfer of pallets P into and out of a manufacturing cell. One transfer unit TE in the lifter L L has two optical sensors S S for detecting the presence of a pallet P. Photoelectric beams are provided at both ends of the units. The transfer unit TE may additionally be moved in two directions by analogy with the central unit CC of the cross conveyor unit C C so there is an output PORT PORT for each direction. One lifter motor HM is controlled by a Telemecanique registered trademark Altivar 71 in combination with a Controllerinside card frequency convertor for lift control which counts the instantaneous position of the conveyor and calculates it. The ControllerInside card was selected instead of the Advantys registered trademark EHC3020 fast counter module because at the time of selection the required precision for the lift position 

The characteristics of the individual components of the transfer units in the system are summarized in the following table.

The pallets P are deployed manually into the system with the help of the units C and C and are conveyed on alternative paths to the workstations W and W. In this very small cell a pallet P circulates in the system until it is directed to one of the workstations. The path is determined at the cross units as a function of the production processes required for the product placed on a certain pallet and this depends on the site and on the availability of the production services in the system at W and W here . A workstation may offer more than one production mode and one production mode may be possible from more than one workstation.

As soon as a pallet P is directed to a given workstation W W to receive a certain production process the line control system a service orchestration in the present case stops the pallet P at the transfer unit C C until the production process has been triggered by the operator. The signal of the operator is transmitted by a simple HMI human machine interface application.

To identify the pallet P the cross units C C and the workstation units C C are each equipped with an identification unit i.e. such as an RFID device radio frequency identification which has the ability to read data from write data to labels on the pallets P. The identification unit IE is used by the line orchestration to question an external Production Execution System PES about the next production step provided. Alternatively this query may not be made at each cross connection but instead the production sequence can be stored on the production label and read off from it.

Numerous automation devices STB are used for controlling the mechanical parts of the production system and form the interface with a Production Execution System PES of a higher level by offering and utilizing services.

The integration of the control devices STB into mechatronic components modules of the electromechanical modular system yields a collaborative automation unit as diagrammed schematically in .

Each workstation W W is equipped with a user panel having two buttons and one switch. The user panel is not used in the production system shown here its actual use was to activate and deactivate the workstation W W plus the possibility of the user sending two commands e.g. OK and ERROR. This functionality is enabled by a PC based HMI which displays the product data and gives the user an opportunity to enter the results of the procedure. Without these buttons the workplace has the same properties as a simple unidirectional transfer unit.

The approach for creating complex flexible and reconfigurable production systems is that these systems are composed of reusable modular components which offer their production properties as a number of different services. This approach to assembly is valid for most levels in production. Simple devices are assembled to form complex devices or machines which are themselves reconstructed to create cells or lines of a production system. The same thing is also true of designing service oriented production systems and assembling complex services from simpler services.

The model based orchestration engine OE together with the orchestration tools CDS is part of a system architecture which is referred to in as a general orchestration engine box. This figure also gives an overview of the relationships with other integrated components e.g. the Decision Support System DSS and the design and simulation of service oriented systems with 2D 3D engineering environments CDS.

Based on hardware and overall project requirements it has been decided that the fundamental building blocks which constitute the distributed system should be configurable software components for different tasks. Software components have therefore been drafted as bots that have a so called orchestration engine internally and are capable of coordinating their activities in a service oriented manner and also taking over collaboration processes with other components in the system.

In the example according to the autonomy range of the bot is a transfer unit conveyor . The communication with other software components in the system e.g. other bots is implemented via the offer of services and utilization of the required services of other components. For the design configuration and maintenance of the bots various tools are required and must be user friendly and must accelerate development by using a program approach at a higher level visual languages .

Since services are not isolated entities using directly linked software components a logic unit which creates the interaction is to be provided. The selected modeling language is obtained from Petri Net specifications with expansions at a higher level such as time considerations a property system and an adaptable token engine. This is referred to below as a Petri Net of a higher level high level Petri Net HLPN . The expandable property mechanism of the HLPN is used as an interface for configuration of the properties associated with the web service.

Additional requirements include the use of the Decision Support System DSS which is capable of making correct data available to the Petri Net model at each decision point. This DSS is the most important interface between the model based approach for the transport system and the production planning system.

Additional details about the scientific approaches used are disclosed in the following publications all of which refer to the SOCRADES project . The full content of these publications is herewith referenced 

Since SOA based automation systems do not have the respective user software and methodologies efforts have been undertaken in the field of software development and several software packages have been created for the production system being used. In each case system engineering and the associated tools should facilitate the work of the developer. With regard to the Petri Net there is only limited practical benefit due to the lack of computer tools which would enable simple utilization of large and complex networks.

This project has been referred to as Continuum Development Tools in accordance with the continuum concept known from physics and philosophy. The first developments were achieved by integration of software components that had already been developed in particular the PndK Petri Nets Development ToolKit under the same name. With this integration the demand for numerous software packages became obvious including a framework for development of bots engineering tools for creating and managing bots and numerous additional aids mainly libraries to support tasks such as communication and interfaces for devices.

The support package includes several reusable software libraries and tools. Some of these were developed internally and others were added from external sources e.g. the SAO 4D DPWS library available at https forge.soa4d.org for the development of web services and the QT Toolkit see http qtsoftware.com which is used mainly as a graphic toolkit for human interaction in CDS.

The main development languages are C and C . The development environment was generated and managed with the help of multiple tools the versioning system used was Subversion http subversion.tigris.org . CMake http www.cmake.org was selected as the building system allows development and generation beyond a given platform . In addition the documentation is generated with the aid of Doxygen http www.doxygen.org . No special software project management tool is used because the group consists of only a few people and development can normally be conducted at one location.

To meet the necessary requirements bots intended for implementation of multiple functions must have a consistent anatomy for the functionality of the various function modules organs . Modules running asynchronously possible data inconsistencies and processes and threads running in parallel may cause problems. In general module integration into a completely functioning bot may be considered. By analogy with what takes place in almost all creatures having a nervous system the pulses or signals generated by the modules must be directed correctly to the destination and interpreted. This may be considered a loose form of integration in event based integration in particular in which modules interact with one another by reporting on events and reacting to events.

The Continuum Bot Framework is the basis for the development of bots. shows a class diagram focusing on the CBF and implementations of the modules and bots. A module may be defined by inheritance of the CBF Abstract Module Class and specific functionalities may thereby be added to it. For example the Petri Net Kernel Module uses the functions and structures of the Continuum Petri Nets Kernel Library. For the DPWS module the external SOA4D DPWS library was used to generate a communication module. This can be used by bots for communicating with other bots by offering their own services or by using the services of the others. An independent Bot integrated as a stand alone application or as a library can be achieved by modification of the CBF AbstractBot by adding a special code and combining the modules required. shows an example of a mechatronic bot which depends on several modules.

Signals are used for the intraspecific communication of a bot i.e. there is an event based interaction between the modules. A signal is generated by the CBF signal class and several parameters and user data can be defined with the instances of the signal. Signals are sent by a module and relayed over an intermediate CBF module manager which is connected to each module. Reception and analysis of the signals are performed by each module asynchronously. When a signal is received it is stored in the local queue of the module. Internally a module represents a thread loop which analyzes the local queue of received signals. When a signal is taken from the queue this triggers the execution of a program code corresponding to this event. The signal mechanism used may be compared with the signal slot principle of the QT Toolkit with regard to function.

However it may also be appropriate to use Petri Nets for typical systems with a defined behavior or also for more complex systems with distributed participants. In any case system engineering and the respective tools should facilitate the work of the developer. With regard to the Petri Net it has only limited practical benefit due to the lack of computer tools which would enable simple utilization of large and complex networks. Continuum Development Studio CDS therefore intends to offer a user friendly environment for multiple engineering tasks of service oriented automation systems from specification and configuration of the automation bot analysis and simulation to starting operation of the system. shows a screenshot of CDS simulating a Petri Net test model.

This development has been based on a port and the natural further development of the previous PndK which was provided additionally with a Multi Document View type framework like the structural template of the Model View Controller plus additional tools. The framework was created on the inadequate basis of the QT Toolkit that was used which actually supports Model View programming in class form but does not have a framework for its administration and integration into an application . Essentially the framework has a document manager class for monitoring documents and their views a Project Explorer for adding documents in a logical manner and the abstract classes with which developers can furnish personalized documents and views. The document manager allows the creation of document instances and view instances in the manner of the factory method and also offers personalization of their tools e.g. toolbars and other widgets. File management through operations such as New Open Save etc. is also handled in an integrated manner for all types of documents. At the present time only Petri Net types and text document types and corresponding views are implemented.

Petri Net Document View allows design analysis and independent simulation of Petri Nets. In addition a personalized property system has been developed which provides for the addition of Petri Nets and their elements with information which can be used so that a Petri Net model can be associated with the behavior of an automation bot for example. It is also possible to import a WSDL data file that has already been configured and assign it to the transitions of the modeled Petri Net so that the transitions actively participate in the message sequences when the model is used in a bot. There is a built in orchestration engine which can coordinate and synchronize the services in accordance with the Petri Net defined workflow using the SOA4D DPWS library . Configuration of the bots with the Petri Net Kernel Module is performed mainly by describing the expected behavior based on a Petri Net model including the utilization of external services providing one s own services and by device access.

The previous sections have explained how a Petri Net designer can specify models for mechatronic components or even larger systems.

According to a first idea of the invention the invention is based on a method and a software product for configuring HLPNs in SOA based automation devices.

The next section will describe and explain a tool chain for compiling systems SYS the creation of configuration files DF descriptor files and the use of these files on devices STB or on simulators SIM. shows the complete sequence of component design or system design as well as the compilation and use of the devices STB.

As already explained above a system SYS may comprise a plurality of mechatronic components C C L L W W which are embodied as a unit of mechanics electronics controllers and an interface such as for example communication by means of web services. Examples of mechatronic components include the lifters L L and the transfer units C C each with the respective automation device STB.

Taking into account WSDL files and device templates DT so called Component Instance Models CIM which have an instance name and reference name are formed from the component models. The Component Instance Model CIM describes a certain mechatronic component such as lifters L L in the system SYS for example the lifter L of a local system.

A component model is understood to be an HLPN model of a mechatronic component without instance names or reference names. A component model CM describes all the components of one type for example lifters L L.

The Composition Tool CT is used for semiautomatic composition of a system model SM from a set of Component Instance Models CIM. The composition runs according to a Layout Configuration File LCF XML based XRC files which describes the relationships of the Component Instance Models CIM to be connected. The file is generated with the help of a text editor or by means of external tools e.g. Delmia. In addition the user must generate a single model CIM for each physical component C C L L copy and insert even if the same models CIM are used. Each Component Instance Model CIM must then be configured with a correct and binding reference name. This must be performed by the designer or by replacing character strings in the text editor.

Device Descriptor Files DDF are needed for creating the configuration files CF these Device Descriptor Files establish a 1 1 link between the binding reference name in the models CIM and the real DPWS devices services. The user can start a network scan procedure for detecting all DPWS devices which write Device Descriptor Files including the device type operational use address descriptor name etc. The user next generates the connection to the binding name by renaming the respective Device Descriptor File.

A DPWS device is understood to be a logic device visible as a service endpoint in the network which offers certain services for discovery and metadata access. A DPWS device is a container for the actual functional services DPWS services .

DPWS is a standard which defines a separate resource model with DPWS devices and services. The DPWS standard requires that a DPWS device must be available as the service endpoint in the network and must offer WS Discovery and WS Metadata Exchange as services. DPWS services may thus be queried and addressed by the device. For example the lifter L is a DPWS device of the lifter type which offers the DPWS services such as lifting and transfer. 

A DPWS service is a DPWS compatible dedicated service of the lifting or transfer type for example. Furthermore WS metadata exchange and optionally also WS eventing are required and supported by the DPWS standard.

Metadata of a service that is used refers to additional information of a service endpoints which can be downloaded by the device via DPWS services.

A system model SM that should be used is represented as a DPWS device. Therefore a Device Descriptor File is also needed for this purpose. The creation of a new descriptor file is generated by the template generator batch file which therefore needs a binding name as input. The binding name must correspond to the project name of the model name of the XPN file .

An HTTP web server is used to allow access all files via the URL so that each tool of each computer that can read the metadata of the services used can also interpret the WSDL memory site properties and can thus download the WSDL without user intervention. Materna Explorer can automatically download and generate clients for example. Another advantage is that these files can be administered centrally in this way.

The current implementation of the general communication module which is configured by rewritten WSDL files causes certain restrictions on the WSDL files. Only DPWS compatible definitions can be used which means that only operations with a SOAP HTTP connection and document style and literal encoding may be used. Messages may either be blank or may include only a message part. The message part must be based on an XML element and must not be based on a type. The types are to be specified in the same WSDL file. Xsd sequence may be used but all specifications for events must be of a fixed size unbounded must not be used. Xsd choice Xsd union xsd any must not be used. All basic types are handled as strings and no type testing is performed. Restrictions and facets such as enumerations Xsd enumeration may be used but here again there is no type testing. SOAP coding and array types are not supported.

The following steps are to be performed individually and you must be sure that all preparations have been made 

The goal of the method described here is to show the gain in flexibility by using a service oriented architecture by executing a production order of an ERP Enterprise Resource Planning system ERP directly in the production shop PS as shown in . In addition there are only minimal prerequisites of the specific composition of the production line throughout the entire system. However to be able to offer a coherent application a specific setup is selected. The detailed production steps are saved in a Production Execution System PES.

This Production Execution System PES is integrated between the Petri Net based Decision Support module DSS which is connected to the intelligent devices STB and the ERP system ERP Enterprise Resource Planning as shown in . It registers the New Order Entry in the ERP by means of the Local Discover Unit LDU. When a New Order Entry is received additional details are queried by the ERP system. To this end a Get Order Details message is used identifying the Production Execution System PES itself with a machine ID representing the production unit.

The Production Execution System PES sends the status message READY with the number of producible units back to the system ERP. This response is based on internally stored data with regard to the production time required for an individual product. Production starts after receipt of the Start message. The production execution command is sent to the system ERP after each change in order status until the request has been completely executed.

A production step is terminated after a Service Completed message has been sent from the Production Execution System. This leads to the next step of the service. When the last step of the production list has been executed the product is completed. Completion of a single product increases the number of products produced by one and triggers a status update which is sent to the ERP system.

A more extensive sequence for production of a single product is shown in which follows. This example relates to a product for which the process description is as follows 

The workflow begins within the Petri Net Engine STB PNE which requests the decision to continue with production. To identify the pallet Pzu that is to be processed the engine OE accesses the RFID number of the connected RFID reader OSI and thereby uses the respective service. This connection is modeled according to a specific physical topology in the Petri Net.

This pallet ID is used to obtain the next service from the Production Execution System PES. Due to the service sent back the Petri Net Engine STB PNE can continue. Next the pallet P is moved to the intended site e.g. to the workstation W. On reaching the destination of the pallet the production unit W which has been guided there receives the Execute Service command for the given pallet ID. Next the production unit W performs the service.

For this application a PC based HMI is used as the production unit. This is a program which displays a text message with the production step queried for the user. The text displayed is supplied by the production execution. In a real system the Production Execution System may supply additional information for performing production steps e.g. a program for operating a manipulator or the like.

The production unit used is confirmed by the operator after the production step has been terminated by pushing a button. This button may either be part of the HMI or may then be a physical button. In the Production Execution System is notified that the service ws for the pallet ID 10721 is concluded. With this message the result of the production step can also be supplied for example if the service has been performed successfully the result OK is used. The next time a service is requested for this pallet ID another service is sent back. Thus the pallet is conveyed to the next service. The times for completion of each individual production step and for producing the overall product are measured and stored in a database.

To demonstrate the workflow over a longer period of time the production unit may be configured so that it runs automatically. In this case the service is concluded after a certain period of time. It is thus also possible for the system to produce units and execute orders automatically without human intervention.

To simulate additional scenarios production steps may be provided with other results than OK e.g. FAILURE PROCESSING DEFECT NOTONSTOCK.

The Production Execution System stores the data in a corresponding database . The data may be divided into two parts. The first part is the definition of the production process used in the application. It can define the production steps required for a given URI for example. The second part serves to receive and execute the individual orders. Time relevant data is also stored in this part.

The Process Description tables with the Production Step Production Step List and Provider Provider List constitute the first part. The production order and product tables are used for the second part.

Various operating modes can be used in the ERP system with the order details. The following table shows the processes that can be used initially with the production steps executed.

The tools used and the engineering methodology were added to the production system with the goal of transporting pallets to the workstations and creating flexibility in the design and maintenance of the system.

As soon as the software is completely concluded and ready for operation the question arises as to how it is used for specification of the automation system. The numerous engineering steps required from system design to operation and reconfiguration are described in the following section see .

The design phase currently allows the use of virtual display in a 3D simulation tool mainly to export the connection data in XML format for the Continuum Development System CDS. The CDS is used for the design and analysis of the Petri Net model for describing the behavior of the bot FIG. . . If the device connection information is imported by the 3D simulation tool then several steps are performed by the CDS 1 creating instance models CIM of the Petri Net model SM for each bot based on the models generated 2 creating the required properties of the Petri Net model SM so that multiple parameters of the given information are written by a 3D simulation tool into the model e.g. bot device data connections . . . and 3 based on the expansion of the Petri Net model the model composition may be used to create a connection logic and for the overall system analysis FIG. . .

After analysis and simulation can be performed with the CDS and also with the 3D simulation tool which supply the services of virtual devices the bots must then be configured. The process of deployment a service which encapsulates its logic as a Petri Net model to form a bot having an embedded Petri Net Kernel Template model is shown in FIG. .. The deployment functionality is a standard feature of the DPWS and is offered as a dynamic deployment service. The goal and the deployment service can be found through a Stacks Built In Discovery Service. After the deployment a new service endpoint is added and the execution of the service logic is initiated. The deployment data comprises data on the Petri Net behavior model connections to neighbors required services services offered by the bot and also additional configuration data for the additional modules of the bot. The bot will self configure and will configure its modules and is then ready for operation.

Operation here means autonomous behavior of the bots according to their defined model plus internal handling of exceptions and the offer and utilization of services by different bots and other software components belonging to the system FIG. . . Features for higher levels in the service approach also include combining multiple services into one simplification of the external view lateral collaboration between bots offering services decentralization in comparison with a hierarchical control approach. Business integration and in general integration of higher levels of the production cell is achieved through service orientation. Business requirements are expressed through the production planning and the management of the production cells by monitoring their work status by means of specific series deactivation activation of various routing paths of the production etc.

During operation a new configuration may be necessary if a control model for a bot is no longer valid or if production strategies have been changed. In these cases the bots affected must be stopped without bringing the system to a standstill and then the services would no longer be available. During this period of time new models can be created to achieve a new desired behavior. These models are then transferred to the bots and operation can ultimately be resumed.

This section describes the automation bots with an embedded orchestration engine which are used in control devices STB for coordination of the production activities of the scenario. Depending on the distribution of the automation devices during use each device should have an embedded automation bot that is responsible for its activity. As an example and in view of one bot may be responsible for all lifter units while another bot may be responsible for the central part of the conveyor system. A modular system but necessarily with more devices and therefore more bots would be the definition of one bot for each of the 12 units and the two workstations.

The properties of the automation bot specified for the method described here can be summarized in the following bullet points 

The goals of application for all physical systems explained in the preceding section and for the software tools and components are as follows 

According to another idea of the invention the invention is based on an HL PN based approach and tools for development and application of orchestration engines embedded in automation systems.

Physical devices such as conveyors C C and lifters L L are presented to the network N as logic devices LD. These logic devices LD and their services S run on the STB controllers even running on a few of them when defined at the PC gateway e.g. RFIDs . The specification of the services S of the logic devices LD and their control logic CL is achieved by multiple procedures 

To start these services a BootP DHCP server must be used to assign IP addresses to the devices. In this case a BootP server was used with a configuration file comprising all STBs.

To describe the services and make them usable for clients more than one WSDL v1.1 Web Services Descriptor Language is used. The endpoints EP of the logic devices LD are associated with the corresponding service data listed below 

The message sequence of the transfer units conveyors C C is expressed in for the two operations TransferIn and TransferOut.

The message sequence of the lifters L L is supplied in for the three operations IFtransferIn IFtransferOut and IFlifting.

Behavior models are generated as a function of the available elementary services S and their operational procedures as well as the assumed behavior of the devices. Editing processes of the control models were performed with the help of Continuum Development Studio.

Conflicts are nodes in the Petri Net modeled system where alternative paths are to be selected. This means that more than one transition may actually be switched. This corresponds to a situation in which decisions must be made.

In general to retrieve the Decision Support System DSS at a point in the net the pallet ID must first be queried via the OSITrack service procedure GetID. The parameter of the query id p loaded .conflict id of the loaded part must be replaced with the ID of the location of the conflict characterized in the example as loaded . Then the first places of each branch connection resulting from the conflict has a services property with values of the services leading to this branch separated by commas. This example shows the service ws which stops the pallet and waits until a TransferOut is given by the workstation W after conclusion of the operational procedure involving the pallet and a standard service for all other pallets which do not have any relationship to workstation . The responsible orchestration engine will stop at the loaded conflict in run time will forward the pallet data to the Decision Support System DSS and will wait on a response indicating which transition associated with a certain service is to be performed .

The following table shows the details for modeling each Petri Net model and the corresponding device.

Analysis and validation of models are performed by means of the analysis function of the Continuum Development Studio. The analysis is based on a check and confirmation of static and dynamic model properties. The validation is based on an isomorphism between the model properties and specifications of the modeled service oriented automation and production components and processes. If the model has a transition invariance for example and a liveliness property then the transition invariance corresponds to the existence of a basic path basic service composition orchestration .

A separate inventive method for connecting behaviors orchestration models and generating orchestration services is described below.

The connection strategy illustrated in is used in this system. The composition tool is used to generate the model orchestration write based on the models CM of the components C C orchestration middle based on the models CM of the components C C L L C C and orchestration left based on the models CM of the components C C . The generated models communicate with one another to perform transfer operational procedures of the pallets by means of service retrieval TransferIn TransferOut mechanism .

For the sake of simplicity and also to demonstrate the composition function in a standard and reusable manner the generated orchestration service implements the same transfer interface as the conveyors with a few particular features see orch device and . Therefore the orchestration services can be created just as progressively as the transfer units before them.

As soon as models are generated and validated they can be used for configuration of the orchestration engine devices STB PNE. This takes place by means of the Continuum Development System CDS and additional support to apply the data to the devices.

For the setup only the application which responds in real time to the queries of the orchestration engine is executed.

The execution of the model is started on the basis of a service transfer service offered by the orchestration engine. Normally the execution starts immediately after deployment.

The following table shows the functions that can be executed with the given approach and the proposed tools.

According to a third inventive idea the invention is based on a model based Service Orchestration Engine associated with a Decision Support System.

The model based Service Orchestration Engine utilizes a Petri Net dialect as the modeling and logic language High Level Petri Net HL PN . The HL PN was expanded by adding elements for MAPPING web service specific properties directly ONTO the HL PN model service and data contracts as well as configuration of the DPWS discovery. However these models may also be expanded by adding additional properties. In addition to DPWS compatible web services other message and or event oriented communication layers may also be configured.

Petri Nets are suitable for mapping competing and concurrent processes with distributed resources which operate on a limited amount of hardware and software resources. The fundamental approach is to model each component of a system individually and furnish it with logic interfaces that allow automated composition of the model components to form an overall static model of the system. The model instances are then interconnected in accordance with the actual topology of the system. Due to the fact that the component models supply all the interfaces the overall model contains all possible sequence paths in principle. On the example of a material flow system this means that a system consisting of transport components will contain all flow paths that also permit physical transport of material by connecting the transport elements. In the trivial case the system may contain linear paths and the process may thus take place more or less sequentially but in more complex compositions the process might contain a few paths having multiple bifurcations and connections so that alternative sequence paths may be selected in run time. The bifurcations and connections in such complex processes are modeled as conflict nodes in the Petri Net. Conflicts in a Petri Net model may have different meanings in a real system. For example a pallet could be transported on a transport element in various directions or two subprocesses might compete for the same resource.

Some problems can be solved by simple algorithms e.g. random selection of a process path but such approaches are not efficient from a global standpoint or they may even be harmful for certain topologies because deadlocks occur there and the process is blocked. It is thus clear that subprocesses may be synchronized to a limited extent not only locally but also in an expanded context. These problems are not new and are at least partially solved by Enterprise Resource Planning ERP Production Execution System MES sic PES .

For the orchestration engine and an orchestrated system of services an architecture that enables a separation of the decision algorithms and the service orchestration was selected. There is a special interface between the orchestration engine and the so called Decision Support System to exchange decision questions answers and metadata for decision making. At the orchestration level so called local decisions are made based on simple algorithms and they intervene for example to resolve conflicts quickly when the higher level Decision Support System DSS has not made a decision. Thus at a lower level decisions which are based purely on knowledge of the models and the current status of the models are made.

From the standpoint of orchestration bottom up the DSS encapsulates the upper systems as a service for decision making without knowing which algorithms the decision is based on.

From the standpoint of Enterprise Resource Planning ERP top down the DSS encapsulates the production i.e. manufacturing system as a Manufacturing Execution System MES service with interfaces for receipt of production orders and for production monitoring. The ERP system has no detailed knowledge of the automation processes but has knowledge only about production orders and their status.

Example according to For an electronic assembly production system PS a Production Execution System PES component production execution PE which supplies an interface DSS I for the service orchestration OE and the interface ERP I for an Enterprise Resource Planning System ERP was developed. An ERP system is thus capable of sending production orders to the Production Execution System PES. The production system uses pallets P which can send unfinished products to various workstations W W for processing. The conflict nodes in the model refer to among other things the locations where transport elements C C have multiple inputs and outputs and can carry pallets P to different workstations W W. The production system PS detects and identifies pallets P based on RFID tags OSI containing the pallet ID. With the help of the pallet ID at conflict points the production system PS can ask the Production Execution System PES via the DSS interface where the pallet is to be sent. The Production Execution System PES has identified the product belonging to the pallet P its processing status and the next working steps on the basis of knowledge of all ongoing orders all production processes the utilization of the workstations instantaneous and planned the availability of production resources so the Production Execution System PES can decide to which workstation the product is to be sent.

