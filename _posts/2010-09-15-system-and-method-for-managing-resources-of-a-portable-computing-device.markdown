---

title: System and method for managing resources of a portable computing device
abstract: A method and system for managing resources of a portable computing device is disclosed. The method includes receiving node structure data for forming a node, in which the node structure data includes a unique name assigned to each resource of the node. A node has at least one resource and it may have multiple resources. Each resource may be a hardware or software element. The system includes a framework manger which handles the communications between existing nodes within a node architecture. The framework manager also logs activity of each resource by using its unique name. The framework manager may send this logged activity to an output device, such as a printer or a display screen. The method and system may help reduce or eliminate a need for customized APIs when a new hardware or software element (or both) are added to a portable computing device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08615755&OS=08615755&RS=08615755
owner: QUALCOMM Incorporated
number: 08615755
owner_city: San Diego
owner_country: US
publication_date: 20100915
---
Portable computing devices PCDs are becoming personal necessities for people on personal and professional levels. These devices may include cellular telephones portable digital assistants PDAs portable game consoles palmtop computers and other portable electronic devices. Each of these devices may include a primary function. For example a cellular telephone generally has the primary function of receiving and transmitting telephone calls.

In addition to the primary function of these devices many include peripheral functions. For example a cellular telephone may include the primary function of making cellular telephone calls as described above and the peripheral functions of a still camera a video camera global positioning system GPS navigation web browsing sending and receiving emails sending and receiving text messages push to talk capabilities etc. As the functionality of such a device increases the computing or processing power required to support such functionality also increases. Further as the computing power increases there exists a greater need to effectively manage the processor or processors that provide the computing power.

In the past as each peripheral function supported by hardware or software or both was introduced to a device such as a cellular telephone a specific application programming interface API was introduced for each peripheral function. For example there may be a separate API for the video camera and a separate API for the GPS navigation application software. Each API generally logged its actions independently and each API generally has its own data structure which would need to cross reference the existing hardware or software of the cellular telephone that was in existence prior to the introduction of the new peripheral function.

The introduction of separate APIs for each peripheral function is very cumbersome and time consuming because of the cross reference to different hardware and software elements. Each hardware or software element supporting the base functions of the cellular telephone may have been provided with a nomenclature established by the original equipment manufacturer OEM of the cellular telephone and or the OEM of the underlying electronic supporting the base functions of the cellular telephone. The logging and debugging of new features or functions associated with software or hardware or both has long been recognized by those of ordinary skill in this portable computing device art as a significant problem in providing new products or features or both .

What is needed is a system and method that may overcome the problems associated with introducing new features or functions supported by new software or hardware or both that are added to systems built by original equipment manufacturers OEMs .

A method and system for managing resources of a portable computing device is disclosed. The method includes receiving node structure data for forming a node in which the node structure data includes a unique name assigned to each resource of the node. A node has at least one resource and it may have multiple resources. Each resource may be a hardware or software element. The system includes a framework manger which handles the communications between existing nodes within a node architecture. The framework manager also logs activity of each resource by using its respective unique name. The framework manager may send this logged activity to memory nonvolatile storage such as an embedded file system or an output device such as a printer or a display screen. The method and system may help reduce or eliminate a need for customized APIs when a new hardware or software element or both are added to a portable computing device.

According to a first exemplary aspect a method for managing resources of a portable computing device includes receiving node structure data for forming a node in which the node structure data includes a unique name. The method further includes reviewing the node structure data for one or more dependencies and then determining if each resource associated with a dependency exists within a node framework. If a resource associated with a dependency does not exist then the node structure data is stored in a temporary storage. If each resource for each dependency exists then the node and its one or more corresponding resources is created. If the node is created then the node is published within the node framework using its corresponding unique name in a state ready for processing communications.

According to another exemplary aspect a computer system for managing resources of a portable computing device includes a processor operable to receive node structure data for forming a node in which the node structure data comprising a unique name for each resource that is part of the node. The processor is also operable to review the node structure data for one or more dependencies and the processor is operable to determine if each resource associated with a dependency exists within a node framework. If a resource associated with a dependency does not exist then the processor is operable to store the node structure data in a temporary storage. If each resource for each dependency exists then the processor is operable to create the node and its one or more corresponding resources. If the node is created then the processor is operable to publish the node within the node framework using the one or more unique names corresponding node s one or more resources in a state ready for processing communications.

According to another exemplary aspect a computer system for managing resources of a portable computing device includes means for receiving node structure data for forming a node in which the node structure data comprises a unique name for each resource that is part of the node. The computer system further has means for reviewing the node structure data for one or more dependencies and means for determining if each resource associated with a dependency exists within a node framework. The computer system further includes means for storing the node structure data in a temporary storage if a resource associated with a dependency does not exist. The computer system also has means for creating the node and its one or more corresponding resources if each resource for each dependency exists. The computer system further has means for publishing the node within the node framework using the one or more unique names corresponding node s one or more resources in a state ready for processing communications if the node is created.

According to a further aspect a computer program product includes a computer usable medium having a computer readable program code embodied therein in which the program code is adapted to be executed and to implement a method for managing resources of a portable computing device. The method implemented by the code includes receiving node structure data for forming a node in which the node structure data has a unique name for each resource that is part of the node. The method also includes reviewing the node structure data for one or more dependencies and determining if each resource associated with a dependency exists within a node framework. If a resource associated with a dependency does not exist then the method stores the node structure data in a temporary storage. If each resource for each dependency exists then the process creates the node and its one or more corresponding resources. If the node is created then the process publishes the node within the node framework using the one or more unique names corresponding node s one or more resources in a state ready for processing communications.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects.

In this description the term application may also include files having executable content such as object code scripts byte code markup language files and patches. In addition an application referred to herein may also include files that are not executable in nature such as documents that may need to be opened or other data files that need to be accessed.

The term content may also include files having executable content such as object code scripts byte code markup language files and patches. In addition content referred to herein may also include files that are not executable in nature such as documents that may need to be opened or other data files that need to be accessed.

As used in this description the terms component database module system and the like are intended to refer to a computer related entity either hardware firmware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computing device and the computing device may be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers. In addition these components may execute from various computer readable media having various data structures stored thereon. The components may communicate by way of local and or remote processes such as in accordance with a signal having one or more data packets e.g. data from one component interacting with another component in a local system distributed system and or across a network such as the Internet with other systems by way of the signal .

In this description the terms communication device wireless device wireless telephone wireless communication device and wireless handset are used interchangeably. With the advent of third generation 3G wireless technology greater bandwidth availability has enabled more portable computing devices with a greater variety of wireless capabilities. Therefore a portable computing device may be a cellular telephone a pager a PDA a smartphone a navigation device or a hand held computer with a wireless connection or link.

Referring initially to and an exemplary portable computing device PCD is shown and is generally designated . As shown the PCD may include a housing . The housing may include an upper housing portion and a lower housing portion . shows that the upper housing portion may include a display . In a particular aspect the display may be a touch screen display. The upper housing portion may also include a trackball input device . Further as shown in the upper housing portion may include a power on button and a power off button . As shown in the upper housing portion of the PCD may include a plurality of indicator lights and a speaker . Each indicator light may be a light emitting diode LED .

In a particular aspect as depicted in the upper housing portion is movable relative to the lower housing portion . Specifically the upper housing portion may be slidable relative to the lower housing portion . As shown in the lower housing portion may include a multi button keyboard . In a particular aspect the multi button keyboard may be a standard QWERTY keyboard. The multi button keyboard may be revealed when the upper housing portion is moved relative to the lower housing portion . further illustrates that the PCD may include a reset button on the lower housing portion .

Referring to an exemplary non limiting aspect of a portable computing device PCD is shown and is generally designated . As shown the PCD includes an on chip system that includes a multicore CPU . The multicore CPU may include a zeroth core a first core and an Nth core .

As illustrated in a display controller and a touch screen controller are coupled to the multicore CPU . In turn a touch screen display external to the on chip system is coupled to the display controller and the touch screen controller .

As further illustrated in a stereo audio CODEC may be coupled to the multicore CPU . Moreover an audio amplifier may coupled to the stereo audio CODEC . In an exemplary aspect a first stereo speaker and a second stereo speaker are coupled to the audio amplifier . shows that a microphone amplifier may be also coupled to the stereo audio CODEC . Additionally a microphone may be coupled to the microphone amplifier . In a particular aspect a frequency modulation FM radio tuner may be coupled to the stereo audio CODEC . Also an FM antenna is coupled to the FM radio tuner . Further stereo headphones may be coupled to the stereo audio CODEC .

As depicted in the touch screen display the video port the USB port the camera the first stereo speaker the second stereo speaker the microphone the FM antenna the stereo headphones the RF switch the RF antenna the keypad the mono headset the vibrator and the power supply are external to the on chip system .

In a particular aspect one or more of the method steps described herein may be stored in the memory as computer program instructions. These instructions may be executed by the multicore CPU in order to perform the methods described herein. Further the multicore CPU the memory or a combination thereof may serve as a means for executing one or more of the method steps described herein in order to sample data within a central processing unit .

Referring to a processing system is shown and is generally designated . In a particular aspect the processing system may be incorporated into the PCD described above in conjunction with . As shown the processing system may include a multicore central processing unit CPU and a memory connected to the multicore CPU . The multicore CPU may include a zeroth core a first core and an Nth core . The zeroth core may include a zeroth dynamic clock and voltage scaling DCVS algorithm executing thereon. The first core may include a first DCVS algorithm executing thereon. Further the Nth core may include an Nth DCVS algorithm executing thereon. In a particular aspect each DCVS algorithm may be independently executed on a respective core .

Moreover as illustrated the memory may include an operating system stored thereon. The operating system may include a bus arbiter or scheduler and the scheduler may include a first run queue a second run queue and an Nth run queue . The memory may also include a first application a second application and an Nth application stored thereon.

In a particular aspect the applications may send one or more tasks to the operating system to be processed at the cores within the multicore CPU . The tasks may be processed or executed as single tasks threads or a combination thereof. Further the scheduler may schedule the tasks threads or a combination thereof for execution within the multicore CPU . Additionally the scheduler may place the tasks threads or a combination thereof in the run queues . The cores may retrieve the tasks threads or a combination thereof from the run queues as instructed e.g. by the operating system for processing or execution of those task and threads at the cores .

In a particular aspect the framework manager may be a software program. However in an alternative aspect the framework manager may be a hardware controller that is external to the memory . In either case the framework manager the memory the cores or any combination thereof may serve as a means for executing one or more of the method steps described herein in order to sample data from the cores .

An example of a legacy software element may include but is not limited to a Dynamic Environment Manager DEM . This is a software module that handles interprocessor notification of processor sleep events. For example a first processor A uses the DEM to receive a notification that a second processor B has gone idle come back from idle. On newer hardware this software functionality has been subsumed into the route processor module RPM subsystem communication protocol. Other legacy software elements exist and are included within the scope of the invention.

An example of a legacy hardware element may include but is not limited to an AMBA Advanced Microcontroller Bus Architecture High performance Bus AHB . On older PCDs the AHB may comprise the primary system bus whereas on newer PCDs the system bus fabric is completely different and the AHB bus is only used for special applications to communicate with modules that have not yet been updated to communicate via the new system bus fabric. Other legacy hardware elements exist and are included within the scope of the invention.

The framework manager may comprise a library of computer instructions that manages data structures such as nodes described below which communicate with each of the aforementioned hardware and software elements. The framework manager may be responsible for creating one or more resources that may form nodes and as illustrated on the right side of the dashed line A of . Each node and is a representation or model of each software or hardware element on the left hand side of the dashed line A of . For the remainder of this disclosure a general or non specific node will be designated with reference numeral as illustrated in .

As noted previously each exemplary node and of may comprise one or more resources. A resource may comprise a software element or hardware element or both. For example a first node comprises a single resource that generally corresponds with the first hardware element or central processing unit . With the inventive software architecture described in this disclosure each resource of a node may be provided with a unique name comprising one or more alphanumeric characters. In the exemplary embodiment illustrated in the resource of the first node has been assigned the resource name of core cpu. This exemplary resource name generally corresponds to conventional file naming structures known to one of ordinary skill in the art. However as recognized by one of ordinary skill the art other types of resource names containing any other combination of alpha numeric characters and or symbols are well within the scope of the invention.

In the exemplary embodiment of the second node comprises a plurality of resources. Specifically in this particular exemplary embodiment the second node has a first resource comprising a single hardware element corresponding to the bus arbiter or scheduler . The second resource of the second node comprises a software element generally corresponding to the first software element of the bus program A A. The third resource of the second node comprises another software element generally corresponding to the second software element of the bus program B B. One of ordinary skill the art recognizes that any combination and any number of resources and resource types for a given node are well within the scope of the invention.

Other relationships displayed in include dependencies illustrated with dashed lines . Dependencies are relationships between respective resources of another node . A dependency relationship usually indicates that a first resource A is reliant upon a second resource B that may provide the first resource A with information. This information may be a result of an operation performed by a second resource B or it may simply comprise status information that is needed by the first resource A or any combination thereof. The first resource A and second resource B may be part of the same node or they may be part of different nodes .

In the first node is dependent upon the second node as indicated by the dependency arrow B which originates with the first node and extends to the second at . also illustrates that the first node is also dependent upon the third node as illustrated by the dependency arrow A. also illustrates that the second node is dependent upon the fourth node as illustrated by the dependency arrow C. One of ordinary skill in the art recognizes that the dependencies illustrated with the dashed arrows of are only exemplary in nature and that other combinations of dependencies between respective nodes are within the scope of the invention.

The architecture or framework manager is responsible for maintaining the relationships described above that include but are not limited to the client requests and the dependencies illustrated in . The framework manager will try to instantiate or create as many nodes as it can as long as the dependencies for any given node are complete. A dependency is complete when a resource which supports a dependency is in existence or is in a ready state for handling information that relates to the dependency .

For example the first node comprising the single resource core cpu may not be created or established by the framework manager if the third node comprising the single resource clk cpu has not been created because of the dependency relationship A that exist between the first node in the third node . Once the third node has been created by the framework manager then the framework manager may create the first node because of the dependency relationship A.

If the framework manager is unable to create or instantiate a particular node because one or more of its dependencies are incomplete the framework manager will continue running or executing steps corresponding to those nodes that were created successfully by the framework manager . The framework manger will usually skip over a call for a particular node which may not exist due to incomplete dependencies in which dependent resources have not been created and return messages to that call which reflect that incomplete status.

In a multicore environment such as illustrated in the framework manager may create or instantiate nodes on separate cores like the first second and Nth cores and of . Nodes may generally be created in a multicore environment on separate cores and in parallel as long as the nodes are not dependent on one another and if all of a particular node s corresponding dependencies as described below are complete.

Calls within the node architecture illustrated in may be made to an alias or an actual resource name of a resource within a node . For example the first node A has a dependency arrow A to indicate that the first node A is dependent upon the two resources resources and of the second node B. also illustrates how a client of the first node A may issue a client request to the first node A. After these client requests are issued the second node B may trigger an event or provide a response to a query in which messages corresponding to the event and the query flow back to the client .

For example the first node has a dependency arrow B to indicate that the first node is dependent upon the three resources of the second node . Similarly the third resource bus ahb sysB comprising the second software element B and generally designated with the reference letter C in has a dependency arrow C that indicates this third resource C is dependent upon the single clk sys ahb resource of the fourth node .

The query function is generally not externally identified and generally it does not have a state. The query function may be used to determine the state of a particular resource of a node . The query function and the events may have relationships with established clients and these relationships are represented by directional arrows to indicate that information from respective event and query function are passed to a particular client .

The node or resource graphs B and B of respectively represent relationships that exist in memory such as memory of and which are managed by the framework manager and related data structures that may comprise the nodes . The node or resource graph graphs B and B can be automatically generated by the framework manager as a useful tool for identifying relationships between respective elements managed by the framework manager and for troubleshooting by a software team.

Next in block the framework manager may review the dependency data that is part of the node structure data received in block . In decision block the framework manager may determine if the node structure data defines a leaf node . A leaf node generally means that the node to be created based on the node structure data does not have any dependencies. If the inquiry to decision block is positive meaning that the node structure data for creating the current node does not have any dependencies then the framework manager continues to routine block .

If the inquiry to decision block is negative then the No branch is followed to decision block in which the framework manager determines if all of the hard dependencies within the node structure data exist. A hard dependency may comprise one in which a resource cannot exist without. Meanwhile a soft dependency may comprise one in which a resource may use the dependent resource as an optional step. A soft dependency means that a node or resource of the node which has a soft dependency may be created or instantiated within the node architecture even when the soft dependency does not exist.

An example of a soft dependency may comprise an optimization feature that is not critical to the operation for a resource oriented containing multiple resources. The framework manager may create or instantiate a node or a resource for all hard dependencies that are present and even when a soft is dependency is not present for those nodes or resources which have soft dependencies that are not created. A call back feature may be used to reference the soft dependency so that when the soft dependency becomes available to the framework manager the framework manager will inform each callback referencing the soft dependency that the soft dependencies are now available.

If the inquiry to decision block is negative then the No branch is followed to block in which the node structure data is stored by the framework manager in temporary storage such as memory and the framework manager creates a call back feature associated with this un instantiated node.

If the inquiry to decision block is positive then the Yes branch is followed to routine in which a node is created or instantiated based on the node structure data received in routine block . Further details of routine block will be described below in connection with . Next in block the framework manager publishes the newly created node using its unique resource name s so that other nodes may send information to or receive information from the newly created node .

Referring now to which is a continuation flow chart of in block the framework manager notifies other nodes which are dependent on the newly created node that the newly created node has been instantiated and is ready to receive or transmit information.

According to one exemplary aspect notifications are triggered immediately when a dependent node like node B of is created i.e the notifications are performed recursively. So if node B of is constructed node A is immediately notified. This notification may allow node A to be constructed since node B was node A s final dependency . Construction of node B may causes other nodes to be notified and so on and so on. Node B does not get completed until the final resource dependent on node B is completed.

A second slightly more complex implementation is to put all of the notifications onto a separate notification queue and then run through the queue at a single point in time i.e. the notifications are performed iteratively. So when node B of is constructed the notification to node A is pushed onto a list. Then that list is executed and node A gets notified. This causes the notification to other additional nodes besides node A not illustrated in to be put on the same list and that notification is then sent after the notification to node A is sent. The notifications to other nodes besides the notification to node A doesn t happen until after all the work associated with node B and node A has been completed.

Logically these two implementations are exactly equivalent but they have different memory consumption properties when implemented. The recursive realization is simple but can consume an arbitrary amount of stack space with the stack consumption being a function of the depth of the dependency graph. The iterative implementation is slightly more complex and requires a bit more static memory the notification list but stack usage is constant irrespective of the depth of a dependency graph such as illustrated in .

Also notification of node creation in block is not limited to other nodes. It may also used internally for alias construction. Any arbitrary element in the system can use the same mechanism to request for notification when a node or marker becomes available not just other nodes. Both nodes and non nodes may use the same notification mechanism.

In decision block the framework manager determines if other nodes or soft dependencies are now released for creation or instantiation based on the creation of the current node . Decision block is generally determining if resources may now be created because certain dependency relationships have been fulfilled by the current node which has recently undergone creation or instantiation.

If the inquiry to decision block is positive then the Yes branch is followed back to routine block in which the released node may now be created or instantiated because of the fulfillment of a dependency by the node that was just created.

If the inquiry to decision block is negative then the No branch is followed to block in which the frame work manager may manage communications between elements of the software architecture as illustrated in . Next in block the framework manager may continue to log or record actions taken by resources by using the resource names associated with a particular resource. Block may be executed by the framework manager after any action taken by the framework manager or any of the elements managed by the framework manager such as the resources nodes clients events and query functions . Block is yet one important aspect of the invention in which the framework manager may maintain a running log of activity that lists actions performed by each element according to their unique identifier or name provided by the authors who created a particular element such as a resource of a node .

Compared to the prior art this logging of activity in block that lists unique names assigned to each resource of a system is unique and may provide significant advantages such as used in debugging and error troubleshooting. Another aspect of many that makes the system unique is that separate teams may work on different hardware and or software elements independently of one another in which each team will be able to use resource names that are unique and easy to track without the need for creating tables to translate less meaningful and usually confusing resource names assigned by other teams and or the original equipment manufacturer OEM .

Next in decision block the framework manager determines if a log of activity recorded by the framework manager has been requested. If the inquiry to decision block is negative then the No branch is followed to the end of the process in which the process returns back to routine . If the inquiry to decision block is positive then the Yes branch is followed to block in which the framework manager sends the activity log comprising meaningful resource names and respective actions performed by the resource names to an output device such as a printer or a display screen and or both. The process then returns to routine block described above.

According to exemplary aspects of the system resources of nodes may generally have unique names across the system but it is not required that client or event names be unique though they may be unique as desired.

For convenience a conventional tree file naming structure or file naming metaphor that employs forward slash characters for creating unique names may be employed such as but not limited to core cpu for CPU and clk cpu for clock . However as recognized by one of ordinary skill the art other types of resource names containing any other combination of alpha numeric characters and or symbols are well within the scope of the invention.

Next in block the framework manager may receive data for one or more driver functions associated with one or more resources of the node being created. A driver function generally comprises the action to be completed by one or more resources for a particular node . For example in the driver function for the resource core cpu of node may request the amount of bus bandwidth and the CPU clock frequency it requires in order to provide the requested amount of processing that has been requested. These requests would be made via clients not illustrated of the resources in nodes and node . The driver function for clk cpu in node would usually be responsible for actually setting the physical clock frequency in accordance with the request it received from the core cpu resource of node .

In block the framework manager may receive node attribute data. The node attribute data generally comprises data that defines the node policies such as security can the node be accessed via user space applications remotability can the node be accessed from other processors in the system and accessibility can the resource support multiple concurrent clients . The framework manager may also define attributes that allow a resource to override default framework behavior such as request evaluation or logging policy.

Subsequently in block the framework manager may receive customized user data for the particular node being created. The user data may comprise a void star field as understood by one of ordinary skill in the art with respect to the C programming language. User data is also known to one of ordinary skill in the art as a trust me field. Exemplary customized user data may include but is not limited to tables such as frequency tables register maps etc. The user data received in block is not referenced by the system but allows for customization of a resource if the customization is not recognized or fully supported by the framework manager . This user data structure is a base class in the C programming language intended to be extended for particular or specific uses.

One of ordinary skill the art recognizes that other kinds of data structures for extending specific uses of a particular class are within the scope of the invention. For example in the programming language of C C plus plus an equivalent structure may comprise the key word public which would become an extension mechanism for a resource within a node .

Next in block the framework manager may receive dependency array data. The dependency array data may comprise the unique and specific names of one or more resources on which the node being created is dependent. For example if the first node of was being created then in this block the dependency array data may comprise the resource names of the three resources of the second node and the single resource name of the third node on which the first node is dependent.

Subsequently in block the framework manager may receive resource array data. The resource array data may comprise parameters for the current node being created such as parameters relevant to the first node of if this first node was being created. The resource array data may comprise one or more of the following data the names of other resources unit maximum value resource attributes plug in data and any customized resource data similar to the customize user data of block . The plug in data generally identifies functions retrieved from a software library and usually lists the client types that may be supported by the particular node or plurality of nodes being created. The plugin data also allows for customization of client creation and destruction. After block the process returns to block of .

In the attribute data block customize user data block and the dependency array data block have been illustrated with dashed lines to indicate that these particular steps are optional and not required for any given node . Meanwhile the unique name block a driver function block and resource array data block have been illustrated with solid lines to indicate that these steps of routine are generally mandatory for creating a node .

In block the framework manager may create or instantiate the one or more resources corresponding to the node structure data of block . Next in block the framework manager may activate the driver functions received in routine block of routine block using the maximum values received in the resource array data block of routine block . According to one exemplary aspect the driver functions may be activated using the maximum values received in the resource array data block of routine block . According to another preferred exemplary aspect each driver function may be activated with an optional initial value that is passed along with the node structure data from routine . If initial data is not provided the driver function is initialized at 0 the minimum value. The driver function is also usually activated in manner such that it is known that it is being initialized. This enables the resource to perform any operations that are specific to initialization but do not need to be performed during normal or routine operation. The process then returns to step of .

The name table allows a first design team such as an original equipment manufacturer OEM for software drivers focused on certain hardware and or software elements to provide unique names internal relative to the first design team working on the particular piece of hardware or software. With the name table second and third or more outside design teams may be able to reference the hardware or software elements of the first design team of the OEM in this example by using aliases preferred by those of the second and third outside design teams.

For example an OEM may assign the name cpu to the central processing unit of as illustrated in the first row and second column of the table in . Meanwhile a second team of professionals relative to the OEM may desire to assign a different name or alias to the same central processing unit . The second team may assign the alias of main processor which corresponds to the resource name of cpu as illustrated in the first row and first column of the table of .

If the inquiry to decision block is negative then the No branch is followed to block in which the alias is stored in temporary storage until the resource is created. Specifically when an alias to an undefined name is created this alias is stored in memory and the process goes back to waiting for more aliases to be defined. When an alias is instantiated the alias name is stored in memory along with a callback against the as yet undefined name alias . When that undefined name alias is published that notifies the alias which then causes it to be published. This behavior is essentially the same as the resource creation process when there is a missing dependency.

The process then proceeds back to block . If the inquiry to decision block is positive then the Yes branch is followed to block in which the alias is published by the framework manager so that other resources may access the resource corresponding to the alias that has just been created. The process then returns.

Next in block customized user data may be received by the framework manager if there are any particular customizations for this client being created. Block has been illustrated with dashed lines to indicate that the step is optional. The customized user data of block is similar to the customized user data discussed above in connection with the creation of resources for nodes .

In block the framework manager receives the client type category assigned to the particular client being created. The client type category as of this writing may comprise one of four types a required b impulse c vector and d isochronous. The client type category list may be expanded depending upon the resources being managed by the system and upon the application programs relying upon the resources of the nodes .

The required category generally corresponds with the processing of a scalar value that is passed from the required client to a particular resource . For example a required request may comprise a certain number of millions of instructions per second MIPs . Meanwhile the impulse category generally corresponds with the processing of a request to complete some activity within a certain period of time without any designation of a start time or stop time.

An isochronous category generally corresponds with a request for an action that is typically reoccurring and has a well defined start time and a well defined end time. A vector category generally corresponds with an array of data that usually is part of multiple actions that are required in series or in parallel.

Subsequently in block the framework manager receives data that indicates whether the client has been designated as synchronous or asynchronous. A synchronous client is one that typically requires the framework manager lock a resource of a node until the resource returns data and an indication that the resource has finished completing the requested task from the synchronous client .

On the other hand an asynchronous client may be handled by one or more threads See in parallel which are accessed by the framework manager . The framework may create a callback to a thread and may return a value when the callback has been executed by a respective thread . One of ordinary skill the art recognizes that the asynchronous client does not lock up a resource like a synchronous client does when the task of the synchronous client is being executed.

After block in decision block the framework manager determines if the resource identified by the client are available. If the inquiry to decision block is negative then the No branch is followed to block in which a null value or message is returned to a user indicating that the client cannot be created at this time.

If the inquiry to decision block is positive then the Yes branch is followed to decision block in which the framework manager determines if each resource identified by the client supports the client type provided in block . If the inquiry to decision block is negative then the No branch is followed back to block in which a null value or message is returned indicating that the client cannot be created at this time.

If the inquiry to decision block is positive then the Yes branch is followed to block in which the framework manager creates or instantiates the client in memory. Next in block if any customized user data is received in block such as optional arguments then these optional arguments may be mapped with their respective resources a particular nodes . Next in block the newly created client is coupled to its corresponding one or more resources in an idle state or on requested state as illustrated in described above. The process then returns to block of .

In block the framework manager may receive the data associated with a particular client request such as one of the three mentioned above a required b impulse and c vector. The data associated with a required request generally comprises a scalar value that is passed from the required client to a particular resource . For example a required request may comprise a certain number of millions of instructions per second MIPs . Meanwhile an impulse request comprises a request to complete some activity within a certain period of time without any designation of a start time or stop time. Data for a vector request generally comprises an array of multiple actions that are required to be completed in series or in parallel. A vector request may comprise an arbitrary length of values. A vector request usually has a size value and an array of values. Each resource of a node may be extended to have a pointer field in order to support a vector request. In the C programming language the pointer field is supported by the union function as understood by one of ordinary skill in the art.

Next in block the framework manager issues the request through the client that was created by the method described above in connection with . Subsequently in block the framework manager double buffers the request data being passed through the client if the request is a required type or a vector type. If the request is an impulse type then block is skipped by the framework manager .

For required requests in this block values from a prior request are maintained in memory so that the framework manager can determine if there is any difference between the previous requested values in the current set of requested values. For vector requests prior requests are usually not maintained in memory although a resource of a node may maintain it as desired for a particular implementation. Therefore block is optional for vector types of requests.

In block the framework manager calculates the delta or difference between the previous set of requested values in the current set of requested values. In decision block the framework manager determines if the current set of requested values is identical to the previous set of requested values. In other words the framework manager determines if a difference exists between the current set of requested values and the previous set of requested values. If there is no difference between the current set and previous set of requested values then the Yes branch is followed which skips blocks through block to block in which the process ends.

If the inquiry to decision block is negative meaning that the set of requested values are different relative to the set of pre previous requested values then the No branch is followed to decision block .

In decision block the framework manager determines if the current request is an asynchronous request. If the inquiry to decision block is negative then the No branch is followed to block in which the resource corresponding to the client request is locked by the framework manager . If the inquiry to decision block is positive meaning that the current request is asynchronous request type then the Yes branch is followed to block in which the request may be pushed onto another thread and may be executed by another core if a multicore system like that of is currently managed by the framework manager . Block has been illustrated with dashed lines to indicate that this step may be optional if the PCD is a single core central processing system.

Subsequently in block the resources corresponding to the request is locked by the framework manager . Next in block the resource executes the update function which generally corresponds to the plug in data of the resource array data received in block of . The update function generally comprises a function responsible for the new resource state in light of a new client request. The update function compares its previous state with the requested state in the client request. If the requested state is greater than the previous state then the update function will perform the client request. However if the requested state is equal to or less than the current state and which the resource is operating at then the client request will not be performed in order to increase the efficiency since the old state achieves or satisfies the requested state. An update function takes a new request from the client and aggregates it with all the other active requests to determine the new state for the resource.

As an example multiple clients may be requesting a bus clock frequency. The update function for the bus clock would usually take the maximum of all the client requests and use that as the new desired state for the bus clock. It is not the case that all resources will use the same update function although there are some update functions that will be used by multiple resources. Some common update functions are to take the maximum of client requests to take the minimum of client requests and to sum the client request. Or resources may define their own custom update function if their resource needs to aggregate requests in some unique way.

Next in block the framework manager passes the data to the resource corresponding to the client request so that the resource may execute the driver function which is specific to the resource of a node . A driver function applies the resource state as computed by the update function. This may entail updating hardware settings issuing requests to dependent resources calling legacy functions or some combination of the above.

In the previous example the update function computed the requested bus clock frequency. The driver function may receive that requested frequency and it may update the clock frequency control HW to run at that frequency. Note that sometimes it is not possible for the driver function to meet the exact requested state that update function has computed. In this case the driver function may choose the frequency that best meets the request. For example the bus clock HW may only be able to run at 128 MHz and 160 MHz but the requested state might be 150 MHz. In this case the driver function should run at 160 MHz as that exceeds the requested state.

Next in block the framework receives state control from the resource which have executed the driver function in block . Subsequently in block if defined against the resource events may be triggered so that data is passed back to the client which corresponds to the event . Events may be processed in another thread. This may minimize the amount of time spent with the resources locked and allows for more parallel operation in a multicore system as illustrated in . One or more events may be defined against a resource in a manner similar to how a request may be defined against a resource as described in this method . In other words the event creation process may largely parallel the client creation process. One thing that is different with the events is that it is possible to define events that only get triggered when certain thresholds are crossed.

This defining of events that only get triggered based on thresholds allows for notification of when a resource is getting oversubscribed it has more concurrent users than it can support which is indicative of a system overloading condition or when a resource goes low off which may allow other things to be shut off restore functionality that was disabled when the system became oversubscribed etc. Because the event registration may be done with thresholds it reduces the amount of work the system has to do on event notification to only happen when there is something really necessary. It is also possible to register for an event on every state change.

Next in optional block if the request being processed is a vector request then this optional block is usually performed. Optional block generally comprises a check or determination to assess whether the vector pointer is still positioned on the same data that the user passed into the vector. If the inquiry to this optional block is positive meaning that the pointer is still pointing to the same data which was passed by the user into the vector then the pointer is cleared out so that references to old data is not maintained. This optional block is generally performed to account for the double buffering block described above when a vector request is being processed compared to an impulse request and a required request.

Subsequently in block the framework unlocks the requested resource so that other client requests may be handled by the current but now released requested resource of a particular node . The process then returns to the first block for receiving the next client request.

Block is the first step of the sub method or routine for processing isochronous requests . Block occurs after block and before block of . In block the framework manager may receive the deadline data such as deadline C as discussed above in connection with .

Next in block the framework manager may calculate a difference between the current time and the deadline provided in block . Subsequently in block which occurs after block but before block of the framework manager compares the start time A and finish time B with the deadline C See . In block because the framework manager was provided with the amount of activity requested and because the framework manager tracks the start time A and finish time B then in block the framework manager may calculate the amount of work that was performed by the resource of a particular node .

Next in block which occurs after block and before block of an optimization process may be executed. Block has been illustrated with dashed lines to indicate that the step is optional or that this step may be performed off line and off device relative to the PCD . The optimization process may attempt to determine how the work may be best completed between the start time in the deadline while taking into account many different variables such as power consumption and responsiveness. In some exemplary embodiments this block may be entirely skipped altogether without departing from the scope of the invention. The process then returns to block of for processing the next client request .

Certain steps in the processes or process flows described in this specification naturally precede others for the invention to function as described. However the invention is not limited to the order of the steps described if such order or sequence does not alter the functionality of the invention. That is it is recognized that some steps may performed before after or parallel substantially simultaneously with other steps without departing from the scope and spirit of the invention. In some instances certain steps may be omitted or not performed without departing from the invention. Further words such as thereafter then next etc. are not intended to limit the order of the steps. These words are simply used to guide the reader through the description of the exemplary method.

Additionally one of ordinary skill in programming is able to write computer code or identify appropriate hardware and or circuits to implement the disclosed invention without difficulty based on the flow charts and associated description in this specification for example.

Therefore disclosure of a particular set of program code instructions or detailed hardware devices is not considered necessary for an adequate understanding of how to make and use the invention. The inventive functionality of the claimed computer implemented processes is explained in more detail in the above description and in conjunction with the Figures which may illustrate various process flows.

In one or more exemplary aspects the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored on or transmitted as one or more instructions or code on a computer readable medium. Computer readable media include both computer storage media and communication media including any medium that facilitates transfer of a computer program from one place to another. A storage media may be any available media that may be accessed by a computer. By way of example and not limitation such computer readable media may comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium that may be used to carry or store desired program code in the form of instructions or data structures and that may be accessed by a computer.

Also any connection is properly termed a computer readable medium. For example if the software is transmitted from a website server or other remote source using a coaxial cable fiber optic cable twisted pair digital subscriber line DSL or wireless technologies such as infrared radio and microwave then the coaxial cable fiber optic cable twisted pair DSL or wireless technologies such as infrared radio and microwave are included in the definition of medium.

Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

Although selected aspects have been illustrated and described in detail it will be understood that various substitutions and alterations may be made therein without departing from the spirit and scope of the present invention as defined by the following claims.

