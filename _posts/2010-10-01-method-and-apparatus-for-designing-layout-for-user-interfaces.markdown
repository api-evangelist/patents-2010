---

title: Method and apparatus for designing layout for user interfaces
abstract: A method is provided that receives an image that includes graphical metadata for specifying alignment information. The method renders the image by using the alignment information. Rendering the image by using the alignment information includes positioning text on the image, aligning the image with another image, and identifying visual boundaries of the rendered image. The graphical metadata includes a geometric shape that specifies a region on the image where the text is to be rendered. The alignment metadata also specifies a maximum size for text rendered on the image. In some embodiments, the image is a multi-layer image that includes a first layer for the image and a second layer for the graphical metadata. In some embodiments, the layer that includes the graphical metadata is designated to include graphical metadata. The graphical metadata is not rendered on a graphical user interface where the image is rendered.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09513883&OS=09513883&RS=09513883
owner: APPLE INC.
number: 09513883
owner_city: Cupertino
owner_country: US
publication_date: 20101001
---
A graphical user interface GUI is a human computer interface that allows a user to interact with programs through a set of graphical objects such as controls icons menus and windows. The GUIs have all but replaced the earlier command line interfaces which used only text and were accessed solely by a keyboard. Users interact with GUI objects by using a mouse trackball touchpad or keyboard. For instance a mouse can be used to move a pointer on the screen on top of a GUI object such as an icon to select the object. Then the object can be moved by dragging or can be selected by clicking on its icon.

Many tools exist that facilitate writing GUIs for application developers. These tools provide libraries that define each GUI element e.g. as a class and provide application programming interfaces APIs from which an application can create object instances. Also source code for predefined methods are available that allow application developers to use or modify in order to develop application programs to display and manipulate GUI objects.

In order to control the specifics of the sizing and spacing of graphical elements to determine where text is to be rendered relevant to the image and to align graphical elements against each other there is a need to generate a correspondence between the image artwork and the displayed layout. Typically a correspondence is made between the image artwork and what the code is doing by actually hard coding the desired layout in the software itself. There is therefore an explicit awareness of the underlying design and topology of the image artwork in the code. Such a correspondence would require custom written software programs to display GUI objects for the specific topology and alignment requirements of each application.

Tools are also available that allow manual entering of metadata that describe how graphical components of GUI elements can be aligned against each other and how the associated text can be placed on GUI elements at render time. These tools are used to enter the descriptions through a set of alphanumeric fields once the image artwork is designed. In order to specify the alignment information measuring tools provided by graphics editing tools are used to determine the exact distances of text relative to the image as well as the distances of different graphical components relative to each other.

Some embodiments provide a method and a system for augmenting pixel based artwork for a graphical user interface GUI element with additional image based metadata. In some embodiments the additional metadata is used at runtime by an application that displays the user interface to enable correct alignment of text on a GUI element. For instance an image for a pushbutton may include in addition to the pushbutton bezel graphical metadata in the form of a rectangle that identifies place and the maximum size of text being displayed on the pushbutton at runtime. Several different applications running at different times can use the same pushbutton image and the same graphical metadata to display different text on the pushbutton image.

In some embodiments the GUI element includes several components and the graphical metadata enables the correct placement and rendering of multiple constituent parts of the overall GUI element. For instance a slider includes a knob and a track. The knob and the track can each include graphical metadata in the form of geometric shapes that specify how the knob is to be aligned on the track when the knob is moved in runtime from one position to another position. In some embodiments the GUI element includes graphical metadata to identify the boundaries e.g. visual edges or corners of the image as distinguished e.g. from a drop shadow that is displayed with the image.

One advantage of including graphical metadata in the graphical assets is the ability to execute a wide variety of designs for interface elements purely through the graphical asset manipulation and without requiring any changes in the underlying software. Operations such as aligning text with an image at runtime and aligning different movable components of a graphical user interface element can be done by using pixel based data that is delivered as an integral part of the image of the graphical asset itself.

In some embodiments the image for the graphical asset is created as a multi layer image. In these embodiments one or more of the layers are utilized to include the graphical metadata. In some embodiments one or more specific types of layers e.g. channel layer mask layer and or any other particular type of layer in the image are designated to include graphical metadata to distinguish the layers that include metadata from layers that include the graphics for the rendered image.

In the following detailed description of the invention numerous details examples and embodiments of the invention are set forth and described. However it will be clear and apparent to one skilled in the art that the invention is not limited to the embodiments set forth and that the invention may be practiced without some of the specific details and examples discussed.

Some embodiments provide a method and a system for augmenting pixel based artwork for a graphical user interface GUI element with additional image based metadata. In some embodiments the additional metadata is used at runtime by an application that displays the user interface to enable correct alignment of text on a GUI element. For instance an image for a pushbutton may include in addition to the pushbutton bezel graphical metadata in the form of a rectangle that identifies place and the maximum size of text being displayed on the pushbutton at runtime. Several different applications running at different times can use the same pushbutton image and the same graphical metadata to display different text on the pushbutton image.

In some embodiments the GUI element includes several components and the graphical metadata enables the correct placement and rendering of multiple constituent parts of the overall GUI element. For instance a slider includes a knob and a track. The knob and the track can each include graphical metadata in the form of geometric shapes that specify how the knob is to be aligned on the track when the knob is moved in runtime from one position to another position. In some embodiments the GUI element includes graphical metadata to identify the boundaries e.g. visual edges or corners of the image as distinguished e.g. from a drop shadow that is displayed with the image.

One benefit of including graphical metadata in the graphical assets is the ability to execute a wide variety of designs for interface elements purely through the graphical asset manipulation and without requiring any changes in the underlying software. Operations such as aligning text with an image at runtime and aligning different movable components of a graphical user interface element can be done by using pixel based data that is delivered as an integral part of the image of the graphical asset itself.

In some embodiments the image for the graphical asset is created as a multi layer image. In these embodiments one or more of the layers are utilized to include the graphical metadata. In some embodiments one or more specific types of layers e.g. channel layer mask layer and or any other particular type of layer in the image are designated to include graphical metadata to distinguish the layers that include metadata from layers that include the graphics for the rendered image.

Some embodiments provide a method that receives an image which includes graphical metadata for specifying alignment information. The method renders the image by using the alignment information. The alignment information is used to position text on the image. The alignment information is also used to align the image with another image. For instance two components of a control element that move against each other are aligned by using graphical metadata that specify regions for aligning the image of the components. Graphical metadata also includes regions that identify the visual boundaries of the rendered images.

The graphical metadata includes a geometric shape that specifies a region on the image where the text is to be rendered. The alignment metadata also specifies a maximum size for text rendered on the image.

Some embodiments provide a computer readable medium that stores a computer program. The computer program is executable by at least one processing unit. The computer program includes a set of instructions for receiving an image that includes graphical metadata which specify alignment information. The computer program also includes a set of instructions for rendering the image by using the alignment information.

Some embodiments provide a method for defining a program for rendering an image for a user interface. The method defines a module for receiving an image that includes graphical metadata that specify alignment information. The method defines a module for rendering the image based on the alignment information.

Several more detailed embodiments of the invention are described in sections below. Specifically Section I describes several term and definitions used in some embodiments. Next Section II provides an overview of the graphical user interface drawing framework of some embodiments. Section III describes how graphical assets are aligned using graphical metadata. Section IV describes the software architecture of the graphical user interface drawing framework of some embodiments. Next Section V describes the software architecture of the runtime drawing API of some embodiments. Lastly Section VI provides a description of a computer system with which some embodiments of the invention are implemented.

In the following discussions the term graphical user interface GUI is referred to a type of user interface UI that allows users to interact with computer programs. In addition to text a GUI generally includes visual indicators and allows a human user to manipulate and interact with the GUI elements.

The image used to render a visual component of the GUI such as a control or an icon is referred to as an asset artwork asset or graphical asset interchangeably. For instance an image for a checkbox a pushbutton and a slider are all referred to as an asset artwork asset or graphical asset.

There is a fundamental difference between the checkbox asset and the slider asset however. The slider includes at least two parts a track and a knob while the checkbox is just a single checkbox. An elementary asset of the GUI is a unit of the GUI that cannot be broken down further into parts. For instance the slider has at least two elementary assets the knob and the track while the checkbox is the only elementary asset of the checkbox element. Although several examples are used that refer to elementary assets for simplicity the teachings disclosed for different embodiments of the invention equally apply to assets that are not elementary i.e. can still be broken into smaller packets .

An elementary asset such as a checkbox can be drawn checked unchecked or partly checked. The checkbox can have different appearances when pressed unpressed disabled or inactive. There can also be raised inset and matte variants as well as several different tints and several different sizes for the checkbox. The term rendition is therefore used to refer to a specific drawing of an elementary asset.

Graphical metadata is referred to graphical drawings that are added to images of assets to convey additional information about the assets. For instance a graphical metadata can be a geometric shape such as a rectangle or a polygon included in the image to specify the size and location of text to be displayed on the image at the render time i.e. at the runtime of an application that displays the GUI to a user . As disclosed throughout the specification graphical metadata are used to convey other information such as visual boundaries edges and corners of the rendered assets and regions for alignment of assets with each other. Graphical metadata are distinguished from alphanumeric metadata which define properties of the image by using strings of characters and numbers as opposed to shapes and graphical images that identify different regions for alignment and rendering of text and images.

As shown in a designer e.g. a graphics artist or a visual designer uses the graphics editing tool to create the graphical image or artwork for the assets. In some embodiment each asset is stored in the form of a file or an object that includes the pixels needed to draw or render the asset.

The designer also draws graphical metadata e.g. rectangles polygons ellipses circles etc. that carry alignment and other information needed to display the artwork on a graphical user interface at runtime. The artwork for the asset therefore includes the graphical metadata for the asset. The use of graphical metadata to draw and align the assets is described further below. The asset artwork and the associated metadata are stored in the elementary assets library . The distiller automatically analyzes the metadata and converts the graphical metadata into a set of metrics such as numerical coordinates for placing text on graphical objects or for aligning graphical objects with each other. The elementary assets and the associated metadata are stored in a runtime asset database.

At render time one or more applications utilize the API modules to draw the graphical objects. In some embodiments the applications are linked to the API modules prior to the applications runtime. In other embodiments the API modules are dynamically linked to the applications at the applications runtime. The drawing API modules draw the graphical objects and associated text requested by the applications using the artwork in the runtime asset database .

The graphics editing tool is used when the GUI is being designed while the APIs are used during runtime of applications that display i.e. draw or render the GUI during their execution. The example of the distiller in generates the runtime asset library prior to the execution of applications . However it would be realized by one of ordinary skill in the art that the distiller can be part of a real time interpreter that converts graphical metadata into numerical coordinates for individual applications at runtime without deviating from the teaching for the embodiments of the invention. Specifically in the embodiments that distiller converts graphical metadata at runtime of applications the distiller tool sends its output to the rendering applications and or the APIs instead of or in addition to storing the output in the runtime asset database . Several different embodiments provided for creating and drawing GUI assets are described further below by reference to .

The process optionally stores at the assets and their associated graphical metadata in a graphical assets library . The process then distills at the assets to prepare the assets for runtime display by the drawing API modules . For instance the process analyzes the graphical metadata associated with each asset and identifies the coordinates for the boundaries visual edges or corners of the assets. The process also analyzes the graphical metadata and identifies coordinates for the corners or edges of alignment regions used to align assets with each other and with their associated text. The process then optionally stores at the assets and their associated metadata in a runtime asset database . The process then exits.

One of ordinary skill in the art will recognize that process is a conceptual representation of the operations used to generate the artwork assets for runtime processing. The specific operations of process may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Furthermore the process could be implemented using several sub processes or as part of a larger macro process. For instance some embodiments provide separate tools for graphics editing and distilling operations while other embodiments provide a single integrated tool.

The process then retrieves at the requested asset and its associated metadata from the runtime asset database . Next the process uses the metadata to display the asset. For instance the process uses the metadata to display the asset at a desired location e.g. by using boundary identification metadata to display text at proper location e.g. by using text alignment metadata and or to align the asset with other displayed assets e.g. by using asset alignment metadata . The process then exits. Some embodiments distill the assets as part of the same runtime process that renders the graphical assets on a graphical user interface. In these embodiments operation shown in is performed as a part of process instead of process . In these embodiments operation which stores the assets and their associated metadata in the runtime library is optional.

One of ordinary skill in the art will recognize that process is a conceptual representation of the operations used to generate the artwork assets for runtime processing. The specific operations of process may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Furthermore the process could be implemented using several sub processes or as part of a larger macro process. Furthermore operations and described in are performed by process in some embodiments.

Some embodiments draw graphical image assets as multi layered objects. The number of layers depends on the complexity of the asset. For instance a glass push button requires a highlight layer. In addition an asset may have different layers for different states such as normal pressed inactive disabled etc. conceptually illustrates a multi layered graphical object that includes three layers . The designer uses the graphics editing tool to draw different layers of the asset. At render time the layers are used to display the object. The drawing API displays the asset based on the properties of each layer e.g. opacity transparency etc. .

Some embodiments utilize additional layers for adding other graphical objects such as drop shadows or highlights to the image. In addition some embodiments designate one or more layers of an asset image to include graphical metadata for the asset. The graphical metadata is in the form of a geometric shape such as a rectangle a polygon an ellipse a circle or any arbitrary shape and specifies how the asset is aligned with text and other graphical assets. In addition graphical metadata is used in some embodiments to identify the boundaries i.e. visual edges and corners of an asset.

In some embodiments each layer includes multiple images for an elementary asset. For instance a checkbox in each layer can include different images to indicate on e.g. checked off e.g. unchecked and mixed e.g. shown as a dashed line values for the checkbox. In addition each value of the checkbox can have several different tints e.g. blue yellow grey green etc. in some embodiments. As an example when there are three values eight tints and five states for a checkbox there could be 120 renditions for the checkbox. These renditions can be arranged in five layers with each layer having twenty four renditions of the checkbox.

The checkbox elementary asset also has three values of on off and mixed . In addition the checkbox images in the example of can have one of the eight tints of grey indigo violet red orange yellow green and blue. The checkbox elementary asset of the example of therefore has five layers and can have up to 120 different renditions although in the example of the rollover state has similar renditions for all three images related to each tint .

In some embodiments the layer or layers used to include graphical metadata are distinguished from other layers. For instance layers for graphical metadata are designated as channel layers mask layers or graphical metadata layers in some embodiments. Designating separate layers for graphical metadata makes it easier to identify and extract the graphical metadata from the image asset. The graphical metadata can be conceptually visualized as an acetate layer or mask on the asset layout. The graphical metadata therefore provides pixel data which is used to display and align graphical assets on a graphical user interface.

Storing image data and graphical metadata as a multi layer object provides several advantages. For instance image data is packaged coherently together with and directly alongside its associated graphical metadata in one object that can be stored in one data structure or in one file. At the same time storing graphical metadata and image data in separate and easily identifiable layers enables a tool such as the distiller tool to easily identify and process the graphical metadata. Several examples of these graphical metadata are described in the following sub sections.

The next layer is utilized to include two graphical metadata and . Graphical metadata is used to identify the boundaries i.e. visual edges and corners of the pushbutton as distinguished from e.g. the drop shadow around it. As shown in this example graphical metadata is drawn as a rectangle that closely matches the outer exterior of the pushbutton shape .

Layer also includes a second graphical metadata which is used to align text which is displayed on the pushbutton at runtime. Although the example of shows both graphical metadata and in one layer some embodiments include each graphical metadata in a separate layer.

The pixels in drop shadow and pushbutton shape are parts of the pushbutton image that are rendered on the GUI by a rendering application shown in . However the drop shadow is not a critical part of the layout while the pushbutton shape is a critical part which is manipulated by the rendering application . Using graphical metadata facilitates identifying the critical part of the pushbutton image from the non critical parts of the image.

The knob elementary asset also includes two layers and . Layer includes the graphics for the knob shape or layout . Layer includes two graphical metadata and . Graphical metadata is used to identify the boundaries of the knob shape. Graphical metadata is used to indicate where to align the knob with other elementary assets. Although the example of shows both graphical metadata and in one layer some embodiments include each graphical metadata in a separate layer. Also as described by reference to above an asset image may include several layers and each layer may have multiple renditions of the asset. In addition an asset may have several layers for different drop shadows and or highlights. For simplicity only shows one layer for each asset image and one layer for graphical metadata of each asset.

The knob layout is aligned with the track layout at rendering time by using the two graphical metadata and . The two geometries in this example the two rectangles and are used to determine how to align the two elementary objects. For instance when the knob is set by the rendering application to a value such as a value between ticks Tand T the value is calculated and the alignment metadata for the knob and the track are used to display the knob at the new place along the track.

The visual boundaries of the knob layout are distinguished from the surrounding objects by using graphical metadata which identifies the visual boundaries of the knob layout . When the knob is displayed at a new position the graphical metadata is used to display the knob at proper location.

The drawing API may center the alignment region of the knob on the alignment region of the track at the new knob position. Also when the knob reaches the maximum and minimum positions e.g. at the left most or right most edges of a horizontal track graphical metadata of the track is used to correctly position the knob layout on the track.

The use of graphical metadata for aligning the elementary assets and identifying the boundaries of the assets has several additional advantages. For instance the visual appearance of the shape of the knob or the track can change in different renditions of the slider asset without affecting the rendering application or the drawing API modules . The drawing API modules can still use graphical metadata and to align the knob and the track. The knob shape can change from e.g. the pointed tip shape to a round shape or the width or thickness of the track can change without a need to make the rendering application or the drawing API aware of the topology of the image as long as the graphical metadata identify the alignment regions and boundaries of the elementary assets.

Furthermore the same GUI is sometimes rendered on display devices such as mobile phones that have different resolutions. In these embodiments the image of the same asset rendered on a high resolution display has a different number of pixels than the image rendered on a low resolution display. In addition since more pixels are available for a high resolution display the asset can be rendered with more details or with a different shape in the high resolution device. Using graphical metadata to identify alignment regions and boundaries of the elementary assets enables the rendering applications to render GUI images on displays of different pixel densities without a need for making the rendering application software code aware of the pixel topology of the image.

The annotating tool includes one or more modules for indicating the logical information such as the state of each elementary asset. The annotating tool is used to add metadata that cannot be included in the asset in a graphical form. For instance for a particular rendition of a checkbox the annotating tool is used to add metadata to specify whether in this particular rendition the checkbox is on off or mixed. The annotating tool is also used to indicate the tint e.g. blue yellow etc. and the state e.g. normal inactive disabled etc. of the checkbox. The output of the annotating tool is stored in the rendition information library .

The distiller tool includes one or more modules which are used to retrieve information from the elementary assets library which includes graphical assets and graphical metadata and from the rendition information library which includes non graphical metadata . The distiller modules in some embodiments analyze the graphical metadata and identify metrics such as the coordinate values for the edges and or corners of metadata. For instance the alignment regions are analyzed and a set of coordinate values for the corners of the alignment regions are derived. The edge identifying regions are also analyzed and a set of coordinate values for the corners of the edge identifying regions are derived.

As described above the distiller tool in some embodiments analyzes the graphical metadata prior to runtime of applications i.e. prior to the rendering time of the GUI . In other embodiments the distiller tool is linked to rendering applications and analyzes the graphical metadata during the runtime of applications .

At rendering time one or more applications which are linked to one or more API modules request certain renditions of the graphical assets to be displayed on the display screen for a graphical user interface. The applications identify where and when to draw the elementary assets. The applications also identify the text if any that has to be displayed on the asset. The API modules use the information stored in the runtime asset database to display the requested asset artwork on the GUI with proper alignment.

In some embodiments the distiller modules directly integrate each image with the associated alignment boundary and other metadata and store them in the runtime asset database or pass them to the API modules at rendering time . In some embodiments the distiller uses the same or similar multi layer image object to store the graphical image of an asset and its associated graphical metadata as the graphics editing tool does. In these embodiments the image and the associated metadata are still packaged together as one entity after being processed by the distiller tool. One advantage of this approach is the information for the asset image and the associated metadata are easily distinguishable throughout the process of asset creation and rendering while the image and its associated metadata are still being stored together as one object and or in one file. Such an approach simplifies retrieving of an asset and identifying the asset s metadata.

In some embodiments the graphic editing tool the annotating tool and the distiller are separate tools in a graphical user interface drawing framework. conceptually illustrates a graphical user interface drawing framework that includes separate graphics editing tool annotating tool and distiller tool . also shows the elementary assets library the rendition information library and the runtime asset database .

As shown a library of API modules is provided that is used by rendering applications to draw the graphical user interface artwork assets. The rendering applications link either dynamically or prior to their runtime to one or more API modules . The API modules use the information in the runtime asset database to display the artwork with proper alignment. In some embodiments the distiller tool is utilized to analyze the graphical metadata prior to runtime of the rendering applications and to store the results in the runtime asset database . In other embodiments the distiller tool is linked to or is invoked by the rendering applications during the runtime of these applications to analyze the graphical metadata. In these embodiments the distiller tool sends the metrics such as the coordinates of the alignments regions to the API modules instead of or in addition to storing the metrics in the runtime asset database .

As shown in process receives at the assets e.g. when the asset is drawn by the GUI designer using the graphics editing tool shown in . Next the process receives the set of graphical metadata associated with each asset. The process receives at the graphical metadata that specify the boundaries i.e. the visual edges and corners of the asset. For instance some assets are drawn with different shading overlays and backgrounds. In some embodiments the boundaries of the assets are identified by a graphical region such as a rectangle or other geometric shapes that tightly encloses the asset. The process receives the metadata e.g. when the graphical metadata is drawn by the GUI designer using the graphics editing tool shown in .

The process then receives at graphical metadata that specify regions for aligning the asset with other assets. For instance in some embodiments control objects such as a slider and its associated track that move against each other include graphical metadata that identify alignment regions for aligning the assets. The process receives the metadata e.g. when the graphical metadata is drawn by the GUI designer using the graphics editing tool shown in .

The process then receives at graphical metadata that specify regions for aligning the asset with the associated text. For instance in some embodiments graphical metadata in the form of a polygon or ellipse are overlaid on an asset to identify the location and or the size of the text that is displayed on the asset at runtime. The process receives the metadata e.g. when the graphical metadata is drawn by the GUI designer using the graphics editing tool shown in . Graphical metadata received in operations are distinguished from non graphical numeric or alphanumeric metadata in that graphical metadata use a graphical shape as opposed to alphanumeric strings or numeric values to visually specify the boundaries the alignment regions or other information for the graphical elements.

The process optionally stores at the asset and the associated graphical metadata in a graphical assets library . In some embodiments such as the embodiment shown in where the graphics editing tool is integrated with other components of the graphical user interface drawing framework the asset and the associated graphical metadata are passed to the other components for further processing with or without storing the assets in the graphical assets library .

Although the graphics editing tool is described as a tool that generates multi layer graphical assets some embodiments include a graphics editing tool that generates the asset artwork in one layer and tags the graphical alignment regions to identify them as graphical metadata. In these embodiments the distiller tool is configured to recognize the graphical metadata tags and analyze them to identify the coordinates of the corners and the edges of the alignment regions.

One of ordinary skill in the art will recognize that process is a conceptual representation of the operations used to generate an artwork asset. The specific operations of process may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Furthermore the process could be implemented using several sub processes or as part of a larger macro process. For instance a particular asset may not have some or all of the disclosed metadata. Similarly some embodiments may support different graphical metadata for the assets.

The above mentioned modules are available to a graphics designer through an input device such as a keyboard and or a mouse and an output device such as a display screen . The importing and exporting module enables the graphics designer to import or export images from to one or more external image libraries . The selection module provides several tools to select all or portions of images for editing.

The editing module provides several tools for the graphics designer to edit and retouch images. The duplicating module allows all or portions of images to be duplicated. The color adjustment module provides tools for color and tonal adjustment to the images. The filtering module allows the graphics designer to apply special effects to the images. The painting module allows changing the color of pixels to create colored areas in the images. The printing module allows the graphics designer to generated printed copy of the images using an output device such as a color printer.

The channel creation and masking module allows the graphics designer to use channels and masks to store color information and manipulate different parts of images. In addition some embodiments designate certain layers such as a channel layer or a mask layer to create graphical metadata to identify the boundaries of graphical assets and to identify alignment regions for aligning elementary assets with other elementary asset and with text. In these embodiments channel layers or mask layers are not used for their intended purpose of storing color information or manipulate different parts of images and are instead used to store graphical metadata.

Finally the layer handling module allows the graphical designer to create a multi layer image. A multi layer image includes designated layers for the asset image that will be rendered on the GUI as well as designated layers for graphical metadata. Such an orthogonal approach partitions the image information in such a way that in one hand the graphical metadata is integrated with the image and on the other hand the graphical metadata is easily identifiable and cannot be confused with the pixels that are part of the rendered image. In some embodiments the output of the graphics editing tool is stored in the elementary assets library . In other embodiments the output of the graphics editing tool is sent to the distiller tool without saving in the elementary assets library.

As shown in process receives at commands and instructions e.g. from a graphics designer or a software programmer to identify the purpose and specifics of different renditions of each elementary asset. The process retrieves at the assets from the elementary assets library shown in . The process generates at non graphical metadata for the elementary assets based on the received commands and instructions to annotate the assets. The process then stores at the information in the rendition information library . Adding alphanumeric metadata through the annotating tool is different from adding graphical metadata to the artwork using a graphics editing tool. The graphical metadata are included as visual indicators in the artwork e.g. by using the same graphics editing tool on which the artwork is designed and while the artwork is designed. On the other hand the alphanumeric metadata using the annotating tool are generated e.g. manually after the artwork design is complete. The use of the annotating tool and the additional alphanumeric metadata is optional in some embodiments.

One of ordinary skill in the art will recognize that process is a conceptual representation of the operations used to annotate the elementary assets with non graphical metadata. The specific operations of process may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Furthermore the process could be implemented using several sub processes or as part of a larger macro process. For instance a particular asset may not have some or all of the disclosed metadata. Similarly some embodiments may support different graphical metadata for the assets.

The alphanumeric metadata generation module receives the graphics designer s commands and instructions through the user interface module . The alphanumeric metadata generation module retrieves different renditions of elementary assets from the elementary assets library generates metadata for the elementary assets as specified by the graphics designer and stores the metadata in the rendition information library .

Otherwise the process analyzes at the graphical metadata and determines metrics such as coordinates of visual edges and or corners of the asset. Next the process determines at whether the asset has associated graphical metadata that specify alignment regions for aligning the asset with other assets. When the asset does not have such metadata the process proceeds to which is described below. Otherwise the process analyzes at the graphical metadata and determines metrics such as coordinates of the edges and or corners of the alignment regions.

Next the process determines at whether the asset has associated metadata that identify the visual edges of the asset. When the asset does not have such metadata the process proceeds to which is described below. Otherwise the process analyzes at the graphical metadata and determines metrics such as coordinates of the edges and or corners of the text alignment regions. Finally the process optionally stores at the asset and the associated metadata including the determined coordinates of different edges and corners of the regions in the runtime asset database . Specifically the process ties up 1 different renditions of elementary assets from the elementary assets library 2 the rendition metadata from the rendition information library and 3 coordinates of the edges and corners of the alignment and edge regions and stores the results in the runtime asset database . In some embodiments the distiller tool stores each elementary asset and its associated metrics such as coordinates of the alignment and boundary regions in one object e.g. a multi layer object and or in one file.

In some embodiments the distiller tool is used before the runtime of applications shown in to generate the runtime asset database . In these embodiments process stores the asset and the associated metadata in the runtime asset library and the rendering applications through their APIs access the runtime asset library during their runtime to display the graphical elements.

In some embodiments the distiller tool is used at the runtime of applications to analyze and determine the coordinates of different regions specified in the graphical metadata. In these embodiments the distiller tool is a part of the runtime framework for executing the applications . In these embodiments the runtime framework receives graphical metadata at runtime and utilizes process to determine the coordinates of the regions specified by the graphical metadata. In some of these embodiments process stores the asset and the associated metadata in the runtime asset library for use by the drawings APIs that are linked to the applications . In other embodiments process passes the coordinate information to the APIs without saving them in the runtime asset library .

One of ordinary skill in the art will recognize that process is a conceptual representation of the operations used to analyze the graphical metadata. The specific operations of process may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Furthermore the process could be implemented using several sub processes or as part of a larger macro process. For instance a particular asset may not have some or all of the disclosed metadata. Similarly some embodiments may support different graphical metadata for the assets.

The graphical metadata retrieval module retrieves assets from the elementary assets library extracts the graphical metadata associated with each asset and passes the graphical metadata to boundary identification module text alignment analyzer module and elementary asset alignment analyzer module . Boundary identification module identifies the graphical metadata that specify the visual boundaries of elementary assets and sends the graphical metadata to the coordinate identification module for identifying the coordinates of the visual boundaries i.e. visual edges or visual corners of the elementary assets.

Text alignment analyzer module identifies the graphical metadata that specify the text alignment regions. The text alignment analyzer module sends the graphical metadata to the coordinate identification module for identifying the coordinates of the text alignment regions.

Elementary asset alignment analyzer module identifies the graphical metadata that specify the elementary asset alignment regions. The text alignment analyzer module sends the graphical metadata to the coordinate identification module for identifying the coordinates of the elementary asset alignment regions.

Coordinate identification module receives a graphical metadata representing a region such as visual boundaries of an elementary asset a text alignment region or an elementary asset to elementary asset alignment region. The coordinate identification module identifies a set of metrics such as the coordinates of the edges and or corners of the received region and saves the coordinates e.g. in a set of tables as coordinate metadata.

Linking module ties up each elementary asset with its associated coordinate metadata as well as non graphical metadata from the rendition information library and save the information in the runtime asset database for use by API modules at rendering time. In the embodiments that the distiller tool is invoked or is linked to rendering applications at the runtime of the applications the output of the liking module is used by the drawing APIs during the runtime of the applications to render the images on a graphical user interface.

As shown in the process receives at a request from an application to draw as asset. In some embodiments the requesting application is linked either at runtime or prior to runtime to one or more modules from the drawing API. In some embodiments the requesting application identifies a specific rendition of each asset as well as the time and location where the asset has to be displayed e.g. display the asset now at the cursor position or at certain coordinates .

The process then retrieves at the requested asset and its associated metadata from the runtime asset database shown in . As described above in some embodiments the distiller tool is a part of runtime framework for rendering the GUI elements. In these embodiments process receives the asset and its associated metadata from the distiller tool instead of the runtime asset database. illustrates an alternative embodiment where the distiller tool is either linked to the rendering application or is invoked at the runtime of the rendering application . As shown in in this embodiment the distiller tool receives graphical metadata at rendering time i.e. while the rendering application is being executed . The distiller tool utilizes a process similar to process to analyze different graphical metadata and to return the coordinates of alignment regions and coordinates of the boundary regions of the elementary assets to the drawing API modules .

Referring back to process then determines at whether the asset has associated boundary identifying metadata. When the asset does not have such metadata the process proceeds to which is described below. Otherwise the process displays at the asset at the requested location using the boundary identifying metadata.

The process then determines at whether the asset has to be aligned with other assets. In some embodiments the process makes the determination based on the type of the asset e.g. when the asset is a slider based on whether the asset overlaps or intersects another assets and or whether the asset includes graphical alignment metadata. When the asset does not require alignment the process proceeds to which is described below. Otherwise when the asset requires alignment with other assets the process displays at the requested rendition of the asset by aligning the asset with other assets using the alignment metadata. If the asset includes edge identifying metadata the process uses the metadata for displaying the asset.

Next the process determines at whether the asset does not have associated text the process exits. Otherwise the process uses the alignment metadata to align the text with the asset. The process then exits.

One of ordinary skill in the art will recognize that process is a conceptual representation of the operations used to generate an artwork asset. The specific operations of process may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Furthermore the process could be implemented using several sub processes or as part of a larger macro process. For instance a particular asset may not have some or all of the disclosed metadata. Similarly some embodiments may support different graphical metadata for the assets.

The rendition selection module receives an identification of a particular rendition of an elementary asset from the rendering application that is linked to the API modules. The rendition selection module also receives other parameters such as the time and location for displaying the asset from the application program. If the elementary asset has an associated text for display the rendition selection module also receives the text from the rendering application. The rendition selection module retrieves information about the particular elementary asset from the runtime asset database and passes the information along with the other parameters received from the rendering application to boundary identification module text to elementary asset alignment module and elementary asset to elementary asset alignment module . In the embodiments that the distiller tool is a part of the runtime rendering framework rendition selection library retrieves the information about the particular elementary asset from the distiller tool not shown in instead of the runtime asset database.

Boundary identification module uses the boundary identification metadata and provides the coordinates of the visual edges and corners of the elementary asset to the drawing module . Text to elementary asset alignment module uses the text alignment metadata and provides the coordinates of the region where the text associated to the elementary asset has to be displayed to the drawing module .

Elementary asset to elementary asset alignment module uses the elementary asset alignment metadata and provides the coordinates of the coordinates of the alignment region of the elementary asset to the drawing module . The drawing module uses the information received from edge identification module text to elementary asset alignment module and elementary asset to elementary asset alignment module and displays the elementary asset with proper alignments. If the elementary asset has associated text the drawing module displays the text using the text alignment metadata.

Many of the above described tools processes methods and functionalities are implemented as software processes that are specified as a set of instructions recorded on a computer readable storage medium also referred to as computer readable medium . When these instructions are executed by one or more computational or processing unit s or element s such as processors or other computational elements like ASICs and FPGAs they cause the computational element s to perform the actions indicated in the instructions. Computer is meant in its broadest sense and can include any electronic device with computational element. Examples of computer readable media include but are not limited to CD ROMs flash drives random access memory RAM chips hard drives erasable programmable read only memories EPROMs electrically erasable programmable read only memories EEPROMs etc. The computer readable media does not include carrier waves and electronic signals passing wirelessly or over wired connections.

In this specification the term software is meant to include firmware residing in read only memory or applications stored in magnetic storage which can be read into memory for processing by a processor. Also in some embodiments multiple software inventions can be implemented as sub parts of a larger program while remaining distinct software inventions. In some embodiments multiple software inventions can also be implemented as separate programs. Finally any combination of separate programs that together implement a software invention described here is within the scope of the invention. In some embodiments the software programs when installed to operate on one or more computer systems define one or more specific machine implementations that execute and perform the operations of the software programs.

The bus collectively represents all system peripheral and chipset buses that support communication among internal devices of the computer system . For instance the bus communicatively connects the processor with the read only memory the system memory and the permanent storage device .

From these various memory units the processor or processing unit retrieves instructions to execute and data to process in order to perform the processes of the invention. In some embodiments the processor comprises a Field Programmable Gate Array FPGA an ASIC or various other electronic components for executing instructions. The read only memory ROM stores static data and instructions that are needed by the processor and other modules of the computer system. The permanent storage device on the other hand is a read and write memory device. This device is a non volatile memory unit that stores instruction and data even when the computer system is off. Some embodiments of the invention use a mass storage device such as a magnetic or optical disk and its corresponding disk drive as the permanent storage device . Some embodiments use one or more removable storage devices flash memory card or memory stick as the permanent storage device.

Like the permanent storage device the system memory is a read and write memory device. However unlike storage device the system memory is a volatile read and write memory such as a random access memory. The system memory stores some of the instructions and data that the processor needs at runtime.

Instructions and or data needed to perform processes of some embodiments are stored in the system memory the permanent storage device the read only memory or any combination of the three. For example the various memory units include instructions for processing multimedia items in accordance with some embodiments. From these various memory units the processor retrieves instructions to execute and data to process in order to execute the processes of some embodiments.

The bus also connects to the input and output devices and . The input devices enable the user to communicate information and select commands to the computer system. The input devices include alphanumeric keyboards and cursor controllers. The output devices display images generated by the computer system. The output devices include printers and display devices such as cathode ray tubes CRT or liquid crystal displays LCD . Finally as shown in bus also couples computer to a network through a network adapter not shown . In this manner the computer can be a part of a network of computers such as a local area network LAN a wide area network WAN or an Intranet or a network of networks such as the Internet .

Any or all of the components of computer system may be used in conjunction with the invention. For instance some or all components of the computer system described with regards to comprise some embodiments of the systems described above. However one of ordinary skill in the art will appreciate that any other system configuration may also be used in conjunction with the invention or components of the invention.

Some embodiments include electronic components such as microprocessors storage and memory that store computer program instructions in a machine readable or computer readable medium alternatively referred to as computer readable storage media machine readable media or machine readable storage media . Some examples of such computer readable media include RAM ROM read only compact discs CD ROM recordable compact discs CD R rewritable compact discs CD RW read only digital versatile discs e.g. DVD ROM dual layer DVD ROM a variety of recordable rewritable DVDs e.g. DVD RAM DVD RW DVD RW etc. flash memory e.g. SD cards mini SD cards micro SD cards etc. magnetic and or solid state hard drives read only and recordable blu ray discs ultra density optical discs any other optical or magnetic media and floppy disks. The computer readable media may store a computer program that is executable by at least one processor and includes sets of instructions for performing various operations. Examples of hardware devices configured to store and execute sets of instructions include but are not limited to application specific integrated circuits ASICs field programmable gate arrays FPGA programmable logic devices PLDs ROM and RAM devices. Examples of computer programs or computer code include machine code such as produced by a compiler and files including higher level code that are executed by a computer an electronic component or a microprocessor using an interpreter.

As used in this specification and any claims of this application the terms computer server processor and memory all refer to electronic or other technological devices. These terms exclude people or groups of people. For the purposes of the specification the terms display or displaying means displaying on an electronic device. As used in this specification and any claims of this application the terms computer readable medium and computer readable media are entirely restricted to tangible physical objects that store information in a form that is readable by a computer. These terms exclude any wireless signals wired download signals and any other ephemeral signals.

While the invention has been described with reference to numerous specific details one of ordinary skill in the art will recognize that the invention can be embodied in other specific forms without departing from the spirit of the invention. Thus one of ordinary skill in the art would understand that the invention is not to be limited by the foregoing illustrative details but rather is to be defined by the appended claims.

