---

title: Generating test sets using intelligent variable selection and test set compaction
abstract: In one embodiment, constructing one or more sets of variables corresponding to one or more input variables of a software module respectively; for each one of the sets of variables, computing an average branching depth that is affected by the set of variables; selecting a first one of the sets of variables that has the smallest average branching depth; assigning a first symbolic value to the input variable of the first set of variables; symbolically executing the software module to generate a first set of test cases for the first set of variables; optionally compacting the first set of test cases by removing the redundant tests that do not increase test coverage and selecting a minimal subset of the first set of test cases that cover all the covered conditional branch points; and validating the software module using the first set of test cases.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08479171&OS=08479171&RS=08479171
owner: Fujitsu Limited
number: 08479171
owner_city: Kawasaki-shi
owner_country: JP
publication_date: 20100524
---
A software application may include any number of modules and each module may be tested or validated individually. A software module may be tested or validated manually or automatically. In the former case a person e.g. a software testing engineer may manually design test cases for the software module based on the design specification of the module execute the module under the test cases and check for module behavior or output that does not agree with the test cases. In the later case a software testing tool implemented as computer software or hardware may automatically generate test cases for a software module under test execute the module under test while simulating the test cases and check for module behavior or output that does not agree with the test cases.

This disclosure is now described in detail with reference to a few embodiments thereof as illustrated in the accompanying drawings. In the following description numerous specific details are set forth in order to provide a thorough understanding of this disclosure. However this disclosure may be practiced without some or all of these specific details. In other instances well known process steps and or structures have not been described in detail in order not to unnecessarily obscure this disclosure. In addition while the disclosure is described in conjunction with the particular embodiments it should be understood that this description is not intended to limit the disclosure to the described embodiments. To the contrary the description is intended to cover alternatives modifications and equivalents as may be included within the spirit and scope of the disclosure as defined by the appended claims.

To test or validate a software module typically test cases are generated for the module based on for example the design specification or other types of requirements e.g. functional behavioral or performance requirements of the module. Thereafter the software module is executed under the test cases and the module s behavior or output is validated against the test cases. In particular embodiments a test case may include a set of input values and information describing the specific test to be performed on the software module in connection with the input values. In particular embodiments the input values may be assigned to the input variables of the software module when the module is being tested. Each input value may be selected to cause the module to respond in some specific manner e.g. providing a specific output value . The test information may describe what specific features of the software module are tested how and under what circumstance the input values are to be applied to the input variables of the software module what is the correct behavior or output value the software module should provide in response to the input values and so on.

Test cases may be generated for a software module either manually e.g. by humans or automatically e.g. by a test case generating tool implemented as computer hardware or software . Often manually generated test cases have relatively poor coverage on different portions of the source code of the software module under test and the actual process of manually generating the test cases is time consuming and costing. On the other hand automatically generated test cases provide better test coverage and requires less time and human effort.

In particular embodiments the input values of the test cases may be obtained by performing symbolic execution on the software module under test. However this method may have some drawbacks. Since symbolic execution is very expensive in terms of CPU time and other types of computer resources it is typically performed on the software module by making only one input variable of the software module symbolic at a time. If a software module has more than one input variables then symbolic execution needs to be performed on the software module multiple times. Furthermore depending on which one of the input variables is symbolically executed first and which one is symbolically executed second the input values obtained from symbolic execution may differ and may provide different test coverage. Second if a software module has a relatively large number of input variables the number of input variables obtained from symbolic execution and thus the number of test cases generated may be very large resulting in a test case explosion which may lead to large regression testing times when the test cases are integrated into for example test suits.

To overcome these drawbacks when performing symbolic execution on a software module that has multiple input variables particular embodiments may intelligently determine the order for symbolically executing the input variables based on the branching depths the input variables affect. In addition once the test cases are generated as a result of symbolic execution particular embodiments may eliminate those test cases that provide duplicate or superfluous test coverage to reduce the number of test cases eventually used to test the software module.

In the field of computer science symbolic execution refers to the analysis of software programs by tracking symbolic rather than actual values as a case of abstract interpretation. It is a non explicit state model checking technique that treats input to software modules as symbol variables. It creates complex mathematical equations or expressions by executing all finite paths in a software module with symbolic variables and then solves the complex equations with a solver typically known as a decision procedure to obtain error scenarios if any. In contrast to explicit state model checking symbolic execution is able to work out all possible input values and all possible use cases of all input variables in the software module under analysis.

Software module foo has two input variables a and b and two intermediate variables c and d . In particular embodiments an intermediate variable of a software module is a variable local to the software module and exists only in the context of the software module. It may also be referred to as a local variable because it only has a local scope and is accessible only from within the software module in which it is declared. The value of an intermediate variable may depend directly or indirectly on the value of one or more input variables of the software module. For example with module foo the value of intermediate variable c depends directly on the values of input variables a and b as indicated by line 3 of the code and the value of intermediate variable d depends indirectly on the values of input variables a and b through intermediate variable c as indicated by line 5 of the code. In addition module foo contains a conditional branching point at line 4 of the code caused by the if else statement. The conditional branching point at line 4 is associated with a branching condition c.equals qrs . Depending on whether this branching condition is satisfied or holds true that is whether intermediate variable c equals qrs module foo proceeds down different execution paths and different portions of the code of module foo is actually executed. More specifically if intermediate variable c does not equal qrs then the value of intermediate variable d is computed and returned as indicated by lines 5 and 6 of the code. On the other hand if intermediate variable c does equal qrs then the value of intermediate variable c is returned as indicated by line 8 of the code.

When symbolic execution is performed on module foo its input and intermediate variables are each assigned a symbolic value instead of an actual value. illustrates an example execution flow representing the steps of performing symbolic execution on module foo . In this example input variable a is assigned symbolic value x input variable b is assigned symbolic value y intermediate variable c is assigned symbolic value z and intermediate variable d is assigned symbolic value w . Since variables a b c and d are of type string symbolic values x y z and w each represent an arbitrary string.

In addition is the symbolic expression that represents the result of the symbolic execution at various points along the execution paths. More specifically at which corresponds to line 2 of the code variables a b c and d are assigned their respective symbolic values x y z and w and initially has an empty or null expression. As the execution proceeds further expressions are added to depending on what code has been executed. At which corresponds to line 3 of the code has the expression z concat x y because line 3 of the code is c a.concat b and x y and z are the symbolic value assigned to variable a b and c respectively. Next line 4 of the code is a conditional branching point and there are two possible execution paths down which the execution may proceed. Thus the symbolic execution may also proceed down two different paths from the first path path includes and corresponding to lines 5 and 6 of the code and the second path path includes corresponding to line 8 of the code.

In order to proceed down path variable c does not equal qrs which means symbolic value z does not equal qrs . Therefore the expression z qrs is added to at . Conversely in order to proceed down path variable c does equal qrs which means symbolic value z equals qrs . Therefore the expression z qrs is added to at . Along path the value of variable d is determined at line 5 of the code which corresponds to . Therefore the expression w concat z t is added to at 108. Note that because z concat x y the expression for w may be rewritten as w concat concat x y t . is the end of path and thus the expression of at represents the conditions in symbolic form that need to be satisfied in order to reach the end of path . Similarly is the end of path and thus expression of at represents the conditions in symbolic form that need to be satisfied in order to reach the end of path .

In particular embodiments solving for the expression of at may provide the actual values for input variables a and b that cause module foo to reach the end of path and solving for the expression of at may provide the actual values for input variables a and b that cause module foo to reach the end of path . In particular embodiments these actual values may then be used as test values that may be assigned to input variables a and b when testing module foo . Since the test values include actual values for input variables a and b that cause module foo to reach both the end of path and the end of path it may be assured that all possible execution paths of module foo are tested if these test values are applied.

As mentioned before since symbolic execution is expensive usually only one input variable is made symbolic at a time and executed symbolically. If a software module has multiple input variables symbolic execution needs to be performed iteratively over all input variables one at a time. The order in which the input variables are chosen to be made symbolic may have a huge impact on the quality of the automatically generated test set in terms of final coverage. For example consider the following code segment 

Suppose a and b are input variables. If input variable a is made symbolic first then performing symbolic execution may result in for example two concrete i.e. actual values for variable a 6 and 4 which correspond to the clause a 5 at line 1. With the concrete values of a being 6 and 4 if b is made symbolic second then two more concrete values for b 1 and 3 may result from performing symbolic execution. The input value pairs for a b 6 1 6 3 4 1 4 3 are guaranteed to cover all possible execution paths through the above code segment.

On the other hand instead of input variable a being made symbolic first suppose input variable b is selected first to be made symbolic. Since during symbolic execution some concrete value needs to be assumed for input variable a a may be assigned a random value. If the value of a is assumed to be less than 5 then symbolic execution will miss the if block at lines 3 and 4 entirely. As result it will not be able to generate any meaningful value for variable b . The final resulting test set will only have the two values of a which are subsequently calculated with some random value generated for input variable b . The resulting test set may look something like a b 6 7 4 7 where 7 is the random value assigned to input variable b . This second test set will result in test input values that provide much worse code coverage than those resulted from the first test set. Consequently the order at which input variables are made symbolic for the purpose of symbolic execution may have huge impact on the level of the final code coverage obtained by the automatically generated test set.

To address this possible problem particular embodiments may intelligently determine the order for symbolically executing the input variables of a software module. illustrates an example method for determining the order for symbolically executing the input variables of a software module and illustrates an example system for determining the order for symbolically executing the input variables of a software module. are described in connection with each other.

In particular embodiments a software module may have any number of input variables and any number of intermediate variables. In particular embodiments the value of each intermediate variable may depend directly or indirectly on the value of at least one input variable. That is a change to the value of an input variable results in a change to the value of an intermediate variable that directly or indirectly depends on the input variable. Of course an intermediate variable may depend on multiple input variables and multiple intermediate variables may depend on the same input variable. Particular embodiments may determine which intermediate variable depends directly or indirectly on which input variable of a software module by performing relevancy analysis on the input variables as illustrated in step of . In particular embodiments step may be performed by component of system illustrated in which takes a software module as input and performs relevancy analysis on the input variables of software module .

In particular embodiments relevancy analysis may compute a set of variables of a software module that is relevant to a set of symbolic variables. Particular embodiments may consider a variable as relevant if it may store a symbolic value given a set of symbolic inputs which is based on the insight that software analysis may be regarded as model checking of abstract interpretation. As a result software analysis enjoys the soundness guarantee from abstract interpretation and the automation advantages from model checking. In particular embodiments the relevancy analysis performed on software module may be based on weighted pushdown model checking techniques. Relevancy analysis is described in more details in U.S. Patent Publication 2010 0223599 A1 filed on 27 Feb. 2009 entitled Efficient Symbolic Execution of Software Using Static Analysis and U.S. Patent Publication 2010 0242029 A1 filed on 19 Mar. 2009 entitled Environment Data Refinement Based on Static Analysis and Symbolic Execution .

Once it has been determined which variable depends on which input variable of the software module particular embodiments may construct a variable set for each input variable as illustrated in step of . The variable set includes the input variable itself and all the intermediate variables that directly or indirectly depend on the input variable according to the result of the relevancy analysis. The number of variable sets thus constructed equals the number of input variables the software module has. Note that an intermediate variable may belong to multiple variable sets since the intermediate variable may depend on multiple input variables.

For each variable set particular embodiments may compute an average branching depth reached by the input and intermediate variables from the set as illustrated in step of . In particular embodiments step may be performed by component of system illustrated in . In particular embodiments the software module may have any number of conditional branching points e.g. if statements and each conditional branching point has a branching condition specified by at least one input or intermediate variable. Depending on whether the branching condition is satisfied the software module may proceed down different execution paths. For example consider the following code segment 

At line 1 there is a conditional branching point and the branching condition is m n kn and k2 . For the branching condition at line 3 to be satisfied the value of variable k needs to be greater than 2. Similarly if the branching condition at line 3 is satisfied then the code at line 4 is executed. Otherwise the code between lines 6 11 is executed. At line 6 there is a third conditional branching point and the branching condition is n k n m which also includes multiple sub conditions e.g. n k and n m . For the branching condition at line 6 to be satisfied the value of variable n needs to equal either the value of variable k or the value of variable m . If the branching condition at line 6 is satisfied then the code at line 7 is executed. Otherwise the code at line 9 is executed.

Furthermore the conditional branching point at line 3 is nested within the conditional branching point at line 1 and the conditional branching point at line 6 is further nested within the conditional branching point at line 3. If the branching condition associated with the conditional branching point at line 1 is not satisfied the conditional branching point at line 3 is never reached during execution of the code. However if the branching condition associated with the conditional branching point at line 3 is not satisfied the conditional branching point at line 6 is reached during execution of the code. In fact in order to reach the conditional branching point at line 6 the branching condition at line 1 needs to be satisfied but the branching condition at line 3 cannot be satisfied

To compute the average branching depth reached by the input and intermediate variables from one of the variable sets for the input variable and each of the intermediate variables from the set particular embodiments may compute a branching depth reached by the input or intermediate variable. Then particular embodiments may average the branching depths computed for all the individual input and intermediate variables to determine the average branching depth for the variable set. To compute the branching depth reached by one of the variables from the variable set particular embodiments may examine each of the conditional branching points in the software module starting from the outmost conditional branching point and gradually proceeding toward the inner nested conditional branching points. If the variable affects the branching condition associated with a conditional branching point then particular embodiments may increment the branching depth of the variable by 1. In the above example code segment the branching condition associated with the conditional branching point at line 1 is affected by variables m n and k because all three variables are involved with the sub conditions that together form the branching condition. On the other hand the branching condition associated with the conditional branching point at line 3 is only affected by variable k because only variable k is involved with the branching condition.

Once the average branching depths have been thus computed for all the variable sets particular embodiments may select the variable set that has the smallest average branching depth as illustrated in step of . If there are multiple variable sets that all have the same smallest average branching depth then particular embodiments may randomly select one of the variable sets that have the smallest average branching depth.

Particular embodiments may perform symbolic execution on the input variable from the selected variable set to generate test cases for the software module as illustrated in step of . In particular embodiments step may be performed by component of system illustrated in which provides as output a set of test cases . As described above in connection with particular embodiments may assign a symbolic value to the input variable from the selected variable set perform symbolic execution on the software module solve for the symbolic expressions e.g. obtained at the end of the different execution paths to obtain actual values for the input variable from the selected variable set which may then be used as test values to be applied to the input variable when the software module is tested. These actual values for the input variable may be used to generate test cases for the software module. Particular embodiments may repeat this process multiple times each time selecting another variable set. For example during the second iteration the variable set that has the second smallest average branching depth may be selected and symbolic execution may be performed on the software module with the input variable from this second variable set having a symbolic value. The actual values may be determined for this input variable based on the result of the symbolic execution. Again if multiple variable sets have the same average branching depth during this iteration one of the variable sets may be selected randomly. During the third iteration the variable set that has the third smallest average branching depth may be selected and symbolic execution may be performed on the software module with the input variable from this third variable set having a symbolic value. And so on until sufficient test cases are obtained for the software module. In other words the variable set that has the smallest average branching depth during each iteration is selected for that iteration and the actual values are determined for the input variable from the selected variable set.

Given a set of test cases generated for a software module either through the process illustrated in or some other suitable means sometimes not all the test cases from the set may provide valuable test coverage on the software module and yet applying all these test cases to test the software module may require a lot of resources e.g. in terms of computer resources . Particular embodiments may examine the coverage value of the individual test cases from the set of test cases and select only a subset of the test cases for testing the software module. illustrates an example method for reducing the size of a set of test cases and illustrates an example system for reducing the size of a set of test cases. are described in connection with each other.

As described above in particular embodiments a software module may have any number of input variables any number of intermediate variables that each directly or indirectly depend on at least one of the input variables and any number of conditional branching points. Each conditional branching point is associated with a branching condition that is affected by at least one of the input or intermediate variables. In particular embodiments for a given input variable all the conditional branching points that have branching conditions that are either affected by the input variable itself or by any intermediate variable that directly or indirectly depends on the input variable is considered to be affected by the input variable. For example suppose intermediate variable j depends on input variable i . Further suppose that one conditional branching point has a branching condition that is affected by input variable i and another conditional branching point has a branching condition that is affected by intermediate variable j . In this case both conditional branching points are considered to be affected by input variable i because intermediate variable j depends on input variable i .

In particular embodiments for the set of test cases each test case from the set may include a combination of actual values that may be applied to the input variables of the software module as test input values during the testing of the software module. For example suppose that a software module has three input variables a b and c of the type integer . Further suppose that it has been determined that input variable a may have actual values 2 and 7 input variable b may have actual values 5 and 11 and input variable c may have actual values 52 9 and 27. From these actual values for the three input variables a set of twelve possible test cases may be generated for the software module because there are twelve unique combinations of the three sets of actual values 

Particular embodiments may analyze a set of test cases generated for a software module as illustrated in step of . In particular embodiments step may be performed by component of system illustrated in which takes as input a set of test cases for analysis and attempts to reduce the size of test case set by removing redundant test cases from test case set .

The individual conditional branching points of the software module are affected by the input variables. That is different actual values assigned to an input variable as testing values may cause the software module to proceed down different execution paths leading from a conditional branching point affected by the input variable. In the above example suppose input variable a affects a conditional branching point cbp1 . From conditional branching point cbp1 the software module may proceed down two different execution paths. More specifically if input variable a is assigned test value 2 software module may proceed down one execution path and if input variable a is assigned test value 7 software module may proceed down another execution path. In this case all the test cases where the value for input variable a is 2 cover the first execution path and there are six such test cases in the above example. Similarly all the test cases where the value for input variable a is 7 cover the second execution path and there are again six such test cases in the above example.

Particular embodiments may construct a graph representing the test values from the set of test cases which may be assigned to the individual input variables and illustrates an example graph constructed for the above example with input variables a b and c . Each edge in graph represents an input variable and each node in graph represents a possible test value for an input variable from the twelve test cases illustrated above. Traversing along different paths of graph eventually leads to different test cases. In particular embodiments such a graph may help identify which test case covers which execution path of the software module. In particular embodiments if there are multiple test cases that cover the same execution path then all but one of the redundant test cases may be removed from the set of test cases as illustrated in step of because the additional test cases do not really provide any additional test coverage for the software module. This may reduce the size of the set of test cases. For example in at nodes and it may be determined that the subsequent branches of graph from nodes and do not provide new test coverage on the execution paths of the software module that are not covered by the test cases at nodes and . Therefore all the test cases below nodes and may be removed from the set of test cases.

Using a graph such as graph illustrated in may not be able to remove all the redundant test cases from the set of test cases. Particular embodiments may further reduce the size of the set of test cases e.g. further perform test set compaction based on a bipartite graph an example of which is illustrated in . In particular embodiments a bipartite graph such as the one illustrated in may be constructed for the test cases and the conditional branches of the software module by component of system illustrated in . In particular embodiments a bipartite graph e.g. bipartite graph may include two parts. One part e.g. represents the remaining test cases from the test case set with each node representing one of the remaining test cases. Another part e.g. represents all the possible conditional branches of the software module with each node representing one of the conditional branches. If a test case covers a conditional branch then a directed edge links the node in part representing the test case to the node in part representing the conditional branch. It is possible that a conditional branch is not covered by any available test case e.g. node by only one test case e.g. node or by multiple test cases e.g. node .

Once a bipartite graph e.g. bipartite graph has thus been constructed particular embodiments may iteratively select the test cases using a greedy algorithm as illustrated in steps and of . In particular embodiments steps and may be performed by component of system illustrated in which provides as output a subset of test cases selected from test case set . Particular embodiments may first select all the essential test cases in the bipartite graph that uniquely cover at least one of the conditional branches as illustrated in step of . That is each of the essential test cases selected is the only test case that covers a particular conditional branch. For example in node represents an essential test case because this test case is the only test case that covers conditional branches represented by nodes and . Similarly node also represents an essential test case. These test cases are selected first. However node does not represent an essential test case because it does not uniquely cover any conditional branch therefore this test case is not selected at this point.

Once all the essential test cases are selected they may be removed from the bipartite graph. Also the conditional branches that the essential test cases cover may be removed from the bipartite graph. Next from the remaining test cases in the bipartite graph particular embodiments may iteratively select the test case that covers the most number of conditional branches one at a time and then remove that selected test case from the bipartite graph until all the conditional branches covered by the available test cases are covered by the selected test cases as illustrated in step of . If there is any conditional branch that is not covered by any available test case e.g. the conditional branch represented by node in then particular embodiments may ignore it for the purpose of the greedy algorithm. Thereafter particular embodiments may test the software module using only the selected test cases as illustrated in step of .

In particular embodiments the components illustrated in may be implemented as computer hardware or software. Particular embodiments may be implemented in a network environment. illustrates an example network environment suitable for providing software validation as a service. Network environment includes a network coupling one or more servers and one or more clients to each other. In particular embodiments network is an intranet an extranet a virtual private network VPN a local area network LAN a wireless LAN WLAN a wide area network WAN a metropolitan area network MAN a portion of the Internet or another network or a combination of two or more such networks . This disclosure contemplates any suitable network .

One or more links couple a server or a client to network . In particular embodiments one or more links each includes one or more wireline wireless or optical links . In particular embodiments one or more links each includes an intranet an extranet a VPN a LAN a WLAN a WAN a MAN a portion of the Internet or another link or a combination of two or more such links . This disclosure contemplates any suitable links coupling servers and clients to network .

In particular embodiments each server may be a unitary server or may be a distributed server spanning multiple computers or multiple datacenters. Servers may be of various types such as for example and without limitation web server news server mail server message server advertising server file server application server exchange server database server or proxy server. In particular embodiments each server may include hardware software or embedded logic components or a combination of two or more such components for carrying out the appropriate functionalities implemented or supported by server . For example a web server is generally capable of hosting websites containing web pages or particular elements of web pages. More specifically a web server may host HTML files or other file types or may dynamically create or constitute files upon a request and communicate them to clients in response to HTTP or other requests from clients . A mail server is generally capable of providing electronic mail services to various clients . A database server is generally capable of providing an interface for managing data stored in one or more data stores.

In particular embodiments one or more data storages may be communicatively linked to one or more severs via one or more links . In particular embodiments data storages may be used to store various types of information. In particular embodiments the information stored in data storages may be organized according to specific data structures. In particular embodiment each data storage may be a relational database. Particular embodiments may provide interfaces that enable servers or clients to manage e.g. retrieve modify add or delete the information stored in data storage .

In particular embodiments each client may be an electronic device including hardware software or embedded logic components or a combination of two or more such components and capable of carrying out the appropriate functionalities implemented or supported by client . For example and without limitation a client may be a desktop computer system a notebook computer system a netbook computer system a handheld electronic device or a mobile telephone. This disclosure contemplates any suitable clients . A client may enable a network user at client to access network . A client may enable its user to communicate with other users at other clients .

A client may have a web browser such as MICROSOFT INTERNET EXPLORER GOOGLE CHROME or MOZILLA FIREFOX and may have one or more add ons plug ins or other extensions such as TOOLBAR or YAHOO TOOLBAR. A user at client may enter a Uniform Resource Locator URL or other address directing the web browser to a server and the web browser may generate a Hyper Text Transfer Protocol HTTP request and communicate the HTTP request to server . Server may accept the HTTP request and communicate to client one or more Hyper Text Markup Language HTML files responsive to the HTTP request. Client may render a web page based on the HTML files from server for presentation to the user. This disclosure contemplates any suitable web page files. As an example and not by way of limitation web pages may render from HTML files Extensible Hyper Text Markup Language XHTML files or Extensible Markup Language XML files according to particular needs. Such pages may also execute scripts such as for example and without limitation those written in JAVASCRIPT JAVA MICROSOFT SILVERLIGHT combinations of markup language and scripts such as AJAX Asynchronous JAVASCRIPT and XML and the like. Herein reference to a web page encompasses one or more corresponding web page files which a browser may use to render the web page and vice versa where appropriate.

Particular embodiments may be implemented on one or more computer systems. illustrates an example computer system . In particular embodiments one or more computer systems perform one or more steps of one or more methods described or illustrated herein. In particular embodiments one or more computer systems provide functionality described or illustrated herein. In particular embodiments software running on one or more computer systems performs one or more steps of one or more methods described or illustrated herein or provides functionality described or illustrated herein. Particular embodiments include one or more portions of one or more computer systems .

This disclosure contemplates any suitable number of computer systems . This disclosure contemplates computer system taking any suitable physical form. As example and not by way of limitation computer system may be an embedded computer system a system on chip SOC a single board computer system SBC such as for example a computer on module COM or system on module SOM a desktop computer system a laptop or notebook computer system an interactive kiosk a mainframe a mesh of computer systems a mobile telephone a personal digital assistant PDA a server or a combination of two or more of these. Where appropriate computer system may include one or more computer systems be unitary or distributed span multiple locations span multiple machines or reside in a cloud which may include one or more cloud components in one or more networks. Where appropriate one or more computer systems may perform without substantial spatial or temporal limitation one or more steps of one or more methods described or illustrated herein. As an example and not by way of limitation one or more computer systems may perform in real time or in batch mode one or more steps of one or more methods described or illustrated herein. One or more computer systems may perform at different times or at different locations one or more steps of one or more methods described or illustrated herein where appropriate.

In particular embodiments computer system includes a processor memory storage an input output I O interface a communication interface and a bus . Although this disclosure describes and illustrates a particular computer system having a particular number of particular components in a particular arrangement this disclosure contemplates any suitable computer system having any suitable number of any suitable components in any suitable arrangement.

In particular embodiments processor includes hardware for executing instructions such as those making up a computer program. As an example and not by way of limitation to execute instructions processor may retrieve or fetch the instructions from an internal register an internal cache memory or storage decode and execute them and then write one or more results to an internal register an internal cache memory or storage . In particular embodiments processor may include one or more internal caches for data instructions or addresses. This disclosure contemplates processor including any suitable number of any suitable internal caches where appropriate. As an example and not by way of limitation processor may include one or more instruction caches one or more data caches and one or more translation lookaside buffers TLBs . Instructions in the instruction caches may be copies of instructions in memory or storage and the instruction caches may speed up retrieval of those instructions by processor . Data in the data caches may be copies of data in memory or storage for instructions executing at processor to operate on the results of previous instructions executed at processor for access by subsequent instructions executing at processor or for writing to memory or storage or other suitable data. The data caches may speed up read or write operations by processor . The TLBs may speed up virtual address translation for processor . In particular embodiments processor may include one or more internal registers for data instructions or addresses. This disclosure contemplates processor including any suitable number of any suitable internal registers where appropriate. Where appropriate processor may include one or more arithmetic logic units ALUs be a multi core processor or include one or more processors . Although this disclosure describes and illustrates a particular processor this disclosure contemplates any suitable processor.

In particular embodiments memory includes main memory for storing instructions for processor to execute or data for processor to operate on. As an example and not by way of limitation computer system may load instructions from storage or another source such as for example another computer system to memory . Processor may then load the instructions from memory to an internal register or internal cache. To execute the instructions processor may retrieve the instructions from the internal register or internal cache and decode them. During or after execution of the instructions processor may write one or more results which may be intermediate or final results to the internal register or internal cache. Processor may then write one or more of those results to memory . In particular embodiments processor executes only instructions in one or more internal registers or internal caches or in memory as opposed to storage or elsewhere and operates only on data in one or more internal registers or internal caches or in memory as opposed to storage or elsewhere . One or more memory buses which may each include an address bus and a data bus may couple processor to memory . Bus may include one or more memory buses as described below. In particular embodiments one or more memory management units MMUs reside between processor and memory and facilitate accesses to memory requested by processor . In particular embodiments memory includes random access memory RAM . This RAM may be volatile memory where appropriate Where appropriate this RAM may be dynamic RAM DRAM or static RAM SRAM . Moreover where appropriate this RAM may be single ported or multi ported RAM. This disclosure contemplates any suitable RAM. Memory may include one or more memories where appropriate. Although this disclosure describes and illustrates particular memory this disclosure contemplates any suitable memory.

In particular embodiments storage includes mass storage for data or instructions. As an example and not by way of limitation storage may include an HDD a floppy disk drive flash memory an optical disc a magneto optical disc magnetic tape or a Universal Serial Bus USB drive or a combination of two or more of these. Storage may include removable or non removable or fixed media where appropriate. Storage may be internal or external to computer system where appropriate. In particular embodiments storage is non volatile solid state memory. In particular embodiments storage includes read only memory ROM . Where appropriate this ROM may be mask programmed ROM programmable ROM PROM erasable PROM EPROM electrically erasable PROM EEPROM electrically alterable ROM EAROM or flash memory or a combination of two or more of these. This disclosure contemplates mass storage taking any suitable physical form. Storage may include one or more storage control units facilitating communication between processor and storage where appropriate. Where appropriate storage may include one or more storages . Although this disclosure describes and illustrates particular storage this disclosure contemplates any suitable storage.

In particular embodiments I O interface includes hardware software or both providing one or more interfaces for communication between computer system and one or more I O devices. Computer system may include one or more of these I O devices where appropriate. One or more of these I O devices may enable communication between a person and computer system . As an example and not by way of limitation an I O device may include a keyboard keypad microphone monitor mouse printer scanner speaker still camera stylus tablet touch screen trackball video camera another suitable I O device or a combination of two or more of these. An I O device may include one or more sensors. This disclosure contemplates any suitable I O devices and any suitable I O interfaces for them. Where appropriate I O interface may include one or more device or software drivers enabling processor to drive one or more of these I O devices. I O interface may include one or more I O interfaces where appropriate. Although this disclosure describes and illustrates a particular I O interface this disclosure contemplates any suitable I O interface.

In particular embodiments communication interface includes hardware software or both providing one or more interfaces for communication such as for example packet based communication between computer system and one or more other computer systems or one or more networks. As an example and not by way of limitation communication interface may include a network interface controller NIC or network adapter for communicating with an Ethernet or other wire based network or a wireless NIC WNIC or wireless adapter for communicating with a wireless network such as a WI FI network. This disclosure contemplates any suitable network and any suitable communication interface for it. As an example and not by way of limitation computer system may communicate with an ad hoc network a personal area network PAN a local area network LAN a wide area network WAN a metropolitan area network MAN or one or more portions of the Internet or a combination of two or more of these. One or more portions of one or more of these networks may be wired or wireless. As an example computer system may communicate with a wireless PAN WPAN such as for example a BLUETOOTH WPAN a WI FI network a WI MAX network a cellular telephone network such as for example a Global System for Mobile Communications GSM network or other suitable wireless network or a combination of two or more of these. Computer system may include any suitable communication interface for any of these networks where appropriate. Communication interface may include one or more communication interfaces where appropriate. Although this disclosure describes and illustrates a particular communication interface this disclosure contemplates any suitable communication interface.

In particular embodiments bus includes hardware software or both coupling components of computer system to each other. As an example and not by way of limitation bus may include an Accelerated Graphics Port AGP or other graphics bus an Enhanced Industry Standard Architecture EISA bus a front side bus FSB a HYPERTRANSPORT HT interconnect an Industry Standard Architecture ISA bus an INFINIBAND interconnect a low pin count LPC bus a memory bus a Micro Channel Architecture MCA bus a Peripheral Component Interconnect PCI bus a PCI Express PCI X bus a serial advanced technology attachment SATA bus a Video Electronics Standards Association local VLB bus or another suitable bus or a combination of two or more of these. Bus may include one or more buses where appropriate. Although this disclosure describes and illustrates a particular bus this disclosure contemplates any suitable bus or interconnect.

Herein reference to a computer readable storage medium encompasses one or more non transitory tangible computer readable storage media possessing structure. As an example and not by way of limitation a computer readable storage medium may include a semiconductor based or other integrated circuit IC such as for example a field programmable gate array FPGA or an application specific IC ASIC a hard disk an HDD a hybrid hard drive HHD an optical disc an optical disc drive ODD a magneto optical disc a magneto optical drive a floppy disk a floppy disk drive FDD magnetic tape a holographic storage medium a solid state drive SSD a RAM drive a SECURE DIGITAL card a SECURE DIGITAL drive or another suitable computer readable storage medium or a combination of two or more of these where appropriate. Herein reference to a computer readable storage medium excludes any medium that is not eligible for patent protection under 35 U.S.C. 101. Herein reference to a computer readable storage medium excludes transitory forms of signal transmission such as a propagating electrical or electromagnetic signal per se to the extent that they are not eligible for patent protection under 35 U.S.C. 101.

This disclosure contemplates one or more computer readable storage media implementing any suitable storage. In particular embodiments a computer readable storage medium implements one or more portions of processor such as for example one or more internal registers or caches one or more portions of memory one or more portions of storage or a combination of these where appropriate. In particular embodiments a computer readable storage medium implements RAM or ROM. In particular embodiments a computer readable storage medium implements volatile or persistent memory. In particular embodiments one or more computer readable storage media embody software. Herein reference to software may encompass one or more applications bytecode one or more computer programs one or more executables one or more instructions logic machine code one or more scripts or source code and vice versa where appropriate. In particular embodiments software includes one or more application programming interfaces APIs . This disclosure contemplates any suitable software written or otherwise expressed in any suitable programming language or combination of programming languages. In particular embodiments software is expressed as source code or object code. In particular embodiments software is expressed in a higher level programming language such as for example C Perl or a suitable extension thereof. In particular embodiments software is expressed in a lower level programming language such as assembly language or machine code . In particular embodiments software is expressed in JAVA. In particular embodiments software is expressed in Hyper Text Markup Language HTML Extensible Markup Language XML or other suitable markup language.

This disclosure encompasses all changes substitutions variations alterations and modifications to the example embodiments herein that a person having ordinary skill in the art would comprehend. Similarly where appropriate the appended claims encompass all changes substitutions variations alterations and modifications to the example embodiments herein that a person having ordinary skill in the art would comprehend.

