---

title: Composition model for cloud-hosted serving applications
abstract: Methods and apparatus for executing an application are disclosed. In accordance with one embodiment, a request is received. One or more of a plurality of module types are instantiated such that a plurality of module objects are generated. A query plan linking the plurality of module objects is executed such that a response to the request is generated. The response is then returned.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09229980&OS=09229980&RS=09229980
owner: Yahoo! Inc.
number: 09229980
owner_city: Sunnyvale
owner_country: US
publication_date: 20100223
---
The present invention relates generally to computer implemented execution of applications using query plans.

Companies typically dedicate enormous resources to implementing software applications. Often companies dedicate a team of programmers to each application being implemented. Moreover each team of programmers typically spends a great deal of time on designing and implementing a particular solution. A desire to create applications to take advantage of modern architectures such as the multi core central processing unit CPU architecture make design and implementation of a solution even more complicated and technically challenging. As a result the development of software applications is typically a costly endeavor.

Methods and apparatus for executing an application are disclosed. In one embodiment an application such as a serving application may include one or more query plans. Each query plan may link a plurality of module objects. Therefore an application may be executed by executing its corresponding query plans.

In accordance with one embodiment a query plan linking a plurality of module objects is generated by instantiating one or more of a plurality of module types wherein the plurality of module types includes a request module type and a response module type. A request is received. The query plan linking the plurality of module objects is executed such that a response to the request is generated. The response is then returned.

In another embodiment a plurality of query plans are generated. For example each of the query plans may be associated with a particular service or server. When a request is received one of the query plans may be selected to process the request. The selection of a query plan may be based upon a variety of factors including a service identified in the request.

The module types may include a request module type a response module type a basic module type an asynchronous module type a branch module type a multibranch module type a fork module type a join module type and or a termination module type. In accordance with one embodiment an instance of the request module type obtains information from the request e.g. via deserialization and the response is formed by an instance of the response module type using the obtained information e.g. via serialization . Each of the module types may comprise a set of computer readable instructions.

In accordance with one aspect a system includes means for instantiating one or more query plans such that each of the query plans links a corresponding plurality of module objects means for instantiating one or more of a plurality of module types such that a plurality of module objects are generated means for receiving a request means for executing one of the query plans linking a corresponding plurality of module objects such that a response to the request is generated and means for returning the response. The system may further include means for identifying one of the query plans to execute in order to generate a response to a particular request.

The system may also provide multi threaded capabilities via a horizontal container. The horizontal container may also have the capability of receiving a request e.g in accordance with a particular protocol as well as forming a response e.g in accordance with a particular protocol . The horizontal container may receive the request from an endpoint and return the response to the endpoint from which the request was received. The horizontal container may be implemented via a set of computer readable instructions.

The system may also include vertical middleware responsible for loading e.g. instantiating query plans and selecting an appropriate query plan to process a request. The vertical middleware may therefore include one or more query plans that have previously been loaded. The vertical middleware may comprise a set of computer readable instructions.

The system may further comprise a cloud that includes a pool of centrally managed hardware. Centralized management and provisioning of the hardware may provide for dynamic on demand provisioning to match the needs of a particular application. The cloud may include a plurality of servers as well as other hardware such as storage devices.

In one embodiment the cloud may communicate one or more endpoints in the cloud to the horizontal container. The horizontal container may communicate one or more endpoint definitions to the middleware where the endpoint definitions are mapped to one or more endpoints in the cloud. Thus the horizontal container may return a response to an endpoint from which a request was previously received by identifying the endpoint mapped to a particular endpoint definition provided by the middleware.

In accordance with one embodiment a system includes a plurality of module types vertical middleware and a horizontal container. The vertical middleware may be configured to instantiate one or more of the plurality of module types such that a plurality of module objects are generated for each query plan identify a query plan to generate a response to a request and execute the identified query plan linking a plurality of module objects. The horizontal container may be configured to receive a request e.g. from a cloud and forward the request to the middleware as well as be configured to receive a response from the middleware and return the response e.g. to the cloud .

In another embodiment the invention pertains to one or more devices each comprising a processor and a memory. The processor s and or memories may be configured to perform one or more of the above described method operations. In another embodiment the invention pertains to a computer readable storage medium having computer program instructions stored thereon that are arranged to perform one or more of the above described method operations.

In accordance with another embodiment the module types vertical middleware and horizontal container may each be implemented via a corresponding set of computer readable instructions. Thus the module types vertical middleware and or horizontal container may be implemented via one or more devices. More particularly the devices may be devices in a cloud.

These and other features and advantages of the present invention will be presented in more detail in the following specification of the invention and the accompanying figures which illustrate by way of example the principles of the invention.

Reference will now be made in detail to specific embodiments of the invention. Examples of these embodiments are illustrated in the accompanying drawings. While the invention will be described in conjunction with these specific embodiments it will be understood that it is not intended to limit the invention to these embodiments. On the contrary it is intended to cover alternatives modifications and equivalents as may be included within the spirit and scope of the invention as defined by the appended claims. In the following description numerous specific details are set forth in order to provide a thorough understanding of the present invention. The present invention may be practiced without some or all of these specific details. In other instances well known process operations have not been described in detail in order not to unnecessarily obscure the present invention.

Systems such as serving systems often have many common design elements. The external entry point for any request is typically a web server. Behind the server are typically a variety of different services that participate in the processing and serving of the request. These services are often performed via a front end server a clustered partitioned set of data servers etc. However despite common design patterns between many systems there is typically little sharing of the building blocks of these systems with each team tending to build their own systems from scratch.

The disclosed embodiments support the use of reusable software components to implement various applications. More particularly the disclosed embodiments may be used to implement a variety of serving systems such as advertising and search systems. For instance the disclosed embodiments may enable a request such as a search query or server request to be processed and a response to be returned using various reusable components. In this manner various applications and algorithms for selecting and providing search results and or one or more advertisements may be implemented in a more efficient manner. Accordingly teams may be freed to focus on their particular application logic and capabilities.

The disclosed embodiments may be implemented using a variety of programming languages. In one embodiment the disclosed embodiments are implemented using an object oriented language such as C . Thus in the following description the terms module object or module will be used to refer to an instance of a particular module type.

The system may also include vertical middleware . The middleware may include software that executes one or more applications which may each be composed of one or more query plans. Each query plan may include a plurality of module objects of various module types that are executed in a specified order. Each of the module objects may be one of a plurality of module types. More particularly a query plan may include module objects of one or more module types. Moreover a query plan may include one or more module objects of a single module type. Various module types will be described in further detail below.

The middleware may load applications upon startup. More particularly the middleware may be responsible for instantiating a query plan and any corresponding module objects. In one embodiment the module objects of the query plan may not be accessed by another query plan. Rather each query plan may have a plurality of module objects that are dedicated to the query plan.

Upon receipt of a request the middleware may select an application or query plan to process the request. The middleware may also be responsible for scheduling one or more query plans during execution.

The system may further include a horizontal container . The horizontal container may include software that is responsible for receiving and propagating external client requests to the middleware as well as propagating responses received from the middleware to clients that initiated the requests. The horizontal container may be implemented using various protocols via an abstract application programming interface API for a protocol driver plugin. The protocol implemented by the horizontal container may provide a request response capability. The horizontal container may provide cluster scatter gather network input output I O where one request may be sent to multiple partitions e.g. servers and the responses aggregated at the container and returned to the client.

In addition the horizontal container may support multi threaded functionality. More particularly multiple distinct requests may be processed in parallel where each of the requests may be processed within a single one of a plurality of threads or in case of a fork or a multibranch module multiple threads can be employed simultaneously in processing a single request. Generally access to a module within a query plan is serialized. However different concurrent requests executed by different threads may execute the same module simultaneously.

In one embodiment information regarding the request may be provided as a context object that contains request data and additional metadata about the request. When the horizontal container receives a request the horizontal container may provide the context object to the vertical middleware . The context object may then be passed as a parameter to and between modules during execution of a query plan.

In one embodiment the system may include one or more APIs and or hardware interfaces for exporting monitoring and metrics data. More particularly an API may enable an application to define a monitoring event generate a variety of monitoring and metrics data and export the monitoring and metrics data to a receiving system for monitoring.

The system may be a serving system that is hosted within a cloud referred to as hosting cloud . A cloud may include a pool of centrally managed hardware. Centralized management and provisioning of the hardware may provide for dynamic on demand provisioning to match the needs of a particular application. Thus a cloud enables the provision of dynamically scalable resources. Often a cloud will include a plurality of servers. At least one of the plurality of servers may function as a web server and or search server. The resources may also be virtualized as a service over the Internet.

The container may serve as an abstraction layer that supports communication between the hosting cloud and the middleware . More particularly the hosting cloud may provision and or modify endpoints within the cloud . For example the endpoints may include one or more network devices such as servers. In order to enable the middleware and upper layers to communicate with the endpoints one or more abstract endpoints i.e endpoint definitions or named endpoints may be provisioned and mapped to the endpoints in the cloud by the container and or the cloud . The container may provide these abstract endpoints to the middleware enabling the middleware to communicate with endpoints in the cloud .

In one embodiment one or more cloud serving engines in the cloud may communicate with the container to provision and or modify endpoints. The container may then provide corresponding abstract endpoints to the middleware enabling the middleware to communicate with the abstract endpoints. This enables the cloud to add replace remove or otherwise modify endpoints without affecting the applications running in the middleware . Therefore dynamic changes to the endpoints and or corresponding abstract endpoints may be made while an application is running without impacting the application.

The horizontal container and or middleware may be independent of communication protocols implemented in the cloud . Thus applications may be written independently of communication protocols. Accordingly applications that are written may be reusable and portable to other systems.

As shown at a request may be received. For instance the request may be received via a web server. Upon receiving the request the middleware may identify a query plan to process the request at . This may be accomplished by identifying one of a plurality of query plans. More particularly upon receipt of a request the server or service being requested may be identified enabling one of a plurality of query plans providing the requested server or service to be identified. The request may then be processed via the identified query plan. In this manner requests directed to a particular server or requesting a particular service may be processed by a corresponding one of a plurality of query plans.

An attribute map may be generated in order to maintain values of attributes that are accessed and or modified during a particular session for the request. The attribute map may be accessed and updated during the session to reflect current values of the attributes.

The identified query plan linking a plurality of module objects may be executed at such that a response to the request is generated. More particularly modules in a query plan are executed in the specified order until the query plan has completed execution or alternatively an error occurs. In one embodiment when an error occurs a terminate module is executed as will be described in further detail below. The response may be returned to an initiator of the request at . For instance the response may be returned via a web server.

A module may include one or more methods e.g. functions or procedures . For example a module may include a run method. In addition the module may include data that is local to the module. The methods of a module and any corresponding attributes e.g. input and or output parameters may be defined by an interface definition.

Each module may be defined by an interface definition. More particularly an interface definition for a module may declare one or more operations e.g. methods that the module will perform. In addition the interface definition for a module may identify a set of one or more attributes that the module e.g. a method of the module will access. More particularly the interface definition may identify the name of each of the attributes the type of the attribute e.g. integer string etc. and or whether the attribute functions as an input and or output parameter. An example module and corresponding interface definition will be described in further detail below with reference to . In one embodiment a module can only access those attributes specified in its interface definition. Therefore input and output dependencies of modules within a query plan may be validated from the corresponding interface declarations. This validation may be performed when a query plan is initially loaded or generated.

Since each query plan communicates with a module via its interface definition the internal functionality of a module may be modified without impacting a query plan calling the module. Moreover since the operations implemented by a module and corresponding attributes are visible a query plan may be easily composed without knowledge of the specific implementation details of the operations of the module.

A plurality of module types may be supported. In order to generate a module of a particular module type an instance of the module type is generated. Thus instantiation of the various module types enables the module types to be reusable. Various examples of module types that may be implemented are described below.

Request A request module may be responsible for processing a request e.g. server request . For instance the request module may perform de serialization associated with the request or data received in association with the request e.g. from a buffer . A query plan may include a single request module.

Response A response module may be responsible for forming a response e.g. server response . In addition the response module may perform serialization of a response and provide the serialized response into a buffer for transport. Typically there is only one response module in a query plan. However some applications may include multiple response modules for forming multiple responses per query.

Basic A basic module may be used for straight line application logic that does not depend upon additional external services e.g. web services . Basic modules may be executed from start to finish through a single call.

Asynchronous An asynchronous module may be used to implement application logic that depends upon external services e.g. web services . Within an asynchronous module one or more network services may be invoked. As responses are received from these services by the horizontal container corresponding callback methods may be invoked by the horizontal container. Thus each asynchronous module may include a callback method that may be called by the horizontal container. When a callback method is invoked the execution of the path in the query plan returns to the point after which the network service was invoked. This may be accomplished by passing the original request or corresponding context object along with a response received from the external service via the callback method.

Branch A branch module may determine during runtime which one of two or more child modules to invoke next thereby providing switch like control flow behavior in the query plan.

Fork A fork module may execute its child modules in parallel on multiple threads such that each of the child modules is executed on a separate one of the threads. Any module that is not a branch module and has more than one child module may be considered to be a fork module.

Multibranch A multibranch module may be used to select one or more of a set of two or more branch modules and to execute the sub branches of each of the selected branch module s in parallel. A multibranch module may prevent specific branch module s from being executed. Similarly a multibranch module may prevent one or more specific sub branches from being executed.

Join A join module may be used to synchronize modules executing simultaneously on independent execution paths. A join module may collect responses generated via the different paths. As each execution path completes it may enter the join module. In one embodiment only one thread per request runs in a join module at a time. By default a join module may wait for all execution paths to complete before continuing to execute the next non parallel module. However a join module can decide whether to wait for additional execution paths to complete. In other words the join module may decide not to wait for all execution paths to complete and implicitly cancel all outstanding execution paths. A join module may occur after a fork module. Therefore the join module may cancel one or more of the pending fork paths that have not yet completed executing.

Since a join module is invoked after multiple parallel paths of execution a join module has an opportunity to resolve any conflicts that might have occurred due to multiple modules modifying the same attribute e.g. output parameter argument . As each execution path enters a join module that join module may select the corresponding output value to keep for the attribute or choose not to keep the value for the attribute.

Termination In the event of an error in the execution of any of the paths a termination module may be executed. The execution of the termination module may enable an error response to be returned. The termination module may be of any type of module. In one embodiment the termination module does not have any child modules.

Module is an example of a fork module which executes modules and in parallel on separate threads. Specifically module is an instance of a Doc Selection module with a parameter prod idx while module is an instance of the Doc Selection module with a parameter rscrch idx. Modules and are both asynchronous modules which are executed via a run method where a corresponding callback method resume may be invoked by the horizontal container when a response is received from an external service.

Module is an example of a join module which may collect responses generated by module and or . Module may cancel the execution of one of the modules or when the other module has completed execution.

Branch module may determine during runtime whether to execute child module or child module . In this example child modules and implement two different ranking models Ranking Model A and Ranking Model B respectively.

A corresponding interface definition for BranchInterface shown as the second parameter of the run method of is shown in . More particularly the interface definition for Branch Interface indicates that the module will access two attributes SelectBranch and Error. The SelectBranch attribute is an input attribute indicated by IN ARG and has a value of data type string. The other attribute Error is an output attribute indicated by OUT ARG and has a value of data type string. Input attributes allow read only operations such as isSelectBranchValid and getSelectBranch in and output attributes allow modification operations such as setError in .

The disclosed embodiments may be implemented in a variety of systems and in a variety of contexts. For example the disclosed embodiments may be used to implement ad serving. Upon receiving a request one of a plurality of advertisements may be selected and returned via a response. As another example the disclosed embodiments may be used to implement searching functionality. Thus a response that is returned to the client may include search results. However these examples are merely illustrative and the disclosed embodiments may be used to implement a variety of systems for a variety of purposes.

The disclosed embodiments may be implemented in any of a wide variety of computing contexts. For example as illustrated in implementations are contemplated in which users interact with a diverse network environment via any type of computer e.g. desktop laptop tablet etc. media computing platforms e.g. cable and satellite set top boxes and digital video recorders handheld computing devices e.g. PDAs cell phones or any other type of computing or communication platform. Such devices may be referred to as clients.

And according to various embodiments input that is processed in accordance with the invention may be obtained using a wide variety of techniques. For example a query such as a search query may be obtained via a graphical user interface from a user s interaction with a local application web site or web based application or service and may be accomplished using any of a variety of well known mechanisms for obtaining information from a user. However it should be understood that such methods of obtaining input from a user are merely examples and that a query such as a search query may be obtained in many other ways.

Responses such as search results and or advertisements may be processed selected and or returned in response to a request according to the disclosed embodiments in some centralized manner. This is represented in by server and data store which as will be understood may correspond to multiple distributed devices e.g. one or more servers and one or more data stores. The servers may include a search server and or web server. The invention may also be practiced in a wide variety of network environments represented by network including for example TCP IP based networks telecommunications networks wireless networks etc. The network may take any suitable form such as a wide area network or Internet and or one or more local area networks LAN s . The network may include any suitable number and type of devices e.g. servers and or storage devices as well as routers and or switches for forwarding requests such as search or web object requests from each client to the application e.g. search or web application and for forwarding responses such as search or web results back to the requesting clients.

A query such as a search query may be processed or executed via one or more applications such as search applications e.g. associated with a search server and or web server and or one or more data sources. Embodiments of the present invention may be employed with respect to any application such as a search application. The application may be implemented by executing a query plan on any number of servers.

Embodiments disclosed herein may be implemented via one or more servers and or clients. For example various features may be implemented via a web browser and or application on the clients. The disclosed embodiments may be implemented via software and or hardware.

In addition the computer program instructions with which embodiments of the invention are implemented may be stored in any type of computer readable media and may be executed according to a variety of computing models including a client server model a peer to peer model on a stand alone computing device or according to a distributed computing model in which various of the functionalities described herein may be effected or employed at different locations.

The disclosed techniques of the present invention may be implemented in any suitable combination of software and or hardware system such as a web based server or desktop computer system. Moreover a system implementing various embodiments of the invention may include a portable device such as a laptop or cell phone. The embodiments of this invention may be specially constructed for the required purposes or it may be a general purpose computer selectively activated or reconfigured by a computer program and or data structure stored in the computer. The processes presented herein are not inherently related to any particular computer or other apparatus. In particular various general purpose machines may be used with programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required method steps.

Regardless of the system s configuration it may employ one or more memories or memory modules configured to store data program instructions for the general purpose processing operations and or the inventive techniques described herein. The program instructions may control the operation of an operating system and or one or more applications for example. The memory or memories may also be configured to store instructions for performing the disclosed methods as well as query plans module types modules etc.

Because such information and program instructions may be employed to implement the systems methods described herein the present invention relates to machine readable media that include program instructions state information etc. for performing various operations described herein. Examples of machine readable media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROM disks magneto optical media such as floptical disks and hardware devices that are specially configured to store and perform program instructions such as read only memory devices ROM and random access memory RAM . Examples of program instructions include both machine code such as produced by a compiler and files containing higher level code that may be executed by the computer using an interpreter.

CPU may also be coupled to an interface that connects to one or more input output devices such as such as video monitors track balls mice keyboards microphones touch sensitive displays transducer card readers magnetic or paper tape readers tablets styluses voice or handwriting recognizers or other well known input devices such as of course other computers. Finally CPU optionally may be coupled to an external device such as a database or a computer or telecommunications network using an external connection as shown generally at . With such a connection it is contemplated that the CPU might receive information from the network or might output information to the network in the course of performing the method steps described herein.

Although the foregoing invention has been described in some detail for purposes of clarity of understanding it will be apparent that certain changes and modifications may be practiced within the scope of the appended claims. Therefore the present embodiments are to be considered as illustrative and not restrictive and the invention is not to be limited to the details given herein but may be modified within the scope and equivalents of the appended claims.

