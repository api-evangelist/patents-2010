---

title: Context-based routing in multi-hop networks
abstract: Context-based routing in multi-hop networks involves using a context-based routing metric. In a described implementation, respective path values are calculated for respective ones of multiple paths using the context-based routing metric. A path is selected from the multiple paths responsive to the calculated path values. Data is transmitted over at least one link of the selected path. In an example embodiment, the context-based routing metric is ascertained responsive to an estimated service interval (ESI) of a bottleneck link of each path of the multiple paths. In another example embodiment, the context-based routing metric is ascertained responsive to an expected resource consumption (ERC) metric. In an example embodiment of path selection, the path is selected using a context-based path pruning (CPP) technique that involves maintaining multiple local contexts at each intermediate node, with each local context representing at least one partial path.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08214526&OS=08214526&RS=08214526
owner: Microsoft Corporation
number: 08214526
owner_city: Redmond
owner_country: US
publication_date: 20100129
---
This U.S. Non provisional Application for Letters Patent is a continuation of and claims the benefit of priority to U.S. patent application Ser. No. 11 745 340 filed on May 7 2007 the disclosure of which is incorporated by reference herein.

Some networks including some wireless networks are pre planned and centrally controlled. A single provider can organize the network nodes and installs the infrastructure. Operationally a centralized entity has a wealth of knowledge about various network characteristics. Consequently a routing between two communication participants at different network nodes may be pre planned and centrally controlled.

On the other hand ad hoc networks including wireless ad hoc networks do not usually involve significant pre planning or centralized control. One or perhaps a few network nodes are often established by different individuals. These individuals activate their respective network nodes which are designed to automatically interoperate with other network nodes that are established by other individuals. Even without pre planning or centralized control operation of these ad hoc networks still entails routing connections for communication participants between two network nodes. Mechanisms and techniques for effectively determining efficient routings can involve considering and sharing parameters across many network nodes as well as appropriately balancing a multitude of factors.

Context based routing in multi hop networks involves using a context based routing metric. In a described implementation respective path values are calculated for respective ones of multiple paths using the context based routing metric. A path is selected from the multiple paths responsive to the calculated path values. Data is transmitted over at least one link of the selected path. In an example embodiment the context based routing metric is ascertained responsive to an estimated service interval ESI of a bottleneck link of each path of the multiple paths. In another example embodiment the context based routing metric is ascertained responsive to an expected resource consumption ERC metric. In an example embodiment of path selection the path is selected using a context based path pruning CPP technique that involves maintaining multiple local contexts at each intermediate node with each local context representing at least one partial path.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. Moreover other method system scheme apparatus device media procedure API arrangement etc. implementations are described herein.

A fundamental problem in multi hop wireless networks is routing e.g. moving packets from a source node to a destination node. Routing protocols have traditionally been based on finding shortest cheapest paths under certain cost metrics. A conventional routing metric models the cost of a path as the sum of the costs on the constituting links where the cost of a link typically reflects the link quality in one way or another e.g. loss rate supported bit rate delay etc. . The routing system then aims at finding the path offering the lowest total cost.

However such common practice is not adequate for all scenarios especially as new wireless technologies appear in the lower layers of the networking stack. For example a promising technique for improving the capacity of mesh networks is to use multiple radios. With multiple radios a device can transmit and receive at the same time including on different radio interfaces. The radio spectrum can therefore potentially be utilized more efficiently because more concurrent communications can be packed in spectrum space and time when using multiple radios. Hence multiple radios open up new opportunities for high throughput wireless communications. A key challenge towards unleashing the potential of multiple radios in wireless mesh networks is interference aware routing. Example implementations for a self interference aware routing protocol for multi radio wireless mesh networks are described herein.

To model the self interference of the links on a path a Self Interference aware routing Metric SIM is described. It is a context based metric in that the cost of a link depends on what other e.g. previous links are used in the route. The cross coupling of the links in a context based metric renders it challenging to find the minimum cost route. In particular a direct application of Dijkstra s shortest path algorithm fails to incorporate the impact of past decisions on the future parts of the route. Hence a context based path pruning CPP method is also described. The CPP method prunes suboptimal partial paths based on fixed length contexts as it explores the path space.

Thus implementations of the described interference aware approach involve two synergistic building blocks 1 a context based path metric the SIM that properly models the link interdependencies and 2 an efficient algorithm the CPP method for route optimization under the context based path metric. Together they constitute an instance of a general context based routing paradigm which is applicable to scenarios where modeling the interactions between different links is relevant to performance. Other applications of this paradigm for wired and wireless networks are also described herein below.

Another example is local mixing a recent link layer advance that exploits the broadcast nature of the wireless medium. The local mixing engine may reside between the routing and media access control MAC layers. It maintains information about the packets each neighbor has and identifies opportunities to mix the outgoing packets via network coding to reduce the e.g. number of transmissions in the air. Local mixing on its own can improve the link layer efficiency. The gain of this technique however depends on the traffic pattern in the network and hence the routing decisions. An implementation that is described herein involves a routing method based on a Markovian metric that can find routes that are likely to have more mixing opportunities.

This Markovian metric models the cost of a path as the cost of the first hop plus the cost of the second hop conditioned on the first hop and so on. A Markovian metric is used to model the reduction of channel resource consumption due to local mixing. This leads to routing decisions that can better take advantage of local mixing opportunities. Throughput gains and resource savings can be achieved by applying the Markovian metric to facilitate local mixing.

The description that follows is divided into two major sections Example Implementations for Context Based Routing in Multi Radio Mesh Networks and Example Implementations for Routing with a Markovian Metric to Promote Local Mixing . Certain realizations of the latter may be considered as specific implementations of the former including optionally with wireless nodes having only one radio. The principles described herein may also be applied to other networks having multiple links originating and terminating at different nodes.

Generally context based routing in multi hop networks may be implemented in many different network types and topologies. However an example network is illustrated in and described below.

Each network node may be in communication with one or more other network nodes via at least one network communications link some of which are explicitly denoted in . Each link may be a wired link or a wireless link. A path is shown between network node and network node path extends through network nodes and . Although the illustrated path includes three links a path may be more generally comprised of any two or more links .

To enable wireless communication one or more network nodes may be realized as a wireless network node . Each wireless node includes at least one radio . Two radios and are specifically shown. However each wireless node may have r radios in which r represents some positive integer 1 2 3 4 . . . r.

Each radio enables a wireless network node to communicate on a wireless channel. Each radio is typically capable of communicating via one or more wireless links in accordance with at least one wireless standard. Example wireless standards include but are not limited to IEEE 802.11 standards IEEE 802.16 standards IEEE 802.22 standards UWB and so forth. By way of example only multiple such wireless network nodes may form a wireless ad hoc mesh network.

As introduced above a promising technology for improving the capacity of wireless mesh networks is to use multiple radios at each node. With multiple radios a device can transmit and receive at the same time including on different radio interfaces. The radio spectrum can also be utilized more efficiently because more concurrent communications can be packed in spectrum space and time. However maximizing the benefit of multiple radios calls for intelligent routing decisions that are aware of multiple radios and can take advantage of them. In particular routes that contain low interference among the constituting links are chosen.

Generally example implementations for Context based Routing Protocol CRP for interference aware routing in multi radio networks are described herein. CRP addresses some open issues and challenges on this problem. In a described implementation CRP has two principle components 1 a new path metric the SIM and 2 a novel context based path selection technique the CPP method .

One aspect of the first component the SIM metric is that it is context dependent. In other words it assesses the cost of each link in the context of previous hops for the path under consideration. As described further herein below the SIM metric is a weighted sum of the estimated transmission time ETT and the maximum expected service interval ESI at the bottleneck link. Similar to how the long term throughput of a pipelining system is determined by the bottleneck component the long term throughput of a wireless route is determined by the bottleneck link. Herein below we show that the maximum ESI term can be interpreted as an ideally achievable throughput assuming perfect scheduling.

Because the SIM metric is context dependent a direct application of the Dijkstra s shortest path algorithm may lead to rather suboptimal paths. The reason is that Dijkstra s algorithm operates on an optimality principle The shortest path from s to t via v is the shortest path from s to v concatenated with the shortest path from v to t. Such an optimality principle no longer holds for a context based metric. In response to this situation the second component of CRP is a general context based path pruning method CPP for discovering good paths using a context based metric. To model the context of a partial path while avoiding the exponential growth in the number of partial paths CPP maintains a set of paths that reach each node v corresponding to different local contexts. Each local context can be viewed as a concise summary of the dominating history of all the partial paths that end with that local context based on the observation that older history usually has less impact on the future. The current best path under each local context is maintained and considered further for possible expansion into an s t path.

In short implementing the interference aware routing approach of CRP involves i properly modeling the link interdependencies e.g. via the SIM metric and ii handling the ensuing algorithmic challenges in route optimization e.g. via the CPP method . The use of local contexts in pruning is synergistic with the use of contexts in cost modeling. Together they present a general context based routing paradigm which is applicable in scenarios where modeling link interdependencies is relevant.

Context based routing metric ascertainer ascertains a context based routing metric such as a SIM metric a Markovian metric e.g. ERC and so forth. Path value calculator calculates a value for a given path under a selected context based routing metric. Context based routing metric ascertainer and path value calculator for example may cooperatively interact in the performance of their functions. The calculated values for different paths may be compared in order to select a preferred path.

Path selector selects a preferred path responsive to the calculated values for multiple potential paths. Path selector may implement for example a context based path pruning CPP technique as described herein. Path value calculator and path selector for example may cooperatively interact in the performance of their functions. Once a path has been selected or at least a first link of a selected path has been determined data for a communication may be transmitted by data transmitter using a radio .

In a described implementation starting at block a context based routing metric is ascertained. At block respective path values for respective paths of multiple paths are calculated using the context based routing metric. Example implementations for the actions of blocks and are described herein below in Section 2 which is entitled Self Interference Aware Routing Metric .

At block a path from the multiple paths is selected responsive to the calculated path values using a context based path pruning technique. Example implementations for the actions of block are described herein below in Section 3 which is entitled Context Based Path Pruning . It should be understood that a final path value associated with and representing the cost of a given path as well as a final path selection may be achieved gradually under a described implementation of CPP. At block data is transmitted over at least one link of the selected path toward the ultimate destination of the data.

For an example implementation we describe in this section a first component of CRP the self interference aware metric SIM . By way of example only we address a multi hop wireless network equipped with multiple radios. Without loss of generality we assume that each radio is tuned to a fixed channel for an extended duration and that a route specifies the interfaces to be traversed.

We define the SIM metric as a weighted sum of two terms the expected transmission time ETT and the expected service interval ESI . An example equation version of the SIM metric is presented below as equation M0 with M denoting a multi radio embodiment 

A sub optimal routing is shown in network topology b . With network topology b primary interference occurs when two adjacent nodes transmit on the same channel and secondary interference occurs when two nodes that are separated by only one intervening or intermediate node transmit on the same channel. An example superior if not optimal routing is shown in network topology c . Any two nodes that are communicating on the same channel for the illustrated path are thus maximally separated. Using the SIM metric the path in c exhibits a lower cost than the path in b . Hence SIM allows us to distinguish these two paths.

In a described implementation the first term for the SIM metric is the sum of the ETT along the route. The ETT metric aims at estimating the average transmission time for sending a unit amount of data. It may be defined as indicated in equation M1 below 

For equation M1 the ETX metric estimates the number of transmissions including retransmissions needed to send a unicast packet across a link. It is computed as

In a described implementation the second term is the estimated service interval ESI at the bottleneck link. This variable therefore reflects how fast the route can send packets in the absence of contending traffic. The max operation is used here instead of the sum operation. This can be explained by a pipeline analogy. In a pipeline system including several processing stages the long term throughput is determined by that of the bottleneck stage instead of the average throughput of the stages. Sending packets along a wireless route is similar or analogous. Thus the long term throughput of a flow is determined by that of the bottleneck link.

Characterizing the interference relations among the links can be challenging. One method is to make use of actual interference measurements. Consider two links A B and C D using the same channel. There are four primary forms of interference i C can sense A s transmission via physical or virtual carrier sensing and hence refrains from accessing the medium ii A can sense C s transmission iii transmissions of A and C collide in D and iv transmissions of A and C collide in B. Based on this we adopt without loss of generality a simplified approach for the description herein We treat the two links as interfering if A has a link to C or D with sufficiently good quality or C has a link to A or B with sufficiently good quality.

The ESI expression of equation M2 leaves out the interference caused by other contending traffic. This is a simplification in modeling hence the interference caused by other contending traffic may alternatively be incorporated into an implementation. The ESI expression M2 considers the self interference from the previous hops of the route by adding up the expected transmission times of the previous links. The intuition is that the packets at the link need to share the channel with the interfering links on the route.

It is possible to also add the ETTs from the subsequent links on the path as well as from the previous links because both previous and subsequent links can create interference. Although this approach can alternatively be adopted the following theorem explains why it is not adopted herein.

Theorem 1 Interpretation of Bottleneck ESI Assuming ideal scheduling sufficiently long flow absence of contending traffic and an ideal binary interference model dictated by a conflict graph the end to end throughput of 1 maxESI e is achievable.

Proof of Theorem 1 Under the assumptions in the theorem s claim finding the optimal end to end throughput essentially amounts to finding an optimal interference free scheduling of the uses of the constituting links. If we can schedule each link to transfer B bits in T seconds then the throughput BIT can be achieved. It is well known that this problem can be viewed as a continuous version of the graph coloring problem on the conflict graph.

In greedy coloring algorithms nodes in a graph are visited one by one. Each node tries to reuse some existing colors if possible. If not the node selects a new color. With this procedure it is easy to see that the graph can be colored in U 1 colors where U is the maximum degree of a vertex. The greedy coloring algorithm always looks at the already colored nodes but not future nodes. Hence in fact the upper bound can be tightened to one plus the maximum number of already colored neighbors for the nodes.

We now apply a greedy coloring like algorithm for scheduling the links on a route. This is illustrated in for a path with 6 links eto e. is a block diagram of an example interference free scheduling of six links with regard to an estimated service interval ESI at a bottleneck link. We visit the links on the route sequentially from the first hop to the last hop. For each link e find one or more intervals with a total length of ETT e . Similarly to greedy coloring when assigning the intervals to a link we only need to examine the previous links but not future links. With this greedy scheduling process we can finish the assignment in a total duration of maxESI e . If we repeat this scheduling pattern for a sufficiently long time then we can deliver one packet end to end every maxESI e sec . Hence the throughput is achievable.

The Theorem 1 above shows that the bottleneck ESI corresponds to a theoretically achievable throughput. Conversely if a link einterferes with a set of previous links then typically links in e would be expected to mutually interfere hence forming a clique in the conflict graph . If that indeed is the case then we cannot deliver more than one packet end to end every maxESI e sec . Thus this relatively non rigorous argument shows that the maximum throughput is roughly around maxESI e .

In an example implementation as described above we assumed without loss of generality that each radio interface is tuned to a fixed channel for an extended time duration. This is referred to herein as a static channel assignment.

However there are alternative system models for using multiple radios in which each node has at least two radios. By way of example only for each node some of its radio interfaces are fixed at certain channels and the remaining are tunable. To send a packet to a node v a node tunes one of its tunable interfaces to one of node v s fixed interfaces. This model is referred to herein as a semi static channel assignment. Under the semi static model to specify a route we can specify the sequence of receiving interfaces e.g. via their IP addresses etc. . The ESI metric can therefore also be applied to the semi static model with essentially no changes.

In this section we describe example implementations of a second component of CRP the CPP path selection algorithm. In addition to defining a good path metric another challenge is to find the optimal or near optimal or at least superior route under a given path metric. As a starting point we first consider a link state routing framework. In link state routing each router measures the cost to each of its neighbors constructs a packet including these measurements sends it to all other routers and computes the shortest paths locally. A centralized algorithm for computing the shortest paths may therefore be adopted with link state routing. However the CPP method can also be applied in some other distributed settings. Examples of other settings and protocols are described herein below in Section 3.2 which is entitled Applying CPP to Other Protocols .

The relatively simpler problem of finding the optimal path under a decomposable path metric is described first by way of review. In a decomposable path metric each link has a nonnegative cost and the cost of a path is the sum of the costs of the constituting links. This problem is well understood. For example the classical shortest path algorithm by Dijkstra can be applied to find the optimal path with complexity O V where V denotes the number of nodes in the network.

Dijkstra s algorithm maintains upper bound labels f v on the lengths of minimum cost s v paths for all v V. The label of each node is either temporary or permanent throughout the execution of the algorithm. At each iteration a temporary label with least total cost is made permanent and the remaining temporary labels are updated. Specifically if v has the minimum total cost among the temporary nodes then we update the cost of every other temporary node w using equation M3 below min . M3 

In contrast the SIM metric is history dependent. As a result finding the shortest path under the SIM metric is a new challenge. For example a direct application of the Dijkstra s shortest path algorithm may lead to highly suboptimal paths with the history dependent SIM metric. Consider the example shown in .

The reason that Dijkstra s algorithm returns a suboptimal route is that it operates on an optimality principle The shortest path from s to t via v is the shortest path from s to v concatenated with the shortest path from v to t. Consequently each node only needs to remember the cost of the best s v path. Such an optimality principle no longer holds for a metric such as SIM instead an s v path Pmay have a larger cost than an s v path Pbut still eventually lead to a lower overall cost toward the final destination node t.

We describe herein example implementations of a context based path pruning CPP technique. It can be applied as a heuristic method for optimizing a context based metric. To model the potential impact of past hops on future hops we maintain a set of paths that reach each node v instead of a single s v path having minimum cost . Thus a set of partial paths that reach each intermediate node as the partial paths are extended link by link toward a destination node are maintained.

An issue that arises is How many paths should we store at each node as we search for a good s t path Storing all paths would apparently result in an exponential complexity. To keep the complexity manageable we constrain the amount of memory at each node. It is observed that the effect of self interference has a localized nature. Normally given what happened in the recent past i.e. the first few previous hops the older history is unlikely to have a significant impact on the future.

This observation motivates us to organize the memory at each node according to several local contexts. Each local context can be viewed as a concise summary of the dominating history of all the partial paths that end with that local context based on the observation that older history usually has less impact on the future. During an execution of a CPP algorithm each node stores the current best during the execution of the algorithm path under each possible local context. The current best paths that are stored are considered further for potential expansion into an s t path.

The local contexts can be defined in a number of manners. For example we can define the local context of a path as the sequence of links in the last l hops. As another example we can define the local context of a path as the sequence of channels taken by the links in the last l hops. Either of these definitions can provide reasonable summaries of the past that would impact the future. Other local context definitions can alternatively be adopted.

In a described implementation a CPP method can be performed using a Dijkstra style instantiation. Algorithm 1 shows such an example Dijkstra style instantiation of a CPP method. A pseudo code version of an example CPP method is thus provided below as Algorithm 1.

With respect to the pseudo code in Algorithm 1 above we maintain a set T of temporary paths and a set P of permanent paths. In each step we choose the temporary path with minimum cost. Such a path say is made permanent. Then we consider the possible ways of extending toward an s t path. For each extension e we determine its local context and search for a path with the same local context in T and P. If a path with the same local context already exists then such an existing path is compared with and the winner is retained. If a path with the same local context does not exist then is added to T.

In a described implementation starting at block a minimum cost path is selected from a set of temporary paths. At block the sets of temporary paths and permanent paths are updated. For example the selected path may be removed from the set of temporary paths and the selected path may be added to the set of permanent paths. At block the selected minimum cost path is extended by a link to create a valid extended path. At block the local context of the valid extended path is ascertained using a predetermined function.

At block it is determined if any path from the set of temporary paths or the set of permanent paths is associated with the same ascertained local context. If not if there are no others with the same local context then at block the valid extended path is added to the set of temporary paths.

If there is a path with the same local context as determined at block then at block it is determined if the cost of the valid extended path is less than the path with the same ascertained local context. If so then at block the path having the same local context is replaced with the valid extended path. If not then the minimum cost path is extended by a different link at block . The minimum cost path is also extended by a different link at block after blocks and . Although not specifically indicated in flow diagram may be repeated from block until the set of temporary paths is empty.

An alternative approach to understanding and implementing a CPP method is described below. For each physical node v we introduce one vertex vfor each local context c that is applicable to v and we interconnect the vertices according to the original connectivity. We denote such a context expanded graph by G. Algorithm 1 can be interpreted as applying the Dijkstra s algorithm to the expanded graph Gto find a shortest path tree in G.

When employing path metrics such as SIM that are not decomposable the cost update step needs to be revised. Instead of using equation M3 above node v first reconstructs the current best path from the source say

We now illustrate this context expanded graph using an example four node scenario as shown in which is a graphical depiction of an example four node network topology having up to three orthogonal channels to illustrate a context based path pruning technique. These four nodes are labeled A B C and D. There are three orthogonal links from A to B two orthogonal links from B to C and one link from C to D. The channel numbers CH are shown above the link and the ETT metrics are shown below the links. For the sake of clarity consider 0.5 and the simplified interference model noted above in Section 2.2 ESI of the Bottleneck Link . In this example Dijkstra s algorithm using equation M4 for non decomposable path metrics returns A CH1 B CH2 C CH1 D with a total cost of 2.55.

To connect Algorithm 1 with running Dijkstra s algorithm with equation M4 over the expanded graph we can view each node as storing the current best path with which it is reached from the source. The current best path can be obtained by backtracking along the best links that reach each node. With a one hop based local context as shown in the route found is A CH2 B CH1 C CH1 D with a total cost of 2.5.

If the path metric indeed has a fixed memory span say 1 hop then a CPP technique with the local context defined by the 1 hop links is guaranteed to find the optimal solution because no pruning step is suboptimal . Other metrics however may have a longer memory span. The SIM path metric for example has a memory span that can potentially involve the entire path history. Nevertheless even if a selected path metric has a longer memory span than the length of the local contexts the CPP method can still be applied as an effective heuristic method.

As noted above Algorithm 1 can be essentially viewed as applying Dijkstra s algorithm with equation M4 over the expanded graph. With Algorithm 1 however the involved vertices and links are constructed on the fly without explicitly maintaining the expanded graph. Due to the connection between Algorithm 1 and Dijkstra s algorithm we can easily conclude that the time complexity of Algorithm 1 is O C where C is the total number of local contexts at all nodes.

If we define the local context of a path as the sequence of channels taken by the links in the last l hops then C is upper bounded by K K . . . K V G where K is the number of channels in the system and V G is the set of nodes in the original network. Although other values of l may be adopted for an example practical implementation with current hardware software processing technologies we specifically propose to use l 2. For this example l 2 leads to a specific complexity that is given by equation M5 below . M5 

The CPP method is a general method to efficiently explore the path space. It can also be applied to other scenarios in other settings including but not limited to distance vector protocols on demand route discovery and so forth.

First we describe how CPP can be implemented in a framework based on the Bellman Ford shortest path algorithm. The Bellman Ford algorithm maintains for each node v first the minimum cost s v path with 0 interior nodes then the minimum cost s v path with 1 interior node then the minimum cost s v path with 2 interior nodes and so on. Similar to what is described above for Dijkstra s method to use the CPP method we essentially can run the Bellman Ford algorithm over the context expanded graph G. Specifically we maintain a set Qof paths. For k 1 to V G 2 we consider the paths in the Qset one by one. For each path in consideration we examine all possible paths obtained by extending by one more hop. For each extended path e we then check if there exists a path Q in the current set with the same local context. If not the extended path is inserted into the set otherwise the path is compared with the existing path Q and the better is retained.

The practical counterpart of Bellman Ford s algorithm is the distance vector protocol e.g. DSDV . Originally each router maintains a table i.e. a vector giving the best known cost to reach each destination and the associated interface s . Tables are updated by exchanging information with neighbor nodes. To adapt to our current context expanded graph scenario first we construct the context expanded graph in a reverse manner.

CPP can also be applied to on demand route discovery protocols including but not limited to dynamic source routing DSR DSR with ETX and so forth. In DSR a source node broadcasts route request packets to discover routes to a destination. When a node forwards a route request it appends its address and the related link costs. To implement CPP in DSR when a node receives a request it has already forwarded it forwards it again if the path cost to a neighbor v is better than the best which it has already forwarded with the same local context.

Context based routing may be implemented in applications that extend beyond self interference aware routing. In this section alternative implementations and applications of context based routing are described.

Network Coding Network coding has been proposed as a link layer enhancement technique for wireless networks. Consider a 3 node chain A B C with two opposite flows A C and C A. In this case the middle node B can XOR two packets traveling in opposite directions thereby reducing the transmissions required for packet exchange from 4 down to 3 transmissions. However previous schemes proposed for network coding are opportunistic and critically depend on the traffic pattern in the network and thus the routing decisions. To increase the benefit of network coding routes that create more mixing opportunities can be ascertained and selected. Context based routing can be applied in such scenarios.

Node B knows that a packet arriving from A and going to C can be mixed with the background flow. Consequently node B can announce a lower conditional cost for a cost B C A B to attract new flows to adopt a route that can be mixed with the background flows. With the illustrated example node B announces that the cost B C equals 1 generally. However it also announces that the cost B C A B equals half of the general amount. The lower cost is justified by the lower resource that the path consumes. In this network coding scenario the path metric has a one hop memory hence the CPP method can find the optimal route.

Furthermore it is possible to combine multiple context based metrics in systems where context is required to model multiple phenomena. As an example we can potentially perform route selection in a wireless network with multiple radios as well as local mixing. To that end but by way of example only Routing with a Markovian Metric to Promote Local Mixing is described in greater detail herein below.

Multicast While the description above applies context based routing to multi radio unicast context based routing can also be applied to optimize multicast trees in multi radio networks.

Optical Networks The problem of choosing light paths in a WDM optical network has some synergy with a wireless network equipped with multiple radios. Each optical router has multiple incoming wavelengths and outgoing wavelengths. Some costlier devices can also perform wavelength conversion. Thus the cost of choosing an outgoing wavelength can depend on context. For example the cost can depend on the incoming wavelength and the cost of conversion.

In the description above we present example implementations for routing metrics and route selection performed in multi radio wireless networks. Context information can be used to enhance if not optimize routes when interdependencies between links in a path exist. An example context based metric that is described herein above is the SIM metric. An associated context based route selection method the CPP method is also described. Although they may be implemented separately they jointly provide an effective way for performing interference aware routing in multi radio networks. CRP can find good routes when frequency reuse is possible heterogeneous nodes exist in the network and or transient bottlenecks occur. Hence it is a good general purpose routing protocol for multi radio wireless network meshes.

Network coding refers to a scheme where a node is allowed to generate output data by mixing i.e. computing certain functions of its received data. The broadcast property of e.g. the wireless medium renders network coding particularly useful.

Consider nodes v v von a line as illustrated in . is a graphical depiction of an example three node network topology to illustrate how transmissions can be saved using local mixing network coding. Suppose vwants to send packet xto vvia vand vwants to send packet xto vvia v. A conventional solution without network coding requires 4 transmissions over the air. This non network coding approach is illustrated in . Using network coding on the other hand this packet exchange can be performed using 3 transmissions. This network coding approach is illustrated in .

The principles illustrated in can be generalized to a chain of nodes. For packet exchanges between two wireless nodes along a line the consumed channel resources can potentially be halved. Such advantages can be realized in practice. For example each wireless router can examine its local buffer and mix a left bound packet with a right bound packet here left and right are in the relative sense . Such a mixture packet can be de mixed by the left and right neighbors.

As another example a framework for exploiting network coding and the broadcast medium to improve the efficiency of unicasting in multi hop wireless networks has been presented. Each node snoops on the medium and buffers packets it has heard. A node also informs its neighbors which packets it has overheard. This allows nodes to know roughly what packets are available at each neighbor i.e. who has what . Knowing who has what in the neighborhood a node examines its pending outgoing packets and decides how to form output mixture packets with the objective of most efficiently utilizing the medium.

Thus a link layer enhancement scheme can be implemented in the networking stack. is a block diagram showing an example network layer relationship for routing to promote local mixing with a local mixing engine shunt. As is illustrated in the local mixing engine sits above the MAC layer e.g. for IEEE 802.11 and below the network layer e.g. for routing . Given the routing decisions the local mixing engine tries to identify mixing opportunities. It has been shown that local mixing can improve the link layer efficiency. The gain of this technique however depends on the traffic pattern in the network. Thus the description herein below involves making routing decisions that increase if not maximize the benefits offered by the local mixing engine.

By way of example only the description herein below focuses on wireless mesh networks e.g. static multi hop wireless networks . However the described implementations and principles are applicable to other wireless networks and or wired networks. State of the art routing protocols for wireless mesh networks have traditionally been based on finding shortest paths under certain cost metrics. The simplest path metric is the hop count. However various link quality metrics have also been proposed for static wireless mesh networks. These metrics include by way of example but not limitation the per hop round trip time RTT the expected transmission count ETX the expected transmission time ETT and so forth.

One approach is to modify the link metrics to take into account the effect of the local mixing engine in reducing the transmissions over the air. This however is not straightforward. Consider the example setting illustrated in . is a graphical depiction of an example nine node mesh network topology having two long term background flows and . These two long term flows in the network are v v v and v v v .

We want to find a good routing path from vto v. Due to the existence of the local mixing engine the route v v v v vis a good solution because the packets belonging to this new flow can be mixed with the packets belonging to the opposite flow v v v resulting in improved resource efficiency. To encourage using such a route link v vcan announce a lower cost. There are some issues in doing so because a packet from vthat traverses v vmay not share a ride with a packet from vthat traverses v v although a packet from vthat traverses v vcan.

The example above reveals that in the presence of the local mixing engine assessing the channel resource incurred by a packet transmission involves some context information about where the packet arrives from. For example we can say that given the current traffic condition the cost for sending a packet from vto vthat previously arrives from v is smaller. An observation here is the relevancy of defining link cost based on some context information. This leads to the concept of a Markovian metric which is described below.

A conventional routing metric models the cost of a path as the sum of the costs on the individual links. In contrast an example Markovian metric introduces context information into the cost modeling. The cost of sending a packet or a stream of packets across a link is thus allowed to depend on where the packet or the stream arrived from. The cost of a path is modeled as the cost of the first hop plus the cost of the second hop conditioned on the first hop and so on.

Definition 1 example Markovian metric Consider a path v v . . . v. A Markovian metric models the cost of a path as the sum of the conditional costs on the links as is shown by equation L1 with L denoting a local mixing embodiment 

The conventional routing metric can be viewed as a special case of the Markovian metric where all of the conditional link costs are equal to their unconditional counterparts. The decomposition relation of equation L1 is reminiscent of the decomposition of the joint probability distribution of random variables forming a Markov chain into a product of the conditional probabilities. Thus a Markovian metric to an unconditional metric is like a Markov chain to a memoryless sequence of random variables.

Due to this decomposition structure the dynamic programming principle still applies. Hence finding the shortest path with a Markovian metric can still be done in polynomial time. In a practical network support for the Markovian metric can be added relatively easily into an existing routing framework that uses a conventional routing metric.

Properly defining the conditional and unconditional link costs and computing them are central issues in the applications of a Markovian metric. A relatively concrete example can be found below in Section 3 which is entitled Markovian Metric for Local Mixing . In this section we assume that we are given a set of unconditional link costs Wand a set of conditional link costs W. For ease in notation we use wto denote an unconditional link cost cost v v and wto denote a conditional link cost cost v v v v .

A graphical representation of these costs which is termed herein the dot graph is described below. We denote the original graph by G and the resulting dot graph by . For the example network in the graphical representation of the link costs is illustrated in . is a graphical depiction of an example nine node mesh network topology that illustrates conditional and unconditional link costs. In this example we assume each unconditional link cost is 1 and there are two conditional costs w 0.5 and w 0.5. For instance here cost v v v v 

In a described implementation to produce we first add to G a dot for each directed link in the original graph which splits the original link into two halves. Thus there is a one to one correspondence between the links in the original graph G and the dots in . With slight abuse of notation we refer to these dots as the names for the links in G for example the dot that splits the link from vto vis referred to as e. Therefore has V G E G nodes.

Second for each conditional link cost cost v v v v in the given set W we draw an edge from the dot eto the dot e. These edges together with the edges generated by splitting the original links constitute the edge set of the dot graph. To distinguish from the edges in the original graph we call an edge in the dot graph a wire. Therefore has 2 E G W wires.

Third we associate a cost label with each wire in . The cost of a wire from a physical node v V G to a dot e V is the given unconditional cost of the link w. The cost of a wire from a dot e V to a physical node v V G is 0. The cost of a wire from a dot e V to another dot e V is w the given conditional cost of the link.

In general we allow the coexistence of a conditional cost and unconditional cost for the same link e.g. a cost b c a b and a cost b c . We assume the conditional link cost is less than or equal to its corresponding unconditional link cost. This is without loss of generality because we can define the unconditional cost on a link as the maximum of the corresponding conditional link costs. The meaning is intuitive The unconditional link cost represents a conservative estimate of the cost incurred given further context information the cost may be lower. For example in w 0.5

For a described implementation and from an intuitive perspective the dot graph models the existence of short cuts at various places in the network. It is easy to see that a path in the dot graph G maps into a route in the original network and that the cost of the route is the total cost along the path in . For instance consider a path from vto vin with the path identified by enumeration L2 below . L2 The above path enumeration L2 corresponds to the physical route v v v v v. The cost of the path is w w w w 3.5. In comparison consider the path that is identified by enumeration L3 below . L3 The above path enumeration L3 corresponds to the physical route v v v v v which has a cost of 4. Therefore path is better than path .

More generally to find the minimum cost route between two physical nodes a shortest path algorithm is applied over the dot graph. For example with Dijkstra s algorithm the complexity is O V . Irrelevant dots in can be removed. In other words a dot emay be introduced only if there is a need to express a related conditional link cost e.g. when Wincludes a cost w or w . Here the asterisk symbol is used as a wildcard. By excluding the irrelevant dots the number of vertices in the dot graph can be reduced to O V G min E G 2 W .

Proposition 1 Min Cost Routing w Markovian Metric Given a set of unconditional link costs Wand a set of conditional link costs the minimum cost routing from a source node s to a destination or sink node t can be found by running a shortest path algorithm over the dot graph. This can be done in complexity O V G min E G 2 W .

The dot graph representation makes it easier to see how to modify the existing routing protocols for a Markovian metric system. Essentially a physical node vplays several characters in a distributed routing algorithm including those of its neighboring dots that do not physically exist. In particular by way of example only the computational responsibility can be divided as follows. Let each physical node vbe responsible for its own outgoing wires of vplus the outgoing wires of its incoming dots e . For example in physical node vimplements the computation involving wires e v v e e e. Example approaches to supporting a Markovian metric in two types of representative routing algorithms are described below.

1 Link State Routing Example protocols in this category include OLSR LQSR and so forth. In link state routing each router measures the cost to each of its neighbors constructs a packet including these measurements sends it to all other routers and computes the shortest paths locally using this information.

To support a Markovian metric the following changes are involved in a link state routing system. Each router can measure the unconditional and conditional costs along the links wires it is responsible for and broadcast the measurements to all other routers. Take node vin as an example. Here vneeds to measure the unconditional costs to each neighbor as well as the conditional costs of the form cost e e .

2 Distance Vector Routing An example protocol amongst other protocols in this category is DSDV In distance vector routing also known as the Bellman Ford algorithm each router maintains a table i.e. a vector giving the best known cost to reach each destination and which interface to use to get there. There tables are updated by exchanging information with the neighbors.

Let us start with a first cut solution. Once every T milliseconds each router sends each neighbor a list of its estimated minimum cost to reach each destination. Since each physical node vis also playing the roles of its incoming dots a first cut implementation aggregates the tables from vand its incoming dots. For example consider node vin . This node vis also responsible for playing the roles of e e e. Thus the aggregated table includes one minimum cost from eto v for i 1 3 5 and all other such destinations. The estimated minimum cost to reach destination vis denoted herein as cost e v . Thus in this case the following equality L4 holds cost cost cost . L4 

Similar scenarios may occur whenever the conditional cost cannot lead to a lower route to the given node v. In these scenarios sending both cost e v and cost e v is wasteful. To remove such redundancy we can include in the table cost v v and then cost e v only if it is lower than cost v v . This more efficiently utilizes communication bandwidth.

In this section an example approach to using a Markovian metric to increase if not maximize the benefit of local mixing is described. An issue with this goal is properly defining the link costs and computing them. We begin the consideration of link metrics with the unconditional link metrics. Although other link metrics can be employed one popular link quality metric is the expected transmission count ETX . This metric estimates the number of transmissions including retransmissions needed to send a unicast packet across a link. It may be obtained by measuring the loss probabilities of broadcast packets between pairs of neighboring nodes.

The ETX metric can be viewed as a characterization of the amount of resource consumed by a packet transmission. With the local mixing engine several packets may share a ride in the air. Naturally the passengers can share the airfare. In effect each participating source packet is getting a discount. Such a discount however cannot be accurately modeled by an unconditional metric such as ETX because the applicability of the discount depends on the previous hop of the packet.

In contrast we therefore describe a conditional link metric termed herein the expected resource consumption ERC metric which models the cost saving due to local mixing. Consider a packet sent in the air. If it is a mixture of k source packets then each ingredient source packet is charged 1 k the resource consumed by the packet transmission. The resource consumed by the transmission can be measured in terms of e.g. air time consumed energy some combination thereof and so forth.

We now describe an example scheme for computing the ERC. Each node maintains a table with wire information such as a WireInfoTable . Each row of the table contains the measured statistics about a wire say e e which crosses the current node v. The packets forwarded by the current node can be classified into categories associated with the wires. A packet that is received along eand sent along efalls into the category e e .

For each wire category we collect the total number of packets sent and the total resource consumed in a sliding time window. The total resource consumption is obtained by adding the resource consumption for each sent packet. Although other charging models may be employed a relatively simple charging model is described herein. For example if a source packet across wire e eis sent in a mixture of 3 packets we set the resource consumption of this source packet as of the ETX of link e. Alternatively other metrics can be used in lieu of ETX such as ETT and so forth.

To implement the sliding window computation efficiently the time axis can be quantized into discrete slots of equal length. A sliding window of N slots is thus used. For each wire we maintain a circular buffer of N bins at any time one of the N bins is active. At the start of each slot we shift the active bin pointer once and clear the statistics in the new active bin. Each time a packet is transmitted in the air we update the statistics in the current active bin accordingly. By way of example only N may be set equal to 10 slots each with a length of length 0.5 s. Other values of i and slot lengths may alternatively be used.

To evaluate the conditional link metric for a certain wire e e we first obtain the ERC for each slot say n using equation L5 below 

The measurement method described above generates an estimate of the current ERC which is the ERC seen by a flow whose packets are currently being mixed. In addition to the current ERC we collect another statistic called the marginal ERC which is the ERC meant for a flow that has not been actively using the wire. The marginal ERC represents an estimate of the ERC if a small amount of new traffic is added to a particular wire e e. If the existing flows already use up most of the mixing opportunities then the marginal ERC will likely not have a high discount. Both the current ERC and the marginal ERC are reported.

To compute the marginal ERC in a described implementation an example rule is applied. Specifically for a wire e ein a given time slot we examine the number of unmixed packets y in the reverse wire e e. If y is large enough then there will likely be more mixing opportunities hence we set the marginal ERC as a larger value. As a specific example if y 25 then we set the marginal ERC as 0.75 of the ETX e.g. a 25 discount otherwise we set the marginal ERC as the ETX e.g. no discount . However other marginal ERC computational approaches may alternatively be employed.

In a described implementation potential oscillations are avoided with randomized route holding. In order to model the resource reduction due to local mixing the ERC takes the traffic load into account. This can potentially cause oscillation in the routing decisions. Notably the discounts offered by the local mixing engine exist only when the flows cross in certain ways. Stated alternatively the advertised discounts have restrictions hence only a few qualifying flows may find them attractive. Because the discounts benefit all the flows whose packets are being mixed there is incentive for flows to route in a certain cooperative manner that is ultimately mutually beneficial.

If the flows try such a mutually beneficial arrangement for some time they will confirm the discounts and tend to stay in the arrangement. Such an arrangement is analogous to the Nash equilibrium in game theory where no player wants to deviate from its current strategy given all other players strategies. However a complication is that there can be more than one equilibrium. We want the flows to make dynamic decisions that eventually settle down to one equilibrium.

To facilitate settling down to one equilibrium the following strategy may be implemented. To prevent potential route oscillations we require each flow to stay for at least Tduration after each route change where Tis a random variable. The randomization of the mandatory route holding time Tis used to avoid flows from changing routes at the same time. For an additional oscillation avoidance measure after the mandatory route holding duration each node may be permitted to switch to a new route only if the new route offers an appreciably smaller total cost.

An example Markovian metric is described herein. The Markovian metric models the cost of a path as the sum of the individual conditional link costs. It is somewhat analogous to the decomposition of the joint probability of a Markov chain into a product of conditional probabilities. The Markovian metric can be used to make routing decisions that better take advantage of local mixing.

An example expected resource consumption ERC metric is described as a conditional link metric that models the cost reduction due to local mixing. Markovian metric routing using the ERC link metric can reduce the total resource consumption of a path leading to better system efficiency. With such a Markovian metric flows tend to self organize themselves toward an equilibrium arrangement that can benefit each other. Example techniques that can facilitate flows settling down into an equilibrium are also described.

The local mixing engine on its own can improve the link layer efficiency. It identifies mixing opportunities on the fly and takes advantage of them if they are present. Routing with a Markovian metric makes local mixing more useful as it creates more mixing opportunities. This can translate to notable resource saving and throughput gain.

As illustrated two devices and are capable of engaging in communications via network . Communications include by way of example but not limitation the exchange of wireless network parameters e.g. by broadcast or specifically addressed interactions to effectuate a path routing interactions to facilitate local mixing packet forwarding for a flow and so forth. Although two devices are specifically shown one or more than two devices may be employed depending on implementation.

Generally a device may represent any computer or processing capable device such as a server device a workstation or other general computer device a data storage repository apparatus a personal digital assistant PDA a mobile phone a gaming platform an entertainment device a router computing node a mesh or other network node a wireless access point some combination thereof and so forth. As illustrated device includes one or more input output I O interfaces at least one processor and one or more media . Media include processor executable instructions .

In a described implementation of device I O interfaces may include i a network interface for communicating across network ii a display device interface for displaying information on a display screen iii one or more man machine interfaces and so forth. Examples of i network interfaces include a network card a modem one or more ports a network communications stack a radio and so forth. Examples of ii display device interfaces include a graphics driver a graphics card a hardware or software driver for a screen or monitor and so forth. Examples of iii man machine interfaces include those that communicate by wire or wirelessly to man machine interface devices e.g. a keyboard a remote a mouse or other graphical pointing device etc. .

Generally processor is capable of executing performing and or otherwise effectuating processor executable instructions such as processor executable instructions . Media is comprised of one or more processor accessible media. In other words media may include processor executable instructions that are executable by processor to effectuate the performance of functions by device . Processor executable instructions may be embodied as software firmware hardware fixed logic circuitry some combination thereof and so forth.

Thus realizations for context based routing in multi hop networks may be described in the general context of processor executable instructions. Generally processor executable instructions include routines programs applications coding modules protocols objects components metadata and definitions thereof data structures application programming interfaces APIs etc. that perform and or enable particular tasks and or implement particular abstract data types. Processor executable instructions may be located in separate storage media executed by different processors and or propagated over or extant on various transmission media.

Processor s may be implemented using any applicable processing capable technology. Media may be any available media that is included as part of and or accessible by device . It includes volatile and non volatile media removable and non removable media storage and transmission media e.g. wireless or wired communication channels hard coded logic media combinations thereof and so forth. Media is tangible media when it is embodied as a manufacture and or composition of matter. For example media may include an array of disks or flash memory for longer term mass storage of processor executable instructions random access memory RAM for shorter term storing of instructions that are currently being executed and or otherwise processed link s on network for transmitting communications and so forth.

As specifically illustrated media comprises at least processor executable instructions . Generally processor executable instructions when executed by processor enable device to perform the various functions described herein. Such functions include but are not limited to i those actions that are illustrated in flow diagrams and of ii the producing transmitting receiving processing etc. of link parameters and or path metrics iii the functions of components of iv the virtual nodes of context expanded graphs A B and of and and so forth.

The devices actions aspects features functions procedures modules data structures protocols network nodes communications etc. of are illustrated in diagrams that are divided into multiple blocks and other elements. However the order interconnections interrelationships layout etc. in which are described and or shown are not intended to be construed as a limitation and any number of the blocks and or other elements can be modified combined rearranged augmented omitted etc. in any manner to implement one or more systems methods devices procedures media apparatuses arrangements etc. for context based routing in multi hop networks.

Although systems media devices methods procedures apparatuses mechanisms schemes approaches processes arrangements and other implementations have been described in language specific to structural logical algorithmic and functional features and or diagrams it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

