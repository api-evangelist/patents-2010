---

title: Remote presentation over lossy transport with forward error correction
abstract: In various embodiments, methods and systems are disclosed for integrating a remote presentation protocol with a datagram based transport. In one embodiment, an integrated protocol is configured to support lossless or reduced loss transport based on Retransmission (ARQ) combined with Forward Error Correction (FEC). The protocol involves encoding and decoding of data packets including feedback headers and FEC packets, continuous measurement of RTT, RTO and packet delay, dynamically evaluating loss probability to determine and adjust the ratio of FEC, congestion management based on dynamically detecting increase in packet delay, and fast data transmission rate ramp-up based on detecting a decrease in packet delay.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08738986&OS=08738986&RS=08738986
owner: Microsoft Corporation
number: 08738986
owner_city: Redmond
owner_country: US
publication_date: 20100305
---
Remote computing systems can enable users to remotely access hosted resources. Servers on the remote computing systems can execute programs and transmit signals indicative of a user interface to clients that can connect by sending signals over a network conforming to a communication protocol such as the TCP IP protocol. Each connecting client may be provided a remote presentation session i.e. an execution environment that includes a set of resources. Each client can transmit signals indicative of user input to the server and the server can apply the user input to the appropriate session. The clients may use remote presentation protocols such as the Remote Desktop Protocol RDP to connect to a server resource.

Remote presentation protocols are typically session level protocols that use a TCP type connection between the client and the host. When a remote presentation session is established over a wide area network round trip time and data packet loss may result in delays that negatively impact real time end user experience such as tearing and jitter.

In various embodiments methods and systems are disclosed for integrating the remote presentation protocol with a datagram based transport.

In one embodiment such an integrated protocol may be configured to support lossless or reduced loss transport based on Retransmission ARQ combined with Forward Error Correction FEC . The protocol includes encoding and decoding of data packets including feedback headers and FEC packets continuous measurement of RTT RTO and packet delay dynamically evaluating a loss probability to determine and adjust the FEC ratio congestion management based on dynamically detecting an increase in packet delay and fast data transmission rate ramp up based on detecting a decrease in packet delay. In an embodiment the transport layer may be integrated into both the server and client and may provide the ability to provide a lossless transport with in order data delivery or a lossy transport and report back data loss or out of order delivery to the remote presentation layer. The integrated protocol may implement a remote presentation session over a single transport or co exist with TCP based transport for different portions of the data stream.

Certain specific details are set forth in the following description and figures to provide a thorough understanding of various embodiments of the disclosure. Certain well known details often associated with computing and software technology are not set forth in the following disclosure to avoid unnecessarily obscuring the various embodiments of the disclosure. Further those of ordinary skill in the relevant art will understand that they can practice other embodiments of the disclosure without one or more of the details described below. Finally while various methods are described with reference to steps and sequences in the following disclosure the description as such is for providing a clear implementation of embodiments of the disclosure and the steps and sequences of steps should not be taken as required to practice this disclosure.

Embodiments may execute on one or more computers. and the following discussion are intended to provide a brief general description of a suitable computing environment in which the disclosure may be implemented. One skilled in the art can appreciate that computer systems can have some or all of the components described with respect to computer of .

The term circuitry used throughout the disclosure can include hardware components such as hardware interrupt controllers hard drives network adaptors graphics processors hardware based video audio codecs and the firmware software used to operate such hardware. The term circuitry can also include microprocessors configured to perform function s by firmware or by switches set in a certain way or one or more logical processors e.g. one or more cores of a multi core general processing unit. The logical processor s in this example can be configured by software instructions embodying logic operable to perform function s that are loaded from memory e.g. RAM ROM firmware and or virtual memory. In example embodiments where circuitry includes a combination of hardware and software an implementer may write source code embodying logic that is subsequently compiled into machine readable code that can be executed by a logical processor. Since one skilled in the art can appreciate that the state of the art has evolved to a point where there is little difference between hardware software or a combination of hardware software the selection of hardware versus software to effectuate functions is merely a design choice. Thus since one of skill in the art can appreciate that a software process can be transformed into an equivalent hardware structure and a hardware structure can itself be transformed into an equivalent software process the selection of a hardware implementation versus a software implementation is trivial and left to an implementer.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computer through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite disk scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or universal serial bus USB . A display or other type of display device can also be connected to the system bus via an interface such as a video adapter . In addition to the display computers typically include other peripheral output devices not shown such as speakers and printers. The system of also includes a host adapter Small Computer System Interface SCSI bus and an external storage device connected to the SCSI bus .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another computer a server a router a network PC a peer device or other common network node a virtual machine and typically can include many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in can include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer can be connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer can typically include a modem or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external can be connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are examples and other means of establishing a communications link between the computers may be used. Moreover while it is envisioned that numerous embodiments of the disclosure are particularly well suited for computer systems nothing in this document is intended to limit the disclosure to such embodiments.

Referring now to another embodiment of an exemplary computing system is depicted. Computer system can include a logical processor e.g. an execution core. While one logical processor is illustrated in other embodiments computer system may have multiple logical processors e.g. multiple execution cores per processor substrate and or multiple processor substrates that could each have multiple execution cores. As shown by the figure various computer readable storage media can be interconnected by one or more system busses which couples various system components to the logical processor . The system buses may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. In example embodiments the computer readable storage media can include for example random access memory RAM storage device e.g. electromechanical hard drive solid state hard drive etc. firmware e.g. FLASH RAM or ROM and removable storage devices such as for example CD ROMs floppy disks DVDs FLASH drives external storage devices etc. It should be appreciated by those skilled in the art that other types of computer readable storage media can be used such as magnetic cassettes flash memory cards digital video disks and Bernoulli cartridges.

The computer readable storage media provide non volatile storage of processor executable instructions data structures program modules and other data for the computer . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computer system such as during start up can be stored in firmware . A number of programs may be stored on firmware storage device RAM and or removable storage devices and executed by logical processor including an operating system and or application programs.

Commands and information may be received by computer through input devices which can include but are not limited to a keyboard and pointing device. Other input devices may include a microphone joystick game pad scanner or the like. These and other input devices are often connected to the logical processor through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or universal serial bus USB . A display or other type of display device can also be connected to the system bus via an interface such as a video adapter which can be part of or connected to a graphics processor . In addition to the display computers typically include other peripheral output devices not shown such as speakers and printers. The exemplary system of can also include a host adapter Small Computer System Interface SCSI bus and an external storage device connected to the SCSI bus.

Computer system may operate in a networked environment using logical connections to one or more remote computers such as a remote computer. The remote computer may be another computer a server a router a network PC a peer device or other common network node and typically can include many or all of the elements described above relative to computer system .

When used in a LAN or WAN networking environment computer system can be connected to the LAN or WAN through a network interface card . The NIC which may be internal or external can be connected to the system bus. In a networked environment program modules depicted relative to the computer system or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections described here are exemplary and other means of establishing a communications link between the computers may be used. Moreover while it is envisioned that numerous embodiments of the present disclosure are particularly well suited for computerized systems nothing in this document is intended to limit the disclosure to such embodiments.

A remote desktop system is a computer system that maintains applications that can be remotely executed by client computer systems. Input is entered at a client computer system and transferred over a network e.g. using protocols based on the International Telecommunications Union ITU T.120 family of protocols such as Remote Desktop Protocol RDP to an application on a terminal server. The application processes the input as if the input were entered at the terminal server. The application generates output in response to the received input and the output is transferred over the network to the client computer system. The client computer system presents the output data. Thus input is received and output presented at the client computer system while processing actually occurs at the terminal server. A session can include a shell and a user interface such as a desktop the subsystems that track mouse movement within the desktop the subsystems that translate a mouse click on an icon into commands that effectuate an instance of a program etc. In another example embodiment the session can include an application. In this example while an application is rendered a desktop environment may still be generated and hidden from the user. It should be understood that the foregoing discussion is exemplary and that the presently disclosed subject matter may be implemented in various client server environments and not limited to a particular terminal services product.

In most if not all remote desktop environments input data entered at a client computer system typically includes mouse and keyboard data representing commands to an application and output data generated by an application at the terminal server typically includes video data for display on a video output device. Many remote desktop environments also include functionality that extend to transfer other types of data.

Communications channels can be used to extend the RDP protocol by allowing plug ins to transfer data over an RDP connection. Many such extensions exist. Features such as printer redirection clipboard redirection port redirection etc. use communications channel technology. Thus in addition to input and output data there may be many communications channels that need to transfer data. Accordingly there may be occasional requests to transfer output data and one or more channel requests to transfer other data contending for available network bandwidth.

Referring now to depicted are high level block diagrams of computer systems configured to effectuate virtual machines. As shown in the figures computer system can include elements described in and components operable to effectuate virtual machines. One such component is a hypervisor that may also be referred to in the art as a virtual machine monitor. The hypervisor in the depicted embodiment can be configured to control and arbitrate access to the hardware of computer system . Broadly stated the hypervisor can generate execution environments called partitions such as child partition through child partition N where N is an integer greater than or equal to 1 . In embodiments a child partition can be considered the basic unit of isolation supported by the hypervisor that is each child partition can be mapped to a set of hardware resources e.g. memory devices logical processor cycles etc. that is under control of the hypervisor and or the parent partition and hypervisor can isolate one partition from accessing another partition s resources. In embodiments the hypervisor can be a stand alone software product a part of an operating system embedded within firmware of the motherboard specialized integrated circuits or a combination thereof.

In the above example computer system includes a parent partition that can also be thought of as domain in the open source community. Parent partition can be configured to provide resources to guest operating systems executing in child partitions N by using virtualization service providers VSPs that are also known as back end drivers in the open source community. In this example architecture the parent partition can gate access to the underlying hardware. The VSPs can be used to multiplex the interfaces to the hardware resources by way of virtualization service clients VSCs that are also known as front end drivers in the open source community. Each child partition can include one or more virtual processors such as virtual processors through that guest operating systems through can manage and schedule threads to execute thereon. Generally the virtual processors through are executable instructions and associated state information that provide a representation of a physical processor with a specific architecture. For example one virtual machine may have a virtual processor having characteristics of an Intel x86 processor whereas another virtual processor may have the characteristics of a PowerPC processor. The virtual processors in this example can be mapped to logical processors of the computer system such that the instructions that effectuate the virtual processors will be backed by logical processors. Thus in these example embodiments multiple virtual processors can be simultaneously executing while for example another logical processor is executing hypervisor instructions. Generally speaking and as illustrated by the figures the combination of virtual processors various VSCs and memory in a partition can be considered a virtual machine such as virtual machine or .

Generally guest operating systems through can include any operating system such as for example operating systems from Microsoft Apple the open source community etc. The guest operating systems can include user kernel modes of operation and can have kernels that can include schedulers memory managers etc. A kernel mode can include an execution mode in a logical processor that grants access to at least privileged processor instructions. Each guest operating system through can have associated file systems that can have applications stored thereon such as terminal servers e commerce servers email servers etc. and the guest operating systems themselves. The guest operating systems can schedule threads to execute on the virtual processors and instances of such applications can be effectuated.

Referring now to illustrated is an alternative architecture that can be used to effectuate virtual machines. depicts similar components to those of however in this example embodiment the hypervisor can include the virtualization service providers and device drivers and parent partition may contain configuration utilities . In this architecture hypervisor can perform the same or similar functions as the hypervisor of . The hypervisor of can be a stand alone software product a part of an operating system embedded within firmware of the motherboard or a portion of hypervisor can be effectuated by specialized integrated circuits. In this example parent partition may have instructions that can be used to configure hypervisor however hardware access requests may be handled by hypervisor instead of being passed to parent partition .

Referring now to computer may include circuitry configured to provide remote desktop services to connecting clients. In an example embodiment the depicted operating system may execute directly on the hardware or a guest operating system or may be effectuated by a virtual machine such as VM or VM . The underlying hardware and is indicated in the illustrated type of dashed lines to identify that the hardware can be virtualized.

Remote services can be provided to at least one client such as client while one client is depicted remote services can be provided to more clients. The example client can include a computer terminal that is effectuated by hardware configured to direct user input to a remote server session and display user interface information generated by the session. In another embodiment client can be effectuated by a computer that includes similar elements as those of computer . In this embodiment client can include circuitry configured to effect operating systems and circuitry configured to emulate the functionality of terminals e.g. a remote desktop client application that can be executed by one or more logical processors . One skilled in the art can appreciate that the circuitry configured to effectuate the operating system can also include circuitry configured to emulate a terminal.

Each connecting client can have a session such as session which allows the client to access data and applications stored on computer . Generally applications and certain operating system components can be loaded into a region of memory assigned to a session. Thus in certain instances some OS components can be spawned N times where N represents the number of current sessions . These various OS components can request services from the operating system kernel which can for example manage memory facilitate disk reads writes and configure threads from each session to execute on the logical processor . Some example subsystems that can be loaded into session space can include the subsystems that generates desktop environments the subsystems that track mouse movement within the desktop the subsystems that translate mouse clicks on icons into commands that effectuate an instance of a program etc. The processes that effectuate these services e.g. tracking mouse movement are tagged with an identifier associated with the session and are loaded into a region of memory that is allocated to the session.

A session can be generated by a session manager e.g. a process. For example the session manager can initialize and manage each remote session by generating a session identifier for a session space assigning memory to the session space and generating system environment variables and instances of subsystem processes in memory assigned to the session space. The session manager can be invoked when a request for a remote desktop session is received by the operating system .

A connection request can first be handled by a transport stack e.g. a remote desktop protocol RDP stack. The transport stack instructions can configure logical processor to listen for connection messages on a certain port and forward them to the session manager . When sessions are generated the transport stack can instantiate a remote desktop protocol stack instance for each session. Stack instance is an example stack instance that can be generated for session . Generally each remote desktop protocol stack instance can be configured to route output to an associated client and route client input to an environment subsystem for the appropriate remote session.

As shown by the figure in an embodiment an application while one is shown others can also execute can execute and generate an array of bits. The array can be processed by a graphics interface which in turn can render bitmaps e.g. arrays of pixel values that can be stored in memory. As shown by the figure a remote display subsystem can be instantiated which can capture rendering calls and send the calls over the network to client via the stack instance for the session.

In addition to remoting graphics and audio a plug and play redirector can also be instantiated in order to remote diverse devices such as printers mp3 players client file systems CD ROM drives etc. The plug and play redirector can receive information from a client side component which identifies the peripheral devices coupled to the client . The plug and play redirector can then configure the operating system to load redirecting device drivers for the peripheral devices of the client . The redirecting device drivers can receive calls from the operating system to access the peripherals and send the calls over the network to the client .

As discussed above clients may use a protocol for providing remote presentation services such as Remote Desktop Protocol RDP to connect to a resource using terminal services. When a remote desktop client connects to a terminal server via a terminal server gateway the gateway may open a socket connection with the terminal server and redirect client traffic on the remote presentation port or a port dedicated to remote access services. The gateway may also perform certain gateway specific exchanges with the client using a terminal server gateway protocol transmitted over HTTPS.

Turning to depicted is a computer system including circuitry for effectuating remote services and for incorporating aspects of the present disclosure. As shown by the figure in an embodiment a computer system can include components similar to those described in and and can effectuate a remote presentation session. In an embodiment of the present disclosure a remote presentation session can include aspects of a console session e.g. a session spawned for a user using the computer system and a remote session. Similar to that described above the session manager can initialize and manage the remote presentation session by enabling disabling components in order to effectuate a remote presentation session.

One set of components that can be loaded in a remote presentation session are the console components that enable high fidelity remoting namely the components that take advantage of 3D graphics and 2D graphics rendered by 3D hardware.

3D 2D graphics rendered by 3D hardware can be accessed using a driver model that includes a user mode driver an API a graphics kernel and a kernel mode driver . An application or any other process such as a user interface that generates 3D graphics can generate API constructs and send them to an application programming interface API such as Direct3D from Microsoft . The API in turn can communicate with a user mode driver which can generates primitives e.g. the fundamental geometric shapes used in computer graphics represented as vertices and constants which are used as building blocks for other shapes and stores them in buffers e.g. pages of memory. In one embodiment the application can declare how it is going to use the buffer e.g. what type of data it is going to store in the buffer. An application such as a videogame may use a dynamic buffer to store primitives for an avatar and a static buffer for storing data that will not change often such as data that represents a building or a forest.

Continuing with the description of the driver model the application can fill the buffers with primitives and issue execute commands. When the application issues an execute command the buffer can be appended to a run list by the kernel mode driver and scheduled by the graphics kernel scheduler . Each graphics source e.g. application or user interface can have a context and its own run list. The graphics kernel can be configured to schedule various contexts to execute on the graphics processing unit . The GPU scheduler can be executed by logical processor and the scheduler can issue a command to the kernel mode driver to render the contents of the buffer. The stack instance can be configured to receive the command and send the contents of the buffer over the network to the client where the buffer can be processed by the GPU of the client.

Illustrated now is an example of the operation of a virtualized GPU as used in conjunction with an application that calls for remote presentation services. Referring to in an embodiment a virtual machine session can be generated by a computer . For example a session manager can be executed by a logical processor and a remote session that includes certain remote components can be initialized. In this example the spawned session can include a kernel a graphics kernel a user mode display driver and a kernel mode display driver . The user mode driver can generate graphics primitives that can be stored in memory. For example the API can include interfaces that can be exposed to processes such as a user interface for the operating system or an application . The process can send high level API commands such as such as Point Lists Line Lists Line Strips Triangle Lists Triangle Strips or Triangle Fans to the API . The API can receive these commands and translate them into commands for the user mode driver which can then generate vertices and store them in one or more buffers. The GPU scheduler can run and determine to render the contents of the buffer. In this example the command to the graphics processing unit of the server can be captured and the content of the buffer primitives can be sent to client via network interface card . In an embodiment an API can be exposed by the session manager that components can interface with in order to determine whether a virtual GPU is available.

In an embodiment a virtual machine such as virtual machine of or can be instantiated and the virtual machine can serve as a platform for execution for the operating system . Guest operating system can embody operating system in this example. A virtual machine may be instantiated when a connection request is received over the network. For example the parent partition may include an instance of the transport stack and may be configured to receive connection requests. The parent partition may initialize a virtual machine in response to a connection request along with a guest operating system including the capabilities to effectuate remote sessions. The connection request can then be passed to the transport stack of the guest operating system . In this example each remote session may be instantiated on an operating system that is executed by its own virtual machine.

In one embodiment a virtual machine can be instantiated and a guest operating system embodying operating system can be executed. Similar to that described above a virtual machine may be instantiated when a connection request is received over the network. Remote sessions may be generated by an operating system. The session manager can be configured to determine that the request is for a session that supports 3D graphics rendering and the session manager can load a console session. In addition to loading the console session the session manager can load a stack instance for the session and configure system to capture primitives generated by a user mode display driver .

The user mode driver may generate graphics primitives that can be captured and stored in buffers accessible to the transport stack . A kernel mode driver can append the buffers to a run list for the application and a GPU scheduler can run and determine when to issue render commands for the buffers. When the scheduler issues a render command the command can be captured by for example the kernel mode driver and sent to the client via the stack instance .

The GPU scheduler may execute and determine to issue an instruction to render the content of the buffer. In this example the graphics primitives associated with the instruction to render can be sent to client via network interface card .

In an embodiment at least one kernel mode process can be executed by at least one logical processor and the at least one logical processor can synchronize rendering vertices stored in different buffers. For example a graphics processing scheduler which can operate similarly to an operating system scheduler can schedule GPU operations. The GPU scheduler can merge separate buffers of vertices into the correct execution order such that the graphics processing unit of the client executes the commands in an order that allows them to be rendered correctly.

One or more threads of a process such as a videogame may map multiple buffers and each thread may issue a draw command. Identification information for the vertices e.g. information generated per buffer per vertex or per batch of vertices in a buffer can be sent to the GPU scheduler . The information may be stored in a table along with identification information associated with vertices from the same or other processes and used to synchronize rendering of the various buffers.

An application such as a word processing program may execute and declare for example two buffers one for storing vertices for generating 3D menus and the other one storing commands for generating letters that will populate the menus. The application may map the buffer and issue draw commands. The GPU scheduler may determine the order for executing the two buffers such that the menus are rendered along with the letters in a way that it would be pleasing to look at. For example other processes may issue draw commands at the same or a substantially similar time and if the vertices were not synchronized vertices from different threads of different processes could be rendered asynchronously on the client thereby making the final image displayed seem chaotic or jumbled.

A bulk compressor can be used to compress the graphics primitives prior to sending the stream of data to the client . In an embodiment the bulk compressor can be a user mode not shown or kernel mode component of the stack instance and can be configured to look for similar patterns within the stream of data that is being sent to the client . In this embodiment since the bulk compressor receives a stream of vertices instead of receiving multiple API constructs from multiple applications the bulk compressor has a larger data set of vertices to sift through in order to find opportunities to compress. That is since the vertices for a plurality of processes are being remoted instead of diverse API calls there is a larger chance that the bulk compressor will be able to find similar patterns in a given stream.

In an embodiment the graphics processing unit may be configured to use virtual addressing instead of physical addresses for memory. Thus the pages of memory used as buffers can be paged to system RAM or to disk from video memory. The stack instance can be configured to obtain the virtual addresses of the buffers and send the contents from the virtual addresses when a render command from the graphics kernel is captured.

An operating system may be configured e.g. various subsystems and drivers can be loaded to capture primitives and send them to a remote computer such as client . Similar to that described above a session manager can be executed by a logical processor and a session that includes certain remote components can be initialized. In this example the spawned session can include a kernel a graphics kernel a user mode display driver and a kernel mode display driver .

A graphics kernel may schedule GPU operations. The GPU scheduler can merge separate buffers of vertices into the correct execution order such that the graphics processing unit of the client executes the commands in an order that allows them to be rendered correctly.

All of these variations for implementing the above mentioned partitions are just exemplary implementations and nothing herein should be interpreted as limiting the disclosure to any particular virtualization aspect.

The process of compressing encoding and decoding graphics data as referred to herein may generally use one or more methods and systems described in commonly assigned U.S. Pat. No. 7 460 725 entitled System And Method For Effectively Encoding And Decoding Electronic Information hereby incorporated by reference in its entirety. The process of transporting such data may incorporate techniques described in U.S. patent application No. 12 364 520 now U.S. Pat. No. 8 228 800 entitled Optimized Transport Protocol For Delay Sensitive Data Attorney Docket No. 325618.01 .

In various methods and systems disclosed herein improvements to the transmission of remote presentation graphics data to a client computer may be implemented to provide a more timely and rich user experience. The embodiments disclosed herein for encoding and transmitting graphics data may be implemented using various combinations of hardware and software processes. In some embodiments functions may be executed entirely in hardware. In other embodiments functions may be performed entirely in software. In yet further embodiments functions may be implemented using a combination of hardware and software processes. Such processes may further be implemented using one or more CPUs and or one or more specialized processors such as a graphics processing unit GPU or other dedicated graphics rendering devices.

In remote desktop scenarios the graphics content of a user s desktop located on a host computer e.g. the server is typically streamed to another computer e.g. the client . The server and the client will exchange the desktop graphics data in a well defined protocol or format. Microsoft s Remote Desktop Protocol RDP is an example of such a protocol. The RDP protocol is a stream oriented application layer protocol that may use a stream based transport layer protocol such as the Transmission Control Protocol TCP for exchanging data with the client. In the following discussion we define application latency or application delay for a portion of the stream as the latency experienced by the application layer protocol in receiving that portion of the stream. This can be defined to be the time difference between when the application wishes to send the portion to when the receiving application receives that portion. We define transmission latency as the latency experienced by individual packets sent by the transport protocol. Transmission loss loss or loss rate refers to the probability of that packets sent by the transport protocol will be lost. Protocols such as the TCP protocol typically exhibit high application latency when the underlying transport is a wide area network WAN connection with high transmission latency and loss. If such a link is used for RDP traffic such application latencies may result in a negative user experience because the desktop graphics data may be delivered to the client in a time delayed fashion.

Accordingly when providing a remote presentation session with a client computer using a protocol such as RDP in some scenarios it may be desirable to execute the protocol over a lossy transport. For example when a particular high latency link is experiencing a high loss rate the use of some stream based protocols such as TCP may result in a significant delay. In such protocols when data packets are not properly received or lost the lost data packets must be retransmitted before progress can be made in the processing of the received data. Thus in such cases it may be advantageous to use a lossy datagram transport mechanism rather than a streaming lossless transport mechanism. Lossy protocols can be any type of protocol that may generally be characterized as protocol with lossy semantics. Such protocols may not provide verification of delivery retransmission of lost data and implied or explicit ordering of data packets. Such protocols may also be referred to as a datagram protocol. By being able to transmit data on a lossy datagram protocol much of the delay caused by recovery mechanisms for lost packets may be avoided. In various embodiments disclosed herein methods are described that address the above issues by providing a loss tolerant graphics exchange protocol and thus allowing the use of a non stream based protocol such as User Datagram Protocol UDP .

In one embodiment a UDP connection may be provided for transmitting the graphics data. depicts a connection between a remote presentation server and a remote client . In typical remote presentation configurations the client and the server exchange information through the lossless transport . Such information may comprise both control and graphics data. In an embodiment a lossy transport is added to the connection between the client and the server. The lossy transport may be used to exchange the graphics data. The lossless transport may be used for control type data such as a list of encryption keys or bitmap cache confirmation. In other embodiments only the lossy transport may be used for the connection between the client and the server.

As mentioned previously in a remote virtual desktop environment graphics data is typically rendered on the host partition and transferred to the client using remote presentation protocols such as RDP after some form of compression is applied to the data. Graphics data typically consists of various elements that may have different tolerances to data loss and transmission delays. In addition the overall remote desktop experience may include other elements with differences in their requirements for delivery reliability and transmission delays. Examples of such display and experience elements include 

In an embodiment a link characteristics detector may be provided that continuously monitors the link between the client and server for characteristics such as available bandwidth end to end latency and data loss. The link characteristics detector may also ensure that the measurements are performed such that they take into account the data flowing through all the channels between the client and server. This data may then be provided to the channel manager to optimize the channels currently in use or subsequently opened.

A link characteristics detector may incorporate some of the functionality described in common assigned U.S. patent application No. 12 719 669 Attorney Docket MVIR 0626 filed on Mar. 8 2010 hereby incorporated in its entirety.

On a high latency lossy network typically found in WAN situations the real time interactive remote presentation experience using a remote presentation protocol such as RDP over TCP IP may not provide an adequate user experience. In various embodiments a remote presentation protocol may use a transport stack based on a lossy protocol such as UDP combined with forward error correction FEC to provide improvements to the user experience when using remote presentation services such as the remoting of desktops.

In an embodiment a remote presentation data stream may be transmitted over a bi directional datagram based transport that supports data and feedback encoding packet loss detection packet retransmission forward error correction and rate control. Such a transport may provide lossless and in order data delivery based on re transmission and FEC. Alternatively the transport can be lossy and include a capability to report lost packets to the remote presentation layer.

In a preferred embodiment a datagram based bi directional transport may be provided that incorporates dynamic detection and adjustable forward error correction to reduce latency on a high loss and high latency network. The transport interface may support 100 lossless and in order data delivery or partially lossy data delivery. The transport may be integrated as part of a remote presentation protocol stack for either the entire data stream or a portion of the data stream.

Packet delays typically consist of one or more of time spent in the sender queue network propagation delay network queuing delay and time spent retransmitting or decoding FEC. Network propagation delays typically cannot be improved at the remote presentation level. Delays due to time spent in the send queue may be improved by better application rate control. Network queuing delay and time spent retransmitting or decoding FEC may be improved by modifying the transport protocol. In various embodiments the disclosed techniques may be used to improve the remote presentation performance through improvement of network queuing delay and FEC retransmission and decoding.

Remote presentation protocols are typically session level protocols that use a TCP type connection between the client and the host. The protocol typically multiplexes virtual channel data and primary graphics channel on such a connection. On a lossless high speed network TCP typically provides reliability and guaranteed delivery of the multiplexed payload meeting the response time needs of interactive bi directional traffic.

On a WAN when round trip time exceeds 50 ms and where packet losses exceed 1 2 a TCP type connection may exhibit one or more of the following issues 

Such issues may cause graphics channel artifacts such as tearing and jitter affecting quality of the user experience and delays exceeding the physical link round trip times. To improve the user experience using a remote presentation protocol over a high loss and high latency WAN the remote presentation protocol may be integrated with a datagram based transport. In one embodiment such an integrated protocol may be configured to support 

The transport layer may be integrated into both the server and client and may provide the following capabilities 

Referring to the transmission of data packets from one computer over the network to another computer can be delayed for a variety of reasons. The network can be inherently lossy resulting in transmitted data packets either being lost in the network before they reach their destination or being corrupted when they reach their destination. Consequently the lost or corrupted data packets would have to be retransmitted over the network. Exemplary networks which are inherently lossy may include for example wireless networks and networks comprising malfunctioning routers. The network can also experience congestion due to bandwidth limitations in the network resulting in data packets having to be queued on the sending computer before an opportunity to transmit them over the network. Significant network congestion can also result in transmitted data packets being lost in the network due to factors such as router queue overruns and the like. These packet transmission delays are exacerbated in situations where the data packets are generated by their source application in a bursty manner.

In various embodiments a packet transmission flow control function may be provided that reduces transmission delays associated with transmitting original data packets generated by the local application over a network to a remote application based on the current state of the network. The transmission flow control function may reduce network congestion and related original data packet transmission delays that can occur when the original data packets are transmitted over the network at a rate which exceeds the network s currently available bandwidth. Accordingly the transmission flow control function may also reduce the round trip time RTT for transmitting each original data packet.

In another embodiment a hybrid rate plus window based congestion protocol which controls the rate of packet transmission into the network may be implemented. Such a hybrid rate plus window based congestion protocol may provide low queuing delay near zero packet loss fair allocation of network resources among multiple flows and full link utilization. The hybrid protocol may use congestion window to control the maximum number of outstanding bits a transmission rate to control the rate of packets entering the network packet pacing a queuing delay based rate update to control queuing delay within tolerated bounds and minimize any packet loss aggressive ramp up graceful back off to fully utilize the link capacity and provide fairness among multiple flows.

Existing congestion control protocols are typically window based or delay based. Window based protocols have the advantage that even with the use of aggressive ramp up strategies the sending rate does not exceed the link capacity by more than 2 at any given moment since the sender can only send more packets once an ACK or NACK timeout . However since window based protocols can send a full burst of packets at once some packets suffer a large queuing delay. Thus the congestion detection thresholds and the actual maximum queuing delay achieved is usually no less than the round trip time RTT . For some applications e.g. VoIP conferencing interactive software applications this may not be tolerable. In addition if the network router buffers have memory equal to the bandwidth delay product of the network such congestion control protocols may produce packet loss even if they respond to delay signals such as TCP Vegas or FAST TCP .

Rate based protocols on the other hand can directly control the rate of packet transmission. However care must be taken in not ramping up the rate too aggressively otherwise they can result in oscillatory behavior or even packet loss. In an embodiment a joint window plus rate based protocol may be provided. The use of a window provides the advantages of a window based protocol. However to prevent all packets from going out at once the packets may be paced using a transmission rate. The use of pacing may result in very low queuing delay depending on the congestion detection thresholds and practically zero packet loss.

However the use of a low congestion detection threshold may result in potential link under utilization if the congestion detection threshold in units of time is less than the round trip time RTT of the link. For example the same problem may occur with TCP when network router buffer size as measured in units of time is less than the RTT. This may occur in high bandwidth delay product networks since even a relatively large amount of network router buffer memory in units of bits is small in units of time. For example a 100 Mb buffer with network capacity of 2 Gbps will only be a 100 2000 50 ms buffer. If the link RTT is 100 ms then this will result in link under utilization even if the system does not back off until congestion induced packet loss takes place.

If it is assumed that the queuing delay thresholds are set in the range of 10 20 ms then so long as the RTT is larger than the threshold link under utilization may occur. One solution is to simply ramp up more aggressively when far from congestion and reduce the ramp when congestion approaches. Similarly once congestion is encountered back off may be less aggressive when congestion is mild and back off may be more aggressive once congestion level is high. The congestion level is typically found using queuing delay as a metric to determine when congestion may occur.

By considering these factors full link utilization may be achieved. So long as rate updates are performed using an additive increase multiplicative decrease AIMD manner fairness across multiple flows can be achieved. In addition the rate control update may be performed using a three zone scheme. The congestion level may be classified based upon average queuing delay queuing delay trend and packet loss. The transmission rate may be updated depending on which zone is currently active so as to keep queuing delay tightly controlled within some desired bound. Queuing delay may be computed so as to not be sensitive to clock offset or clock skew aka clock drift .

A goal of a congestion control protocol is to control the transmission rate so that sent packets suffer minimal network queuing delay and loss caused by congestion while sustaining throughput close to the available network bandwidth and ensure fair sharing of network resources. Most congestion control protocols use an additive increase multiplicative decrease AIMD scheme to adjust the transmission rate R or window W at the nth time instant using

AIMD control schemes have the property that they guarantee fairness regardless of network state. Details of an AIMD scheme include its definitions of congestion amount to increase and amount to decrease . Congestion may be defined in terms of loss delay and explicit congestion congestion notification signals if present . Thus an AIMD scheme may be used from a TCP variant as the base for congestion control. The congestion control strategy may be characterized by the following objectives.

Fast adaptation to available bandwidth Since it is desirable to tolerate small queuing delays smaller than RTT and buffer size the function may ramp up quickly to prevent link under utilization.

Sensitive to network delay To reduce queuing delay and packet loss the function may use queuing delay as an indicator of congestion to control the rate.

Based on the above objectives a congestion control function may be provided that is characterized by one or more of the following.

Rate based Use a combination of rate based plus window based congestion control to introduce packets at a relatively steady rate into the network. This leads to a more steady network behavior in terms of delay which is needed to obtain accurate queuing delay measurements.

Fast ramp up The function may ramp up aggressively when far from congestion using queuing delay as an indicator of how far the current state is from congestion.

Graceful back off Instead of backing off by a constant factor when congested the function may back off based on the level of congestion. When entering congestion the back off may not be as aggressive as when heavily congested as indicated by queuing delay .

Delay constrained congestion detection The definition of congestion may be modified so that queuing delay can be accurately controlled within some desired range. The protocol may operate on epochs of length L that are defined to be units of time equal to the estimated round trip propagation time the minimum RTT seen so far . At the end of each epoch the epoch length is updated the congestion level classified into one of three zones as described below and the transmission rate updated as described below. The window plus rate based rate control is performed as described below.

Instead of simply defining congestion as a binary event congestion or no congestion in an embodiment a more continuous definition of congestion level may be used using both packet loss and one way delay OWD . An estimate of the current queuing delay may be computed by taking an average of the relative one way delay ROWD measurements of all packets which have been acknowledged in the previous epoch which just ended. The relative one way delay is computed as ROWD OWD OWD where OWD is the actual one way delay computed as the received time using the receiver s clock minus the sent time using the sender s clock. OWDis the minimum OWD value seen so far. Although OWD is sensitive to clock offset ROWD is not since OWDis an estimate of the propagation delay plus the clock offset. To prevent ROWD measurements from being sensitive to clock drift where one clock is running faster than the other OWDcan be taken to be the minimum over some window of measurements rather than the true minimum seen so far. Let avg ROWD be the estimate of the queuing delay. The congestion level may be classified into one of the following three zones.

If packets are being properly paced an increasing OWD trend means buffers are building up and thus implies congestion. The congestion control protocol strives to stay in Zone 1 and Zone 2 and thus the typical queuing delay seen is between d1 and d2. By appropriately choosing d1 and d2 and accounting for typical propagation delay seen on the link the end to end delay due to the network can be controlled. Delays larger than d2 will only be seen when new flows enter.

TCP uses window based congestion control in which the window size defines the maximum number of bits that can be outstanding. The protocol is allowed to transmit a packet so long as the number of outstanding bits F is less than the window size W . The outstanding bit count increases whenever a new packet is sent and reduces once the packet is acknowledged ACK or once the packet times out NACK . However in media streaming applications rate based congestion control is frequently used. In such applications the application controls the transmission rate directly. The sender is allowed to send packets at the rate of R bits second regardless of the outstanding bit count.

An advantage of window based congestion control is its self clocking behavior since the sender is not able to increase the sending rate too fast if packets are suffering a large queuing delay since the outstanding bit count only reduces on ACK or NACK . Windows based congestion control can send out a burst of packets with bursty applications. Though for small bursts this can result in packets potentially having a lower end to end delay since they do not incur pacing delay for a large burst of packets some packets can experience a large queuing delay and even packet loss since the instantaneous sending rate can be much larger than the average.

In an embodiment window based congestion control may be combined with a rate based congestion control scheme. For example a window may be used to control the maximum number of outstanding bits and also control the rate at which packets can enter the network using a transmission rate. The transmission rate R in bits sec is the quantity which is directly adjusted based on congestion signals and a window of size W RL in bits is used to control the maximum number of outstanding bits where L is the epoch length.

In a pure rate based scheme if a packet of size P bits is sent then with a transmission rate of R the next packet may only be allowed after P R seconds. In a pure window based scheme the packet may be sent immediately so long as FT P R and if F

At the end of every epoch the transmission rate R and window W may be updated based on the congestion classification. The direction of change is determined using the zone classification defined above. Instead of updating the window the transmission rate is directly updated using

 for dand decays to by the Zone 1 boundary d. is given by the following if no packet loss is encountered 

A method for computing queuing delay which is insensitive to clock offset and clock drift is now described. Suppose the sender records packet n as leaving the sender at time s using the sender clock and then the receiver records the time the packet is received as r using the receiver clock. The receiver sends back this information time received to the sender. The sender then can compute packet n as having a one way delay OWD r s . OWD includes network propagation delay network queuing delay as well as clock offset between receiver and sender. Since the propagation delay is assumed to be a constant p and if it is assumed that the clock offset is a constant c and if it is assumed that the minimum OWD seen so far OWD min is from the state when queuing delay was zero then we can compute the relative one way delay and assume it to be the queuing delay call it q as ROWD OWD OWD min since q p c q p c . However if the protocol is running for a long time the clock drift can become significant i.e. c is not a constant but changes over time.

In one embodiment a method can keep track of two minimum OWD values OWD min1 and OWD min2 . Let OWD min1 be the minimum OWD seen from some time t to the current time call it t . Thus OWD min1 is easy to compute since it just involves an update of the form OWD min1 min OWD min1 r s . Let OWD min2 be the minimum OWD seen from some other time t where t t to the current time. The method may use ROWD OWD OWD min1 until the current time t exceeds some threshold call it t . Until t we use the value OWD min1 as the base. At t the method can switch to using OWD min2 as the base i.e. ROWD OWD OWD min2 and then set OWD min1 to be the current value. The method may keep updating both OWD min1 and OWD min2 and alternate between using one or the other as the base. This is done as shown in .

Referring to the white bars indicate OWD min1 and the gray bars indicate computation of OWD min2. From time t to time t OWD min1 which is being computed as minimum from t to the current time is used as the base to compute ROWD. During this time OWD min1 is the minimum of t t up to t t seconds of samples. Then OWD min1 is reset at time t. However by this time OWD min2 is the minimum of t t seconds of samples and thus it is used as the base until t. For example suppose t 0 t 30 t 60 and t 90. Then the base being used is the minimum of at least 30 seconds of samples and no more than the minimum of 60 seconds of samples.

In various embodiments a packet encoding function may be provided that dynamically determines for each output packet to be transmitted over the network at each transmission opportunity whether the output packet will be a forward error correction FEC packet. If it is determined that the output packet will be an FEC packet the packet encoding function may dynamically determine which FEC packet to transmit. These decisions may be based on the current state of the network and minimizing the expected time until each original data packet becomes useful to the remote application on the destination computer. The packet encoding function may reduce the expected original data packet transmission delays by minimizing the need for original data packet retransmission.

Referring again to when a new communications session is established between the local application and the remote application the network s currently available bandwidth may be measured. The network s currently available bandwidth may be measured by transmitting a sequence of specialized low overhead probe packets it is noted that these are not data packets over the network to the destination computer where these probe packets were generated by a probe packets generator . It is noted that alternate embodiments are also possible wherein the network s currently available bandwidth may be measured or estimated using other known methods.

Once the packet encoding strategy has been calculated for a given transmission opportunity then based on this strategy the packet encoder may read one or more original packets from the transmit queue and form an output packet from the original packets where the output packet is subsequently transmitted over the network to the remote application. Based on the calculated packet encoding strategy the output packet can be a single original packet or an FEC packet which is formed from a linear combination of a plurality of original packets.

Output packets that are received over the network from the remote application may be input to the decoder . Each received output packet may be temporarily stored in an output packets receive queue . The received output packets may then be read from the output packets receive queue in a first in first out manner and are input to a packet decoder . The packet decoder may attempt to decode each received output packet and extract the one or more original packets included therein. Original packets which are successfully extracted may subsequently be delivered to the local application.

When the destination computer successfully receives a particular output packet that was transmitted over the network from the source computer the destination computer may transmit an acknowledgement ACK packet over the network back to the source computer. The ACK packet may indicate that the particular output packet was successfully received by the destination computer. The ACK packet may also indicate that the particular output packet is considered lost since a later output packet was successfully received by the destination computer. The ACK packet can also indicate if the particular output packet was received out of order. ACK packets that are received over the network from the destination computer are input to a feedback generator . The feedback generator processes the ACK packets to routinely compute the round trip time and a one way packet transmission delay indicator at a prescribed interval where this delay indicator specifies if the one way packet transmission delay is increasing decreasing or unchanged. The feedback generator maintains a history of computed round trip times and delay indicators and also routinely computes at the prescribed interval a median round trip time over a prescribed congestion window. The feedback generator provides the ACK packets the computed round trip times the computed delay indicators and the computed median round trip times to the packet transmission strategy calculator as part of the aforementioned feedback .

The encoding strategy function may employ an adaptive FEC method wherein for each transmission opportunity the source computer may dynamically determine for each output packet to be transmitted over the network whether the output packet will be an FEC packet or a single original packet.

If it is decided that the output packet will be an FEC packet the packet encoding function may dynamically determine which FEC packet to transmit. These decisions are based on minimizing the expected time until each original data packet becomes useful to the remote application on the destination computer and take into consideration the current state of the network and the current transmission status of each original packet generated by the local application.

The adaptive FEC function may reduce congestion in the transmit queue of the encoder . Referring again to upon each transmission opportunity the source computer s packet transmission strategy calculator groups the sequences of original packets generated by the local application into the following four different sets where the grouping is based on the current transmission status of each original packet . The first set comprises original packets which have already been formed into output packets by the packet encoder and transmitted over the network to the destination computer at various transmission opportunities and are definitively known to have been successfully received by the destination computer. The second set comprises original packets which have already been formed into output packets by the packet encoder and transmitted over the network to the destination computer at various transmission opportunities and are definitively known to have not been successfully received by the destination computer due to having been lost or corrupted during their transmission over the network.

Referring again to the third set comprises original packets which have already been formed into output packets by the packet encoder and transmitted over the network to the destination computer at various transmission opportunities but no definitive information is known regarding whether or not these original packets have been successfully received by the destination computer. Original packets in this third set are assumed to still be in flight. The fourth set comprises original packets which have not yet been formed into output packets and transmitted over the network to the destination computer.

Upon each transmission opportunity the source computer s packet transmission strategy calculator uses the information it has regarding the current state of the network and the current transmission status of each original packet generated by the local application i.e. which if any original packets are in the first second third and fourth sets described above to dynamically decide how the next output packet to be transmitted over the network will be formed. This decision may be made as follows.

When there are no original packets in the second set third set or fourth set at the current transmission opportunity i.e. all of the original packets generated by the local application have been successfully received by the remote application the strategy calculator simply instructs the packet encoder to form no output packet i.e. nothing would be transmitted at the current transmission opportunity . In the unlikely event that there are one or more original packets in the second set at the current transmission opportunity the strategy calculator can instruct the packet encoder to form the next output packet from one particular original packet in the second set i.e. the output packet transmitted at the current transmission opportunity would comprise a retransmission of a particular original packet which was lost during its previous transmission over the network .

When there are no original packets in the third set but there are one or more original packets in the fourth set at the current transmission opportunity the source computer s packet transmission strategy calculator instructs the packet encoder to form the next output packet from the next original packet in the fourth set. Whenever there are no original packets in the fourth set but there are one or more original packets in the third set at the current transmission opportunity the source computer s packet transmission strategy calculator instructs the packet encoder to form the next output packet as an FEC packet. Whenever there are one or more original packets in both the third and fourth sets at the current transmission opportunity the strategy calculator computes a first sum of expected packet transmission delays for the original packets in the third and fourth sets over a prescribed number N of succeeding transmission opportunities based on the assumption that the next output packet is formed as an FEC packet. The strategy calculator also computes a second sum of expected packet transmission delays for the original packets in the third and fourth sets over the prescribed number N of succeeding transmission opportunities based on the assumption that the next output packet is formed from the next original packet in the fourth set.

In one embodiment of the packet encoding strategy function after the first and second sums have been computed the strategy calculator compares the first and second sums. Whenever the first sum is less than the second sum the strategy calculator instructs the packet encoder to form the next output packet as an FEC packet. Whenever the first sum is equal to or great than the second sum the strategy calculator instructs the packet encoder to form the next output packet from the next original packet in the fourth set.

In another embodiment after the first and second sums have been computed the strategy calculator may compute a first probability of the first sum being smaller than a prescribed threshold. The strategy calculator then computes a second probability of the second sum being smaller than the prescribed threshold. The strategy calculator then compares the first and second probabilities. Whenever the first probability is greater than the second probability the strategy calculator instructs the packet encoder to form the next output packet as an FEC packet. Whenever the first probability is equal to or less than the second probability the strategy calculator instructs the packet encoder to form the next output packet from the next original packet in the fourth set.

Although transmitting an output packet comprising an FEC packet at the current transmission opportunity can reduce the transmission delay for original packets in the third set this could have an effect of increasing the transmission delay for original packets in the fourth set. On the other hand if an output packet comprising the next original packet in the fourth set is transmitted at the current transmission opportunity this could have an effect of increasing the transmission delay for original packets in the third set. The strategy calculator weighs these two effects against each other based on the current content of the third and fourth sets and determines the optimal type of output packet to transmit over the network at each transmission opportunity in order to minimize the expected transmission delays due to packet loss and congestion in the network. Although the aggressive ramp up in the rate of transmission can result in the source computer transmitting output packets at a rate which overshoots the network s currently available bandwidth and thus can result in an increase in the network s packet loss rate due to congestion in the network the transmission of output packets comprising FEC packets can compensate for such packet loss. As the network s packet loss rate decreases due to a reduction of congestion in the network the probability of the strategy calculator deciding that an output packet will be an FEC packet will generally also be reduced.

The transport function may consist of two components. One component is the congestion control component which estimates the available bandwidth in the communications channel determines the current sending rate and backs off reduces sending rate when congestion is detected. It tries to find a fair share of the bandwidth for the sending application while trying to minimize self congestion induced loss and queuing delay. The hybrid FEC ARQ protocol disclosed herein can operate with many existing congestion control modules e.g. TFRC rate control. The second component may be a transmission strategy component that determines which type of packet to send at each transmission opportunity.

Since delay is an important factor in determining the perceived user performance of interactive applications the transport module may reduce the expected delay incurred by each packet while ensuring reliable in order delivery. The delay incurred by the packets has several components e.g. waiting time in the sender s queue propagation delay network queuing delay retransmission delay and decoding delay if a coding scheme is used. The requirement of in order delivery can also cause additional delay as a packet may need to wait for prior missing packets to be delivered or decoded.

For the following discussion original packets may be defined as the data packets which the application wishes to send from the sender to the receiver. For a stream with an in order reliable delivery requirement original packet i is defined to be sequentially decodable i.e. usable if and only if it and all prior packets j i are delivered or decoded. Let sequential decodability delay SDD refer to the time span between when a packet enters the sender queue from the application to the time it becomes sequentially decodable. This is the delay that is important for interactive applications. Let coded packets refer to the packets that actually enter the network. These packets can be original FEC packets or resent packets. Let transmission delay be the delay sending these coded packets from the sender to the receiver. This delay consists of the network propagation delay and queuing delay. The SDD on the original packets is a function of transmission delay incurred by the coded packets as well as loss rate suffered by the coded packets and the coding strategy being used.

The transmission strategy can send one of three types of packets original packet FEC packet or resent packet. The FEC packets consist of linear combinations over a Galois field of existing unacknowledged undecodable packets in the sender queue. Let x l be the lth original source packet which is represented as a vector of bytes each of which is an element in GF 2 . Then if y k is the kth packet sent from the sender to the receiver it can be written as

At any given transmission opportunity the cost used to decide amongst the various policies is used to minimize the expected SDD. The following terms which are defined.

It may be assumed that the congestion control module achieves a smooth transmission rate and queuing delay. Thus k 1 k T the time between successive transmission opportunities is relatively constant and k transmission delay is stable and approaches the network propagation plus queuing delay . Then rearranging terms above 1 we get

To simplify further the method may only consider source packets starting from l B n all other packets have already been decoded and ending at E n which is the last packet entering the sender queue. The method may also consider other packets past E n that will enter the sender s queue but this will be application specific. For each packet n the method may only consider certain terms in the summation over k. For packets which currently have non zero probability of decidability p n 1 0 the method may only consider the first term in the summation and for original packets which have p n 1 0 we the method may look at the first Lterms which is defined to be the expected time until pbecomes non zero. This gives 

The value for used by 5 is estimated using a sliding window of certain number of packets into the past. The loss for this window is computed and the overall loss rate is updated using 1 using some weight .

When allocating the transmission rate amongst source and FEC packets one method is to allocate some percentage of it to the needed source rate accounting for loss and make sure that the percentage of non innovative packets waste does not take more than the remainder. The waste can be computed using a deterministic term based upon feedback and a probabilistic term for the in flight coded packets those which have not been acknowledged or timed out . At a given transmission opportunity n let w be the number of packets that are known to the sender to have been useless by the receiver from feedback and let t be the total number of packets received from feedback . We can compute the expected fraction of packets which are waste more than the needed amount defined as FEC packets minus lost packets as

For any given packet that is being considered for transmitting at n the method can update the set and calculate an updated value of u. The method may control the amount of waste u to below a certain threshold U. If sending an FEC packet causes u to be above this threshold then the packet is not sent.

In an embodiment the packet queuing delay packet loss rate and OWD trend may be estimated based on said acknowledgment packets. The above operations may further comprise inputting a sequence of data packets generated by an application into a transmit queue and forming a sequence of output packets from the data packets in the transmit queue wherein each output packet comprises either a FEC packet or a single data packet based on a decision which is dynamically determined at each transmission opportunity. The FEC packet may comprise a linear combination of data packets in the transmit queue the linear combination determined over a Galois field.

The above operations may further comprise transmitting the sequence of output packets to the client computer and increasing the rate of transmission until congestion is detected. In one embodiment the linear combination may comprise a predetermined sequence of unacknowledged data packets in the transmit queue. In another embodiment the decision may use a cost function for minimizing an expected average sequential decodability delay over a number of data packets the expected sequential decodability delay computed using a probability of sequential decodability. The congestion may be detected based upon the packet queuing delay the packet loss rate and the OWD trend wherein the packet queuing delay packet loss rate and OWD trend is determined based on acknowledgement packets received from the client computer. The operations may further include the step of reducing the rate of transmission until the congestion is no longer detected.

In an embodiment the packet queuing delay and OWD trend may be estimated based on a round trip time RTT and a OWD. The packet loss rate may be estimated by computing a number of packets lost during a sliding window to compute an estimate of the current loss rate and smoothing the estimated current loss rate using an exponential weighted moving average of the current loss rate to obtain an estimate of the probability of loss rate wherein packets are declared to be lost when no acknowledgement is received within a retransmission time out RTO that is computed using RTT and the variance in RTT RTTVAR .

The congestion level may further be classified into one of three zones the three zones characterized by 1 the OWD is not increasing and the average packet queuing delay is less than a predetermined threshold 2 OWD is not increasing no packet is lost and the average queuing delay is greater than the predetermined threshold but less than an upper threshold and 3 OWD is increasing the average queuing delay is greater than the upper threshold or packet loss is accompanied by an increase in an average queuing delay. The transmission rate may be increased when the congestion level is in zone 1 the transmission rate is reduced when the congestion level is in zone 2 or zone 3 and the transmission rate is reduced at a greater rate in zone 3 than in zone 2.

In an embodiment the average packet queuing delay may be determined using a relative OWD which is a difference between an actual OWD and a minimum OWD measured over a predetermined number of OWD values and the OWD is a difference between a packet received time using a receiver clock and a sent time using a sender clock.

Any of the above mentioned aspects can be implemented in methods systems computer readable media or any type of manufacture. For example per a computer readable medium can store thereon computer executable instructions for transmitting remote presentation data from a computing device to a client computing device using a datagram based transport protocol. Such media can comprise a first subset of instructions for measuring link characteristics of a communication session between the computing device and the client computing device the communication session established using a datagram based transport protocol and a second subset of instructions for applying a forward error correction FEC mechanism to the datagram based transport protocol and adjusting an FEC injection rate based on the link characteristics . It will be appreciated by those skilled in the art that additional sets of instructions can be used to capture the various other aspects disclosed herein and that the three presently disclosed subsets of instructions can vary in detail per the present disclosure.

The foregoing detailed description has set forth various embodiments of the systems and or processes via examples and or operational diagrams. Insofar as such block diagrams and or examples contain one or more functions and or operations it will be understood by those within the art that each function and or operation within such block diagrams or examples can be implemented individually and or collectively by a wide range of hardware software firmware or virtually any combination thereof.

It should be understood that the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the disclosure or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the disclosure. In the case of program code execution on programmable computers the computing device generally includes a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may implement or utilize the processes described in connection with the disclosure e.g. through the use of an application programming interface API reusable controls or the like. Such programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

While the invention has been particularly shown and described with reference to a preferred embodiment thereof it will be understood by those skilled in the art that various changes in form and detail may be made without departing from the scope of the present invention as set forth in the following claims. Furthermore although elements of the invention may be described or claimed in the singular the plural is contemplated unless limitation to the singular is explicitly stated.

