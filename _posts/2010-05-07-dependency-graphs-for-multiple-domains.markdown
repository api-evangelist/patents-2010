---

title: Dependency graphs for multiple domains
abstract: A first dependency graph representing one or more dependencies in a first computing domain in a computer system can be generated. The first dependency graph can include a reference to an object in a second computing domain that is different from the first computing domain. A second dependency graph can be generated using the reference to the object. The second dependency graph can represent one or more dependencies in the second computing domain in the computer system, and the one or more dependencies represented in the second dependency graph can include one or more dependencies of the object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08392465&OS=08392465&RS=08392465
owner: Microsoft Corporation
number: 08392465
owner_city: Redmond
owner_country: US
publication_date: 20100507
---
A dependency graph is a data structure that represents dependencies between objects in a computer system such as in a single computing device or in a network of computing devices. Dependency graphs can be used to represent dependencies between objects that are managed by a particular type of software. For example a database server may provide a dependency graph that represents dependencies between different database objects such as different databases database tables columns in database tables etc.

The tools and techniques described herein are directed to generating dependency graphs for multiple domains. This can be useful for example where a dependency graph in a first domain includes a reference to an object in a second domain. In this situation a second graph can be generated for the second domain and that second graph can represent dependencies for the referenced object. As used herein a domain is a portion of a computer system e.g. server or set of servers in a computer network that is mapped to a metadata system. Different domains have different metadata systems that have different types of metadata and or different ways of extracting metadata. For example Windows Server file servers SQL Server database servers Oracle database servers and SQL Server Integration Service SSIS data integration subsystems in a computer network may be four different domains in the same computer system.

In one embodiment the tools and techniques can include generating a first dependency graph representing one or more dependencies in a first computing domain in a computer system. The first dependency graph can include a reference to an object in a second computing domain that is different from the first computing domain. A second dependency graph can be generated using the reference to the object e.g. by using the reference to locate an appropriate provider module and invoking the provider module to extract the second dependency graph . The second dependency graph can represent one or more dependencies in the second computing domain in the computer system and the one or more dependencies in the second computing domain can include one or more dependencies of the object i.e. one or more dependencies on the object and or one or more dependencies of the object on one or more other objects .

In another embodiment of the tools and techniques a first dependency graph representing one or more dependencies in a first computing domain in a computer system can be generated. It can be determined whether the first dependency graph includes one or more references to one or more external objects in one or more other domains. If the first dependency graph includes one or more references to one or more external objects in one or more other domains then one or more dependency graphs for one or more of the external objects from the one or more other domains can be extracted.

In yet another embodiment of the tools and techniques a first dependency graph representing one or more dependencies in a first computing domain in a computer system can be generated. A reference in the first dependency graph to a dependency on an external object outside the first domain can be identified. Additionally an extraction provider module that is configured to extract dependency graphs from a second domain can be located. The second domain can include the external object. The provider module can be invoked to extract from the second domain a second dependency graph for the external object.

This Summary is provided to introduce a selection of concepts in a simplified form. The concepts are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter. Similarly the invention is not limited to implementations that address the particular techniques tools environments disadvantages or advantages discussed in the Background the Detailed Description or the attached drawings.

Embodiments described herein are directed to techniques and tools for generating dependency graphs for multiple domains. Such improvements may result from the use of various techniques and tools separately or in combination.

Such techniques and tools may include generating a first dependency graph representing one or more dependencies in a computer system. The first dependency graph may include a reference to an external object in a second computing domain that is different from the first computing domain. For example if the first domain is a SSIS domain a task from an SSIS package in that domain may depend on a database table from a SQL Server relational database domain. If the first dependency graph includes such a reference to an external object in a second domain then a second dependency graph can be generated for the second domain and that second dependency graph can represent dependencies of that external object. The second dependency graph may or may not represent other dependencies in the second domain. For example the graph may include only dependencies of a particular database table or it may include all dependencies in a larger extraction unit e.g. a file system folder at a particular level .

One or more benefits may be realized from the tools and techniques for generating dependency graphs for multiple domains. For example database graphs for multiple domains can be generated according to the tools and techniques described herein and those graphs can be included in a central database storage. Those dependency graphs can be used in representing intra domain dependencies and inter domain dependencies. For example an overall merged graph may be generated for multiple domains. Additionally indications of the extraction points e.g. servers from which the graphs were obtained can be maintained. Accordingly access to each dependency graph can be limited to user objects that would be allowed to access the extraction point from which the graph came. As used herein a user object is a computer object that can be granted or denied access permissions. A user object may represent a user a group of users an organization a device a software module etc.

The subject matter defined in the appended claims is not necessarily limited to the benefits described herein. A particular implementation of the invention may provide all some or none of the benefits described herein. Although operations for the various techniques are described herein in a particular sequential order for the sake of presentation it should be understood that this manner of description encompasses rearrangements in the order of operations unless a particular ordering is required. For example operations described sequentially may in some cases be rearranged or performed concurrently. Techniques described herein with reference to flowcharts may be used with one or more of the systems described herein and or with one or more other systems. For example the various procedures described herein may be implemented with hardware or software or a combination of both. Moreover for the sake of simplicity flowcharts may not show the various ways in which particular techniques can be used in conjunction with other techniques.

The computing environment is not intended to suggest any limitation as to scope of use or functionality of the invention as the present invention may be implemented in diverse general purpose or special purpose computing environments.

With reference to the computing environment includes at least one processing unit and memory . In this most basic configuration is included within a dashed line. The processing unit executes computer executable instructions and may be a real or a virtual processor. In a multi processing system multiple processing units execute computer executable instructions to increase processing power. The memory may be volatile memory e.g. registers cache RAM non volatile memory e.g. ROM EEPROM flash memory or some combination of the two. The memory stores software implementing dependency graphs for multiple domains.

Although the various blocks of are shown with lines for the sake of clarity in reality delineating various components is not so clear and metaphorically the lines of and the other figures discussed below would more accurately be grey and blurred. For example one may consider a presentation component such as a display device to be an I O component. Also processors have memory. The inventors hereof recognize that such is the nature of the art and reiterate that the diagram of is merely illustrative of an exemplary computing device that can be used in connection with one or more embodiments of the present invention. Distinction is not made between such categories as workstation server laptop handheld device etc. as all are contemplated within the scope of and reference to computer computing environment or computing device. 

A computing environment may have additional features. In the computing environment includes storage one or more input devices one or more output devices and one or more communication connections . An interconnection mechanism not shown such as a bus controller or network interconnects the components of the computing environment . Typically operating system software not shown provides an operating environment for other software executing in the computing environment and coordinates activities of the components of the computing environment .

The storage may be removable or non removable and may include non transitory computer readable storage media such as magnetic disks magnetic tapes or cassettes CD ROMs CD RWs DVDs or any other medium which can be used to store information and which can be accessed within the computing environment . The storage stores instructions for the software .

The input device s may be a touch input device such as a keyboard mouse pen or trackball a voice input device a scanning device a network adapter a CD DVD reader or another device that provides input to the computing environment . The output device s may be a display printer speaker CD DVD writer network adapter or another device that provides output from the computing environment .

The communication connection s enable communication over a communication medium to another computing entity. Thus the computing environment may operate in a networked environment using logical connections to one or more remote computing devices such as a personal computer a server a router a network PC a peer device or another common network node. The communication medium conveys information such as data or computer executable instructions or requests in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired or wireless techniques implemented with an electrical optical RF infrared acoustic or other carrier.

The tools and techniques can be described in the general context of computer readable media. Computer readable media are any available media that can be accessed within a computing environment. By way of example and not limitation with the computing environment computer readable media include memory storage and combinations of the above.

The tools and techniques can be described in the general context of computer executable instructions such as those included in program modules being executed in a computing environment on a target real or virtual processor. Generally program modules include routines programs libraries objects classes components data structures etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer executable instructions for program modules may be executed within a local or distributed computing environment. In a distributed computing environment program modules may be located in both local and remote computer storage media.

For the sake of presentation the detailed description uses terms like determine choose adjust and operate to describe computer operations in a computing environment. These and other similar terms are high level abstractions for operations performed by a computer and should not be confused with acts performed by a human being unless performance of an act by a human being such as a user is explicitly noted. The actual computer operations corresponding to these terms vary depending on the implementation.

The dependency extractor can interact with a first provider module to extract dependency graphs from a first domain . For example the first domain may include a first extraction point and a second extraction point that are both Microsoft SQL Server database servers. The first provider module can be configured to receive requests from the dependency extractor for dependency graphs in the first domain i.e. the SQL Server domain in this example which may include all the SQL Server database servers in the environment . The first provider module can also be configured to retrieve dependency metadata from the extraction points and in the first domain . For example the first provider module may communicate with the extraction points and in the first domain with network messages API calls dedicated connections etc. as is appropriate for the types of extraction points in the first domain . The first provider module can also be configured to generate a dependency graph by translating dependency metadata to a form that can be processed by the dependency extractor e.g. a form that can be transmitted to the dependency extractor using an application programming interface that is exposed by the dependency extractor .

The dependency extractor can also manage extraction of dependency graphs from other domains. As is illustrated in the dependency extractor can invoke a second provider module to extract dependency metadata from a second computing domain which can include a third extraction point and a fourth extraction point . The dependency extractor can also invoke a third provider module to extract dependency graphs from a third domain which can include a fifth extraction point . Of course the dependency extractor could interact with more or fewer domains and provider modules than are illustrated in .

Techniques for generating dependency graphs from multiple domains will now be discussed in the context of the dependency graph generation environment of . The technique can include the dependency extractor invoking the first provider module to ask extraction points and in the first domain to identify catalog objects to be used as units of extractions. For example if the first domain is a SQL Server domain then the catalog objects may be databases in the first domain . As another example if the first domain is a SSIS data integration subsystem the catalog objects may be SSIS packages. The first provider module can receive the catalog objects and translate them into representations of extraction operations. Those representations can be passed to the dependency extractor and placed in the extraction operations queue . Alternatively the objects may be passed to the dependency extractor and the dependency extractor may use those objects to generate the representations of extraction operations. The representations can each include a reference to the provider module here the first provider module that can be invoked to perform the extraction of the corresponding dependency graph. Similarly representations of extraction operations for the second domain may also be included in the extraction operations queue .

Once the queue is populated with initial representations of extraction operations the dependency extractor can fetch each operation representation from the queue and invoke an appropriate provider module to perform the extraction with the scope defined in the extraction operation representation. For example if the first domain is a SQL Server domain the dependency extractor may invoke the first provider module to extract a dependency graph for a specified database from the first extraction point .

Each extracted dependency graph can be processed to determine whether external objects from other domains i.e. domains other than the domain from which the dependency graph was extracted are included in the graph. For example a dependency graph extracted from a particular domain or can be parsed by the corresponding provider module or to identify references to external objects that do not belong to the domain for that provider module or .

If such external object references are found they can be used to generate addition extraction operation representations which can be executed to extract additional dependency graphs which may reveal new dependencies of those objects in their native domains. For example a first database table in one database domain may depend on a second database table in a second database domain and that second database table in the second database domain may in turn depend on a third database table also in the second database domain. As an example of this the two domains may be an Oracle database domain and a SQL Server database domain and a SQL Server instance may establish a linked server connection to an Oracle database. A stored procedure on the SQL Server side may use tables from the Oracle and SQL Server sides and define the dependencies between the first second and third database tables discussed above. The dependency of the first table on the third table via the second table would not be revealed by dependency graphs that only represent the first database table s native database domain. However those dependencies may be revealed by another dependency graph extracted from the second database domain that includes the second and third database tables when that second domain graph is considered along with the first domain graph that includes the second and third database tables.

As an example when a provider module or identifies a reference to an external object in a dependency graph the provider module or can mark that reference as an external reference and can pass the external reference on to the dependency extractor . Upon receiving an external reference the dependency extractor can pass the reference on to other available provider modules or and each of those other provider modules can inform the dependency extractor whether the reference is recognized as being from the domain or of that provider module or . For example if the first provider module is a SQL Server provider module then the first provider module can parse connection strings to recognize SQL Server connections. If a provider module or informs the dependency extractor that it recognizes an external reference as being from its domain then the dependency extractor can add an operation representation for the external object reference to the extraction operations queue along with an indication that the provider module or can be invoked in performing the extraction operation.

A provider that locates a reference to an external object can generate an object that identifies the external object and includes properties to assist a provider in the object s native domain in extracting dependencies of that object. That new object can be passed to the provider in the object s native domain. For example during the parsing of an SSIS package by an SSIS provider the SSIS provider may find a reference to a SQL Server object e.g. a table view or query . When this happens the SSIS provider can create a new external object and populate that new external object with properties related to the referenced external object. The new external object can be passed to a SQL Server provider. The object can be constructed in such a way that the SQL Server provider that receives the new object can understand that the new object represents a SQL Server object and can load the properties that were stored inside the new object by the SSIS provider. This can be implemented using various different protocols such as Uniform Resource Identifier URI Resource Description Framework RDF or some other standard or in house protocol implementation.

The original dependency graph that includes the external object reference can be stored in the central graph storage along with other dependency graphs . The stored graph can include a superficial reference to the external object in the other domain.

When it is time to retrieve the newly added operation representation for the external object from the queue that representation can be processed like other operation representations from the queue . This can include invoking the provider module or that recognized the external object reference as belonging to its domain. The extracted graph from the external object s native domain or can include a reference to the external object. The reference to the external object in the original graph and the reference to the external object in the graph from the external object s native domain may be used later to join those references as a single node in a common dependency graph. Such a common dependency graph can include both the original dependency graph and the dependency graph from the external object s native domain.

If there is no available extraction point from which a dependency graph can be extracted for a newly scheduled extraction operation representation that operation representation can be preserved in the queue . A common graph composed of the dependency graphs in the central storage may have a missing section in this case. However this missing section can be identified to a user as a warning of the incompleteness of the common graph. Also a warning can be issued to a system operator prompting the system operator to add a connection to the corresponding extraction point. For example a system operator may provide user input such as a user name password network address etc. to allow a provider module or to connect to the extraction point. Missing sections of a common graph may be filled up as connections are established to new extraction points in the environment . For example connections to extraction points can be managed using a subscription registry which can include connection information for extraction points. The subscription registry may be used to perform scheduled updates of the already extracted dependency graphs and connection information for new extraction points may be added to the subscription registry.

As the particular extraction point specific graphs get added to the central graph storage each of those graphs can preserve a link with or reference to the extraction point or from which it came. These links or references can be used to protect access to elements of the aggregated graph based on the extraction point or from which each element originated. Thus if a user object would not have access to an extraction point or then that user object can be denied access to dependency graph elements from that extraction point or . Accordingly low privileged users of the common graph can be denied access to parts of the common graph that represent parts of the environment that are restricted for those users.

While a particular environment has been described above the techniques and tools described herein may be used in other environments that differ from the environment of . For example the provider module structure can provide benefits such as ease of extending the environment to interact with additional domains. However a central dependency extractor may include functionality to interact with multiple domains in a system without invoking separate provider modules.

Several dependency graph generation techniques will now be discussed. Each of these techniques can be performed in a computing environment. For example each technique may be performed in a computer system that includes at least one processor and a memory including instructions stored thereon that when executed by the at least one processor cause the at least one processor to perform the technique a memory stores instructions e.g. object code and when the processor s execute s those instructions the processor s perform s the technique . Similarly one or more computer readable storage media may have computer executable instructions embodied thereon that when executed by at least one processor cause the at least one processor to perform the technique.

Referring to a dependency graph generation technique will be discussed. The technique can include generating a first dependency graph representing one or more dependencies in a first computing domain in a computer system. The first dependency graph can include a reference to an object in a second computing domain that is different from the first computing domain. The technique can also include generating a second dependency graph using the reference to the object. The second dependency graph can represent one or more dependencies in the second computing domain in the computer system and those dependencies can include one or more dependencies of the object.

Generating the second dependency graph can include determining that the second domain includes the object and extracting metadata for the second dependency graph from the second domain. Additionally generating the first dependency graph can include invoking a first provider module to extract metadata from the first domain and generating the second dependency graph can include invoking a second provider module to extract metadata from the second domain. Where the object is a first object the technique can further include passing directly or indirectly a second object from the first provider module to the second provider module where the second object can identify the first object. Moreover generating the second dependency graph can include determining whether an extraction point for the second dependency graph is available. If the extraction point is available then generating the second dependency graph can include retrieving metadata for the second dependency graph from the extraction point. If the extraction point is not available then generating the second dependency graph can include waiting until the extraction point is available to retrieve metadata for the second dependency graph from the execution point.

The technique of may further include sending the first dependency graph and the second dependency graph to a central dependency extraction module. Additionally the technique may include storing the first dependency graph and the second dependency graph in a central dependency graph storage.

The first dependency graph can include an indication that the first dependency graph came from a first extraction point in the first domain and the second dependency graph can include an indication that the second dependency graph came from a second extraction point in the second domain. Moreover the technique can further comprise limiting access to the first dependency graph to user objects that have access to the first extraction point and limiting access to the second dependency graph to user objects that have access to the second extraction point.

Referring to another dependency graph generation technique will be discussed. The technique of can include generating a first dependency graph representing one or more dependencies in a first computing domain in a computer system. The technique of can also include determining whether the first dependency graph includes one or more references to one or more external objects in one or more other domains. If so then the technique can include extracting one or more dependency graphs for one or more of the external objects from the one or more other domains. Extracting can include searching for one or more provider modules to extract dependency metadata for the one or more other domains. Extracting can also include determining whether one or more matching provider modules for extracting dependency metadata for the one or more other domains have been found. If not or even if such a provider is only found for some of the external object s then a warning may be raised such by displaying warning that informs a user of potential missing dependencies for the one or more external objects. If one or more matching provider modules for extracting dependency metadata for the one or more other domains is found then extracting can comprise including in a queue one or more elements for performing one or more extraction operations for extracting one or more dependency graphs for the one or more external objects and invoking the one or more matching provider modules to extract one or more dependency graphs for one or more of the external objects.

If one or more matching provider modules for extracting dependency metadata for the one or more other domains are found then the technique may also include storing the first dependency graph and the one or more dependency graphs for the one or more of the external objects in a central dependency graph storage repository. Additionally if one or more matching provider modules for extracting dependency metadata for the one or more other domains are found then the technique may include storing one or more indications of one or more domains that are represented by the one or more dependency graphs for the one or more of the external objects. The technique may also include limiting access to the first dependency graph to user objects that have access to an extraction point in the first domain from which the first dependency graph was extracted. Moreover if one or more matching provider modules for extracting dependency metadata for the one or more other domains is found then the technique may include limiting access to the one or more dependency graphs for the one or more of the external objects to user objects that have access to the corresponding extraction points in the other domains i.e. extraction points that include the one or more external objects .

Referring to yet another dependency graph generation technique will be discussed. In the technique of a first dependency graph can be generated . The first dependency graph can represent one or more dependencies in a first computing domain in a computer system. The technique can further include identifying a reference in the first dependency graph to a dependency on an external object outside the first domain. The technique can also include locating an extraction provider module that is configured to extract dependency graphs from a second domain which can include the external object. Moreover the technique can include invoking the provider module to extract from the second domain a second dependency graph for the external object.

Generating the first dependency graph can include invoking a provider module for extracting the first dependency graph from the first domain. The first dependency graph can include an indication that the first dependency graph came from a first extraction point in the first domain and the second dependency graph can include an indication that the second dependency graph came from a second extraction point in the second domain. Also the technique can further include limiting access to the first dependency graph to user objects that have access to the first extraction point and limiting access to the second dependency graph to user objects that have access to the second extraction point. The acts can also include storing the first dependency graph and the second dependency graph in a central dependency graph storage.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

