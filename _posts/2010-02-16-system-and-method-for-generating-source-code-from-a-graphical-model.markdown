---

title: System and method for generating source code from a graphical model
abstract: A graphical user interface that enables a user to create and specify the properties of custom storage classes is disclosed. The characteristics of each storage class are specified via parameter settings accessible from the graphical interface. Each custom storage class designed through the interface is defined by a combination of parameter settings. A code preview window in the graphical interface displays salient aspects of the source code references to model data given the selected parameter settings. The display is shown dynamically and adjusted to reflect subsequent changes in parameter settings.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08504983&OS=08504983&RS=08504983
owner: The MathWorks, Inc.
number: 08504983
owner_city: Natick
owner_country: US
publication_date: 20100216
---
The present application is a continuation of U.S. application Ser. No. 10 698 820 entitled System and Method for Generating Source Code from a Graphical Model filed Oct. 31 2003 which is related to a United States Patent Application entitled Generating Code For Data References U.S. patent application Ser. No. 09 876 487 the contents of which are hereby incorporated by reference.

The illustrative embodiment of the present invention relates generally to the use of custom storage classes in a graphical model and more specifically to the use of a graphical user interface to select parameters for custom storage classes used in the automatic generation of source code from a graphical model and the display of that generated code.

Automatic code generation is a process whereby software source code is automatically produced from a graphical model. The software source code produced by the automatic code generation process may be compiled and then executed on a digital computer or other electronic device implementing the functionality specified by the model. The graphical model being studied may contain many different types of data references. Data may be used to represent the states of the system as well as the flow of matter energy or information between system components. Each item of data in the model is defined to have a data storage class. Data is in turn represented in the generated software source code in a manner that is prescribed by its storage class. The software source code references data in a number of different ways including defining data declaring data initializing data reading a value of data assigning the value of data and the choice of storage class controls how each of these references are generated.

Code generators may provide predefined sets of storage classes and they may also permit the user to define new custom storage classes with user defined characteristics. The custom storage class provides a central point for software code generation of a set of objects since changes to the unique set of instructions defining a custom storage class collectively apply to the potentially large set of data of that class. Common software engineering practices that may be enabled with custom storage classes include embedding a data item in a bit field embedding a data item in a structure embedding a data item in a union using platform specific declarations in the data declaration defining the scope and storage of the data declaring data using arbitrary C types and accessing data through function calls.

Unfortunately it is often difficult to create a custom storage class. Conventional methods of creating custom storage classes for use with an automatic code generator require the use of programmatic callbacks that interface to the lower levels of the code generator architecture. The writing of the programmatic callbacks requires an in depth knowledge of the workings of the automatic code generator. The required level of knowledge regarding the automatic code generator is often lacking for many users as is the desire to write the programmatic callbacks.

The illustrative embodiment of the present invention provides a graphical user interface that enables a user to create and specify the properties of custom storage classes. The characteristics of each storage class are specified via parameter settings accessible from the graphical interface. Each custom storage class designed through the interface is defined by a combination of parameter settings. A code preview window in the graphical interface displays the source code references to model data given the selected parameter settings. The display is shown dynamically and adjusted to reflect subsequent changes in parameter settings.

In one embodiment in an electronic device with a graphical modeling and execution environment that includes at least one graphical model a method provides a user interface which has different user selectable parameter settings for a custom storage class. The custom storage class specifies the manner in which an automatic code generator creates source code for data referenced by a graphical model. Following the selection of parameters through the interface a custom storage class is created using the selected parameters.

In another embodiment in an electronic device having a modeling and execution environment that includes at least one graphical model a system includes a user interface with different selectable parameter settings for a custom storage class. The custom storage class specifies the manner in which an automatic code generator creates source code from the model. The system also includes a custom storage class created utilizing parameters selected by a user from the user interface and a view of code generated by the automatic code generator utilizing the user selected parameters.

The illustrative embodiment of the present invention provides a user interface displaying user selectable parameter settings to be used in the creation of a custom storage class. The custom storage class is utilized by an automatic code generator in a modeling and execution environment to create source code referencing data from a graphical model. Salient aspects of the generated source code are displayed to the user in a code view area of the user interface. Subsequent alterations in the user selected parameters cause a regeneration of the displayed source code and an update of the display of this new code to the user.

The electronic device is interfaced with a display . The display includes a user interface generated by the modeling and execution environment . The user interface which is accessible by a user through an input device such as a mouse includes user selectable parameter settings and . The user selectable parameter settings and are parameters for use in the creation of a custom storage class and are discussed in more detail below. The user selectable parameter settings and may be represented on the user interface in a number of ways including through the use of conventional user interface controls such as radio buttons check boxes or text boxes able to accept textual input specifying a parameter value. The user selectable parameters are utilized by the automatic code generator to create a custom storage class. The custom storage class is then utilized by the automatic code generator the create source code referencing data for the graphical model . The user interface also includes a code view area where the automatic code generator may display salient aspect of the source code created from the use of the custom storage class.

Those skilled in the art will recognize that the environment depicted in is just one of many environments falling within the scope of the present invention. For example the various components depicted in may be dispersed over a distributed network. Thus the user and the display may be located remotely from a server holding the modeling and execution environment . Similarly the graphical model and the created custom storage class may be located remotely from the modeling and execution environment over a network. It will be appreciated that many other configurations are also possible within the scope of the present invention.

The graphical model may be a block diagram model. A block diagram model includes a set of symbols called blocks interconnected by signal lines that carry signals. Blocks are functional entities that operate on signal values contained in the signal lines. Each block can have zero or more input signal lines and zero or more output signal lines. Blocks may also have states. A state is a variable that determines a block s output and whose current value is a function of the previous values of the block s states and or inputs. In a block diagram model the signals carried on the signal lines are the streams of values that appear at the output ports of blocks. The signal can have a wide range of attributes such as name data type e.g. 8 bit 16 bit or 32 bit integer numeric type e.g. real or complex and dimensionality e.g. one dimension array two dimension array or multi dimensional array .

Each item of data in the graphical model is defined to have a data storage class. A data storage class contains the instructions that define how the automatic code generator is to produce code when a reference to an item of data belonging to that data storage class is encountered in the model. Data storage classes may be either pre defined or custom. Pre defined data storage classes represent those data storage classes inherent within a modeling system. Pre defined data storage classes are not capable of modification by a user and represent an instruction or set of instructions for each type of reference to the data. It should be appreciated that although the examples contained herein are made with reference to block diagram models the illustrative embodiment of the present invention may also be applied to other types of diagrams besides block diagrams.

Custom data storage classes are not inherent to the modeling system and are generated by an interpreted programming language process. Using the interpreted programming language process the user specifies a custom data storage class by specifying a set of instructions for each type of reference to the data. This set defines the data storage class. Specifically the custom data storage class is characterized by the set of instructions defined by the user via parameter settings that detail how to generate software source code for each type of reference to data that is of that class. The parameter settings for the custom class are chosen by the user via the user interface . The user may then specify that custom data storage class as the item s storage class. Because the user specifies and defines these instructions the possible variations in the software source code to be generated are extensive. The instructions corresponding to a given custom data storage class may be a function of the set of items that are defined to be of that class so that the mechanism is self referential.

Once the graphical model is specified an automatic code generator examines each data item specified in the graphical model and determines the storage class of the data item. If the data storage class is predefined the automatic code generator applies a fixed set of instructions to generate code for each type of reference to the item. If the data storage class is determined to be a custom storage class the automatic code generator accesses an external set of user defined instructions associated with the custom data storage class through an application programming interface API to generate code for each type of reference to the item.

An implementation of the code generation process can be seen in Real Time Workshop from The MathWorks Inc. of Natick Mass. Real Time Workshop is a set of tools that generate code from Simulink models for targeted systems. Simulink translates the graphical model into a Real Time Workshop .rtw file. Simulink is a software package for modeling simulating and analyzing dynamic systems. Simulink supports linear and nonlinear systems modeled in continuous time sampled time or a hybrid of the two. Systems can also be multi rate i.e. have different parts that are sampled or updated at different rates. Real Time Workshop takes the .rtw file and pre defined data storage classes supplied by The MathWorks Inc. to produce C programming language code corresponding to the graphical model . During the code generation process tokens in the pre defined storage class files are replaced with strings defined in the .rtw file. Customized code generation occurs when Real Time Workshop encounters a data record in the .rtw file that instructs it to utilize a custom data storage class instead of the predefined data storage class to generate code corresponding to a reference to data. More specifically when an item of data is defined to have a custom data storage class instructions associated with that data storage class are used to generate code corresponding to the data at each point in the code generation process where the data is referenced.

As noted above the illustrative embodiment of the present invention enables a user to customize the way source code is generated for a model by adjusting parameter settings through a user interface. depicts the sequence of steps followed by the illustrative embodiment of the present invention to create and display source code referencing model data. The sequence begins when the user interface is displayed containing multiple parameter settings and step . The user selects parameters for the custom storage class step . The custom storage class is created by utilizing the selected parameter settings and step . The automatic code generator creates source code referencing the data of the graphical model using the settings embodied in the custom storage class step . The created source code is then displayed in the user interface to the user step . The displayed source code may include tokens or regular expressions representative of actual code segments.

The initial generation of code responsive to the parameter settings may not always result in a desired outcome for the user. The illustrative embodiment of the present invention allows the process to iterate with a real time display of adjusted code reflective of each code recalculation. is a flowchart of the sequence of steps followed by the illustrative embodiment of the present invention to adjust and re display source code generated following a change in the selected parameters for a custom storage class. The sequence begins when the user selects parameters in the user interface and the custom storage class is created step . The custom storage class is then used to create source code referencing model data and the source code is displayed to the user in the code view portion of the user interface step . Subsequently the user may change parameter settings and the process creates new source code step . The new source code based on the adjusted parameter settings is then displayed to the user step .

Those skilled in the art will recognize that other additional parameter settings may also be adjusted through the user interface . Header file information may be specified as may certain details of Simulink usage e.g. the user may specify whether parameter or signal objects will utilize the custom storage class . Various other settings specific to particular custom storage classes may also be specified e.g. struct data settings for the Struct custom storage class . Certain non portable directives to a compiler referred to as pragmas such as near and far qualifiers may also be specified via the user interface . It will be appreciated that additional custom storage classes may also be created and displayed via the user interface in order for a user to adjust parameter settings for the code generation process.

Since certain changes may be made without departing from the scope of the present invention it is intended that all matter contained in the above description or shown in the accompanying drawings be interpreted as illustrative and not in a literal sense. Practitioners of the art will realize that the system configurations depicted and described herein are examples of multiple possible system configurations that fall within the scope of the current invention. Likewise the sequences of steps discussed herein are examples and not the exclusive sequence of steps possible within the scope of the present invention.

