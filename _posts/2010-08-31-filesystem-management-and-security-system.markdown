---

title: Filesystem management and security system
abstract: A system to implement user-level filesystem related calls instead of an operating system kernel may include data processing applications executing via a computer processor. The system may also include a plurality of user-level filesystems, each one of which is associated with at least one of the data processing applications. The system may further include a user-level library in communication with the data processing applications, the user-level library configured to implement user-level filesystem related calls instead of an operating system kernel executing via the computer processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08495750&OS=08495750&RS=08495750
owner: International Business Machines Corporation
number: 08495750
owner_city: Armonk
owner_country: US
publication_date: 20100831
---
This application contains subject matter related to the following co pending applications entitled RESOURCE MANAGEMENT AND SECURITY SYSTEM and having an 12 872 996 and PROCESSOR SUPPORT FOR SECURE DEVICE DRIVER ARCHITECTURE and having an 12 873 085 the entire subject matters of which are incorporated herein by reference in their entirety. The aforementioned applications are assigned to the same assignee as this application International Business Machines Corporation of Armonk N.Y.

The invention relates to the field of computer systems and more particularly to address resource management and security of such.

Most general purpose computers utilize an operating system OS as an interface between their applications and the computer hardware. As such the OS usually manages data processing application programs executing on the computer as well as controlling the hardware resources responsive to the data application programs. A data processing application is an application that processes data. A user application may be a data processing application that processes data directly in support of one of the computer s users. A system application may be a data processing application processing data in support of one or multiple user or system applications running on the same or a remote system. System applications are typically implemented as user level application running with special privileges and commonly referred to as system daemons.

In addition the portion of the OS that may control other portion of the OS is usually called the OS kernel. The OS kernel usually has complete access to the application address space and files.

According to one embodiment of the invention a system to implement user level filesystem related calls instead of an operating system kernel may include data processing applications executing via a computer processor. The system may also include a plurality of user level filesystems each one of which is associated with at least one of the data processing applications. The system may further include a user level library in communication with the data processing applications the user level library configured to implement user level filesystem related calls instead of an operating system kernel executing via the computer processor.

The system may additionally include a plurality of persistent storage devices supporting the plurality of user level filesystems that are adjacent to the computer processor. The system may also include a mediator configured to assign access rights to blocks of each one of the plurality of user level filesystems to the data processing application instead of the operating system kernel.

Each user level library in communication with data processing applications may interact directly with the mediator to determine its access rights to read and to write any persistent storage block instead of the operating system kernel. The mediator may manage device drivers and or an input output memory management unit instead of the operating system kernel.

The mediator may prevent the operating system kernel hosting the device drivers from accessing for reading or writing its address space either directly or through a direct memory access DMA engine. The mediator and or the data processing application may encrypt and or decrypt the storage block data content. The mediator may use dedicated hardware or one of the data processing applications may use dedicated hardware managed by the mediator to encrypt and decrypt storage block data content. The mediator may use device allocation tables to map block addresses to block physical addresses to limit a malicious operating system kernel from corrupting each one of the plurality of user level filesystems. The user level library may interact with a remote trusted persistent storage unit using a block level protocol over a plurality of secure connections.

Another aspect of the invention is a method to implement user level filesystem related calls instead of an operating system kernel. The method may include executing data processing applications via a computer processor. The method may also include associating each one of a plurality of user level filesystems with at least one of the data processing applications. The method may further include configuring a user level library in communication with the data processing applications to implement user level filesystem related calls instead of an operating system kernel executing via the computer processor.

The method may additionally include supporting the plurality of user level filesystems with a plurality of persistent storage devices that are adjacent to the computer processor. The method may also include configuring a mediator to assign access rights to blocks of each one of the plurality of user level filesystems to the data processing application instead of the operating system kernel.

The method may further include determining access rights to read and to write any persistent storage block instead of the operating system kernel for each user level library in communication with data processing applications through direct interaction between the mediator and each user level library. The method may additionally include managing at least one of device drivers and input output memory management unit through the mediator instead of the operating system kernel.

The method may also include preventing through the mediator the operating system kernel hosting the device drivers from accessing for reading or writing its address space either directly or through a direct memory access DMA engine. The method may further include encrypting and decrypting the storage block data content by at least one of the mediator and the data processing application. The method may additionally include using device allocation tables to map block addresses to block physical addresses to limit a malicious operating system kernel from corrupting each one of the plurality of user level filesystems by the mediator.

Another aspect of the invention is a computer readable program codes coupled to tangible media to implement user level filesystem related calls instead of an operating system kernel. The computer readable program codes may be configured to cause the program to execute data processing applications via a computer processor. The computer readable program codes may also associate each one of a plurality of user level filesystems with at least one of the data processing applications. The computer readable program codes may additionally configure a user level library in communication with the data processing applications to implement user level filesystem related calls instead of an operating system kernel executing via the computer processor.

With reference now to and a system to address resource management and security in a computer system is initially described. The system is a programmable apparatus that stores and manipulates data according to an instruction set as will be appreciated by those of skill in the art.

In one embodiment the system includes a communications network which enables a signal to travel anywhere within system between computer processor s and the data processing resources of system and or between data processing resources or system such as computer memory input output devices and other data processing devices . The communications network is wired and or wireless for example. The communications network is local and or global with respect to system for instance.

According to one embodiment the system includes an operating system kernel executing on a computer processor . In an embodiment the system includes a data processing application .

In one embodiment the system includes a mediator configured to execute on the computer processor . In an embodiment the mediator operates between the operating system kernel and the data processing application. In one embodiment the mediator controls access to user related application state of the data processing application and restricts access of the operating system kernel to the user related application state.

In one embodiment kernel code is part of the OS kernel in commercial or academic operating systems. It runs with super user privileges and it provides support to all user and system applications running on the underlying computer system . Super user mode is the most privileged level at which software runs on a typical computer systems with no hardware support for virtualization or with such support disabled. Software running in the most privileged mode has access to all the hardware resources of the system . In system the mediator code is run in the most privileged level and the modified kernel code is run in a mode with slightly fewer privileges. This means that the mediator code has access to all the hardware resources the modified kernel has access to fewer hardware resources than the mediator and also less than the original kernel had access to in the unmodified original computer system and applications are run in a mode with even fewer privileges than the modified kernel code.

In one embodiment the mediator restricts access of the operating system 1 directly by taking over the control of the Memory Management Unit MMU from the modified operating system kernel and 2 indirectly by taking over the control of the I O MMU or of any devices that have access to the system memory directly without their accesses being controlled by the I O MMU from the modified operating system and related device drivers. In an embodiment the mediator programs the MMU such that any attempt by the modified operating system kernel to access application memory is validated by mediator code or redirected to a mediator buffer and forwarded by the mediator to the application. In an embodiment the mediator validates any attempts by any I O device driver included in the kernel to program the I O MMU and while drivers for devices not using the I O MMU are rewritten or tested to a higher level such that they can be included in the mediator code base.

In one embodiment the user related application state comprises data produced by the data processing application during its operation and which is visible to the mediator and is not visible to the operating system kernel . In an embodiment the user related application state comprises data read from devices attached to system or external to system and accessible using I O devices such as a wired or wireless network interface. In an embodiment the operating system kernel controls system related application state that is used to control portions of the data processing application at the operating system kernel s level.

In one embodiment the operating system kernel is modified to relinquish a portion of its functionality to the mediator . In an embodiment the system further includes data processing resources in communication with the computer processor . Data processing resources include any resource used by system and or any other computer system during the input output storage manipulation of data transfer of data or the like.

In one embodiment the mediator has higher access rights than the operating system kernel to the computer processor and the data processing resources . In an embodiment the operating system kernel has restricted access to user related application state because the mediator performs transfers between the user related application state and data structures of the operating system kernel as needed to enable the operating system kernel s remaining functions.

In one embodiment the mediator controls system calls and exceptions between the operating system kernel and the data processing application . In an embodiment the data processing resources include computer memory communication network input output devices and data processing devices such as crypto co processors or temperature monitoring sensors wherein the computer memory stores the data processing application the mediator operating system kernel a shared user level library and a system daemon .

In one embodiment the mediator controls access of operating system data processing application user level shared library and system daemon to the computer memory using the memory management unit of the processor . In an embodiment the mediator virtualizes select registers of the input output devices . In an embodiment the mediator uses an input output memory management unit of computer processor to control data transfer sources and data transfer destinations to and from input output devices . In one embodiment the system further includes an Internet protocol security module implemented as a system daemon and running outside of the operating system kernel to directly communicate with the data processing application without communicating with the operating system kernel.

In view of the foregoing the system addresses resource management and security in a computer system for example. For instance commercial operating systems OSes are large and complex. Generally attempts to prove them correct against a comprehensive set of specifications have failed. In addition over the past years all most public OSes have been compromised by network initiated attacks.

In addition there is no prior disclosure of a computer and OS architecture that separates the resource protection from the resource management functions of an operating system. More specifically there is no prior disclosure of an architecture in which compromises of the operating system will only result in applications being denied access to the computer data processing resources and computer processor that they need and normally have access to without any loss of application data or compromise of the application code and data for instance.

In one embodiment system may utilize 1 minimal changes to the kernels of existing commercial OSes and to the existing processor chipset architectures 2 the addition of a small and trusted system software component that can be proved correct and 3 minimal changes to the rest of the system software and to the applications preferably restricted to modifications of the system libraries used to interface applications with the kernel and with the new trusted system software component for example.

Recent efforts in the art are based on a radically different hardware architecture which requires massive changes to existing operating system and application implementations or require a Virtual Machine Monitor to encapsulate an unmodified kernel and minimally changed applications. Both approaches depend heavily on cryptography exhibit significant performance degradations and do not fully protect the data in the local file system. Older approaches require an entirely new operating system implementation and have never been successfully tested on large installations.

With additional reference to in one embodiment of the proposed architecture the modified operating system kernel has no access to the state address space plus registers of any of the applications it runs and its access to the local file system may be restricted to the file s it really needs access to for instance the current Linux kernel only needs access to one of the sbin init etc init bin sh or bin init application file to properly start .

In one embodiment the interface between applications and kernel which includes system calls and exceptions is mediated by a small layer of software that runs at a higher privilege level than the kernel. This trusted software component called mediator uses a memory management unit MMU to restrict kernel access to the address spaces of local applications and it is designed to reduce the number of kernel code changes.

In an embodiment the file system implementation is largely removed from the kernel which has access only to a small portion of the root file system such as the sbin init program. File systems for local block devices are implemented in shared user level libraries with the kernel resident block device drivers controlling the devices but mediator controlling the source and destinations of data transfers from and to these devices by using an possibly enhanced input output memory management unit IOMMU and by virtualizing select registers of the attached block device controllers.

In an embodiment the architecture prevents the kernel from accessing the application state stored in the processor registers even when servicing an interrupt taken while executing application code. In contrast existing architectures save the processor state in the kernel address space while servicing an interrupt which allows a compromised kernel to access the application state stored in the processor registers and to load tainted values in these registers upon returning from interrupt.

In one embodiment the Internet Protocol Security IPsec implementation is removed from the kernel into a dedicated user level system application daemon which communicates with the local applications directly without kernel intermediation using shared memory . In an embodiment applications using IPsec will use library implementations for the higher layers of the networking stack. In one embodiment the original network stack remains in the kernel as applications are expected to use secure sockets layer SSL for most of their sensitive network communication for instance.

In one embodiment system architecture does not use encryption to protect application data from being accessed by the OS kernel or by other system or not applications for instance. For example system does not aim at improving the kernel s resilience to attacks but it aims at preventing the attacker from accessing application data once it takes control of the kernel because the mediator cannot be compromised.

In one embodiment system requires modest changes to the existing kernel and system software and small extensions to existing processor architectures to achieve this goal. In an embodiment each of the software or hardware mechanisms such as but not limited to additional privilege level with fast and secure control transfer to lower kernel level and supervising the access to and from attached block devices based on block or superblock access rights secure interrupt state save and restore in hardware user level distributed file system implementation and an enhanced IOMMU architecture all of which may be used by system are the subject of related but separate disclosures.

In one embodiment mediator is a relatively small software component that has simultaneous access to the kernel and current application address spaces and it mediates parameter and result passing for system calls. In an embodiment application registers which include the application return address are saved in the mediator s local memory.

In one embodiment the mediator code prepares a stack entry in the kernel address space for the system call code and switches the processor to the kernel i.e. lower privilege level to start executing the system call code. In an embodiment to safely transfer the control to a lower privilege code and back the processor architecture may have to be enhanced with mechanisms that ensure that the system call will eventually return to mediator as specified by its semantics. More specifically the fork clone and abort exit system calls may require two or no return paths to be set up by mediator while the rest of the system calls typically require only one.

In one embodiment mediator intermediates exception handling as well. In an embodiment mediator is responsible for the virtualization of the local memory checking and modifying the process tables maintained by the OS kernel .

In an alternative implementation on recent x86 processor architectures mediator can take advantage of their enhanced MMU s designed for efficient virtualization AMD s Nested Page Tables and Intel s Extended Page Tables . This approach may reduce the OS kernel changes required to protect the application state from a compromised kernel but the resulting system may not be hosted efficiently by a hardware enabled virtual machine monitor VMM .

In existing OS kernels when the processor takes an interrupt while executing application code i.e. while in User Mode the application registers are saved in kernel address space. A compromised kernel can access these values or resume the interrupted application with tainted register values including program counter and stack pointer designed to modify the application behavior towards revealing more of its state to the attacker.

The system architecture includes several alternatives including but not limited to running the bottom half of the interrupt handler in mediator address space or modifying the processor to 1 encrypt and decrypt registers automatically after taking an interrupt and before resuming the application respectively or 2 to use memory locations not accessible to the kernel for storing the application state upon servicing the interrupt after being saved registers must also be cleared .

In one embodiment if debugger support is needed instructions executing at the highest priority level may be able to read and modify the content of the saved registers. In an embodiment when debugger support is not needed this capability may be disabled.

In one embodiment to prevent the OS kernel from having access to application data the implementations of the supported local file systems are removed from the kernel into user level shared libraries. In an embodiment data blocks from local disks or other block devices supporting a file system are direct memory accessed directly into and from application address spaces. In an embodiment the kernel resident device drivers program the transfer but mediator controls the source and destination of each transfer by virtualizing the IOMMU and selected registers of the block device controllers.

Towards this end and to prevent information leakage through the swap device mediator maintains an access rights list at the block or superblock level for each attached block device. In one embodiment between system starts this information is stored externally and its integrity protected using the same mechanisms as for the mediator and kernel code possibly with dedicated tamper resistant hardware.

In an embodiment an application level component which communicates directly with the applications without kernel mediation handles disk blocks that may not be assigned a clear ownership such as blocks containing metadata shared referring to data blocks owned by multiple users. The same component implements file locking services for example.

In one embodiment the kernel keeps ownership of the network stack as applications may use SSL for secure communication. In an embodiment kernel IPsec implementations may be moved out of the kernel either in a separate application or inside the mediator code base and address space.

In one embodiment an application based implementation is preferable with mediator intermediating between the IPsec user level implementation and crypto accelerator devices if any.

In an embodiment mediator includes a serial line driver and minimal kernel monitoring debugging functionality. Even after these additions its small size makes it more amenable to formal verification.

In one embodiment upon system initialization mediator is copied and started in main memory by a boot loader. In an embodiment mediator is responsible for initializing the modified OS kernel . Upon system shutdown mediator shuts down after the kernel for instance.

It is noted that OS kernels have complete access to the application address space and files. As a result a corrupted kernel exposes all the application state internal data structures and files to the attacker. Existing work attempts to protect the kernel from running unauthorized code or to enforce safety properties on modules running in kernel address space.

In contrast in one embodiment system uses mediator a system software component designed to work with a modified OS kernel to contain its access to the address spaces of the local applications and to the storage devices attached to the computer system. In one embodiment mediator s architecture requires modest changes to the existing kernel architecture concentrated in the application kernel interface and virtual memory management.

In one embodiment applications running on a mediator enabled OS kernel are still exposed to denial of service attacks. In this respect mediator complements ongoing efforts to enhance the reliability of the underlying OS kernel .

In one embodiment mediator is a relatively small system software component running at a privilege higher than the OS kernel that intermediates the legitimate interactions between kernel and applications and restricts all the other kernel accesses to application data by design applications are already prevented from accessing sensitive kernel data in existing OS architectures .

In one embodiment the largest mediator component handles system calls exceptions and signal activation by passing parameters and results between application and kernel while having access to the address spaces of both and by unmapping the address space of the current application from the kernel address space while in kernel mode. In an embodiment MMU management is transferred from kernel to mediator .

In one embodiment MMU management in mediator shares certain elements with the equivalent functionality in a virtual machine monitor VMM it also protects applications from a malicious kernel. Example attacks include but are not limited to attempting to map application pages in kernel address space establishing unrequested shared memory regions between applications extending legitimate shared memory regions with the purpose of leaking information from one application to another allocating new pages to an application without zeroing them changing the legitimate page frames of an application possibly as a result of a sequence of swap out in operations with illegitimate pages and so on. In an embodiment to prevent this type of attack system closely correlates the application s system calls and exceptions related to address space changes such as copy on write with changes to the address space of the application and with MMU management.

In one embodiment other mediator components virtualize the locally connected storage devices by enforcing block level access rights and prevent interrupt handlers running in the kernel address space from accessing the application state stored in the processor registers when the processors takes an interrupt while in User Mode . In an embodiment the system coordinates with the user level file system to safely start a new process.

For example file system implementations are traditionally hosted in the operating system kernel and accessed by applications via system calls. On systems supporting multiple file systems such as Linux the kernel implements a common virtual file system abstraction that hides the details of each of the supported file systems under a common application programming interface API . Remote network file systems are typically supported by a kernel component which supports the common API for the local applications and which interfaces with the remote file server over the network. User level file systems like the preceding are implemented as separate monolithic applications accessible through the kernel API.

XN supports user level implementations of various library file systems called libFSes. XN which is included in the scaled down kernel of the Exokernel system acts as a multiplexer of stable storage. XN has an extensible architecture it can be extended with FS specific untrusted deterministic functions UDFs which are used to interpret the metadata disk blocks. Each file system hosted on devices managed by XN comes with its own set of UDFs which are written in a restricted RISC like assembly language.

Overshadow describes a system that uses encryption heavily to protect file system data against a corrupted OS kernel. However the file system metadata is still handled by the kernel resident file system implementation.

The system employs a user level implementation of the local file system with most of the implementation distributed among applications and with very few and small central components. Each application is linked to a library that implements the FS related system calls normally hosted in the kernel. The library implementation is supported by a block device manager which is a centralized component and is hosted in the mediator component.

Applications interact directly with mediator to read or write disk blocks. The device drivers are still part of the OS kernel while the IOMMU is managed by mediator . In an alternative implementation mediator hosts the block device drivers as well.

When the device drivers are hosted by the kernel valid requests are forwarded to the kernel which is prohibited to DMA anything directly to and from its address space mediator retains the control of the IOMMU . The integrity of the blocks read from disk is verified against hash values maintained by mediator together with the access rights . The values are either computed in software by the application or mediator or in hardware by an expanded IOMMU IObridge. In other words the system prevents a malicious kernel from accessing any file system data metadata included.

Furthermore if the IOMMU IObridge can be reliably extended to enforce the write addresses that are sent to the disk controller then a mediator extension that use the device allocation tables to map block addresses to disk physical addresses maintained by the disk driver can guarantee that a malicious kernel cannot corrupt a local file system provided the disk controllers can be trusted .

In one embodiment of the invention a system to implement user level filesystem related calls instead of an operating system kernel includes data processing applications executing via a computer processor . The system also includes a plurality of user level filesystems each one of which is associated with at least one of the data processing applications . The system further includes a user level library in communication with the data processing applications the user level library configured to implement user level filesystem related calls instead of an operating system kernel executing via the computer processor .

In one embodiment the system additionally includes a plurality of persistent storage devices supporting the plurality of user level filesystems that are adjacent to the computer processor . In an embodiment the system also includes a mediator configured to assign access rights to blocks of each one of the plurality of user level filesystems to the data processing application instead of the operating system kernel .

In one embodiment each user level library in communication with data processing applications interact directly with the mediator to determine its access rights to read and to write any persistent storage block instead of the operating system kernel . In an embodiment the mediator manages device drivers and or an input output memory management unit instead of the operating system kernel .

In one embodiment the mediator prevents the operating system kernel hosting the device drivers from direct memory and accessing anything directly to and from its address space. In an embodiment the mediator and or the data processing application encrypt and or decrypt the storage block data content.

In one embodiment the mediator uses dedicated hardware or one of the data processing applications uses dedicated hardware managed by the mediator to encrypt and decrypt storage block data content. In an embodiment the mediator uses device allocation tables to map block addresses to block physical addresses to limit a malicious operating system kernel from corrupting each one of the plurality of user level filesystems . In an embodiment the user level library interacts with a remote trusted persistent storage unit using a block level protocol over a plurality of secure connections.

Another aspect of the invention is a method to implement user level filesystem related calls instead of an operating system kernel which is now described with reference to flowchart of . The method begins at Block and may include executing data processing applications via a computer processor at Block . The method may also include associating with at least one of the data processing applications a plurality of user level filesystems each one of a plurality of user level filesystems at Block . The method may further include configuring a user level library in communication with the data processing applications to implement user level filesystem related calls instead of an operating system kernel executing via the computer processor at Block . The method ends at Block .

In another method embodiment which is now described with reference to flowchart of the method begins at Block . The method may include the steps of at Blocks and . The method may additionally include supporting the plurality of user level filesystems with a plurality of persistent storage devices that are adjacent to the computer processor at Block . The method ends at Block .

In another method embodiment which is now described with reference to flowchart of the method begins at Block . The method may include the steps of at Blocks and . The method may also include configuring a mediator to assign access rights to blocks of each one of the plurality of user level filesystems to the data processing application instead of the operating system kernel at Block . The method ends at Block .

In another method embodiment which is now described with reference to flowchart of the method begins at Block . The method may include the steps of at Blocks and . The method may further include determining access rights for read and write to any persistent storage block for each user level library in communication with data processing applications through direct interaction between the mediator and each user level library instead of the operating system kernel at Block . The method ends at Block .

In another method embodiment which is now described with reference to flowchart of the method begins at Block . The method may include the steps of at Blocks and . The method may further include managing at least one of device drivers and input output memory management unit through the mediator instead of the operating system kernel at Block . The method ends at Block .

In another method embodiment which is now described with reference to flowchart of the method begins at Block . The method may include the steps of at Blocks and . The method may further include preventing through the mediator the operating system kernel hosting the device drivers from accessing for reading or writing its address space either directly or through a direct memory access DMA engine at Block . The method ends at Block .

In another method embodiment which is now described with reference to flowchart of the method begins at Block . The method may include the steps of at Blocks and . The method may further include encrypting and decrypting the storage block data content by at least one of the mediator and the data processing application at Block . The method ends at Block .

In another method embodiment which is now described with reference to flowchart of the method begins at Block . The method may include the steps of at Blocks and . The method may further include using device allocation tables to map block logical addresses to block physical addresses to limit a malicious operating system kernel from corrupting each one of the plurality of user level filesystems by the mediator at Block . The method ends at Block .

Another aspect of the invention is a computer readable program codes coupled to tangible media to implement user level filesystem related calls instead of an operating system kernel . The computer readable program codes may be configured to cause the program to execute data processing applications via a computer processor . The computer readable program codes may also associate each one of a plurality of user level filesystems with at least one of the data processing applications . The computer readable program codes may additionally configure a user level library in communication with the data processing applications to implement user level filesystem related calls instead of an operating system kernel executing via the computer processor .

In system when a local file system is mounted the mediator resident block manager receives the location of the device superblock s and it assumes the ownership of these blocks and the list of access rights of the various principals and groups to the device s blocks. This includes access rights to the blocks used to store file system metadata. It also receives the hashes for all the file system blocks that are currently in use not free . The access rights data is collected by a trusted application upon booting a system by scanning the file system on the device to be mounted or by retrieving it from a trusted location.

The trusted application uses the mediator block manager to build the access rights information and the integrity of the application can be verified in either in software by a mediator component using a TPM based static root of trust or using the features of the new Intel AMD processors supporting dynamic root of trust capabilities. Hash values and access control lists are not necessarily computed from scratch every time the file system is mounted.

To applications the file system appears as a Virtual File System layer which acts as an interface between user code and the implementations of the supported file systems. Most if not all of the implementation of these file systems is in a user level library linked to each application. The mediatior resident block manager controls the superblock and its copies for each of these file systems as it manages block allocation on these devices. As the location and format of the superblocks is FS specific the block manager can be considered a part of the FS implementation.

As long as 1 each of the used i.e. not free disk blocks of the file system can be assigned a R W access control list in terms of the principals running various user level applications and 2 mandatory file locking is not supported there is no need for a centralized file system component other than the mediator resident block manager .

Data blocks obviously satisfy the first condition. The system can accommodate either separate copies for each disk block for each application or shared copies for example between applications reading the same file or directory.

However metadata blocks as used in popular file systems rarely satisfy the first condition. The most obvious example is the i node block which stores in the same 128 byte Linux Ext2 FS structure access rights information and the pointers to the data blocks. The presence of the access control fields prevents an application that can write extend the file to have write access to block containing the i node even in the situation where similar i nodes are grouped together in the same block. Therefore a new i node like structure is needed where access control information is separated from data related information such as pointers to the data blocks or the time the file contents last changed and stored in separate blocks. Access control information for files with identical ownership is stored in a now smaller i node like data structure with small i nodes with identical ownership being grouped together in a block.

Data related information is stored in a separate block instead of grouping together in one block the data related info for several related files the rest of the block is filled with file content remotely similar to how fast symlinks are stored in the i nodes of several popular file systems. Handling other metadata blocks besides i nodes is challenging too and their handling is FS specific.

For higher performance and resilience to failures popular file systems such as Ext2 and Ext3 are based on a substantially more complex disk layout than the original Unix file system. For instance in Ext2 data blocks are grouped in Block groups each one with its own i node table and block bitmaps.

Unless disk blocks that are assigned unambiguous R W rights can be grouped in such a way that the R W rights of the additional metadata blocks can be assigned unequivocally there is a need for a centralized file system component. Each mounted FS type will require a separate component which can also handle superblock s management i.e. block allocation de allocation and mandatory file system locks.

The system uses both a new file system structure where the vast majority of the metadata blocks in addition to the data blocks can be a read or written directly by applications and a way to map existing file system structures into the constrains imposed by the mostly user space file system in the mediator architecture. To satisfy condition the user level library FS implementations include an application level entity that implements mandatory locking in conjunction with the mediator resident block manager.

Orthogonal to conditions 1 and 2 is the handling the journaling capabilities of a file system in an efficient manner. By design journal implementations require a centralized implementation per disk drive to leverage the speed of sequential writes to the drive. Therefore to support log journal file systems the mediator includes capabilities for maintaining a journal of block devices that works in conjunction with the block manager.

Overall in the mediator architecture most of the implementation of the various file systems consists of user level libraries which interact with a small mediator resident block manager for the fast path i.e. moving data blocks between application pages and disk drive and a per file system type user level daemon which handles disk block without a definitive ownership for the slow path . Furthermore the file system daemon can be further divided between a main component in charge of metadata blocks without a definitive ownership and a few slave daemons running under various system IDs and which are used to update metadata information in blocks that cannot be modified by running applications. For example to update the time of last file access in the i node of a file accessed by an application that has only read rights to the file and it is not the owner of the file .

Special file systems will remain hosted by the kernel although minor changes in the implementations of some are expected. As a result most if not all of the virtual FS layer will remain in the kernel .

Note that the Linux kernel already supports direct I O transfers between drive and user level data pages. Note that in this FS architecture the centralized components in the implementations of the various file systems are separated and isolated from the kernel by the mediator memory management. They communicate with the user level library component of the FS directly through shared memory and with the mediator resident block manager to change the access rights to various disk blocks. Mediator prevents these FS components from interacting with the kernel where the most error prone components are hosted i.e. the network stack and device drivers. The performance related impact of hosting this functionality in user space is expected to be offset by its new security related attributes.

A corrupted operating system kernel can prevent disk block reads can deliver the wrong blocks fail to perform the block write operations use incorrect block addresses when writing or simply write random data at random addresses. Mediator prevents the kernel from delivering tainted data to applications or to the centralized file system component at the application level by providing the application FS component the correct hash of the disk data block or by checking this hash value against the value computed on the fly by an expanded IOMMU IObridge during the transfer.

Preventing a malicious kernel from tainting the FS content on the disk is substantially more difficult and it requires extensive hardware support in the form of an IObridge unit which include an IOMMU subsystem. Like the IOMMU the expanded IObridge is under the control of the mediator software layer running at the highest priority level and it is designed to check the kernel access to the block devices connected to the IO bus it controls. One way to look at this functionality is that of a reverse IOMM U as the IOMMU controls device read writes to the system memory. Preferably the expanded IObridge unit is microprogrammed and mediator expands its functionality for each new device and device layout by expanding its internal program.

Mediator includes at least one simple driver for a trusted I O device such as serial interface and basic primitives for loading and starting restarting and monitoring kernel activities and integrity.

In an embodiment mediator leverages a processor execution mode with higher priority than the one used to run the OS kernel .

Processor architectures with only two execution modes will need to be enhanced with an additional mode to run mediator for example. For processors with more than two modes but for which the kernel is configured in the highest priority mode such as the x86 family from Intel or AMD the kernel is either modified to run at a lower level say one instead of zero or mediator takes advantage of the virtualization capabilities of the newer members of the x86 processor family similarly on non x86 processors mediator can take advantage of hardware capabilities designed for efficient virtualization for instance. The later approach prevents the resulting system modified kernel mediator system software from being hosted by one of the existing VMM which is designed to take advantage of the virtualization support added to the processor for example.

In one embodiment mediator separates the address spaces of applications and kernel with small changes to the existing kernel by capturing application system calls exceptions and signal handling. On these events mediator handles the MMU to restrict the access of application or kernel to its own address space for instance. Based on the nature of the event such as system call invocation system call return exception invocation or return signal invocation or the like mediator in cooperation with the modified kernel performs parameter and result passing between the two address spaces involved for example.

In one embodiment the kernel is modified to transfer MMU handling to mediator . In an embodiment if the processor architecture provides additional i.e. unused by the kernel MMU functionality that can be leveraged to ensure address space isolation mediator can take advantage of it which will reduce the magnitude of kernel changes but will prevent other system components such as a VMM if present from using this additional MMU functionality. In an embodiment to reduce the extent of kernel changes mediator can manage proxy objects buffers for application resident objects buffers and modifies pointers accordingly upon system call invocation and return.

To limit the additional system call overhead mediator can include the implementation of a few short and frequently used system calls for example.

The transfer of control from mediator to the kernel upon a system call or exception invocation hides from the kernel any application related information that is not necessary for completing the invocation such as the location in the application code where the system call was invoked or where the exception triggered for instance.

In one embodiment mediator manages all the local block devices to prevent the kernel from accessing application data stored in the local file system s . In an embodiment only the fraction of the device driver functionality handling data transfers must be transferred from the kernel resident drivers to mediator device testing initialization and shutdown can still be done by kernel resident code.

Towards this goal mediator controls all the device registers used to configure initiate data transfers for instance. Mediator maintains an access rights R W map for each block device to assist in data access and program launch execution for example.

In an alternate embodiment IOMMU management if present is transferred from kernel to mediator while device management device drivers possibly after small modifications is left to the kernel. In an embodiment mediator and kernel cooperate to enable user level DMAs directly from disk block to selected pinned down application pages. In an embodiment protected user level DMA supports the library user level file system component of the architecture which is the subject of a separate but related disclosure.

In one embodiment mediator protects the application information captured in the processor state when the processor takes an interrupt while in UserMode from being released to the kernel by handling the lowest level of the interrupt processing invocation return i.e. the bottom half of the interrupt service routine ISR and transferring control to the kernel only after saving this information in mediator address space and clearing the registers. In alternative embodiment a modified processor architecture which is the topic of a separate but related disclosure can provide the same protection with virtually no negative performance impact.

Overall mediator separates the applications network stack plus drivers and the file system for example. This is true even when the file system has a small application level system component daemon which is prevented by mediator from performing any network related system calls and more generally from performing any system calls that would leak file system related information to a remote machine directly or indirectly through a potentially corrupted kernel for instance.

As will be appreciated by one skilled in the art aspects of the invention may be embodied as a system method or computer program product. Accordingly aspects of the invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

While the preferred embodiment to the invention has been described it will be understood that those skilled in the art both now and in the future may make various improvements and enhancements which fall within the scope of the claims which follow. These claims should be construed to maintain the proper protection for the invention first described.

