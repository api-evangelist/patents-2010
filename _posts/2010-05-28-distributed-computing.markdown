---

title: Distributed computing
abstract: Distributed computing is described. In an embodiment a user drags and drops an icon representing specified functionality into a graph layout view of a distributed computing graph in order to control a distributed computing system. For example, the distributed computing graph controls currently executing processes in a distributed computing system. In an embodiment a dynamic mapping between the graph layout view and the distributed computing graph occurs such that the functionality of the icon is implemented. For example, the icon may represent a data bus connecting some of the currently executing processes and used to implement check pointing and/or caching mechanisms. In other examples the icon represents any of a spooler-player mechanism, debugging tools, multi-scale visualization tools, and data driven visualization tools.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08572229&OS=08572229&RS=08572229
owner: Microsoft Corporation
number: 08572229
owner_city: Redmond
owner_country: US
publication_date: 20100528
---
Distributed computing is required in many application domains. For example computational science management of distributed database systems management of distributed computing systems for bio informatics image analysis or other applications in which very large amounts of data are to be processed or huge amounts of computational resources are required. However orchestration of complex data flows of substantial amounts of data from live streaming sources is difficult with existing approaches.

The use of distributed computing systems is becoming more widespread. Often computational processes are decomposed into multiple subprocesses which are executed on different computing systems or computational processes are divided into fragments and the fragments are spread over multiple systems to be computed. Management of these distributed computing systems is typically carried out by a single entity which owns the computational process and there is a general need to simplify and improve the manner in which the management is achieved. For example existing tools to manage scientific workflows enable a scientist to make use of remote computing resources to carry out in silico experiments. However it is difficult to enable the experiments to be managed by multiple users working on different computers at the same time in a simple and effective manner. In addition existing approaches are often unsuited to novice users who have little or no knowledge of remote computing resources that may be used.

There is an increasing need to harness the cumulative power of multiple computing devices owned by a single person e.g. an individual s laptop office desktop computer and home computer or to harness the power of grid and cloud computing. However current systems do not enable this to be achieved in a simple to use and effective manner. As a result it is difficult to engage in collaborative design development and review of scientific or technical computing projects. In addition the results of any such collaborative computations are difficult to visualize and use by executives policy makers and other users.

The embodiments described below are not limited to implementations which solve any or all of the disadvantages of known distributed computing systems.

The following presents a simplified summary of the disclosure in order to provide a basic understanding to the reader. This summary is not an extensive overview of the disclosure and it does not identify key critical elements of the invention or delineate the scope of the invention. Its sole purpose is to present some concepts disclosed herein in a simplified form as a prelude to the more detailed description that is presented later.

Distributed computing is described. In an embodiment a user drags and drops an icon representing specified functionality into a graph layout view of a distributed computing graph in order to control a distributed computing system. For example the distributed computing graph controls currently executing processes in a distributed computing system. In an embodiment a dynamic mapping between the graph layout view and the distributed computing graph occurs such that the functionality of the icon is implemented. For example the icon may represent a data bus connecting some of the currently executing processes and used to implement check pointing and or caching mechanisms. In other examples the icon represents any of a spooler player mechanism debugging tools multi scale visualization tools and data driven visualization tools.

Many of the attendant features will be more readily appreciated as the same becomes better understood by reference to the following detailed description considered in connection with the accompanying drawings.

The detailed description provided below in connection with the appended drawings is intended as a description of the present examples and is not intended to represent the only forms in which the present example may be constructed or utilized. The description sets forth the functions of the example and the sequence of steps for constructing and operating the example. However the same or equivalent functions and sequences may be accomplished by different examples.

The entities in the distributed computing system are arranged to enable activities to be carried out in the distributed computing system under the control of one or more distributed computing graphs. An activity is one or more processes which are associated with an aim or objective. For example the activity may be an experiment a data centre management process a computational computing objective or other group of processes associated with an objective. Each activity has an associated distributed computing graph which controls currently executing processes in the distributed computing system in order to carry out the activity. Entities in the distributed computing system are aware of the distributed computing graph and this is achieved in any suitable manner. For example the distributed computing graph may be replicated at the entities. It is also possible for the distributed computing graph to be shared amongst the entities using a peer to peer distribution system of any suitable type. As described in more detail below each entity has a graph layout view of the distributed computing graph and is aware of communication protocols addresses and contracts associated with the processes assigned to the distributed computing graph.

The term distributed computing graph is used to refer to a data structure storing a plurality of nodes connected by links where each node represents a currently executing process at a specified entity in a distributed computing system. For example the process may be a computational process which takes data from one or more sources which could also be other processes and produces output. It is also possible for the process to be one which retrieves data from a source and reformats or pre processes that data so that it is suitable for a later computation process. In this case the data sourc es are specified at the node representing the process. Entities in the distributed computing system are arranged to carry out the represented processes which may be parallel concurrent or sequential using the specified entities and data sources. Each distributed computing graph is associated with an activity as described above.

For example one of the entities in the distributed computing system may be a PC operated by an end user in order to participate in a collaborative computing activity with other entities. The PC may provide a graphical user interface which displays a graph layout view of a distributed computing graph as illustrated schematically in . The end user is able to edit the graph layout view of the distributed computing graph in order to carry out a type of programming activity. Changes that the end user makes to the graph layout view cause the underlying distributed computing graph to update and thus control the currently executing processes that form the activity. End users at other entities in the distributed computing system are also able to control those currently executing processes in a collaborative manner by using graph layout views at their respective entities.

End users are also able to view the outputs of an activity. For example an entity in the distributed computing system may be a laptop computer displaying data resulting from an activity as illustrated schematically in . Various views viewports and user interface objects may be created and edited by an end user and associated with the distributed computing graph in order to achieve this. Those views viewport and user interface objects are collectively referred to in this document as a visualization layer. All the entities in the distributed computing system are aware of the visualization layer in the same manner as for the distributed computing graph.

In an example a data source such as a text file exists on a local machine operated by a user. The user is able to create or modify a graph layout view of a distributed computing graph using a user interface at an entity in the distributed computing system such as PC . This is achieved by connecting a node representing the text file to one or more other nodes representing other entities in the distributed computing system and in this way a process is added to the graph. For example these other entities may comprise a remote web service. The edge in the graph created between the text file node and the web service node may be implemented using a SOAP call to the web service to send the text file data to the web service for processing. However this is not essential. Any suitable method of implementing the edge in the graph may be used. Another process may then be added to the graph layout view of the distributed computing graph. For example this process may be a local executable file which is added as a node to the graph layout view by connecting it to the node representing the web service. This connection may be implemented using a SOAP call to the web service to pull the processed text file data from the web service. Another process may be created and a node representing it connected to the node representing the executable file. This newly added process may represent a file comprising the pulled data and is interpreted as a file by the distributed computing system. In this way a file system is effectively used to perform the process making use of remote web services. The file system and web service are examples only and may be substituted by any other suitable technology. For example databases custom executable files for computational processes reading and writing to and from files.

Within the distributed computing system processes are able to notify each other. This is implemented using any suitable notification mechanism for example using push and pull notification mechanisms or publish and subscribe mechanisms. Once a process is completed for example the web service call is finished in the above example a local representation of the process actively sends out to all entities in the distributed computing system a notification to indicate this using the particular notification mechanism being used.

Any suitable methods may be used to enable the processes and the local graph nodes to communicate. For example an application programming interface is provided at each entity. This may be used by a programmer to link a process to a local graph item. For example the application programming interface provides a set of contracts and communication mechanisms to be used by local representations of processes in the graph layout views to communicate with one another in the distributed computing system. In this way the graph layout view of a process may be thought of as a wrapper which enables a process to talk to one or more other graph items. Thus process events such as process notification process error process completion may be communicated to other graph items. Whether two processes are able to communicate may be specified by details in the wrappers.

The documents storing the graph layout view distributed computing graph and visualization layer may be exported to various stand alone formats that can be run without the need for a graph engine. For example distributed computing graph documents may be rendered directly to programming source code for use in creating desktop applications or web applications.

The graph layout view of the distributed computing graph comprises nodes connected by links. At least some of the nodes represent processes carried out at specified entities in a distributed computing system. For example node represents a process carried out at machine A for example this might be to retrieve data node represents a process carried out at machine B for example to carry out computations using the data from node A and node represent processes carried out at machine C of for example to carry out computations on the results provided by node B . Node may represent processes to retrieve or format data from entity D. Nodes and may be in a community .

In embodiments a user is able to drag and drop icons into the graph layout view of the distributed computing graph. These icons may be pre configured and provided by the graph engine. The icons are a type of node and represent processes currently executing in the distributed computing system. Each icon has an associated specified functionality. For example an icon representing a data bus may be a line which may be sized and shaped by a user to connect a plurality of nodes in the graph layout view. Other examples of icons include spooler player icons multiplexer icons debugging breakpoint icons debugging inspector icons and navigator icons. By inserting such icons into a graph layout view a user is able to create and implement the functionality represented by those icons in the distributed computing system in a simple and effective manner. The term icon is used to refer to a graphical item suitable for display at a graphical user interface and which represents functionality with which it is associated.

A visualization layer is illustrated in . This layer is optional and enables a display of outputs from an activity to be easily created and managed. The visualization layer may comprise any combination of views view ports and user interface objects. For example these views view ports and user interface objects are connected to nodes in the distributed computing graph using a suitable application programming interface. This enables data output from the processes represented by the nodes of the distributed computing graph to be directly provided to the visualization layer. For example shows a web page displaying data from process A of the distributed computing graph. It also shows a graphical user interface display comprising a button that may be activated or deactivated depending on data output from process B of the distributed computing graph. A ranked list of documents may also be presented at this graphical user interface display using output from process D of the distributed computing graph.

Entities in the distributed computing system have access to the distributed computing graph and form their own graph layout views of this graph. Also each participant in an activity has access to the associated distributed computing graph even if that participant does not host any parts of that activity. The graph layout views are dynamically updated in order that they correspond to the distributed computing graph in the event that any changes occur in the distributed computing graph. Also if a change is made at a graph layout view of the distributed computing graph this change is dynamically updated in the distributed computing graph itself and so is updated in graph layout views at each of the entities in the distributed computing system. That is each graph layout view always reflects changes made by others in the distributed computing system.

As mentioned above each participant in an activity has access to the associated distributed computing graph even if that participant does not host any parts of that activity. For example a participant may require only to view the output of an experiment. In this case the participant connects to the distributed computing graph concerned but does not provide any input data storage processing capabilities or other resources for sharing.

When a user edits or creates the graph layout view of the distributed computing graph he or she is able to add a bus as illustrated in which shows part of a distributed computing graph. In the example of three nodes are shown in the distributed computing graph connected along bus . By drawing a bus on the graph layout view of the distributed computing graph the user is able to specify how data is to be shared between the nodes on the bus. The nodes on the bus represent processes which may either write data to the bus read data from the bus or both read and write data to the bus. For example the bus enables the user to specify that functionality of a two way data connection be provided between the processes such that anything a writer puts onto the bus can be read by all readers and all reader writers simultaneously.

In order to enable the bus functionality to be implemented a graph engine at the user s machine dynamically updates the distributed computing graph shared in the distributed computing system. This update process comprises adding any connections or inserting intermediaries in order to implement the bus functionality.

Optionally the dynamic update process may also implement a check pointing mechanism using the bus. This is achieved by adding one or more data stores at automatically selected locations in the distributed computing graph and configuring those to store data written to the bus at specified intervals. The graph engine has access to rules or other criteria to enable it to automatically select appropriate locations for the data stores in the distributed computing graph and find and use appropriate data stores in the distributed computing system. For example for the portion of a bus segment that connects components that all execute on a single computer a single checkpoint data store can be created on the local disk drive. For busses which transect two or more computers one checkpoint dataset may be created on the local disk storage system of each computer. The timing of checkpoint writes to the checkpoint data store may be determined heuristically based on the rate of change of data on the bus which is monitored along with user provided preferences. For instance for processes where computation is very costly meaning that repeating the computation would require much time or the use of computer resources that incur monetary expense the user might choose to request more frequent checkpoints however for very large volumes of data that can be cheaply and quickly reproduced the user might request few or no checkpoints on that data bus.

The graph engine automatically inserts data stores on the bus at locations it selects as shown in the middle part of . For example data store is able to store data written to the bus by writer and data store is able to store data written to the bus by writer . Data may be written to the data stores from the bus at specified intervals. In this way if a process connected to the bus fails or stops for any reason then when that process resumes it is possible to recover the activity of the distributed computing graph by using the data from the data stores. Also by using data store the latency introduced by the different hardware connecting writer to the bus can be accommodated.

In other examples more than one data store may store duplicate data from the bus. For example in the case that the bus crosses a community boundary as illustrated in the bottom part of . In this example reader and writer are members of a community but the remainder of the bus is not. Suppose that a process leading to the writer is computationally very expensive and is carried out using a cluster of high performance computers. The reader writer may be at a home PC which is turned off at night. The user of the home PC may wish to make use of the cluster of high performance computers at night and is able to do so by using data store .

In another example a visualization layer document is opened by a user for the first time. At this stage the currently executing processes represented by the distributed computing graph produce outputs and data is written to data stores on the bus as described above. The data is displayed at the visualization layer document associated with the distributed computing graph. When the user closes the visualization layer document the currently executing processes proceed in the background. Later the user re opens the visualization layer document. It is then able to use data from the data stores unless the graph engine indicates that this data needs to be re computed.

The bus mechanisms described above may also be used for caching. In this case data from the data stores is used once checks have been made to find out whether that data may be relied upon or whether the computations that produced that data need to be re run. This improves computational efficiency and robustness since it is not necessary to re compute data in many situations. For example illustrates two buses as part of a distributed computing graph. A first one of the two buses connects a writer W reader R and reader writer . The second bus connects reader writer and reader R . The graph engine has automatically inserted two data stores and to the distributed computing graph as described above.

The process which produces the data written to the bus by writer W may be very computationally expensive and may be expected to take around one week to complete. The data written onto bus may be written to data store every 10 minutes. A check pointing mechanism may then be used as described above so that if the computationally expensive process fails and later resumes the overall activity can be picked up again using the data from data store . However suppose that the feeds to the process that leads to writer W change. For example this may be a result of a change in the graph layout view and hence the distributed computing graph. It may also be because of a change in the behavior of the feed itself. For example suppose that the feed is from a sensor network which monitors temperature. The monitored temperature may have been fluctuating about a relatively steady average temperature but then may change significantly and fluctuate about a new much higher average temperature. In this case the data from the data store may not be an accurate reflection of the current sensor network data. A graph engine at one or more entities in the distributed computing system is able to detect when feeds to a process change using the distributed computing graph. It uses this information to decide whether data from a particular data store may be relied upon or needs to be recomputed.

In practice the rate of a calculation at a process in the distributed computing graph rarely matches or exceeds the rate at which it is required to view the results of that calculation. Information may need to be updated at a user interface display several times per second but requires minutes hours or days to calculate. In order to address this data stores may be used as described above to store calculation results in readiness for later display. In addition spooler player mechanisms may be used to decouple rate of calculation from rate of visualization as now described.

When a user creates or edits a graph layout view of a distributed computing graph he or she is able to drag and drop a spooler player icon into the graph layout view. A graph engine at the entity providing the graph layout view detects the added spooler player icon and updates the underlying distributed computing graph such that a spooler player process is added. This is achieved as a result of the dynamic mapping between the graph layout view and the distributed computing graph.

With reference to a graph engine is arranged to update a distributed computing graph in order to provide a spooler player process with the following functionality. The spooler process is arranged to store data from a producer process to which it is connected at a spool store. That data may be stored using representations selected on the basis of metadata provided to the spooler process from the producer process . A player process is arranged to play data from the spool store to a visualization layer on the basis of user input. That user input may be received at the visualization layer . The spooler process is also able to request data from the producer on the basis of user input rules or other criteria and knowledge of the spool store. The knowledge about the spool store such as the range of data held in the spool store the capacity of the spool store may be stored at data store .

For example suppose that slider is set at year 1960. Suppose that data from 1959 to 1961 is currently in the spool store. The player process plays data for the year 1960 from the spool store to the visualization layer. If the user moves the slider to the year 1990 the player process is able to access data store and determine that data for that year is not available in the spool store . The spooler process requests the data for year 1990 from the producer . The spooler process uses rules or other criteria to intelligently sequence its requests for data from the producer . For example when seeking data for a particular date range the data for the mid point of the range may be requested first followed by data for dates either side of the mid point beginning closest to the mid point and working away from the mid point towards the limits of the date range. In another example the spooler process may sequence its requests for data so that data points for times more recent than the currently displayed data point are requested before data points for times prior to the currently displayed data point. This is beneficial for applications where users are likely to require more recent data values.

Data can typically be analyzed at a multitude of different scales each suited to different tasks or decision processes. For example the same data stream may be analyzed using a plurality of different models each suited to a different scale. For example illustrates a plurality of different scales for analyzing forest data a planetary or globe level a country level an individual tree level and an individual leaf level. Different models may be available for each of these different scales and these are illustrated as models to in . For example model may be a set of ordinary differential equations ODEs . Model may be a different set of ODEs which is more expensive to run. Model may be a perfect plasticity model and model may be an individual leaf model.

If a distributed computing system is arranged to implement an activity as described herein it may comprise a distributed computing graph controlling a plurality of currently executing processes. Those processes may each be suited to a different scale of data analysis for example by implementing models to of . In that case the distributed computing graph may comprise a multiplex node as illustrated in . For example a programmer may drag and drop a multiplex icon into a graph layout view of the distributed computing graph. A dynamic update process occurs as described above and a multiplex mechanism is created automatically in the distributed computing graph by a graph engine at the distributed computing entity used by the programmer A visualization layer may comprise a user control as part of a user interface. This user control is associated with the multiplex mechanism in the distributed computing graph by a programmer using a suitable application programming interface. Each of the models is a currently executing process in the distributed computing system. The user control enables a user to specify which of the models is to be selected to provide output to the visualization layer. In this way an end user is able to view live outputs from the different currently executing models in a simple and effective manner.

As described above a distributed computing graph controls currently executing processes in a distributed computing system. As a result it is difficult for a programmer or controller of an activity to debug potential errors in a distributed computing graph because all the processes are always running and cannot be stopped for debugging purposes. To assist with debugging a graph engine is arranged to detect break points added to a graph layout view of a distributed computing graph. This break point is automatically implemented by the graph engine by inserting one or more buffers in the distributed computing graph. This is now described with reference to .

The upper part of shows part of a graph layout view of a distributed computing graph. It comprises nodes representing processes A B and C where process A outputs data to process B which in turn outputs data to process C. A user places a break point between nodes A and B as illustrated and sets parameter values for that break point. For example those parameter values may be latitude x longitude y and data value 12. The corresponding part of a distributed computing graph is illustrated in the bottom part of and shows buffer added between process A and process B.

The graph engine detects a break point added to the graph layout view. The break point has associated conditions specified by a programmer. The graph engine automatically inserts a buffer in the distributed computing graph. The buffer is arranged to automatically store data if the specified conditions are met and optionally to display a pop up at a user interface in that event. The buffer may be arranged to let data flow through the buffer in steps. The buffer may also be arranged to let a reduced flow of data through. In another example the buffer may be arranged to repeatedly output the same piece of data.

In another example a programmer is able to add an inspector icon to a graph layout view. The programmer may input one or more criteria with the inspector icon. A graph engine detects the added inspector and automatically inserts a user interface object at a corresponding visualization layer in order to display data output from a process adjacent to the inspector icon. The user interface object may be configured to take into account the criteria provided with the inspector icon. For example the data output from a process may comprise latitude longitude temperature triplets. The criteria may be to only display latitude values.

Previously dedicated applications have been provided to write computer programs and separate dedicated applications have been provided to write text documents and create visual displays of data such as slide packs charts and graphs. In order to display data calculated by a computer program it has previously been possible to pre compute the data using the computer program and then copy and paste that data into another application to create slide packs charts graphs and the like. The data in the slide packs and other documents is then static and quickly becomes out of date or not relevant as time goes by.

In embodiments described herein a visualization layer may be provided in a manner which enables a dynamic link to be maintained between data calculated by one or more processes and visual displays documents decision maker dashboards and or user interfaces. For example a visualization layer may comprise a plurality of web pages or slides in a presentation document. The order or sequence in which those web pages or slides are to be presented may be varied dynamically according to data output from one or more computational processes controlled by a distributed computing graph.

For example a user or programmer is able to drag and drop a navigator icon or other data driven navigation tool into a graph layout view as illustrated in . In this example the navigator icon is connected to each of three processes A B and C. A distributed computing graph associated with the graph layout view is also illustrated. This controls currently executing processes A B and C which produce data streams. The distributed computing graph comprises functionality for implementing the navigator logic associated with the navigator icon. This functionality is added to the distributed computing graph by a graph engine automatically as part of the dynamic mapping between the graph layout view and the distributed computing graph.

A visualization layer comprises four display items such as slides or documents or user interface items or web pages . Those web pages are linked to one or more of the processes A B C as illustrated and dynamically display live data from the processes to which they are linked. Each display item comprises a next button or other user interface item which enables a user to move to a subsequent web page or display in a sequence of display items. However the sequence of display items or web pages is not pre specified but is rather dynamically determined using navigator logic and data from the currently executing processes A B C.

For example a visualization layer may receive user input selecting a next button or similar user interface device . Navigator logic at the distributed computing graph is used to select which web page or slide or document or user interface item to present next on the basis of data observed from one or more of the currently executing processes. In this way data streams from the currently executing processes are used to influence a user interface display presentation document or decision maker dashboard in a simple and effective manner. Thus data may be used to drive the flow of a slide presentation and or aspects of a visualization.

In many cases processes in the distributed computing system run much longer than an individual user s laptop may be turned on for. For example a user may start a computation that runs in a high performance computer community and then close his or her laptop. Later when the user starts up the laptop it is updated with the latest data from the ongoing computation.

Each part of a computation each community participant has its own graph engine which manages the local computation. Each participant has its own copy of the controlling document the activity for the ongoing computation. Computations are driven and controlled by the document not by any one computer so it is possible to start a computation by opening a document on one computer and then open the same document on another computer and see the current data. In this way a decentralized document is provided to control a distributed or cloud computing system. Data may also be stored via the document either in a local location that is replicated to other participants or in a shared well known location like a cloud store . These things all work together to create documents that appear to run on the cloud and which appear to continue to run even when a user is not actively watching controlling them. Documents may stop computing when they have either reached their cache limits or when the calculations naturally wind down.

Computing based device also comprises one or more processors which may be microprocessors controllers or any other suitable type of processors for processing computing executable instructions to control the operation of the device in order to operate as part of a distributed computing system. Platform software comprising an operating system or any other suitable platform software may be provided at the computing based device to enable application software to be executed on the device. The computing based device comprises a graph engine which implements a dynamic mapping with a distributed computing graph as described herein. A visualization component may be provided to implement a visualization layer associated with the distributed computing graph. A data store may be provided to buffer store or cache data.

The computer executable instructions may be provided using any computer readable media that is accessible by computing based device . Computer readable media may include for example computer storage media such as memory and communications media. Computer storage media such as memory includes volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EPROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that can be used to store information for access by a computing device. In contrast communication media may embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism. Although the computer storage media memory is shown within the computing based device it will be appreciated that the storage may be distributed or located remotely and accessed via a network or other communication link e.g. using communication interface .

The computing based device also comprises an input output controller arranged to output display information to a display device which may be separate from or integral to the computing based device . The display information may provide a graphical user interface. The input output controller is also arranged to receive and process input from one or more devices such as a user input device e.g. a mouse or a keyboard . This user input may be used to influence or select data to be presented on the display device . In an embodiment the display device may also act as the user input device if it is a touch sensitive display device. The input output controller may also output data to devices other than the display device e.g. a locally connected printing device.

The term computer is used herein to refer to any device with processing capability such that it can execute instructions. Those skilled in the art will realize that such processing capabilities are incorporated into many different devices and therefore the term computer includes PCs servers mobile telephones personal digital assistants and many other devices.

The methods described herein may be performed by software in machine readable form on a tangible storage medium. Examples of tangible or non transitory storage media include disks thumb drives memory etc and do not include propagated signals. The software can be suitable for execution on a parallel processor or a serial processor such that the method steps may be carried out in any suitable order or simultaneously.

This acknowledges that software can be a valuable separately tradable commodity. It is intended to encompass software which runs on or controls dumb or standard hardware to carry out the desired functions. It is also intended to encompass software which describes or defines the configuration of hardware such as HDL hardware description language software as is used for designing silicon chips or for configuring universal programmable chips to carry out desired functions.

Those skilled in the art will realize that storage devices utilized to store program instructions can be distributed across a network. For example a remote computer may store an example of the process described as software. A local or terminal computer may access the remote computer and download a part or all of the software to run the program. Alternatively the local computer may download pieces of the software as needed or execute some software instructions at the local terminal and some at the remote computer or computer network . Those skilled in the art will also realize that by utilizing conventional techniques known to those skilled in the art that all or a portion of the software instructions may be carried out by a dedicated circuit such as a DSP programmable logic array or the like.

Any range or device value given herein may be extended or altered without losing the effect sought as will be apparent to the skilled person.

It will be understood that the benefits and advantages described above may relate to one embodiment or may relate to several embodiments. The embodiments are not limited to those that solve any or all of the stated problems or those that have any or all of the stated benefits and advantages. It will further be understood that reference to an item refers to one or more of those items.

The steps of the methods described herein may be carried out in any suitable order or simultaneously where appropriate. Additionally individual blocks may be deleted from any of the methods without departing from the spirit and scope of the subject matter described herein. Aspects of any of the examples described above may be combined with aspects of any of the other examples described to form further examples without losing the effect sought.

The term comprising is used herein to mean including the method blocks or elements identified but that such blocks or elements do not comprise an exclusive list and a method or apparatus may contain additional blocks or elements.

It will be understood that the above description of a preferred embodiment is given by way of example only and that various modifications may be made by those skilled in the art. The above specification examples and data provide a complete description of the structure and use of exemplary embodiments of the invention. Although various embodiments of the invention have been described above with a certain degree of particularity or with reference to one or more individual embodiments those skilled in the art could make numerous alterations to the disclosed embodiments without departing from the spirit or scope of this invention.

