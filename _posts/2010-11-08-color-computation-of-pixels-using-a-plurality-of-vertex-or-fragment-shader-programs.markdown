---

title: Color computation of pixels using a plurality of vertex or fragment shader programs
abstract: A plurality of vertex or fragment processors on a graphics processor perform computations. Each vertex or fragment processor is capable of executing a separate program to compute a specific result. A combiner manages the combination of the results from the respective processors, and produces a final transformed vertex or pixel value. The vertex or fragment processors and the combiner can be programmable to modify their operations. As such, the vertex or fragment processors can operate in a parallel or serial configuration, or both. The combiner manages and resolves the operations of the serial and/or parallel configurations. A synchronization barrier enables the combiner to perform data-dependency analysis to determine the timing and ordering of the respective processors' execution. A transformation module can include one or more programmable vertex processors that transforms three-dimensional geometric data into fragments. The fragment processors subsequently receive and compute a result for each fragment, which is combined using the combiner to produce the final pixel value.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08194083&OS=08194083&RS=08194083
owner: Graphics Properties Holdings, Inc.
number: 08194083
owner_city: Newark
owner_country: US
publication_date: 20101108
---
This application is a continuation of U.S. patent application Ser. No. 11 183 848 filed Jul. 19 2005 now allowed which is incorporated by reference herein in its entirety.

The present invention relates generally to producing computer generated images and more specifically to computing pixel values for said images.

Computer graphics processing algorithms can be categorized into two principal methods ray tracing and rasterization. Almost all modern computer graphics cards implement the rasterization method. This method is characterized by a graphics pipeline that dictates how three dimensional geometric data as well as two dimensional pixel data are processed to ultimately be displayed in a frame buffer. For each geometric primitive the corresponding geometric data enters a transformation stage and is transformed into fragments. Those fragments and their corresponding pixel data are rasterized to compute a final pixel color. This version of the pipeline is commonly called the fixed function pipeline. 

Recent generations of graphics processors have diverged from the fixed function pipeline model. In these implementations the fixed order of functions performed by either the transformation or rasterization stages is replaced by a user defined computer program commonly termed a shader. However conventional programmable pipelines suffer from substantial limitations. For example during the rasterization stage a single shader for coloring a pixel must perform all color computations for said pixel. Therefore if pixels share common color computations that are invariant between separate pixels and computed identically inside of the shader program the current shader architecture forces those computations to be redundantly computed. A similar situation exists in the processing of vertices by the transformation stage of the graphics pipeline.

User modifications of shader programs impose another limitation on conventional programmable pipelines. For instance if a pixel shader is programmed to perform multiple operations these operations are combined within the code of a single pixel shader so that all color computations are processed as discussed. If a user subsequently decides to modify one or more of these multiple operations the user must re write the code for the single pixel shader to alter the corresponding subroutine for each modified operation. The entire shader program with the altered subroutine s must be downloaded to a graphics card and executed to implement the modified operation s . If the amount of time required for either constructing or downloading a program is proportional to the program s length making a tiny change to one aspect of the rasterization process induces a penalty of the combined length of all the operations.

Therefore a need exists to develop a technology that addresses these concerns and facilitates the ability to generate graphics in a timely and cost effective manner.

A method system and computer program product are provided for utilizing a plurality of vertex processors whether implemented in hardware and or software and or a plurality of fragment processors whether implemented in hardware and or software each executing a user defined vertex or fragment program on a graphics processing unit GPU to generate a graphics image.

Unless otherwise specified the term processor is used herein to indicate either a vertex processor or a fragment processor without loss of generality.

One or more programmable vertex processors can be implemented on the GPU to perform computation for a vertex. Each vertex processor is capable of executing a separate vertex program to generate transformed vertices suitable for processing in rasterization. A control unit or combiner manages the combination of the results from the vertex processors and produces a final transformed vertex to be processed subsequently by the fragment part of the graphics pipeline.

One or more programmable fragment processors can be implemented on the GPU to perform computations for a pixel. Each fragment processor is capable of executing a separate fragment program to produce a specific result during the computations. A control unit or combiner manages the combination of the results from the fragment processors and produces a final pixel value such as color characteristics.

The processors can operate in a parallel configuration. As such each processor operates independently and mutually exclusive of each other. The control unit would combine the results of the parallel operations to produce the final computed vertex or pixel value.

The processors can also operate in a serial configuration. As such the collection of processors operate in a sequential order and the results of one processor are passed as input to a subsequent processor. The last result is passed to the control unit which resolves the final computed vertex or pixel value. In an embodiment the output of each processor is fed into the control unit which takes the output possibly modifies it and passes it into the next processor in line.

The processors can also operate in a multi tiered configuration. As such combinations of serial and parallel operations are performed by the collection of processors and these operations are managed and resolved by the control unit. To facilitate the synchronization of output from each processor especially with regards to the parallel operations a synchronization barrier enables the control unit to perform data dependency analysis to determine which processor needs to execute before other processors.

In an embodiment the results of each processor are enhanced with a data field s that provides instructions to the control unit for resolving the final vertex or pixel value from the results. In another embodiment a separate user defined combiner program is executed to provide combination instructions to the control unit for resolving the final vertex or pixel value from the results. In an embodiment a combiner processor is programmable to receive instructions from user created programs. In another embodiment the operations of the control unit are fixed by the system architect.

In an embodiment a transformation module includes one or more programmable vertex processors. The vertex processor s perform a sequence of operations including but not limited to operations that transforms three dimensional geometric coordinates vertices into two dimensional window or screen oriented coordinates clip coordinates . Additional vertex specific data may also be computed during the execution of the vertex shader on the vertex processor. The clip coordinates are subsequently passed to a rasterization module along with possibly additional two dimensional pixel data that generates fragments which are ultimately processed into color pixel values. The rasterization module contains the one or more programmable fragment processors which compute the results contributing to the final pixel value.

This specification discloses one or more embodiments that incorporate the features of this invention. The embodiment s described and references in the specification to one embodiment an embodiment an example embodiment etc. indicate that the embodiment s described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic. Moreover such phrases are not necessarily referring to the same embodiment. Further when a particular feature structure or characteristic is described in connection with an embodiment it is submitted that it is within the knowledge of one skilled in the relevant art s to effect such feature structure or characteristic in connection with other embodiments whether or not explicitly described.

A method system and computer program product are provided for utilizing a plurality of vertex processors whether implemented in hardware and or software and or a plurality of fragment processors whether implemented in hardware and or software each executing a user defined vertex or fragment program on a graphics processing unit GPU to generate a graphics image.

Unless otherwise specified the term processor is used herein to indicate either a vertex processor or a fragment processor without loss of generality.

In an embodiment a plurality of programmable vertex processors are utilized on the GPU to perform specific computations for a vertex. Each vertex processor is capable of executing a separate program and can be executed in series and or in parallel with respect to the other vertex processors. A control unit manages the combinations of the results from the distinct vertex processors into a final transformed vertex with possible associated data for subsequent processing in the rasterization part of the graphics pipeline.

Similarly in an embodiment a plurality of programmable fragment processors are utilized on the GPU to perform specific computations for a pixel. Each fragment processor is capable of executing a separate program and can be executed in series and or in parallel with respect to other fragment processors. A control unit manages the combination of the results from the distinct fragment processors into a final value for the pixel. Specific embodiments of the present invention are discussed in greater detail below.

The following terms are defined so that they may be used to describe embodiments of the present invention. As used herein 

 Vertex means a data structure that is used to represent a point in three dimensional space possibly with additional data for example color surface properties etc. .

 Pixel means a data structure that is used to represent a picture element. Any type of pixel format can be used.

 Texture refers to image data or other types of data that can be mapped to an object to provide additional surface detail or other effects. In computer graphics applications texture is often a data structure including but not limited to an array of texels. A texel can include but is not limited to a color value or an intensity value. These texel values are used in rendering to determine a value for a pixel. As used herein the term texture includes for example texture maps bump maps and gloss maps.

 Texture sample refers to a sample selected from a texture map or texture. The sample can represent one texel value or can be formed from two or more texel values blended together. Different weighting factors can be used for each texel blended together to form a sample. The terms texel sample and texture sample are sometimes used interchangeably.

 Texture unit refers to graphics hardware firmware and or software that can be used to obtain a texture sample e.g. a point sample or a filtered texture sample from a texture. A texture unit can in some embodiments obtain multiple texture samples from multiple textures.

Architecture includes six overlapping layers . Layer represents a high level software application program. Layer represents a three dimensional 3D graphics software tool kit such as the OPENGL PERFORMER toolkit available from Silicon Graphics Inc. Mountain View Calif. . Layer represents a graphics application programming interface API which can include but is not limited to the OPENGL API available from Silicon Graphics Inc. Mountain View Calif. the DIRECTX API available from Microsoft Corporation Redmond Wash. or the like. Layer represents system support such as operating system and or windowing system support. Layer represents firmware. Finally layer represents hardware including graphics hardware. Hardware can be any hardware or graphics hardware including but not limited to a computer graphics processor single chip or multiple chip a specially designed computer an interactive graphics machine a gaming platform a low end game system a game console a network architecture et cetera.

In other embodiments of the present invention less than all of the layers of architecture can be implemented. As will be apparent to a person skilled in the relevant art s after reading the description of the invention herein various features of the present invention can be implemented in any one of the layers of architecture or in any combination of layers of architecture .

Host system comprises an application program a hardware interface or graphics API a processor and a memory . Application program can be any program requiring the rendering of a computer image. The computer code of application program is executed by processor . Application program assesses the features of graphics subsystem and display through hardware interface or graphics API . Memory stores information used by application program .

Graphics subsystem comprises a vertex operation module a rasterizer a texture memory and a frame buffer . Texture memory can store one or more textures or images such as texture . Texture memory is connected to a texture unit by a bus . Rasterizer comprises a pixel operation module a texture unit and a blending unit . Texture unit and blending unit can be implemented separately or together as part of a graphics processor.

In embodiments of the present invention texture unit can obtain multiple point samples or multiple filtered texture samples from textures and or images stored in texture memory . Blending unit blends texels and or pixel values according to weighting values to produce a single texel or pixel. The output of texture unit and or blending unit is stored in frame buffer . Display can be used to display images stored in frame buffer .

The embodiment of the invention shown in has a multipass graphics pipeline. It is capable of operating on each pixel of an image object during each pass that the image makes through the graphics pipeline. For each pixel of the image during each pass that the image makes through the graphics pipeline texture unit can obtain at least one texture sample from the textures and or data stored in texture memory . Although the embodiment of the invention shown in has a multipass graphics pipeline it is noted here that other embodiments of the invention do not have a multipass graphics pipeline. Moreover method embodiments of the invention can be implemented using systems that do not have a multipass graphics pipeline.

According to embodiments of the present invention a plurality of fragment processors are implemented within the graphics processing unit GPU such as graphics subsystem to compute a pixel value such as color characteristics. Each fragment processor is capable of executing a separate program.

Another embodiment of a GPU that is useful for implementing an embodiment of the present invention is illustrated in as a multi shading graphics subsystem . Multi shading graphics subsystem is characterized as a programmable graphics pipeline that processes three dimensional geometric data and two dimensional pixel data to display a single pixel in a frame buffer .

The three dimensional geometric data for the pixel is passed to a transformation module e.g. vertex operation module . Transformation module executes one or more vertex shader programs. The vertex shader program s perform a sequence of mathematical operations that transform the three dimensional geometric data into clip coordinates.

The two dimensional pixel data for the pixel is passed to a rasterization module e.g. rasterizer . Rasterization module applies the two dimensional pixel data and the clip coordinates from transformation module to generate fragments. Rasterization module also shades the fragments in a process that enables the computation of a final value e.g. color for the pixel. The rasterization computations can also include a depth value for determining whether the pixel is visible or occluded by other objects in a scene.

Rasterization module includes a plurality of fragment processors that execute a plurality of pixel shader programs to conduct for example various color computations to generate the pixel s final color. The color computations include a base color application a color application from a texture lookup table e.g. texture memory a blending of the base color with a color present at the pixel s location in frame buffer various tests to determine whether a fragment should be written into frame buffer or the like. If a fragment passes all enabled tests its color is transferred into frame buffer at the pre computed location.

To compute the pixel s final value the results of fragment processors are passed to a combiner . Combiner is a control unit that is capable of arithmetic and or logic processing. Thus combiner can mathematically combine the results from fragment processors and or select a certain result s from fragment processors thereby discarding the non selected result s . The final value is passed to frame buffer as discussed.

As discussed multi shading graphics subsystem is a programmable graphics pipeline. As such one or more of the vertex shader programs of transformation module and or one or more of the pixel shader programs of rasterization module are user created programs that instruct graphics subsystem to performs specified operations on the data e.g. three dimensional geometric data and two dimensional pixel data . Since the shader programs of transformation module and rasterization module are individually programmable a graphics programmer or user can control various aspects of the geometric processing as discussed in greater detail below.

With respect to the plurality of fragment processors each fragment processors is capable of executing a separate program. For instance depicts n fragment processors for executing n separate programs. As would be apparent to one skilled in the relevant art s the quantity of fragment processors depicted in are shown for illustrative purposes only. The actual quantity can be any value as determined by the system architect.

An example of an assembly language that could be used write the first fragment program for fragment processor is provided below 

The assembly language used to write the above example is part of a published specification from the OPENGL Architecture Review Board ARB the ARB fragment program extension. Other assembly languages could be used to implement the present invention. As can be seen in the above code the first fragment program for fragment processor takes the input fragment color i.e. fragment.color and transfers it to the resulting pixel color i.e. result.color .

An example of an assembly language that can be used write the second fragment program for fragment processor is provided below 

As can be seen in the above code the second fragment program executed on fragment processor retrieves the colors from a texture map to color the pixel.

An example of the assembly language that can be used to write the third fragment program for fragment processor is provided below 

As can be seen in the above code the third fragment program executed on fragment processor computes the color of the pixel using a common simplified lighting model.

To combine the results together combiner is instructed to put the outputs from the fragment processors together. Depending upon the implementation of the interface for combiner different approaches can be utilized to program combiner . In an embodiment combiner is programmed in a language similar to the fragment programs for fragment processors as discussed above. An example of such a program for combiner is provided below 

The above approach would most likely use a small subset of the commands of the complete fragment processing language but would be more flexible than having to use the full processing language. In another embodiment a fixed set of subroutines is used to program combiner to combine the results of fragment processors . A similar set of procedures exists in the OPENGL API available from Silicon Graphics Inc. Mountain View Calif. that currently programs texture combiners which were effectively replaced by a fragment processor . An example of the set of subroutines used to program combiner is provided below 

The above approach would include appropriate mappings of inputs to results and mathematical operations on those inputs. If a graphics board e.g. graphics subsystem has multiple fragment processors and the language to program these processors is a superset of the operations that combiner uses then one of the fragment processors could be re tasked assuming suitable circuitry to handle mapping inputs to outputs to be combiner and programmed suitably.

In an embodiment user created programs are executed to create or modify fragment processors . In another embodiment a user may be blocked from modifying one or more of fragment processors . This configuration is useful in a case where a software library allows a user to program selected fragment processor s but make other fragment processor s available to graphics subsystem for its own use.

Although n serialized fragment processors are provided for illustrative purposes the actual quantity of fragment processors that can be provided in series can be determined by the system architect. Additionally user created programs can be executed to create or modify all or a subset of the serialized fragment processors and or selected fragment processors can be reserved for utilization by graphics subsystem .

User created programs can be executed to create or modify all or a subset of the fragment processors and or selected fragment processors can be reserved for utilization by graphics subsystem . Additionally the quantity or ordering of the parallel and serial fragment processors can be altered as determined by the system architect. Given a set of fragment processors some subset of those fragment processors could execute in series with each other while other fragment processors execute in parallel and have their outputs fed into combiner which combines those values together and passes its output into some other subset of fragment processors and so on. Therefore it is important that the operations of each fragment processors are synchronized to improve system correctness performance and efficiency.

In an embodiment having serial fragment processors such as fragment processors the output of every fragment processors is fed into combiner which takes the output possibly modifies it and passes it into the next fragment processor in line. In this embodiment the synchronization of output from the fragment processor e.g. fragment processor is implicit since combiner cannot continue until an upstream fragment processor has finished its work.

In an embodiment having parallel fragment processors such as fragment processors the fragment processors execute in parallel and combiner receives all of their output. When all fragment processing is complete combiner combines the values together and outputs the result. In this embodiment the output from the fragment processors should be synchronized to enhance the performance of combiner .

In an embodiment having multi tiered fragment processors such as fragment processors some fragment processors execute and pass their output into combiner . Combiner passes the results into the next fragment processors which proceed to pass their results back into combiner and so on until all fragment processors have completed their programs in the designated order. In this embodiment the synchronization of output from the fragment processors e.g. fragment processors are influenced by combiner which operates as a traffic cop designating in what order and by whom operations proceed. With respect to the serial executions combiner merely waits until a previous stage is completed and then either computes the final result or passes data onto the next stage. For the parallel executions combiner needs to wait until all of the outputs from all currently parallel executing fragment processors e.g. fragment processors have completed before proceeding. Combiner therefore includes a synchronization barrier that enables compiler to perform data dependency analysis to determine which fragment processors e.g. fragment processors need to execute before other fragment processors can proceed.

The present invention also includes various techniques for instructing the operations of combiner . In an embodiment the results of each fragment processor e.g. fragment processors are enhanced with a data field that provides instructions to combiner for resolving the final pixel value from the results. In another embodiment a separate combiner program is executed to provide combination instructions to combiner for resolving the final pixel value from the results. In an embodiment the data field or combiner program is programmable to receive instructions from user created programs. In another embodiment the operations of combiner are fixed by the system architect.

As discussed above in an embodiment of the present invention a plurality of vertex processors are executed by a graphics processing unit GPU such as graphics subsystem to transform three dimensional geometric data such as data into alternative coordinates such as three dimensional eye coordinates two dimensional normalized device coordinates two dimensional clip coordinates and the like . Each vertex processors is capable of executing a separate vertex program to produce a specific result during the transformation.

Transformation module includes a vertex data dispatcher a plurality of vertex processors and a vertex results combiner . Transformation module is configured to operate a plurality of vertex processors shown as vertex processors in parallel mode. As such vertex data dispatcher accesses the three dimensional data from host system and forwards the data along the correct path to the appropriate vertex processor 

To compute the final clip coordinates vertex results combiner mathematically combines the results from vertex processors and or selects a certain result s from vertex processors . Therefore vertex results combiner is a control unit that is capable of arithmetic and or logic processing.

As discussed one or more of the plurality of vertex processors are individually programmable and each vertex processor are capable of executing a separate vertex program. The quantity of vertex processors can vary as determined by the system architect.

In another embodiment of the present invention a plurality of vertex processors are provided in a serial configuration. illustrates another embodiment of multi shading graphics subsystem which serializes the processing of geometric data e.g. data through transformation module . As shown transformation module includes a plurality of vertex processors communications infrastructure and vertex results combiner . Vertex processors serializes the processing through transformation module such that the results of one vertex processor is passed as input into a subsequent vertex processor until all enabled processing stages have completed. The last result from vertex processor is passed to vertex results combiner which computes the final clip coordinate.

Communications infrastructure can be a communications bus or the like such as communications infrastructure described below with reference to . Communications infrastructure provides bidirectional communications among vertex processors and vertex results combiner . The information exchanged during the bidirectional communications includes but is not limited to results from vertex processors synchronization information and intermediate output from vertex results combiner .

As discussed one or more of the plurality of vertex processors are individually programmable and each vertex processor are capable of executing a separate vertex program. Additionally the quantity of vertex processors can vary as determined by the system architect. Moreover in other embodiments a plurality vertex processors can be provided to support a combination of parallel vertex shading e.g. vertex processors and serial vertex shading e.g. vertex processors . In such a multi tiered environment one or more parallel vertex processors e.g. execute and pass their output to vertex results combiner which proceeds to pass results to one or more serial vertex processors e.g. . The serial vertex processors s e.g. would in turn pass results back to vertex results combiner and so on until all vertex processors have completed their programs in a designated order. As such vertex combiner synchronizes the operations similarly to combiner as discussed above.

The present invention provides significant improvements over an existing graphics system that includes multiple vertex or fragment processors in a single instruction multiple data SLMD environment. For example a single fragment processor must contain all color computations for the pixel that is being processed. Therefore if one or more of these color computations must be applied to other pixels the entire fragment program must be executed to re compute the re occurring color computations. However the present invention does not require redundant or re occurring computations for multiple pixels to be re computed for each pixel. Such computations can be stored and re utilized during the computations for other pixels. As a result significant savings can be realized over the processing time when compared to the existing graphics system with a single fragment processor.

The present invention also better manages user modifications to fragment programming than an existing graphics system with a single fragment processor. For example should a user program the fragment processor to perform N operations these operations would be combined within the code for a single fragment program. The single fragment program would be downloaded to a graphics card and executed. Should the user decide to modify one or more of the N operations the user would need to re write the single fragment program to alter the subroutine for each modified operation. The entire fragment program with the altered subroutine s must be downloaded and executed to implement the modified operation s . If the amount of time required for either constructing or downloading a program is proportional to the program s length making a tiny change to one aspect of the fragment s processing induces a penalty of the combined length of all the operations.

However the user programmable processors e.g. fragment processors vertex processors etc. of the present invention allow a user to configure a combiner e.g. combiner combiner etc. to run the processing in a sequential mode as discussed above. If a user desires to change a small part of one or more operations performed by a respective processors e.g. fragment processors vertex processors etc. the only penalty incurred by the system e.g. system is that associated with constructing and reloading the modified processor s e.g. fragment processors vertex processors etc. . The operation s performed by the unmodified program executing on its assigned processor e.g. fragment processors vertex processors etc. impose no significant adverse impacts on system efficiency.

The present invention improves the efficiency and efficacy of post processing operation s that are outside of what the original application author or user has considered. For example assume that the fragment processing operations of a graphics system cannot be modified. However a user desires to modify one more images generated by a fragment program e.g. color correction or balance blurring or sharpening of the image or other image processing operations . With an existing single fragment execution engine the user would need to have the single fragment program generate the images and save them to off line storage i.e. retrieve the image from the graphic board s frame buffer and store it in the system s memory or disk drive . Afterwards the user must reload the fragment processor with the post processing operations and submit the previous image to the graphics subsystem for subsequent processing. The fragment processor would thereafter pass the images back to the graphics board and generate the output.

However according to embodiments of the present invention the user programs the combiner e.g. combiner to take the output of a first processor e.g. fragment processor and pass it into a second processor e.g. fragment processor that is programmed to generate a final result. This is beneficial on many fronts first retrieving images from a graphics board is a slow operation and then the images need to be sent back down to the graphics board for the subsequent processing which also takes time. The difference in bandwidths and speeds of doing all of the processing on the board in a single pass is orders of magnitude faster than the read back approach executed by the above described existing single fragment processor.

In an embodiment of the present invention a user or user program can intercept the graphics commands of a graphics application and perform post processing on the associated operation s . If a single fragment or vertex program executing on a fragment or vertex processor is being utilized the bookkeeping relative to managing the single processor is more intensive in comparison with the bookkeeping relative to managing multiple processors e.g. fragment processors vertex processors etc. . Utilizing a combiner e.g. combiner combiner etc. and a plurality of programs executing on processors e.g. fragment processors vertex processors etc. a user can execute the interception commands to thereby turn on and turn off certain processing features without having to do much with the graphic applications original command stream. Using a single processor the user or components of the graphics system must preserve the graphics application s graphics state which usually either requires reading it from a graphics board which slows down operations or keeping track of every change executed by the interception commands so that the user can replace them if the user makes subsequent modifications which is tedious and prone to errors .

The present invention can be implemented in one or more computer systems capable of carrying out the functionality described herein. illustrates an example of a computer system that can be used to implement computer program product embodiments of the present invention. This example computer system is illustrative and not intended to limit the present invention. Computer system represents any single or multi processor computer. Single threaded and multi threaded computers can be used. Unified or distributed memory systems can be used.

Computer system includes one or more processors such as processor and one or more graphics subsystems such as graphics subsystem . One or more processors and one or more graphics subsystems e.g. graphics subsystem or graphics subsystem can execute software and implement all or part of the features of the present invention described herein. Graphics subsystem forwards graphics text and other data from the communications infrastructure or from a frame buffer e.g. frame buffer for display on the display e.g. display . Graphics subsystem can be implemented for example on a single chip as a part of processor or it can be implemented on one or more separate chips located on a graphic board. Each processor is connected to a communications infrastructure e.g. a communications bus cross bar or network . After reading this description it will become apparent to a person skilled in the relevant art s how to implement the invention using other computer systems and or computer architectures.

Computer system also includes a main memory preferably random access memory RAM and can also include secondary memory . Secondary memory can include for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive an optical disk drive etc. The removable storage drive reads from and or writes to a removable storage unit in a well known manner. Removable storage unit represents a floppy disk magnetic tape optical disk etc. which is read by and written to by removable storage drive . As will be appreciated the removable storage unit includes a computer usable storage medium having stored therein computer software e.g. programs or other instructions and or data.

In alternative embodiments secondary memory may include other similar means for allowing computer software and or data to be loaded into computer system . Such means can include for example a removable storage unit and an interface . Examples of such can include a program cartridge and cartridge interface such as that found in video game devices a removable memory chip such as an EPROM or PROM and associated socket and other removable storage units and interfaces which allow software and data to be transferred from the removable storage unit to computer system .

In an embodiment computer system includes a frame buffer and a display . Frame buffer is in electrical communications with graphics subsystem . Images stored in frame buffer can be viewed using display . Many of the features of the invention described herein are performed within the graphics subsystem .

Computer system can also include a communications interface . Communications interface allows software and data to be transferred between computer system and external devices via communications path . Examples of communications interface can include a modem a network interface such as Ethernet card a communications port a PCMCIA slot and card etc. Software and data transferred via communications interface are in the form of signals which can be electronic electromagnetic optical or other signals capable of being received by communications interface via communications path . Note that communications interface provides a means by which computer system can interface to a network such as the Internet. Communications path carries signals and can be implemented using wire or cable fiber optics a phone line a cellular phone link an RF link free space optics and or other communications channels.

Computer system can include one or more peripheral devices which are coupled to communications infrastructure by graphical user interface . Example peripheral devices which can form a part of computer system include for example a keyboard a pointing device e.g. a mouse a joy stick and a game pad. Other peripheral devices which can form a part of computer system will be known to a person skilled in the relevant art s given the description herein.

In this document the term computer program medium and computer usable medium are used to generally refer to media such as removable storage unit removable storage unit a hard disk installed in hard disk drive or a carrier wave or other signal carrying software over a communications path to communications interface . These computer program products are means for providing software to computer system .

Computer programs also called computer control logic or computer readable program code are stored in main memory and or secondary memory . Computer programs can also be received via communications interface . Such computer programs when executed enable the computer system to perform the features of the present invention as discussed herein. In particular the computer programs when executed enable the processor to perform the features of the present invention. Accordingly such computer programs represent controllers of the computer system .

In an embodiment where the invention is implemented using software the software may be stored in a computer program product and loaded into computer system using removable storage drive hard drive interface or communications interface . Alternatively the computer program product may be downloaded to computer system over communications path . The control logic software when executed by the one or more processors causes the processor s to perform the functions of the invention as described herein.

In another embodiment the invention is implemented primarily in firmware and or hardware using for example hardware components such as application specific integrated circuits ASICs . Implementation of a hardware state machine so as to perform the functions described herein will be apparent to a person skilled in the relevant art s .

In yet another embodiment the invention is implemented using a combination of both hardware and software.

The foregoing description of the specific embodiments will so fully reveal the general nature of the invention that others can by applying knowledge within the skill of the art including the contents of the documents cited and incorporated by reference herein readily modify and or adapt for various applications such specific embodiments without undue experimentation without departing from the general concept of the present invention. Therefore such adaptations and modifications are intended to be within the meaning and range of equivalents of the disclosed embodiments based on the teaching and guidance presented herein. It is to be understood that the phraseology or terminology herein is for the purpose of description and not of limitation such that the terminology or phraseology of the present specification is to be interpreted by the skilled artisan in light of the teachings and guidance presented herein in combination with the knowledge of one skilled in the art.

While various embodiments of the present invention have been described above it should be understood that they have been presented by way of example and not limitation. It will be apparent to one skilled in the relevant art s that various changes in form and detail can be made therein without departing from the spirit and scope of the invention. Thus the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

