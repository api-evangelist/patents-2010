---

title: Shared memory between child and parent partitions
abstract: A mechanism for the creation of a shared memory aperture between modes in a parent and child partition is described. The shared memory aperture can be created between any memory mode between the guest and any host. For example, a shared memory aperture can be created between the kernel mode on the child partition and the user mode on the parent partition.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08463980&OS=08463980&RS=08463980
owner: Microsoft Corporation
number: 08463980
owner_city: Redmond
owner_country: US
publication_date: 20100930
---
One increasingly popular form of networking may generally be referred to as remote presentation systems which can use protocols such as Remote Desktop Protocol RDP and Independent Computing Architecture ICA to share a desktop and other applications executing on a server with a remote client. Such computing systems typically transmit the keyboard presses and mouse clicks or selections from the client to the server relaying the screen updates back in the other direction over a network connection e.g. the Internet . As such the user has the experience as if his or her machine is operating entirely locally when in reality the client device is only sent screenshots of the desktop or applications as they appear on the server side.

The user graphics and video may be rendered at a server for each user. The resulting bitmaps may then be sent to the client for display and interaction. In some systems the graphics accelerator such as a GPU may also be virtualized. For example rather than modeling a complete hardware GPU the GPU may be virtualized and thus provide for an abstracted software only GPU that presents a software interface different from that of the underlying hardware. By providing a virtualized GPU a virtual machine may enable a rich user experience with for example accelerated 3D rendering and multimedia without the need for the virtual machine to be associated with a particular GPU product.

In some cases a virtualized device on the child partition such as a virtualized GPU may transfer large amount of data to the host partition in order to emulate a video capable card. Due to the limitations of standard virtual machine bus mechanisms the transfer of such large amounts of data may impose burdens on the system design and performance.

In various embodiments memory may be allocated in the child partition and a mapping may be created using virtualization system APIs. This mapping may then be transferred to the host partition where additional virtualization system APIs may assist in mapping the memory into the host partition s user space. Additional synchronization mechanisms and read write APIs may allow applications on both the child and parent partitions to read the data in the shared memory. Furthermore the ability to map any region of memory in the child to the parent whether kernel or user space may also be provided.

Certain specific details are set forth in the following description and figures to provide a thorough understanding of various embodiments of the disclosure. Certain well known details often associated with computing and software technology are not set forth in the following disclosure to avoid unnecessarily obscuring the various embodiments of the disclosure. Further those of ordinary skill in the relevant art will understand that they can practice other embodiments of the disclosure without one or more of the details described below. Finally while various methods are described with reference to steps and sequences in the following disclosure the description as such is for providing a clear implementation of embodiments of the disclosure and the steps and sequences of steps should not be taken as required to practice this disclosure.

It should be understood that the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the disclosure or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the disclosure. In the case of program code execution on programmable computers the computing device generally includes a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may implement or utilize the processes described in connection with the disclosure e.g. through the use of an application programming interface API reusable controls or the like. Such programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

A remote desktop system is a computer system that maintains applications that can be remotely executed by client computer systems. Input is entered at a client computer system and transferred over a network e.g. using protocols based on the International Telecommunications Union ITU T.120 family of protocols such as Remote Desktop Protocol RDP to an application on a terminal server. The application processes the input as if the input were entered at the terminal server. The application generates output in response to the received input and the output is transferred over the network to the client

Embodiments may execute on one or more computers. and the following discussion are intended to provide a brief general description of a suitable computing environment in which the disclosure may be implemented. One skilled in the art can appreciate that computer systems can have some or all of the components described with respect to computer of .

The term circuitry used throughout the disclosure can include hardware components such as hardware interrupt controllers hard drives network adaptors graphics processors hardware based video audio codecs and the firmware software used to operate such hardware. The term circuitry can also include microprocessors configured to perform function s by firmware or by switches set in a certain way or one or more logical processors e.g. one or more cores of a multi core general processing unit. The logical processor s in this example can be configured by software instructions embodying logic operable to perform function s that are loaded from memory e.g. RAM ROM firmware and or virtual memory. In example embodiments where circuitry includes a combination of hardware and software an implementer may write source code embodying logic that is subsequently compiled into machine readable code that can be executed by a logical processor. Since one skilled in the art can appreciate that the state of the art has evolved to a point where there is little difference between hardware software or a combination of hardware software the selection of hardware versus software to effectuate functions is merely a design choice. Thus since one of skill in the art can appreciate that a software process can be transformed into an equivalent hardware structure and a hardware structure can itself be transformed into an equivalent software process the selection of a hardware implementation versus a software implementation is trivial and left to an implementer.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computer through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite disk scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or universal serial bus USB . A display or other type of display device can also be connected to the system bus via an interface such as a video adapter . In addition to the display computers typically include other peripheral output devices not shown such as speakers and printers. The system of also includes a host adapter Small Computer System Interface SCSI bus and an external storage device connected to the SCSI bus .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another computer a server a router a network PC a peer device or other common network node a virtual machine and typically can include many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in can include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer can be connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer can typically include a modem or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external can be connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are examples and other means of establishing a communications link between the computers may be used. Moreover while it is envisioned that numerous embodiments of the disclosure are particularly well suited for computer systems nothing in this document is intended to limit the disclosure to such embodiments.

Referring now to another embodiment of an exemplary computing system is depicted. Computer system can include a logical processor e.g. an execution core. While one logical processor is illustrated in other embodiments computer system may have multiple logical processors e.g. multiple execution cores per processor substrate and or multiple processor substrates that could each have multiple execution cores. As shown by the figure various computer readable storage media can be interconnected by one or more system busses which couples various system components to the logical processor . The system buses may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. In example embodiments the computer readable storage media can include for example random access memory RAM storage device e.g. electromechanical hard drive solid state hard drive etc. firmware e.g. FLASH RAM or ROM and removable storage devices such as for example CD ROMs floppy disks DVDs FLASH drives external storage devices etc. It should be appreciated by those skilled in the art that other types of computer readable storage media can be used such as magnetic cassettes flash memory cards digital video disks Bernoulli cartridges.

The computer readable storage media provide non volatile storage of processor executable instructions data structures program modules and other data for the computer . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computer system such as during start up can be stored in firmware . A number of programs may be stored on firmware storage device RAM and or removable storage devices and executed by logical processor including an operating system and or application programs.

Commands and information may be received by computer through input devices which can include but are not limited to a keyboard and pointing device. Other input devices may include a microphone joystick game pad scanner or the like. These and other input devices are often connected to the logical processor through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or universal serial bus USB . A display or other type of display device can also be connected to the system bus via an interface such as a video adapter which can be part of or connected to a graphics processor . In addition to the display computers typically include other peripheral output devices not shown such as speakers and printers. The exemplary system of can also include a host adapter Small Computer System Interface SCSI bus and an external storage device connected to the SCSI bus.

Computer system may operate in a networked environment using logical connections to one or more remote computers such as a remote computer. The remote computer may be another computer a server a router a network PC a peer device or other common network node and typically can include many or all of the elements described above relative to computer system .

When used in a LAN or WAN networking environment computer system can be connected to the LAN or WAN through a network interface card . The NIC which may be internal or external can be connected to the system bus. In a networked environment program modules depicted relative to the computer system or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections described here are exemplary and other means of establishing a communications link between the computers may be used. Moreover while it is envisioned that numerous embodiments of the present disclosure are particularly well suited for computerized systems nothing in this document is intended to limit the disclosure to such embodiments.

A remote desktop system is a computer system that maintains applications that can be remotely executed by client computer systems. Input is entered at a client computer system and transferred over a network e.g. using protocols based on the International Telecommunications Union ITU T.120 family of protocols such as Remote Desktop Protocol RDP to an application on a terminal server. The application processes the input as if the input were entered at the terminal server. The application generates output in response to the received input and the output is transferred over the network to the client computer system. The client computer system presents the output data. Thus input is received and output presented at the client computer system while processing actually occurs at the terminal server. A session can include a shell and a user interface such as a desktop the subsystems that track mouse movement within the desktop the subsystems that translate a mouse click on an icon into commands that effectuate an instance of a program etc. In another example embodiment the session can include an application. In this example while an application is rendered a desktop environment may still be generated and hidden from the user. It should be understood that the foregoing discussion is exemplary and that the presently disclosed subject matter may be implemented in various client server environments and not limited to a particular terminal services product.

In most if not all remote desktop environments input data entered at a client computer system typically includes mouse and keyboard data representing commands to an application and output data generated by an application at the terminal server typically includes video data for display on a video output device. Many remote desktop environments also include functionality that extend to transfer other types of data.

Communications channels can be used to extend the RDP protocol by allowing plug ins to transfer data over an RDP connection. Many such extensions exist. Features such as printer redirection clipboard redirection port redirection etc. use communications channel technology. Thus in addition to input and output data there may be many communications channels that need to transfer data. Accordingly there may be occasional requests to transfer output data and one or more channel requests to transfer other data contending for available network bandwidth.

Referring now to depicted are high level block diagrams of computer systems configured to effectuate virtual machines. As shown in the figures computer system can include elements described in and components operable to effectuate virtual machines. One such component is a hypervisor that may also be referred to in the art as a virtual machine monitor. The hypervisor in the depicted embodiment can be configured to control and arbitrate access to the hardware of computer system . Broadly stated the hypervisor can generate execution environments called partitions such as child partition through child partition N where N is an integer greater than or equal to 1 . In embodiments a child partition can be considered the basic unit of isolation supported by the hypervisor that is each child partition can be mapped to a set of hardware resources e.g. memory devices logical processor cycles etc. that is under control of the hypervisor and or the parent partition and hypervisor can isolate one partition from accessing another partition s resources. In embodiments the hypervisor can be a stand alone software product a part of an operating system embedded within firmware of the motherboard specialized integrated circuits or a combination thereof.

In the above example computer system includes a parent partition that can also be thought of as domain in the open source community. Parent partition can be configured to provide resources to guest operating systems executing in child partitions N by using virtualization service providers VSPs that are also known as back end drivers in the open source community. In this example architecture the parent partition can gate access to the underlying hardware. The VSPs can be used to multiplex the interfaces to the hardware resources by way of virtualization service clients VSCs that are also known as front end drivers in the open source community. Each child partition can include one or more virtual processors such as virtual processors through that guest operating systems through can manage and schedule threads to execute thereon. Generally the virtual processors through are executable instructions and associated state information that provide a representation of a physical processor with a specific architecture. For example one virtual machine may have a virtual processor having characteristics of an Intel x86 processor whereas another virtual processor may have the characteristics of a PowerPC processor. The virtual processors in this example can be mapped to logical processors of the computer system such that the instructions that effectuate the virtual processors will be backed by logical processors. Thus in these example embodiments multiple virtual processors can be simultaneously executing while for example another logical processor is executing hypervisor instructions. Generally speaking and as illustrated by the figures the combination of virtual processors various VSCs and memory in a partition can be considered a virtual machine such as virtual machine or .

Generally guest operating systems through can include any operating system such as for example operating systems from Microsoft Apple the open source community etc. The guest operating systems can include user kernel modes of operation and can have kernels that can include schedulers memory managers etc. A kernel mode can include an execution mode in a logical processor that grants access to at least privileged processor instructions. Each guest operating system through can have associated file systems that can have applications stored thereon such as terminal servers e commerce servers email servers etc. and the guest operating systems themselves. The guest operating systems can schedule threads to execute on the virtual processors and instances of such applications can be effectuated.

Referring now to illustrated is an alternative architecture that can be used to effectuate virtual machines. depicts similar components to those of however in this example embodiment the hypervisor can include the virtualization service providers and device drivers and parent partition may contain configuration utilities . In this architecture hypervisor can perform the same or similar functions as the hypervisor of . The hypervisor of can be a stand alone software product a part of an operating system embedded within firmware of the motherboard or a portion of hypervisor can be effectuated by specialized integrated circuits. In this example parent partition may have instructions that can be used to configure hypervisor however hardware access requests may be handled by hypervisor instead of being passed to parent partition .

Referring now to computer may include circuitry configured to provide remote desktop services to connecting clients. In an example embodiment the depicted operating system may execute directly on the hardware or a guest operating system or may be effectuated by a virtual machine such as VM or VM . The underlying hardware and is indicated in the illustrated type of dashed lines to identify that the hardware can be virtualized.

Remote services can be provided to at least one client such as client while one client is depicted remote services can be provided to more clients. The example client can include a computer terminal that is effectuated by hardware configured to direct user input to a remote server session and display user interface information generated by the session. In another embodiment client can be effectuated by a computer that includes similar elements as those of computer . In this embodiment client can include circuitry configured to effect operating systems and circuitry configured to emulate the functionality of terminals e.g. a remote desktop client application that can be executed by one or more logical processors . One skilled in the art can appreciate that the circuitry configured to effectuate the operating system can also include circuitry configured to emulate a terminal.

Each connecting client can have a session such as session which allows the client to access data and applications stored on computer . Generally applications and certain operating system components can be loaded into a region of memory assigned to a session. Thus in certain instances some OS components can be spawned N times where N represents the number of current sessions . These various OS components can request services from the operating system kernel which can for example manage memory facilitate disk reads writes and configure threads from each session to execute on the logical processor . Some example subsystems that can be loaded into session space can include the subsystems that generates desktop environments the subsystems that track mouse movement within the desktop the subsystems that translate mouse clicks on icons into commands that effectuate an instance of a program etc. The processes that effectuate these services e.g. tracking mouse movement are tagged with an identifier associated with the session and are loaded into a region of memory that is allocated to the session.

A session can be generated by a session manager e.g. a process. For example the session manager can initialize and manage each remote session by generating a session identifier for a session space assigning memory to the session space and generating system environment variables and instances of subsystem processes in memory assigned to the session space. The session manager can be invoked when a request for a remote desktop session is received by the operating system .

A connection request can first be handled by a transport stack e.g. a remote desktop protocol RDP stack. The transport stack instructions can configure logical processor to listen for connection messages on a certain port and forward them to the session manager . When sessions are generated the transport stack can instantiate a remote desktop protocol stack instance for each session. Stack instance is an example stack instance that can be generated for session . Generally each remote desktop protocol stack instance can be configured to route output to an associated client and route client input to an environment subsystem for the appropriate remote session.

As shown by the figure in an embodiment an application while one is shown others can also execute can execute and generate an array of bits. The array can be processed by a graphics interface which in turn can render bitmaps e.g. arrays of pixel values that can be stored in memory. As shown by the figure a remote display subsystem can be instantiated which can capture rendering calls and send the calls over the network to client via the stack instance for the session.

In addition to remoting graphics and audio a plug and play redirector can also be instantiated in order to remote diverse devices such as printers mp3 players client file systems CD ROM drives etc. The plug and play redirector can receive information from a client side component which identifies the peripheral devices coupled to the client . The plug and play redirector can then configure the operating system to load redirecting device drivers for the peripheral devices of the client . The redirecting device drivers can receive calls from the operating system to access the peripherals and send the calls over the network to the client .

As discussed above clients may use a protocol for providing remote presentation services such as Remote Desktop Protocol RDP to connect to a resource using terminal services. When a remote desktop client connects to a terminal server via a terminal server gateway the gateway may open a socket connection with the terminal server and redirect client traffic on the remote presentation port or a port dedicated to remote access services. The gateway may also perform certain gateway specific exchanges with the client using a terminal server gateway protocol transmitted over HTTPS.

Turning to depicted is a computer system including circuitry for effectuating remote services and for incorporating aspects of the present disclosure. As shown by the figure in an embodiment a computer system can include components similar to those described in and and can effectuate a remote presentation session. In an embodiment of the present disclosure a remote presentation session can include aspects of a console session e.g. a session spawned for a user using the computer system and a remote session. Similar to that described above the session manager can initialize and manage the remote presentation session by enabling disabling components in order to effectuate a remote presentation session.

One set of components that can be loaded in a remote presentation session are the console components that enable high fidelity remoting namely the components that take advantage of 3D graphics and 2D graphics rendered by 3D hardware.

3D 2D graphics rendered by 3D hardware can be accessed using a driver model that includes a user mode driver an API a graphics kernel and a kernel mode driver . An application or any other process such as a user interface that generates 3D graphics can generate API constructs and send them to an application programming interface API such as Direct3D from Microsoft . The API in turn can communicate with a user mode driver which can generates primitives e.g. the fundamental geometric shapes used in computer graphics represented as vertices and constants which are used as building blocks for other shapes and stores them in buffers e.g. pages of memory. In one embodiment the application can declare how it is going to use the buffer e.g. what type of data it is going to store in the buffer. An application such as a videogame may use a dynamic buffer to store primitives for an avatar and a static buffer for storing data that will not change often such as data that represents a building or a forest.

Continuing with the description of the driver model the application can fill the buffers with primitives and issue execute commands. When the application issues an execute command the buffer can be appended to a run list by the kernel mode driver and scheduled by the graphics kernel scheduler . Each graphics source e.g. application or user interface can have a context and its own run list. The graphics kernel can be configured to schedule various contexts to execute on the graphics processing unit . The GPU scheduler can be executed by logical processor and the scheduler can issue a command to the kernel mode driver to render the contents of the buffer. The stack instance can be configured to receive the command and send the contents of the buffer over the network to the client where the buffer can be processed by the GPU of the client.

Illustrated now is an example of the operation of a virtualized GPU as used in conjunction with an application that calls for remote presentation services. Referring to in an embodiment a virtual machine session can be generated by a computer . For example a session manager can be executed by a logical processor and a remote session that includes certain remote components can be initialized. In this example the spawned session can include a kernel a graphics kernel a user mode display driver and a kernel mode display driver . The user mode driver can generate graphics primitives that can be stored in memory. For example the API can include interfaces that can be exposed to processes such as a user interface for the operating system or an application . The process can send high level API commands such as such as Point Lists Line Lists Line Strips Triangle Lists Triangle Strips or Triangle Fans to the API . The API can receive these commands and translate them into commands for the user mode driver which can then generate vertices and store them in one or more buffers. The GPU scheduler can run and determine to render the contents of the buffer. In this example the command to the graphics processing unit of the server can be captured and the content of the buffer primitives can be sent to client via network interface card . In an embodiment an API can be exposed by the session manager that components can interface with in order to determine whether a virtual GPU is available.

In an embodiment a virtual machine such as virtual machine of or can be instantiated and the virtual machine can serve as a platform for execution for the operating system . Guest operating system can embody operating system in this example. A virtual machine may be instantiated when a connection request is received over the network. For example the parent partition may include an instance of the transport stack and may be configured to receive connection requests. The parent partition may initialize a virtual machine in response to a connection request along with a guest operating system including the capabilities to effectuate remote sessions. The connection request can then be passed to the transport stack of the guest operating system . In this example each remote session may be instantiated on an operating system that is executed by its own virtual machine.

In one embodiment a virtual machine can be instantiated and a guest operating system embodying operating system can be executed. Similar to that described above a virtual machine may be instantiated when a connection request is received over the network. Remote sessions may be generated by an operating system. The session manager can be configured to determine that the request is for a session that supports 3D graphics rendering and the session manager can load a console session. In addition to loading the console session the session manager can load a stack instance for the session and configure system to capture primitives generated by a user mode display driver .

The user mode driver may generate graphics primitives that can be captured and stored in buffers accessible to the transport stack . A kernel mode driver can append the buffers to a run list for the application and a GPU scheduler can run and determine when to issue render commands for the buffers. When the scheduler issues a render command the command can be captured by for example the kernel mode driver and sent to the client via the stack instance .

The GPU scheduler may execute and determine to issue an instruction to render the content of the buffer. In this example the graphics primitives associated with the instruction to render can be sent to client via network interface card .

In an embodiment at least one kernel mode process can be executed by at least one logical processor and the at least one logical processor can synchronize rendering vertices stored in different buffers. For example a graphics processing scheduler which can operate similarly to an operating system scheduler can schedule GPU operations. The GPU scheduler can merge separate buffers of vertices into the correct execution order such that the graphics processing unit of the client executes the commands in an order that allows them to be rendered correctly.

One or more threads of a process such as a videogame may map multiple buffers and each thread may issue a draw command. Identification information for the vertices e.g. information generated per buffer per vertex or per batch of vertices in a buffer can be sent to the GPU scheduler . The information may be stored in a table along with identification information associated with vertices from the same or other processes and used to synchronize rendering of the various buffers.

An application such as a word processing program may execute and declare for example two buffers one for storing vertices for generating 3D menus and the other one storing commands for generating letters that will populate the menus. The application may map the buffer and issue draw commands. The GPU scheduler may determine the order for executing the two buffers such that the menus are rendered along with the letters in a way that it would be pleasing to look at. For example other processes may issue draw commands at the same or a substantially similar time and if the vertices were not synchronized vertices from different threads of different processes could be rendered asynchronously on the client thereby making the final image displayed seem chaotic or jumbled.

A bulk compressor can be used to compress the graphics primitives prior to sending the stream of data to the client . In an embodiment the bulk compressor can be a user mode not shown or kernel mode component of the stack instance and can be configured to look for similar patterns within the stream of data that is being sent to the client . In this embodiment since the bulk compressor receives a stream of vertices instead of receiving multiple API constructs from multiple applications the bulk compressor has a larger data set of vertices to sift through in order to find opportunities to compress. That is since the vertices for a plurality of processes are being remoted instead of diverse API calls there is a larger chance that the bulk compressor will be able to find similar patterns in a given stream.

In an embodiment the graphics processing unit may be configured to use virtual addressing instead of physical addresses for memory. Thus the pages of memory used as buffers can be paged to system RAM or to disk from video memory. The stack instance can be configured to obtain the virtual addresses of the buffers and send the contents from the virtual addresses when a render command from the graphics kernel is captured.

An operating system may be configured e.g. various subsystems and drivers can be loaded to capture primitives and send them to a remote computer such as client . Similar to that described above a session manager can be executed by a logical processor and a session that includes certain remote components can be initialized. In this example the spawned session can include a kernel a graphics kernel a user mode display driver and a kernel mode display driver .

A graphics kernel may schedule GPU operations. The GPU scheduler can merge separate buffers of vertices into the correct execution order such that the graphics processing unit of the client executes the commands in an order that allows them to be rendered correctly.

All of these variations for implementing the above mentioned partitions are just exemplary implementations and nothing herein should be interpreted as limiting the disclosure to any particular virtualization aspect.

A graphics processing unit or GPU is a specialized processor that offloads 3D graphics rendering from the microprocessor. A GPU may provide efficient processing of mathematical operations commonly used in graphics rendering by implementing various graphics primitive operations. A GPU may provide faster graphics processing as compared to the host CPU. A GPU may also be referred to as a graphic accelerator.

Graphics applications may use Application Programming Interfaces APIs to configure the graphics processing pipeline and provide shader programs which perform application specific vertex and pixel processing on the GPU. Many graphics applications interact with the GPU using an API such as Microsoft s DirectX or the OpenGL standard.

As described above virtualization operates by multiplexing physical hardware by presenting each virtual machine with a virtual device and combining their respective operations in the hypervisor or virtual machine monitor such that hardware resources are used while maintaining the perception that each virtual machine has a complete standalone hardware resource. As discussed a virtual machine monitor VMM or hypervisor is a software system that may partition a single physical machine into multiple virtual machines.

A virtual machine may render into a virtual device via the virtual GPU device driver. The actual rendering may be accomplished by accelerating the rendering using a single or multiple GPU controllers in another virtual machine the parent virtual machine or on a remote machine that acts as a graphics server that is shared by many guest virtual machines. An image capture component on the parent virtual machine may retrieve snapshots of the desktop images. The captured images can be optionally compressed and encoded prior to transmitting to the client. The compression and encoding can take place on the parent virtual machine or the child or guest virtual machine. A remote presentation protocol such as Remote Desktop Protocol RDP may be used to connect to the virtual machines from remote clients and for transmitting the desktop images. In this manner a remote user can experience graphical user interfaces such as Windows Aero and execute 3D applications and multimedia via a remote login.

The virtualization scheme may based on one or both of two modes. In one embodiment a user mode driver may provide for a virtualization boundary higher in the graphics stack and a kernel mode driver may provide a virtualization boundary lower in the graphics stack. In one embodiment the virtual GPU subsystem may comprise a display driver that further comprises user mode and kernel mode components that execute on the virtual machines and the render component of the render capture compress process that executes on the parent partition. In an embodiment the display driver may be a Windows Display Driver Model WDDM driver.

The virtual GPU subsystem may virtualize the physical GPU and provide accelerated rendering capability for the virtual machines. The virtual GPU driver may in one embodiment be a WDDM driver . The driver may remote corresponding commands and data to the parent partition for rendering. A rendering process which may be part of a render capture compress subsystem may perform the corresponding rendering on the GPU. For each virtual machine there may be provided a corresponding render capture compress component on the host or parent partition . WDDM drivers allow video memory to be virtualized with video data being paged out of video memory into system RAM.

On request by a graphics source sub system running on the child virtual machine the render capture compress subsystem may return compressed or uncompressed screen updates as appropriate. The screen updates may be based on the changed rectangle size and the content. The virtual GPU driver may support common operating systems such as VISTA and WINDOWS 7.

As discussed some embodiments may incorporate a WDDM driver. A WDDM driver acts as if the GPU is a device configured to draw pixels in video memory based on commands stored in a direct memory access DMA buffer. DMA buffer information may be sent to the GPU which asynchronously processes the data in order of submission. As each buffer completes the run time is notified and another buffer is submitted. Through execution of this processing loop video images may be processed and ultimately rendered on the user screens. Those skilled in the art will recognize that the disclosed subject matter may be implemented in systems that use OpenGL and other products.

DMA buffer scheduling may be driven by a GPU scheduler component in the kernel mode. The GPU scheduler may determine which DMA buffers are sent to the GPU and in what order.

The user mode driver may be configured to convert graphic commands issued by the 3D run time API into hardware specific commands and store the commands in a command buffer. This command buffer may then be submitted to the run time which in turn calls the kernel mode driver. The kernel mode driver may then construct a DMA buffer based on the contents of the command buffer. When it is time for a DMA buffer to be processed the GPU scheduler may call the kernel mode driver which handles all of the specifics of actually submitting the buffer to the GPU hardware.

The kernel mode driver may interface with the physical hardware of the display device. The user mode driver comprises hardware specific knowledge and can build hardware specific command buffers. However the user mode driver does not directly interface with the hardware and may rely on the kernel mode driver for that task. The kernel mode driver may program the display hardware and cause the display hardware to execute commands in the DMA buffer.

In one embodiment all interactions with the host or parent partition may be handled through the kernel mode driver. The kernel mode driver may send DMA buffer information to the parent partition and make the necessary callbacks into the kernel mode API run time when the DMA buffer has been processed. When the run time creates a graphics device context the run time may call a function for creating a graphics device context that holds a rendering state collection. In one embodiment a single kernel mode connection to the parent partition may be created when the first virtual graphics device is created. Subsequent graphics devices may be created with coordination from the user mode device and the connection to the parent partition for those devices may be handled by the user mode device.

In another embodiment a connection to the host or parent partition may be established each time the kernel mode driver creates a new device. A connection context may be created and stored in a per device data structure. This connection context may generally consist of a socket and I O buffers. Since all communication with the GVM goes through the kernel mode driver this per device connection context may help ensure that commands are routed to the correct device on the host or parent partition.

In one embodiment a separate thread may be provided on the host or parent partition for each running instance of the user mode device. This thread may be created when an application creates a virtual device on the child partition. An additional rendering thread may be provided to handle commands that originate from the kernel mode on the child partition e.g. kernel mode presentations and mouse pointer activity .

In one embodiment the number of rendering threads on the parent partition may be kept at a minimum to match the number of CPU cores.

Additional tasks may be performed when managing a GPU. For example in addition to providing graphics primitives the hardware context for the GPU may be maintained. Pixel shaders vertex shaders clipping planes scissor rectangles and other settings that affect the graphics pipeline may be configured. The user mode driver may also determine the logical values for these settings and how the values translate into physical settings.

In one embodiment the user mode driver may be responsible for constructing hardware contexts and command buffers. The kernel mode driver may be configured to convert command buffers into DMA buffers and provide the information to the GPU when scheduled by the GPU scheduler.

The virtual GPU may be implemented across several user mode and kernel mode components. In one embodiment a virtual machine transport VMT may be used as a protocol to send and receive requests across all the components. The VMT may provide communication between modules that span two or more partitions. Since there are multiple components in each partition that communicate across the partitions a common transport may be defined between the components.

The display driver may receive GPU specific commands and may be written to be hardware specific and control the GPU through a hardware interface. The display driver may program I O ports access memory mapped registers and otherwise interact with the low level operation of the GPU device. The virtual GPU driver may receive parent partition specific commands and may be written to a specific interface exposed by the parent partition . In one embodiment the parent partition may be a Direct3D application running on a different machine and the parent partition may act as a GPU that natively executes Direct3D commands. In this embodiment the commands that the user mode display driver receives from the Direct3D run time can be sent to the parent partition unmodified.

As shown in in one embodiment the Direct3D commands on the child partition may be encoded in the user mode driver and the kernel mode driver and sent along with the data parameters to the parent partition . On the parent partition a component may render the graphics by using the hardware GPU.

In another embodiment depicted in the Direct3D commands on the child partition may be sent to the user mode driver and the kernel mode driver . The commands may be interpreted adapted in the kernel mode driver and placed in DMA buffers in the kernel mode. The parent partition may provide virtual GPU functionality and command buffers may be constructed by the user mode driver . The command buffer information may be sent to the kernel mode driver where they may be converted into DMA buffers and submitted to the parent partition for execution. On the parent partition a component may render the commands on the hardware GPU.

When an application requests execution of a graphics processing function the corresponding command and video data may be made available to a command interpreter function. For example a hardware independent pixel shader program may be converted into a hardware specific program. The translated command and video data may be placed in the parent partition work queue. This queue may then be processed and the pending DMA buffers may be sent to the parent partition for execution. When the parent partition receives the commands and data the parent partition may use a Direct3D API to convert the commands data into a form that is specific to the parent partition s graphics hardware.

Thus in the child partition a GPU driver may be provided that conceptually looks to each virtual machine as a real graphics driver but in reality causes the routing of the virtual machine commands to the parent partition. On the parent partition the image may be rendered using the real GPU hardware.

In one illustrative embodiment depicted in a synthetic 3D video device may be exposed to the virtual machine and the virtual machine may search for drivers that match the video device. A virtual graphics display driver may be provided that matches the device which can be found and loaded by the virtual machine. Once loaded the virtual machine may determine that it can perform 3 D tasks and expose the device capabilities to the operating system which may use the functions of the virtualized device.

The commands received by the virtual machine may call the virtual device driver interface. A translation mechanism may translate the device driver commands to DirectX commands. The virtual machine thus believes it has access to a real GPU that calls the DDI and device driver. The device driver calls coming in are received and translated the data is received and on the parent side the DDI commands may be re created back into the DirectX API to render what was supposed to be rendered on the virtual machine. In some instances converting DDI commands into DirectX API commands may be inefficient. In other embodiments the DirectX API may be circumvented and the DDI commands may be converted directly into DDI commands on the host partition. In this embodiment the DirectX subsystem may be configured to allow for this circumvention.

In another embodiment only one connection may be established to the parent partition and communication with the graphics device contexts can be multiplexed over one communication channel. While there is typically a one to one mapping of graphics devices from the child partition to the parent partition in this embodiment the communication channel is not associated with any particular graphics device. A select device token may be sent before sending commands that are destined for a particular device. The select device token indicates that all subsequent commands should be routed to a particular graphics device. A subsequent select device token may be sent when graphics commands should to be sent to a different device.

Alternatively in another embodiment only one graphics device may available on the parent partition. Here a many to one mapping of devices from the child partition to devices on the parent partition may be implemented. The correct GPU state may be sent before sending commands associated with a particular graphics device. In this scenario the GPU state is maintained by the child partition instead of the parent partition. In this embodiment the illusion that multiple graphics device contexts exist on the child partition is created but in reality all are processed by one graphics device context on the parent partition that receives the correct GPU state before processing commands associated with a given child partition graphics device context.

Thus in various embodiments a GPU may be abstracted and device driver calls on a virtual machine may be sent to a parent partition where the commands are translated to use the API of the graphics server. Before sending to the parent partition the device driver calls may be converted into intermediate commands and data before they are sent to the parent partition and converted to the application level API. The intermediate stages may be implementation specific and depend on the particular hardware being used.

Using the above described techniques a stable virtual GPU can be synthesized and a given virtual machine need not be concerned with the particular piece of hardware that sits underneath as long as the minimum requirements are met by the underlying device. For example in one situation the parent partition may by using an NVIDIA GPU and in another case the parent partition may be using an ATI device. In either case a virtual set of capabilities may be exposed as long as the underlying GPU provides a minimal predetermined set of capabilities. The application running on the virtual machine operates as though the WDDM driver has a stable set of features. The virtual machine may be saved and migrated to another system using a different GPU without affecting the application using the GPU services.

In the GPU scenarios described above 3D graphics may be used. 3D graphics uses modeling via the wireframe representation of three dimensional objects that may be displayed as a two dimensional image using various 3D rendering techniques. Such techniques may for example represent a 3D object using a collection of points in 3D space connected by a geometric entity such as a triangle. When a scene in a video application is set up the various virtual objects the viewer s perspective color and lighting may be considered in generating a still image or an animation. Typically the 3D model s vertices are colored and that color may then be interpolated across the model s surface during rendering. One method of adding color information to a 3D model is by applying a 2D texture image to the model s surface using texture mapping. Textures may add detail surface texture or color to a computer generated graphic or 3D model. Vertex geometry information vertex buffers may comprise texture coordinates that indicate how to map the points of the texture image map to the 3D model s surface. The texture may be mapped to the surface of a shape such as a triangle that is typically used in 3D modeling. Additionally shaders may perform complex calculations to fetch from arbitrary locations within any number of textures.

3D applications typically require a significant amount of texture data to produce good quality scenes. The amount of texture data in turn requires a significant amount of space in memory and on the storage medium e.g. hard disk or optical disk .

As described above when virtualizing graphics hardware a significant amount of video memory may be needed for textures and other data. For example when running a 3D application in a virtual machine large amounts of graphics data may be pushed to the video drivers. Furthermore the actual rendering will occur on the parent partition and thus the graphics data must be transferred from the child partition to the parent partition.

As an additional factor the graphics data typically must be transferred not just from kernel mode in the child to the kernel mode on the parent because the renderer for the child partition uses a user mode application on the parent. The user mode application on the parent thus needs to send commands to the kernel mode in the child which then needs to transfer data to the user mode application in the parent.

Graphics data is one illustrative example of a scenario in which it is desirable to transfer large volumes of data between virtual machine partitions. The embodiments disclosed herein are applicable to any type of data and are not limited to the transfer of graphics data.

The above described need can be addressed by opening up a shared memory channel between the kernel mode in the guest and the user mode on the host. Such a transfer breaks a number of boundaries in which the shared memory must be remapped and reallocated in order for the user mode application to access the data that the kernel mode in the guest is trying to render.

However some solutions can be very inefficient. For example some systems may provide a custom kernel mode service on the host that talks to the kernel mode service on the guest. The host custom kernel mode service then needs to translate the kernel mode memory to user mode memory and talk to the user mode application on the host. This can be very expensive and cumbersome. For example some systems may first copy memory between the kernel mode in the child partition and the kernel mode in the parent. The data would then need to be copied from the kernel mode in the parent to the user mode area.

In various embodiments disclosed is a mechanism for the creation of a shared memory aperture between modes in a parent and child partition. The shared memory aperture can be created between any memory mode between the guest and any host. For example a shared memory aperture can be created between the kernel mode on the child partition and the user mode on the parent partition.

By using such a mechanism a direct bridge can be provided for example from the kernel mode in the child to the user mode in the parent. Such a bridge may provide the shortest path for data to be passed from the kernel or user mode in the child partition to the desired destination mode kernel or user in the parent partition and vice versa.

As further detailed below in some embodiments the size of aperture can be negotiated when the shared memory aperture is created. Furthermore in some embodiments the aperture can be established by leveraging existing APIs.

The Virtual Machine Bus VMBus may be a set of libraries and drivers that provide a mechanism to establish a channel between Virtual Service Provider VSP and Virtual Service Consumer VSC endpoints. The VMBus allows a VSP to publish virtual devices into virtual machines running in child partitions. In the child partition the VMBus provides a bus driver that exposes each synthetic virtual device that is published into that virtual machine. The guest OS running in the virtual machine then recognizes and installs the appropriate device driver stacks for the synthetic devices. The VMBus libraries also provide mechanisms to share memory between the child and parent partition and assists in virtual interrupt delivery across partitions.

The VSC may provide a direct interface with the virtualization system e.g. Hyper V components and establishes the VMBus channel to the synthetic virtual device running in a virtual machine. The VSP is a kernel mode driver running on the host OS in the parent partition. The VSP provides a VMBus channel into a virtual machine and if there is a synthetic device VSC component that accepts the channel offer the channel is created. The VSP and VSC act as the endpoints on the VMBus channel and communicate using an upstream ring buffer and a downstream ring buffer. The ring buffers may be used to exchange control packets and small data packets. If larger amounts of data need to be transferred then a shared memory buffer may be established. A VSP instance running in the parent partition may manage all of the channels established with VSC components in the various virtual machines running a particular synthetic device.

The VSC may be part of a synthetic virtual device running in a virtual machine and implements the interface between the synthetic device and the other Hyper V components. The VSC accepts the VMBus channel offer made by its corresponding VSP and uses the channel to exchange configuration and state management packets. The VSC may set up shared memory channels to the corresponding synthetic device components running in the parent partition.

In one embodiment a shared memory aperture may be created via a library. The library may have a number of APIs that allow for the creation and deletion of a shared memory aperture and reading and writing to the shared memory aperture. The library may be built into any component that wishes to use a shared memory aperture. The library may work with the corresponding synthetic device drivers on the parent and child partitions in order to communicate over the VMBus or any child parent communication system to establish a connection.

In an embodiment after the child partition boots the child partition can make a request of the parent by allocating memory creating a mapping and requesting a connection to the parent. The parent partition receives the connection request validates the connection request and verifies the mapping. After this verification is complete the parent partition maps the child memory into the host memory where the connection has been requested.

The parent and child partitions may use read and write APIs from the library to read and write to the memory region. Any sized memory region within limitations of parent and child memory can be created.

In the context of the some of the illustrative virtualization systems described above an instance of a desktop window manager process may be spawned by a desktop window manager broker when a new virtual machine is started. The desktop window manager process contains the rendering component that receives D3D command and data streams from the virtualized GPU components in the corresponding virtual machine. The desktop window manager process renders the D3D streams using the host OS Direct 3D software components and the physical GPUs managed by the host OS. The capture component of the desktop window manager determines which parts of each rendered frame have changed and encodes these frame differences. The capture component then passes the encoded data to the graphics source module of the user mode terminal services component.

The user mode terminal services component runs in the guest OS of a virtual machine in a child partition. The user mode terminal services component accepts a single user login from a client computer using a remote presentation connection. The user mode terminal services component creates a user session and handles the redirection of the various devices between the virtual desktop and the client computer. A shared memory channel may be used to receive the encoded frame difference display data for the remote virtual desktop and applications and sent over the remote presentation connection to the terminal services client software on the client computer where it is decoded and displayed.

The desktop window manager process renders the D3D command and data stream received from the device kernel mode and user mode driver components.

High performance transport channels are needed for the D3D command and data stream from the virtualized GPU drivers being sent to the render module in the desktop window manager process and the encoded frame difference data sent by the capture module to the graphics source in the user mode terminal services component. This need is handled by a shared memory transport channel library which provides a shared memory transport mechanism. The shared memory transport channel library provides an API that allows the creation of shared memory transport channels. The shared memory transport channel library interacts with the VSC and VSP components to map the allocated buffers so that the buffers are shared between the components running in the child and root partitions. Kernel mode and user mode versions of the library may be provided.

An Open function may be used to create the channel in the software components running in the guest OS in the child partition as well as the desktop window manager process instances running in the host OS. Once the channel has been created data can be sent in either direction using Send and Receive functions. The channel may be closed using a Close function.

When the Open function is called the shared memory transport channel library determines if it is running on the guest or on the host. If it is running on the guest the Open function allocates a memory buffer that is used to implement the two circular buffers and the control state in shared memory. The shared memory transport channel library opens a VSC device object and sends a DeviceIoControl message to the VSC driver requesting that the user mode or kernel mode buffer allocated in the child partition be shared with a root partition buffer in the shared memory transport channel library linked to the desktop window manager process.

The VSC driver obtains a memory descriptor list MDL for the buffer and locks the pages into the guest OS memory space. The VSC driver converts the MDL to a guest physical address descriptor list GPADL that describes the actual real system physical pages that the memory buffer has been allocated by the Hypervisor. The VSC sends a packet over the VMBus channel to the VSP requesting that the VSP complete the shared memory mapping operation.

The VSP driver converts the GPADL it receives from VSC driver into a host OS MDL and locks the pages in system memory. The render and capture modules in the desktop window manager process performs an Open function call to the shared memory transport channel library linked into the desktop window manager process. The shared memory transport channel library determines that it is running on the host and reserves a buffer of the same size as the one allocated on the guest and sends a DeviceIoControl waiting for the channel open request from the guest. The VSP uses the virtual address of the memory buffer that the shared memory transport channel library has reserved using a VirtualAlloc function and maps these reserved pages to the already allocated and locked system pages from the guest partition thus sharing the memory. The VSP uses unique identifiers to map the channel open request from the guest to the appropriate listening module in the desktop window manager process. The virtual machine partition ID is used to determine the guest virtual machine correspondence to the appropriate desktop window manager instance.

The Send and Receive calls transfer the data through the shared memory buffers and the details are transparent to the callers. The Receive function can operate in a blocked or non blocked mode based on a ReceiveMode parameter in the Open function. Alternatively a EventSelect function can be used to allow the reception of data to be signaled so that the caller can wait for a single or multiple events and then be signaled when one of the events occurs.

When the Close operation is called the VSC and VSP are called and the shared memory is unlocked unmapped and freed. The channel close return status is returned when any subsequent calls are made on the opposite endpoint. This endpoint then calls the Close to finalize the close operation.

The circular buffer and control memory used by the shared memory transport channel library may be allocated by a shared memory transport channel library. The library users may not have access to this internal memory other than indirectly through the Send and Receive functions. These functions may have client buffer pointer and byte count parameters. The library copies data from the send buffer into its internal shared memory buffer and then copies the data into the destination receive buffer. If the send buffer is larger than the internal buffer multiple transfers can be performed to send all of the data. The sender must make sure that the bytes specified by the send buffer pointer and byte count are in its send buffer. The receiver will receive the amount of data that is specified by the byte count in each call to Receive. The receiving process is responsible for making sure that its buffer pointer and byte counts do not result in receive buffer overflow.

The two channel endpoints control the format of the data they transfer over the channel. The shared memory transport channel library may be configured such that it does not check on the content of the data that is transferred. The two endpoints may be responsible to exchange version packets when the channels are opened and verify that the two endpoints can properly interoperate with each other. If this check fails the endpoints may call the Close function with a status indicating incompatible versions and the desktop window manager process may send status indicating a failure. The VSP notifies the system of the failure and the virtual machine startup will fail.

Accordingly a shared memory based transport channel API surface is provided that various components can utilize to transfer data between the components running in the child virtual machine partitions and the corresponding instances of the desktop window manager process running in the root partition. The shared memory transport channel library allows the current socket transport to be replaced with a higher performance transport solution.

The shared memory transport channels may be utilized by the other VDI components to enhance inter component data transfer performance. The shared memory transport channels provide bi directional data transfer capabilities utilizing inter virtual machine shared memory pages. The internal channel design provides an upstream and a downstream circular buffer between the channel endpoints and manages the streaming of data between the sending and receiving endpoints. A channel endpoint originates in a child virtual machine partition and terminates in the corresponding desktop window manager process running in the root partition. The child virtual machine endpoints can originate in the kernel mode driver the user mode driver and the graphics source module in the user mode terminal services component.

The user mode components may use the shared memory transport channel library to create and transfer data over an instance of the shared memory transport channel. Exemplary functions for the shared memory transport channel library are now described.

The components may open a channel using the Open function. The channels originate in the guest virtual machine to allow the shared memory buffer allocation to take place in the guest virtual machine. If the component calling Open is running in the guest virtual machine then the shared memory transport channel library allocates the memory buffer and sends a DeviceIoControl to the VSC driver to set up the shared memory buffer. If the Open function is called by the desktop window manager process that corresponds to the virtual machine running in the child partition it listens for the channel to be opened by a component in the guest virtual machine. The desktop window manager process reserves a buffer and sends a DeviceIoControl to the VSP to listen for the channel creation. When the guest virtual machine component opens the channel the VSC sends the VSP a message over the VMBus channel. The VSP maps the guest virtual machine buffer and the host buffer to the same system physical pages and responds to the listen for channel DeviceIoControl from the desktop window manager process. The Open function returns a handle that is used to specify this specific channel instance when calling the other shared memory transport channel library functions. The Close function closes the channel which causes all the shared memory to be unmapped and freed.

The Send function may be used to send a specified number of bytes to the opposite endpoint. The Receive function may be used to receive the data. The Receive function can operate in either blocking or non blocking mode which can be specified by the receive mode parameter in the Open function. The EventSelect function can be used to specify an event which can be signaled if either a specified amount or any amount of data has been received. This allows the channel owner to wait for the receive event to signal the presence of data. The Flush function may be used to block until all data that has been sent is received by the opposite endpoint.

The shared memory transport channels may be used to create multiple persistent channels between the software components running in the child partition and the corresponding desktop window manager process running in the root partition. The components running in the child partition open the channel instance when they are started. The desktop window manager process has threads that wait for a new channel connection to be made from child partition components as they are started. Once created the channels remain persistent until the components are being closed or when the virtual machine is being shutdown.

The shared memory transport channel library monitors the channel and detects if the channel stops functioning or if either side closes the channel. If a guest virtual machine component closes the channel the shared memory transport channel library notifies the opposite endpoint and sends the close channel DeviceIoControl to the VSC driver to unmap and free the memory. When it is notified of the channel being closed the desktop window manager process cleans up its state and call the Close function. This function sends a close channel DeviceIoControl to the VSP driver. The VSP coordinates with the VSC in the guest virtual machine to unmap and free the memory. If the close operation is initiated by a guest virtual machine component then this is considered a normal channel close.

If the desktop window manager process initiates the channel close then this can be considered a channel lost condition. This can occur if the desktop window manager process is terminated for any reason. In this case the channel lost status is conveyed to the guest virtual machine components that have open channels with the desktop window manager process instance that is terminating. The guest virtual machine components will now have inconsistent states and must reset themselves and re establish the channel connections when the desktop window manager process is restarted by the broker process.

A similar situation may exist when a virtual machine restore operation is performed. The desktop window manager process may not save all of the current D3D states during a save virtual machine operation. When the virtual machine is restored the desktop window manager process is restarted and listens for the channels to be created from the guest virtual machine. The guest virtual machine is completely saved and restored so the components must be reset and re establish the channels to the desktop window manager process. The shared memory transport channel library calls the error handler specified in the Open function or returns the CT VMT CHANNEL LOST return status. When the component receives the channel lost notification it must reset itself and re establish the channels.

Any of the above mentioned aspects can be implemented in methods systems computer readable media or any type of manufacture. For example a computer readable medium can store thereon computer executable instructions for transferring data between virtual machine partitions. Such media can comprise a first subset of instructions for sending by a child virtual machine partition to a parent virtual machine partition a request for allocation of memory wherein the allocation indicates a maximum buffer size for transferred data a second subset of instructions for mapping the requested memory allocation a third set of instructions for allocating the requesting memory in a shared memory aperture between modes in the child and parent virtual machine partitions and a fourth set of instructions for transferring data between the child and parent virtual machine partitions using the shared memory aperture. It will be appreciated by those skilled in the art that additional sets of instructions can be used to capture the various other aspects disclosed herein and that the four presently disclosed subsets of instructions can vary in detail per the present disclosure.

The foregoing detailed description has set forth various embodiments of the systems and or processes via examples and or operational diagrams. Insofar as such block diagrams and or examples contain one or more functions and or operations it will be understood by those within the art that each function and or operation within such block diagrams or examples can be implemented individually and or collectively by a wide range of hardware software firmware or virtually any combination thereof.

It should be understood that the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the disclosure or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the disclosure. In the case of program code execution on programmable computers the computing device generally includes a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may implement or utilize the processes described in connection with the disclosure e.g. through the use of an application programming interface API reusable controls or the like. Such programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

While the invention has been particularly shown and described with reference to a preferred embodiment thereof it will be understood by those skilled in the art that various changes in form and detail may be made without departing from the scope of the present invention as set forth in the following claims. Furthermore although elements of the invention may be described or claimed in the singular the plural is contemplated unless limitation to the singular is explicitly stated.

