---

title: Method and system for implementing efficient cursor pruning
abstract: Disclosed are improved methods, systems, and media for cursor sharing and cursor pruning. According to some approaches, existing child cursors are distinguished using a cursor sharing criteria node structure. A sharing criteria node (also referred to as a “diagnostic” node) is created when a sharing criteria mismatch/failure happens. The node contains information about why the child cursor could not be shared and also information that can be used to quickly re-evaluate this sharing criterion in the future.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08301667&OS=08301667&RS=08301667
owner: Oracle International Corporation
number: 08301667
owner_city: Redwood Shores
owner_country: US
publication_date: 20100225
---
Many operations performed in a database system are executed using database query language statements such as statements in the structured query language SQL . SQL is a non procedural language for accessing and manipulating data in a relational or object relational database. Procedural languages such as PL SQL may also be used to perform operations in a database system. For purpose of illustration this document will be explained with reference to SQL statements and relational database structures such as tables and rows. It is noted however that the inventive concepts disclosed herein are applicable to other types of languages objects structures and operations in a database.

A cursor is a handle to a query execution area corresponding to an area in memory in which a parsed SQL statement and or other information for processing the SQL statement are stored. Cursors enable a SQL statement to retrieve rows from a database table into a given result set which can then be accessed displayed or operated upon. To execute a SQL statement the cursor is first created either in conjunction with the SQL query or independently. The cursor may be automatically handled by the database system or manually controlled by a programmer through an application programming interface. The SQL statement is thereafter parsed optimized and executed to produce a set of rows called the result set. The rows in the result set are retrieved fetched either a row at a time or in groups. The cursor can be considered the database query and its result set.

A significant level of overhead and expense is normally required to create a cursor particularly due to the sheer amount of work involved to perform a hard parse of the SQL statement and to generate an execution plan for that statement. The SQL compilation process involvers a parse phase where the SQL statement is analyzed and parsed into its constituent components to create an expression parse tree. An optimizer accepts the parsed and analyzed statement from the parse phase to determine an appropriate method to best execute the particular SQL statement based upon a number of criteria including gathered statistical information optimization methodologies and or selectivity analysis. The result is a memory resident data structure that dictates an execution plan for carrying out the database statement request.

Due to this expense it is often inefficient to recreate a cursor each and every time a request is made to execute a particular SQL statement. Instead the cursor can be cached and reused to execute the same SQL statement.

As noted above it is highly desirable to allow executing queries to share cursors since there is a significant cost involved in creating new child cursors. The problem is that there is also a significant expense involved in searching existing child cursors to find the child cursor that has the exact same set of sharing criteria as the query currently being executed. In the example that is shown in assume that there are N number of existing child cursors and M number of sharing criteria that may need to be checked to find the appropriate cursor that can be re used for a current query execution.

In this case it is possible that there may need to be at least N M number of items that need to be reviewed at run time to see if there is an existing child cursor that can be re used. This results in runtime of O nm . At the end of this lengthy and expensive process it is still quite possible that none of the child cursors are usable and that a new child cursor will need to be created to handle the current query execution. This could become a very inefficient and costly process depending upon the number of child cursors and sharing criteria that have been established.

Embodiments of the present invention provide improved methods systems and media for cursor sharing and cursor pruning According to some embodiments existing child cursors are distinguished using a cursor sharing criteria node structure. A sharing criteria node also referred to as a diagnostic node is created when a sharing criteria mismatch failure happens. The node contains information about why the child cursor could not be shared and also information that can be used to quickly re evaluate this sharing criterion in the future.

Further details of aspects objects and advantages of the invention are described below in the detailed description drawings and claims. Both the foregoing general description and the following detailed description are exemplary and explanatory and are not intended to be limiting as to the scope of the invention.

As previously noted cursor sharing is very desirable to allow improvements to database performance related to compiling sharing and executing SOL and PL SQL statements. By way of background it is noted that cursor caching can be used on several levels to improve cursor re execution time by maintaining reference to cached cursors and avoiding hard parse. For example a first level of cursor caching may take place in a client side statement cache that holds a cursor number for a particular SOL statement. The cached cursor number acts as a reference to the server side cursor that was previously executed for the same SOL statement. This cursor number is session specific and points to a particular server side cursor instantiation object in a particular database session.

A second level of cursor caching could be implemented as a session cursor cache which is a pool of previously executed cursor instantiation objects. Cursor instantiation objects maintain session specific states that were used during the previous execution to facilitate re use during the same session. It could also contain a reference to the shared child cursor that was used during the last execution. A cache hit at this level would result in a soft parse in which one would go through a subset of sharing criteria checks.

A third possible level of cursor caching is the pool of child cursors in a system general shared memory area. This is a possible last level of caching to avoid hard parsing. A soft parse at this level means that the system would go through the comprehensive list of sharing criteria check to find one existing child that can be shared.

Conventional shared cursor architectures are not efficient when there is a high number of shared cursors e.g. where a parent cursor corresponds to a list of child cursors and the process to find the right child cursor involves a linear scan of this list. As a result shared cursor performance degrades exponentially as the number of child cursors increases.

Embodiments of the present invention provide improved methods systems and media for cursor sharing and cursor pruning According to some embodiments the idea is to distinguish the existing child cursors using a cursor sharing criteria node structure. A sharing criteria node or diagnostic node is created when a sharing criteria mismatch or failure occurs. The node contains information about why the child cursor could not be shared and also information that can be used to quickly re evaluate this sharing criterion in the future. Whenever there is an attempt to share this child cursor again in the future the information already stored in the sharing criteria node can be used to possibly prune this child cursor from the search list. The result is that the entire list of sharing criteria can be reviewed for at most one child cursor regardless of the number of existing child cursors.

User station comprises any type of computing station that may be used to access operate or interface with data storage device whether directly or remotely over a network. Examples of such user stations include for example workstations personal computers or remote computing terminals. User station comprises a display device such as a display monitor for displaying processing results or data to users at the user station . User station also comprises input devices for a user to provide operational control over the activities of some or all of system .

DBMS provides management for some or all of the database functionality and operations utilized in system . Using cursor sharing module DBMS allows for the efficient sharing of cursors . The general approach to implement the cursor sharing module according to some embodiments is to distinguish the existing child cursors using a cursor sharing criteria node structure. A diagnostic sharing criteria node is created when a sharing criteria mismatch failure happens and contains information about why the particular child cursor could not be shared and also information that is necessary or useful to quickly re evaluate this sharing criterion in the future. Whenever there is an attempt to share this child cursor again in the future the information already stored in the sharing criteria node is used to possibly prune this child cursor from the search list.

For instance suppose that there is already one child cursor that has been built. Later another session attempts to share this child cursor and while going through the list of sharing criteria it is found that the child cursor cannot be shared because of sharing criterion A. At this point the cursor sharing module will create two sharing criteria nodes of sharing criterion A one for child cursor number and one for child cursor number . From that point on criterion A will serve as the distinguishing criterion between child number and number .

Suppose a third session now needs a cursor. The third session will first look at the sharing criteria node created for child cursor and if it finds that it matches sharing criterion A then it will evaluate the rest of the sharing criteria for child cursor otherwise it will simply prune child cursor from its search list. Therefore the entire list of sharing criteria will be evaluated for at most one child cursor.

Note that this approach could potentially end up with a large number of sharing criteria nodes one per sharing criterion. As a further optimization the system may dynamically reorganize the nodes when the number of nodes grows above a certain threshold where the ordering of the nodes will be determined by the selectivity of the associated sharing criteria. In this optimization nodes with higher sharing criteria selectivity will be evaluated earlier during the pruning process.

The child node may already be associated with one or more diagnostic nodes which corresponds to one or more sharing criteria that have previously been identified as causing a mismatch with previous attempts to share its corresponding child cursor. If so then at that previous sharing criteria is checked against the sharing criteria for the current session. If there is a mis match between the stored sharing criteria for the child node and the sharing criteria for the current session then the child node cursor can be immediately pruned from the list at .

This highlights one of the key advantages of the approach where a child node can be checked very quickly and efficiently to see if its corresponding cursor can be re used for the current session. Instead of potentially requiring all M number of sharing criteria to be checked and stored for each child node it is likely that only a small number of sharing criteria that are already stored for the existing nodes cursors need to be checked for most of the child nodes.

If there is not a mis match with the already stored sharing criteria for the child node then at the process iterates through the other sharing criteria not already in a diagnostic node to see if the child cursor is appropriate for sharing re use. A determination is made whether there are any mis matches between the sharing criteria for the current session and the child cursor. If there is a good match for all for of the sharing criteria then the child cursor can be re used at .

On the other hand if there is an identified mismatch in the sharing criteria then at a diagnostic node for the mis matched sharing criterion is added to the child node and the child node cursor is pruned from consideration for sharing at .

A determination is made at whether there are any further existing child nodes cursors to consider for sharing. If so then the process returns back to to select another child node for processing. If not then a new child cursor is created at and its corresponding child node added to the tree of nodes for the parent cursor.

The previously identified mis matched sharing criterion is added to the newly created child node at . In this approach a sharing criteria node is made only if it helps to distinguish the existing child cursors from another existing child cursor. In other words each node helps the process to get rid of at least one potential child cursor candidate. To explain consider the degenerate case in which each node helps to get rid of exactly one potential child cursor and when going through P nodes reduces the cardinality of the candidate child cursor set to n p . The worst case running time becomes O p n p p . Note that a sharing criteria node is created only when it is needed to create one new child cursor so n p and the running time is therefore linear.

According to some embodiments each sharing criterion corresponds to a sharing criteria identifier a sharing criteria evaluation functionality a diagnostic functionality a pruning functionality and an end of compile functionality. The evaluation functionality is used to determine whether the sharing criterion matches or not. If the result is a mismatch a new sharing criteria node is created for the existing child cursor. The diagnostic functionality is performed to dump out the diagnostic information stored under the sharing criteria node. The pruning functionality is performed whenever there is an attempt to share a child cursor with at least one existing sharing criteria node attached. The pruning functionality decides whether the system can prune the child cursor from the search list. Finally the end of compile functionality is performed after a new child cursor is created because of mismatch of the specified sharing criteria. The end of compile functionality is used to create a sharing criteria node and attach it to this new child cursor to enable the effective efficient pruning.

Any suitable sharing criterion may be utilized in conjunction with the invention. Examples of sharing criteria include system settings optimizer settings user personal settings privileges and authorization levels and different mappings that may occur to system objects and tables.

According to the present embodiment all the sharing criteria nodes have a common header structure. The payload portion of the sharing criteria node itself is free format and can be specified dynamically e.g. to store ACL access control list IDs and evaluation results for ACL mis matches mismatching bind position data type and length for bind variable mis matches. Within the same sharing criteria one implementation approach can be to have different payload formats depending on a mis match reason or reason code stored in the header of the node.

Each parent cursor can be configured to keep track of the number of child cursors created due to each specific sharing criteria failure. This number of child cursors defines the selectivity of a sharing criterion and it grows as the number of child cursors increases. Initially when the number of child cursors is small the sharing criteria nodes are organized as a linked list in the child cursor. To select the appropriate child cursor for each sharing criteria node in the list the system would call the pruning function functionality that is defined. The pruning functionality would evaluate the corresponding sharing criteria and decides whether the system can prune this child cursor from the candidate search list.

At the beginning of the process the candidate child cursor search list includes all of the existing child cursors. While going through the sharing criteria nodes the system continues to reduce the size of this list by pruning the ones that do not satisfy the sharing criteria. When the number of child cursors nodes increase above a certain threshold the system will sort the linked list in descending order of selectivity so that pruning can be carried out more effectively.

As is evident from the above runtime analysis of cursor sharing is greatly enhanced in terms of speed and efficiency using the present invention. In this new approach of embodiments of the current invention a sharing criteria node is made only if it helps to distinguish the existing child cursors from another existing child cursor. In other words when the system evaluates a pair of sharing criteria node it can get rid of at least one and possibly at most two potential child cursor candidate.

If there are N child cursors there will be 2 n 1 sharing criteria node. After finishing the evaluation of all 2 n 1 sharing criteria nodes there will only be at most 1 candidate child cursor left and therefore there will only need to be an evaluation of the entire list of sharing criteria on at most 1 child cursor. Therefore the runtime becomes 0 2 n 1 p which is linear.

At a later point in time assume that User seeks to establish a session to execute the query. At this point the previous child cursor C is checked to see if it can be re used to allow User to execute the query. First a list of the child nodes is compiled which in the present case includes only one child node C. Since there have not been any previous mis matches against the child node C this child node does not yet have any previously mis matched sharing criteria associated with the child node i.e. no diagnostic nodes are yet associated with C . Therefore the system will iterate through all of the sharing criteria to see if there are any mis matches between settings for User and the sharing criteria set up for C.

In the present situation there is a mis match since C is associated with a sharing criterion for language set to English whereas User is configured to be associated with a sharing criterion for language set to Chinese. Therefore as shown in child node C is pruned from the list of candidate child cursors and as shown in a new object data in the form of a sharing criteria node is created to be associated with child node C. The sharing criteria node identifies the reason for pruning C from the list of candidate child nodes i.e. because of the existence of a mis match for the language setting since the language setting for C is English.

Therefore a new cursor C is created to execute the query for User . As shown in a new child node corresponding to child node C is added to the cursor hierarchy and a sharing criteria node is created to be associated with C. The sharing criteria node identifies the reason for creating C instead of using an existing child cursor i.e. because of the existence of a mis match for the language setting since the language setting for C is Chinese.

At a later point in time assume that User seeks to establish a session to execute the query. At this point the previous child cursors C and C are checked to see if either one can be re used to allow User to execute the query. First a list of the existing child nodes is compiled which in the present case includes a list that has both C and C.

The example process begins by checking C. Since there have been at least one previous mis match against the child node C this child node does have a previously mis matched sharing criteria associated with the child node. Therefore as shown in the system will begin by checking the sharing criteria node for C against the sharing criteria for User . Here it can be seen right away that the language sharing criteria of English recorded in the sharing criteria node does not match the sharing criteria language value of French required for User . Therefore as shown in C can be immediately pruned from the list of candidate cursors to be shared with User .

The example process next checks the suitability of sharing C with User as shown in . Since child node C is already associated with a sharing criteria node the sharing criteria value recorded in this node is checked against the sharing criteria for User . Here it can be immediately discovered that the language sharing criteria of Chinese recorded in the sharing criteria node does not match the sharing criteria language value of French required for User . Therefore as shown in C can be immediately pruned from the list of candidate cursors to be shared with User .

There are no further candidate child cursors that can be re used for the execution of the query for User . Therefore a new cursor C is created to execute the query for User and a new child node for C is added to the cursor hierarchy as shown in . A new object data in the form of a sharing criteria node is created to be associated with child node C where the sharing criteria node identifies the reason for creating new node C i.e. because of the existence of a mis match for the language setting since the language setting for C is French.

While the example of is a very simple example using only a single sharing criterion it is noted that the present invention is usable with complex implementations that involve large numbers of sharing criteria.

The security level sharing criteria addresses the security level or level of authorizations that correspond to the query execution by a given user session. In the present example the security level setting for User User and User is 2 while the security level setting for User is 1 .

The table resolution mapping criteria addresses how resources may be mapped differently depending upon the specific user or session that is executing the query. For example when User is executing the query then the table variable T resolves to a table Michael.T . When User is executing the query then the table variable T resolves to a table Scott.T . However when either User or User is executing the query then the table variable T resolves to a default table.

The optimizer setting sharing criterion corresponds to any appropriate optimizer configuration setting that may be established to compile and create an execution plan for the query. In the present example the optimizer setting for User and User is 4 the optimizer setting for User is 5 and the optimizer setting for User is 3 .

At a later point in time assume that User seeks to establish a session to execute the query. At this point the previous child cursor C is checked to see if it can be re used to allow User to execute the query. First a list of the candidate child nodes is compiled which in the present case includes a list of only one child node C. Since there has not been any previous mis matches against the child node C this child node does not yet have any previously mis matched sharing criteria associated with the child node. Therefore the system will iterate through all of the sharing criteria to see if there are any mis matches between settings for User and the sharing criteria set up for C.

In the present situation there is a mis match since C is associated with a sharing criterion for language set to Chinese whereas User is configured to be associated with a sharing criterion for language set to English. Therefore as shown in a new object data in the form of a sharing criteria node is created to be associated with child node C and the child node C will be pruned from the list of candidate cursors. The sharing criteria node identifies the reason for pruning C from the list of candidate cursors nodes i.e. because of the existence of a mis match for the language setting since the language setting for C is Chinese whereas User needs the query executed with a language setting for English.

Therefore a new cursor C is created to execute the query for User . As shown in a new child node corresponding to child node C is added to the cursor hierarchy and a sharing criteria node is created to be associated with C. The sharing criteria node identifies the reason for creating C instead of using an existing child cursor i.e. because of the existence of a mis match for the language setting since the language setting for C is English.

At a later point in time assume that User seeks to establish a session to execute the query. At this point the previous child cursors C and C are checked to see if either one can be re used to allow User to execute the query. First a list of the existing child nodes is compiled which in the present case includes a list that includes both C and C.

In this example the process begins by checking C. As shown in the system will begin by checking the sharing criteria node for C against the sharing criteria for User . Here it can be seen right away that the language sharing criterion of English recorded in the sharing criteria node does not match the sharing criterion language value of Chinese required for User . Therefore as shown in C can be immediately pruned from the list of candidate cursors to be shared with User .

The example process next checks the suitability of sharing C with User as shown in . Since child node C is already associated with a sharing criteria node the sharing criteria value recorded in this node is checked against the sharing criteria for User . Here it can be immediately discovered that the language sharing criterion of Chinese recorded in the sharing criteria node does match the sharing criterion language value of Chinese required for User . Therefore C cannot be immediately pruned from the list of candidate cursors to be shared with User .

Therefore the system will iterate through all of the sharing criteria between C and the settings for User to see if there are any mis matches for the sharing criteria. In the present situation there is a mis match since C is associated with a sharing criterion for security level set to 1 whereas User is configured to be associated with a sharing criterion for the security setting of 2 . Therefore as shown in child node C is pruned from the list of candidate child cursors and a new object data in the form of a sharing criteria node is created to be associated with child node C. The sharing criteria node identifies the reason for pruning C from the list of candidate child nodes i.e. because of the existence of a mis match for the security level setting since the setting for C is 1 whereas User needs a security level setting of 2 .

There are no further candidate child cursors that can be re used for the execution of the query for User . Therefore a new cursor C is created to execute the query for User and a new child node for C is added to the cursor hierarchy as shown in . A new object data in the form of a sharing criteria node is created to be associated with child node C where the sharing criteria node identifies the reason for creating new node C i.e. because of the existence of a mis match for the security level setting since the setting required for C is 2 .

At a later point in time assume that User seeks to establish a session to execute the query. At this point the previous child cursors C C and C are checked to see if any can be re used to allow User to execute the query. First a list of the existing child nodes is compiled which in the present case is a list that includes C C and C.

In this example the process begins by checking C. As shown in the system will begin by checking the sharing criteria node for C against the sharing criteria for User . Here it can be seen right away that the language sharing criterion of English recorded in the sharing criteria node does not match the sharing criterion language value of Chinese required for User . Therefore as shown in C can be immediately pruned from the list of candidate cursors to be shared with User .

The example process next checks the suitability of sharing C with User . Since child node C is already associated with sharing criteria nodes and the sharing criteria values recorded in nodes and are checked against the sharing criteria for User . Here as illustrated in checking the language sharing criterion of Chinese recorded in the sharing criteria node shows a match with the sharing criterion language value of Chinese required for User . However as illustrated in checking the security level sharing criterion of 1 recorded in sharing criteria node shows a mis match with the required security level setting of 2 for User . Therefore C can be pruned from the list of candidate cursors to be shared with User as illustrated in .

The example process next checks the suitability of sharing C with User as shown in . Since child node C is already associated with a sharing criteria node the sharing criteria value recorded in this node is checked against the sharing criteria for User . Here it can be immediately discovered that the security level sharing criterion of 2 recorded in the sharing criteria node does match the sharing criterion security level of 2 for User . Therefore C cannot be immediately pruned from the list of candidate cursors to be shared with User .

Therefore the system will iterate through all of the sharing criteria between C and the settings for User to see if there are any mis matches for the sharing criteria. In the present situation there is a mis match since C is associated with a sharing criterion for optimizer setting of 4 whereas User is configured to be associated with a sharing criterion for the optimizer setting of 3 . Therefore as shown in a new object data in the form of a sharing criteria node is created to be associated with child node C. As shown in child node C is pruned from the list of candidate child cursors. The sharing criteria node identifies the reason for pruning C from the list of candidate child nodes i.e. because of the existence of a mis match for the optimizer setting since the setting for C is 4 whereas User needs an optimizer setting of 3 .

There are no further candidate child cursors that can be re used for the execution of the query for User . Therefore a new cursor C is created to execute the query for User and a new child node for C is added to the cursor hierarchy as shown in . A new object data in the form of a sharing criteria node is created to be associated with child node C where the sharing criteria node identifies the reason for creating new node C i.e. because of the existence of a mis match for the optimizer setting since the setting required for C is 3 .

Therefore what has been described in an improved approach to manage cursor sharing and to effectively and efficiently prune cursors that cannot be re used.

According to one embodiment of the invention computer system performs specific operations by processor executing one or more sequences of one or more instructions contained in system memory . Such instructions may be read into system memory from another computer readable usable medium such as static storage device or disk drive . In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and or software. In one embodiment the term logic shall mean any combination of software or hardware that is used to implement all or part of the invention.

The term computer readable medium or computer usable medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media and volatile media. Non volatile media includes for example optical or magnetic disks such as disk drive . Volatile media includes dynamic memory such as system memory .

Common forms of computer readable media includes for example floppy disk flexible disk hard disk magnetic tape any other magnetic medium CD ROM any other optical medium punch cards paper tape any other physical medium with patterns of holes RAM PROM EPROM FLASH EPROM any other memory chip or cartridge or any other medium from which a computer can read.

In an embodiment of the invention execution of the sequences of instructions to practice the invention is performed by a single computer system . According to other embodiments of the invention two or more computer systems coupled by communication link e.g. LAN PTSN or wireless network may perform the sequence of instructions required to practice the invention in coordination with one another.

Computer system may transmit and receive messages data and instructions including program i.e. application code through communication link and communication interface . Received program code may be executed by processor as it is received and or stored in disk drive or other non volatile storage for later execution. Computer system may communicate through a data interface to a database on an external storage device .

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. For example the above described process flows are described with reference to a particular ordering of process actions. However the ordering of many of the described process actions may be changed without affecting the scope or operation of the invention. The specification and drawings are accordingly to be regarded in an illustrative rather than restrictive sense.

