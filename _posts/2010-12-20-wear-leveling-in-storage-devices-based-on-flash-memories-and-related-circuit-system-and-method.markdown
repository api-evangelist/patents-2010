---

title: Wear leveling in storage devices based on flash memories and related circuit, system, and method
abstract: A wear leveling solution is proposed for use in a storage device based on a flash memory. The flash memory includes a plurality of physical blocks, which are adapted to be erased individually. A corresponding method starts with the step for erasing one of the physical blocks. One of the physical blocks being allocated for storing data is selected; this operation is performed in response to the reaching of a threshold by an indication of a difference between a number of erasures of the erased physical block and a number of erasures of the selected physical block. At least the data of the selected physical block being valid is copied into the erased physical block. The selected physical block is then erased.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08099545&OS=08099545&RS=08099545
owner: STMicroelectronics Pvt. Ltd.
number: 08099545
owner_city: Greater Noida
owner_country: IN
publication_date: 20101220
---
The present application is a divisional application of U.S. patent application Ser. No. 12 075991 filed May 9 2007 which application is incorporated herein in its entirety.

This application is related to U.S. patent application Ser. Nos. 11 801 687 filed May 9 2007 entitled RESTORING STORAGE DEVICES BASED ON FLASH MEMORIES AND RELATED CIRCUIT SYSTEM AND METHOD Ser. No. 11 801 742 filed May 9 2007 entitled MANAGEMENT OF ERASE OPERATIONS IN STORAGE DEVICES BASED ON FLASH MEMORIES and Ser. No. 11 801 745 filed May 9 2007 entitled GARBAGE COLLECTION IN STORAGE DEVICES BASED ON FLASH MEMORIES which have a common filing date and owner and which are incorporated by reference.

An embodiment of the present disclosure relates to the storage device field. More specifically an embodiment of the present disclosure relates to wear leveling in storage devices based on flash memories.

Storage devices based on flash memories have become very attractive in the last years for example they are commonly used as mass memories also known as solid state mass memories in several data processing systems. These storage devices are compact robust and with low power consumption therefore they may be advantageous especially in portable systems such as mobile telephones which are typically supplied by batteries.

Typically flash memories used to implement the above mentioned storage devices can be erased only in blocks having a relatively large size for example 16 32 Kbytes . Therefore once data has been written into the flash memory this data cannot be updated unless the corresponding whole block is erased. In order to emulate operation of a random access device such as a standard hard disk a translation layer is provided on top of the flash memory. The translation layer manages any update of the data stored in the flash memory by writing a new version thereof in a different area of the flash memory and at the same time updating corresponding mapping information.

A problem with some storage devices based on flash memories is that the number of times each block can be erased is intrinsically limited for example on the order of 100 000 300 000 times. Indeed every erasing of the block physically wears its memory cells. As a result as time goes on more time is required to erase the memory cells sporadic faults may appear when they are programmed and the capability of distinguishing between different conditions e.g. storing a 0 or a 1 thereof lessens in the end the block may entirely lose the ability of being erased thereby becoming unusable or bad . This limited endurance to the erasures of the blocks reduces the lifetime of the storage devices.

In order to alleviate the above described problem wear leveling techniques have been proposed. The wear leveling techniques are aimed at distributing the number of erasures of the blocks uniformly throughout the whole flash memory. In this way all the blocks should approach the number of their allowable erasures as a result the lifetime of the memory device theoretical tends towards its maximum value.

For example an approach that has been proposed is of selecting the blocks to be used for writing data with a random algorithm statistically the blocks should then be erased with a similar frequency.

As a further improvement US A 2006 0155917 the entire disclosure of which is herein incorporated by reference discloses a solution that is based on a table storing the number of erasures of each block of the flash memory the table is used to create a list which orders the erased blocks being available to be used for writing data according to their number of erasures. In this way whenever an erased block must be used for writing data it is possible to select the one with the lowest number of erasures the selected block is likely to be erased again later on so as to increase the uniformity of the distribution of the erasures.

However the solutions known in the art may not be completely satisfactory in some applications. Indeed the available wear leveling techniques are often ineffective in obtaining an actual uniform distribution of the erasures of the blocks in the flash memory.

Therefore in many practical situations it may be that the erasures concentrate on some blocks only. As a result those blocks may become unusable in a relatively short time while other blocks are subject to a far lower number of erasures. Unfortunately this may have detrimental effect on the lifetime of the whole memory device.

In its general terms an embodiment the present disclosure is based on is the idea of extending the application of the wear leveling process to more blocks of the flash memory.

More specifically an embodiment of the disclosure proposes a wear leveling method for use in a storage device based on a flash memory. The flash memory includes a plurality of physical blocks which are adapted to be erased individually. The method starts with the step for erasing one of the physical blocks. One of the physical blocks being allocated for storing data is selected this operation is performed in response to the reaching of a threshold by an indication of a difference between a number of erasures of the erased physical block and a number of erasures of the selected physical block. At least the data of the selected physical block being valid is copied into the erased physical block. The selected physical block is then erased.

In an embodiment of the disclosure the method is applied during a garbage collection procedure wherein a physical block of the root type and one or more physical blocks of the child type are compacted into a single physical block of the root type .

In an embodiment only the valid data of the selected physical block is copied into the erased physical block.

The threshold may be set to a percentage for example 30 70 of an allowable range of an aging index representing the number of erasures of each physical block.

In a proposed implementation only a youngest allocated physical block being subject to the lowest number of erasures is taken into account for the selection of the allocated physical block to be used to replace the erased physical block.

Alternatively the selection may be performed among a set of allocated physical blocks being eligible to this purpose according to a preference criteria based on one or more characteristics thereof.

For example it is possible to select the youngest eligible allocated physical block of a child type when available .

This result may be achieved by means of a list which orders the allocated physical blocks according to the corresponding number of erasures.

Moreover another embodiment of the disclosure proposes a data processing system including one or more storage devices.

With reference now to a mobile telephone is illustrated. The telephone is formed by several units that are coupled in parallel to a communication bus . In detail a microprocessor P controls operation of the telephone a RAM is directly used as a working memory by the microprocessor . Several peripheral units are further coupled to the bus through respective drives . Particularly a storage device implements a solid state mass memory the storage device is used to store data that should be preserved even when a power supply of the telephone is off for example firmware for the microprocessor application programs and personal information of a user of the telephone such as an address book . Moreover the telephone includes input units for example a keypad a microphone and a camera and output units for example a display and a loudspeaker . A transceiver RX TX implements any communications with a telephone exchange not shown in the figure to send and receive information.

Passing now to the storage device is based on a flash memory . The flash memory includes a matrix of memory cells with NAND architecture not shown in the figure . The flash memory programs and reads the memory cells at the level of physical pages for example each one consisting of 528 bytes . On the other hand the memory cells are erased at the level of far larger physical blocks for example each one including 32 physical pages . Therefore once a physical page has been programmed so as to write the desired data into it this physical page cannot be updated any longer unless the whole respective physical block is erased or the update involves only the further programming of its memory cells .

A control unit manages the flash memory so as to emulate a random access to the storage device . The control unit is based on a micro controller . The micro controller accesses a RAM being used as a working memory and a series of registers . An interface couples the micro controller with the flash memory another interface instead couples the same micro controller with the driver not shown in the figure of the telephone for the storage device .

Operation of the micro controlled is managed by firmware which is stored in the flash memory and then loaded at least partially into the RAM when the micro controller is running the firmware is initially installed onto the flash memory during a manufacturing process of the storage device.

A functional scheme of the same storage device is illustrated in . The flash memory provides a physical memory space . The physical memory space includes its physical blocks which can be erased individually each physical block is identified by a corresponding physical block number for example of 12 bits for accessing up to 4096 physical blocks . In turn each physical block includes its physical pages which can be programmed only once for each memory cell and read individually each physical page is identified by a corresponding physical offset within the physical block of 4 bits in the example at issue wherein each physical block includes 32 physical pages .

The storage device emulates a logical memory space . The logical memory space includes logical sectors for example each one of 512 bytes which can be written repeatedly to any value and read individually. The logical sectors are grouped into logical blocks for example each one including 32 logical sectors . Each logical block is identified by a corresponding logical block number for example again of 12 bits for accessing up to 4096 logical blocks each logical sector is identified by a corresponding logical offset within the logical block of 4 bits in the example at issue . The different versions of the logical sectors are written into corresponding physical sectors each physical sector typically including a single physical page . The physical sector includes a main area for storing the value of the logical sector and a spare area for storing service information i.e. 512 bytes and 16 bytes respectively in the example at issue .

One of the physical blocks is dedicated to store an Aging Block Table ABT for example the aging block table is stored in the last physical block of the physical memory space that is available i.e. being not bad . For each physical block the aging block table stores an aging index indicating the number of erasures of the physical block the aging indexes of all the physical blocks are stored in succession in the main areas of multiple physical sectors with the aging index of each physical block being stored in the position corresponding to its physical block number . For example each aging index is represented with two bytes therefore in the example at issue wherein the physical memory space includes 4096 physical blocks and each physical sector has a main area of 512 bytes the aging block table is stored in 4096 2 512 16 physical sectors of the corresponding physical block. Each physical sector used to store the aging block table is identifying by means of a corresponding aging flag which is written in its spare area typically the aging flag consists of a specific bit that is asserted for the physical sectors storing the aging block table while it is deasserted for the other physical sectors . In this way the aging flag of the first physical sector of the different physical blocks may also be used to identify the one storing the aging block table when it is asserted . Typically all the aging indexes are set to 1 every time the flash memory is formatted with all its physical blocks that are erased . Whenever the aging block table must be updated its new version is written into the next 16 physical sectors of the same physical block if available when this physical block is full it is erased and the aging block table is then written into its first 16 physical sectors.

A Flash Translation Layer FTL maps the logical memory space onto the physical memory space . Particularly each logical block is associated with one or more physical blocks organized into a tree structure in a specific implementation the logical block is associated with a physical block that defines a root node and possibly with another physical block that defines a leaf node depending on the root node . The logical sectors of the logical block are written in succession into consecutive physical sectors of the associated physical block s the writing of the logical sectors starts from the root physical block and then continues to the leaf physical block once the root physical block is full. Since the physical sectors can be programmed only once any time a logical sector must be updated its new version is written into another physical sector. When a logical sector is written into a physical sector its value is stored in the main area of the physical sector the spare area instead stores an indication of the corresponding logical sector for example its logical offset . The spare area of the first physical sector of each physical block is also used to store an indication of the corresponding logical block for example its logical block number and an indication of the position of the physical block in the tree structure i.e. root node or leaf node .

The translation layer manages a Logical to Physical L2P mapping table . The mapping table associates each logical block with its root physical block and leaf physical block if any in turn the mapping table associates each written logical sector with the physical sector in the root physical block or in the leaf physical block wherein its last version is stored. The mapping table is created at least partially during an initialization of the storage device at its power on by reading the relevant information stored in the spare areas of the different physical sectors the mapping table is then maintained up to date according to the operations performed on the storage device.

The translation layer also manages a free list . The free list indicates the physical blocks that are erased and then available to write data by means of their physical block numbers together with the corresponding aging indexes the erased physical blocks are arranged in the free list in increasing order of their aging indexes starting from a youngest erased physical block with the lowest aging index i.e. being subject to the lowest number of erasures . As above the free list is created during the initialization of the storage device at its power on by reading the aging block table . The free list is then maintained up to date according to the operations performed on the storage device.

The maximum allowable value of each aging index depends on the number of bits being used for storing it in the example at issue the aging index can span a range from 0 to 2 1 65 535. In order to avoid any overflow once a generic aging index reaches its maximum allowable value i.e. 65 535 all the aging indexes are divided by two.

The information stored in the free list i.e. the updated aging indexes of the erased physical blocks is merged with the content of the aging block table storing the previous aging indexes of all the physical blocks for example after a predefined number of erasures the new version of the aging block table so obtained is then written back to the corresponding physical block by previously erasing it when necessary .

The translation layer exploits the free list to implement a wear leveling algorithm. For this purpose whenever an erased physical block must be used for writing data the translation layer selects the first erased physical block in the free list i.e. the youngest erased physical block with the lowest aging index the erased physical block so selected is then removed from the free list with the next erased physical block having the aging index just higher than becomes the new first erased physical block in the free list .

The structure of the aging block table and of the free list together with the corresponding wear leveling algorithm are described in greater detail in the above mentioned document US A 2006 0155917.

The solution according to an embodiment of the present disclosure is based on the observation that the number of erasures of the physical blocks strongly depends on an access pattern to the data stored therein. Indeed the data stored in some physical blocks may be highly dynamic i.e. it changes continually . Therefore the physical blocks storing dynamic data are erased very shortly after they have been written so as to become part of the wear leveling algorithm. Conversely data stored in different physical blocks may be substantially static i.e. it changes very seldom once it has been written . In this case the physical blocks storing static data may be not erased for a long time therefore these physical blocks are not taken into account by the wear leveling algorithm until they are erased .

In the solution proposed in an embodiment of the present disclosure as described in detail in the following whenever a physical block is erased a search is performed for any younger written physical block with a far lower number of erasures particularly one of the written physical blocks is selected when the difference between the number of erasures of the erased physical block and the number of erasures of the selected physical block i.e. the difference between their aging indexes reaches a predefined threshold value. In this case the data stored in the selected physical block or at least the valid one is copied into the erased physical block. The selected physical block is then erased.

As a result the selected physical block replaces the erased physical block. Therefore the selected physical block becomes part of the wear leveling algorithm being inserted into the free list after its erasing . Generally the selected physical block is placed at the beginning of the free list being its number of erasures very low so that it should be used to write data shortly and then probably erased again .

The proposed technique makes it possible to erase even the physical blocks that store static data. In this way all the physical blocks are taken into account by the wear leveling algorithm. Therefore the obtained distribution of the number of erasures of the physical blocks is far less dependent on the access pattern to the data stored in the physical blocks.

This may strongly increase the uniformity of the distribution of the erasures of the physical blocks in the flash memory.

It is then possible to reduce any concentration of the erasures on some physical blocks only like the physical blocks storing data that is highly dynamic .

In this way the number of erasures of all the physical blocks may tend to approach their maximum allowable value.

In a suggested implementation of the solution according to an embodiment of the present disclosure the threshold value is set according to the range of the aging index. For example the threshold value is equal to 30 70 40 60 or 50 the range of the aging index. Therefore in the example at issue wherein the range of the aging index is 0 65 535 the threshold value may be set to 32 768. The proposed threshold value is anticipated to provide very good results in terms of uniformity of the distribution of the erasures with an acceptable overhead of the storage device for the operations required to replace the erased physical block with the selected physical block .

For this purpose the translation layer may exploit an allocation list . The allocation list indicates the physical blocks that are written by means of their physical block numbers together with the corresponding aging indexes the written physical blocks are arranged in the allocation list in increasing order of their aging indexes starting from a youngest written physical block with the lowest aging index i.e. being subject to the lowest number of erasures . As above the allocation list is created during the initialization of the storage device at its power on by reading the aging block table . The allocation list is then maintained up to date according to the operations performed on the storage device.

The translation layer also interfaces with a service that implements a garbage collection procedure. When the garbage collection service is invoked for a specific logical block for example because both the root physical block and the leaf physical block associated with the logical block are full so that no further writing can be performed on its logical sectors the root and leaf physical blocks are compacted into a new root physical block.

The translation layer controls the physical memory space through a hardware adaptation layer . The adaptation layer exports a command interface for reading programming the physical pages and for erasing the physical blocks of the flash memory. The adaptation layer implements different functions that are required to access the flash memory such as a low level driver of the flash memory an ECC manager a bad blocks manager and the like .

An exemplary application of the solution according to an embodiment of the present disclosure during the above mentioned garbage collection procedure will be now described with reference to .

Particularly as shown in let us consider a generic logical block that is stored in a root physical block denoted with PBr and a leaf physical block denoted with PBl . The different versions of the corresponding logical sectors denoted with LSi i 0 . . . 31 have been written in succession into consecutive physical sectors of the root physical block PBr and then of the leaf physical block PBl after its completion . The last version of each logical sector LSi is shown in the corresponding physical sector PBr PBl with a white background the proceeding versions thereof not valid any longer are instead shown with a gray background. For example the logical sector LS has been written at the beginning into the 1physical sector of the root physical block PBr starting from the upper left corner and then moving from left to right along each row down to the lower right corner next versions of the same logical sector LSI have been written into the 16and the 27physical sectors of the root physical block PBr and then into the 1 the 3 the 6 the 11 and the 19physical sectors of the leaf physical block PBl. The last version of the logical sector LSI has been written into the 22physical sector of the leaf physical block PBl.

When the logical block is compacted the first erased physical block i.e. the youngest one with the lowest aging index is extracted from the free list for use as its new root physical block differentiated with a prime notation i.e. PBr the new root physical block PBr is then removed from the free list . The last versions of the logical sectors LSi are now copied from the old root physical block PBr and leaf physical block PBl into the new root physical block PBr . For this purpose the old physical blocks PBr PBl are scanned backward from the end of the old leaf physical block PBl to the beginning of the old root physical block PBr . Each encountered logical sector LSi is copied into the first available physical sector of the new root physical block PBr when it is not present yet in PBr being the latest version thereof while it is discarded otherwise being a previous version thereof . At the end the last versions of all the logical sectors LSi stored in the old physical blocks PBr PBl will be written in the new root physical block PBr at most filling it . In this phase the spare area of each physical sector of the new root physical block PBr being programmed is set accordingly. Particularly the spare area of the first physical sector of the new root physical block PBr will store the indication that it is the root node for the corresponding logical block. At the same time the mapping table is updated accordingly so as to associate the logical block with the new root physical block PBr and each written logical sector LSi thereof with the corresponding physical sector of the new root physical block PBr . The new root physical block PBr is then inserted into the allocation list in the correct position according to its aging index.

Moving to the old physical blocks PBr PBl are erased the old physical blocks PBr PBl are then removed from the allocation list . The wear leveling algorithm is then applied to the erased old child physical block PBl. For this purpose as described in detail in the following the aging index of the erased physical block PBl obtained by incrementing its previous value is compared with the aging indexes of the written physical blocks. When no far younger written physical block is found with the difference between the aging index of the erased physical block PBl and the aging index of each written physical block not reaching the threshold value the erased physical block PBl is inserted as usual into the free list not shown in the figure in the correct position according to its aging index. Conversely when a far younger written physical block denoted with PBw is found the last versions of the logical sectors stored in the written physical block PBw again denoted with LSi are copied into the erased physical block PBl. In the example illustrated in the figure this involves copying the physical sectors LS LS LS LS SL SL LS and LS from the 20 18 16 15 14 13 10and 4physical sectors respectively of the written physical block PBw into the first eight physical sectors of the physical block PBl being not erased any longer . In this phase the spare area of each physical sector of the physical block PBl being programmed is set accordingly. Moreover the information relating to the physical block PBl stored in the spare area of its first physical sector is copied from the corresponding information of the written physical block PBw particularly the physical block PBl is identified as a root node or a leaf node like the written physical block PBw for the same logical block. At the same time the mapping table is updated accordingly so as to associate the logical block with the physical block PBl and each written logical sector LSi thereof with the corresponding physical sector of the physical block PBl . The physical block PBl is then inserted into the allocation list in the correct position according to its aging index.

Passing to the written physical blocks PBw is erased the physical block PBw now erased is removed from the allocation list not shown in the figure . The physical block PBw is then inserted into the free list the physical block PBw is arranged in the correct position according to the aging index which is obtained by incrementing its previous value. The wear leveling algorithm is then applied to the erased old root physical block PBr this involves repeating the same operations described above which explanation is omitted for the sake of brevity .

The use of the allocation list for selecting the written physical block to be used to replace the erased physical block according to different embodiments of the present disclosure will be now described with reference to .

Particularly shows the allocation list wherein the written physical blocks are ordered starting from the youngest written physical block at the top and moving down to the other written physical blocks with increasing aging indexes in the figure the written physical blocks are denoted with the reference PB being followed by an index indicating their position in the allocation list starting from 1 for the youngest written physical block PB .

In a proposed embodiment of the disclosure the aging index of the erased physical block is only compared with the aging index of the youngest written physical block PB at the beginning of the allocation list . When the difference between the aging index of the erased physical block and the aging index of the youngest written physical block PB is higher than the threshold value the youngest written physical block PB is selected for replacing the erased physical block as indicated by a corresponding arrow in the figure . Conversely no written physical block will be selected since all the aging indexes of the other written physical blocks are higher so that the same difference will be lower . In this case the allocation list may be replaced with a simple register which only indicates the youngest written physical block together with its aging index since the information about the other written physical blocks is never used .

This solution is simple and fast moreover it may be implemented with a very low waste of working memory space when the above mentioned register is used .

Moving to in a different embodiment of the disclosure the selection of the written physical block to be used to replace the erased physical block is performed among all the written physical blocks that are eligible for this purpose i.e. with the difference between the aging index of the erased physical block and the aging index of each eligible written physical block that is higher than the threshold value . In the example at issue the eligible written physical blocks are the first three physical blocks PB PB and PB of the allocation list as indicated by a dashed line .

In this case the first eligible physical block PB PB along the allocation list that is selected is of the leaf type this result may be achieved by scanning the allocation list until a leaf eligible physical block is found. For example as shown in the figure the eligible physical block PB is of the root type and the eligible physical blocks PB PB are of the leaf type therefore the leaf eligible physical block PB is selected even if its aging index is slightly higher that the one of the root eligible physical block PB.

Anyway as shown in when all the eligible physical blocks again including the physical blocks P P are of the root type the youngest physical block PB is selected as above. This happens when the scanning of the allocation list reaches a physical block that is not eligible i.e. the physical block PB without finding any eligible physical block of the leaf type in this case the wear leveling algorithm returns to the beginning of the allocation list .

This solution allows selecting a written physical block that generally includes a lower number of last versions of the corresponding logical sectors. As a result the number of logical sectors to be copied from the selected physical block to the erased physical block may be reduced at least statistically this may have a beneficial effect on the performance of the wear leveling algorithm since the time spent for selecting the written physical block among the eligible ones is negligible .

With reference now to the logic flow of an exemplary procedure that can be implemented to initialize the above described storage device at its power on is represented with a method .

The method begins at the black start circle and then passes to block . In this phase the aging block table is searched by scanning the physical blocks of the flash memory backwards starting from the last one as soon as the physical block storing the aging block table is found as indicated by the aging flag of its first physical sector being asserted the last version thereof is loaded.

A loop is then performed for each other physical block of the flash memory. The loop starts at block wherein the service information of a current physical block starting from the first one is retrieved from the spare area of its first physical sector .

The method then branches at block according to the condition of the current physical block. Particularly if the physical block is erased the blocks are executed if the physical block is written the blocks are executed and if the physical block is bad the block is executed in any case the method then passes to block .

Considering now block this branch is followed when the physical block is identified as erased for example when a corresponding flag in the spare area of its first physical sector is asserted in this case the aging index of the erased physical block is extracted from the aging block table by accessing the location corresponding to its physical block number. A new entry for the free list is then created at block by adding the relevant information of the erased physical block i.e. its physical block number and aging index . Continuing to block this entry is inserted in the correct position into the free list according to the aging index of the erased physical block. The flow of activity then descends into block .

With reference instead to block this branch is followed when the physical block is identified as written for example when a corresponding flag in the spare area of its first physical sector is asserted as above the aging index of the written physical block is extracted from the aging block table by accessing the location corresponding to its physical block number. A new entry for the allocation list is then created at block by adding the relevant information of the written physical block i.e. its physical block number and aging index . Continuing to block this entry is inserted in the correct position into the allocation list according to the aging index of the written physical block. The flow of activity then descends into block .

At the end the block is entered when the physical block is identified as bad for example when present in a corresponding list in this case the bad physical block is discarded. As above the flow of activity then descends into block .

Considering now block a test is made to verify whether all the physical blocks of the flash memory have been processed. If not the method returns to block to repeat the same operations for a next physical block. Conversely the process ends at the concentric white black stop circles .

Moving now to the logic flow of an exemplary wear leveling algorithm that can be implemented in the same storage device is represented with a method .

The method begins at the black start circle and then passes to block . As soon as a garbage collection procedure is invoked the block is entered in this phase the youngest erased physical block is extracted from the beginning of the free list for use as a new root physical block for the logical block to be compacted the new root physical block is then removed from the free list saving its aging index into a corresponding register . Proceeding to block the last versions of the logical sectors of the logical block are copied from the corresponding old root physical block and old leaf physical block into the new root physical block. The new root physical block is then inserted into the allocation list at block in the correct position according to its aging index . At this point the old root and leaf physical blocks are erased at block at the same time the old physical blocks are removed from the allocation list saving their aging indexes into corresponding registers .

A loop is then performed for each erased physical block starting from the old leaf physical block . The loop begins at the synchronization bar wherein the method forks into two branches that are executed alternatively according to different implementations of the proposed solution . Particularly an implementation involves the execution of the branch formed by the blocks whereas another implementation involves the execution of the branch formed by the blocks the two branches joint at the further synchronization bar .

With reference now to block this branch is followed when only the youngest written physical block is taken into account by the wear leveling algorithm in this phase the aging index of the youngest written physical block is extracted from the beginning of the allocation list or from the corresponding register. The aging index of the erased physical block is compared with the aging index of the youngest written physical block at block . If their difference is higher than the threshold value the youngest written physical block is selected for replacing the erased physical block at block the method then passes to the synchronization bar . Conversely the method descends into the synchronization bar directly.

Considering instead block this branch is followed when all the eligible written physical block are taken into account by the wear leveling algorithm in this phase the aging index of a current written physical block starting from the youngest one is extracted from the allocation list. The aging index of the erased physical block is compared with the aging index of the current written physical block at block . If their difference is higher than the threshold value the method verifies at block the type of the current written physical block i.e. root node or leaf node . If the written physical block is of the root type the method at block passes to the next written physical block of the allocation list the flow of activity then returns to block to repeat the same operations described above. On the contrary when the written physical block is of the leaf type this written physical block is selected for replacing the erased physical block at block the method then descends to the synchronization bar . Referring back to block if the difference between the aging index of the erased physical block and the aging index of the written physical block does not reach the threshold value a test is made at block to verify whether the current physical block is the first written physical block of the allocation list i.e. the youngest one . If not the youngest written physical block of the root type is selected at block for replacing the erased physical block the method then descends to the synchronization bar . Conversely the synchronization bar is reached directly from block .

In any case the flow of activity then continues from the synchronization bar to the block . In this phase the method verifies whether a written physical block has been selected for replacing the erased physical block. If so at block the last versions of the logical sectors stored in the selected logical block are copied into the erased physical block being not erased any longer . This physical block is then inserted into the allocation list in the correct position according to its aging index at block . Descending to block the selected physical block is erased at the same time the selected physical block now erased is removed from the allocation list saving its aging index into a corresponding register . The selected physical block is then inserted into the free list at block in the correct position according to its aging index being obtained by incrementing the corresponding value previously saved . The method then descends into block . Referring back to block when no written physical block has been selected for replacing the erased physical block the erased physical block is inserted into the free list at block in the correct position according to its aging index the method then descends into block .

Considering now block a test is now made to verify which erased physical block has been processed. If the above described operations have been performed for the erased old leaf physical block the method returns to block to repeat the same procedure for the erased old root physical block. Conversely once both the erased old leaf and old root physical blocks have been processed the method ends at the concentric white black stop circles .

Naturally in order to satisfy local and specific requirements a person skilled in the art may apply to the solution described above many logical and or physical modifications and alterations. More specifically although the present disclosure has been described with a certain degree of particularity with reference to preferred embodiment s thereof it should be understood that various omissions substitutions and changes in the form and details as well as other embodiments are possible. Particularly the proposed solution may even be practiced without the specific details such as the numerical examples set forth in the preceding description to provide a more thorough understanding thereof conversely well known features may have been omitted or simplified in order not to obscure the description with unnecessary particulars. Moreover it is expressly intended that specific elements and or method steps described in connection with any disclosed embodiment of the disclosure may be incorporated in any other embodiment as a matter of general design choice.

Particularly the proposed solution lends itself to be implemented with equivalent methods by using similar steps removing some steps being non essential or adding further optional steps moreover the steps may be performed in a different order concurrently or in an interleaved way at least in part .

Similar considerations apply if the storage device emulates an equivalent logical memory space with a different number and or size of the logical blocks each one including logical sectors with a different number and or size likewise the physical memory space of the flash memory may have a different number and or size of the physical blocks each one including physical pages with a different number and or size.

It should be noted that the selected physical block may be either erased immediately or simply added to an invalid list for its next erasure as described in the co pending patent application entitled MANAGEMENT OF ERASE OPERATIONS IN STORAGE DEVICES BASED ON FLASH MEMORIES application Ser. No. 11 801 742 the entire disclosure of which is herein incorporated by reference .

Even though in the preceding description reference has been made to a specific wear leveling algorithm it should be readily apparent that the proposed solution may be implemented in combination with any other technique attempting to distribute the number of erasures of the blocks uniformly throughout the flash memory of the storage device even if the stand alone application of the proposed solution is not excluded .

Alternatively it is possible to implement the mapping of the logical memory space on the physical memory space with different techniques for example by associating a tree structure with a root node and multiple child nodes with each logical sector by storing the required information in any other way and the like moreover it is possible to implement a different mapping structure and a dynamic bad block management with the corresponding forced garbage collection procedures as described in the co pending patent application GARBAGE COLLECTION IN STORAGE DEVICES BASED ON FLASH MEMORIES U.S patent application ser. No. 13 196 820 the entire disclosure of which is herein incorporated by reference . Likewise the garbage collection procedure may be controlled in a different way for example according to specific algorithms based on the current filling rate of the flash memory alternatively the wear leveling algorithm may be applied only to one out of the erased old root physical block and old leaf physical block for example only to the older one with the higher number of erasures . More generally the proposed solution lends itself to be used whenever any physical block is erased for example during a recovering of the storage device following a power loss as described in the co pending patent application entitled RESTORING STORAGE DEVICES BASED ON FLASH MEMORIES AND RELATED CIRCUIT SYSTEM AND METHOD U.S. patent application Ser. No. 11 801 687 the entire disclosure of which is herein incorporated by reference .

The proposed wear leveling algorithm may also be implemented with a different procedure for copying the relevant data for example nothing prevents copying every physical sector storing either a valid or an invalid logical sector or even the whole content of the selected written physical block to the erased physical block.

The proposed aging index is merely illustrative for example it is possible to use a different number of bits for its storing so as to change the corresponding allowable range accordingly more generally the proposed solution may be based on any equivalent information indicative of the number of erasures of the physical blocks for example directly stored in each physical block . In any case the threshold value may be set in a different way for example the possibility of using a dynamic threshold value is not excluded such as equal to a percentage of the aging index of an oldest physical block with the highest number of erasures .

It should be readily apparent that the above described techniques for selecting the written physical block to be used for replacing the erased physical block are not exhaustive. For example it is possible to implement more sophisticated algorithms such as disabling the replacement until a minimum number of erasures is reached .

Moreover other criteria may be used for selecting the written physical block among the eligible ones. For example nothing prevents analyzing all the eligible written physical blocks and then choosing the one that meets a desired preference criterion based on or more characteristics of the written physical blocks such as with the lowest number of valid logical sectors . In this way it would be possible to actually optimize the copy of the selected written physical block onto the erased physical block at the cost of an increased computational complexity .

Similar considerations apply if the allocation list is replaced with an equivalent structure adapted to order the written physical blocks according to their aging indexes for example this result may be achieved by means of a chain implemented with pointers an ordered table and the like.

Even though in the preceding description reference has been made to a flash memory with NAND architecture this is not to be interpreted in a limitative manner more generally the proposed solution lends itself to be used in a storage device based on any other flash memory for example of the NOR type of the phase change type and the like .

Similar considerations apply if the program which may be used to implement each embodiment of the disclosure is structured in a different way or if additional modules or functions are provided likewise the memory structures may be of other types or may be replaced with equivalent entities not necessarily consisting of physical storage media . In any case the program may take any form suitable to be used by or in connection with any control system of the storage device such as software firmware or microcode. Moreover it is possible to provide the program on any medium being adapted to be used by the control system the medium can be any element suitable to contain store communicate propagate or transfer the program. For example the medium may be of the electronic magnetic optical electromagnetic infrared or semiconductor type examples of such medium are the flash memory itself or a ROM where the program can be pre loaded wires wireless connections broadcast waves and the like. In any case the solution according to an embodiment of the present disclosure lends itself to be implemented with a hardware structure for example integrated in a chip of semiconductor material or with a combination of software and hardware.

Alternatively the control system being used to implement the wear leveling algorithm may have a different structure or it may include equivalent components.

Likewise the above described architecture of the storage device is merely illustrative and it must not be interpreted in a limitative manner.

It should be readily apparent that the proposed structure might be part of the design of an integrated circuit. The design may also be created in a programming language moreover if the designer does not fabricate chips or masks the design may be transmitted by physical means to others. In any case the resulting integrated circuit may be distributed by its manufacturer in raw wafer form as a bare die or in packages. Moreover the proposed structure may be integrated with other circuits in the same chip or it may be mounted in intermediate products such as mother boards .

In any case it should be noted that the storage device may be used in any other data processing system further examples of such system are an MP3 player a digital camera a PDA a laptop computer and the like.

From the foregoing it will be appreciated that although specific embodiments of the disclosure have been described herein for purposes of illustration various modifications may be made without deviating from the spirit and scope of the invention.

