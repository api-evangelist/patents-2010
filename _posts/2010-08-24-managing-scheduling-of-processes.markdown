---

title: Managing scheduling of processes
abstract: A mechanism dynamically modifies the base-priority of a spawned set of processes according to their actual resource utilization (CPU or I/O wait time) and to a priority class assigned to them during their startup. In this way it is possible to maximize the CPU and I/O resource usage without at the same time degrading the interactive experience of the users currently logged on the system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09009717&OS=09009717&RS=09009717
owner: International Business Machines Corporation
number: 09009717
owner_city: Armonk
owner_country: US
publication_date: 20100824
---
The present invention generally relates to scheduling of processes in a computer. More particularly the invention aims at dynamically monitoring and adapting the priority of a tree of processes.

Process scheduling in operating systems dispatches processes for execution on the available CPUs of the computer. The scheduling algorithm must take into account the different types of processes which may have different CPU and I O consumption. Also the scheduler of the operating system has to optimize global CPU usage and to respect a same CPU time for each thread.

Nowadays there are plenty of process scheduling algorithms adopted by the modern operating systems to assign priorities to processes. The main purpose of such process scheduling algorithms is to minimize resource starvation and to ensure fairness amongst the parties utilizing the resources. To achieve this goal the operating system schedulers dynamically modify the actual priority of the process in their internal scheduling queue for example by assigning a temporary priority burst to a process in specific situations i.e. at the end of an I O operation . Some operating systems such as the IBM AIX operating system AIX is a trademark of International Business Machine Corp. registered in many jurisdictions worldwide allow even to globally modify the adopted scheduling algorithm.

Additionally operating systems usually provide commands and application programming interfaces APIs that can be used to modify and tune the priority of a specified set of processes. For this purpose a set of system services are available in various operating systems nice renice for the Linux operating system LINUX is a registered trademark of Linus Torvalds in the United States other countries or both set priority in the Java programming language JAVA and all Java based trademarks and logos are trademarks of Sun Microsystems Inc. in the United States other countries or both and SetPriorityClass SetThreadPriority are examples of process functions for Windows operating system Microsoft Windows Windows NT and the Windows logo are trademarks of Microsoft Corporation in the United States other countries or both a thread being a basic unit to which the operating system allocates processor time a process being an executing application that consists of one or more threads.

Even if the scheduling algorithms generally do a good job in dispatching and assigning the right priorities to the executing processes there are situations when the embedded scheduling policies are not enough to manage in an effective way how a specific set of processes have to be executed. Typical examples of such processes are long running system management processes such as the execution of an Inventory scan on a machine. These kinds of operations are usually long running tasks comprising different phases with different characteristics from a CPU I O consumption point of view. They include very CPU intensive phases followed by I O bound operations followed again by a CPU bound phase and so on. Additionally such tasks usually spawn child processes to perform some of the steps of the primary task.

Since each process started on an operating system has a fixed base priority defined by the command used to spawn it usually a long running process with time varying characteristics from a CPU usage and I O usage point of view may not be properly managed by the operating system scheduler during its whole life.

Starting such a long running process with a lower base priority would be good during the CPU intensive phases so that other system activities and in particular interactive applications would not be disturbed too much. On the other hand having a lower priority may degrade a lot the execution time during I O intensive phases resulting in an overall long execution time. Vice versa using a higher priority would be beneficial during the I O intensive phases but would degrade a lot the responsiveness of the system for interactive applications during the CPU intensive phases.

One solution to manage process priorities is implemented in the z OS Worload Manager product described in the IBM z OS is a trademark of International Business Machine Corp. registered in many jurisdictions worldwide redbook SG24 6472 03 at http www.redbooks.ibm.com abstracts sg246472.html Open

In z OS Workload Manager a contract is made Service Level Agreement STA between the installation user and the operating system. The installation classifies the work running on the z OS operating system in distinct service classes and defines goals for them that express the expectation of how the work should perform. These goal definitions are used along with the different workload priorities to manage the work across all systems of a sysplex environment. This ensures that defined SLAs get respected and that eventually competing workload gets moved to different regions. This control on priority of process execution does not answer the need for adapting priority of a running process as it changes its behavior during the execution in the context of a single machine i.e. a desktop computer .

one illustrative embodiment a method is provided to manage processes running on a computer system each running process being distributed computing resources and assigned a current process priority. The method comprises selecting a set of processes among said computer processes and assigning them a process priority class determined from the type of consumption that said selected processes make of the computing resources. The method further comprises initializing monitoring of the selected processes to which a process priority class has been assigned. The method further comprises for each monitored process collecting on a first regular time basis computing resources used by said monitored process computing on a second regular time basis on a past period of time an average value of the collected computing resources and determining a process priority for said monitored process by applying a rule adapted to the process priority class assigned to said monitored process and changing the current priority of said monitored process into the determined process priority.

In another illustrative embodiment a system for managing processes running on a computer is provided. The computer comprises an operating system monitored using an interface the operating system being adapted to distribute computing resources to each running process and to assign them a current process priority which can be changed using a process management interface with the operating system. The system further comprises a management engine for selecting a set of processes among said running processes and assigning them an initial process priority class adapted to the type of consumption that each selected process makes of the computing resources. The system further comprises a monitoring agent for monitoring said selected processes to which a process priority class has been assigned. The monitoring agent is further provided to collect on a first regular time basis computing resources used by each running process to be monitored and to transmit to the Management Engine said collected computing resources of each monitored processes. The management engine is further configured to compute for each monitored process on a second regular time basis on a past period of time an average value of the collected computing resources determine a process priority for each monitored process by applying a rule adapted to the process priority class and change the current priority of the monitored process into the determined process priority.

A Monitoring Agent continuously monitors the CPU usage and I O activity of a list of processes for which the priority is managed by a Management Engine during their execution. It is noted that a corresponding list of processes monitored by the Monitoring Agent is maintained by the Monitoring Agent. These two lists should be synchronized. One other embodiment is when the lists are merged into a unique list shared both by the Management Engine and the Monitoring Agent in the case for example where the Management Engine and the Monitoring Agent are located on the same computer .

The Monitoring Agent collects the CPU usage and I O activity and sends such metrics to the Management Engine . The Management Engine receives metrics from the Monitoring Agent and may adjust the priority of the monitored processes according to a set of pre configured policies . The adjusted priority is computed by the Management Engine using historical data of the metrics stored in a repository .

The box in dotted line encompasses the set of processes managed by the Monitoring Engine. Other processes run on the same operating system that are not included in the figure. The components of the system of the illustrative embodiment described in may act on a subset of all the processes running in the computer .

The Monitoring Agent must be located on the same machine as the computer executing the processes. The application programming interfaces APIs for monitoring a process must be called on the same operating system where the processes are running since they require access to the operating system OS kernel to extract the related metrics. So at least a minimum amount of code must run on the local machine to extract such information. The Monitoring Engine can be located on the same machine but could also be located on a different machine and could remotely communicate with the Monitoring Agent and could remotely change the processes priorities.

It is noted that the set or processes monitored by the Monitoring Agent at a given time may have spawn processes. In Child Processes are spawn processes. Other processes may run which are not monitored by the system of the invention but under the unique scheduling of the operating system. The system of the invention applies to a subset of all the running processes.

Generally with the operating system scheduling a spawn process inherits the same priority of its parent process. However when a parent process spawns a Child Process an operating system may seta different priority to the Child Process. As explained later in reference to with the illustrative embodiment the operating system assigns a default priority to each spawned process unless an optional configurable flag is specified by the user that tells if the Monitoring Engine has also to control the priority of the spawned process over time.

The protocol between the Monitoring Agent and the operating system for collecting metrics is dependent on the operating system itself. In general each operating system has its own way to provide metrics about running processes. For example with Windows operating system such data can be accessed through a set of public APIs and counters. On UNIX systems similar mechanisms are available.

The protocol between the Management Engine and the operating system is usually represented by a set of public APIs or also command line tools that the operating system exposes to the users. Through such APIs tools the Management engine is able to stop stall processes and to change their priorities. As already mentioned a few examples of such APIs tools are nice renice for Linux operating system set priority Java programming language and SetPriorityClass SetThreadPriority which are process functions for Windows operating system.

The Management Engine assigns a Process Priority Class to a process according to configuration parameters entered by the administrator. The configuration parameters associate a process id to a Process Priority Class. In the illustrative embodiment the Management Engine controls the executing processes by initially assigning a Process Priority Class to processes for which the execution has been started independently. In one other embodiment the same Management Engine is also in charge of starting the processes to be controlled and assigns the Process Priority Class to them. As a matter of fact the Management Engine may use two different ways to manage a process 

1. By directly starting a process through a command line or GUI that the user may leverage for this purpose.

2. By taking control of an already started process through a command line or GUI that the user may leverage for this purpose.

In both cases the interface used to start the process or to take control of an already running process among other things may prompt the administrator that a Priority Class is to be assigned to the process. Or alternatively the Priority Class may be assigned by averaging the Configuration Parameters of the Management Engine some of such parameters may be used to specify the association between a given process executable and its Priority Class. As an example when a process associated to an executable called wscanfs gets started the system automatically assigns to it the Priority Class specified in this configuration.

The Management Engine includes the process to which a Process Priority Class has been assigned in the list of processes managed by the Management Engine.

At regular intervals for example twice per second the Monitoring Agent sends to the Management Engine the CPU and the I O metrics related to the configured process list.

At regular intervals a separate thread started from the Management Engine infers the resource utilization CPU and I O from a history analysis of the CPU and I O metrics. The so called regular intervals are in general different from the time intervals used by the Monitoring Agent to send the data.

Using the so calculated average values the Management Engine automatically re calibrates the base priority assigned to each monitored process. illustrates this step of adjusting the process priority during their execution.

The logic to re calculate a new base priority value leverages the Process Priority Class assigned to the process. To each Process Priority Class is associated a rule that specifies how to determine the new base priority of the spawned processes based on the latest calculated metrics. The Management Engine reads the rule corresponding to the Process Priority Class of the process in the list of processes to be managed and computes the average computing resource consumption .

The Management Engine reads the rule corresponding to the Process Priority Class and computes a new base priority value for said each process using this rule.

Just as an example for long running processes whose activities are in some moments CPU bound and in other moment I O bounds the new base priority could be calculated on the basis of the average values of the CPU and I O metrics according to the following formula 

Where P Kand Kare constants values while Tand Trepresent respectively the average CPU usage and the average percent of time the CPU is idle as it waits for an I O to complete I O wait time . In a nutshell this formula means that the more the CPU usage is compared to the I O resources usage the lower the new priority to be assigned to the process and vice versa It is assumed that the greater the value of P the higher the priority of a process . Similar rules could be defined for other priority classes.

It is noted that computing of a new computed base priority value and its assignment for the processes to be managed by the Management Engine may be extended to the spawn processes. This may be indicated as a configuration parameter of the Management Engine by the administrator.

Then the Management Engine applies the newly base priority to the managed processes using an appropriate System tool or system service or a standard API to interface the operating system scheduler. For example this can be done calling the renice command with Linux operating system or leveraging the operating system native APIs of the servers such as the setpri or thread setsched to set kernel thread scheduling configuration parameters.

The Management Engine detects that the process and or its child processes terminates removes the process id from the list of the managed processes and indicates the Monitoring Agent to update the list of monitored processes in the same way.

