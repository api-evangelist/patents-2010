---

title: Dynamically weighted semantic trees
abstract: Various embodiments of systems and methods for dynamically weighted semantic trees are described herein. One or more software elements of a hierarchy are identified in response to user actions in a report. The user actions are related to at least one software element of the one or more software elements of the hierarchy. A local tree is constructed for each user by assigning local weights for the one or more software elements based on user visits to the one or more software elements. A group tree is constructed for each group to which the users belong by assigning group weights for the one or more software elements based on the user visits to the one or more software elements. The local tree and the group tree are stored for use in various applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08745092&OS=08745092&RS=08745092
owner: Business Objects Software Limited
number: 08745092
owner_city: Dublin
owner_country: IE
publication_date: 20101206
---
The field relates generally to business intelligence tools. More particularly the field is related to dynamic creation of semantic trees for business intelligence applications.

Business Intelligence BI generally refers to a category of software systems and applications used to improve business enterprise decision making and governance. These software tools provide techniques for analyzing and leveraging enterprise applications and data. These tools are commonly applied to financial human resource marketing sales service provision customer and supplier analyses. More specifically these tools can include reporting and analysis tools to analyze forecast and present information content delivery infrastructure systems for delivery storage and management of reports and analytics data warehousing systems for cleansing and consolidating information from disparate sources and integration tools to analyze and generate workflows based on enterprise systems. Business Intelligence tools work with data management systems such as relational databases or On Line Analytic Processing OLAP systems used to collect store and manage raw data and transactional enterprise systems that generate data.

Business Intelligence documents contain vast amounts of data that may be spread across several databases and numerous tables. Also data usage in business intelligence documents can be different in different scenarios. A user s area of interest may be limited to few regions in the underlying elements e.g. semantics of the data. There can also be several personas using a same document. Such data usage can be analyzed and leveraged for providing various functionalities and features. But considering the amount of data in business intelligence documents and the dynamic nature of documents analysis of data usage can be extremely tedious and process intensive.

It would therefore be desirable to dynamically assign weights for underlying elements of data based on data usage. The weights can then be used for providing various functionalities.

Various embodiments of systems and methods for dynamically weighted semantic trees are described herein. One or more software elements of a hierarchy are identified in response to user actions in a report. The user actions are related to at least one software element of the one or more software elements of the hierarchy. A local tree is constructed for each user by assigning local weights for the one or more software elements based on user visits to the one or more software elements. A group tree is constructed for each group to which the users belong by assigning group weights for the one or more software elements based on the user visits to the one or more software elements. The local tree and the group tree are stored for use in various applications such as for example tag generation applications.

These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof presented in connection with the following drawings.

Embodiments of techniques for dynamically weighted semantic trees are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

In one embodiment in the context of business intelligence applications e.g. SAP Business Objects the software elements can be semantic elements of a semantic layer data source. In business intelligence applications user interfaces are provided to retrieve data e.g. using queries into a document and generate a variety of reports using the retrieved data. In another embodiment the software elements can be hierarchical content elements of a content management system.

The software elements can be represented by a hierarchical arrangement of root nodes and sub nodes. Each node represents a software element. A plurality of sub nodes can branch out from each root node. Each sub node can in turn can have other sub nodes. In one embodiment a hierarchy includes a root node and all the lower level nodes emanating from the root node. Several such hierarchies form an entire hierarchy for all the underlying software elements of data in a data source e.g. a data warehouse or a database . In one embodiment if at least one underlying software element of a hierarchy is related to user actions then all the software elements of that hierarchy are identified and used to construct the local tree.

At at least one local tree is constructed for each user by assigning weights for the software elements that are identified at . The local tree is a hierarchical structure with weighted software elements. Weights are assigned to the software elements based on the user visits to the software elements. If a user selects particular data or user actions are related to particular data the underlying software elements of the selected data are considered as visited by the user. If a software element is visited for a first time by a user a weight is assigned for at least the visited software element. If the same software element is visited for a second time by the same user an incremental weight is assigned and added to the existing weight of the software element. In this way local trees are constructed for each user.

At a group tree is constructed for each group to which users belong. Each group consists of a set of users. The group tree is also a hierarchical structure with weighted software elements. For a group tree weights are assigned to the software elements based on the user visits to the software elements by any of the users of that group. Many users of the group can visit the software elements. There will be a first user visit to a software element i.e. the software element is visited for the first time by a user of the group. For a first user visit to a software element a weight is assigned for at least the visited software element. If the same software element is visited by any of the users in the group an incremental weight is assigned and added to the existing weight of the software element. Similarly group trees for all groups are constructed.

At the local trees and the group trees are stored. The trees can be stored on server side after each weight assignment to software elements. The weights in the stored local trees and the group trees are updated for subsequent user visits. The stored trees can be used for several purposes. For example the weights of the software elements can be used for ranking in search applications and for predictive algorithms. The software elements of the trees can also be used to automatically generate tags. Each software element can be used as a tag. The weight of a tag can be determined by the weight of the software element in the local tree and the group tree. In one example an average or weighted average of weight of the software element in the local tree and the group tree can be taken. The tags can be then be presented to a user. Tag presentation can be related to the weight of the tags. For example if a tag cloud is presented to the user weight of the tags can be related or proportional to display size display form or other display parameter of the tags.

In another embodiment of variable increase the local weight for a software element that is subsequently visited is increased to a greater degree compared to other software elements in the hierarchy. These other software elements can be above or below the level of the visited software element. User actions for generating a report can result in visiting of a lowest hierarchical software element. In which case the local weight of the lowest hierarchical software element is increased to a greater degree compared to other software elements in the hierarchy.

The local weight of the software elements can also be increased in subsequent visits based on a time parameter a location parameter a peer parameter a user role parameter and a report parameter. If a user spends more time on a particular software element then the local weight for that software element is increased further while keeping weights of other software elements constant. In this case the time parameter can be the duration of time spent by the user on a software element. User actions such as cursor movements and position can be used to decide the time spent by the user on a software element. Also in one embodiment to consider that an element is visited a user need to spend a minimum time on the element. This minimum time can be configured while implementing the dynamic weighing method.

If a user is present at a location such as a city or a state then the local weight of the location semantic elements are increased to a greater extent compared to other software elements. For example if a user is in a city k then the local weight of the city k semantic element is increased to a greater extent compared to other software elements. Report parameter can include frequency of usage of a report. If a particular report is being used more then the local weight of the software elements of that report can be increased to a greater degree.

User role parameter considers the role of a user belonging to a group. For a user with a higher role the local weight of the software elements is increased to a greater degree. Consider that a user m has a higher role compared to user n. A local tree m is created for the user m and a local tree n is created for the user n with same software elements. The weights of the software elements in local tree m are increased to a greater degree compared to the weights of software elements in local tree n. 

The group weight is increased for following user visits that are subsequent to the first user visit at . Considering the example of group 1 if the same software element is visited for a second time i.e. second user visit either by the same user or any other user of the group then the group weight of at least the visited software element is increased. As in the case of local weight the group weight can also be increased variably. In one embodiment the group weight of the visited software element can be increased to a greater degree compared to the group weight of other software elements in the hierarchy.

In another embodiment the amount of increase in group weight can be decreased for subsequent user visits. For example the increase in weight for a third user visit can be less than can the increase in weight for a second user visit. In another example the group weight for a third user visit by a user 1 can be increased to lesser degree compared to the increase in weight for a second user visit by the user 1. In other embodiments similar to the procedure used for increasing local weight the group weight can also be increased in subsequent visits based on a time parameter a location parameter a peer parameter a user role parameter and a report parameter.

The report is generated by a user 1 to view sales revenue from stores. The user performs actions on the reporting tool for generating report. For example the user can select state city and sales revenue and perform a querying operation for generating the sales revenue report. Therefore the semantic elements that are visited by the user can be determined as the store element state element city element measures element and sales revenue element. The store element the state element and the city element are part of the store hierarchy and the measures element and sales revenue element are part of the measures hierarchy . For the user 1 who generated the report a first local tree is constructed by assigning local weights to the store element the state elements and the city elements of the store hierarchy and a second local tree is constructed by assigning weights to the measures elements and sales revenue elements of the measures hierarchy . An embodiment of first and second local trees is shown in .

Referring to a first local tree is constructed by assigning weights to the semantic elements in the store hierarchy and a second local tree constructed by assigning weights to the semantic elements in the measures hierarchy. The first local tree is the result of a plurality for visits by the user 1. The user 1 may be interested in only some of the cities. The user s interest can be deciphered from the user actions. For example the user 1 may select a particular city e.g. Miami for a more detailed data. The selected city is identified and then a local weight is assigned to Miami element the city element the state element and the store element . If the user visits the Miami element again i.e. selects Miami again the local weight of Miami element is increased and the local weight of other semantic elements can be left unchanged or increased variably. In one embodiment the local weight is increased variably by increasing the local weight of the city element to a lesser degree compared to increase in local weight of the Miami element . The local weight of the Florida element can be increased to a lesser degree compared to increase in local weight of the Miami element and the local weight of the state element can be increased to a lesser degree compared to increase in local weight of the Florida element . The local weights can be similarly increased for user visits to other specific city elements such as Austin and specific state elements such as Texas .

The second local tree is also the result of a plurality of visits by the user 1 to the sales revenue element . The sales revenue element and the measures element are identified based on user s selection actions. A local weight is assigned to sales revenue element and the measures element . If the user visits the sales revenue element again the local weight of sales revenue element is increased and the local weight of the measures element can be left unchanged or increased variably.

Referring to consider that a user 2 who belongs to the group X visits element C after the visit by the user 1 . A local tree for user 2 is then constructed by assigning a local weight X to all the elements of the hierarchy. Since the user 2 also belongs to group Z and it is the second user visit to the element C the group weights in the group tree are increased. The group weights can be increased variably. For example the group weight for element C is increased by Y the group weight for the element B is increased by Y and the group weight for element A is increased by Y wherein Y1 Y2 Y3

For example if Y 3 then Y can be 0.3 Y can be 0.2 and Y can be 0.1. The group weight of the lowest hierarchical element C is increased to a greater degree i.e. Y compared to the increase in weights i.e. Y and Y for elements B and A. The local tree of user 1 is left unchanged.

Referring to the local tree for the user 1 is updated by increasing the local weights of the elements if the user 1 visits the element C again. The local weights can be increased variably. For example the local weight for element C is increased by X the local weight for the element B is increased by X and the local weight for element A is increased by X where X X X. The local weight of the lowest hierarchical element C is increased to a greater degree i.e. X compared to the increase in weights i.e. X and X for elements B and A. The local tree of user 2 is left unchanged. Since this is the third user visit to the element C the group weights in the group tree are increased. The group weights can be increased variably. For example the group weight for element C is increased by Y the group weight for the element B is increased by Y and the group weight for element A is increased by Y where Y4 Y5 Y6 Y Y4 Y2 Y5 Y3 Y6 

It can be observed that the local and group trees are dynamically created based on user activities in the reports. Weights are assigned and increased without any user intervention. The local and group trees have latest weights based on data usage by various users at any given point in time.

On the second report the user may perform actions such as hovering over the quarter 1 sales revenue figure of San Francisco. In response to this San Francisco element California element Sales revenue element and Q element can be identified. A local tree can then be constructed using at least these elements. In one embodiment three local trees can be constructed for the same user. A first local tree for the store state city hierarchy a second local tree for measures sales revenue and a third local tree for time period year quarter hierarchy.

Some embodiments of the invention may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment of the invention may be implemented using Java C or other object oriented programming language and development tools. Another embodiment of the invention may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather the scope of the invention is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

