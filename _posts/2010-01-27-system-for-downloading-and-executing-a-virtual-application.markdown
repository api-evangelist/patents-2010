---

title: System for downloading and executing a virtual application
abstract: A virtual process manager for use with a client application. Both the virtual process manager and the client application are installed on a client computing device. The client application is configured to receive a user command to execute a virtual application at least partially implemented by a virtualized application file stored on a remote computing device. In response to the user command, the client application commands to the virtual process manager to execute the virtualized application file. Without additional user input, the virtual process manager downloads the virtualized application file from the remote computing device and executes the virtual application at least partially implemented by the downloaded virtualized application file on the client computing device. The client application may comprise a conventional web browser or operating system shell process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09104517&OS=09104517&RS=09104517
owner: CODE SYSTEMS CORPORATION
number: 09104517
owner_city: Seattle
owner_country: US
publication_date: 20100127
---
The present invention is directed generally to a virtual process manager and more particularly to a virtual process manager configured to download a virtualized application file from a remote server and execute the downloaded file.

A virtual application is a virtual machine image pre configured with all of the files registry data settings components runtimes and other dependencies required for a specific application to execute immediately and without installation on a host computing device. The virtual application is partially isolated from other applications implemented on a host computing device and partially isolated from an underlying host operating system installed and executing on the host computing device. The virtual application is encapsulated from the host operating system by a virtual runtime environment which includes a virtual operating system that receives operations performed by the virtualized application and redirects them to one or more virtualized locations e.g. a virtual filesystem virtual registry and the like .

Thus the virtual application may be conceptualized as including two components a virtualization runtime and a virtual application configuration. The virtualization runtime implements the virtual runtime environment which implements various operating system application programming interfaces APIs in such a way that allows the executing virtual application to access and interact with items that may not be present on the host computer. The virtual application configuration includes data necessary to implement the virtual application within the virtualization runtime.

The virtual application is stored in and implemented by one or more data files and or executable files. Depending upon the implementation details the one or more data files and or executable files storing and implementing the virtual application may include blocks of data corresponding to each application file of a natively installed version of the application. Herein these blocks of data will be referred to as virtual application files. The one or more data files and or executable files storing and implementing the virtual application also include configuration information. When the virtual application is executed the configuration information is used to configure the virtual operating system to execute the virtual application. For example the configuration information may contain information related to the virtual application files virtual registry entries environment variables services and the like. The virtual operating system is configured to communicate with the host operating system as required to execute the virtual application on the host computing device.

A download manager is a computer program that downloads files from a web server over the Internet. The download manager is separate from a web browser which is used to navigate to a web page displaying a link to a file stored on the server. When the user clicks on the link to the file the download manager is launched and manages the download.

Conventional download managers require user interaction and an application installation process. For example download managers typically require a user to select a storage location on the user s computer into which the file will be downloaded. Then after the file is downloaded the download manager typically launches the installation process or the user executes the file separately. Alternatively a dialog box may ask the user if the user wants to install an application implemented by the downloaded file and or execute the file. Often when the user indicates the user wants to execute the application an installer is launched that installs the application. The installation process often requires additional user interactions and may be very time consuming require special permissions to perform the installation and perform potentially undesirable modifications to the user s computing device. When the installer is finished the installer may execute the downloaded and installed file. However the user is typically queried a second time as to whether the user would like to execute the file.

Thus prior art download managers require user interaction after a file is selected for download. Therefore using conventional download managers is time consuming and requires substantial user interaction. Further because the user must respond to the questions presented by the download manager the user must monitor at least a portion of the file transfer.

A need exists for a virtual process manager configured to download and execute a virtual application while requiring less user interaction than prior art download managers. A further need exists for a virtual process manager that more quickly executes virtualized application files stored on a remote server particularly in view of the fact that a virtualized application file need not be installed on the user s computer to execute thereon. A method of launching applications stored on a remote server is also desirable. The present application provides these and other advantages as will be apparent from the following detailed description and accompanying figures.

The present application describes a virtual process manager referred to as a Sandbox Manager configured to download a virtualized application file from a server computing device to a client computing device operated by a user. The Sandbox Manager does not query the user for any information during the download or execution of the virtualized application file. The user simply selects the virtualized application file for download using a Client Application such as a web browser or operating system shell and together the Client Application and the Sandbox Manager effect the transfer of the virtualized application file to the client computing device and the execution of the virtualized application file on the client computing device. Thus the user need not select a location in which to store the virtualized application file on the client computing device or indicate whether the user would like to execute the virtualized application file. In this manner the Sandbox Manager may be used to download and execute the virtualized application file in less time than is required using a conventional download manager.

As explained above a virtualized application file is transferred to the client computing device from the server computing device . The virtualized application file is illustrated in dashed lines to indicate that the virtualized application file is stored in the cache during and after the download. However before the download begins the virtualized application file is not stored in the cache . As will be explained below the virtualized application file may be an executable file or a file configured to execute within a virtualized environment provided by a virtual machine.

The system memory A stores one or more files implementing one or more virtual machines. By way of a non limiting example the system memory A may include a plurality of virtual machine executable files that when executed each implement a different virtual machine. For example each of the virtual machine executable files may implement a different version of the same virtual machine. The virtual machine executable files may be executed individually. When executed a virtual machine executable file implements a virtualized environment. Execution of a virtual machine executable file may be initiated by the Sandbox Manager using a command including a parameter e.g. a file path identifying a virtualized application file to execute. In response to receiving the parameter the virtual machine executable file executes the identified virtualized application file inside the virtualized environment implemented by the virtual machine executable file. The virtual machine may execute within an operating system shell process. Optionally the virtual machine executable files may be stored in the cache .

The virtualized application file includes a version identifier that may be used by the Sandbox Manager to select which of the virtual machine executable files is configured to execute the virtualized application file .

In the embodiment illustrated the system memory B stores web server components configured to implement a web server. The web server components may be configured to provide a web page having one or more links to virtualized application files using standard http protocol. By way of non limiting examples the web server components may include Internet Information Services IIS provided by Microsoft Corporation Apache and the like. While illustrated as being outside the filesystem B those of ordinary skill in the art appreciate that the virtualized application file and web server components may be conceptualized as being within the filesystem B.

The virtualized application file may include components necessary to implement a virtual runtime environment including a virtual operating system configured to execute in the operating system A see of the client computing device illustrated in . Alternatively the virtual runtime environment may be implemented by one of the virtual machine executable files see . The virtualized application file includes components necessary to implement a virtual application configured to execute in the virtual runtime environment. In particular embodiments a single virtualized application file is used to implement both the virtual operating system and the virtual application . However those of ordinary skill in the art appreciate that more than one virtualized application file may be used to implement the virtual operating system and the virtual application . For example the components implementing the virtual runtime environment may be stored in one of the virtual machine executable files see and the components implementing the virtual application may be stored in the virtualized application file . Further one or more of the files used to implement the virtual application may be other than an executable file having the exe file extension.

The virtual operating system includes a virtual filesystem a virtual registry and a virtual process environment and threading subsystems component . When executing the virtual application interacts with the virtual filesystem virtual registry and virtual process environment and threading subsystems component instead of interacting directly with the filesystem A the registry A and the process environment and threading subsystems component A of the operating system A illustrated in . The virtual operating system is configured to communicate with the operating system A illustrated in as required to execute the virtual application .

The virtual application executes inside a virtual runtime environment provided at least in part by the virtual operating system . Some virtual applications require one or more additional runtime environments to execute. For example to execute a Flash application the Flash runtime engine must also be installed. Therefore to virtualize a Flash application both the Flash application and Flash runtime engine must be included in the virtualized application file and configured to execute in the portions of the virtual runtime environment provided by the virtual operating system . Collectively all runtime components necessary to execute the virtual application will be referred to as a virtual runtime engine. When executed the virtual runtime engine generates at least in part the virtual runtime environment in which the virtual application executes.

The virtualized application file includes a configuration data block . The configuration data block may include virtual application files A C corresponding to each of the application files of a natively installed version of the same application. The virtualized application file identifies one or more of the virtual application files A C as a startup executable that executes when the virtual application is first executed. The startup executable may be identified in the configuration data block .

When the virtualized application file is executed the configuration data block configures the virtual operating system to execute the virtual application . For example the configuration data block may contain configuration information related to files and directories in the virtual filesystem keys and values in the virtual registry environment variables services and the like.

The configuration data block may also include basic application metadata and settings such as the application name application version and sandbox location. Further the configuration data block may provide isolation information to the virtual operating system . This information indicates which directories virtual application files A C virtual registry entries environment variables and services are to be isolated from the operating system A see of the client computing device see . While illustrated as being outside the virtual filesystem those of ordinary skill in the art appreciate that the application files A C may be conceptualized as being within the virtual filesystem when the virtual application is executing.

To execute the virtual application an initialization process is first performed. During this process the virtual operation system is launched and configured by the configuration data block . After the initialization process has completed the appropriate startup executable s is are launched inside the virtual operating system . The virtual operating system intercepts calls to the operating system A and routes them to corresponding components of the virtual operating system . For example when the virtual application requests access an application file that corresponds to the virtual application file A using a path of a natively installed version of the application the virtual operating system intercepts the request and routes the request to one of the virtual application file A. The virtual operating system may also route some requests and actions to the operating system A see of the client computing device see for processing.

U.S. patent application Ser. No. 12 188 155 filed on Aug. 7 2008 U.S. patent application Ser. No. 12 188 161 filed on Aug. 7 2008 and U.S. patent application Ser. No. 12 685 576 filed on Jan. 11 2010 all of which are incorporated herein by reference in their entireties disclose systems that may be used to create and configure the virtualized application file . As described in greater detail in U.S. patent application Ser. Nos. 12 188 155 12 188 161 and 12 685 576 the virtualized application file may be created by a virtual application executable constructor or authoring tool using an application template that includes copies of files such as a configuration file application files A C and the like used to configure the virtualized application file . However the template is not a requirement. Instead to build the virtualized application file the authoring tool needs only the configuration file and copies of any applications files A C necessary for a natively installed version of the application to execute. The applications files A C and the configuration file are referred to collectively as an application configuration . In some embodiments the authoring tool combines the application configuration and the components of the virtual runtime engine e.g. the virtual operating system into an executable virtualized application file. However in other embodiments the authoring tool omits the components of the virtual runtime engine from the virtualized application file to create a virtualized application file for execution by a virtual machine implemented by a virtual machine executable file such as one of the virtual machine executable files .

For ease of illustration the authoring tool and the application configuration have been illustrated as being stored in the system memory B of the server computing device see . However this is not a requirement. As is apparent to those of ordinary skill in the art the virtualized application file may be created on a computing device other than the server computing device such as the computing device illustrated in and transferred to the server computing device illustrated in for storage thereon.

Returning to as mentioned above the system memory A of the client computing device see stores the Client Application and the Sandbox Manager .

The Client Application translates user commands button clicks etc into requests for operations that the Sandbox Manager performs. In embodiments in which the Client Application is implemented as a web browser the browser plug in or other type of translation application may be installed on the client computing device see . Together the browser and browser plug in perform the functions of the Client Application .

By way of a non limiting example the browser plug in may be installed on the client computing device see by placing a dynamic link library dll implementing the plug in in a predetermined installation directory and registering the dll i.e. an assembly in the registry A e.g. a Windows registry of the client computing device see . An Assembly Registration tool e.g. Regasm.exe may be used to register the dll in the registry A.

Once the plug in has been installed the plug in can be used by a website implemented by the web server components see of the server computing device illustrated in via client scripting technologies such as client side javascript code executing in the Client Application . To access the plug in from the server computing device illustrated in a plug in object reference is created and sent to the Client Application . In response to receiving the reference to the plug in the Client Application loads the plug in by mime type ProgID class GUID and the like depending on the implementation details of the Client Application which in this embodiment is implemented as a web browser . The plug in exposes methods which can be used to send requests to the Sandbox Manager .

The requests include commands and optionally one or more parameters. The requests may be implemented as strings each including a command. If the request also includes parameters the parameters may be separated from one another and the command by a predetermined character such as a semi colon comma and the like. In other words the request may be implemented as a semi colon delimitated string or a string delimited in another manner. The following Table A provides a list of commands that my be included in a request.

As mentioned above the Client Application communicates with the Sandbox Manager over the communication link which may be implemented as a TCP connection. By way of a non limiting example the Client Application may send the requests as text messages using TCP protocol to the Sandbox Manager over the TCP connection. As described above each of the requests includes a command and may include one or more parameters e.g. a parameter list . These commands may be characterized as a communication protocol between the Client Application and the Sandbox Manager .

In block the Client Application receives a command from the user via a conventional user interface e.g. a mouse keyboard and the like . The user command instructs the Client Application to download the virtualized application file and or execute the virtualized application file .

The plug in is configured to request a different session for each virtualized application file being transferred and or executed. Thus each virtualized application file being transferred and or executed may be identified by a unique session identifier.

In decision block the plug in determines whether a session identifier is associated with the virtualized application file . The decision in decision block is YES when a session identifier is associated with the virtualized application file . The decision in decision block is NO when a session identifier is not associated with the virtualized application file .

When the decision in decision block is NO in block the plug in requests a new communication session having a unique session identifier with the Sandbox Manager over the communication link . Then the Client Application advances to block .

In block the Client Application translates the user command received in block into a request to be sent to the Sandbox Manager over the communication link . For example in embodiments in which the Client Application is a web browser in which the plug in is loaded in block the web browser receives the user command e.g. the user clicks on a hyperlink presses a button and the like and in block the plug in translates the user command into a request including a command e.g. one of the commands listed in Table A above and optionally one or more parameters e.g. the session identifier associated with the virtualized application file . The user command may be an instruction to download the virtualized application file see an instruction to execute the virtualized application file and the like. As mentioned above the request may be a string including the command and parameters if any.

Returning to in block the Client Application transmits the request to the Sandbox Manager over the communication link e.g. a TCP connection illustrated in . Optionally in block the Client Application may receive information from the Sandbox Manager . The information received may be a response to the command e.g. a response to a ping command a result of performing the command status and or progress information related to performing a command an error message and the like. Then the method terminates.

Returning to the Sandbox Manager receives requests from the Client Application and performs the command included in the requests. The Sandbox Manager manages the transfer of the virtualized application file see from the server computing device to the client computing device illustrated in . The Sandbox Manager also manages execution of the virtual application see on the client computing device see . Turning to the Sandbox Manager includes a communications server e.g. a TCP server one or more predefined Client Request object types a Client Request Manager a Downloader and an Executer .

Returning to as mentioned above in block the plug in requests a different communication session having a unique session identifier for each virtualized application file being transferred and or executed. Referring to in response to each request for a new communication session the communications server establishes a communication session between the Client Application and the Sandbox Manager and generates a unique session identifier for the new communication session. In this manner each virtualized application file being transferred and or executed may be identified by a unique session identifier.

Each of the predefined Client Request object types is associated with a particular type of virtualized application file. For example the Client Request object types include a Client Request object type associated with the virtualized application file . The types are used to create a Client Request object for each virtualized application file to be downloaded and or executed by the Sandbox Manager . An object of the Client Request object type associated with the virtualized application file is responsible for managing transfer and execution of the virtualized application file including determining status managing the cache see stored on the filesystem A etc.

The Client Request Manager determines whether a Client Request object has been created for a particular virtualized application file associated with a session identifier. If a Client Request object has not been created for a virtualized application file the Client Request Manager see identifies which of the predefined Client Request object type is configured to manage details about the virtualized application file creates a Client Request object of the type identified and associates the Client Request object with the session identifier associated with the virtualized application file. By way of a non limiting example a Client Request object may need to be created when the Sandbox Manager receives a start command for the first time to start downloading the virtualized application file . The Client Request Manager may include a dictionary configured to store Client Request objects for use in performing commands included in requests. The dictionary may be stored in the cache see of the filesystem A see .

Each of the Client Request objects includes a status field indicating a status related to the transfer and or execution of the virtualized application file. Table B below provides non limiting examples of status values or codes that may be stored in the status field.

The status field may be set to Canceled when user exits the web page e.g. browses to another page closes the browser window and the like on which the link to the virtualized application file being downloaded is displayed. By way of a non limiting example when the user exits the web page a cancel call may be created automatically e.g. by script code executing in the Client Application and sent to the plug in . In response the plug in sends a cancel message including the session identifier e.g. cancel to the Sandbox Manager over the communication link . If the status value of the status field of the Client Request object including the session identifier in the cancel message is In Progress the transfer is cancelled by the Sandbox Manager .

By way of a non limiting example the status value of the status field may be determine in the following manner. If the transfer of the virtualized application file has not yet started the current status is Not Started. If the transfer has started and is in progress the current status is In Progress. If the transfer has started is not in progress and has completed the current status is Complete. If the transfer has started is not in progress has not completed and has been canceled the current status is Canceled. If the transfer has started is not in progress has not completed has not been canceled and has encountered an error the current status is Error. Table C below provides a non limiting example of error codes that may used by the Sandbox Manager .

Each of the Client Request objects includes a progress field indicating an amount e.g. a percentage from 0 to 100 of the virtualized application file stored in the cache see of the filesystem A see .

Each of the Client Request objects may include a path to the transferred virtualized application file stored on the cache see of the filesystem A see .

The Downloader downloads a particular virtualized application file identified by a session identifier.

Next in decision block the parameters are validated. By way of a non limiting example the parameters may be validated by determining whether the number of parameters matches the number that were expected. The decision in decision block is YES when the parameter are valid e.g. the number of parameters matches the number that were expected . Thus if a particular command does not include parameters e.g. the ping command the decision in decision block is YES if the request does not include any parameters. The decision in decision block is NO when the parameter are invalid e.g. the number of parameters does not match the number that were expected .

When the decision in decision block is NO in block an error message is sent to the Client Application . Then the method terminates.

When the decision in decision block is YES the Sandbox Manager advances to decision block . In decision block the Sandbox Manager determines whether the request includes a session identifier. The decision in decision block is YES when the request includes a session identifier. The decision in decision block is NO when the request does not include a session identifier.

When the decision in decision block is YES in block the session identifier is used to identify or locate a Client Request object associated with the session identifier and responsible for downloading and or executing the virtualized application file identified by the session identifier. The dictionary of the Client Request Manager may be used to lookup the Client Request object associated with the session identifier.

In decision block the Sandbox Manager determines whether a Client Request object associated with the session identifier has been identified. The decision in decision block is YES when a Client Request object associated with the session identifier has been identified. The decision in decision block is NO when a Client Request object associated with the session identifier has not been identified in block .

When the decision in decision block is NO in block the Sandbox Manager sends an error message to the Client Application . The error message may include the error indicator Invalid Session Id see Table C above . Then the method terminates. Thus if a command is sent to the Sandbox Manager with a session identifier that is not in the dictionary an error is returned to the Client Application and a new request must be sent to the Sandbox Manager . For example if a status progress or exec command was received in block including a session identifier not associated with a Client Request object for the Sandbox Manager to perform the command the transfer must be started again with a new request including the start command.

When the decision in decision block is NO the Sandbox Manager advances to decision block to determine whether the Sandbox Manager should create a new Client Request object. Referring to Table A above only two commands listed do not include the session identifier the start command and the ping command. The decision in decision block is YES when the command in the request is the start command. Otherwise the decision in decision block is NO. Thus the decision in decision block is NO when the request includes the ping command.

When the decision in decision block is YES in block the Sandbox Manager creates a new Client Request object and associates the new Client Request object with a session identifier. By way of a non limiting example a method call may be made to the Client Request Manager see to create the new Client Request object. In response to the method call the Client Request Manager identifies the Client Request object type that manages details about the particular virtualized application file being transferred to and or executed on the client computing device see . Then a new Client Request object having the type identified by the Client Request Manager is created.

The Client Request Manager includes a Client Request object for each virtualized application file the Sandbox Manager is transferring and or executing. The Client Request object may be cached in the dictionary of the Client Request Manager which may be configured to provide fast lookup of the Client Request object in response to subsequent requests including the session identifier involving the cached Client Request object. The Client Request object is responsible for managing the transfer of the virtualized application file status of the transfer progress of the transfer execution of the virtualized application file management of the cache see etc. Thus when a transfer is started a unique session identifier is generated a Client Request object is created the Client Request object is associated with the unique session identifier and the Client Request object is stored in the dictionary for future lookups. The status field of the new Client Request object is set to Not Started and the progress field is set to 0 . 

Then the Sandbox Manager advances to block from block . When the decision in decision block is NO the Sandbox Manager also advances to block .

In block Sandbox Manager performs the command. If applicable the command is executed on the Client Request object identified in block or created in block . Then in optional block Sandbox Manager sends information back to the Client Application . For example as discussed below with respect to the method see some commands instruct the Sandbox Manager to perform operations that return values to the Client Application . Then the method terminates.

If the command is a ping command in blocks and the Sandbox Manager sends a response to the Client Application . If the command is a start command in block the Downloader downloads the virtualized application file . If the command is a status command in blocks and the Sandbox Manager obtains the status value from the status field of the Client Request object identified in block or created in block and sends the status value to the Client Application . If the command is a progress command in blocks and the Sandbox Manager obtains the progress value from the progress field of the Client Request object identified in block or created in block and sends the progress value to the Client Application . If the command is a exec command in block the Executer executes the virtualized application file .

In first block the Client Application receives a new user command to download and execute the virtualized application file . In block the Client Application sends a request including the ping command to the Sandbox Manager . The ping command is sent by the Client Application to determine whether the Sandbox Manager is in a state to service commands e.g. available and functioning and capable of responding to requests. If the Sandbox Manager is running and in a state to service commands the Sandbox Manager will send a response to the Client Application .

In decision block the Client Application determines whether it has received a response from the Sandbox Manager to the request sent in block . The decision in the decision block is YES when the Client Application has received a response from the Sandbox Manager indicating that the Sandbox Manager is in a state to service commands and is capable of responding to requests. The decision in the decision block is NO when the Client Application has not received a response from the Sandbox Manager or receives a response indicating the Sandbox Manager is not in a state to service commands e.g. available and functioning or is incapable of responding to requests.

When the decision in the decision block is NO the Client Application returns to block . Alternatively when the decision in the decision block is NO the method may terminate. Optionally the Client Application may display a message to the user indicating the virtualized application file is not available to download.

When the decision in the decision block is YES in block the Client Application establishes a new communication session with the Sandbox Manager and sends a request including a start command to the Sandbox Manager . As mentioned above when the communications server see of the Sandbox Manager initiates a new session the communications server generates a new and unique session identifier. The start command commands the Sandbox Manager to begin transferring the virtualized application file .

In block when the Sandbox Manager receives the start command the Client Request Manager identifies a Client Request object type for the virtualized application file creates a Client Request object of the type identified and associates the session identifier with the new Client Request object. Then the Sandbox Manager determines whether at least a portion of the virtualized application file is stored in the cache see of the filesystem A see . The decision in the decision block is YES when at least a portion of the virtualized application file is stored in the cache see . Otherwise the decision in the decision block is NO. 

When the decision in decision block is YES in decision block the Sandbox Manager determines whether the virtualized application file is stored in its entirety in the cache see of the filesystem A see . The decision in the decision block is YES when the virtualized application file is stored in its entirety in the cache see of the filesystem A see . The decision in the decision block is NO when less than the entire virtualized application file is stored in the cache see .

When the decision in decision block is YES the virtualized application file need not be transferred to the client computing device because the virtualized application file is already stored in the cache see of the filesystem A see . In block the Sandbox Manager updates the status field of the Client Request object to Complete and the progress field to 100 . Then the Sandbox Manager advances to block .

When the decision in decision block or decision block is NO the Sandbox Manager begins transferring the virtualized application file. If the decision block was NO in block the Sandbox Manager adds the virtualized application file to the cache see of the filesystem A see . The Sandbox Manager sets the status field of the Client Request object to Not Started and the progress field to 0 . Then in block the Sandbox Manager begins transferring the virtualized application file from its beginning.

If the decision block was YES but the decision block was NO in block the Sandbox Manager sets the status field of the Client Request object to In Progress calculates the progress value and sets the progress field to the calculated progress value. Then the Sandbox Manager begins transferring the virtualized application file from wherever the previous transfer activities left off. The transfer may be started in a new thread using http protocol. In block the progress field of the Client Request object is updated occasionally e.g. periodically to indicate the percentage of the virtualized application file transferred. Then the Sandbox Manager advances to block .

In block the Sandbox Manager returns the session identifier associated with the virtualized application file to the Client Application .

In block the Client Application sends a request to the Sandbox Manager including the status command. In response to the status command in block the Sandbox Manager sends the status value e.g. in progress or complete of the status field of the Client Request object to the Client Application . In block the Client Application receives the status value sent by the Sandbox Manager . Optionally the Client Application may display the status value of the transfer to the user.

In decision block the Client Application determines whether the entire virtualized application file has been downloaded. The decision in decision block is YES if the status field of the Client Request object indicates the entire virtualized application file has been downloaded e.g. the status field has the value Complete . The decision in decision block is NO if the status field of the Client Request object indicates the virtualized application file has not been completely downloaded e.g. status field has the value In Progress .

If the decision in decision block is NO in block the Client Application sends a request to the Sandbox Manager including the progress command to determine the progress value of the transfer of the virtualized application file . In response to the progress command in block the Sandbox Manager sends the progress value in the progress field of the Client Request object e.g. 10 25 etc. to the Client Application . In block the Client Application receives the progress value sent by the Sandbox Manager . Optionally the Client Application may display the progress value to the user. Then the Client Application returns to block .

If the decision in decision block is YES in block the Client Application sends a request to the Sandbox Manager including an exec command. In response to the exec command in block the Executer see of the Sandbox Manager executes the virtual application at least partially implemented by the virtualized application file that the Sandbox Manager has just transferred. Then the method terminates.

As mentioned above the parameters of the exec command includes the session identifier identifying the virtualized application file transferred and optional command line arguments. The session identifier is used to identify the Client Request Object storing the path to the transferred virtualized application file stored on the cache see of the filesystem A see . The path is then used to execute the transferred virtualized application file. The transferred virtualized application file may be executed via an operating system programming interface function call e.g. ShellExecute CreateProcess and the like .

In block if the virtualized application file is configured to be executed inside a virtualized environment provided a virtual machine executable file e.g. the virtualized application file is not an executable file having the .exe extension the Sandbox Manager executes the virtual machine executable file and instructs the executing virtual machine to execute the virtualized application file . The Sandbox Manager may send a command to the operating system A to execute the virtual machine inside an operating system shell process. The command may include the path to the virtualized application file as a parameter that the virtual machine uses to locate and execute the virtualized application file .

If more than one virtual machine executable file e.g. virtual machine executable files are stored in the system memory A the Sandbox Manager identifies which of the virtual machine executable files is configured to execute the virtualized application file . As explained above the virtualized application file may include a version identifier that may be used by the Sandbox Manager to select which of the virtual machine executable files is configured to execute the virtualized application file . Each of the virtual machine executable files may also include a version identifier that may be matched to the version identifier of a particular virtualized application file to determine whether the virtual machine executable file is configured to execute the particular virtualized application file.

By way of a non limiting example blocks and of the method may be implemented in accordance with the following block of pseudo code.

By way of a non limiting example the function named StartDownload used in the above block of pseudo code may be implemented as follows 

By way of a non limiting example the function named FindFullSize used in the first block of pseudo code may be implemented as follows 

Moreover those skilled in the art will appreciate that implementations may be practiced with other computer system configurations including hand held devices multiprocessor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. Implementations may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

The exemplary hardware and operating environment of includes a general purpose computing device in the form of a computing device . Each of the client computing device and the server computing device may be implemented in accordance with the computing device . By way of non limiting example the Client Application the Sandbox Manager the virtual machine executable files and the transferred virtualized application file may be implemented on a first computing device like the computing device . The web server components and the authoring tool may be implemented on a second computing device like the computing device configured to storing the virtualized application file and generate a web page displaying a link e.g. a hyperlink to the virtualized application file and providing a reference to the plug in .

The computing device includes the system memory . Each of the system memory A see and the system memory B see may be constructed in accordance with the system memory .

The computing device also includes a processing unit and a system bus that operatively couples various system components including the system memory to the processing unit . There may be only one or there may be more than one processing unit such that the processor of computing device comprises a single central processing unit CPU or a plurality of processing units commonly referred to as a parallel processing environment. The computing device may be a conventional computer a distributed computer or any other type of computer.

The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory may also be referred to as simply the memory and includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computing device such as during start up is stored in ROM . The computing device further includes a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM DVD or other optical media.

The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical disk drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of computer readable instructions data structures program modules and other data for the computing device . It should be appreciated by those skilled in the art that any type of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards USB drives digital video disks Bernoulli cartridges random access memories RAMs read only memories ROMs and the like may be used in the exemplary operating environment. As is apparent to those of ordinary skill in the art the hard disk drive and other forms of computer readable media e.g. the removable magnetic disk the removable optical disk flash memory cards USB drives and the like accessible by the processing unit may be considered components of the system memory .

A number of program modules may be stored on the hard disk drive magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computing device through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor computers typically include other peripheral output devices not shown such as speakers and printers.

The computing device may operate in a networked environment using logical connections to one or more remote computers such as remote computer . These logical connections are achieved by a communication device coupled to or a part of the computing device as the local computer . Implementations are not limited to a particular type of communications device. The remote computer may be another computer a server a router a network PC a client a memory storage device a peer device or other common network node and typically includes many or all of the elements described above relative to the computing device . The remote computer may be connected to a memory storage device . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet. The network may include any of the aforementioned networking environments.

When used in a LAN networking environment the computing device is connected to the local area network through a network interface or adapter which is one type of communications device. When used in a WAN networking environment the computing device typically includes a modem a type of communications device or any other type of communications device for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the personal computing device or portions thereof may be stored in the remote computer and or the remote memory storage device . It is appreciated that the network connections shown are exemplary and other means of and communications devices for establishing a communications link between the computers may be used.

The computing device and related components have been presented herein by way of particular example and also by abstraction in order to facilitate a high level view of the concepts disclosed. The actual technical design and implementation may vary based on particular implementation while maintaining the overall nature of the concepts disclosed.

Returning to the operating system A the Client Application the Sandbox Manager the virtual machine executable files and the transferred virtualized application file may be stored as computer executable components on the system memory A. Each of the operating system A the Client Application the Sandbox Manager the virtual machine executable files and the transferred virtualized application file may be implemented using software components that are executable by the processing unit and when executed perform the functions described above.

Returning to the virtualized application file the web server components and the authoring tool may be stored as computer executable components on the system memory . Each of the virtualized application file the web server components and the authoring tool may be implemented using software components that are executable by the processing unit and when executed perform the functions described above.

The foregoing described embodiments depict different components contained within or connected with different other components. It is to be understood that such depicted architectures are merely exemplary and that in fact many other architectures can be implemented which achieve the same functionality. In a conceptual sense any arrangement of components to achieve the same functionality is effectively associated such that the desired functionality is achieved. Hence any two components herein combined to achieve a particular functionality can be seen as associated with each other such that the desired functionality is achieved irrespective of architectures or intermedial components. Likewise any two components so associated can also be viewed as being operably connected or operably coupled to each other to achieve the desired functionality.

While particular embodiments of the present invention have been shown and described it will be obvious to those skilled in the art that based upon the teachings herein changes and modifications may be made without departing from this invention and its broader aspects and therefore the appended claims are to encompass within their scope all such changes and modifications as are within the true spirit and scope of this invention. Furthermore it is to be understood that the invention is solely defined by the appended claims. It will be understood by those within the art that in general terms used herein and especially in the appended claims e.g. bodies of the appended claims are generally intended as open terms e.g. the term including should be interpreted as including but not limited to the term having should be interpreted as having at least the term includes should be interpreted as includes but is not limited to etc. . It will be further understood by those within the art that if a specific number of an introduced claim recitation is intended such an intent will be explicitly recited in the claim and in the absence of such recitation no such intent is present. For example as an aid to understanding the following appended claims may contain usage of the introductory phrases at least one and one or more to introduce claim recitations. However the use of such phrases should not be construed to imply that the introduction of a claim recitation by the indefinite articles a or an limits any particular claim containing such introduced claim recitation to inventions containing only one such recitation even when the same claim includes the introductory phrases one or more or at least one and indefinite articles such as a or an e.g. a and or an should typically be interpreted to mean at least one or one or more the same holds true for the use of definite articles used to introduce claim recitations. In addition even if a specific number of an introduced claim recitation is explicitly recited those skilled in the art will recognize that such recitation should typically be interpreted to mean at least the recited number e.g. the bare recitation of two recitations without other modifiers typically means at least two recitations or two or more recitations .

