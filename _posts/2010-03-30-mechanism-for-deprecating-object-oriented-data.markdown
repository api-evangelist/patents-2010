---

title: Mechanism for deprecating object oriented data
abstract: Techniques are described to allow the deprecation of classes in an object-oriented data model, such as a CDM for a CMDB. When a class is deprecated and replaced by another existing or new class, data associated with instances of the deprecated class may be migrated to the replacement class. A mapping between the deprecated class and its replacement class may be provided to allow existing applications to continue to access data using the deprecated class without change until the deprecated class is finally deleted or the application is updated to use the replacement class. New applications written to use the object-oriented data model after the deprecation may use the replacement class to access data instances created using the original data model.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08983982&OS=08983982&RS=08983982
owner: BMC Software, Inc.
number: 08983982
owner_city: Houston
owner_country: US
publication_date: 20100330
---
This application claims priority to U.S. Provisional Application Ser. No. 61 289 342 entitled A Mechanism to Deprecate Object Oriented Data filed Dec. 22 2009 which is incorporated by reference in its entirety herein.

This disclosure relates generally to the field of computer software. More particularly but not by way of limitation it relates to a method of allowing changes to an object oriented data model that allows older versions of the model to co exist with newer versions of the model such that both existing applications and new ones may continue to operate seamlessly without any changes or disruption.

Today applications often store business information in repositories in an object oriented fashion. Typically well defined schemas or models describe how the data may be stored and accessed. In general the model describes the various classes the class hierarchy and how the classes can be associated. Applications rely on the information in the model to perform operations on the data stored in the repository.

Situations may arise that may warrant changes to a model. The changes might be related to changing a class definition deleting a class introducing a new class etc. Such changes to the model are often very disruptive to existing consuming applications. In such scenarios the existing and already functioning applications that were working well before typically stop working and have to be suitably updated or patched before they may continue to work.

One such repository is a Configuration Management Database CMDB that uses an object oriented model called the Common Data Model CDM . As new technologies emerge and standards evolve the CDM has to be updated to keep up with the changes. In the past there have been instances where changes were made to the CDM that compromised backward compatibility. Such incompatible changes have been disruptive to both consumers and providers of the CMDB. Typically different applications interact with the CMDB for various reasons and those applications must be patched after making changes to the CDM. What is needed is a mechanism that would facilitate changes to the data model without breaking the consuming applications. In other words the mechanism should allow the old model to co exist with the newly updated model such that both existing applications and new ones may continue to operate seamlessly without any changes or disruption.

In one embodiment a method is disclosed. The method comprises deprecating a first class of an object oriented model of a computer implemented database selecting a second class of the object oriented model as a replacement for the first class and migrating data associated with a first instance of the first class to a second instance of the second class.

In another embodiment a computer readable medium is disclosed. The computer has instructions for a programmable control device stored thereon wherein the instructions cause a programmable control device to perform the method described above.

In yet another embodiment a networked computer system is disclosed. The networked computer system comprises a plurality of computers communicatively coupled at least one of the plurality of computers programmed to perform at least a portion of the method of described above wherein the entire method described above is performed collectively by the plurality of computers.

The techniques and embodiments described below allow the deprecation of classes in an object oriented data model. When a class is deprecated and replaced by another existing or new class data associated with instances of the deprecated class may be migrated to the replacement class. Existing applications written to use the object oriented data model may continue to access data using the deprecated class without change until the deprecated class is finally deleted or the application is updated to use the replacement class. New applications written to use the object oriented data model after the deprecation may use the replacement class to access data instances created using the original data model.

In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the invention. It will be apparent however to one skilled in the art that the invention may be practiced without these specific details. In other instances structure and devices are shown in block diagram form in order to avoid obscuring the invention. References to numbers without subscripts are understood to reference all instance of subscripts corresponding to the referenced number. Moreover the language used in this disclosure has been principally selected for readability and instructional purposes and may not have been selected to delineate or circumscribe the inventive subject matter resort to the claims being necessary to determine such inventive subject matter. Reference in the specification to one embodiment or to an embodiment means that a particular feature structure or characteristic described in connection with the embodiments is included in at least one embodiment of the invention and multiple references to one embodiment or an embodiment should not be understood as necessarily all referring to the same embodiment. The order of actions described below is illustrative and by way of example only and other actions and other orders of taking those actions may be performed as desired.

Although the following description is written in terms of a CMDB and deprecating classes in a CDM the disclosed techniques are not limited to such a context and may be used in any situation in which object oriented classes and data are desired to be deprecated while allowing existing applications to continue to function without change during the deprecation period.

A CMDB represents the authorized configuration of the significant components of an information technology IT environment. Those components may include hardware components software components people and services provided by the IT environment. A CMDB helps an organization understand the relationships between these components and track their configuration. CMDB implementations often involve federation the inclusion of data into the CMDB from other sources in such a way that the source of the data retains control of the data.

The CMDB records configuration items CI and details about the important attributes and relationships between CIs. Examples of CIs include individual requirements documents hardware software models plans and people. The CDM typically models not only the components themselves but also the relationships between those components. For example a group of hardware devices that is a collection of subcomponents may use a class for modeling the hardware device and one or more subclasses that model the hardware subcomponents that are used in the hardware device to allow tracking changes to the hardware device at the device level at the subcomponent level or both. In another example software that is installed on a hardware device may be modeled with relationships between the software and the hardware device allowing the IT organization to understand among other things what software may be affected by a change or problem affecting a hardware device or where updates to the software may need to be installed.

The CDM is metadata that describes or models the data representing the real world components that is contained in the CMDB and can be used to address how the CMDB data is to be manipulated.

Providing the capability to deprecate classes in a CDM will minimize disruption to consuming applications and also help preserve and maintain the backward compatibility of the CDM. If a decision is made that an existing class should be deleted or replaced with a new class then the existing class may be deprecated. Existing applications referring to a deprecated class should continue to function correctly using the deprecated classes and new applications may use the new class that replaces the deprecated class.

The disclosed techniques are applicable to classes shipped by a CMDB vendor as well as for classes created by consumer applications. In some embodiments there may be a boundary between applications delineating which application may deprecate which classes. In such embodiments the owner of the class typically the creator of the class may decide whether to deprecate the class. For example if SoftwareServer is a class shipped by a CMDB vendor and a discovery application extends that class and creates an OracleAppServer class the CMDB may be the owner of the SoftwareServer class and the discovery application may be the owner of the OracleAppServer class. If an ownership rule is enforced then only the discovery application as owner of the class may decide whether to deprecate the OracleAppServer class. Some embodiments may not enforce an ownership rule in which case any application may deprecate any class.

Embodiments described below provide mapping information about the classes and attributes that are going to be deprecated. This mapping information may be provided by the owner of the class when the decision is made to deprecate the class. Various embodiments will change the class model such that interfaces of the class and the behavior of CMDB client applications do not need to change. Data associated with deprecated classes may be migrated to a new location without duplicating the data in the CMDB.

Before going further a brief overview of deprecation may be in order. Deprecation of a class and its attributes implies that the class and attributes are going to be removed in the future with either the class or one or more attributes being deleted or replaced by another class or attribute. How long the deprecation period extends is up to the owner of the class that is deprecated. Deprecation allows some time for old applications to migrate to the new class model. During this time the old applications may continue to work as before. At the end of the deprecation period the deprecated class may be deleted. The deprecation period provides time for end users to modify or replace all of the applications that rely on the deprecated class.

A CDM class may be considered a candidate for deprecation if either the class is to be replaced by a new class or the class is to be deleted such as when the class is considered obsolete. In some embodiments suitable indicators may indicate that a class is deprecated. The CMDB create update delete CRUD metadata application programming interfaces APIs may continue in use on deprecated classes. CMDB API clients may still extend classes or add attributes in the deprecated classes. In one embodiment appropriate warning messages may be logged when operating on a deprecated class.

CRUD operations may continue to act on deprecated class instances. If a replacement class is defined for the deprecated class data associated with deprecated classes may be migrated so that it may be accessed though the replacement class but remains accessible through the deprecated class. The CMDB data is not duplicated during the data migration but is moved according to the mapping for deprecated classes attributes.

Deprecation has been available in programming languages such as the JAVA programming language. JAVA is a registered trademark of Sun Microsystems. The deprecation in the context of a programming language however has merely meant that a feature of the language is flagged as deprecated. The compiler or interpreter compiling or interpreting source code written in the programming language typically generates the same executable code as before the deprecation but produces a warning message noting the feature is deprecated sometimes with a message suggesting how the programmer should modify the program to eliminate the deprecated feature.

Deprecation of a class in object oriented data model as disclosed herein in contrast involves modifying a data model that is used by applications that are already written to use the data model. The data model should be changed in such a way that old applications can interact with it without change allowing new applications written to the changed data model and old applications written to the original data model to access data instances that were created using the original data model. This involves more than merely flagging a class of the data model as deprecated.

When a class is deprecated it may be deprecated with no replacement class. Alternately it may be deprecated and replaced either by another existing class or by a new class. When deprecating a class and replacing the deprecated class with another class some or all of the attributes of the deprecated may be mapped to existing or new attributes of the target class.

In one embodiment a relationship can be mapped to another relationship if the endpoint classes are the same or they are the superclasses and the cardinality constraint is more permissive. In such an embodiment a 1 1 relationship can be mapped to a 1 many relationship but a 1 many relationship may not be mapped to a 1 1 relationship. In other embodiments these constraints may be eliminated or relaxed.

Similarly when an attribute of a class is deprecated it may be deprecated with no replacement attribute. Alternately it may be deprecated and replaced either by another existing attribute or by a new attribute of a different class. In one embodiment an attribute may be deprecated and replaced by a single other attribute without transformation or concatenation of the attribute. For example the data type of the replacement attribute is the same as the data type of the attribute being deprecated even though the attribute is now an attribute of a different class.

In one embodiment the following use cases for class deprecation are supported. A leaf class may be deprecated and replaced with its superclass. A superclass may be deprecated along with all of its subclasses. A class may be deprecated and replaced with a sibling class. A class may be deprecated and replaced with a sibling class of its superclass. A class may be deprecated and replaced with a class in another class hierarchy. One or more attributes of the class may be deprecated.

In one embodiment a utility may be provided to perform the deprecation function. The utility provides the mechanism for deprecating a class or attribute and also provides a mechanism for migrating the data associated with the deprecated class or attribute. A property may be added to the CMDB metadata to indicate whether the class or attribute is deprecated. The utility may be written in any desired programming language such as the JAVA programming language.

In one embodiment if the class is to be deprecated and replaced with a new class then the new class may be created prior to execution of the utility. In one embodiment only an owner of the class to be deprecated may deprecate the class.

The deprecation utility may use a class attributes mapping as input. Any suitable user interface may be provided to allow the user to create modify or delete class mappings for deprecation including loading of a pre defined mapping. If the class or attribute to be deprecated is not to be replaced by another class or attribute then the mapping may not be required and the utility in one embodiment may simply mark the class or attribute as deprecated.

The mapping data may be stored in CMDB configuration classes. After the mapping is completed then the mapping information may be bundled with installation materials for the CMDB to allow use of the deprecated classes by existing applications. The deprecation utility may then use the mapping data to deprecate the classes in the data model and suitably modify the corresponding data structures.

In block a class to be deprecated may be identified. If multiple classes are to be deprecated then a list of such classes may be created and the actions of blocks may be performed for each member of the list. In block if the deprecated class is not to be replaced with another class blocks may be skipped. In block any non existing class that is to replace the deprecated class may be created. In block the mapping user interface of the utility may be used to create suitable mappings for the deprecated class and its attributes mapping them to their replacement as desired. In block the mapping data may be bundled with installation materials for the CMDB to allow customers to modify the CMDB to use the modified CDM while allowing existing CMDB applications to continue to function without change.

In one embodiment the deprecation utility may be provided in the installation procedure for the CMDB. The installation upgrade process for the CMDB and applications bundled with the CMDB may invoke this utility to perform the class deprecation function and the data migration function. The utility may adjust the internal structure of the CMDB such that CRUD operations via the CMDB API may work without change to old applications redirecting or mapping CRUD operations on the deprecated class to operate on the replacement class. Once the internal data structure is adjusted the utility may migrate the data from the deprecated class to the mapped or target class according to the previously defined attribute mapping. During the migration of the CI instances the value of an attribute such as classID may be changed to the mapped class ID but values of other attributes such as an instance ID may not change. The utility may mark the class or attribute as deprecated.

In one embodiment forms are used as data structures for storing and accessing CMDB data. In such an embodiment several types of forms may exist. A Regular form stores data in a regular database table. A Join form links Regular forms together and Vendor forms allow access to data from external data sources which may or may not be stored in tables and which may be local or remote. Vendor forms may require some programming to link to the other data source. The use of forms is illustrative and by way of example only and other embodiments may use other data structures and techniques to allow users to enter or view data in the object oriented data repository.

As illustrated in diagram after deprecation of the class ApplicationServer fields C and D are moved from the ApplicationServer class to the SoftwareServer class by moving from the ApplicationServer  form to the SoftwareServer  form . For data storage purposes the attributes now exist in SoftwareServer class but fields C and D remain attributes of deprecated class ApplicationServer . After migration of the data for instances of the ApplicationServer class the base form ApplicationServer  may be deleted.

The look and feel of the form ApplicationServer does not change but the definition of the form changes. In one embodiment the post deprecation form ApplicationServer may be a vendor form that uses code to obtain data formerly in the ApplicationServer  form from the SoftwareServer form .

New or updated clients of the CMDB may use the SoftwareServer class and old application clients of the CMDB may continue to use the deprecated ApplicationServer class . Instance operations performed by one client may be visible to another. For example if a new client creates a SoftwareServer class instance then an existing client may access it as an instance of the ApplicationServer class . In order to do this a user may provide a mapping qualification that is part of the mapping information. This qualification may be a set of criteria by which the CMDB may be configured to identify which instances of the SoftwareServer class can be considered as instances of the ApplicationServer class .

In one embodiment a deprecation module may be used to handle the interaction with deprecated classes. The deprecation module may handle get set create and delete calls for CRUD operations. API calls made via the vendor form for the deprecated class may call methods of the deprecation module which in turn make appropriate CMDB calls to manipulate the migrated data and any new data. The deprecation module may use the mapping created during the deprecation process to map calls into appropriate CMDB API calls and to map data between the deprecated and new class forms.

In the example above unchanged old applications may continue to use the ApplicationServer form without seeing any difference between the original join form and the new vendor form representing the deprecated class. The deprecation module may handle making CMDB API calls that take care of massaging the data.

When deprecating classes relationship instances that involve the deprecated class may also be changed. The relationship instances have the class IDs of the source and destination endpoints of the relationship. So when any of the end point classes is deprecated and replaced with another class the relationship instances may be updated with the class ID of the replacement class. For example using the example of if there is a relationship between a CI that is an instance of BaseElement and another CI that is an instance of ApplicationServer classID then relationship data may be changed to replace the class ID ApplicationServer with the class ID SoftwareServer as the source or destination class ID.

In this example attribute C is mapped to a new attribute C while attribute D is not mapped to a new attribute but merely moved. After deprecation form is a vendor form obtaining information from vendor form mapping attribute C as C. Form continues to join forms and . Form handles attributes A B G and H as before but also handles attributes C C as C and D. After migration of the data form may then be deleted. In some embodiments form may be retained until the deprecated class is finally deleted.

In some embodiments subclasses of deprecated classes may also be deprecated and their corresponding forms changed as described above.

Diagram illustrates the form structure and attributes after deprecation of Class C in this example mapping attributes C into a new attribute C D into a new attribute D E into a new attribute E and F unchanged into form . Form is changed from a join form into a vendor form that obtains all of its attributes from form . Form now handles attributes C D E F G and H. Form handles attributes A and B obtained from form as well as attributes C C as C D D as D E E as E F G and H obtained from form . Vendor form obtains all of its attributes from form .

In a scenario where a class is to be deprecated and replaced by a class in a completely different hierarchy then mapping of attributes may be done to the root class level of the new hierarchy. In such a scenario relationship CIs do not have any common classes and the relationship may be deprecated if it involves the deprecated class or its subclasses.

Like a regular class a relationship class may also be deprecated. If the relationship consists of R A B where A and B are endpoint classes of relationship R then this class may be migrated to relationship class R1 A1 B1 if classes A1 and B1 are superclasses of A and B respectively and with a no less permissive cardinality constraint. All of the scenarios for regular classes may be applicable to relationship classes as well.

In some embodiments an attribute may also be deprecated if it is moving or be modified in the same class. For example an attribute may be deprecated by being renamed or changing its data length. However an attribute that is moving from one class to another is an example of deprecation of a class instead of deprecation of an attribute. Attribute deprecation involves mapping of the attributes in the same class.

In order to perform class deprecation in one embodiment a data structure is used to store mappings for deprecated classes in the CMDB as configuration classes. This avoids the need to provide special APIs for maintaining the mappings or to create special export import functionality for the mapping data. In one embodiment a new class may be added to the CMDB to store the class mapping information with the following attributes a OriginalClassID b OperationType c MappedClassID d ApplicationName e ApplicationVersion f Deprecation Phase g DeprecationStatus and h Qualification.

The OriginalClassID attribute is the class ID of the deprecated class. The OperationType attribute indicates whether the deprecation is a simple deletion of a class or replacement of the class by another class. The Qualification attribute may be used to indicate instances of the replacement class that can be recognized as instances of the deprecated class. The MappedClassID attribute is the class ID of the replacement class. The ApplicationName and ApplicationVersion attributes indicate the application that deprecated this class. The DeprecationPhase attribute indicates whether the class has been fully deprecated or is still in the process of being deprecated. The DeprecationStatus attribute indicates whether the class is a candidate for deprecation or has been deprecated.

In addition a new class may be added to the CMDB for attribute mapping information. In one embodiment the new class may have the following attributes a ClassMappingID b OriginalAttributeID c OperationType d NewAttributeID e ApplicationName f the ApplicationVersion g DeprecationStatus and h DefaultValue. In one embodiment one attribute may be mapped to only one attribute. In one embodiment an attribute mapping may only be done between attributes of the same data type.

The ClassMappingID attribute is a foreign key for this entry. The OriginalAttributeID attribute is the attribute ID of the deprecated attribute. The OperationType attribute indicates whether the deprecation is a simple deletion or a replacement. The MappedAttributeID attribute is the attribute ID of the new attribute that is replacing the deprecated attribute. The DefaultValue attribute is a default value of the replacement attribute if an instance of the deprecated classes moved. For example if the class J2EEApplicationServer is deprecated and the target class is ApplicationServer then there may be an attribute called AppServerType that may be set to J2EEAppServer by default when the instance of J2EEApplicationServer is moved to the ApplicationServer class. The ApplicationName and ApplicationVersion attributes indicate the application that deprecated this class. The DeprecationStatus attribute indicates whether the class is a candidate for deprecation or has been deprecated.

In addition to the mapping classes described above in one embodiment existing class properties and attribute properties may be extended to include the property IsDeprecated indicating whether the class or attribute has been deprecated.

In one embodiment the deprecation migration utility may be implemented in the Java programming language. is a flowchart illustrating an example technique for a deprecation migration utility according to one embodiment. In block the CMDB metadata cache may be loaded. In block the mappings of deprecated classes and attributes may be loaded. In block a list of classes to deprecate is identified and blocks through are performed for each class to be deprecated. In this embodiment the migration process may be divided into multiple phases. In block the utility may determine the phase of the deprecation for the CI. If it is at phase 1 then in block appropriately modify data structures of the replacement class. It is in phase 2 begin migrating the data in block . If it is in phase 3 appropriately modify the data structures of the deprecated class in block . If the phase indication is null indicating the deprecation process has not begun begin with block . Phase 1 is followed by phase 2 which is followed by phase 3. In some embodiments phases 2 and 3 may be performed in the opposite order.

Then in block the next class is determined and the above processing repeated for each class. In block the utility obtains a list of attributes to migrate from the mapping loaded in block . In block the attributes are marked as deprecated. In block the attribute data is migrated.

In one embodiment the deprecation utility is multithreaded with the number of threads configurable via a command line option allowing concurrent processing of multiple deprecations.

In block the join forms for the class and the subclasses may be renamed. In block a vendor form for the old class and the subclasses with all fields of the old form may be created. In block the workflow from the old forms may be copied into the forms. In block the deprecated class data may be migrated according to the mapping. After all of the data model changes for the deprecated classes are performed in block the old forms may be deleted and the new forms renamed to the original name of the original forms before marking the class as deprecated in block .

At some future time the deprecated classes and attributes may be deleted. In some embodiments the future upgrade to the CMDB also handles the deletion of the deprecated classes and attributes. The migration utility in one embodiment has a command line option to delete deprecated classes attributes.

Referring now to an example computer for use in deprecating object oriented data is illustrated in block diagram form. Example computer comprises a system unit which may be optionally connected to an input device or system e.g. keyboard mouse touch screen etc. and display . A program storage device PSD sometimes referred to as a hard disc is included with the system unit . Also included with system unit is a network interface for communication via a network with other computing and corporate infrastructure devices not shown . Network interface may be included within system unit or be external to system unit . In either case system unit will be communicatively coupled to network interface . Program storage device represents any form of non volatile storage including but not limited to all forms of optical and magnetic storage elements including solid state storage including removable media and may be included within system unit or be external to system unit . Program storage device may be used for storage of software to control system unit data for use by the computer or both.

System unit may be programmed to perform methods in accordance with this disclosure an example of which is in . System unit comprises a processor unit PU input output I O interface and memory . Processing unit may include any programmable controller device including for example one or more members of the Intel Core Pentium and Celeron processor families from the Intel and the Cortex and ARM processor families from ARM. INTEL CORE PENTIUM and CELERON are registered trademarks of the Intel Corporation. CORTEX is a registered trademark of the ARM Limited Corporation. ARM is a registered trademark of the ARM Limited Company. Memory may include one or more memory modules and comprise random access memory RAM read only memory ROM programmable read only memory PROM programmable read write memory and solid state memory. One of ordinary skill in the art will also recognize that PU may also include some internal memory including for example cache memory.

Various changes in the components as well as in the details of the illustrated operational method are possible without departing from the scope of the following claims. For instance the illustrative system of may be comprised of more than one computer communicatively coupled via a communication network wherein the computers may be mainframe computers minicomputers workstations or any combination of these. Such a network may be composed of one or more local area networks one or more wide area networks or a combination of local and wide area networks. In addition the networks may employ any desired communication protocol and further may be wired or wireless. In addition acts in accordance with and may be performed by a programmable control device executing instructions organized into one or more program modules. A programmable control device may be a single computer processor a special purpose processor e.g. a digital signal processor DSP a plurality of processors coupled by a communications link or a custom designed state machine. Custom designed state machines may be embodied in a hardware device such as an integrated circuit including but not limited to application specific integrated circuits ASICs or field programmable gate array FPGAs . Storage devices suitable for tangibly embodying program instructions include but are not limited to magnetic disks fixed floppy and removable and tape optical media such as CD ROMs and digital video disks DVDs and semiconductor memory devices such as Electrically Programmable Read Only Memory EPROM Electrically Erasable Programmable Read Only Memory EEPROM Programmable Gate Arrays and flash devices.

The above description is intended to be illustrative and not restrictive. For example the above described embodiments may be used in combination with each other. Many other embodiments will be apparent to those of skill in the art upon reviewing the above description. The scope of the invention therefore should be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled. In the appended claims the terms including and in which are used as the plain English equivalents of the respective terms comprising and wherein. 

