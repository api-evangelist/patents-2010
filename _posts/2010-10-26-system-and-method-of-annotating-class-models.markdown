---

title: System and method of annotating class models
abstract: In one embodiment the present invention includes a computer-implemented method of annotating software objects. The method includes storing rules that define how to annotate a software object. The method further includes processing the software object according to the rules. The method further includes generating an annotation document based on the software object having been processed according to the rules. The method further includes generating an annotated software object based on the software object and the annotation document. As a result, annotated software objects may be generated in a dynamic, non-intrusive manner.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08701087&OS=08701087&RS=08701087
owner: SAP AG
number: 08701087
owner_city: Walldorf
owner_country: DE
publication_date: 20101026
---
The present invention relates to object oriented programming and in particular to dynamic semantic annotation of objects.

Unless otherwise indicated herein the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.

One of the central requirements of system integration is the unambiguous exchange of information e.g. data objects in object oriented programming. A common way of establishing such an exchange is using semantic annotations of the objects exchanged. Current systems use extensible markup language XML or the resource description framework RDF combined with the web ontology language OWL for integration. While the former does not provide any information about the exchanged objects semantics the latter can only be applied if there exists a 1 1 mapping between a class model and an ontology.

More specifically system integration is a common software engineering task. Ontologies have been proposed for a long time as a means for providing interoperability between systems as they can serve as an inter lingua and an interchange format for information exchange. Practically this means that exchanged information is annotated with a commonly agreed upon ontology. That is based on annotations of the systems class models using a commonly agreed upon ontology referred to as the T Box object instances of those class models can be expressed as exchanged information referred to as A box instances of that ontology and be transmitted between systems in a semantically unambiguous way.

Since the paradigm of object oriented programming is predominant information exchange is implemented as an exchange of data objects in most cases. Thus using semantic annotations for information exchange boils down to annotating data objects.

Annotating objects means providing universally understandable information about the object e.g. a set of RDF statements referring to a commonly agreed upon ontology. There are a variety of approaches for producing such annotations which in most cases statically assign each class in the class model to a corresponding category in the ontology thus tacitly assuming that a 1 1 mapping between the class model and the ontology exists. Furthermore those approaches are most often implemented in an intrusive manner i.e. the class model s implementation needs to be adapted for adding semantic annotations. Three general types of approaches are generative approaches intrusive approaches and non intrusive approaches.

In generative approaches the class model is generated from the ontology with which the objects shall be annotated. Thus the degree of influence is very high. Generative approaches have a 1 1 mapping between the class model and the ontology.

Generative approaches are an appealing solution when building software from scratch. Once a domain ontology has been captured together with domain experts e.g. as a part of the specification it can be used to automatically generate part of the program code creating an ontology from program code is also possible although only rarely seen . Besides the savings in development efforts generative approaches ensure by definition that the ontology and the class model always match perfectly i.e. a 1 1 mapping between the class model and the ontology exists and that the ontology and the software do not run out of sync when the ontology is evolving over time given that the class model is regenerated after each change in the ontology .

Examples for generative approaches are the approach described by Voelkel and Sure in RDFReactor From Ontologies to Programmatic Data Access the approach described by Kalyanpur Pastor Battle and Padget in Automatic Mapping of OWL Ontologies into Java the approach described by Eberhart in Automatic Generation of Java SQL Based Ingerence Engines from RDF Schema and RuleML and the approach described by Parreiras Saatho Walter Franz and Staab in APIs gogo Automatic Generation of Ontology APIs . Other examples include the approach described by Oren Delbru Gerke Haller and Decker in ActiveRDF Object Oriented Semantic Web Programming as applied to Ruby and the approach described by Swartz in TRAMP Makes RDF look like Python Data Structures as applied to Python.

Intrusive approaches perform changes on the class model s implementation such as adding special attributes and or methods to the classes for providing annotations. Intrusive approaches may adapt the class model s implementation for adding semantic annotations.

Intrusive approaches do not generate new Java classes from an ontology but modify i.e. intrude into an existing class model by adding additional code fragments. Examples of intrusive approaches include the approach described by Story in Sommer Semantic Object Metadata Mapper the approach described by Reed in Semantic Annotation for Persistence the approach described by Alishevskikh in RDFBeans the approach described by Wagner Babi and Bednar in Java RDF Framework for Knowledge Repository and the approach described by Quasthoff and Meinel in Design Pattern for Object Triple Mapping . Most of those works are based on the foundation of mapping class models and databases described by Fowler in Patterns of Enterprise Application Architecture . Note that all those approaches require a 1 1 mapping between Java classes and concepts in the ontology.

Non intrusive approaches provide ways to annotate class models without modifying those class models e.g. by using mappings in a separate file or by dynamically registering classes with categories in the ontology at run time. A drawback of non intrusive approaches is often a larger coding effort as compared to running a code generator or adding a few Java annotations . Examples of non intrusive approaches include the ELMO approach described at and the approach described by Hillairet Bertrand and Lafaye in Bridging EMF applications and RDF data sources .

Most of the current approaches for semantic annotation of data objects suffer from two main defects a they only support static 1 1 mappings between class models and ontologies and b they are intrusive i.e. require changes to the class model for performing the annotation.

More specifically generative approaches may only be used when creating new software. In case of existing code for the class model they cannot be applied. Therefore they are not suitable for integration tasks dealing with legacy code.

Similarly intrusive approaches are suitable if a class model already exists or may be used when creating the class model from scratch e.g. in projects where the use of ontologies has not been foreseen from the beginning of the development they demand more discipline from the developers as they have to take care about the synchronicity of the class model and the ontology themselves.

These defects occur due to the different natures of class models and ontologies. Class models serve the purpose of creating a model which allows for efficient programming and results in efficiently executable code. In contrast ontologies serve the purpose of providing a clear formal conceptualization of a domain. 1 1 mappings would result in either cumbersome class models or in ontologies reflecting the shared conceptualization in a suboptimal manner. Hence the assumption of an exact 1 1 mapping see a above is an assumption which is not realistic.

Furthermore system integration most often deals with legacy systems that cannot or must not be altered be it for technical or legal reasons. These findings make it hard to apply current intrusive annotation approaches see b above to real world integration tasks.

An embodiment of the present invention implements a rule based approach for semantically annotating class models dynamically which can be implemented in a non intrusive way. This approach allows using pragmatic class models and comprehensive formal ontologies in parallel and thereby helps bridging the two worlds. In general an embodiment of the present invention uses rules based on XPath expressions for dynamic semantic annotation and allows using existing software systems in a non intrusive manner. Other embodiments may use a different syntax or language than XPath expressions for defining such rules.

In one embodiment the present invention includes a computer implemented method of annotating software objects. A software object is provided. The software object is an instance of a class in an object oriented computing environment. The software object may be generated by a software component that is executed by an application server. The method includes storing rules that define how to annotate the software object and that operate according to the class of the software object. The method further includes processing the software object according to the rules. An annotation engine component that is executed by the application server may process the software object according to the rules. The method further includes generating an annotation document based on the software object having been processed according to the rules. The annotation engine component may generate the annotation document. The method further includes generating an annotated software object based on the software object and the annotation document. The annotated software object corresponds to the software object as annotated by the annotation document. An application programming interface component that is executed by the application server may generate the annotated software object.

The method may be implemented by a computer program that is executed by a computer system. Alternatively a computer system may be configured to implement the method.

According to an embodiment the annotation engine component is configured to process the software object in a non intrusive manner with regard to the software component.

According to an embodiment the rules relate an ontology and a class model according to an arbitrary mapping. For example the employed rules and ontology comply to a consistent formal theory making up the basis for semantically annotating classes in a class model.

According to an embodiment the rules define how to create an annotation document the rules include categories and relations and the categories and relations relate to a domain ontology.

According to an embodiment the annotation engine component is configured to generate the annotation document in a dynamic manner.

An embodiment of the present invention may have one or more of the following features. First it works in cases where 1 1 mappings between class models and ontologies do not exist e.g. it operates according to an arbitrary mapping . Second it is non intrusive thus the underlying class model does not need to be changed. Third it is usable when dealing with software components that cannot be themselves altered to generate annotations.

The following detailed description and accompanying drawings provide a better understanding of the nature and advantages of the present invention.

Described herein are techniques for generating semantic annotations for objects. In the following description for purposes of explanation numerous examples and specific details are set forth in order to provide a thorough understanding of the present invention. It will be evident however to one skilled in the art that the present invention as defined by the claims may include some or all of the features in these examples alone or in combination with other features described below and may further include modifications and equivalents of the features and concepts described herein.

In this document various methods processes and procedures are detailed. Although particular steps may be described in a certain order such order is mainly for convenience and clarity. A particular step may be repeated more than once may occur before or after other steps even if those steps are otherwise described in another order and may occur in parallel with other steps. A second step is required to follow a first step only when the first step must be completed before the second step is begun. Such a situation will be specifically pointed out when not clear from the context.

In this document the terms and or and and or are used. Such terms are to be read as having the same meaning that is inclusively. For example A and B may mean at least the following both A and B only A only B at least both A and B . As another example A or B may mean at least the following only A only B both A and B at least both A and B . When an exclusive or is intended such will be specifically noted e.g. either A or B at most one of A and B .

An embodiment of the present invention is implemented in an object oriented programming environment. In the following description the term object oriented programming is to be understood to refer not to a generic type of programming but instead to a specific type of programming. In general object oriented programming is a programming paradigm that uses objects to design applications and computer programs. An object oriented program may thus be viewed as a collection of interacting objects as opposed to a non object oriented programming model in which a program is seen as a list of tasks subroutines to perform. In general the teachings of the present invention are applicable to structured compound data types such as RECORD in Pascal or STRUCT in C C both of which may also be used in non object oriented programming environments.

An embodiment of the present invention uses objects. In the following description the term object is to be understood to refer not to a generic data file that is an input to an output of or used by a computer program but instead to a specific type of data structure in an object oriented programming environment. In general an object is a data structure consisting of data fields and methods together with their interactions. An object is a discrete bundle of functions and procedures often relating to a particular real world concept. Other pieces of software can access the object only by calling its functions and procedures that have been allowed to be called by outsiders. Each object is capable of receiving messages processing data and sending messages to other objects. Each object can be viewed as an independent machine with a distinct role or responsibility. The actions or methods on these objects are closely associated with the object. For example the data structures tend to carry their own operators around with them or at least inherit them from a similar object or class . This inheritance may be contrasted with a non object oriented programming model in which the data and operations on the data do not have a tight formal association. 

An embodiment of the present invention uses classes. In the following description the term class is to be understood to refer not to a generic data file that is an input to an output of or used by a computer program but instead to a specific type of data structure in an object oriented programming environment. In general a class is template for an object. A class defines the abstract characteristics of the object including its characteristics its attributes fields or properties and the object s behaviors the things it can do or methods operations or features . Classes provide modularity and structure in an object oriented computer program.

An embodiment of the present invention uses instances. In the following description the term instance is to be understood to refer not to a generic data file that is an input to an output of or used by a computer program but instead to a specific type of data structure in an object oriented programming environment. In general an instance is an actual object created at run time of a particular class. The set of values of the attributes of the instance is called its state. The instance includes its state and its behavior as defined in the object s class or classes .

An embodiment of the present invention uses software components. In the following description the term software component is to be understood to refer not to a generic computer program but instead to a computer program in an object oriented programming environment that instantiates objects. A software component may also receive e.g. as an input an object that was instantiated by another software component.

As discussed above many existing systems for semantic annotation of objects assume a 1 1 mapping between class models and ontologies. Reality however often tells a different story.

Class models and ontologies are different by nature. An ontology claims to be a generic commonly agreed upon specification of a conceptualization of a domain with a focus on precisely capturing the semantics of terms used in a domain. A class model in turn is task specific with the focus on an efficient implementation of an application for solving tasks in the modeled domain. Thus a software engineer would rather trade off precision for a simple efficient model while an ontology engineer would trade off simplicity for a precise representation. Another difference is that in software engineering models are most often prescriptive models which are used to specify how a system is supposed to behave while ontologies are rather descriptive models which describe how the world is. Furthermore an ontology only captures the real world domain while a class model mixes information about the real world domain and the software system.

Due to those differences one often faces the situation where class models and ontologies are incompatible in the sense that a 1 1 mapping does not exist. Enforcing a 1 1 mapping would either result in cumbersome class models or in sub optimal ontologies since the shared conceptualization they are supposed to reflect would be based on concepts only existing in the IT system domain hence hardly reflecting the conceptualization of a domain expert. Therefore conventional annotation approaches relying on such a mapping do not work in most cases which means that they can only be employed when either the class model is adapted to the ontology or vice versa. As this is a desired solution only in rare cases such incompatibilities create a large hurdle for applying semantic web technology e.g. for application integration in practice.

Also as discussed above it is observed that most current approaches for annotating class models are intrusive i.e. they require altering the class model which is also problematic when applying those approaches to real world settings. When integrating systems the implementation of the components to be integrated cannot or must not be changed in many cases e.g. if they are only available as binary code created by a code generator which cannot be adapted or if license agreements forbid changes to the code. Thus intrusive implementations are often not practicable. This also holds for generative implementations which cannot be applied when integrating existing applications.

As detailed below an embodiment of the present invention addresses these two issues and implements an approach for semantically annotating class models. This implementation is dynamic i.e. it does not rely on static 1 1 mappings between the class model and the ontology used for annotation and it is non intrusive i.e. it can be implemented without having to change the class model to annotate. Instead of using static links between the class model and the ontology the implementation uses rules which are dynamically evaluated at run time for producing object annotations.

An embodiment of the present invention relates to direct models where the classes dealt with are related to categories in the ontology rather than to constructs of an ontology language. The embodiment may relate to a Java implementation in which case the class is a Java class. Other embodiments may involve other object oriented programming languages.

As mentioned above an embodiment of the present invention relates to a non intrusive way of annotating objects. Non intrusive approaches do not require any changes on the class model and thus can be applied when the developer cannot or must not change the class model be it for technical or for legal reasons. Non intrusive approaches provide means for annotating class models without modifying those class models e.g. by using mappings in a separate file or by dynamically registering classes with categories in the ontology at run time. The drawback of non intrusive approaches is often a larger coding effort compared to running a code generator adding a few Java annotations which are Java language constructs that may carry arbitrary meta data or using semantic annotations . In general intrusive mechanisms may be implemented by Java annotations by adding additional variables by adding additional methods or by renaming classes variables or methods according to specific naming conventions. In contrast non intrusive mechanisms may use run time registration.

First are described in order to provide a general overview of an embodiment of the present invention. Then further details and various examples are described in .

The system includes an annotation engine component a rules storage component and an ontology enabled application programming interface API component . The system interfaces with a software component . In general the software component generates an object and the system generates an annotated object .

The annotation engine component in general generates an annotation as appropriate for the object . The annotation engine component includes a rule engine component an object inspector component a resource identifier factory component and an annotation writer component . The annotation engine component interfaces with the rules storage component . The rules storage component in general stores rules . The rules refer to a domain ontology . The ontology enabled API component in general interfaces between the software component to receive the object and the annotation engine component to receive the annotation and to generate the annotated object .

The rule engine component in general generates a set of RDF triples from the head of a particular rule when the body of the particular rule is met by the software object. Specific examples of RDF triples can be seen in .

The object inspector component in general tests the object according to a condition or reads data from it according to an expression to obtain a result. The conditions and expressions used to test the object and read data from it are contained in the rules .

The resource identifier factory component in general creates a resource identifier for the object . The resource identifier is unique to and is unambiguous for the object .

The annotation writer component in general generates the annotation based on the result of the expression in the rules applied to the object .

The software component includes business logic object instances and a component API . The business logic controls the operation of the software component for example to create and to manipulate the object instances . The object instances are instances of objects that the software component creates or receives from other software components including the object . The component API interfaces between the software component and other software components for example for the input and output of objects.

At rules are stored that define how to annotate software objects. The rules operate according to the respective classes of the software objects. For example the rules storage component see may store the rules .

At a software object is provided. The software object is an instance of a particular class. The software object may be generated by a program executed by the application server or may be provided to the application server by another program. For example the software component see may generate the object .

At the software object is processed according to the rules. For example the annotation engine component see may process the object according to the rules .

At an annotation document is generated based on the software object having been processed see according to the rules. For example the annotation engine component see may generate the annotation based on the object having been processed according to the rules .

At an annotated software object is generated based on the software object and the annotation document. The annotated software object corresponds to the software object as annotated by the annotation document. For example the ontology enabled API component see may generate the annotated object based on the object and the annotation .

As an initial step the rules may be registered. For example the annotation engine component see may register the rules . For example the rules engine may register the rules so that the rules are on hand for processing the object . Alternatively the rules engine may refer to the rules in the rules storage when processing the object .

The method may include one or more substeps or additional steps that implement the functionality of the other components described above for the system e.g. the specific functionality of the rule engine component .

The embodiment of or can be implemented by an application server in a three tier hierarchy. In general a three tier hierarchy includes a presentation tier an application tier and a database tier. Each tier may be implemented by one or more computers or servers e.g. an application server in the application tier. The application server may implement the annotation engine the software component the ontology enabled API or other components. The application server can be the computer system see . The rules storage may be implemented by a database server in the database tier. The database server may also store the object instances the annotated objects or other data or data structures. The database server can be the server see . The presentation tier may implement a user interface for the user to interact with the system e.g. to create or edit the rules to interact with the object or to interact with the annotated object . The presentation tier may be implemented by the client see .

Further details regarding the features and operation of an embodiment of the present invention are provided below in the sections Further Details Examples and Details Regarding Dynamic Semantic Annotation .

As discussed above the system implements dynamic semantic annotation in a non intrusive manner. For example the software component may be regarded as a black box that accepts certain inputs and that generates certain outputs but without any further requirements or knowledge concerning its details or detailed operation. In summary the system operates as follows. As a preparing step the rules are registered at the annotation engine component . When an object is retrieved from the component s API it is sent to the annotation engine which returns the annotation for the object . The ontology enabled API provides the annotated object for information exchange.

More specifically at run time objects are instantiated in each component. For example consider the objects instantiated as the instantiated objects by the component . When the object leaves the component via the API e.g. when a message containing an object is sent out by the component or when a user queries the component for a set of its objects the object is to be annotated so it can be processed e.g. by a reasoner or by another component. Therefore the annotation engine component hides the original API behind the ontology enabled API also referred to as a fa ade which forwards the object from the component augmented with the annotation as the annotated object . To this end it passes the object to the annotation engine component which returns the annotation in the form of an RDF document that describes the object according to the common domain ontology . This RDF document is then attached to the object so the object is semantically annotated as the annotated object .

For each component a set of annotation rules is stored. The rules define how to create the annotation for objects of a certain class. The categories and relations referred to in those rules are defined in the common domain ontology which is used for annotation.

As described in the annotation engine includes four integral parts the rule engine component that processes the annotation rules the object inspector component that performs tests on the object to be annotated the resource identifier factory component that creates unique and unambiguous URIs for objects and the annotation writer component that creates the annotation document for the object based on the outcome of evaluation the rules.

The rule engine component evaluates the bodies of the rules e.g. XPath expressions according to an embodiment. To that end it makes use of the object inspector component which can perform tests on the object to get the results of such an XPath expression. An embodiment of the rule engine component may use JXPath which directly process XPath expressions on Java objects using Java s reflection API. If a rule s body is fulfilled the corresponding triples from the head are generated which in most cases requires more calls to the object inspector component for filling in the variable parts.

Each rule evaluation returns a set of triples. Those sets may be unified which may involve the renaming of blank nodes as discussed below to an RDF document which is then returned to the ontology enabled API . This step is performed by the annotation writer component .

As a result each component is encapsulated by the ontology enabled API with which annotated objects can be obtained from all integrated components. This ontology enabled API can be used for various purposes such as establishing a message exchange between components using annotated objects or building a SPARQL SPARQL Protocol and RDF Query Language endpoint for reasoning on objects contained in the various components. It thus performs a useful function for system integration.

An embodiment of the present invention may have one or more of the following features. First the software component may generate the object such that the object lacks annotation thus the system adds the annotation to generate the annotated object . Alternatively the software component may generate the object such that the object has an interim annotation in which case the system replaces the interim annotation with the annotation or adds it as an additional annotation to the interim annotation. The whole system may also be regarded as an embodiment of the software component thus several layers of annotations may be stacked.

Second the annotation engine component may process the object in a non intrusive manner with regard to the software component . Thus the annotation engine component may operate with legacy software components that cannot be modified technically or legally or that would be difficult to modify in order for the software component to generate annotated objects on its own.

Third the system may implement the rules such that they relate an ontology and a class model in a manner other than a 1 1 mapping. This relationship may also be called an arbitrary mapping.

Fourth the rules define how to create the annotation document and the rules may include categories and relations as specified in the ontology. The categories and the relations relate to the domain ontology .

Fifth the annotation engine component may generate the annotation document in a dynamic manner. This operation may be contrasted with many existing systems that use a static 1 1 mapping.

Classes in a programming model may be used for representing information about different things. Consider which shows an excerpt from a class model an excerpt from an ontology and a set of exemplary desired RDF triples to be used for annotation. The class model shows the name of the class in its upper part and the attributes of the class in its lower part using the UML notation. The ontology shows categories as ellipses data attributes as rectangles subcategory relations as arrows with empty heads and other relations as arrows with filled heads. Each of the RDF triples is an expression in the form of subject predicate object in which the subject denotes the resource and the predicate denotes traits or aspects of the resource and expresses a relationship between the subject and the object. For example the RDF triples convey the following information in English p0 is a man who has the name Peter .

In one class Person is used for representing instances of both categories Man and Woman distinguished by an attribute. Actual category membership may be decided based on a flag. Although this class can be mapped to the Person category in the ontology information is lost this way. A static mapping approach cannot evaluate the sex attribute at run time and decide upon its value which annotation to produce since the mapping is statically defined at design time. In contrast an embodiment of the present invention is capable of generating a mapping that addresses this example.

For example one of the rules could state that for each object of type Person whose sex attribute has the value MALE a triple identifier rdf type Man should be produced. As the rule engine processes that rule the object inspector reads the value of the object s sex attribute and if the condition equates to true the corresponding triple is generated using the resource identifier factory component for obtaining a unique identifier for the object. The resulting triple is passed to the annotation writer component to be added to the object s annotation. When all rules have been processed the annotation writer unifies their results to an annotation and passes it to the ontology enabled API which produces the annotated object from the object and the annotation . This process is described in more detail below the remainder of the examples. 

A special case of multi purpose classes are artificial classes The class model may also contain classes that do not have any corresponding category in the shared conceptualization and therefore not in the ontology either. One example is shown in in which an AdditionalData class is used for storing information both about a person s email address and social security number. Similar to shows an excerpt from a class model an excerpt from an ontology and a set of exemplary desired RDF triples to be used for annotation. While such a class may be useful for the developer rigid ontology engineering would avoid categories such as AdditionalData . Thus objects of that class must be annotated with different ontological categories. A static mapping approach cannot process this example in contrast an embodiment of the present invention is capable of generating a mapping that addresses this example.

Similarly to using one class for several ontological categories one relation or attribute in the class model may have different corresponding relations in the ontology. shows an excerpt from a class model an excerpt from an ontology and a set of exemplary desired

RDF triples to be used for annotation. In the example shown in an additional flag attribute is used to determine whether the value of the contactData attribute denotes a phone number a fax number or an email address. In the class model only one type of contact information is stored per person. Note that the enumeration ContactType does not have any corresponding category in the ontology . A static mapping approach cannot process this example in contrast an embodiment of the present invention is capable of generating a mapping that addresses this example.

In worse cases there might even be no flag attributes determining the actual representation but only background knowledge held by the developer who uses the class model as shown in . Similar to shows an excerpt from a class model an excerpt from an ontology and a set of exemplary desired RDF triples to be used for annotation. In this example the same attribute contactData is used to hold information about the phone number and email address and the program logic distinguishes both cases based on whether the attribute value contains an symbol. A static mapping approach cannot process this example in contrast an embodiment of the present invention is capable of generating a mapping that addresses this example.

For reasons of simplicity shortcuts are often used in a class model. Such shortcuts may skip some categories when traversing a chain of object relations and move attributes to other categories than in a precise ontology. shows an excerpt from a class model an excerpt from an ontology and a set of exemplary desired RDF triples to be used for annotation. shows that the Person class in stores a postal code attribute containing the postal code of the city the person lives in but there is no direct relation in the ontology since in a precise formalization persons do not have postal codes by nature in the ontology Person and Postal Code are interconnected via the City concept which is omitted in the class model by using a shortcut. Thus the attribute cannot be directly mapped to one relation in the ontology but rather to a chain of relations. A static mapping approach cannot process this example in contrast an embodiment of the present invention is capable of generating a mapping that addresses this example.

As shown in such shortcuts may also comprise combined chains of object and inheritance relations. In this example the classes Professor and Student are modeled as subclasses of Person in the class model while in the ontology they are modeled as roles a person can have a typical difference between ontological and object oriented modeling. In that case the person and her role become mixed in the class model i.e. attributes assigned to the Role concept in the ontology become attributes of the person. The RDF triples result. A static mapping approach cannot process this example in contrast an embodiment of the present invention is capable of generating a mapping that addresses this example.

Data attributes may often contain non atomic values such as a name attribute storing both first and last name or even worse from an ontologically precise point of view also an academic degree dates consisting of a day a month and a year and so on. Phone numbers are also non atomic as they consist of a country and an area code a number and an extension. illustrates the issues related to non atomic values. shows an excerpt from a class model an excerpt from an ontology and a set of exemplary desired RDF triples to be used for annotation. Note that from the values contained in the non atomic data types of the class model several RDF triples have to be generated. A static mapping approach cannot process the date case in this example in contrast an embodiment of the present invention is capable of generating a mapping that addresses the date case in this example. More specifically various rules may be created for parsing various date formats into the correct values for day month and year.

As the examples above illustrate a static approach relying on a 1 1 mapping from classes and attributes to ontology concepts does not fit. In contrast an embodiment of the present invention uses dynamic semantic annotation to transfer objects from an arbitrary class model into instance data of a given ontology.

In contrast to a static approach that defines the semantic annotation of an object at the class level at design time e.g. saying that each object of a class C gets the same annotation or that each object instance carries the same meaning an embodiment performs a dynamic annotation that is able to inspect the object at runtime and to produce an annotation based on that inspection. An embodiment uses rules for defining which object should get which annotation. Furthermore the triples generated as a semantic annotation may have dependent values which can also be calculated e.g. by using regular or arithmetic expressions.

According to an embodiment the rules have a body and a head in the following format. The body consists of a test to be performed on an object. The head is a set of RDF triples each consisting of a subject a predicate and an object all three of which may depend on the object to annotate. For expressing tests and dependent values an embodiment uses XPath which may be not only be used to query XML documents but also Java objects. If the test is evaluated positively one or more triples are generated consisting of a subject predicate and object. The subject predicate and object may be either constants or XPath expressions as well. Thus the syntax of the rules looks as follows using the extended Backus Naur form Rule XPathExpr Triple Triple . 1 Triple 3 Constant XPathExpr 2 

In this syntax Constant denotes an arbitrary sequence of characters enclosed in quotation marks and XPathExpr denotes an XPath expression following the XPath standard enhanced by the following three extensions. First the function uri assigns a unique URI to a Java object. Second the function regex String called on a Java attribute evaluates a regular expression on that object and yields true if the regular expression matches the attribute value false otherwise. Third the symbol used in the head refers to the result of the XPath test performed in the body.

An example rule creating part of a semantic annotation for a Person object with an address attribute may look as follows address uri uri . 3 

For a person object p with the unique URI hxxp foo.bar p0 the rule would be evaluated by retrieving the value of p.address in Java this typically means calling a getter function . Assuming the result is an address object with the URI hxxp foo.bar a0 the body is evaluated for generating the corresponding triple which results in calling the uri function on the object p producing the constant and calling the uri function on the address object identified with the XPath expression of the rule s body which is referenced by using the symbol . Thus the following triple is generated as an annotation given hxxp foo.bar is the default namespace .

Testing attribute values identified by an XPath expression allows for generating triples only if a certain condition is fulfilled. This helps solving the problem of multi purpose classes sex MALE uri . 4 

According to the XPath syntax terms in brackets define tests. The corresponding element is only selected in case that the test is evaluated to true. Rule 4 thus only fires if the value of the attribute sex has the value MALE .

Multi purpose relations can be handled the same way. If implicit knowledge is involved e.g. for telling an email address from a phone number as shown in additional tests with regular expressions may be used to make that knowledge explicit address regex . . uri . 5 address regex uri . 6 

Rule 5 fires if the value of the inspected object s address attribute contains an symbol and then produces the corresponding annotation. Rule 6 fires in the opposite case.

Artificial classes as shown in can also be handled by adding additional triples to the semantic annotation addtlData email uri . 7 addtlData SSN uri . 8 

Like in the examples above the rules bodies are fulfilled if the respective attribute of the artificial class exists. If e.g. the AdditionalData object has the email attribute set a respective triple is added to the Person object s semantic annotation.

Shortcuts as shown in and may be handled by inserting blank nodes indicated by an underscore postal code uri   city   city . 9 

When the head of rule 9 is evaluated two statements are generated which are interconnected via one blank node   city denoting a city that is known to exist but not further specified. When the results of multiple rule heads are merged each rule s result is treated like a separate RDF document thus the blank nodes IDs are renamed to remain unique throughout the merged annotation. Accordingly the developer of annotation rules has to assure unique names for blank nodes only within one rule but not across different rules.

Dealing with non atomic data types as shown in is a more difficult task. In cases where the background knowledge may be formalized e.g. separating a street name from a house number regular expressions can be used for implementing dynamic annotation. However there are numerous cases which cannot be formalized that easily. One typical case is splitting a name into a first name and a last name even with massive domain knowledge it is practically impossible to formulate a rule which treats all names in every language correctly. This case demonstrates the limitations of automatically annotating objects. Note that this limitation is not a limitation of an embodiment of the present invention but a limitation that is due to the fact that some kind of background knowledge can hardly be completely formalized.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT or liquid crystal display LCD for displaying information to a computer user. An input device such as a keyboard and or mouse is coupled to bus for communicating information and command selections from the user to processor . The combination of these components allows the user to communicate with the system. In some systems bus may be divided into multiple specialized buses.

Computer system also includes a network interface coupled with bus . Network interface may provide two way data communication between computer system and the local network . The network interface may be a digital subscriber line DSL or a modem to provide data communication connection over a telephone line for example. Another example of the network interface is a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links is also another example. In any such implementation network interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Computer system can send and receive information including messages or other interface actions through the network interface to an Intranet or the Internet . In the Internet example software components or services may reside on multiple different computer systems or servers and across the network. A server may transmit actions or messages from one component through Internet local network and network interface to a component on computer system .

The computer system and network may be configured in a client server manner. For example the computer system may implement a server. The client may include components similar to those of the computer system .

More specifically the client may implement a client side interface for displaying information generated by the server for example via HTML or HTTP data exchanges. The computer system may implement the system as part of implementing an application server for example by executing one or more computer programs. For example the storage device may implement the rules storage . The processor may implement the functionality of the annotation engine component or the method . The client may implement a graphical user interface for interacting with the system . Further note that the software component and the annotation engine component may be implemented by different servers e.g. the server may implement the software component and the server may implement the annotation engine component .

Ontologies may be used for information system integration. To that end the integrated systems need to exchange information e.g. in the form of semantically annotated data objects. Current approaches for annotating data objects are often static i.e. they assume a 1 1 mapping between the class model and the ontology used for annotation and intrusive i.e. they require changes to the class model. Both assumptions are often not met by real world integration scenarios. Due to the fact that class models and ontologies serve different purposes a 1 1 mapping most often does not exist otherwise the ontology would be rather weak or the class model would be too complex. Furthermore class models often cannot or must not be changed be it for technical or for legal reasons. Thus a more sophisticated mechanism for annotating objects is required.

A number of typical mismatches between class models and ontologies have been discussed above. To cope with such mismatches an embodiment implements dynamic semantic annotation which instead of hard wiring classes from a class model to ontological categories uses rules and run time inspection of objects to create annotations for objects. An embodiment implements such a dynamic annotation approach in a non intrusive way i.e. without changing the original class model.

Reasoners operating on the objects of a software component may use such RDF annotations e.g. by regarding them as an triple store and answer queries about the objects inside the software component. An embodiment may be integrated with other systems such as that described in Heiko Paulheim Efficient Semantic Event Processing Lessons Learned in User Interface Integration Volume 6089 of LNCS at 60 74 Springer 2010 describing an architecture for application integration which pulls instance data dynamically into a reasoner s A box for efficient reasoning using so called A box connectors . An embodiment may be integrated with such a system by wiring the reasoner s A box connectors to the component s annotation engine. This allows for reasoning on a component s objects based on an ontology even if that ontology is not reflected in the design of the software component s class model.

In sum an embodiment implements the automatic generation of RDF annotations from Java objects and uses these annotations for message exchange between components.

The above description illustrates various embodiments of the present invention along with examples of how aspects of the present invention may be implemented. The above examples and embodiments should not be deemed to be the only embodiments and are presented to illustrate the flexibility and advantages of the present invention as defined by the following claims. Based on the above disclosure and the following claims other arrangements embodiments implementations and equivalents will be evident to those skilled in the art and may be employed without departing from the spirit and scope of the invention as defined by the claims.

