---

title: Visualizing query results in stream processing systems
abstract: In a method for visualizing query results in stream processing systems, a visualization service receives a query from a client to visualize data in a stream processing application. The query is sent from the visualization service to a query-able operator of the stream processing application. At the query-able operator, an operation is performed using history data in the query-able operator to produce a first result that satisfies the query and the first result is sent to the visualization service. At the query-able operator, another operation is performed using new data received by the query-able operator to produce a second result that satisfies the query and the second result is sent to the visualization service. The first and second results are output from the visualization service to the client.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08290939&OS=08290939&RS=08290939
owner: International Busines Machines Corporation
number: 08290939
owner_city: Armonk
owner_country: US
publication_date: 20100630
---
This application claims the benefit of U.S. Provisional Application No. 61 351 666 filed Jun. 4 2010 the disclosure of which is incorporated by reference herein in its entirety.

This invention was made with Government support under Contract No. H98230 07 C 0383 awarded by the U.S. Department of Defense. The Government has certain rights in this invention.

The present invention relates to stream processing and more particularly to processing new visualization queries for data within a running stream processing system.

Stream processing is a technique to achieve high performance computing in a distributed system consisting of multiple computers. Stream based applications include market data feed processing and electronic trading network and infrastructure monitoring fraud detection and command and control in military environments. A stream processing application comprises a graph of stream processing operators where nodes of the graph represent operators performing tasks and directed edges of the graph represent data flowing between operators. A stream processing operator may be nothing more than a piece of code that produces a data value at its output every time it is given a data value at its input. Streaming data is usually organized as sequences of tuples flowing asynchronously from operator to operator. A tuple is a list of values with the same or different types. During its lifetime a stream processing application is usually automated without any human interaction.

The flow graphs of most stream processing applications are acyclic. A stream processing application receives external data such as stored raw data collected in advance or real time data from sensors through source operators and sends results through sink operators to storage spaces such as files and databases or other applications such as visualization tools.

Stream processing results are generally very large and generated in high speed. The results for example the internal states accumulated by a stream processing application consist of a sequence of values of the same type or a sequence of tuples. To query and or visualize a data stream existing solutions store data streams in databases or other kinds of physical storage spaces. Client applications are then used to query the database to retrieve stored data streams of interest and visualize them.

For high performance stream processing it is generally not possible to store all data because the states can change in a rate that is higher than what the mass storage can handle and the total amount of data may exceed the existing storage space if a task runs for a long time. In addition multiple client applications may want to visualize different data streams simultaneously which further increases the load of the mass storage. Other reasons for not storing internal states may include complicated data structures and on line processing requirements as well as a demand for low latency.

Exemplary embodiments of the present invention provide a method and computer program product for visualizing query results in stream processing systems.

In the method a visualization service receives a query from a client to visualize data in a stream processing application. The query is sent from the visualization service to a query able operator of the stream processing application. At the query able operator an operation is performed using history data in the query able operator to produce a first result that satisfies the query and the first result is sent to the visualization service. At the query able operator another operation is performed using new data received by the query able operator to produce a second result that satisfies the query and the second result is sent to the visualization service. The first and second results are output from the visualization service to the client.

In accordance with an exemplary embodiment of the present invention there are provided new stream processing operators that can receive queries from users in addition to ordinary data streams from other operators or external data sources. These operators store dynamic application states in memory. After a query is received by such a query able operator historical data is checked and selected results are sent to the output immediately. Then the query is stored within this operator as a standing query. Any new data from the input data streams or updates of operator states will be checked against the set of standing queries for updating the query results. Consequently after sending a query to such a query able operator with very short latency a visualization tool can show not only historical data but also continuous real time updates throughout the entire lifetime of the standing query.

Each query may have a globally unique query identifier id to support multiple query sessions and or multiple users. A routing service can route a query result tuple to the visualization tool that initiates the corresponding query. For web based visualization services this routing service may be implemented by a web server. Since query operations are performed within stream processing operators and no application specific data filtering operation is needed on the visualization side the visualization tool is reusable from application to application allowing developers to focus on development in a single stream processing platform.

In short the present invention introduces human interaction to a stream processing flow allowing users to interactively choose a subset of information or states accumulated in the stream processing flow for visualization. Effectively the present invention allows humans to be actively integrated into a stream processing flow as a component making the entire application flow a close looped system.

Visualization service applies aspects of the present invention as described with reference to . For example flow graph may be an application that processes streams of data that are produced by sensors in an automobile highway network where the data sources may be cars that cross sensors the state of traffic lights weather conditions on the roads etc. In this example each operator would perform a function on the steam of data such as aggregating inputs from all the sensors on a particular road determining if any particular road is above a defined level of congestion etc.

In operation flow graph may be compiled into a stream processing application that may be run on a computing environment that is capable of executing a realtime stream processing platform such as InfoSphere Streams previously known as System S offered by International Business Machines Corporation Armonk N.Y. Details regarding InfoSphere Streams are provided in various IBM publications including for example a publication entitled IBM InfoSphere Streams Redefining Real Time Analytics by Roger Rea and Krishna Mamidipaka published February 2010. The InfoSphere Streams platform uses a high level programming language referred to as the Stream Processing Language SPL formerly known as SPADE . SPADE is described in SPADE System S Declarative Stream Processing Engine Gedik et al. SIGMOD Jun. 9 12 2008 pp. 1123 1134. Further details regarding SPL are described in an IBM Research Report entitled SPL Stream Processing Language Specification Hirzel et al. RC24897 W0911 044 Nov. 5 2009. InfoSphere Streams and the Stream Processing Language support distributed data stream processing applications that can span a number of computing nodes. The Stream Processing Language declarative language is used in one example to program these multi operator applications. Stream Processing Language s stream centric design implies a language where the basic building block is a stream. Stream Processing Language s operator based programming is focused on designing the application around the smallest possible building blocks necessary to deliver the computation an application is designed to perform.

As shown in the query able operators each receive a query stream from a query routing operator which in turn receives queries from the visualization service . The query routing operator is a stream processing operator that locates the query able operator s according to the query parameters and the operator id s specified in a received query tuple and forwards the query to one or more query able operators. The output streams of these operators are sent to the visualization service through the sink operators . The visualization service is used by multiple clients and possibly by multiple users.

A visualization client may be software that has the following capabilities three dimensional 3D viewer graph generator etc. For web based visualization tools the visualization service runs within a web server whereas the visualization clients run inside browsers. The web server is a standalone program that usually supports modules and or plugins for example and the visualization service can run as a module within this web server. Alternatively we can consider the web server as a supporting library for the visualization service. Considered as a single piece the web service and the visualization service constitute a standalone program communicating with other programs of the stream processing application.

The visualization service includes a query service that is responsible for forwarding visualization requests from the visualization clients to the query able operators through the query routing operator. This component also records the query in a routing table for standing queries. The visualization service also includes a data i.e. query results routing service that is responsible for forwarding visualization data received from stream processing operators to the visualization client that has initiated the corresponding query according to the records in the routing table .

A procedure of processing a query in accordance with an exemplary embodiment of the present invention is as follows.

A user sends a query to the visualization service by operating a visualization client through an input device such as a keyboard or mouse . Continuing the example above of a stream processing application for steaming data from an automobile highway the user may send a query requesting a display of road blocks in a highway network that have more than x cars in the previous 60 seconds. The visualization service sends a query tuple to the query routing operator and logs its query id into the routing table . The query routing operator broadcasts the query to one a subset of or all of the query able operators . In the example above the query may be sent to operators that aggregate the numbers of cars on a block of each road. An optional query type or operator id can be used to decide to which operators the query will be sent. The query able operators perform the query against historical data and send query results to the sink operators . The query able operators store the query as a standing query and send subsequent updates as new data come in from upstream operators e.g. operators to the left of the query able operators . The query results and updates contain the original query id. The sink operators then forward query results to the visualization service . The visualization service uses the query id in the received query tuple to find in its routing table the client who sent this query and re routes the data to the client . This procedure will also be described with reference to .

To better manage the lifetime of the standing queries the query able operators maintain an expiration time for each query. The expiration time of a standing query is its timestamp plus a global timeout value. Alternatively the client can provide a different timeout value for each query through a timeout attribute in the query tuple. When a query is added to the set of standing queries its timestamp is updated with the current time. Expired standing queries are deleted. Optionally a query tuple may also contain an additional special new delete extend attribute enabling the following special operations 

 a Delete a standing query. A client can send a special query with this attribute set to delete to remove its previous query of the same query id from the set of standing queries in the query able operators 

 b Extending the timeout. A client can send a special query with this attribute set to extend to update the timestamp of the standing query with the same query id and then the expiration time of this standing query is extended.

The query able operator accepts two input streams a single data stream for input data tuples and a single query stream for input query tuples . The query able operator stores a finite history of data. The data history can be stored in data structures such as a global first in first out FIFO queue or in multiple separate FIFO queues each for a single group. In a typical example of the multiple group case each group has an associated group id and a data tuple received from the data stream is appended only to the queue whose group id equals a data key attribute in the tuple. In this case the data key is considered as part of query parameters. A query received from the query stream of a query able operator is stored in a list of standing queries. Effectively in this example the query able operator is a join between a data window the history and a dynamic set standing queries .

In general for performance reasons the query received in a query tuple contains only a set of parameters. It is better not to include code that needs to be interpreted or compiled the query algorithms themselves can be implemented within the query able operators. However a query able operator is free to allow anything it can handle in the query tuple as query parameters from some simple expressions as constraints or code written in a full fledged query language.

A query tuple may have the following attributes 1 a globally unique query id 2 query parameters such as a data key 3 a new delete extend attribute and or a timeout attribute or 4 an attribute to store an operator id or a set of operator ids if two of more query able operators are used in the same application flow.

In the example shown in upon receiving a non special query tuple the query able operator extracts the group key value and outputs all historical data tuples with the same group key value. The query id and the operator id if any is added to the output as an additional attribute. Then the query tuple is stored in the set of standing queries. When a new data tuple is received it is stored in the data queue and is compared against all standing queries. If the data tuple matches one of the standing queries this data tuple is sent to the output immediately with the query id and the operator id if any attached. If the input data tuple matches two or more standing queries it is replicated to the output for each standing query. Alternatively to save communication bandwidth the entire set of matching query ids can be attached to a single data output to avoid duplication. Further to show only data from a single group at a time the query received from the query stream of the query able operator contains the group key of the data group to be visualized. Therefore each output tuple of the query able operator contains a query id a group key and data retrieved from the data queues.

The removal of out dated data tuples in the query able operator may follow the FIFO order whereas the queries in the dynamic set are removed by the timeout mechanism and special delete and extend queries. The removal of queries in the query able operator may not follow a FIFO order.

The query service sends a tuple . . . to the query routing operator . In other words submit the query with queried data key and list of operators expected to generate result streams oid oidN to the query routing operator. The address of the query routing operator and the ids of the query able operators . . . are found in a query routing table e.g. the standing query routing table of the visualization service and the query id is uniquely generated by the visualization service. This query then becomes a standing query and its query id and the client session id are stored in the data results routing table and shared with a data results routing service.

After query able operators not shown receive the queries from the query routing operator they continuously send query results to including both historical and real time data to sink operators and the sink operators forward these tuples to the visualization service . As shown a result tuple contains the query id an operator id if multiple query able operator ids are used and query results.

After receiving the result tuples the results routing service finds the client session id from the routing table and re routes data e.g. to the correct client session i.e. the client that initiated the query . In other words it finds an appropriate standing query instance according to the tuple s and and routes the data to the visualization client who initiated this standing query.

An implementation of an exemplary embodiment of the present invention may make use of software running on a general purpose computer or workstation. With reference to such an implementation might employ for example a processor a memory and an input and or output interface formed for example by a display and a keyboard .

The term processor as used herein is intended to include any processing device such as for example one that includes a central processing unit CPU and or other forms of processing circuitry. Further the term processor may refer to more than one individual processor. The term memory is intended include memory associated with a processor or CPU such as for example RAM ROM a fixed memory device for example hard drive a removable memory device for example diskette a flash memory and the like. In addition the phrase input and or output interface as used herein is intended to include for example one or more mechanisms for inputting data to the processing unit for example mouse and one or more mechanisms for providing results associated with the processing unit for example printer .

The processor memory and input and or output interface such as display and keyboard can be interconnected for example via bus as part of a data processing unit . Suitable interconnections for example via bus can also be provided to a network interface such as a network card which can be provided to interface with a computer network and to a media interface such as a diskette or CD ROM drive which can be provided to interface with media .

Accordingly computer software including instructions or code for performing exemplary embodiments of the present invention may be stored in one or more of the associated memory devices for example read only memory ROM fixed or removable memory and when ready to be utilized loaded in part or in whole for example into random access memory RAM and executed by a CPU. Such software could include but is not limited to firmware resident software microcode and the like.

As shown in examples of a computer readable medium having computer readable program code for carrying out aspects of the present invention embodied thereon may include media and memory .

A data processing system suitable for storing and or executing program code may include at least one processor coupled directly or indirectly to memory elements though system bus . The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code to reduce the number of times code must be retrieved from bulk storage during execution.

Input and or output or I O devices including but not limited to keyboards displays pointing devices and the like can be coupled to the system either directly such as via bus or through intervening I O controllers.

Network adapters such as network interface may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a RAM a ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article or manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical functions s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

