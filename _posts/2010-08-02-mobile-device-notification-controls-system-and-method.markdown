---

title: Mobile device notification controls system and method
abstract: Provided herein are systems and methods for facilitating mobile device users to control notifications pushed to their mobile devices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08521809&OS=08521809&RS=08521809
owner: Z2Live, Inc.
number: 08521809
owner_city: Seattle
owner_country: US
publication_date: 20100802
---
This application claims the benefit of priority to Provisional Application No. 61 230 448 filed Jul. 31 2009 titled Z2 Live Push Notification Permissions and naming the following inventors Jordan Douglas Arnold Damon Vincent Danieli and David Bryn Bluhm. The above cited application is incorporated herein by reference in its entirety for all purposes.

The present disclosure relates to networked computing and more particularly to systems and methods for facilitating mobile device users to control notifications pushed to their mobile devices.

In general push technology refers to a style of network communication in which a given transaction is initiated by the publisher or central server. By contrast pull technology refers to a style of network communication in which a given transaction is initiated by receiver or client. Push services are often based on a publish subscribe model. For example a client might subscribe to various information channels provided by a publisher. When new content is available on one of those channels the server would push that information out to the client.

Some mobile device platform providers may provide a centralized general purpose Push notification system. For example various versions of the iOS mobile operating system provided by Apple Inc. of Cupertino Calif. enable Push Notifications in which an application on the sender s device e.g. an iPhone iPod Touch iPad and the like can send a notification to the receiver s device through the Apple Push Notification Service APNS . The notification may or may not subsequently appear on the receiver s device. The receiver can typically dismiss the notification or accept the notification which will launch the application with data stored in the message.

The APNS works only when both sender and receiver have installed the application in question when both users have run the application and when the receiver has indicated that it will accept push notifications for a given application by uploading a Push Token to the server of the Push Notification Provider. Once all of these conditions have been met an application on another device can push a notification to the application on the device that generated that Push Token.

Similarly some versions of the Android mobile operating system provided by the Open Handset Alliance support push notifications via Android Cloud to Device Messaging C2DM which was developed by Google Inc. of Menlo Park Calif. To enable C2DM an application on a recipient client device obtains a registration ID and provides the registration ID to a push server. The push server communicates with C2DM servers which route pushed notifications to the client device. The client device wakes up the appropriate application to process the pushed notification. The application can unregister with C2DM when the user no longer wants to receive notifications pushed to the application.

One problem with the generally known push notification systems discussed above is that the user is given little control over push notifications beyond merely opting in or out for each application. However some notifications e.g. an invitation to join a multi device game session may be desirable at certain times but may be distracting annoyances at other times e.g. while the user is at work in class asleep and the like . With existing opt in opt out notification controls the receiving user may be forced to completely opt out of receiving push notifications for an application in order to avoid receiving notifications at undesirable times.

In accordance with various embodiments as discussed below a receiving user may have fine grained control over the receipt of push notifications filtering push notifications on a case by case basis to determine whether the receiver is receptive to the notifications. In various embodiments the receiving user may filter push notifications according to various parameters such as by sender by sending receiving application by time day by the sender and or receiver s geographical location and the like.

In one embodiment a receiving user may manage push notification filters via a user interface within a Z2 Live enabled mobile application a Z2 Live Dashboard and or via the Z2 Live Service Website all of which are provided by Z2 Live of Seattle Wash. the assignee of the present application . Further information about the Z2 Live Service and the technology platform used to implement the Z2 Live Service may be found in co pending U.S. patent application Ser. No. 12 816 282 filed Jun. 15 2010 titled INVITATION SERVICE FOR MULTI DEVICE APPLICATION SESSIONS and naming inventor Damon. V. Danieli. The above cited application is incorporated herein by reference in its entirety for all purposes.

The detailed description that follows is represented largely in terms of processes and symbolic representations of operations by conventional computer components including a processor memory storage devices for the processor connected display devices and input devices. Furthermore these processes and operations may utilize conventional computer components in a heterogeneous distributed computing environment including remote file servers computer servers and or memory storage devices. Each of these conventional distributed computing components is accessible by the processor via a communication network.

The phrases in one embodiment in various embodiments in some embodiments and the like are used repeatedly. Such phrases do not necessarily refer to the same embodiment. The terms comprising having and including are synonymous unless the context dictates otherwise.

Reference is now made in detail to the description of the embodiments as illustrated in the drawings. While embodiments are described in connection with the drawings and related descriptions there is no intent to limit the scope to the embodiments disclosed herein. On the contrary the intent is to cover all alternatives modifications and equivalents. In alternate embodiments additional devices or combinations of illustrated devices may be added to or combined without limiting the scope to the embodiments disclosed herein.

In various embodiments as discussed at length below notification server facilitates one or more of users to control their conditional receptivity to push notifications received from other ones of users .

In some embodiments other servers and or devices not shown may also be present. For example in some embodiments push server may be present working in concert with notification server to push notifications out to some or all of client devices A C. In some embodiment push server when present may be operated by a platform provider. For example in one embodiment push server may comprise an APNS server for delivering push notifications to iOS devices. In another embodiment push server may comprise a C2DM server for delivering push notifications to Android devices. In other embodiments notification server may be able to push notifications to client devices A C on its own. In some embodiments one or more calendar provider servers or other mobile data provider servers not shown may also be present.

Notification server is also connected to filter database . In various embodiments filter database may store persisted filters and or other notification controls as discussed below. In some embodiments filter database may also store other information related to user accounts and or devices. In some embodiments notification server may communicate with filter database via network a storage area network SAN a high speed serial bus and or via other suitable communication technology.

In some embodiments notification server and or filter database may comprise one or more replicated and or distributed physical or logical devices.

In various embodiments network may include the Internet a local area network LAN a wide area network WAN a cellular data network and or other data network. In many embodiments there may be more client devices than are illustrated.

The notification server also includes a processing unit a memory and an optional display all interconnected along with the network interface via a bus . The memory generally comprises a random access memory RAM a read only memory ROM and a permanent mass storage device such as a disk drive. The memory stores program code for a notification request handling routine see discussed below and a matching partner invitation routine see discussed below . In addition the memory also stores an operating system . These software components may be loaded from a computer readable storage medium into memory of the notification server using a drive mechanism not shown associated with a non transient computer readable storage medium such as a floppy disc tape DVD CD ROM drive memory card or the like. In some embodiments software components may also be loaded via the network interface rather than via a computer readable storage medium .

Notification server also communicates via bus with filter database . In various embodiments bus may comprise a storage area network SAN a high speed serial bus and or via other suitable communication technology. In some embodiments notification server may communicate with filter database via network interface .

The client device also includes a processing unit a memory and a display interface all interconnected along with the network interface via a bus . The memory generally comprises a random access memory RAM a read only memory ROM and a permanent mass storage device such as a disk drive flash device or the like. The memory stores program code for one or more mobile applications that may receive push notifications. In addition the memory also stores an operating system . These software components may be loaded from a computer readable storage medium into memory of the client device using a read mechanism not shown associated with a non transient computer readable storage medium such as a floppy disc tape DVD CD ROM drive memory card or the like. In some embodiments software components may also be loaded via the network interface rather than via a computer readable storage medium .

Although an exemplary client device has been described that generally conforms to conventional general purpose computing devices a client device may be any of a great number of devices capable of communicating with the network and executing multi device applications for example a personal computer a game console a set top box a handheld computer a cell phone or any other suitable device.

As the term is used herein a gating condition defines or describes one or more circumstances that must exist or must not exist before a notification handling rule may be applied. For example in various embodiments a gating condition may describe a time period which may include describing a day and or date range such as 10 . 8 . every day 9 . 10 . and 11 . 1 . Monday Wednesday and Friday the first Saturday of every month 2 . 4 . Jul. 26 2010 and the like. In other embodiments a gating condition may define a set of one or more sending users of a prospective push notification. In other embodiments a gating condition may define a set of one or more sending and or receiving applications of a prospective push notification. In still other embodiments a gating condition may define a set of one or more geographical locations of a sending user and or a receiving user of a prospective push notification. The above examples are not exclusive nor are they limiting and in other embodiments other types of gating conditions may be employed.

In some embodiments a filter may also include one or more implicit or explicit logical operators not shown for combining multiple gating conditions. For example in one embodiment multiple gating conditions of the same type e.g. multiple time period conditions multiple sending user conditions multiple receiving user geographical location conditions and the like may be satisfied if any one of the conditions of that type are satisfied while the filter as a while may be satisfied only if all different groups of same type conditions are satisfied. In other words multiple gating conditions of the same type may be logically disjoined while multiple groups of same type gating conditions may be logically conjoined. For example consider a filter having four gating conditions A 9 . 10 . time type B 1 . 2 . time type C John sending user type D Mary sending user type . In one embodiment the filter s conditions may collectively be satisfied if a prospective notification arrives either 9 . 10 . OR 1 . 2 . AND if the prospective notification is sent from either John OR Mary.

In other embodiments multiple gating conditions within a filter may have different implicit logical relationships than those just described and or a filter may specify explicit logical relationships between multiple gating conditions.

A notification handling rule specifies an action to be taken with respect to a prospective notification when a filter s gating condition s are collectively satisfied. For example in one embodiment a notification handling rule may specify that prospective push notifications satisfying a filter s gating conditions be delivered immediately delivery type notification handling rule . In other embodiments a notification handling rule may specify that prospective push notifications satisfying a filter s gating conditions be discarded discard type notification handling rule . In still other embodiments a notification handling rule may specify that prospective push notifications satisfying a filter s gating conditions be queued for later delivery queue type notification handling rule . Collectively notification handling rules that specify whether and or when a notification should be delivered e.g. delivery type discard type and queue type notification handling rules are referred to as receptivity notification handling rules.

Other embodiments may include different notification handling rules and or different types of notification handling rules. For example some embodiments may include additional notification handling rules that specify that the sending user should or should not be notified of the action taken with regard to the prospective notification e.g. notify the sending user that the push notification request was discarded or queued for later delivery . Other embodiments may include presentation related notification handling rules such as rules that specify that when a push notification is delivered to a receiving device the receiving device should present the notification with or without a notification sound with a specified notification sound with or without a notification message with a specified notification message with or without an icon badge and the like.

In some embodiments a filter may also include additional features such as a status message that may be displayed when the filter s gating conditions are satisfied see e.g. discussed below a filter priority indication not shown an indication not shown of how multiple gating conditions if present logically relate and the like.

Beginning the illustrated sequence of operations the receiving user of notification receiving client device A provides to notification server data indicative of the receiving user s conditional receptivity to push notifications. For example in one embodiment notification server may provide an invitation control web page allowing the user to specify gating conditions and notification handling rules. In other embodiments notification server may provide an invitation control web application programming interface Web API by which an application on the receiving user s device A may communicate the user s receptivity data it having been gathered via a user interface provided on the receiving user s device A by the application. In still other embodiments notification server may obtain electronic calendar data associated with the user e.g. via communication with calendar provider server from which conditional receptivity data may be inferred. In some embodiments electronic calendar data associated with the user may be obtained automatically according to a pre determined schedule. In other embodiments electronic calendar data associated with the user may be provided on one or more occasions by the receiving user.

In the embodiment illustrated in the receiving user s conditional notification receptivity data indicates that the receiving user is receptive to push notifications under certain specified gating conditions.

Having received the data indicative of the receiving user s conditional receptivity to push notifications notification server generates a notification filter accordingly. In some embodiments generating a notification filter may simply comprise populating a data structure according to explicit user receptivity indications. For example the user s conditional notification receptivity data may indicate that notifications should be delivered between 7 . 9 . on Tuesdays in which case generating a notification filter may comprise creating a time type gating condition and a delivery type notification handling rule and storing the gating condition and notification handling rule in a filter data structure.

In other embodiments generating a notification filter may comprise analyzing electronic calendar data associated with the user and automatically inferring gating conditions and or notification handling rules. For example in one embodiment time type gating conditions may be inferred according to events and or appointments indicated by the electronic calendar data associated with the user. In other words some or all events and or appointments indicated by the electronic calendar data may be treated as potential filters each having a time type gating condition corresponding to times and or dates associated with an event and or appointment. In some embodiments notification handling rules for such potential filters may be indicated by the receiving user e.g. via an interactive user interface provided by an application on the user s client device and or by notification server .

In other embodiments notification handling rules for such potential filters may be automatically determined according to attributes of the corresponding events and or appointments. For example in one embodiment delivery type notification handling rules may automatically be implemented for appointments having meta data indicating that the receiving user may be idle or otherwise receptive to notifications e.g. a calendar item corresponding to a layover between flights .

In the embodiment illustrated in the generated notification filter s notification handling rule s indicates that push notifications that satisfy the indicated gating condition s be delivered to the receiving user.

Having generated a notification filter notification server stores the generated delivery type notification filter associated with the receiving user in an electronic data store e.g. filter database .

At some point notification server receives a request to push a notification to notification receiving client device A from a requesting user of notification requesting client device C. Notification server then retrieves one or more notification filters associated with the receiving user from the electronic data store e.g. filter database . Notification server then evaluates the retrieved one or more notification filters.

In the embodiment illustrated in the received notification request is determined to satisfy the gating condition s of the delivery type notification filter that was generated and stored in the electronic data store. Applying the notification filter s notification handling rule s notification server generates the requested push notification and provides the requested push notification to notification receiving client device A. In some embodiments the requested push notification may be delivered to the notification receiving client device A via optional push server .

Beginning the illustrated sequence of operations the receiving user of notification receiving client device A provides to notification server data indicative of the receiving user s conditional receptivity to push notifications.

In the embodiment illustrated in the receiving user s conditional notification receptivity data indicates that the receiving user is not receptive to push notifications under certain specified exclusionary gating conditions but that the receiving user may be receptive to the same push notifications once the exclusionary gating conditions are no longer satisfied.

Having received the data indicative of the receiving user s conditional receptivity to push notifications notification server generates a notification filter accordingly. In some embodiments generating a notification filter may simply comprise populating a data structure according to explicit user receptivity indications.

For example the user s conditional notification receptivity data may indicate that notifications should be queued between 9 . 6 . on weekdays in which case generating a notification filter may comprise creating a time type gating condition and a queue type notification handling rule and storing the gating condition and notification handling rule in a filter data structure.

In other embodiments as discussed above generating a notification filter may comprise analyzing electronic calendar data associated with the user and automatically inferring gating conditions and or notification handling rules. For example in one embodiment queue type notification handling rules may automatically be implemented for appointments having meta data indicating that the receiving user may be temporarily occupied in an activity that should not be interrupted by notifications. For example in one embodiment queue type notification handling rules may automatically be implemented for all appointments between 9 . 6 . Mondays Fridays. In another embodiment queue type notification handling rules may automatically be implemented for all appointments associated with work related meta data e.g. all appointments tagged meeting .

In the embodiment illustrated in the generated notification filter s notification handling rule s indicates that push notifications that satisfy the indicated gating condition s be queued for later delivery to the receiving user.

Having generated a notification filter notification server stores the generated queue type notification filter associated with the receiving user in an electronic data store e.g. filter database .

At some point notification server receives a request to push a notification to notification receiving client device A from a requesting user of notification requesting client device C. Notification server then retrieves one or more notification filters associated with the receiving user from the electronic data store e.g. filter database . Notification server then evaluates the retrieved one or more notification filters.

In the embodiment illustrated in the received notification request is determined to satisfy the gating condition s of the queue type notification filter that was generated and stored in the electronic data store. Applying the notification filter s notification handling rule s notification server queues the notification request for later delivery.

In the illustrated embodiment the notification filter s notification handling rule s also indicate that the requesting user be notified that the notification request has been queued for later delivery. Consequently notification server generates a request queued push notification and provides the request queued push notification to notification requesting client device C. In some embodiments the request queued push notification may be delivered to the notification requesting client device C via optional push server .

Periodically notification server re evaluates the queue type notification filter that was generated and stored in the electronic data store until the notification filter s gating conditions are determined to be no longer satisfied indicating that the receiving user may now be receptive to the requested push notification . Consequently notification server generates the requested push notification and provides the requested push notification to notification receiving client device A. In some embodiments the requested push notification may be delivered to the notification receiving client device A via optional push server .

Beginning the illustrated sequence of operations the receiving user of notification receiving client device A provides to notification server data indicative of the receiving user s conditional receptivity to push notifications.

In the embodiment illustrated in the receiving user s conditional notification receptivity data indicates that the receiving user is not receptive to push notifications under certain specified exclusionary gating conditions.

Having received the data indicative of the receiving user s conditional receptivity to push notifications notification server generates a notification filter accordingly. In some embodiments generating a notification filter may simply comprise populating a data structure according to explicit user receptivity indications.

For example the user s conditional notification receptivity data may indicate that notifications should be discarded during the receiving user s vacation between Jul. 26 2010 and Aug. 1 2010 in which case generating a notification filter may comprise creating a time type gating condition and a discard type notification handling rule and storing the gating condition and notification handling rule in a filter data structure.

In other embodiments as discussed above generating a notification filter may comprise analyzing electronic calendar data associated with the user and automatically inferring gating conditions and or notification handling rules. For example in one embodiment discard type notification handling rules may automatically be implemented for appointments having meta data indicating that the receiving user may be occupied in an activity that should not be interrupted by notifications. For example in one embodiment discard type notification handling rules may automatically be implemented for all appointments between 9 . 6 . Mondays Fridays. In another embodiment discard type notification handling rules may automatically be implemented for all appointments associated with work related meta data e.g. all appointments tagged meeting .

In the embodiment illustrated in the generated notification filter s notification handling rule s indicates that push notifications that satisfy the indicated gating condition s be discarded.

Having generated a notification filter notification server stores the generated queue type notification filter associated with the receiving user in an electronic data store e.g. filter database .

At some point notification server receives a request to push a notification to notification receiving client device A from a requesting user of notification requesting client device C. Notification server then retrieves one or more notification filters associated with the receiving user from the electronic data store e.g. filter database . Notification server then evaluates the retrieved one or more notification filters.

In the embodiment illustrated in the received notification request is determined to satisfy the gating condition s of the queue type notification filter that was generated and stored in the electronic data store. Applying the notification filter s notification handling rule s notification server discards the notification request.

In the illustrated embodiment the notification filter s notification handling rule s also indicate that the requesting user be notified that the notification request has been discarded. Consequently notification server generates a request discarded push notification and provides the request discarded push notification to notification requesting client device C. In some embodiments the request discarded push notification may be delivered to the notification requesting client device C via optional push server .

In subroutine block see discussed below routine generates one or more push notification filters associated with a recipient user and stores the one or more push notification filters in an electronic data store e.g. filter database in association with the recipient user. In block routine receives a request from a remote client device to push a notification to the recipient user. For example in one embodiment a user of the requesting device may wish to invite the recipient user to participate in a multi device game or other multi device networked application session. In other embodiments the request to notify the recipient user may originate with an automatic process operating on the requesting client device.

In block routine retrieves one or more push notification filters associated with the recipient user from an electronic data store e.g. filter database . In subroutine block see discussed below routine evaluates the one or more push notification filters associated with the recipient user and handles the push notification request accordingly. Routine ends in block .

In block subroutine generates one or more push notification filters according to the obtained receptivity data. See text above accompanying items and in and respectively discussing the generation of notification filters according to user receptivity data.

In block subroutine stores the generated one or more push notification filters in an electronic data store e.g. filter database associated with the recipient user. Subroutine ends in block returning to the calling routine.

In block subroutine compares the currently selected filter s one or more gating conditions against appropriate attributes of the push notification request under evaluation. For example in various embodiments subroutine may evaluate one or more time related conditions e.g. gating conditions specifying a time a time range a date. and or a date range against the time at which the receiving device would receive the notification. In many embodiments the time at which the receiving device would receive the notification may be within a few seconds or minutes of the current time. In other embodiments the request may specify a future date and or time for delivery of the requested notification in which case the one or more time related conditions would be evaluated against the specified future delivery time. In some embodiments the one or more time related conditions would be evaluated against a determined current local time on the receiving device.

In various embodiments subroutine may evaluate one or more sender related conditions e.g. a set of one or more indicated sending user identities one or more indicated sending devices one or more indicated sending applications one or more characteristics and or attributes of a sending user device application and the like against the identity or other attribute characteristic of the user device and or application associated with the push notification request under evaluation. For example in various embodiments various sender related conditions may be satisfied when the requesting user is or is not John when the requesting user is or is not a member of the recipient user s group of friends when the requesting user is male or female when the requesting application is or is not a card game application when the requesting device is or is not an iPhone and the like.

In various embodiments subroutine may evaluate one or more location related conditions e.g. a current or recent geographical location of the requesting device and or recipient device against a determined location of the requesting and or recipient device associated with the push notification request under evaluation. In some embodiments to determine a location of the requesting and or recipient device subroutine may communicate with the remote device in question to obtain the device s current location. In other embodiments subroutine may determine whether the requesting and or recipient device has recently checked in or otherwise reported its location either to the device performing subroutine e.g. notification server or to another online accessible service that will return recent location indications from the device in question. In some embodiments the request itself may include location information associated with the requesting device.

Having evaluated in block the currently selected filter s one or more gating conditions against appropriate attributes of the push notification request subroutine determines in decision block whether the currently selected filter s one or more gating conditions are currently collectively satisfied. If not then subroutine either proceeds to select the next unevaluated filter in block or ends in block depending on whether it is determined in decision block that one or more additional unevaluated filters exist.

When in decision block subroutine determines that the currently selected filter s one or more gating conditions are currently collectively satisfied then in decision block subroutine applies a notification handling rule according to the currently selected filter depending on the type of the receptivity push notification handling rule.

If the type of the currently selected filter s receptivity push notification handling rule indicates that the request under evaluation should be discarded then in decision block subroutine determines whether the requestor should be informed that the push notification request will not be delivered. For example in one embodiment subroutine may apply a policy to notify or not notify requestors of discarded requests. In other embodiments the currently selected filter may include additional push notification handling rules that indicate whether the requestor should be informed that the push notification request would not be delivered. If the requestor should not be informed then subroutine ends in block . On the other hand if the requestor should be informed then in block subroutine generates a request discarded notification e.g. a push notification a Short Message Service or SMS message an email message or the like . Subroutine delivers the request discarded notification via an appropriate communication channel in block before ending in block .

If the type of the currently selected filter s receptivity push notification handling rule indicates in block that the request under evaluation should be delivered then in block subroutine generates the requested push notification and pushes it to the recipient device in block . In some embodiments pushing the requested notification may include providing it to a push server such as an APNS server or a C2DM server. Subroutine then ends in block returning to the caller.

If the type of the currently selected filter s receptivity push notification handling rule indicates in block that the request under evaluation should be queued then in decision block subroutine determines whether the requestor should be informed but has not yet been informed. For example in one embodiment subroutine may apply a policy to notify or not notify requestors of queued requests. In other embodiments the currently selected filter may include additional push notification handling rules that indicate whether the requestor should be informed that the push notification request would be queued for possible later delivery. If the requestor should be informed but has not yet been informed then in block subroutine generates a request queued notification e.g. a push notification an SMS message an email message or the like . Subroutine delivers the request queued notification via an appropriate communication channel in block .

When the requestor has been informed or when the requestor should not be informed then in block subroutine waits for a period of time before updating one or more time varying request attributes in block . For example the delivery time of the requested notification may be updated to reflect the current time. In some embodiments a current location of the recipient device and or the requesting device may also be updated. For example in some embodiments to update a current location of the requesting and or recipient device subroutine may communicate with the remote device in question to obtain the device s current location. In other embodiments subroutine may determine whether the requesting and or recipient device has recently checked in or otherwise reported its location either to the device performing subroutine e.g. notification server or to another online accessible service that will return recent location indications from the device in question.

After one or more time varying attributes of the notification request under evaluation have been updated in block subroutine re evaluates the selected filter s gating condition s against the updated attributes of the notification request. At some point the currently selected filter s gating conditions may no longer be satisfied. For example in various embodiments the current time may no longer satisfy a time related gating condition the current location of the recipient and or the requestor may no longer satisfy a location related condition or the like.

When the currently selected filter s gating conditions are longer satisfied then subroutine may proceed to evaluate the next filter if any which may indicate that the request should be delivered. Thus the recipient user may be able to defer notifications until he or she is receptive to receiving them. For example in some embodiments the recipient user may be able to defer receiving notifications during working hours during meetings during classes during sleeping hours and the like queuing any notifications received until a specified time period has elapsed. In other embodiments the recipient user may be able to defer receiving notifications while the recipient user is present at a specified location or locations or is not present at a specified location or locations queuing any notifications received while the recipient user is at the location where he or she works for later delivery after the recipient user arrives at the location where he or she resides for example .

In block routine receives a request from an inviter user on a remote client device to match the inviter user with one or more partners in a multi device application session. As the term is used herein a multi device application session refers to a series of contemporaneous interactions involving at least two users of at least two devices often but not always physically remote from one another via a series of networked communications between an instance of an application on a first device operated by a first user and an instance of the application on a second device operated by a second user . For example in various embodiments a multi device application session may comprise a multiplayer game such as card games shooter games fighting or combat games and the like a multi user interactive text audio and or video conference session a multi user productivity application session a virtual reality interactive session and the like.

In block routine identifies a plurality of prospective partners such as registered users who have previously indicated that in some conditions they may be receptive to invitations to join sessions such as the requested multi device application session.

In subroutine block see discussed below routine attempts to identify and invite at least one currently receptive partner. In decision block routine determines whether at least one currently receptive partner was invited to the requested multi device application session. If not then in block routine generates a match failed notification. Subroutine provides the match failed notification for delivery to the requestor in block . In some embodiments the match failed notification may be delivered to the notification receiving client device A via optional push server .

On the other hand if in block at least one currently receptive partner was invited to the requested multi device application session then in block routine determines whether the invitation or invitations was accepted. Routine generates an invitation accepted or an invitation declined notification in block or block respectively before provides generated notification for delivery to the requestor in block . In some embodiments the generated notification may be delivered to the notification receiving client device A via optional push server .

Subroutine begins in block . In block subroutine selects from the set of prospective partners a prospective partner whose receptivity to an invitation has not been evaluated. In various embodiments the set of prospective partners may be ordered according to some criteria such as the order in which they registered the order in which they were returned from an electronic data store e.g. filter database a random order and the like. In such embodiments selecting an un evaluated prospective partner may comprise selecting the next or the previous un evaluated prospective partner according to the partner ordering criteria.

In block subroutine determines attributes that would be associated with a prospective request to invite the selected prospective partner to the requested multi device application session. In block subroutine retrieves one or more push notification filters associated with the selected prospective partner from an electronic data store e.g. filter database .

In block subroutine selects an unevaluated filter from the one or more push notification filters retrieved in block . In some embodiments the one or more push notification filters may be ordered according to priority and or ranking metadata associated with the filters. In some embodiments the selected prospective partner may have specified priority and or ordering metadata when specifying the filters. In other embodiments the one or more push notification filters may be ordered according to other criteria such as the order in which they were created the order in which they were returned from an electronic data store e.g. filter database random order and the like. In cases in which the one or more push notification filters are ordered according to some criterion selecting an unevaluated filter may comprise selecting the first or last unevaluated filter according to the ordering criterion.

In block subroutine compares the currently selected filter s one or more gating conditions against appropriate attributes of the prospective request to invite the selected prospective partner. For example in various embodiments subroutine may evaluate one or more time related conditions sender related conditions location related conditions and or other similar types of conditions. The text accompanying block in above provides a more detailed discussion of gating condition evaluation. 

Having evaluated the currently selected filter s one or more gating conditions against appropriate attributes of the prospective request to invite the selected prospective partner subroutine determines in decision block whether the currently selected filter s one or more gating conditions are currently collectively satisfied. If not then in decision block subroutine determines whether one or more additional unevaluated filters exist and proceeds to select the next unevaluated filter in block if an additional unevaluated filter exists. If no additional unevaluated filters exist then in decision block subroutine determines whether an additional un evaluated prospective partner exists. If an additional un evaluated prospective partner exists then in block subroutine selects and proceeds to evaluate the next prospective partner. If all prospective partners have been evaluated then subroutine ends in block returning an indication that no partner was invited.

On the other hand if subroutine determines in decision block that the currently selected filter s one or more gating conditions are currently collectively satisfied then in decision block subroutine determines whether the currently selected filter s receptivity notification handling rule indicates that the prospective invitation should be delivered. If not e.g. if the currently selected filter s receptivity notification handling rule indicates that the prospective invitation should be discarded or queued then in decision block subroutine determines whether an additional un evaluated prospective partner exists. If an additional un evaluated prospective partner exists then in block subroutine selects and proceeds to evaluate the next prospective partner. If all prospective partners have been evaluated then subroutine ends in block returning an indication that no partner was invited.

However if in decision block subroutine determines that the currently selected filter s receptivity notification handling rule indicates that the prospective invitation should be delivered then in block subroutine generates an push notification inviting the selected prospective partner to join the requested multi device application session. In block subroutine pushes the invitation push notification to a client device associated with the currently selected prospective partner. In some embodiments pushing the invitation push notification may include providing it to a platform provider server such as an APNS server or a C2DM server. Subroutine then ends in block returning to the caller an indication that the currently selected prospective partner was invited to join the requested multi device application session.

In some embodiments before ending subroutine may determine not shown whether additional prospective partners should be evaluated to receive an invitation. If so and if additional un evaluated prospective partners exist then in such embodiments subroutine may cycle back not shown to block to select and proceed to evaluate an additional prospective partner.

In beginning loop block subroutine evaluates each of the one or more friend users in turn. In block subroutine determines attributes that would be associated with a prospective notification request from the signed in user to the current friend user e.g. a request to invite the current friend user to a multi device application session . In block subroutine retrieves one or more push notification filters associated with the current friend user from an electronic data store e.g. filter database .

In block subroutine selects an unevaluated filter from the one or more push notification filters retrieved in block . In some embodiments the one or more push notification filters may be ordered according to priority and or ranking metadata associated with the filters. In some embodiments the selected prospective partner may have specified priority and or ordering metadata when specifying the filters. In other embodiments the one or more push notification filters may be ordered according to other criteria such as the order in which they were created the order in which they were returned from an electronic data store e.g. filter database random order and the like. In cases in which the one or more push notification filters are ordered according to some criterion selecting an unevaluated filter may comprise selecting the first or last unevaluated filter according to the ordering criterion.

In block subroutine compares the currently selected filter s one or more gating conditions against appropriate attributes of the prospective request to notify the current friend user. For example in various embodiments subroutine may evaluate one or more time related conditions sender related conditions location related conditions and or other similar types of conditions. The text accompanying block in above provides a more detailed discussion of gating condition evaluation. 

Having evaluated the currently selected filter s one or more gating conditions against appropriate attributes of the prospective request to notify the current friend user subroutine determines in decision block whether the currently selected filter s one or more gating conditions are currently collectively satisfied. If not then in decision block subroutine determines whether one or more additional unevaluated filters exist and proceeds to select the next unevaluated filter in block if an additional unevaluated filter exists. If no additional unevaluated filters exist then in decision block subroutine may in various embodiments display a default status indicator for the current friend user may display no status indicator for the current friend user or the like.

On the other hand if subroutine determines in decision block that the currently selected filter s one or more gating conditions are currently collectively satisfied then in block subroutine displays a notification receptivity indicator according to the currently selected filter s receptivity notification handling rule. For example if the currently selected filter s receptivity notification handling rule indicates that a currently requested notification from the signed in user should be delivered then subroutine may display a currently receptive indicator for the current friend user if the current friend user is currently signed in or a user not signed in indicator if the current friend user not currently signed in. Similarly if the currently selected filter s receptivity notification handling rule indicates that a currently requested notification from the signed in user should be queued for later delivery then subroutine may display a temporarily un receptive indication for the current friend user. If the currently selected filter s receptivity notification handling rule indicates that a currently requested notification from the signed in user should be discarded then subroutine may display an un receptive indication for the current friend user. Additionally in some embodiments subroutine may display a status message associated with the currently selected filter if any for the current friend user.

In ending loop block subroutine cycles back to block to process the next friend user if any . Once all friend users have been processed subroutine ends in block .

Although specific embodiments have been illustrated and described herein a whole variety of alternate and or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present disclosure. This application is intended to cover any adaptations or variations of the embodiments discussed herein.

