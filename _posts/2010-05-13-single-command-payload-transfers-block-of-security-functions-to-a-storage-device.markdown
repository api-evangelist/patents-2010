---

title: Single command payload transfers block of security functions to a storage device
abstract: A storage device has a storage medium and a processor. The processor is disposed within the storage device and is adapted to receive multiple commands as a command block over an interface. The processor is adapted to extract each of the multiple commands from the single block for execution on the storage device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08656188&OS=08656188&RS=08656188
owner: Seagate Technology LLC
number: 08656188
owner_city: Cupertino
owner_country: US
publication_date: 20100513
---
The present application is a continuation of and claims priority to pending U.S. patent application Ser. No. 11 143 862 filed Jun. 2 2005 and entitled Single Command Payload Transfers Block of Security Functions to A Storage Device the content of which is hereby incorporated by reference in its entirety.

The present invention relates to command processing on a storage device and more particularly to a methodology for processing multiple commands contained in a single data block using a processor disposed on the storage device.

Disc drive and other storage subsystems including flash memory devices and removable storage devices typically have a processor sometimes called a microprocessor in their built in electronics. The processor can be used to hide computations as well as stored data.

SmartCards are a type of storage device that is commonly limited to single security sessions and to simple sequences of operations. As used herein the term SmartCard refers to card with updatable memory and often with an embedded microprocessor. A smartcard may be used in a variety of ways. One use is to initialize the card with a monetary value for use in financial transactions such as paying for telephone calls or for conducting Internet transactions. With respect to storage devices SmartCards can also be utilized as a physical access key for unlocking a storage device.

A storage device based implementation can potentially have a large number of security partitions and can handle multiple simultaneous security sessions to those security partitions. As used herein the term security partition refers to a data area defined on a storage medium of the storage device to which access is strictly controlled. A security session is a secure transaction using for example encryption tunneling or secure socket layer type communication protocols between the security partition and an entity.

Though the storage device typically has more capabilities than a SmartCard the storage device is still limited by the command set that can be sent from a host machine to the storage device. In one sense if the host transmits only one command at a time to a storage device in a manner similar to a typical SmartCard session the capabilities of the storage device are not fully realized. Additionally latencies associated with access time the time interval from a start of a memory read until the insertion of the memory completion signal and cycle time the minimum time interval from the start of a read or write operation to the start of the next memory operation are made worse. Typically the cycle time may be slightly longer than the access time due to various hardware housekeeping tasks that are performed by the memory.

Some memory devices read or write values not as individual words but in blocks of multiple words. In these memory systems there is a latency in accessing the first word of the block that is different from the bandwidth the rate at which the words can be transmitted in words per second once the first word of the block is available.

Because the latency in accessing the first word in a block is cumulative with the rate at which words can be transferred it is desirable to reduce first word latencies in order to minimize delays. Such latencies typically occur in communications between a host system and a storage subsystem.

There is an ongoing need for improved communications between host systems and the storage subsystem. More particularly there is an on going need for improving communications including commands and transactions directed to particular security sessions between the host and the storage subsystem that hosts the transactions.

A storage device has a storage medium and a processor. The processor is disposed within the storage device and is adapted to receive multiple commands as a single block over an interface. The processor is adapted to extract each of the multiple commands from the single block for execution on the storage device.

In one embodiment a method for processing commands on a storage device is described. A command block is received on the storage device over an interface from an external device. The command block is formed from a plurality of commands. Each of the plurality of commands is extracted from the command block using a command processor of the storage device.

In another embodiment a storage device has a storage medium and a processor. The storage medium has one or more security partitions. The processor is disposed within the storage device and is adapted to extract single commands from a command block formed from a plurality of commands. The processor is adapted to process each single command on security sessions associated with the one or more security partitions.

Other features and benefits that characterize embodiments of the present invention will be apparent upon reading the following detailed description and review of the associated drawings.

In the example shown in sliders are supported by suspensions which are in turn attached to track accessing arms of an actuator . The actuator shown in is of the type known as a rotary moving coil actuator and includes a voice coil motor VCM shown generally at . Voice coil motor rotates actuator with its attached heads about a pivot shaft to position heads disposed on sliders over a desired data track along an arcuate path between a disc inner diameter and a disc outer diameter . Voice coil motor is driven by servo electronics based on signals generated by heads disposed on sliders and a host system via interface .

A command set and transmission protocol on the storage subsystem for utilizing a complex set of capabilities of a storage subsystem based security partition or drive card set is described. A session manager is adapted to open and manage multiple sessions simultaneously. The command processor is adapted to parse a series of commands related to transactions on the security partitions or drive card set. A facility is provided to execute remote procedure calls on the drive. The command set and transmission protocol receives a single command payload transferred from the host to the drive and processes the series of commands from the single payload.

It will be understood by a worker skilled in the art that the present invention is applicable to any memory system adapted to host security sessions including the disc drive system shown in . Typically such security sessions within a disc drive system includes secured communications between the host system and the disc drive sent over interface . The interface may be an ATA or SCSI interface. Other memory systems may include MRAM EEPROM drive cards flash memory or any other storage subsystem adapted to host secure transactions. The storage device may be attached to a host system or may be configured as a stand alone storage device which may be connected to a network or embedded as part of a system that has no host or network connections. The network may be a local area network or a wide area network such as the Internet .

A packet is a unit of data transfer for a specific session or security session . The packet consists of a length of type uinteger 2 followed by a data area D of type uinteger. The data area D may be encrypted. In some embodiments the data area D is left as unencrypted text. Packet payloads are divided into one or more subpackets. Session is the number of the session to which the packet belongs and length is the number of bytes in the packet payload.

Flag defines the type of Kind for example 0 queue number 1 command number . Kind is the number of the queue or command of the subpacket. Length is the number of bytes in the subpacket payload.

In general subpackets have fixed length headers followed by a payload. Subpackets fit entirely within an packet and do not span packets . A subpacket may either define some data to load into a session queue or a single command for a session to execute. In an alternative embodiment the subpacket payload may be a tokenized data stream.

In general command transmissions from the host to the drive or from an entity to the drive in a stand alone storage system which are intended for the security subsystem of the storage device contain payloads. The payloads are organized into a superpacket containing one or more packets each of which contains one or more subpackets. Each subpacket typically contains a single command though some commands have data that spans more than one subpacket.

If a single command is sent from the host it would arrive at the security subsystem in a single router packet with a header as shown in . The superpacket contains a superpacket header followed by a packet header followed by a subpacket header which is followed by the subpacket payload.

Conceptually the superpacket can be thought of as a block formed from a plurality of packets and subpackets. The block can be transmitted over the interface and the packets and subpackets can be extracted from the block to retrieve individual commands for execution. In the present invention the storage device includes a processor for extracting individual commands from the received command block. In one embodiment each superpacket command block contains a plurality of commands and associated information for processing on the storage device. As used herein the term extract refers to a process of parsing or unpacking the command block to expose each individual command of the command block for processing by the processor on the storage device. In a preferred embodiment the command block is formed from a plurality of commands and the processor on the storage device extracts each of the plurality of commands from the command block. A session manager can then associate each command with a particular transaction such as a security session.

In general the data structure discussed with respect to through illustrate various forms in which commands are received and delivered to the storage subsystem.

In general a single command payload contained in a superpacket is received by the input interface and stored in an input buffer not shown . The command processor processes the received superpacket parsing the superpacket to retrieve subpackets associated with one or more security partitions on the storage device. The session manager finds the open session or opens a new session and directs the subpacket information to the appropriate session for further processing.

The storage device receives the superpacket via a native interface which writes the packet to an input buffer not shown . An interrupt service routine ISR interface is adapted to interrupt the command processor when a superpacket arrives at the native interface . The command processor is adapted to parse the superpacket to determine that a command is intended for the security subsystem and to pass each security function from the superpacket payload via a transport layer protocol for example a transfer protocol such a Seagate Diagnostic Bridge Protocol developed by Seagate Technology LLC to the session manager . The session manager is adapted to manage all security session activity for multiple simultaneous security session on a storage device. Generally each security session corresponds with one or more security partitions on the storage device. The session manager accesses various data and software objects on the storage device including a security partition SP administrator object an SP MS CSP object an SP remote procedure call RPC object an SP keystore a system information manager SIM an SP structured query language SQL object an SP log and an SP clock .

The session manager makes use of the SP administrator to execute remote procedure calls using the SP RPC within a security session. The SP CSP and the SP Keystore are accessed to encrypt and decrypt data within the security session. The SP SQL object is utilized to access hidden spaces on the storage medium. The SP log object is utilized by the session manager to record security session and security partition transactions. Finally the SP clock is utilized to maintain a sense of time within the security partition and more particularly within a security session for detecting excessive time or time out type conditions.

Once the session manager receives a command the session manager directs the command to the appropriate security session and security partition. The various security partition objects through are utilized by the session manager to access a security partition to deliver the commands and associated information and so on.

The present invention enhances the capabilities of host based application programs simplifies program steps and controls the sequence or ordering of a series of complex operations involving multiple security partitions or drive parts on the storage subsystem. In particular the session manager of the present invention makes it possible to process blocks of functions in a single payload within the drive. This allows commands to be sent over the interface in a single payload thereby reducing latencies.

The session manager is implemented on the drive side as opposed to the host side and is responsible for managing all security session activity for multiple simultaneous sessions. The session manager works closely with a platform firmware task manager to allocate processor time to various co routines.

Upon receiving the command payload the interface client calls a session manager to parse the subpacket using a session manager command which is a public application programming interface command that is accessible to the interface. The session manager calls a number of private functions. For example the session manager reads the router header and the superpacket header. The session manager then retrieves the packet header for each packet in the superpacket. The session manager then tries to find an open session for each packet and if a related session is found the session manager queues the packet to that related session. The session manager then reads the subpacket header and executes the subpacket command for each subpacket in the routed packet payload. If the session is not open already an error message may be returned.

If all available security sessions are active the session manager may generate an error message and issue zero credit. If there are session slots available but the session is not open the system reserves an unopened session for the user and routes the packet to session tasks. In general the number of available security sessions may be a pre configured limitation or a resource limitation depending on the particular implementation. The session manager then returns status information conditional output data and or credits to the interface client.

The session manager initiates a trust session which wakes up after the CPU access is gained from the yield call to the co routines co routines may be other security sessions or other active processes . The session manager reads the subpacket info for each subpacket in the session related packet using a call to stream utilities. The session manager initiates the start method command a remote procedure call to the RPC API and dequeues each subpacket into the session scratch buffer. The session manager then initiates a get token function and decodes each token from the subpacket and processes them. The start method command may be for example a new session command a close session commend start method end method start transaction authenticate session and so on. The get token function may repeatedly call a readstream function to parse the subpacket for the command and may also call the yield function and or yield the CPU temporarily to high priority functions. If any bad tokens are encountered the session manager returns an error code otherwise a success code is returned. In general the session manager accesses the various commands and procedures as session tasks .

The session manager calls session tasks based on the packet data block . If the session task is a trust session the trust session command is invoked block . The session manager invokes a Yield command to gain access to the CPU through the session tasks block . The subpacket is dequeued into the session scratch buffer. Each token from the subpacket is then decoded and processed. A response packet success or fail is queued to the host system.

In this embodiment a single command payload including a superpacket packet and subpacket transfers a block of functions to the storage device. The superpacket has already arrived at the interface. The interface client command processor calls the session manager . The session manager calls the system information manager SIM to read content from a hidden area on the storage medium. The SIM calls the transport layer for example a Seagate Diagnostic Bridge Protocol SDBP to retrieve the incoming buffer file pointer . The SDBP returns the pointer and the SIM returns the superpacket header information to the session manager . The process is repeated to retrieve the packet header.

The session manager then tries to find the session associated with the packet header. If the session is found the session manager generates a status response command to the interface message utilities . The interface message utilities open a write stream via a function call to the stream utilities . Once the stream is opened the packet information is queued to the found session. The session manager then calls the SIM to read the file content of the payload for the packet. The SIM calls the SDBP to retrieve the pointer and the SIM returns the subpacket header information to the session manager. The session manager then processes the subpacket manages the open session and queues commands and information from the subpacket to the session.

Turning now to the session manager invokes a trust session with session tasks . The trust session function triggers a yield call to the co routines . The trust session wakes up upon receipt of the return task message indicating that CPU access is regained. The session manager then causes the payload data or stream to be read via a call to the stream utilities and the subpacket information is returned. The method associated with the subpacket command is called here StartMethod is called by a function call to the RPC API remote procedure call application programming interface . The RPC API retrieves a token associated with the subpacket reads the stream via a call to the stream utilities which returns a number of bytes read. The RPC API then requests CPU access via a yield function call to the co routines . Once the CPU access is regained the RPC API retrieves the next token value from the data utilities which provides a tag length and value of the next token or credit. The RPC API then returns a success flag to the session manager.

This process can be repeated as many times as necessary to completely unpack decode and process a block of security functions. Moreover the session manager is adapted to manage a plurality of simultaneous security sessions each security session accessing a different partition on the storage device. Calls from the session manager to the systems information manager make it possible for the session manager to invoke internal functions without exposing information to a spy or Trojan horse type application. Specifically the session manager calls an internal read file content command invoking a private function of a system information manager to retrieve the data rather than accessing the data directly. Thus data processing can be handled on the drive side without jeopardizing data security.

In one embodiment the function call by the session manager to the system information manager causes the system information manager to retrieve or dynamically assemble a root key for encrypting data returned to the session manager. In this way no unencrypted data is exposed to an unauthorized user.

In some instances requests for access to co routines may require the system to yield access to the CPU temporarily and return access from the CPU when there is a message to process. In some instances the system will repeatedly retrieve the token via calls to read the stream to parse subpacket commands. Retrieving the token also results in calls to the CPU to yield temporarily to a higher priority task.

In general the session manager coordinates processing of the complex set of instructions by retrieving the instructions parsing the block into individual instructions routing the instructions to the appropriate subsystem and coordinating processing for execution according to established priorities. This allows the subsystem to handle multiple simultaneous security sessions.

During the time that a subpacket is being parsed by a read string function the operating co routine called yield frequently so that the task manager can determine whether a higher priority task needs to temporarily gain access to the CPU. A fairness algorithm not illustrated ensures that no task is starved and that all tasks get adequate amounts of processor time. In general the fairness algorithm ensures that high priority tasks receive adequate processing time. The session manager is adapted to terminate sessions or to reject sessions if processor resources are needed by a higher priority task or if processor resources are not available to a new session request. The fairness algorithm operates to balance processor resources among sessions.

In general the present invention reduces first word read latencies by processing groups of commands received in a single command payload rather than by receiving commands over the interface one at a time. In this manner the storage device is made more efficient than conventional storage devices.

It is to be understood that even though numerous characteristics and advantages of various embodiments of the invention have been set forth in the foregoing description together with details of the structure and function of various embodiments of the invention this disclosure is illustrative only and changes may be made in detail especially in matters of structure and arrangement of parts within the principles of the present invention to the full extent indicated by the broad general meaning of the terms in which the appended claims are expressed. For example the particular elements may vary depending on the particular application for the storage subsystem while maintaining substantially the same functionality without departing from the scope and spirit of the present invention. In addition although the preferred embodiment described herein is directed to a command transfer protocol and system for transferring a plurality of security functions via a single command payload it will be appreciated by those skilled in the art that the teachings of the present invention can be applied to any drive side data script processing or decoding process without departing from the scope and spirit of the present invention.

