---

title: Smooth layout animation of visuals
abstract: A declarative animation system allows a designer to declaratively specify transitory behavior of a user interface or other visual display by recognizing changes in an underlying data model that spans visual elements. A visual display is typically comprised of one or more visual elements, as well as an underlying data model. Although animating within a particular visual element is typically straightforward, moving items across visual elements typically involves sophisticated programming logic. However, using the declarative animation system, visual elements can be associated with an underlying data model in a manner that allows the visual display layer to recognize and respond to changes in the underlying data model. This association can also be leveraged to allow automatically generated animation between visual elements without the addition of custom programmatic code. Thus, the declarative animation system allows designers to specify intuitive, graphically sophisticated interfaces without programming knowledge.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09223589&OS=09223589&RS=09223589
owner: Microsoft Technology Licensing, LLC
number: 09223589
owner_city: Redmond
owner_country: US
publication_date: 20100226
---
Modern user interface toolkits use layout managers to create user interfaces that can be dynamically resized. Layout managers are software components that have the ability to lay out components sometimes called widgets by their relative positions without using distance units. It is often more natural to define component layouts in this manner than to define component positions in pixels or common distance units so a number of popular widget toolkits include this ability by default. Widget toolkits often allow designers to place widgets in layout containers that have particular layout characteristics when the container is rendered. Windows Presentation Foundation WPF and Microsoft Silverlight are two examples of toolkits that provide layout managers. Designers describe user interface UI components in Extensible Application Markup Language XAML and can define UI states and transitions using an Application Programming Interface API such as MICROSOFT Silverlight or MICROSOFT WINDOWS Presentation Foundation.

One reason that layout managers are used is to enable automatic resizing of an application so that UIs can work properly on devices with different display resolutions and with resizable reconfigurable windows. Layout managers are also good at handling varying sizes quantities of content. Layout managers are used to automatically determine the layout of graphical elements and controls on a screen. Layout managers typically operate by forcing their children graphical elements UI elements to conform to a certain layout rule. A stack panel for example may force its children into a horizontal or vertical stack controlling only relative position of the objects with respect to each other. As another example a uniform grid might force objects to be arranged in a grid with a fixed size for each child. A table style layout might force children to conform to row and column definitions and to define position margins to control positioning and size.

For dynamic user interfaces it is often useful to transition between different layouts of UI components. For example when a user clicks on a More button the designer may want the area of one component to expand and display more UI controls. For usability reasons designers like transitions to be smooth and allow for detailed control. In some scenarios it is sufficient to simply fade between two entirely different UI screens but this technique does not work when a layout of graphical elements or user interface controls is designed to morph smoothly from one layout to another. For example a designer may want a panel to appear to fly out from the left side after a user logs in to an application. Current animation systems such as Microsoft Visual State Manager automatically animate transitions from one state to another. In the previous example the animation system causes the panel to animate from the left side of the display through several intermediate locations before reaching the final fully displayed location.

User interface animation increases the reality of interacting with objects experienced by users of the interface. For example folders that animate from one location to another are easier to understand than those that simply disappear and reappear at another location. One type of user interface animation is a bounce which refers to the desirability of an object having some amount of elasticity as it moves from one location to another. For example a software designer may want an object dragged from one location to another to bounce at the destination as it would if physically dropped. The bounce calls the user s attention to the object s new location and gives the object a more realistic feel making the interface more pleasing to use.

Many modern applications and systems use motion to explain how information moves from one place to another. Examples include animating the motion of selected items from a master list to a filtered list animating an application to grow out of its icon when launched or animating deleted files to a recycle bin. Today this work is typically done by writing custom code specific to the task. However as the nature of the animation is highly visual there is a great need to put the control of the animation in the hands of a visual designer who does not wish to or even know how to write code to perform the task.

A declarative animation system is described herein that allows a designer to declaratively specify transitory behavior of a user interface or other visual display by recognizing changes in an underlying data model that spans visual elements. A visual display is typically comprised of one or more visual elements as well as an underlying data model. Although animating within a particular visual element is typically straightforward moving items across visual elements typically involves sophisticated programming logic particularly when the visual elements are encapsulated in different controls. However using the declarative animation system visual elements can be associated with an underlying data model in a manner that allows the visual display layer to recognize and respond to changes in the underlying data model. This association can also be leveraged to allow automatically generated animation between visual elements without the addition of custom programmatic code. Thus the declarative animation system allows designers to specify intuitive graphically sophisticated interfaces without programming knowledge.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

A declarative animation system is described herein that allows a designer to declaratively specify transitory behavior of a user interface or other visual display by recognizing changes in an underlying data model that spans visual elements. A visual display is typically comprised of one or more visual elements as well as an underlying data model. For example an e commerce web page might include one visual element that presents a list of items on the left from which a user can select and another visual element that presents a detail view of a selected item on the right. Underlying the visual display in this example is a data model that includes a list of items for sale and information about the items such as an image of the item descriptive information a price and so forth. There is also an overall shopping session data model that contains the items being viewed the contents of a shopping cart and so on. Although animating within a particular visual element is common e.g. sorting a list of items to reorder the items or increasing the size of an element when a cursor hovers over it moving items across visual elements typically involves sophisticated programming logic particularly when the visual elements are encapsulated in different controls. For example although it is intuitively straightforward that a selected item in the list on the left in the above example is related to the item in the detail view on the right there is no way for the visual display to understand this relationship without code connecting the two. However using the declarative animation system visual elements can be associated with an underlying data model in a manner that allows the visual display layer to recognize and respond to changes in the underlying data model. This association can also be leveraged to allow automatically generated animation between visual elements without the addition of custom programmatic code. Thus the declarative animation system allows designers to specify intuitive graphically sophisticated interfaces without programming knowledge.

In some embodiments the system maintains a dictionary of items in which the dictionary key corresponds to the underlying data model of a visual element and the dictionary value is the last known position of that element. Whenever the association between the underlying data model and visual elements changes the declarative animation system can produce an animation from the last known position in one visual element to a new position in another visual element. Returning to the e commerce example above the data models for individual items may not change but the data model of the user s shopping session has changed and the change in the overall shopping session model might change which item s data model is applied to particular visual elements. In this way there can be a declarative relationship between elements at the visual level or at the data level and this declarative relationship can be used to control animations at the layout level without custom code.

The declarative input component parses a declarative representation of a user interface including one or more visual elements. For example the system may load an extensible markup language XML file that defines one or more visual elements to be displayed on a web page or other user interface page. The declarative representation may include information such as hierarchical relationships between visual elements whether visual elements participate in layout animation whether a visual element is identified by a data element with which it is associated and so forth. A declarative representation can be created by a designer having no programming experience using a user interface for editing declarative representations e.g. a visual tool such as MICROSOFT Expression Blend . To the extent that any behavior can be defined within this declarative representation it is within the skill set of the designer without programming knowledge.

The visual layer manager manages a displayed representation of the declarative representation. The visual layer may include graphical controls that map to particular visual element tags specified in a declarative representation e.g. a canvas stack panel and so forth . The visual layer manager manages displaying each visual element as well as informing elements that an update is needed when a parent visual element changes. The visual layer manager understands the visual elements displayed but does not necessarily understand the context of the items. For example a list view may display a list of items and a detail view may display a detailed description of a selected item but the visual layer may not know that the selected item in the list view and the item described in the detail view are related to the same data.

The data layer manager manages one or more data items associated with the displayed representation. The data layer manager may retrieve a list of data items from another source. For example an online bookstore may store data items related to each book that the bookstore sells in a database and the data layer manager may access the database based on a user interface request to display particular items e.g. in response to a search query . The data layer manager may also maintain properties of each data item such as an image associated with a data item a caption related to the data item descriptive text related to the data item and so forth.

The tag identification component identifies a tag for each displayed visual element. In some cases the declarative representation for a visual element specifies a tag for the visual element and the tag identification component simply reads and loads the specified tag into the item dictionary . In other cases the tag identification component automatically generates a tag for a visual element based on a data item related to the visual element. For example if the system is displaying purchasable items from an e commerce website then the data item may include an item for sale and the visual elements may include user interface controls related to displaying the item for sale. A tag for an item can be declared or generated in a way that the tag stays the same for a particular data item even as that item changes relationship with various visual elements. For example a data item may initially be displayed in a first list view and later displayed in a second list view but may have the same tag in both cases. This forms a basis for tracking the data item even as it moves across visual elements.

The item dictionary is a table that maps identified tags to visual elements and stores position information about each visual element. For example the table may include a tag column a layout position column and a parent column. The parent column defines the parent of the visual element. The layout position column specifies a last known position of a visual element which may be in coordinates relative to that element s parent. When user interaction or other input causes a layout change the system performs a layout pass that update the visual display. During the layout pass the system identifies items by tag that have changed position and potentially even changed parent . For example if a data item initially associated with and displayed by a visual element in one list is moved to a second list so that the data item is associated with and displayed by a new visual element then the system correlates the two visual elements by tag and animates the movement of the data item from the first visual element to the second visual element using new position information about the second visual element and last known position information about the first visual element stored in the item dictionary . This allows animation of data item movement across visual elements through a declarative representation and generalized layout pass.

The animation component provides animation as a data items move in a visual display. For example a data item may move within a visual element e.g. sorting a list or may switch visual elements e.g. removal from one list and insertion in another throughout the lifetime of a displayed user interface. The animation component uses changes in position and parent information from the information stored by the item dictionary to detect movement at the data layer and animate the visual layer to reflect a data item s new representation. The animation component may provide any number of well known animation techniques such as fade in fade out using a timer to show an item at intermediate positions between two points over time and so forth.

The computing device on which the system is implemented may include a central processing unit memory input devices e.g. keyboard and pointing devices output devices e.g. display devices and storage devices e.g. disk drives or other non volatile storage media . The memory and storage devices are computer readable storage media that may be encoded with computer executable instructions e.g. software that implement or enable the system. In addition the data structures and message structures may be stored or transmitted via a data transmission medium such as a signal on a communication link. Various communication links may be used such as the Internet a local area network a wide area network a point to point dial up connection a cell phone network and so on.

Embodiments of the system may be implemented in various operating environments that include personal computers server computers handheld or laptop devices multiprocessor systems microprocessor based systems programmable consumer electronics digital cameras network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and so on. The computer systems may be cell phones personal digital assistants smart phones personal computers programmable consumer electronics digital cameras and so on.

The system may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures and so on that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

Continuing in block the system builds a dictionary that tracks one or more visual elements of the user interface defined in the declarative representation and one or more positions of the visual elements. For example the dictionary may include a table keyed by tags associated with each data item and assigned to visual elements associated with each data item. For example a chair in a product catalog may have a tag that is an object representing a data model of the chair that the system also assigns to visual elements that represent the chair. Continuing in block the system displays the visual elements tracked by the dictionary in one or more initial positions. The user interface may include controls for modifying the displayed layout such as check boxes that the user can check and uncheck buttons that modify the displayed layout when activated and so forth.

Continuing in decision block the system determines whether one or more displayed visual elements have changed. If the layout has changed then the system continues at block else the system loops to block to continue waiting for changes. Continuing in block the system updates the displayed visual elements as described further with reference to . During the update the system compares any new position of a visual element based on a tag associated with the visual element with any visual element in the dictionary that was similarly tagged to detect movement. If a movement is detected then the system provides an animated transition from the old position to the new position of the tagged item even if the visual element representing the item has changed. After block these steps conclude.

Continuing in decision block the component determines whether the visual element has an associated tag in the declarative representation. For example a user interface designer may label each visual element with an explicit tag. If the visual element does not have a tag then the component continues in block else the component jumps to block . Continuing in block the component generates a tag for the visual element. For example the component may use the visual element as its own tag. In some embodiments the declarative representation may specify that a particular visual element is tagged based on an associated data model. For example a list may specify that the items in the list provide a tag for each visual element related to an item.

Continuing in decision block the component determines whether the tag associated with the visual element is present in an index of visual elements and position information. If the tag is present in the index then the component continues at block else the component jumps to block . If execution continues to decision block the component determines whether an origin tag exists in the index. For example an origin tag may include an application icon or other well defined location from which the system will perform an animation transition. If the origin tag is found then the component continues at block else the component jumps to block . Continuing in block the component treats the identified origin tag s last position as the last position of the current visual for generating a transition animation. The system may also animate a visual element from its last location to a termination tag not shown in a similar manner e.g. moving an object to a recycle bin .

Alternatively if execution continues to decision block the component determines whether the visual element has a current parent that differs from a stored parent of a visual element in the index with a matching tag. If the visual element has a different parent then the component continues at block else the component jumps to block . For example if a user requests to move a visually represented data item from one list to another then the data item will be represented by an old visual element in the source list and a new visual element in the target list but both will have the same tag so that the old visual element and its last position can be identified in the index. Continuing in block the component transforms a position of the visual element in the index to a coordinate space of the current parent. This step is optional and is used when position coordinates stored in the index are relative to the parent of each visual element.

Continuing in decision block the component determines whether the data item s position has changed between a last position of the visual element in the index and a position of the visual element currently representing the data item. If the position has changed then the component continues at block else the component continues at block . Continuing in block the component creates a translation animation to smoothly move the data item from the last position of the visual element in the index to the position of the visual element currently representing the data item. For example the old position may specify the location of a visual element in a first list from which the data item was removed and the new position may specify the location of a visual element in a second list to which the data item was added. Continuing in block the component updates the index to associate the current parent and the current position with the visual element currently representing the data item. For example the component may use the common tag to update the entry associated with the tag with the new parent and position values. After block these steps conclude.

The table is built from all visuals that have been declaratively marked as participating in layout animation. A visual can mark itself as participating or it can alternatively mark all of its children as participating. When registering to participate the duration and timing curve can also be specified. After a layout pass which updates the positions of all visuals the system scans the positions of all visuals in the table and if any positions have changed the system starts an animation from the old position to the new position. The animation can also be built directly into the layout pass. The animations run in a transformation layer that sits above layout so the animation itself does not affect the table. An example of declarative markup for two visuals participating in layout animation follows.

The declarative animation system goes a step further and animates a visual as it changes layout position and tree position e.g. moving from the left list to the right list . The positions stored in the table are parent relative because if the parent changes position for any reason it will automatically bring all of its children with it. The table is expanded as follows 

If after a layout pass the visual is determined to have a new tree parent then the previous layout position is transformed from the coordinate space of the old parent into the coordinate space of the new parent. The transformed position is used to build the animation. In some embodiments to simplify this process the system adds a root relative layout position column to the table. The declarative markup for this stage is unchanged from that shown above.

In some embodiments the declarative animation system goes still further and replaces a visual identifier with a layout tag. Here the system modifies the left hand column of the table so that it can hold visuals or more abstract tags. Now when scanning participating visuals after a layout pass the system looks for a tag on the element and if no tag is present the element will serve as its own tag. Moreover in a data generated list the system will automatically generate a tag whose value is the data item used to generate that visual.

For example if in the application s data model Cilantro changes status from Like to Dislike the visuals pertaining to Cilantro in the Like list are deleted and a completely new set of visuals are spawned in the Dislike list. With the changes to the leftmost column this table contains sufficient information to produce an effective animation to the new position the new visual representation for Cilantro will appear to come from the last recorded position of the older visual representation. In some embodiments the system adds a last associated visual column to the table as well to manage element lifetime issues. The system can also animate a representation of the object in a layer above the other visuals this is useful for animating outside the clipping region of a ListBox for example. The declarative markup has two new properties added to it TagType which can be set to Element or DataContext and FloatAbove which may look like this 

In some embodiments the system animates a visual from a tagged origin point or towards a tagged termination point. With the described table of information it is possible to effectively animate the entrance and disappearance locations of visuals as well. The system adds properties to a visual signifying Tag I appear from and Tag I disappear to. Then when creating a visual the system can look in the table to find the place a visual is supposed to come from example an application should come from its icon . Similarly when destroying a visual the system can look in the table to find out where the visual is supposed to go example a file should go to the Recycle Bin . Following is simplified markup illustrating an additional TerminationLocation property.

In some embodiments the declarative animation system is implemented in an application programming interface API that developers can invoke to provide animations for their software applications. For example implementations of the animation system may be provided in the Silverlight 3.0 and Windows Presentation Foundation 4.0 APIs. The declarative animation system can also be integrated into a single software application or packaged differently in other APIs or graphics libraries as appropriate for a particular application.

In some embodiments the declarative animation system operates on some visual elements that use layout management alongside other visual elements that do not use layout management. For example a user interface may include elements positioned according to absolute coordinates alongside visual elements positioned relative to other visual elements. The system may animate changes to the relative positioned elements without affecting the absolute positioned elements. The system may also allow a designer to toggle the animation described herein on or off for a particular group of visual elements so that groups with the system on use the techniques described herein and groups with the system toggled off use traditional layout animation techniques.

In some embodiments the declarative animation system also handles transitions that are interrupted. A user interface layout may change to one state when a user toggles a button and another state when the user toggles the button again. If the user quickly toggles the button back and forth then the layout may be mid transition when the user s action reverses the transition. This system handles this smoothly by animating the layout according to the new final state by starting from the mid transition position. To do this the system may store intermediate positions in the item dictionary index.

In some embodiments the declarative animation system receives a property from the declarative representation for a visual element that causes transitions of the visual element to float above other elements. Because the system provides animation of data elements that move from one visual element to another visual element the system may interfere with traditional user interface notions of item parents receiving notification when their children change and so forth. Thus the system may allow the designer to specify that when the system animates a particular visual element transition the animation floats above other controls or visual elements of the user interface. The system may take a bitmap snapshot of the interface or elements within the interface and then superimpose the animated transition over other elements to reach the final position state of the user interface after the transition.

From the foregoing it will be appreciated that specific embodiments of the declarative animation system have been described herein for purposes of illustration but that various modifications may be made without deviating from the spirit and scope of the invention. For example although user interfaces are described herein as examples the system can also be used with other visual displays not necessarily intended for user input or interaction. For example the visual layout may change according to non user input such as movement of a device detected by a GPS chip in the device and so forth. Accordingly the invention is not limited except as by the appended claims.

