---

title: Serving software applications from servers to client computers
abstract: An application serving system is disclosed that comprises a target client computer that connects to a server system and subscribing institution host Web Server, over a network. Both the client computer Web server and server system implement a network protocol layer to communicate across the network. In a preferred embodiment, network is the Internet, or other public or private network, and the network protocol layers are implemented on top of TCP/IP or UDP/IP. Other network configurations and network protocols layers, however, could be implemented in place or in addition to the Internet such as wireless CDPD, GPRS, or other networks. The target, client computer is preferably a PC.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08612514&OS=08612514&RS=08612514
owner: Microsoft Corporation
number: 08612514
owner_city: Redmond
owner_country: US
publication_date: 20100830
---
This application is a continuation of U.S. patent application Ser. No. 12 062 038 filed Apr. 3 2008 which is a continuation of U.S. patent application Ser. No. 09 859 208 filed May 16 2001 now U.S. Pat. No. 7 370 071 which is a continuation in part of U.S. patent application Ser. No. 09 527 188 filed Mar. 17 2000 now U.S. Pat. No. 7 200 632 which is a continuation in part of U.S. patent application Ser. No. 09 456 181 filed Dec. 7 1999 which claims benefits of U.S. Provisional Application No. 60 128 828 filed Apr. 12 1999 the entire contents of which are herein incorporated by reference in their entireties.

Internet or network delivery of application program style functionality has become increasingly important. The ubiquitous client server platform typically requires that the front end application program code be loaded and installed on the client computers. This requirement however is viewed as substantially increasing the installation and maintenance costs associated with computer networks. Moreover many client operating system platforms are deemed unstable. Web delivery of applications programs would enable the code to be completely maintained on the server side.

Additionally there are a number of different business models that are pulling for network delivery of application program functionality. First it can be used in software sales. A web based software sales institution can utilize the Internet or other public network to allow customers to test drive the programs and thereby drive sales. A second justification for deployment arises in the thin client network computer model where the code required for the application level functionality and user data reside on the server side. In this situation when the application functionality is required at the thin client it is provided by the server on an as needed basis. These servers can even be off site in an application service provider ASP environment. Another justification surrounds the possibility to rent programs to users. A large number of potential users may have only limited requirements for certain classes of application programs. Their individual requirements may not justify investment in the typically expensive programs or not justify the costs of client installation. The thought here is to enable these users to rent access to the application programs preferably via the Internet to generate new revenue streams for the application software companies. Also software vendors are becoming more flexible in the terms offered for licensing their software. Servers and clients need to participate in supporting flexible licensing modes potentially even if the software being licensed does not internally support it.

One solution to providing application program functionality to the client computer via the network involves expanding the functionality of the browser. For example the term plug in is used to describe a browser code extension. ActiveX and Java are two of the most common extension platforms for the browser.

While the solution to provide application program functionality via the browser is attractive in its simplicity a number of problems exist under current technology. First providing sophisticated ActiveX and or Java functionality is still in its infancy and largely unproven. Further it ignores the wealth of existing stable application programs that have been written and are being written to run directly on the operating systems such as Windows 95 98 NT 2000 Unix Linux and Mac OS s.

Related but limited solutions attempt to allow potential buyers for example to test drive the program over the Internet. Typically one of two techniques have been used. First the selling institution may allow the potential owner to download a trial version of the program. This version may have reduced capabilities and or a limited lifetime. That is the program is disabled after it has been invoked a set number of times or after a specified date. Moreover the process is complex creating difficulty often requiring a multistep process in which the user must accept a download pick a save as location watch a download quit the browser find the file on the hard drive run an installer etc. Another technique is to extend the potential purchaser s browser in some fashion. For example a demonstration application often unrelated to the original in terms of application code can be downloaded that mimic s the operation or graphical user interface of the application program. The problem here however is coding these applets can be difficult and or time consuming and the experience is typically inferior to that offered by the real version of the application program.

Systems have been proffered to allow complete use of an application in a restricted mode or under licensing which requires a server to unlock the application for a client computer. Most of these systems have only dealt with the problem of restriction of the general license leaving the problem of distribution unsolved.

Against this backdrop most modern operating systems allow for the execution of code that is stored remotely from the client computer. The systems allow a client computer to mount a physically remote memory device such as a file server residing on a server or peer computer and execute the application program residing there. Typically however these capabilities of the operating system are only utilized within an institution where an umbrella of network management exercises control over both the clients and the servers to prevent corruption of data on the server side and configure the client computers to access the server stored code.

The present invention concerns an application program delivery system utilizing a helper application.

The present invention concerns a technique for enabling conventional remote networking to be maintained through non standard ports.

The above and other features of the invention including various novel details of construction and combinations of parts and other advantages will now be more particularly described with reference to the accompanying drawings and pointed out in the claims. It will be understood that the particular method and device embodying the invention are shown by way of illustration and not as a limitation of the invention. The principles and features of this invention may be employed in various and numerous embodiments without departing from the scope of the invention.

Generally the application serving system comprises the user target client computer that connects to a server system and subscribing institution host Web Server over a network .

Both client computer Web server and server system implement a network protocol layer to communicate across the network. In a preferred embodiment network is the Internet or other public or private network and the network protocol layers are implemented on top of TCP IP or UDP IP. Other network configurations and network protocols layers however could be implemented in place or in addition to the Internet such as wireless CDPD GPRS or other networks.

The target client computer is a PC computer in one implementation. It operates a Microsoft Windows 95 98 NT 2000 operating system on an Intel processor IBM compatible hardware platform. Other alternatives however are possible such as open source operating system platforms such as Linux or Apple NAC 03 s or other operating systems that provide an application programming interface API support for developers.

The target computer preferably has preinstalled application programs. In the present implementation a browser such as the ubiquitous Netscape Navigator or Microsoft Explorer browsers is used. Additionally the target computer also preferably has a helper application or software player . Such preinstallation can be performed typically at a website hosted by the institution that operates the server system or also the subscribing institution . The installation of the helper application can also be incorporated into the application serving process.

The subscribing institution which maintains the host web server can be a third party relative to the institution which maintains the server system in one anticipated business model. The subscribing institution has a requirement or desires to provide application programs to the user at the target computer but rather than providing this functionality itself the subscribing institution outsources this to the institution operating the server system . The subscribing institution however typically has an Internet presence. Specifically it will typically maintain a website websites that offer the application programs to users.

From one implementation the server system is maintained by an institution that provides application programs to users as a paid service to subscribing institutions.

Depending on the institution managing the target computer a firewall may be present between the target computer and the network .

Specifically the service institution s server system maintains a user account policy database a customer policy database an application configuration database and a database of current sessions . The server system additionally executes a session ID generator a load balancing process and an encryption process .

Nonetheless it should be appreciated that the technology of the present invention also has applicability to the business model where the server system and host Web server are maintained by the same institution or may even be one and the same machine. In this context the institution does not wish to out source the work associated with the serving of the applications to the user at the target computer but wishes to provide this functionality through in house expertise.

Selection of the link in step causes the browser to interrogate the target computer s operating system to determine whether the appropriate software player SWP has been installed on the target computer in step . This interrogation is performed in one embodiment by an API call to check the operating system registry. Applets ActiveX or scripting however are other modalities for performing the interrogation.

If it is determined that the software player has not been installed on the target computer an installation process is begun in step . In the typical implementation this installation process comprises either pointing the browser or a new instantiation of the browser with a new universal resource locator to website that supports the installation of the software player through a download for example.

The install download is made as simple as possible. A Java applet can be used that allows unattended installation if permission is provided. Preferably a download bar is displayed on the browser screen and then when the Player has installed it automatically begins to launch the application that was initially requested by the user. In this way the result to the user will remain launching the program asked for not just installing the system.

The SID referred to in the SEND step is a unique session ID that is specific to the link and the specific session. The SID is optionally used as an additional security token from the web site that identifies authentication has occurred for this specific session which may be cached. This is important for the rental subscription model where users with credit cards or user names and passwords are consistently authenticated. In addition other unique identifiers can be used in additional embodiments to assist with identifying users player components or other system features or configurable items. These identifiers can be used throughout the system in the way identified here as well as others. Authentication is not intended to be made secure by this method this can be done by other means such as cryptographic security obfuscation or other means though the SID can be used as a nonce in protocols that use them such as Kerberos.

Once there is an installed software player the browser is pointed with a URL to the server system in step . The URL link contains 1 a unique identifier associated by the server system with the application requested TitleId 2 an optional unique user ID SID described above and optionally 3 an identifier that identifies the subscribing institution SubInstId as well as other optional parameters. Typically the subscribing institution is the company that operates the host Web server computer which served the web page that originally contained the link associated with the application that was desired by the user of the target computer .

Specifically in step the server system receives the URL SID TitleId and SubInstId described with reference to . The server system then accesses the user database to verify that 1 the user at the target computer is a valid user by reference to the subscriber Id field SID or through authentication with the system using standard AAA protocols such as NTLM HTTP Basic Kerberos or other authentication means and 2 the subscribing institution is a currently valid subscribing institution by reference to the SubInstId field in step . If either the user or subscribing institution is invalid step an error is returned to the target computer in the step by the server system .

If the user and subscribing institution are verified the server system then proceeds to construct an application descriptor or data file that will coordinate the operation of the target computer and the server system across the network . In present implementation the application descriptor is a file that is named with a .WOW suffix or .OSD . In the case of the .WOW suffixed file its contents are plain text but the file is registered with a MIME type of application softwarewow so that the browser and helper applications may recognize it. In the case of the .OSD file it is an XML file containing much the same description but will be registered as type application softricity. The .OSD file can also be pregenerated and used directly by the client application without the need for on the fly generation. In this case the URL contained in the file will be used for authentication and connection establishment purposes only.

Specifically referring again to in step the server system accesses the customer database to obtain configuration information regarding the session.

Next in step the application descriptor is accessed. This contains information concerning the application which was requested by the user. For example the application descriptor contains such information as minimum system requirements RAM processing power etc. that are required by the application on the target computer the application media weight or processing requirements on the server system associated with each instantiation. In addition licensing and policy information is retrieved from the application database . This information is exchanged by the client and server in order to properly control the license and apply any dynamic policy configuration changes.

Next in step the load balancing process is optionally executed. The server system selects a host computer within the server system that will be primarily responsible for serving the application over the network to the target computer . In the typical embodiment the server system comprises multiple host Web servers. The selected host computer is co located with the other host computers in one implementation alternatively components or servers of the server system are located in a server farm and or geographically local to the target computer . The load balancing process selects the host computer based on geographic proximity to reduce latency. As will be understood by those of skill in the art the load balancing step can also be done later by an external load balancing system. Typically load balancing checks the current session database to determine which host server in the server system has the least load. The list of servers serving the specific application is part of the title s application description. Determination of which server to use is based on the number of concurrent connections to each server and the media weight of each application and also the user s physical geographic location based on the IP address.

Next the current sessions database shown in is updated in step shown in with the current session being added. Specifically the session ID the user s IP internet protocol address the application title the media weight and the server assigned to the session is added as well as licensing information required to maintain proper license control. This license information can include the actual named license key if the software is used in that way or it will use the session ID as a count for concurrent usage limits. Other licensing schemes are all controlled in this database. This database is also used by the load balancing process and optionally by a watch dog process that watches the connections to each host server in the server system to verify that all connections are from authorized users.

In step the application descriptor can be encrypted. Minimally this application descriptor comprises the host address of the host computer of the server system plus the remainder of the URL needed to access the desired application. Finally the application descriptor is sent to the target computer in step .

Referring now to the launch process for the helper application or software player is shown. Upon receiving the application descriptor file the client launches the software player in step . This is a helper application that completes the bulk of the client side application management. In a preferred implementation the receipt or selection double click of the descriptor file automatically launches the software player. This is accomplished by configuration of MIME types during the software player s initial installation. In the Windows 95 operating system MIME types are set in the registry associating files with a specified suffix here WOW or OSD prefix to be opened with the software player .

In step the registration status of the software player with respect to the server system or institution operating the system is determined. It may be required by the institution that each software player be uniquely registered within its database. If it has not been registered and or properly licensed a registration box is displayed on the graphical user interface of the target computer in step . The user is either requested or required to complete the registration information box depending on the implementation. Once completed the registration information is sent in step to the server system over network .

After registration the status of any firewall proxy for firewall is interrogated in step . If it is not valid a proxy information dialog box is displayed in step and the user is requested to complete it on the target computer . Once completed the proxy information is updated in step .

Next the status of the application descriptor is interrogated in step . If no application descriptor file is detected a dialog is generated in step on the target computer for the user. The user is requested to enter a partner or subscribing institution. If it is determined that no institution has been entered in step the process aborts. However if a subscribing institution was entered the process similarly aborts in step but also points the browser to the Web page for the subscribing institution in step . Next at step it is interrogated as to whether the client is monitoring a similar process i.e. the software player is currently running on the client. If it is not running the SWP window is created in step . Depending on the run mode and the configuration of the SWP the window is either hidden or visible on the client interface. In one embodiment the SWP is never visible or is only visible as a system tray icon on Microsoft Windows operating systems.

In step any system setup and or clean up is performed. Generally the operating system registry is written to when applications are run. In one embodiment the software player tracks those modifications and any registry changes these changes are undone when the application and software player are quit. However if the software player was terminated unexpected during its last operation the registry clean up may not have been performed. If not the clean up occurs in this step. Specifically any modified registry settings are returned icons are removed folders in any disk drive are removed and any new copies of applications on desktop are removed. In a preferred embodiment an Operating System Guard is used such as that described in and commonly assigned U.S. patent application Ser. No. 09 859 208 filed May 16 2001 now U.S. Pat. No. 7 370 071 and incorporated herein by reference. The Operating System Guard can be loaded with an application s settings and guaranteed proper operation and cleanup. Next the player is set up on the OS tray. If it is determined that the SWP is currently monitoring a process and thus invoked in step the status of the target computer operating system is interrogated in step . If too many applications are currently running a dialog is generated notifying the user in step and the process aborts in step . However if there are sufficient resources to run the application the new launch application process is started in step .

Specifically the software player reads and potentially decrypts the incoming application descriptor file. To read in the encrypted data the application can utilize publicly available encryption schemes such as DES or an internal private key system specific to the embodiment.

Once decrypted the software player checks to see if this is the first time it has been run on the client computer by checking the computer s internal settings to see if a unique ID has been written to the settings. This is done on Windows by querying the Registry for a specified key. If it finds the unique ID it continues. If it does not find a unique ID it can ask the user for personal information that will be collected for a User Database in one implementation.

It then creates a data structure in step . The version of the application descriptor is then compared to the version of the software player in step to ensure compatibility. If there is an incompatibility or available upgrade a dialog is displayed in step asking the user if they wish to upgrade to a new software player or obtain the new components. If the user agrees to upgrade the new components dynamic link libraries .DLL s in one embodiment are downloaded from the server system in step . The software player unloads the current dynamic link libraries and updates the DLL s in step . In contrast if the user chooses not to install the new software player in step the process aborts in step if the player will be unable to process the application while simultaneously pointing the browser to an upgrade URL hosted by the server system or hosted by another server in step .

If the process is not aborted in step the application requirements contained in the application description are compared to the target computer s configuration in step . If there are inadequate resources the process aborts in step . Additionally the browser is pointed toward a web page hosted by the server system providing for maintenance. Specifically the maintenance URL is passed to the browser in step . For example a minimum or maximum screen depth resolution RAM requirements processor requirements sound board requirements and video board requirements are assessed. These checks are made by querying the necessary API for the operating system in question. If the resources are inadequate the error which is generated can be displayed to the user or alternately transmitted to the server whereas the server may be connected to the hosting institution s CRM or help desk application to which the error is forwarded and potentially the user automatically connected.

If the user system s resources are determined to be adequate in step a message is sent from the target client computer to the server system over the network in step . The message contains the session ID which was received from the server system in the application descriptor file. Also a start request message is sent to the server system. The receipt of the session ID identifies the session and licitly notifies the server system that the target computer has successfully opened the application descriptor file which had been previously sent. The start request indicates that the target client computer is now ready to begin to execute the requested application. At this time the client and server can setup network resources dynamically configuring to penetrate firewalls and exchange any further needed information about the connection or process.

Also the software player also preferably determines via the application descriptor or through exchange with the server the transaction or licensing mode being used. This can impact the appearance of the player on the screen or GUI of the computer in one embodiment. For example if the application descriptor says it is an advertisement based transaction then the software player will respond by positioning itself at the top level of the screen depth and begin to request advertisements from an advertisement server over the network. Conversely if the application descriptor says it is a subscription based the software player will hide itself but continue to work in the background. The ads are most commonly obtained through HTTP calls to a networked ad server. If the client receives notification of a need for a license it will communicate again with the server to obtain and set the license on behalf of the client.

In step the target client computer then waits for a start request acknowledgment from the server system . If no acknowledgment is received after a predetermined time period a dialog is displayed on the target client computer to notify the user that the server system is currently unavailable in step .

If the start request is acknowledged in step by the server system a proxy socket is optionally opened in the target computer and the application server address is passed to the proxy in step . If the proxy application is integral to the SWP the data is passed through a function call or other data structure.

Referring now to in step the software player attempts to create a virtual environment on the target computer simulating that of the application when it is correctly installed. The player first determines if any files are required from the server system to initiate the launch process. If files are required they can be obtained by initiating a drive mounting process in step . Alternatively the files can be obtained using a local file installation and replace process in step . Additionally both processes could be used if multiple files are required. In the preferred embodiment files are not installed or replaced on the target computer. At first the virtual environment will install a symbolic link in lieu of the file. At the time the file is needed it is serviced by the remote server or from a local file cache.

Certain applications require specific files at specific locations. For example certain anti virus programs require virus definitions to exist at specific path. Such hard coded path requirements are addressed in this initial configuration check. A file check is performed and any required files are installed in the manner listed above. If necessary all or part of the file can be transmitted to the client computer before the application is launched.

With the above process the target client computer now has access to the files and specifically the code required to invoke the selected application. Next in step the directory is set to the drive and path of the application and the run command is issued to the host server.

In one embodiment standard Windows remote networking methods are used to attach to the server s directory using the available Windows Networking API. This will invoke a series of SMB messages over NetBIOS and TCP IP. If the client computer is running the Windows 95 version operating system there is an additional step taken here. Since Windows 95 computers need to have the name of the server they are attaching to in a file in the Windows directory called LMHOST the software player writes the name of the server to the LMHOST file using standard file I O techniques. In a preferred embodiment the client can attach a local hardware facility to the remote server allowing the application to appear local whereas the client server communication can be done using any networking protocol agreed upon. The local client computer will function with a simulated local memory device or hard drive with a remote connection to the server s own application container. The server can then transmit or stream needed bits of the applications files and configuration to the client s local memory.

The software player then waits for the application window and the update of the stream display. The window status is acquired by reference to the operating system application programming interface. In a preferred embodiment where it is operating on a Windows OS platform the window status is obtained via the Windows API in step . The stream data size is obtained from the proxy application in step . In step it is interrogated as to whether or not the application window has opened. Until the window opens the host server in the server system is periodically pinged. The window timeout is reset as many as three times and as long as the server is responsive to the ping in step . If there is no server response to the ping as determined in step the user is notified via the dialog in step and the program aborts in step . If however the window opens as determined in step the user interface elements are activated which are specific to the application in step . The size and position of the software player and application windows can then be set in step . At this stage with the application running on the operating system of the target client computer the process proceeds to an application monitoring in step .

In a preferred embodiment of the present invention there are six processes that are performed to monitor the application application window process monitoring tracking pulse monitoring advertising updating net traffic monitoring countdown timing and user event handling. illustrates the steps associated with application window process monitor process and the tracking pulse process. Specifically while the selected application is executing the client computer multitasks to also monitor the operation of the application. One of the processes is the application window process monitor process . Specifically the application monitor process periodically makes API calls to determine whether or not the application s window is still open in step and if the application has spawned any child processes. If the window is open or the child process is still functioning it can maintain and or set the position and layer of the windows of the application and the software player with respect to each other in step according to the transaction mode. However if the application monitor process determines that the application window has closed the software player begins the execution of a shutdown process .

The tracking pulse process periodically sends a pulse or a ping to the host server of the server system in step . If it is determined that no pulse has been received in step the target client computer pings the host server of the server system in step . Based on the status of the ping if it is determined that there is no connection to the server the client will attempt to reestablish communications and its session with the server. If the reestablishment is unsuccessful the client may reattempt to establish its session with another server. If none of these attempts are successful a dialog is generated in step and there is a forced shutdown of the application process in step and again the shutdown process is activated . If the ping is successfully sent to the server but no response is received a dialog is generated in step . Again a no response dialog is generated in step and the shut down process is activated in step .

In other implementations tracking is not provided by sending pulses instead the application server monitors socket connections to determine if the user is still connected. From the client side instead of the server telling the client to shut down the client gets its total time to run as part of the descriptor file and authorization process and begins counting down and eventually shuts down once it hits zero time. Additionally in this implementation the client can re authorize to obtain more time from the server to reset the countdown time. Any time returned by the server is added to the currently remaining run time held by the client. In contrast if it is determined that the pulse is received in step the message is analyzed. If it is determined that the message is to turn off the application in step the application process is terminated in step and the shut down process is activated step . If the message returned that the application must be terminated within n minutes a dialog is generated in step notifying the user of the remaining minutes of access to the application. A countdown timer is started in step . Finally if the message returned is an all clear or OK message in step the process returns.

Step monitors network activity and notifies the net traffic monitoring process in step . This allows the application monitor to determine if there are any problems associated with high traffic which would impact the operation of the application. This is potentially useful as feedback or input to the network transmission layer for maintenance of quality of service for the application. In step the display countdown timer is updated. This countdown timer notifies the user as to the time remaining in which the application is available. This is most relevant where the user has for example rented the application for a fixed period of time as indicated by the transaction mode. The countdown timer updates the countdown timer process so that a shut down process is automatically activated when the timer has timed out.

Currently the bookmarking feature is termed Quick Launch instead of adding it to the start menu folder system it gets book marked as part of a screen in the player the the one that comes up if you click on Quick Launch. It remembers the location from where you initially clicked thus guaranteeing the web site that they will still get ad revenue and a follow up page each time the user clicks on the Quick Launch bookmark.

If the help button is selected in step a help file is displayed. The browser is pointed to a URL of a help file server in step . If the third party home is selected in step the browser is pointed to the URL or a specified URL of the subscribing institution in step . If the home button is selected in step the browser is pointed to the home page of the third party application hosting system in step . If the advertisement is selected in step the browser is pointed to the URL of the advertising company in step . Finally if the quit button is selected in step the application is forced to terminate in step and the shutdown process is started in step .

Finally in one embodiment a follow up URL can be sent to the browser in step . In this embodiment this follow up URL is for the subscribing institution and typically hosted by the web server allowing it to follow with a sales pitch or to solicit for further purchase of services. This allows in some implementations the third party application hosting to be transparent to the user at the target computer. Finally any remaining monitoring processes are identified in step and the monitoring processes are terminated in step . In step the proxy application is quit and the software player is shut down in step .

Finally in certain embodiments a port proxy application is started prior to the application launch process. Generally the port proxy application is required because of two factors. First one embodiment of the present invention utilizes standard Microsoft Windows 95 98 NT 2000 operating system networking protocol implementation of SMB server message block . This standard protocol operates over port . However since it is a sharing protocol it is deemed dangerous or non secure and communications through this port are blocked by many commercial government corporate firewalls. Second the preferred embodiment and all other possible embodiments observe the same issues in attempting to traverse corporate firewalls. Most ports are blocked for client server communication and ways must be found to interoperate through the firewall.

Generally port is not blocked either at the client level by modifications to the client operating system or by the firewall as most other ports are typically blocked. The port proxy allows to the application to execute as if it were mounting a standard server using its native protocol. Communications however are actually occurring over port of the client computer .

The use of the port proxy and port communications requires that the operating system of the host server in the server system is non standard. In one implementation the server code has been recompiled to support SMB communications over port instead of port . In the preferred embodiment the server will support connections on static as well as dynamically negotiated ports including port . This dynamic negotiation is done on a per session basis.

One further fix up is required to ensure that communications are supported through port . Some firewall systems monitor all traffic on ports. Some of these proxies will block any non HTTP traffic on port . According to the invention the client server communications are encapsulated in HTTP packets by adding an HTTP header. In summary the standard communications are converted to the HTTP protocol by the port proxy before being passed to the operating system at the client . As a result communications from the client through the client s local area network will pass through existing firewall systems to the Internet . In an additional configuration the HTTP connection can use advanced encoding modes to stream communications from client to server eliminating the need to constantly regenerate header packets thereby reducing network overhead and latency. Alternatively the proxy application on the client can reroute traffic through port FTP with the server returning on port also reserved for FTP transfer in another embodiment if those ports are open or through any available set of ports.

While this invention has been particularly shown and described with references to preferred embodiments thereof it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the scope of the invention encompassed by the appended claims.

