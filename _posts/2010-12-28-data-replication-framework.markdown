---

title: Data replication framework
abstract: Generally described, the present disclosure is directed to an eventually consistent replicated data store that uses, for its underlying storage, a computer software library that provides a high-performance embedded database for data. The replicated data store employs a plurality of hosts interconnected to one another, allowing for writes to any host and full awareness of membership across all hosts. With the data replication framework disclosed herein, various modes are allowed to be built up on top of the core system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09449065&OS=09449065&RS=09449065
owner: Amazon Technologies, Inc.
number: 09449065
owner_city: Seattle
owner_country: US
publication_date: 20101228
---
Generally described replication is a set of technologies for copying and distributing data and database objects from one database to another and then synchronizing between databases to maintain consistency. Using replication data may be distributed to different locations and to remote or mobile users over local and wide area networks dial up connections wireless connections and publicly accessible networks of networks such as the Internet.

Transactional replication can be used to replicate transactional data such as a database or other form of transactional storage structure. Database replication can be used to describe scenarios in which database management systems attempt to replicate data in order to ensure consistency between redundant resources. Database replication can commonly be associated with master slave relationship between the original and the copies. In a master slave relationship one database may be regarded as the authoritative source of data and the slave databases are synchronized to it. The master logs the updates and the updates are then sent to the slaves in order to synchronize them. The slave outputs a message stating that it has received the update successfully thus allowing the sending and potentially re sending until successfully applied of subsequent updates.

Multi master replication where updates can be submitted to any database node and are then sent through to other servers for synchronization is often desired but may introduce substantially increased costs and complexity which may make it impractical in some situations. One common challenge that exists in multi master replication is transactional conflict prevention or resolution. Most synchronous replication solutions do conflict prevention. Conflict prevention is typically accomplished by not considering a write operation completed until an acknowledgement is received by both the local and remote databases. Further writes wait until the previous write transaction is completed before proceeding. Most asynchronous solutions do conflict resolution. Conflict resolution is typically accomplished by considering a write operation completed as soon as the local database acknowledges the write. Remote databases are updated but not necessarily at the same time. For example if a record is changed on two nodes simultaneously a synchronous replication system would detect the conflict before confirming the commit and would abort one of the transactions. An asynchronous replication system would allow both transactions to commit and would run a conflict resolution during resynchronization. The resolution of such a conflict may be based on a timestamp of the transaction on the hierarchy of the origin nodes or on more complex logic.

Database replication becomes difficult when the number of databases and or the locations between the databases increases. Typically a centralized relational database may be used to store data for a variety of services across several hosts. In such a system a simple request for data would be sent to all the hosts and each of the hosts would need to access the relational database to obtain the requested data. The plurality of access requests to the centralized relational database may strain the database. One solution has been to use localized caches on the hosts to reduce the number of access requests to the centralized database. The localized caches typically store local copies of frequently accessed data thereby reducing the number of access requests to the centralized database. The use of caches may thus allow for some scalability. However as the data requirements grow and larger caches are needed there may be issues such as shortage of random access memory RAM . The use of multiple caches may create coherency issues. Sticky routing may not always be applicable to such systems. When the number of hosts and associated caches is scaled to a large enough number the centralized relational database may simply get overloaded and become unresponsive.

One possible solution to the overloading of a centralized relational database has been to scale with partitions. Caches on the hosts may be partitioned to access multiple relational databases. However such a solution does not really improve availability since the two databases are not replicates of one another. Overall basic caching is not ideal since cache parameters require tuning partitioning becomes a necessity use of more partitions means more failures and availability is not improved.

Generally described the present disclosure is directed to an eventually consistent replicated data store that uses for its underlying storage a computer software library that provides a high performance embedded database for data. The replicated data store employs a plurality of hosts interconnected to one another allowing for writes to any host and full awareness of membership across all hosts. With the data replication framework disclosed herein various modes are allowed to be built up on top of the core system. For example a partitioning strategy may be built on top of the system. An authoritative store may also be built on top of the system. The underlying data replication framework storage does not need to change for new features to be added and multiple layers can be utilized at the same time.

Specifically in one aspect the data replication framework can maintain a network of interconnected hosts with updated membership state information across the hosts without the use of a centralized storage system. In another aspect the data replication framework can implement storage agnostic data replication across the network of interconnected hosts where membership information is taken into consideration for replication strategies. In another aspect the data replication framework enables consistent data replication across the network of hosts using features such as version numbers of data records and hosts acting as redundant senders of data. In another aspect access requests for data from the hosts can be dynamically routed to perform load balancing.

Although various aspects of the disclosure will be described with regard to illustrative examples and embodiments one skilled in the art will appreciate that the disclosed embodiments and examples should not be construed as limiting.

The core replication system described herein runs on a cluster of hosts. The hosts are interconnected and each host is aware of the existence of each other host. The cache on each of the hosts is a complete copy of the data. Such a system provides for both better availability and better scalability.

Illustratively the framework supports relational queries from any one of the hosts A N. Data is replicated on each of the hosts A N on the local data store A N. Each of the local data stores A N may consist of a computer software library that provides a high performance embedded database for data. As will be described below the plurality of hosts A N are interconnected such that each host is aware of the existence of each other host. In some embodiments the data replication framework may also be in communication with an external relational data store for authoritative storage.

As illustrated in when an access request for data is received at the data replication framework the data is locally read at one of the hosts A N. There is no need for an access request from the hosts A N to a centralized relational database for a data read since each of the hosts A N includes a local data store A N including a replicate of all of the data that would be stored at the centralized relational database . In this framework if the centralized relational database were to become unavailable data would still be available to be read at any one of the hosts A N. Additionally the number of hosts may be scaled to any number independent of the capacity of the relational database .

Illustratively persistent replication includes propagating data from one host to other hosts and receiving acknowledgments from the other hosts. When an acknowledgment is not received by one of the hosts the sender retries to send the data until an acknowledgment is received. However acknowledgments may be lost and or data changes may arrive to hosts out of order. The data replication from one host to other hosts implemented by different embodiments of the data replication framework may be performed in conjunction with several features to improve the consistency and availability of data across the hosts. Some examples of these features may include the use of version numbers associated with the data being replicated the use of recorders associated with the transmission of data between hosts.

For illustrative purposes let us continue with the example above but assuming there are a total of 4 hosts for simplicity of description. Host B receives data indicating that the price of a given article is 4.95. Host B then sends this article price to hosts A C and D. Host B receives acknowledgments from hosts A and C but not host D. Therefore host B retries to send the article price to host D. However assume that between the time of the send and the retry host B receives data indicating that the price of the article is now 1.49. Host B sends this data to hosts A C and D. Then host B retries sending the price of 4.95 to host D and this time host D acknowledges receipt. Now hosts A C have data indicating 1.49 for the price of the article while host D has 4.95. This creates an inconsistent group of hosts.

In some embodiments of the data replication framework the inconsistency of data across hosts such as for example the inconsistent article price above may be addressed by the use of version numbers for data records. Accordingly in an illustrative embodiment data records may be given a version number which is incremented with each update. If a host A N receives a change of data for a record with an older version number than the version locally stored then the host A N would reject the data record. In some embodiments the version numbers for the records may be provided by the centralized relational database . The generation and use of version numbers is described in further detail below.

Returning to the example above this time with the use of version numbers host B receives data indicating that the price of a given article is 4.95 and this price would be associated with a version 1. Host B then sends this article price and version number to hosts A C and D. Host B receives acknowledgments from hosts A and C but not host D. Therefore host B retries to send the article price with version number 1 to host D. However assume again that between the time of the first send and the second try host B receives data indicating that the price of the article is now 1.49 associated with a version number 2. Host B sends this price and version number to hosts A C and D and receives acknowledgments from hosts A C and D. Then host B retries sending the price of 4.95 with version 1 to host D. Host D has a locally stored price of 1.49 with a version number 2 associated with it and therefore host D rejects the price of 4.95 with version number 1 and sends an acknowledgment to host B. Now hosts A D have data indicating 1.49 for the price of the article. This creates consistent data across the group of hosts.

The data replication framework may include functionalities such as continuous monitoring of the unavailable host. The continuous monitoring of the unavailable host helps to determine when data should be resent to that host. The continuous monitoring of the host also helps to determine when to declare that host permanently unavailable. Details about the implementation of the continuous monitoring are described further below.

In other embodiments the host sending data such as host B in the example above may become temporarily unavailable during sending or at any other time or the sender host s memory may reach capacity. These situations may also cause inconsistent data replication across the hosts. In some embodiments the data replication framework may include recorders. Recorders are hosts that are responsible for recording data being sent from a host so that the recorders can later provide the data to the sending host if the sending host becomes temporarily unavailable. Recorders also receive the acknowledgments from other hosts for the original sender. The use of recorders enables consistent replication across hosts A N.

Continuing with the example above hosts A D had a price of 1.49 with version number 2 on the local stores A D. Let us suppose that host A then receives a price of 2.34 for the article with a version number 3. Host A writes this price of 2.34 to its local data store A see . Host A will also want to replicate this data to hosts B D. In embodiments where at least one recorder is used host A sends the data to hosts B D and selects at least one of the hosts say host B as the recorder. Host A may receive acknowledgments from host B and C but not host D. Then the host A may become temporarily unavailable. At that point host B would take over for A and resend the price of 2.34 to host D. Host B as recorder would also keep track of acknowledgments received from host D. Then when host A becomes available again Recorder B sends the acknowledgment information received from host D to host A. Through the use of the recorder the data change received by host A is successfully replicated to other hosts even when host A becomes temporarily unavailable. Also the acknowledgments are received by the host A and therefore the changes are not attempted to be sent after the host A becomes available.

A recorder provides redundancy for the sender. Recorders are picked for each change that will persist if the host A N that originally received the change goes down as well as to receive additional acknowledgments from all hosts A N that they have received the change. Recorders are described in further detail below in connection with the description of the data replication algorithm.

In yet another aspect the data replication framework can facilitate the adding new hosts as group members without having to stop read and or write operations on existing hosts and without losing data changes across the existing hosts. A new host added subscribes to the group of hosts A N. Data existing at the hosts A N is copied in one write operation from one of the peer hosts to the newly joining host while the hosts A N continue to accept any new changes. A full change history of all changes made to the data such as the several different versions of the price of an article in the example above need not be kept at any of the hosts A N.

To illustrate the addition of a new member or host let us continue with the example above where the group of existing hosts are hosts A D. Each of hosts A D is aware of its respective peers members. Host A has peers B C and D. Host B has peers A C and D. host C has peers A B and D. Host D has peers A B and C. Then assume a new host E joins the group. Host E may be added to the list of peers for any one of the existing hosts A D. Say it is added to the list of peers for host A. The updated list of peers membership is replicated from host A to hosts B C and D. Then the data on host A is cloned onto host E. Host E sends an indication of readiness to hosts A D. The new changes arriving to hosts D are recorded but not yet sent to host E. These changes are sent after host E has been restored.

In still further embodiments the data replication framework can facilitate consistency in scenarios where one of hosts B or C becomes temporarily unavailable before receiving the updated list of peers membership from host A in the example above. The data replication framework enables membership and replication strategies to be separate from one another through the use of a server registry and a membership module as well as a data replication algorithm as will be described in reference to below. When new hosts join a group of existing hosts there may be situations where races are created and there may be risks of changes being lost. The changes acknowledged from the newly joined host remain and a purge message is sent when durable as a checkpoint. Then the list of peers membership is passed with the purge message. The use of purge messages is described in further detail below.

Continuing the example above assume host B becomes temporarily unavailable. Host A sends a purge message of acknowledged changes for membership of hosts A E to hosts A C E. Then host B becomes available again. When host A attempts to send a purge message of acknowledged changes for membership of hosts A E to host B host B realizes that it needs to update its roster. Then host B updates its roster adding host E to it and sends an acknowledgment to host E. Then host A successfully sends the purge change message to host B.

One skilled in the relevant art will appreciate that the data replication framework can be associated with various additional computing resources such additional computing devices for administration of content and resources and the like. Additionally although the server registry the membership module the data replication algorithm module the query analysis module and the dynamic request routing module are logically connected to the hosts A N these modules may be geographically distributed throughout a communication network in a manner to best serve various demographics of hosts A N.

As illustrated in the server registry may include a member store interface to exchange membership state in the member store of the membership module . The server registry may also include a replicated data store interface to remotely persist changes to the core replication interface . The server registry may also include a direct replication interface to remotely persist changes to a specific member s data store A N. These interfaces and provide the core query and update methods. Illustratively the core replication interface coordinates all replication interaction and accesses the membership agent of the membership module . The membership agent persists state via the member store which in turn persists into the same data store as used by the data stores A N.

In an illustrative embodiment the member store in communication with the membership agent persists known group host members A N and their state. The state of a host member A N may be for example eligible or ineligible. A host may be considered ineligible when it is temporarily or permanently unavailable. The member store shares the same data store as that used for data storage on the hosts A N. In other embodiments the data store for the member store may be separate. A logical mapping may be used to persist member state although it is indexed too. The member store maps member ID to network address and a state where address may be an IP host name plus a TCP port. Member ID may be a randomly chosen ID. Additional fields persisted in the record may include the peer restoration parent a last modified timestamp and an optional timestamp indicating when a member became incommunicado. Illustratively a record exists for a given member ID but multiple records may exist with the same network address. This allows data stores A N to be migrated to different hosts A N and also allows dynamically assigned addresses to change. When a member connection to an address is confirmed all other member records with that same address are deleted from the member store . The membership agent is responsible for replicating member stores in a way to ensure that the stores are ultimately consistent with each other.

When a member state indicates eligible then the member is considered a valid member of the replication group. All changes are replicated to all eligible members. If a member is temporarily ineligible changes will be replicated to that member when it becomes eligible again. If a member is ineligible for an extended period of time the member will be marked as permanently ineligible. All pending changes for that member can be safely discarded. A member state cannot transition backwards from being permanently ineligible to being eligible because pending changes will be permanently lost. Members marked as permanently unavailable must acquire a new identity a new ID and then restore all data from an eligible peer. Once a permanently unavailable member record is created in the member store the only way for this record to be deleted is if the address is re used for another member ID. A timestamp may be stored for each permanently unavailable member record. The permanently unavailable member records which exceed a maximum threshold of time such as for example over a year may be deleted. In various embodiments the length of time may be configurable and may be shorter or longer than a year.

Another property stored in the record of the member store is a timestamp indicating when a member started to be unavailable. The actual member state is still eligible until the membership agent declares it to be permanently unavailable. Persisting the unavailable timestamp allows the membership agent to continue determining the availability of the member from where it left off in case the member becomes available again. If the grace period has expired for example if the membership agent was off for too long the unavailable timestamp is reset to the current time.

The membership agent gets notified when member sessions are created and lost. The membership agent is responsible for replicating the member store between all the member sessions and it is responsible for declaring members as permanently unavailable. Because the membership roster is fully replicated among all group members A N a new member only needs to connect to one seed member. This is how the data replication framework performs member discovery. The roster is replicated to the new member and the new member is replicated to all the existing members. The new member does not need the seed anymore because it has locally persisted the entire roster. Even though the data replication framework can be configured with multiple seed hosts these hosts might disappear when they are released. The loss of seed hosts will not affect existing group members but it will prevent new members from joining. The seed host set will need to be updated to include members which are currently available. Seeding via a central database lookup or via multicast or via a pluggable discovery mechanism are other possibilities in other embodiments.

At block when an eligible host connection is established to the server registry the server registry receives the services of that host. At block the server registry generates a hash table of the remotely addressable services on the hosts. The table may include references or identifiers for remote objects available to the hosts. The table may also include all other connection information necessary for the hosts to access the remote objects. When a host connection becomes ineligible the server registry removes the services of that host from the table. At block the server registry distributes the hash table to all other eligible hosts. When a host connection is established the server registry instructs all existing host sessions A N to connect to the new host. When a host connection is lost or removed because of a host becoming ineligible the server registry instructs all eligible hosts to not connect to the ineligible host. This forms a fully connected mesh network between all hosts A N where all the hosts A N are fully interconnected to one another. The server registry thus acts like a directory service without a central server it floats among hosts themselves.

As described in reference to above host members A N are uniquely identified and can be remotely accessed. All members are aware of the existence of their peers and they routinely check to ensure their availability. At block the membership module listens for new member session connections. If a new member connects the membership module ensures that membership information is persisted along with the data replication framework s data store and any membership changes are replicated to all other members A N at block . In an illustrative embodiment a new member need only connect to one host or seed to access the entire membership roster and become an equal member of the group.

At block the membership module verifies whether a member connection has been lost. If it has not been lost the membership module continues to replicate the member store between member sessions block . However if the member connection has been lost at block the membership module attempts a reconnect and or verifies whether the remote member has attempted to reconnect. If the reconnect is successful at block the membership module continues to replicate the member store between member sessions block . However if the reconnect is unsuccessful the membership module continues to attempt to reconnect and or verify for attempts to reconnect from the remote host for a threshold amount of time at block . If within that threshold of time the reconnection is successful the membership module continues to replicate the member store between member sessions block . However if the reconnect attempts are unsuccessful after the threshold amount of time has been exceeded the member may be declared permanently unavailable. This process is described further in connection with below.

When a member detects that another has been unavailable for too long it can declare it to be permanently unavailable. Once a member has been declared permanently unavailable any pending updates to it can be safely discarded. Should the permanently unavailable member attempt to join the group again it is denied membership. The permanently unavailable member s data store is considered to be too stale and it needs to generate a new identity and be restored from one of the available peers. Detection of temporarily and permanently unavailable members is described in further detail below.

As described briefly in connection with above the data replication framework is designed to ensure that data is ultimately consistent across all hosts A N. In some embodiments the data replication framework may also support additional features to further improve consistency. Returning to changes replicated at block may be done by employing various replication strategies. In some embodiments an at least once strategy may be employed where a given change may be repeated more than once. In various embodiments the change may be replicated twice three times or more. In some embodiments record version numbers may also be used to decide if an incoming change is stale and should be rejected.

In addition in some embodiments before or after verifying the remote host is up at block the data replication algorithm may designate one of the hosts as a recorder. The data replication framework can be thought of as having two types of message streams each of which deliver changes from one peer host A N to another. The first type of message stream may be a live stream which includes changes created on a group member the change sender for delivery to the available group members. The recipients of these changes are either recording or non recording receivers. The second type of message stream may be a standby stream which includes changes that were not delivered as a part of the live stream and are delivered via the standby stream. The bulk of the standby changes occur on account of an unavailable member A N missing changes that were delivered as a part of the live stream. Also live stream messages that suffer from transmission issues either in change delivery or acknowledgment receipt get resent as a part of the standby stream. Transmission of standby streams may be initiated by the change sender or the designated recorder.

Change operations may utilize record version numbers for reconciling conflicts. If a change operation is received against a record version number older than what exists in the data store A N it can be rejected. Several types of core operations may be performed on data records received during data replication depending on designations associated with the data type key value and version. For example in a STORE operation a record may be forcibly stored by deleting any existing record. The given record version number is assigned to the newly stored record. In an UPDATE operation a record may be inserted or updated. If a record already exists the given record version number must be larger than the existing record version. In a PURGE operation a record may be forcibly deleted by its key ignoring any record version number. In a DELETE operation a record may be deleted by its key. If a record already exists the given record version number must be larger or equal to the existing record version. In a TRUNCATE operation all records may be forcibly deleted for a given type.

Record version numbers may be compared using modulo arithmetic. This may allow them to wrap around without affecting the comparison provided that the difference between the values is less than 2. In some embodiments timestamps may be used as version numbers. In some embodiments record version numbers can be incremented with the help of an external database. In such embodiments timestamps need not be used for record version numbers.

The data replication framework provides for direct replication to peers A N. All members within a replication group maintain connections to each other. Remote calls can be made directly to any member even asynchronous calls. The membership agent provides a list of eligible members and also notes which are unavailable. Direct replication is basically implemented by sending a change to each available member asynchronously. A change set can be sent from any member and this same member the sender is responsible for directly replicating the change to all peers in the group. It does this by issuing a simple remote method call. Since a peer can be unavailable the sender is responsible for resending the change set when the peer becomes available again. To guard against change loss the sender persists replication state so that it can resume replication of undelivered changes after restarting.

Because a sender can itself become unavailable all changes pending replication would be lost. When a replicated change set is created the sender chooses additional peers to assume the role of recorders. The amount of recorders required is defined by configuration. In some embodiments two recorders may be used. When the primary sender receives acknowledgment of a change it also acknowledges to the recorders. If a recorder observes that the primary sender becomes unavailable it handles delivery of the changes of the primary sender.

Direct replication follows a commit and propagate strategy. However because additional information is persisted pertaining the replication itself in the data replication framework the weaknesses of direct replication are avoided. In various embodiments of the data replication framework all replication state is persisted in the same transaction as the change set or change session and so if replication is not possible the entire transaction reverts back to its previous state.

As explained above recorders are selected to redundantly store replication state. More recorders improve redundancy but may reduce overall write throughput. The minimum and desired redundancy level may be configurable. If the desired redundancy level is zero then no recorders need be selected. Only the original sender is responsible for resending changes in a standby stream. If the operating system crashes before all changes have been delivered then the sender might lose the changes and not be capable to send the standby stream. As a result the replication group may be inconsistent.

Illustratively all available hosts are recorder candidates which are selected immediately before the changes are committed. Recorder selection distributes the load among the hosts. All members must accept all changes. In some embodiments random or round robin selection may be used for selection of recorders.

The sender of a change does not ordinarily receive its own changes back. Because the sender could lose its own non committed changes after a reboot it needs to restore recent changes from its recorders. For this reason the recommended minimum redundancy level may be one in some embodiments. The sender is recorded as a receiver but the change is initially acknowledged. Upon start up members request all of their respective acknowledged changes from all peers.

Change sets may be assigned a unique identifier or ID which is provided by the initial sender. Change set IDs may be designed to support a natural ordering which loosely matches the order in which changes are sent. If a change could not be initially delivered the standby stream will attempt to match the original order.

In order to persist data an extra replication state may be stored by the sender of a change set and the same state is stored by all selected recorders. The state is persisted in the same transaction as the change set eliminating edge cases caused by commit and propagate style replication. Two tables may store replication changes. The first table may map change set ID to a serialized change set the sender ID and an array of recorder IDs. Sender and recorder IDs may be the same as member IDs and the order of recorders may determine the preference of transmissions in the standby stream. Although a change set may include a time entry a local timestamp may also be recorded in the replication change table.

The second table may contain a list of receivers for a change. It may have a composite key composed of the receiver ID and change set ID. A receiver ID may be just a member ID. The mapped value is an acknowledgment represented by the receiver s checkpoint counter value. The existence of this value indicates that the receiver has acknowledged the change but it has not durably persisted it yet. The record is deleted after it has been acknowledged and durably persisted.

After all receiver records for a change are deleted the entry containing the serialized change set is deleted. In a healthy replication group where all members are available the replication state data exists only for a short period of time. Replication state for unavailable members is kept until the member becomes available again or is declared permanently unavailable.

Senders and recorders do not persist self entries in the replication receiver table but recorders do persist a pre acknowledged entry for the sender. This allows the sender to recover recently lost changes without requiring that changes always be broadcast back to it.

Following a peer data store transfer the restored peer will have a complete copy of the replication state from its peer. Information pertaining to the peer may be removed after the transfer.

During initial propagation immediately before a change set or change session is committed the complete set of replication group peers is examined. From the replication group peers recorders are selected based on the desired redundancy level. Recorders are also persisted as receivers and all replication state entries are inserted as unacknowledged. Following selection of recorders the transaction is committed and then propagation can proceed. As an optimization recorders can store a pre acknowledged entry for the sender to avoid one additional round trip. For each receiver an asynchronous remote call is made. For ordinary receivers the call contains the sender ID the change set ID the recorder IDs and the serialized change set data. Recorders are also passed all non recorder receiver IDs. All receivers will apply the changes but recorders will also insert replication state entries within the same transaction. After the receiver has committed the changes it asynchronously notifies the sender and all recorders by passing back its own ID the change set ID and its checkpoint counter value. This is then persisted in the corresponding entry in the replication receiver table indicating acknowledgment.

The data replication framework waits for at least one recorder to receive the change. This avoids a change being committed locally and then the sender becoming unavailable before having had a chance to replicate the changes to remote hosts. In some embodiments hosts may have the option of waiting for acknowledgments from any kind of hosts not just recorders.

The standby stream is a background thread which ensures that all unacknowledged changes are delivered. Every few seconds or a different configurable time period the replication receiver table is scanned in its natural order. This order is receiver ID change set ID. Change set order approximately matches the time when the change was sent. To avoid overwhelming receivers during transmission of a standby stream sends are not sent asynchronously. The sends are instead sent using a batched mode.

The first reconnect verification attempt at block is performed immediately and each subsequent reconnect verification at block is delayed. The first delay may be one second and it may keep doubling up to for example two minutes. A member leaves the unavailable state and reconnect attempts cease when a reconnect succeeds or the unavailable member establishes a connection itself block .

If a member is unavailable without interruption for an extended period of time block it is declared permanently unavailable at block . Illustratively 20 hours may be a default threshold for the extended period of time. A shorter threshold merely means that an unavailable member might be declared permanently unavailable too soon and might be forced to restore from a peer when it becomes available. If the data store is large a full peer restore might take a long time in which case it might be preferable to have missed updates played back instead.

When a member is declared permanently unavailable at block this state transition is immediately replicated to all other members in the group. This ensures that if a member recently declared permanently unavailable reconnects it gets promptly notified of its permanent unavailability state no matter what member it connects to.

Because a member must be unavailable for an uninterrupted period of time in order to be declared permanently unavailable restarting the membership agent would interfere and possibly cause the verification of the member state to take longer. For this reason the start time of the member s unavailable state may be persisted in the member store .

Returning to before the membership agent attempts a reconnect at blocks and or the membership agent updates the persisted member state indicating that is the member is still unavailable. At a minimum this simply updates the last modified field of the record. It may also set the start time for when the unavailable state was entered. When a member leaves the unavailable state at block the unavailable start time field is cleared.

If the persisted member record already has an unavailable start time it becomes the effective start time if the record was modified within the grace period. The grace period is defined to be double the maximum retry interval which may be about four minutes in some embodiments.

When a member accepts a potential peer member session it queries the member store for the state of the peer member. If the member is new or known to be available then both members synchronize their member store data. If the member has been declared permanently unavailable it is treated as a compromised host for example a zombie. With comprised hosts the member store synchronization is not symmetrical. The member states provided by the compromised host are ignored.

By ignoring state provided by comprised hosts cascading the member unavailability state to connected members is prevented. In such a scenario two members might declare the other permanently unavailable. This might be caused by a temporary network partition which lasted longer than the detection threshold for permanent unavailability. A simple cause might be a disconnected network cable but not a power outage. In the worst case an entire replication group could be declared permanently unavailable following a network partition. Since each side thinks the other side is permanently unavailable it does not replicate any member state. This leads to a permanent network partition. In this state members in the replication group will never reach consistency. Also changes made by one side of the partition will always be ignored by the other.

Compromised hosts are most likely caused by a host being offline long enough to be declared permanently unavailable. The compromised host accepts the member states as provided by its peers and upon doing so it learns that it was declared permanently unavailable. It then creates a new member ID rejoins the group and performs a backup restore from a peer. Logic for detecting compromised hosts prevents the entire replication group from being declared permanently unavailable following an extended network partition. In some embodiments the data replication framework can detect a permanent network partition by simply observing pairs of compromised hosts or two permanently unavailable members declaring the other to be permanently unavailable. The framework may log errors repeatedly to ensure detection by a log scan monitor. It may be necessary in some embodiments to force all hosts on one partition to restore from the other.

Simple algorithms can be devised to automatically repair the permanent network partition. In one embodiment the partition with majority more members may be selected to be correct. The minority may restore from peers in the majority.

In some embodiments resiliency against extended network partition may be achieved by increasing the threshold time for declaring a member permanently unavailable. With a threshold of 20 hours a network partition which is resolved within 20 hours may cause no harm. If longer network partitions are expected the threshold may be increased to a longer period of time. In other embodiments one partition of hosts may be deactivated during a large scale network outage and only reactivated once the network is restored. In such embodiments only the reactivated hosts will be declared permanently unavailable and they can restore from the peers in the other partition.

All host members within the data replication framework locally persist their member ID and they also locally persist a replication group ID. Like the member ID the group ID is a randomly assigned ID. The purpose of the group ID is to ensure that misconfigured replication groups cannot merge together.

For illustration consider two replication group sets A B and C D. If the first set was only seeded with A and B then it will have no knowledge of the second set. Likewise if the second set was only seeded with C and D it will be unaware of the first set. The two sets are different partitions. If a configuration error causes set A B to become aware of C the two sets union into a combined replication group A B C D. Since the two groups were not together initially their data sets will be divergent and a merge can create irreconcilable inconsistencies. By giving each group a unique ID the merge is not allowed. The data replication framework may log errors when such an attempt is made.

When a host first joins a replication group it acquires the group ID of the first seed it was able to contact. If no seed can be contacted the host might be the first in the group. By default a new host may wait up to a threshold amount of time such as for example 15 seconds before forming its own group. Other time periods are also possible. If there is a network partition during the deployment of the new host it may erroneously form a new group which causes a different kind of permanent network partition. As described earlier when a groups attempt to merge back the data replication framework detects and logs these attempts as errors.

If a new replication group is being formed and several hosts are all first they might all form independent groups. To prevent this a in some embodiments a mini master election algorithm may be used during the join period. The new hosts detect the existence of each other as they connect during the initial join wait period. They then exchange their candidate group IDs and the one which is comparably lower than the other is used instead.

In other embodiments there may be an option to disable automatic group assignment. A manual self generating or self sustaining bootstrap process may be used in such embodiments using two deployments the first with automatic group assignment enabled and the second with automatic group assignment disabled.

The data replication framework as described above may assume that all members in a replication group are within the same LAN or data center. Bandwidth may be expected to be high and latency may be expected to be low. All members maintain connections to each other and each is capable of performing the same data replication actions. In some embodiments the data replication framework can also be used over a WAN. Replication groups across a WAN may be mostly isolated. A leader election process may choose which local members send changes over the WAN. The leader election process may also choose which remote members receive changes over the WAN. In some embodiments there may be multiple leaders elected.

Members on each side of the WAN are provided with completely different group IDs. If the same group ID were used the two sides may learn of each other s existence. If this happens they will exchange the complete membership roster and form a single fully connected network defeating the formation of replication groups across the WAN.

Separate group IDs also allow for one way replication which may be performed in either a LAN or a WAN framework. The separate group IDs make it possible to aggregate several data stores into one for example. Group ID separation also helps ensure that problems affecting one data center do not significantly impact services in another data center. The replication link can be severed in an emergency and replication within the data centers continues to work normally. For LAN replication a set of seed hosts to initially join a replication group may be configured. For WAN replication seed hosts which reside in different groups may be configured. Multiple WAN destinations can be configured with this strategy as well.

When the core replication interface first starts it needs to contact at least one member in the remote group. It then locally persists its group ID associated with the configured group name. On subsequent starts it does not need to immediately contact any remote group member because the group ID is known. It will keep trying to connect to at least one member logging an error if failed forever. Unreplicated changes will also pile up forever.

To stop replicating to a group configuration for it must be removed. All unreplicated changes for the group will be purged when the system is restarted with the new configuration. With WAN replication the recorders are additionally responsible for replicating changes to the remote group. By choosing a leader recorder replicator the number of connections established over the WAN is reduced. If multiple leaders exist at any time extra connections are created but this does not corrupt the data store since the data replication framework relies on record version numbers to discard stale or duplicated changes.

In some embodiments leader election for WAN replication may be accomplished by examining the member IDs of all members and to choose the members with the lowest IDs. If one of the leaders becomes unavailable it loses its leader status until it becomes available again. Leader election on the send side of replication reduces the number of connections over the WAN and doing the same on the receiving side reduces it further. With no leaders at all the number of required connections scales as m n where m and n are the member counts on each side. With leaders on one side the number of connections is m or n but with leaders on both sides the number of connections is 1.

The sender of a change in data may ask any member of the remote group for the leader. The sender only keeps a connection to the leader and sends all changes to it. In turn the remote leader replicates all changes to the members of its group.

When a host data store is first created or an existing data store has been declared permanently unavailable it acquires a complete copy of the data store from a peer in the replication group. If no peers exist then an empty data store is created instead. During a restore the peer supplying the copy remains online. The host data store continues to perform ordinary operations although the host load is slightly higher. Any updates which are applied during the transfer are delayed and they are received after the transfer is complete.

Query analysis starts at block where queries received at the hosts are analyzed by the query analysis module . Although all hosts have a replicated copy of the same data store the queries received at each of the hosts may have different frequencies. For example data associated with a given ProductID may be queried on one host and that ProductID may be a popular one causing several queries on that host creating a hot spot. However a request associated with a CustomerID for that same ProductID might send the query to a different host. Therefore the queries are analyzed and a determination is made of where queried data is located at block . From this analysis a distribution of requests is inferred by the query analysis module at block . The distribution of requests inferred is used to try to route requests away from potential hot spots by a router implemented by a dynamic routing request module. In some embodiments the inferred distribution may include a histogram. The inferred distribution constantly adjusts itself and aims to approximate even distribution of requests across hosts. In order to achieve a more ideal distribution a range of keys is created at block and the query analysis module ends at block .

Request routing is a method of partitioning the request stream to minimize disk accesses on the cluster of hosts. A query may include a key class wherein a key may be any type of request and a comparator to compare keys. A router may determine which host every request goes to based on dividers generated by a key store. The router may maintain an ordered list of hosts where the hosts are comparable. Such a list helps maintain consistency among separate applications that may be using the same set of hosts. When a new host is added the host is inserted in order. The dividers are generated to account for the new host. Similarly when a host is removed the dividers are regenerated. The key store stores a sorted multiset or a set that allows for duplicates of the most recently used keys. For every n th key coming into the router the router also sends it to the key store. The router asks the key store to generate a list of dividers to help the router to decide which host a request should be routed. A divider helps the router decide to which host to route a request. The divider contains a key to compare the request to an initial host offset index and a list of probabilities summing to 100 or 1 .

When the router is first turned on the key store is empty and therefore it cannot generate dividers. Thus the first requests may be randomly routed and then seeded to the key store. When the key store gets full the router begins to route by ranges.

Hosts frequently become unavailable and then available again and sometimes more hosts need to be added or removed. When the router detects that there is a change in the number of available hosts it immediately regenerates dividers again so that the load is evenly distributed.

The method of routing used may be based on ranges of request keys. With a cluster of hosts the first host would handle the first fraction of keys the second host would handle the second fraction of keys and so on. This method of routing would distribute keys to hosts evenly and decrease the probability of disk accesses. Due to fluctuations trends and hotspots the ranges should be dynamically adjusted to adapt to the constantly changing popularity of keys. One embodiment keeps samples of the most recently used keys and based off of the samples distributes the request stream. In some embodiments the algorithm may employ a strategy where the range of keys that is routed to specific hosts changes based on traffic. Different hosts would have a different key range going to them based on what items are hot. This would help spread the load across the system and account for variations in load.

A parameter of the algorithm may be to determine the number of keys to store in the keystore. A larger capacity may be better for steady constant request streams while a smaller capacity may be better for request streams that fluctuate rapidly. In some embodiments the number of keys may be 1000. In other embodiments the number of keys may be more or less than 1000.

Another parameter of the algorithm may be to determine the period of updating the dividers. A shorter period may make the dividers reflect a more recent past request stream but may come with a performance trade off. In some embodiments the number of keys may be 1000. In other embodiments the number of keys may be more or less than 1000.

When the divider receives a request key it checks if the request key is less than its own key at block and if true tells the router to route the request to the host offset index the first possible host associated to a divider at block . If the request key matches the divider s key the divider randomly selects a host based on its list of probabilities at block . The first element corresponds to the initial host the second element corresponds to the host to the right of the initial host and so on.

An example is provided for illustrative purposes. Suppose there are 5 hosts and a key store capacity of 20 shown below with respective dividers 

In this example there are 2 dividers. There are no dividers at indices 8 and 12 because they have the same key as a previous divider namely the divider at index 4. The first divider has key 2 a host offset index of 0 since this is the first divider and the host to the left of the divider has index 0 and a probability list of 0 4 9 4 9 1 9. The first probability is 0 since there are no 2 s in 0 3 . The next two probabilities are both 4 9 since there are four 2 s in 4 8 and 9 12 and nine 2 s in total. Finally the last probability is 1 9 since there is one 2 in 13 16 . The second divider has key 6 a host offset index of 3 the host to the left of the divider is host 3 and a probability list of 2 3 1 3.

If a request key of 1 comes in the insertion index of 1 in the divider list is 0 divider at index 4 . The divider sees that 1 is less than its key so immediately returns the host offset index 0. If a request key of 2 comes in the insertion index of 1 in the divider list is 0 again. The divider sees that the keys match so it randomly selects a host based on the probabilities. Thus the 2 will be never be routed to host 0 it will be routed to host 1 44.4 of the time it will be routed to host 2 44.4 of the time and it will be routed to host 3 11.1 of the time.

If a request key of 3 comes in the insertion index of 3 in the divider list is 1 divider at index 16 . The divider sees that 3 is less than its key so immediately returns the host offset index 3. If request key of 7 comes in the insertion index of this request key would be to the right of the dividers so the router immediately routes it to the last host host 4.

It will be appreciated by those skilled in the art and others that all of the functions described in this disclosure may be embodied in software executed by one or more processors of the disclosed components and mobile communication devices. The software may be persistently stored in any type of non volatile storage.

Conditional language such as among others can could might or may unless specifically stated otherwise or otherwise understood within the context as used is generally intended to convey that certain embodiments include while other embodiments do not include certain features elements and or steps. Thus such conditional language is not generally intended to imply that features elements and or steps are in any way required for one or more embodiments or that one or more embodiments necessarily include logic for deciding with or without user input or prompting whether these features elements and or steps are included or are to be performed in any particular embodiment.

Any process descriptions elements or blocks in the flow diagrams described herein and or depicted in the attached figures should be understood as potentially representing modules segments or portions of code which include one or more executable instructions for implementing specific logical functions or steps in the process. Alternate implementations are included within the scope of the embodiments described herein in which elements or functions may be deleted executed out of order from that shown or discussed including substantially concurrently or in reverse order depending on the functionality involved as would be understood by those skilled in the art. It will further be appreciated that the data and or components described above may be stored on a computer readable medium and loaded into memory of the computing device using a drive mechanism associated with a computer readable storing the computer executable components such as a CD ROM DVD ROM or network interface further the component and or data can be included in a single device or distributed in any manner. Accordingly general purpose computing devices may be configured to implement the processes algorithms and methodology of the present disclosure with the processing and or execution of the various data and or components described above.

It should be emphasized that many variations and modifications may be made to the above described embodiments the elements of which are to be understood as being among other acceptable examples. All such modifications and variations are intended to be included herein within the scope of this disclosure and protected by the following claims.

