---

title: Serial line protocol for embedded devices
abstract: Described embodiments provide a transceiver for transferring data between a media controller and a host device through a communication link. The transceiver includes a first interrupt generator configured to i) generate a first interrupt when a command is received from the host device and ii) provide the received command to a receive buffer. A command processing module i) retrieves the received command from the receive buffer, ii) processes the received command, and iii) provides data request data in response to the received command to a transmit buffer. A datagram generator is configured to provide datagram data to the transmit buffer and a second interrupt generator is configured to generate a second interrupt when data in the transmit buffer is ready for transmission. The transmit buffer interleaves i) the data request data in response to the received command and ii) the datagram data, when provided to the communication link.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08504737&OS=08504737&RS=08504737
owner: 
number: 08504737
owner_city: 
owner_country: 
publication_date: 20100901
---
This application claims the benefit of the filing date of U.S. provisional application Nos. 61 245 112 filed Sep. 23 2009 and 61 245 973 filed Sep. 25 2009 the teachings of which are incorporated herein in their entireties by reference.

The subject matter of this application is related to U.S. patent application Ser. Nos. 12 436 227 filed 6 May 2009 Ser. No. 12 475 710 filed 1 Jun. 2009 Ser. No. 12 475 716 filed 1 Jun. 2009 Ser. No. 12 477 996 filed 4 Jun. 2009 Ser. No. 12 478 013 filed 4 Jun. 2009 Ser. No. 12 508 879 filed 24 Jul. 2009 Ser. No. 12 508 915 filed 24 Jul. 2009 Ser. No. 12 643 471 filed 21 Dec. 2009 Ser. No. 12 649 490 filed 30 Dec. 2009 Ser. No. 12 722 828 filed 12 Mar. 2010 Ser. No. 12 730 627 filed 24 Mar. 2010 Ser. No. 12 731 631 filed 25 Mar. 2010 Ser. No. 12 767 985 filed 27 Apr. 2010 Ser. No. 12 768 058 filed 27 Apr. 2010 Ser. No. 12 769 882 filed 29 Apr. 2010 Ser. No. 12 769 910 filed 29 Apr. 2010 Ser. No. 12 873 450 filed Sep. 1 2010 and Ser. No. 12 873 512 filed Sep. 1 2010 the teachings of all of which are incorporated herein in their entireties by reference.

The present invention relates to a universal asynchronous receiver transmitter UART circuit for embedded devices such as media controllers for storage devices such as hard disk drives HDDs and solid state disks SSDs .

Flash memory is a type of non volatile memory that is electrically erasable and re programmable. Flash memory is primarily used in memory cards and USB flash drives for general storage and transfer of data between computers and other digital products. Flash memory is a specific type of electrically erasable programmable read only memory EEPROM that is programmed and erased in large blocks. One commonly employed type of flash memory technology is NAND flash memory. NAND flash memory forms the core of the flash memory available today especially for removable universal serial bus USB storage devices known as USB flash drives as well as most memory cards. NAND flash memory exhibits fast erase and write times requires small chip area per cell and has high endurance. However the I O interface of NAND flash memory does not provide full address and data bus capability and thus generally does not allow random access to memory locations.

There are three basic operations for NAND devices read write and erase. The read and write operations are performed on a page by page basis. Page sizes are generally 2bytes where N is an integer with typical page sizes of for example 2 048 bytes 2 kb 4 096 bytes 4 kb 8 192 bytes 8 kb or more per page. Pages are typically arranged in blocks and an erase operation is performed on a block by block basis. Typical block sizes are for example 64 or 128 pages per block. Pages must be written sequentially usually from a low address to a high address. Lower addresses cannot be rewritten until the block is erased.

A hard disk is addressed linearly by logical block address LBA . A hard disk write operation provides new data to be written to a given LBA. Old data is over written by new data at the same physical LBA. NAND flash memories are accessed analogously to block devices such as hard disks. NAND devices address memory linearly by page number. However each page might generally be written only once since a NAND device requires that a block of data be erased before new data is written to the block. Thus for a NAND device to write new data to a given LBA the new data is written to an erased page that is a different physical page than the page previously used for that LBA. Therefore NAND devices require device driver software or a separate controller chip with firmware to maintain a record of mappings of each LBA to the current page number where its data is stored. This record mapping is typically managed by a flash translation layer FTL in software that might generate a logical to physical translation table. The flash translation layer corresponds to the media layer of software and or firmware controlling an HDD.

Storage devices such as HDDs and SSDs commonly employ a separate media controller chip to facilitate use of the storage device. In general such a media controller chip might process operations of the storage device for example read or write operations. The media controller chip might be implemented as a system on chip SoC having one or more processors. One or more firmware modules will be installed to run on each of the one or more processors with each firmware module including one or more sub components. For example the media controller firmware might include firmware modules and sub components to process one or more diagnostic operations.

An HDD or SSD media controller might operate in compliance with one or more host communication protocols for example the Small Computer System Interface SCSI protocol the Serial Attached SCSI SAS protocol or the Serial Advanced Technology Attachment SATA protocol. The SCSI protocol is a communications protocol where multiple components are connected to the same bus and a process of arbitration determines which device gets access to the bus at any point in time. The SCSI command set is described in the SCSI Primary Commands standard SCSI Primary Commands SPC 3 Revision 23 May 4 2005 hereinafter SCSI SPC standard included by reference herein . The SAS protocol is a serial protocol that employs the standard SCSI command set but is point to point meaning that each SAS device is connected by a dedicated bus to a device that originates requests an initiator . The SATA protocol is a serial protocol that uses the standard ATA command set. The ATA command set is described in the AT attachment standard AT Attachment 8 ATA ATAPI Command Set ATA8 ACS Revision 4a May 21 2007 hereinafter ATA standard included by reference herein . Although in some applications it might be desirable to employ SAS and SATA devices interchangeably in general separate host interface modules within the media controller chip might be required.

Since an HDD or SSD might receive one or more commands such as read write or erase operations before a previously received command has completed a queue might generally maintain a list of commands received while a previous command is being processed. In storage devices operating in accordance with the SCSI standard a control field such as the SCSI Queue Algorithm Modifier QAM field might be employed to indicate whether reordering of the queue of received commands is permitted. As defined by the SCSI Primary Commands standard SPC 3 Section 7.4.6 pg. 285 2005 included by reference herein when the QAM field has a value of zero command reordering is restricted and queued commands must be processed in the order in which they are received. When the QAM field has a value of one command reordering is permitted and the storage device may process queued commands in any order. Further a control field such as the SCSI Task Attribute field might be employed to indicate how commands are queued. As defined by the SCSI Architecture Model SAM 5 Section 8.9 pp. 123 127 2009 included by reference herein the Task Attribute field defines the attributes SIMPLE ORDERED HEAD OF QUEUE or ACA which indicate how a received command should be queued. For example a received command having the HEAD OF QUEUE attribute is placed at the head of the queue ahead of any previously queued commands.

Diagnostic operations are typically small functions implemented in the media controller firmware. Each diagnostic operation might perform a specific task to help debug a given device problem. Common diagnostic operations might for example include reading or writing a register performing a test and reporting device status. A request for the media controller to perform a diagnostic operation might be initiated from one or more different sources. For example a typical SAS or SATA host device might request a diagnostic operation be performed. Further other host types might be employed such as for example USB and in a design and development environment other communication links might be employed. Typically the media controller handles diagnostic operations from different sources independently. Thus every firmware layer generally might include a module for each diagnostic operation and often each firmware layer might include separate module implementations for each type of source.

A universal asynchronous receiver transmitter UART is often used during design and development of an embedded device to provide a way to issue commands to the embedded device and transfer and display logging information indicating the status of the embedded device. A UART is often employed in conjunction with a computer serial port operating according to the RS 232 standard. For RS 232 UARTs to transfer binary data the binary data is typically converted to ASCII e.g. through Base64 encoding or the UART switches into a binary mode to transfer the binary data. Both of these methods add complexity and inefficiency to the implementation. Further typical control software or firmware of RS 232 UARTs do not allow for asynchronous transfer of datagram type messages interleaved with their main command processing messages.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Described embodiments provide a transceiver for transferring data between a media controller and a host device through a communication link. The transceiver includes a first interrupt generator configured to i generate a first interrupt when a command is received from the host device and ii provide the received command to a receive buffer. A command processing module i retrieves the received command from the receive buffer ii processes the received command and iii provides data request data in response to the received command to a transmit buffer. A datagram generator is configured to provide datagram data to the transmit buffer and a second interrupt generator is configured to generate a second interrupt when data in the transmit buffer is ready for transmission. The transmit buffer interleaves i the data request data in response to the received command and ii the datagram data when provided to the communication link.

In accordance with embodiments of the present invention a transceiver is provided for transferring data between a media controller and a host device through a communication link. The transceiver includes a first interrupt generator configured to i generate a first interrupt when a command is received from the host device and ii provide the received command to a receive buffer. A command processing module i retrieves the received command from the receive buffer ii processes the received command and iii provides data request data in response to the received command to a transmit buffer. A datagram generator is configured to provide datagram data to the transmit buffer and a second interrupt generator is configured to generate a second interrupt when data in the transmit buffer is ready for transmission. The transmit buffer interleaves i the data request data in response to the received command and ii the datagram data when provided to the communication link.

Table 1 defines a list of acronyms employed throughout this specification as an aid to understanding the described embodiments of the present invention 

Media controller controls transfer of data between media and an external device coupled to communication link . Media controller might be implemented as a system on chip SoC . Media controller might include internal RAM buffer and might also be coupled to additional external memory shown as external RAM buffer . In an exemplary embodiment internal RAM buffer comprises 128 kB of static RAM SRAM and external RAM buffer comprises 512 MB of double data rate version 2 dynamic RAM DDR2 DRAM . RAM buffer might act as a cache for processor while RAM buffer might act as a read write buffer between media and communication link . Processor includes software and or firmware as needed for operation including for tracking and conflict checking of outstanding access requests in accordance with exemplary embodiments of the present invention as described subsequently.

Although shown in as a single processor processor might be implemented by multiple processors. For example end users of media controller might require higher or lower performance depending on their intended application. The performance requirements might affect the type of processors employed in the SoC or the number of processors employed in the SoC. For example a lower performance SATA SSD media controller might employ a single ARM Cortex M3 processor while a higher performance SAS SSD media controller might employ three ARM Cortex R4 processors ARM Cortex processors are by ARM Holdings plc Cambridge UK . Processor includes software and or firmware as needed for operation. For embodiments having multiple processors inter processor communication might be employed such as described in related U.S. patent application Ser. No. 12 436 227 filed May 6 2009.

Although shown in as a single media device media might be implemented as one or more storage media such as described in related U.S. patent application Ser. No. 12 722 828 filed Mar. 12 2010. For example media might be implemented as an SSD including one or more physical flash silicon dies. In some embodiments host requests might be striped across two or more of the dies analogously to hard drives in a redundant array of independent disks RAID to provide parallel execution. In other embodiments each flash die might be configured as a separate stand alone flash memory device without data striping. Similarly media might be implemented as one or more HDDs or hybrid magnetic and solid state storage systems.

In operation for example media controller might receive one or more requests for media access from external devices such as requests for read or write operations from communication link . Such requests for access to media generally include at least one logical block address LBA where data should be read or written. For example the requests could be to read from or write to a i single media address ii a group of contiguous media addresses or iii a group of non contiguous media addresses. Received requests are processed by host subsystem . In general host layer might process higher level host operations e.g. host command handlers and host LLD might process lower level host operations e.g. parsing host commands to the host layer . Commands accessing a group of non contiguous media addresses might be processed such as described in related U.S. patent application Ser. No. 12 508 915 filed Jul. 24 2009. One or more received commands might be queued or tracked as described in related U.S. patent application Ser. No. 12 649 490 filed Dec. 30 2009. Host subsystem might also perform encryption and decryption of data such as described in related U.S. patent application Ser. Nos. 12 767 985 and 12 768 058 both filed Apr. 27 2010.

Media subsystem translates the LBA into a physical address of the desired data for example as described in related U.S. patent application Ser. No. 12 643 471 filed Dec. 21 2009 Ser. No. 12 769 910 filed Apr. 29 2010 and Ser. No. 12 769 882 filed Apr. 29 2010. Media subsystem interfaces with buffer subsystem . Media layer might process higher level media operations e.g. logical to physical address translation while media LLD might process lower level media operations e.g. media hardware specific read write erase . Media layer also might enable error recovery and wear leveling routines for media such as described in related U.S. patent application Ser. No. 12 475 710 filed Jun. 1 2009 Ser. No. 12 475 716 filed Jun. 1 2009 and Ser. No. 12 508 879 filed Jul. 24 2009. In embodiments of the present invention media layer might support enterprise system sector sizes e.g. 520 or 528 bytes per sector instead of 512 bytes such as described in related U.S. patent application Ser. Nos. 12 477 996 and 12 478 013 both filed Jun. 4 2009.

Since data transfers between communication link and media might be temporarily stored in buffer memory buffer subsystem generally directs the data traffic between host subsystem and media subsystem . For example if an external host not shown provides via communication link data to be written to media buffer subsystem might coordinate temporary storage of the data in buffer until media subsystem coordinates writing the data to media . Similarly if the external host requests to read data from media buffer subsystem might temporarily store the data in buffer until host layer coordinates sending the data to the host via communication link .

In general buffer layer might process higher level buffer and cache operations e.g. cache and buffer allocation while buffer LLD processes lower level buffer operations e.g. RAM hardware specific commands . Buffering of data might occur for example as described in related U.S. patent application Ser. No. 12 722 828 filed Mar. 12 2010 Ser. No. 12 730 627 filed Mar. 24 2010 and Ser. No. 12 731 631 filed Mar. 25 2010. Infrastructure subsystem might generally serve as an operating system for media controller with infrastructure layer performing higher level processing operations e.g. operating system operations and infrastructure LLD performing lower level operating system operations e.g. initialization timers interrupts .

As shown in media controller might also include Buffer Allocation Module BAM . As shown BAM is coupled to host layer buffer layer and infrastructure layer . In embodiments of the present invention BAM might be employed to provide acceleration and flexibility in managing one or more cache buffers in RAM buffers and and the transfer of information between host layer and buffer layer . For example BAM might maintain cache management data that describes data blocks stored in a cache the status of the data blocks stored in the cache e.g. valid dirty etc. the physical address of that data and which modules of media controller are accessing the data.

As will be described in greater detail below BAM might typically include i a first control sequencer for host command and context processing and ii a second control sequencer for buffer command and context processing. In general a context is a data structure used within media controller that specifies the information necessary to send or receive data e.g. to send a data frame or frame information structure FIS on communication link to perform direct memory access DMA etc. . Since both host subsystem and buffer subsystem might access the same cache data structures BAM includes an arbiter to arbitrate between the first and second control sequencers to guarantee access to cache entries. BAM might be employed to perform cache lookup for a command to enhance performance or to process a command and generate a thread of contexts for that command. BAM might also be employed to perform buffer allocation for a context or to modify fields in a context. Thus BAM provides flexibility in manipulating context threads generating individual contexts and allocating cache data in the buffer. BAM will be described in greater detail with regard to .

As described herein embodiments of the present invention provide a media controller that supports one or more host interface protocols e.g. SATA SAS etc. by allowing for modifications of host LLD without substantially affecting other modules of media controller . For example as will be described herein one implementation of Host LLD might be employed for a media controller operating in accordance with the SAS protocol and another implementation of Host LLD might be employed for a media controller operating in accordance with the SATA protocol while both implementations of Host LLD might employ substantially similar implementations of other modules such as host layer buffer subsystem media subsystem and infrastructure subsystem .

Similarly embodiments of the present invention provide media controller that supports one or more media types such as HDD or NAND Flash SSD hybrid magnetic and solid state drives etc. by allowing for modifications of Media LLD without substantially affecting other modules of media controller . For example as will be described herein one implementation of Media LLD might be employed for a media controller employing an HDD and another implementation of Media LLD might be employed for a media controller employing an SSD while both implementations of Media LLD might employ substantially similar implementations of other modules such as buffer subsystem media layer host subsystem and infrastructure subsystem .

As described herein embodiments of media controller support one or more different performance levels. For example media controller might have higher or lower performance requirements depending on the intended use of the media controller. The type of processors employed on the SoC or the number of processors employed on the SoC might change according to the performance requirements. For example a lower performance media controller e.g. a SATA desktop SSD might employ a single ARM Cortex M3 processor while a higher performance media controller e.g. a SAS enterprise SSD might use multiple ARM Cortex R4 processors. For example as will be described herein one implementation of Infrastructure Layer and Infrastructure LLD might be employed for a lower performance media controller and another implementation of Infrastructure Layer and Infrastructure LLD might be employed for a higher performance media controller while employing substantially similar implementations of other modules.

Table 2 shows an exemplary description of the functions of each of the high level and low level modules of media controller as shown in 

As described herein Low Level Host Interface might generally provide a hardware abstraction layer HAL for a specific host interface protocol. Host Command Handler might perform high level functionality of host commands other than read and write commands for example Host Command Handler might send or receive device status data via Communication Link . Host Command Scheduler might schedule received commands for processing by media controller according to host specific queuing rules and might handle command exception conditions. Each of modules and might have unique implementations for each host interface type e.g. SATA SAS etc. . Buffer subsystem might generally perform read and write commands such as described in related U.S. patent application Ser. No. 12 643 471 filed Dec. 21 2009.

For example LLHI might perform hardware initialization of communication link receive and parse commands from a host initiator e.g. a SAS host device coupled to communication link and process transfer and status requests. LLHI might also build a command table and other data structures for command parsing. When LLHI receives a command LLHI might check to see if the command can be parsed and determine the mode of the requested data transfer. For example a data transfer might be an LBA based host transfer or some other type of transfer. LLHI then might pass the parsed command to HCPS . LLHI might also send status updates back to the host for a received command for example indicating that the command has completed . LLHI might also interface with buffer allocation manager BAM for example BAM of .

HMCH processes the high level host commands for each host interface. For example HMCH might validate command specific input manage buffer resources and manage command data transfers and status responses. For example the high level host commands for a SATA host are the ATA command set and a SAS host uses the SCSI command set. HCMH normalizes the host interface specific read write type commands e.g. SATA specific commands to a common format that is generally employed by media controller . Thus other process modules of media controller e.g. buffer subsystem media subsystem etc. do not process host specific commands. For example commands that HCMH might normalize to a common format might include the SATA power management commands e.g. IDLE STANDBY SLEEP while commands that HCMH processes by a host specific handler might include commands to perform device diagnostics identify the device etc. HCMH might generally include a command handler corresponding to all commands supported in the protocol e.g. SATA SAS etc. that are not normalized to a common format.

Normalized commands result in a command structure that is a single format for multiple format of input commands. For example in SCSI there are six ten twelve sixteen and 32 byte commands. Each of these sizes has a read and write command type. A normalized command contains common fields in a fixed format for example a 64 bit field for LBA and a 32 bit field for transfer length. A six byte SCSI read command would for example have its one byte transfer length normalized into the 32 bit transfer length field of the normalized command and its 21 bit LBA normalized into the 64 bit LBA field of the normalized command.

The command handlers of HMCH employ APIs to communicate with LLHI to receive or send data and status information from or to a host device coupled to communication link . For example the SCSI MODE SELECT command handler might use a host data transfer API to receive additional parameters from a host that are transferred separately from the initial host command. As another example the ATA IDENTIFY DEVICE command handler might use the host data transfer API to send the IDENTIFY DEVICE data to the SATA host. All of the non read write command handlers might use send status API to indicate that a command has completed.

For example as shown in HMCH might send a host transfer request to receive additional parameters from a host that are transferred separately from the initial host command. HMCH might send a host status request signal to LLHI to indicate that a corresponding command is complete. LLHI might send a host request status back to CCH . For example if CCH requests a data transfer LLHI will respond with an indication that the transfer reached completion. If CCH requests a status LLHI will respond with an indication of status. As shown similar signals might also be communicated between CCH and LLHI . As described a host command is received by LLHI which performs initial checks on the received command LLHI then provides received commands to HCPS . As shown HCPS might provide normalized commands to CCH and might provide non normalized commands to HMCH . CCH and HMCH might provide an indicator to HCPS when a command is complete.

HCPS generally manages host subsystem . HCPS might validate commands schedule command processing route commands complete commands perform command error handling and manage commands. HCPS processes each host command plus abort and exception conditions received from LLHI . A unique but architecturally similar firmware implementation of HCPS might desirably be employed for each host interface type. Functions performed by the HCPS include i host interface specific protocol checking ii command queuing rules iii scheduling host command handler execution and iv command aborts and exception handling Embodiments of HCPS employ a protocol checking function that scan for cases that may inhibit command execution. For example for the SCSI protocol a Unit Attention Condition following a power on or SCSI reset might prevent commands for executing. Similarly for the ATA protocol the locked or frozen security modes might prevent commands from executing. HCPS also detects unsupported or invalid commands exceptions .

HCPS enforces command queuing rules of the host interface. For example any received SCSI command with an ORDERED queue tag is queued until all commands received previously are completed. Commands received subsequently are also queued until the ORDERED command is completed. HCPS checks for illegal queuing conditions such as for example the receipt of a non queued ATA command while other native queued read write commands are still executing. After completing the appropriate host interface protocol and command queuing checks HCPS adds the command to its internal command queue. A received command that is not queued might become active and scheduled for execution when it is received. For example all read write commands that pass the protocol and queuing checks are immediately passed to CCH . CCH might process and reorder if necessary one or more active read write commands.

However other received commands might not immediately be scheduled for execution. For example non read write commands usually become active when they sent to the corresponding command handler based on their command opcode in HCMH . In some embodiments only one non read write command is allowed to become active and executed in the system at one time e.g. ATA devices . For SCSI devices since command queuing is allowed for non read write commands embodiments of the present invention might process non read write SCSI commands having a SIMPLE queue tag as if they were SCSI commands having an ORDERED queue tag i.e. the commands are scheduled and executed one at a time in the order in which they were received .

As described CCH and HCMH might provide a command complete indication to HCPS when the execution of a command has completed. HCPS might then remove the completed command from the command queue. When a command is completed HCPS also determines if the completed command was causing one or more other commands to be blocked in the system command queue such as described in related U.S. patent application Ser. No. 12 649 940 filed Dec. 30 2009. If a command was blocked the blocked command is provided to the appropriate command handler e.g. one of CCH and HCMH for execution.

In summary HCPS generally i schedules a received read write command for immediate execution and passes it on to CCH in buffer subsystem ii schedules a received non read write command for immediate execution if no other command is active and passes it on to the corresponding non read write command handler in HCMH based on the command opcode iii queues the received command and defers command execution until later e.g. due to SCSI command queuing rules or iv ends the command with an error status due to failing a host interface protocol check a command queuing rules check or due to an invalid command.

At step LLHI provides a notification to the command handler when the host data transfer is complete. At step LLHI and HCPS perform command completion tasks such as for example releasing buffer space recycling data structures and pointers and removing the completed command from command queues. At step HCPS determines if any queued commands were blocked by the completed command. If at step one or more queued commands were blocked by the completed command at step command execution process might return to step to execute the one or more queued commands. If at step no commands were blocked by the completed command command execution process command execution process might be complete at step .

As described in regard to embodiments of the present invention might offload at least part of the workload of host subsystem to a programmable sequencer which might facilitate efficient performance by providing for scatter gather operations and by employing parallel processing and balancing the workload between the host processor firmware and the programmable sequencer. For example as shown in host subsystem might be in communication with buffer allocation manager BAM . BAM might be implemented as a programmable sequencer such as a set of programmable registers in communication with a controller having a small instruction set to modify data in the programmable registers. BAM is coupled to host subsystem and buffer subsystem . BAM might be employed to provide acceleration and flexibility in managing the cache and the transfer of information between host subsystem and buffer subsystem .

BAM might maintain cache management data describing data blocks stored in the cache such as the status of data blocks stored in the cache e.g. valid dirty etc. the address of that data and which modules of media controller are accessing the data. BAM might also aid with host context generation. As described herein a context is generally a data structure used within media controller that specifies the information necessary to send or receive data e.g. information necessary to i generate and send a data frame or frame information structure FIS on communication link ii perform direct memory access DMA etc. .

As shown in BAM might be employed to generate a thread of contexts for a received host command. BAM might also be employed to perform buffer allocation for a context or to modify fields in a context. As shown in BAM might generally include i a first control sequencer for host command and context processing and ii a second control sequencer for media command and context processing. Since both host subsystem and media subsystem might access the same cache data structures BAM might include arbiter to arbitrate between the first and second control sequencers to guarantee access to cache entries.

As shown in host subsystem particularly LLHI might generate a host context . Host context is generated when a data transfer is required from host subsystem to media via buffer subsystem such as when a host write operation is received by media controller . Host context corresponds to a starting address for example a starting LBA of media or a starting buffer address of at least one of RAM buffers and and a length for example an amount of data included in the context . In embodiments of the present invention a sequencer context might generally correspond to a transfer request for one or more data chunks corresponding to the overall length of the host transfer. Host context is provided to programmable sequencer which generates hardware contexts N corresponding to host context . For example if host context corresponds to a data transfer of 4 noncontiguous chunks programmable sequencer might generate 4 hardware contexts e.g. one context for each corresponding noncontiguous chunk . Hardware contexts N are provided to context processing module of host hardware . By employing programmable sequencer to program one or more host hardware contexts from a single host context host subsystem is free to perform other tasks while sequencer generates the host hardware contexts and provides the hardware contexts to context processing module . Context processing module might for example provide direct memory access DMA to transfer data corresponding to hardware contexts N between a host device and at least one of media buffer and buffer .

Similarly media subsystem might generate media context . Media context is generated when a data transfer is required from media subsystem to communication link via buffer subsystem such as when a host read operation is received by media controller . Programmable sequencer might generate one or more hardware contexts N corresponding to host context . Arbiter arbitrates between programmable sequencers and for access to data cached in the buffer. Hardware contexts N are provided to context processing module of media subsystem .

By employing programmable sequencer to program one or more media hardware contexts from a single media context media subsystem is free to perform other tasks while sequencer generates the media hardware contexts and provides the hardware contexts to context processing module of media hardware . Context processing module might for example provide direct memory access DMA to transfer data corresponding to hardware contexts N between media and at least one of buffer and buffer . Thus embodiments of the present invention such as shown in improve the overall host system performance by using programmable sequencers to generate one or more contexts from a single higher level context e.g. and . The parallel sequencers allow for media side operations and host side operations to be performed in parallel such as described in related U.S. patent application Ser. No. 12 731 631 filed Mar. 25 2010.

As described with regard to embodiments of the present invention provide that a single host data transfer e.g. a single data transfer request received from a host device coupled to communication link might correspond to one or more data transfer contexts for data transfers internal to media controller . Data related to a single host data transfer might be scattered in different locations in media or at least one of buffers and yet need to be combined into a single contiguous data transfer to the host device coupled to communication link . Thus embodiments of the present invention allow a protocol command to be split into one or more contexts that can later be recombined into one host data transfer. Splitting a host command into one or more corresponding contexts allows decoupling of host data transfer boundaries e.g. host frame size from data transfer boundaries for media controller e.g. chunk size and the overall size of the data transfer. Thus the size of internal data contexts of media controller might be selected without dependence on the size of data frames transferred over communication link and the total size of the transfer.

Splitting a host command into one or more corresponding contexts might also accommodate multiple buffer management techniques and multiple protocol techniques such as for example SATA programmed input output PIO multiple commands and SAS multiple pending write commands. PIO Multiple commands include data transfers for one or more memory addresses where the alignment of the data in the PIO Multiple command generally does not line up to a boundary of media controller . Thus embodiments of the present invention might beneficially split PIO Multiple commands into one or more contexts that align to chunk boundaries of data stored by media controller for example data stored in media or buffers and .

As shown in command context might correspond to one or more write contexts that are generated to process the data transfer. The size of write contexts might correspond to chunk boundaries of data stored by media controller for example data stored in media or buffers and . The chunk boundaries are independent of the protocol frame boundaries and the overall size of the transfer. A counter might be employed to track the number of chunk boundaries such that a new data transfer context can be processed without affecting the other contexts. As shown in command context corresponding to the SAS TRANSFER READY frame corresponds to write contexts as indicated by the dashed line. Write contexts provide address information for the data to be transferred e.g. the address in at least one of buffers and corresponding to one or more chunks of command context . In embodiments of the present invention each of write contexts have the same configuration options and the total length of write contexts matches the overall data length provided in command context . As described with regard to write contexts might be processed by context processing module of host subsystem .

As described above the one or more read contexts are optional as embodiments of the present invention might depending on the size of the read data transfer or settings of media controller employ varying context boundaries. For example for small read operations only a single context per protocol command might be employed e.g. only read command context . In this case a single context is generated for the data transfer. Alternatively as described previously multiple data transfer contexts might be merged together into one host data transfer. As shown in read command context corresponds to the host command length and one or more read contexts that satisfy the overall instruction length. Protocol frame boundaries are maintained independently of context boundaries so frames of the maximum size allowed by the link protocol might be sent until all of read contexts have been processed.

As shown in read command context is generated and defines the entire data transfer length of the protocol instruction request but this context might reference a context structures accessible by BAM or one or more contexts stored in buffer subsystem . In embodiments of the present invention base buffer pointer is optional. Base pointer might generally provide a single context in buffer subsystem for a transfer while contexts might be generated by BAM as shown in . BAM might generate and store data corresponding to read contexts . Contexts are provided to communication link as a host data transfer. Thus embodiments of the present invention provide the ability to generate contexts for a data transfer command in three ways while supporting the maximum host transfer size i in a single context for the command and the data transfer in buffer subsystem e.g. context without any other contexts ii a command context e.g. context with a single data transfer context in buffer subsystem e.g. base pointer that corresponds to one or more data transfer entries in BAM e.g. contexts and iii one or more contexts in buffer subsystem split between a command context e.g. and one or more data contexts e.g. .

Thus as described herein embodiments of the present invention provide that at least part of a host subsystem workload might be offloaded to a programmable sequencer. The programmable sequencer might facilitate efficient performance by employing parallel processing and balancing the workload between the host subsystem and the programmable sequencer. Further embodiments of the present invention might allow a host protocol command to be split into one or more contexts that might be recombined into one host data transfer. Splitting a host command into one or more contexts allows decoupling of host data transfer boundaries e.g. host frame size from data transfer boundaries e.g. chunk size and the overall size of the data transfer. Thus the size of internal data contexts of a media controller might be selected without dependence on the size of host protocol data frames transferred or the total size of the transfer.

As shown in diagnostic subsystem is configured to receive diagnostic requests from multiple types of sources and route the diagnostic requests to Common Diagnostic Handler CDH . Each supported external source type might have a corresponding request handler shown as Miscellaneous Request Handler MRH Host Request Handler HRH and Debugger Request Handler DRH . Each corresponding request handler is a low level driver for the communications protocol corresponding to the source type. For example HRH might support one or more host types e.g. SATA SAS etc. DRH might support one or more debugger types e.g. JTAG SWD etc. and MRH might support one or more other request types e.g. SPI UART etc. . After the corresponding request handler has received a diagnostic request and parses the command the diagnostic request is sent to CDH .

CDH generally manages the processing of diagnostic requests and handles aspects of diagnostic requests that are common to many diagnostics. Such aspects might include for example memory management and management of data transfers. CDH then routes diagnostic requests to the corresponding one of EDHs . For example each one of EDHs might correspond to a given type of diagnostic task e.g. memory tests etc. . CDH generally handles the complexity of processing a diagnostic request reducing the complexity of EDHs .

CDH might allocate a buffer for a diagnostic even if no data transfer is associated with the diagnostic request. At step CDH determines if the diagnostic request requires data to be transferred from the source of the diagnostic request to media controller . CDH and the corresponding request handler e.g. initiate the transfer from the source in accordance with the source protocol requirements. If at step the diagnostic request does require data from the source at step CDH manages the data transfer as a standard data transfer e.g. similarly as described with regard to . Once the data transfer at step is complete or at step if no data transfer was required processing continues to step .

At step CDH parses the diagnostic request and routes the diagnostic request to the End Diagnostic Handler e.g. one of EDHs corresponding to the diagnostic request. Part of the diagnostic request from every source is a field that indicates which component of media controller the diagnostic request is directed. CDH uses this field to route the diagnostic request to the appropriate EDH. At step the corresponding one of EDHs performs the requested diagnostic operation and responds back to CDH when the diagnostic request is complete. At step CDH determines if a data transfer back to the source of the diagnostic request is required. For diagnostic requests that require data to be transferred to the source at step CDH initiates and manages the transfer. When the data transfer of step completes processing continues to step .

If at step CDH determines that no data transfer is required the process continues to step . If at step no buffer space was allocated at step to process the diagnostic request the process continues to step . If at step there was buffer space allocated then at step CDH deallocates the buffer space allocated at step for the diagnostic request. At step CDH responds back to the corresponding one of request handlers . This response includes a status of the diagnostic request for example indicating if there were any errors during the data transfer CDH processing or EDH processing of the diagnostic request. At step diagnostic request process is completed.

As described herein some diagnostic requests might be provided to media controller via miscellaneous sources such as for example a UART universal asynchronous receiver transmitter . Embodiments of the present invention provide a UART for media controller employing a binary serial protocol and supporting two or more data streams interleaved on the same communication line.

Received commands might typically be executed outside of the interrupt RX INT by helper task as shown by arrow . Performing commands outside of the interrupt allows UART to process other data while the command is executing. Helper task might perform commands that consume system resources for example reading or writing media . Helper task might employ API to communicate with other modules of media controller as indicated by arrow . Response data and command status is provided to TX Buffer from helper task as indicated by arrow . When TX Buffer contains data ready to be sent to the RS 232 link TX INT is generated for UART to send the data out to the RS 232 serial link as indicated by arrow . As shown datagram data might also be provided to TX buffer as indicated by arrow . A multiplexer not shown might control access to TX buffer so that response data status arrow and datagram data arrow are properly provided to TX buffer . Datagram data and response data status will be described in regard to .

Embodiments of the present invention might provide a reliable application level data path a Command Data Transport for issuing commands from the host and receiving responses to those commands from the embedded device. Embodiments of the present invention might also provide an unreliable datagram path Logging Data Transport for delivering logging type information from the device to the host.

Although any number of commands might be implemented commands generally might be classified into one of three categories i NO TRANSFER commands ii WRITE TRANSFER commands and iii READ TRANSFER commands. The exemplary state diagram of shows processing for these command type classifications in accordance with the CDT protocol. In general UART is waiting to receive a CDT command at state . When a command is received UART determines whether the command is a NO TRANSFER WRITE TRANSFER or READ TRANSFER command.

If the received command is a NO TRANSFER command UART performs the requested command shown as state transition to state . UART responds to the host device with an acknowledgement ACK signal and status data indicating the status of the command shown as state transition to state . Once the ACK signal and status data is sent UART returns as indicated by state transition to state to wait to receive another command.

If the received command is a WRITE TRANSFER command UART responds with an ACK signal shown as state transition to state . As indicated by state transition UART waits for the host data at state . After successful receipt of one or more packets of data from the host device UART sends an ACK signal back to the host device indicated as state transition back to state . UART might transition between states and one or more times depending on the amount of data sent from the host device. Once UART receives all the data from the host device UART runs the command as indicated by state transition to state . Once the command is complete UART sends an ACK signal as indicated by state transition to state . After the ACK signal is sent UART might wait for a status request from the host device as indicated by state transition to state . When UART receives the status request from the host device UART responds with an ACK signal and status data as indicated by state transition to state . Once the ACK signal and status data is sent UART returns as indicated by state transition to state to wait to receive another command.

If the received command is a READ TRANSFER command UART responds with an ACK signal shown as state transition to state . UART runs the requested command as indicated by state transition to state . As indicated by state transition UART waits at state to send the requested data until the host device sends a data request. Once the host data request is received UART sends a data block to the host device at state as indicated by state transition . If multiple data blocks are required for the command UART might transition between states and one or more times until all data blocks are sent to the host device as indicated by state transitions and . As indicated by state transition once all the data blocks are sent to the host device UART waits at state for a status request from the host device. When UART receives the status request from the host device UART responds with an ACK signal and status data as indicated by state transition to state . Once the ACK signal and status data is sent UART returns as indicated by state transition to state to wait to receive another command.

If the host device is sending a NO TRANSFER command at state the host device sends the command to UART as indicated by state transition . The host device might also send a status request to UART along with the command. As indicated by state transition the host device then waits at state for UART to reply with an ACK signal and status data. Once the host device receives the ACK signal and status device from UART the host device returns to IDLE state as indicated by state transition .

If the host device is sending a WRITE TRANSFER command at state the host device sends the WRITE TRANSFER command to UART as indicated by state transition . Once the host device sends the WRITE TRANSFER command the host device then waits for UART to reply with an ACK signal at state as indicated by state transition . Once the ACK signal is received as indicated by state transition at state the host device sends a data block to the device. As indicated by state transition the host device returns to state to wait for the ACK signal from UART . The host device might return to state and state one or more times as indicated by state transitions and depending on how many data blocks are included in the WRITE TRANSFER command. As indicated by state transition once the ACK signal for the last data block is received by the host device the host device sends a status request to UART at state . After sending the status request the host device waits at state for the ACK signal and status data from UART as indicated by state transition . Once the host device receives the ACK signal and status device from UART the host device returns to IDLE state as indicated by state transition .

If the host device is sending a READ TRANSFER command at state the host device sends the READ TRANSFER command to UART as indicated by state transition . Once the host device sends the READ TRANSFER command the host device then waits for UART to reply with an ACK signal at state as indicated by state transition . Once the ACK signal is received the host device sends a data request for at least one data block to UART as indicated by state transition . As indicated by state transition the host device waits at state for UART to send the ACK signal and requested data. As indicated by state transitions and the host device might transition between states and one or more times depending how many data blocks are requested in the READ TRANSFER command. As indicated by state transition once the ACK signal for the last data block is received by the host device the host device sends a status request to UART at state . After sending the status request the host device waits at state for the ACK signal and status data from UART as indicated by state transition . Once the host device receives the ACK signal and status device from UART the host device returns to IDLE state as indicated by state transition .

The logging data transfer LDT protocol sends logging information from media controller to the host device. In embodiments of the present invention the LDT protocol sends datagram type packets asynchronously interleaved with CDT packet traffic if any . For example an LDT packet might be sent by UART in between the states shown in . LDT checksum errors might be detected by the host device for an LDT packet but there is no way for the host device to re request the packet from UART and the host device and UART do not send ACK signals for LDT packets. Since no timeouts or retries are implemented in the LDT protocol a packet is sent only once whether the host receives it correctly or not. If a packet is not properly received the host device might choose to ignore the entire packet.

LDT packets might be fixed or variable length. Logging information might generally include a timestamp a sequence number of a process operating on media controller and variable data such as for example internal log files maintained by media controller for tracking for example firmware faults error codes or other firmware statistics. Embodiments of the present invention might employ the SLIP Serial Line Internet Protocol protocol to transfer binary data.

As described herein embodiments of the present invention might employ one or more processors in a single SoC or be implemented as an embedded system having one or more distributed microprocessors. Embodiments of the present invention provide for bundling one or more binary images together into a single binary package file. In systems employing multiple processors each processor might be loaded with a unique firmware binary image file and initialization data. Thus it is beneficial to update the firmware for each of the processors as a set to maintain proper operation of the SoC. Thus embodiments of the present invention package all required binary images into one package file which updates all binary images of the system in a single update and eliminates the need to check compatibility between the one or more binary files of the system. If in the process of updating the one or more images contained within the package file one update fails the entire update might be considered failed .

In an embedded system having multiple processors one processor is generally employed as a boot processor meaning that it is the first processor to start up. The boot processor might direct the boot sequence of any other processors and components within the embedded system. The boot processor generally might boot using data stored in a static read only memory ROM . For example the ROM might be included in infrastructure subsystem of .

The data stored in the ROM might include memory addresses for other elements of the operating system and firmware. When a firmware update is performed the boot processor might start up based on data stored in the ROM and then find and access and decrypt the binary image package file. One or more versions of system firmware i.e. one or more image package files might be stored in a reserved area of the media . As described in related U.S. patent application Ser. No. 12 643 471 filed Dec. 21 2009 media might be divided into one or more separate physical spaces such as an anchor space a reserved space and a data space. The anchor space might contain data that must be stored in particular physical position in media for example a portion of the software or firmware for media controller or configuration files or other data required by media controller at power up. The boot processor might then extract the relevant individual binary images for each of the processors in the system and provide the update images to each processor.

One or more firmware package versions might be stored in media i a GOOD version is the current booted presumably good version ii a NEW version might be an incoming image package file for a firmware update and iii a BAD version might be an incomplete or failed update. For example upon a system reset the boot processor will attempt to boot the new incoming version of firmware. If the new version is successfully booted the boot processor will mark the new image file as GOOD . If the new version does not boot properly the system will revert to the previous version which is still marked GOOD and boot the previous version. The boot processor might also mark the new image file as BAD or might delete the new image file entirely. Thus embodiments of the present invention provide some protection against the system becoming locked up due to a bad or aborted firmware update.

In embodiments of the present invention the binary image package file might be encrypted employing any desired encryption algorithm using a shared key i.e. XTEA . Encryption might be desired to thwart a hacker s attempt to modify the existing image package. When loaded to the intended embedded device the package is first decrypted by the boot processor using the shared key and then is extracted.

Therefore as described herein embodiments of the present invention provide a transceiver for transferring data between a media controller and a host device through a communication link. The transceiver includes a first interrupt generator configured to i generate a first interrupt when a command is received from the host device and ii provide the received command to a receive buffer. A command processing module i retrieves the received command from the receive buffer ii processes the received command and iii provides data request data in response to the received command to a transmit buffer. A datagram generator is configured to provide datagram data to the transmit buffer and a second interrupt generator is configured to generate a second interrupt when data in the transmit buffer is ready for transmission. The transmit buffer interleaves i the data request data in response to the received command and ii the datagram data when provided to the communication link.

Reference herein to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment nor are separate or alternative embodiments necessarily mutually exclusive of other embodiments. The same applies to the term implementation. 

While the exemplary embodiments of the present invention have been described with respect to processing blocks in a software program including possible implementation as a digital signal processor micro controller or general purpose computer the present invention is not so limited. As would be apparent to one skilled in the art various functions of software may also be implemented as processes of circuits. Such circuits may be employed in for example a single integrated circuit a multi chip module a single card or a multi card circuit pack.

The present invention can be embodied in the form of methods and apparatuses for practicing those methods. The present invention can also be embodied in the form of program code embodied in tangible media such as magnetic recording media optical recording media solid state memory floppy diskettes CD ROMs hard drives or any other non transitory machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. The present invention can also be embodied in the form of program code for example whether stored in a non transitory machine readable storage medium loaded into and or executed by a machine or transmitted over some transmission medium or carrier such as over electrical wiring or cabling through fiber optics or via electromagnetic radiation wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. When implemented on a general purpose processor the program code segments combine with the processor to provide a unique device that operates analogously to specific logic circuits. The present invention can also be embodied in the form of a bitstream or other sequence of signal values electrically or optically transmitted through a medium stored magnetic field variations in a magnetic recording medium etc. generated using a method and or an apparatus of the present invention.

It should be understood that the steps of the exemplary methods set forth herein are not necessarily required to be performed in the order described and the order of the steps of such methods should be understood to be merely exemplary. Likewise additional steps may be included in such methods and certain steps may be omitted or combined in methods consistent with various embodiments of the present invention.

As used herein in reference to an element and a standard the term compatible means that the element communicates with other elements in a manner wholly or partially specified by the standard and would be recognized by other elements as sufficiently capable of communicating with the other elements in the manner specified by the standard. The compatible element does not need to operate internally in a manner specified by the standard.

Also for purposes of this description the terms couple coupling coupled connect connecting or connected refer to any manner known in the art or later developed in which energy is allowed to be transferred between two or more elements and the interposition of one or more additional elements is contemplated although not required. Conversely the terms directly coupled directly connected etc. imply the absence of such additional elements. Signals and corresponding nodes or ports may be referred to by the same name and are interchangeable for purposes here.

It will be further understood that various changes in the details materials and arrangements of the parts which have been described and illustrated in order to explain the nature of this invention may be made by those skilled in the art without departing from the scope of the invention as expressed in the following claims.

