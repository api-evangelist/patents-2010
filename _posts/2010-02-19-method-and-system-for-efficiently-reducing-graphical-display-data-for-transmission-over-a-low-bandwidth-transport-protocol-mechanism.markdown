---

title: Method and system for efficiently reducing graphical display data for transmission over a low bandwidth transport protocol mechanism
abstract: The present invention improves the performance of distributed systems by reducing the amount of graphical data transmitted between an application server and a thin client. The encoding technique used for graphical data is adapted in response to the repetitiveness of the graphical data during a particular client-server session. Indexes are maintained that are indicative of this repetitiveness and which identify a particular location in the client's cache memory storing the graphical data. Where the index is not found, but a fuzzy key indicates a strong likelihood that the graphical object is located at the client, the client's persistent storage memory is searched for a file name corresponding to the fuzzy key and which stores the graphical object therein.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08290907&OS=08290907&RS=08290907
owner: Citrix Systems, Inc.
number: 08290907
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20100219
---
This claims priority to and the benefit of U.S. Pat. No. 8 099 389 filed Feb. 6 2009 that claims priority to U.S. Pat. No. 7 502 784 issued Mar. 10 2009 that claims priority to U.S. Pat. No. 7 028 025 issued Apr. 11 2006 that claims priority to U.S. provisional patent application Nos. 60 207 532 filed May 26 2000 and 60 225 217 filed Aug. 14 2000 the entirety of which are incorporated herein by reference.

The present invention relates generally to communication between an application server and a thin client in a distributed system and in particular to the reduction in the amount of graphical display data transmitted over a low bandwidth transport protocol mechanism.

Distributed computer systems utilize the technique of distributing application execution. More specifically an application server locally executes an application program and provides the application output data to clients network users who then display the results on a display screen coupled to their local computer. By performing the application processing functions at the server and displaying the application output at the client these distributed systems make the best use of server and client resources i.e. the more capable server performs the compute and memory intensive application processing functions while the client with potentially greater video performance displays the output. During execution of the application program a user of the client views the application output data on the client s display and interacts with the application program via keyboard or mouse inputs. The client user s inputs correspond to requests to the application server to perform certain actions that affect the operation of the application program. The application server passes these requests to the application for further processing. The application server also intercepts the application output data generated by the application program and typically targeted to the operating system of the application server and transmits all or part of the data to the client for display. From the perspective of the user the application program seems to be executing locally even though it is actually being executed on a remote server and just being displayed locally.

The performance of distributed systems depends to a large degree on the capability of the network which couples the client and the server and therefore on the amount of graphical data corresponding to the application output data that is transmitted over the network. Since the application server and the client workstation are generally linked only by a transport mechanism such as serial lines telephone lines local area networks and wide area networks that possesses lower bandwidth than would be otherwise available if the application program were executing locally the perceived performance of the distributed system may suffer. Accordingly manufacturers of distributed systems software continually strive to improve the performance of such systems.

The present invention improves the performance of distributed systems by reducing the amount of graphical data e.g. bitmapped graphical data encoded bitmaps glyphs and line data transmitted between the server and the client. The invention achieves this reduction in several different ways for example by encoding the graphical data into a smaller object by representing a graphical object with indicia of the object by increasing the repetitiveness of the data in the protocol stream so that compression algorithms operate more efficiently by tracking and leveraging the prior transmissions of identical repetitive graphical objects by adapting the rate of processing activity or the encoding technique in response to changes in the network performance or in response to performance mismatches between the client and server and in several other ways described herein.

In one embodiment the present invention enables the efficient transmission of graphical display data from an application server node to a client node. In this embodiment the invention intercepts a plurality of graphical display information commands issued by an application executing on the server. Once these commands have been intercepted or otherwise obtained they are analyzed to determine whether they should be selected for further transmission to remote client nodes. The selected commands are then encoded and packaged into a protocol packet stream for eventual transmission to the remote client nodes. Prior to transmission the packet stream can be further compressed by subjecting the encoded packets to compression techniques.

The encoding technique of the present invention substantially maximizes compression of the protocol packet stream by building in repeatability into the protocol stream that allows the compression algorithm to substitute pointers for repetitive data. This technique focuses on maximizing the efficiency of the compression algorithm rather than solely reducing the amount of data via encoding prior to transmission. The result of this encoding scheme is that the degree of compression is significantly increased for many types of graphical data. The encoding technique of the present invention encodes the graphical data so that portions of the graphical data that repeat are encoded in the same manner. The compression algorithm then operates on this repetitive encoded data to realize a greater degree of efficiency.

In one embodiment the present invention efficiently reduces the amount of repetitive graphical data transmitted to a remote display device coupled to the client. In this embodiment a server agent searches for an index that may have been previously stored on the server by the server agent associated with the graphical data and which is indicative of a prior transmission of the graphical data to a client agent. The index or handle represents a memory location in the client s cache memory that currently stores the previously transmitted graphical data. If the index is found then the index is transmitted to the client agent thus avoiding the need to transmit the graphical data itself. The client agent obtains the graphical object stored in the cache location identified by the index and performs additional processing activities as directed by the server agent. In one aspect of the invention commands and information transmitted between the server agent and the client agent are queued at the server. The commands in the queue can then be processed in accordance with an estimate of the relative performance between the client and server agents or computers.

If the server agent is unable to locate the index the server agent searches a fuzzy database for a fuzzy key that is associated with the graphical data. The fuzzy key for example corresponds to a length of the graphical data. The fuzzy key indicates that the graphical data had at one time been transmitted to the client and that there is a strong likelihood that the graphical data is stored within the client s persistent storage memory. One or more fuzzy keys are provided to the server agent upon initiating a session between the client and server agents. Alternatively the fuzzy keys are transmitted to the server agent in accordance with a predetermined polling interval. Regardless of how the fuzzy keys are received the server agent stores them in the fuzzy database for subsequent use during the client server session. The fuzzy database relating to a particular session can also be maintained beyond the term of the session so that it is available for future sessions by for example having the client agent persistently cache the graphical data from the particular session and causing the server agent to dynamically construct the fuzzy database on the server from the client s persistently cached graphical data during a future session. This may prove useful in environments where frequent but short sessions are present.

If the fuzzy key is located then the server agent transmits the fuzzy key together with a command to the client agent which for example retrieves the graphical data stored in its persistent storage memory and copies it into its volatile memory. If the client agent fails to retrieve the graphical data the server agent can transmit the graphical data together with a recovery marker to the client agent.

If the server agent is unable to locate the fuzzy key within the fuzzy database the server agent forms the fuzzy key and stores the fuzzy key in the fuzzy database. The server agent then transmits the fuzzy key an index and the graphical data to the client agent which is instructed to store the data in the client s volatile memory associated with the index. As the client server session continues and the client s volatile memory becomes full graphical data will be transferred into the client s persistent storage. In one aspect the client agent stores the graphical data in a file residing in the persistent storage memory that reflects the fuzzy key as part of the file s name.

In one aspect of the invention the server agent instructs the client agent to update an off screen surface coupled to the client agent using the graphical data identified by the server agent and or stored in the client s volatile or persistent storage memory. These instructions can be triggered in response to a change in the off screen surface such as when the off screen surface and on screen surface of the client node interact. If the client agent fails to update the off screen surface in accordance with the server agent s instructions the server agent can transmit the graphical data to the client agent and direct that the client agent update portions of its on screen or off screen surfaces which may have been corrupted with the transmitted graphical data.

Further the encoding technique used to encode the graphical data prior to transmission can be selected based on an estimate of the network conditions of the network that couples the client agent with the server agent. This estimate can correspond to a time differential measured by the client agent that relates to the amount of time expended to receive a particular encoded graphical data.

In one embodiment the present invention adapts a processing rate in response to changing network conditions. In one aspect of the invention the server agent processes graphical data addressed to the client agent at a first rate. By determining the network conditions of the network that couples the client and server agents the server agent can adjust its processing rate from the first rate to a second rate in response to a change in the network conditions. The server agent can determine information about the network conditions by transmitting the processed graphical data to the client agent and instructing the client to measure a time differential associated with the transmission or receipt of the graphical data. In this manner the time differential provides an indicator of the network conditions and the server agent can rationally select the second rate in accordance with this time differential. Similarly the encoding technique used while processing the graphical data by the server agent at the first rate can be modified to a second encoding scheme technique in response to changes in the network conditions that are determined by the server agent. The network conditions can be estimated in accordance with the time differential discussed previously. Once the second encoding technique is selected by the server agent the server agent will process subsequent graphical data using this second encoding technique.

In one embodiment the invention adapts a processing rate of the server in response to a performance mismatch between the server and the client coupled to the server via the network. In operation the server agent processes graphical data and determines a first time period associated with such processing. For example the first time period can be determined by scrolling a frame buffer of the server. The client agent also processes the graphical data and determines a second time period associated with its processing. The server agent then determines the time differential between the first and second time periods and adjusts its processing rate in accordance therewith.

In one embodiment the invention efficiently reduces the amount of graphical line data transmitted from a server to a client via a communications network. The server agent separates a path defining a line or region into a plurality of strips where each of the strips have a beginning and an endpoint coordinate defined within a coordinate system e.g. a Cartesian coordinate system . The coordinate system corresponds to a region of a display surface associated with the client. In one aspect of the invention the server agent quantizes the coordinate system into a plurality of quantized angles e.g. 16 quantized angles and determines the endpoint coordinate of one of the plurality of strips. The coordinate system is then normalized so that its origin coincides with this endpoint coordinate. The beginning coordinate of the adjacent strip in the path is then associated by the server agent with the endpoint coordinate of the first strip. The server agent then selects one of the quantized segments of the coordinate system as corresponding to an approximate angle of the adjacent strip. This technique enables the transmission of the difference between the endpoint coordinates of the two strips i.e. the strip length and an indication of the selected quantized angle and thus avoids having to transmit both sets of coordinates or a coordinate and the precise angle for each strip.

In one embodiment of the invention the server agent remotely controls the formation of an off screen surface at a client which is coupled to the server via a communications network. The server agent informs the client agent that an off screen surface of a particular size or type is to be formed within the client s memory and the client agent responds by selecting and allocating a first memory region having an appropriate format to represent the off screen surface from a plurality of available memory regions in the client s memory. The server agent then either transmits a bitmap or an indicia of the bitmap e.g. index or fuzzy key to the client agent and instructs the client agent to copy the bitmap to a particular location within the first memory region. Once the bitmap is copied to the off screen surface it can be used to update the client s on screen surface. Such off screen operations can also be performed for non bitmap data such as lines or text.

The server agent can also respond to error conditions by storing a duplicate of the client s off screen surface in the server s local memory. In the event of an error condition such as when a preselected memory region of the client s memory is not sufficiently large enough to store a particular off screen surface the client agent asynchronously informs the server agent of the error. In response to the error condition the server agent transmits at least one portion of its duplicate off screen surface or a copy of the bitmap to the client agent and instructs the client agent to update the client s on screen surface using the transmitted duplicate off screen surface data.

The present invention reduces the amount of graphical data transmitted between an application server which is executing an application program and a subscribing client which is locally displaying the output data of the application program by encoding the data into relatively small representations that repeat within the protocol stream transmitted between the client and the server. In this manner the invention minimizes the size of each discrete data element that must be transmitted and increases the repeatability of the data within the protocol stream so that compression algorithms that operate more efficiently on repetitive encoded data can realize a greater degree of compression efficiency. The invention uses a number of techniques to realize this enhanced compression including the following scanning a command queue for later issued commands which supercede earlier issued commands disk caching techniques that improve compression of data that has been previously encountered during a client server session transmission of relative coordinates using quantized regions to avoid sending both endpoints and or the angle of an associated strip and manipulation of off screen surfaces to enhance performance during the client server session. The invention also reduces the frequency of overscroll problems encountered when there is a performance mismatch between a fast server and a relatively slow network or client.

With reference to one or more client nodes hereinafter each client node or plurality of client nodes is generally referred to as are in communication with one or more server nodes hereinafter each server node or plurality of server nodes is generally referred to as via a communications network . The network can be a local area network LAN a medium area network MAN or a wide area network WAN such as the Internet or the World Wide Web. Users of the client node can be connected to the network through a variety of connections including standard telephone lines LAN or WAN links e.g. T1 T3 56 kb X.25 broadband connections ISDN Frame Relay ATM and wireless connections. The connections can be established using a variety of communication protocols e.g. TCP IP IPX SPX NetBIOS and direct asynchronous connections . In some particularly advantageous embodiments the protocol used may be the Independent Computing Architecture protocol manufactured by Citrix Systems Inc. of Fort Lauderdale Fla. or the Remote Display Protocol manufactured by Microsoft Corporation of Redmond Wash.

The client node can be any personal computer e.g. 286 386 486 Pentium Pentium II Macintosh computer Windows based terminal Network Computer wireless device information appliance RISC Power PC X device workstation mini computer main frame computer or other computing device that has a windows based desktop and sufficient memory for executing a small display presentation program. The display presentation program uses commands and data sent to it by the application server across the network to render a graphical display. In a distributed computer system model the execution of application programs occurs primarily on the application server and the user interface keystrokes and mouse movements produced by client side inputs are transmitted over the network to and from the client node .

The client node typically includes a processor a volatile memory e.g. RAM cache an operating system a client agent a persistent storage memory a network interface e.g. a network interface card a keyboard a mouse and a display . Windows oriented platforms supported by the client node can include without limitation WINDOWS 3.x WINDOWS 95 WINDOWS 98 WINDOWS NT 3.51 WINDOWS NT 4.0 WINDOWS 2000 WINDOWS CE MAC OS Java and UNIX. The client agent corresponds to a software program that receives commands and data from the server node and from a user not shown of the client node . The client agent uses the received information when interacting with other components of the client node e.g. when directing the operating system to output data onto the display . The client agent also transmits requests and data to the server node in response to server issued commands or user actions at the client node .

Similarly the server node includes a processor a volatile memory an operating system an application program a server agent persistent storage memory and a network interface . The server agent corresponds to a software program that interfaces with the client agent and other components of the server node to support the remote display and operability of the application program .

Each application server hosts one or more application programs that can be accessed by the client nodes . Examples of such applications include word processing programs such as MICROSOFT WORD and spreadsheet programs such as MICROSOFT EXCEL both manufactured by Microsoft Corporation of Redmond Wash. financial reporting programs customer registration programs programs providing technical support information customer database applications or application set managers.

During execution of the application program a server communicates with the client node over a transport mechanism part of the server agent . In one embodiment the transport mechanism provides multiple virtual channels and one of the virtual channels provides a protocol for transmission of graphical screen data from the server node to the client node . The server executes a protocol driver part of the server agent that intercepts graphical display interface commands generated by the application program and targeted at the server s operating system and translates them into a protocol packet suitable for transmission over the transport mechanism.

In one embodiment and with reference to the server agent intercepts a graphical display interface command step issued by the application program and directed to the operating system encodes graphical data associated with the command and the application program step compresses the encoded graphical data step creates a transport protocol packet incorporating the intercepted command and compressed encoded data step and transmits the transport protocol packet to the target client node step . Graphical data refers to any type of data that can be displayed on the display such as bitmaps glyphs coordinates list of lines strips etc. Hereinafter descriptions of techniques which are applied to particular types of graphical data or graphical objects can be construed to apply to all types of graphical data.

More particularly a protocol driver of the server agent intercepts the graphical display interface commands step . In one embodiment the protocol driver intercepts high level application programming interface calls made by the application program . In one embodiment the protocol driver intercepts GDI commands provided by WINDOWS based operating systems. In another embodiment the protocol driver intercepts QUICKDRAW commands provided by MAC OS based operating systems. In still other embodiments the protocol driver intercepts lower level commands such as interface calls to the device driver associated with the graphical display of the server node . In still other embodiments the graphical display interface command may be duplicated rather than intercepted. In these embodiments the display of the application program output data on the server and the client will be substantially similar if not identical. The protocol driver creates a transport protocol packet based on the intercepted graphical display command step . The protocol driver may use a protocol command set that contains an analogous command for each possible intercepted display interface command. Alternatively the protocol driver may use a command set that is a subset of the intercepted display interface commands. In other embodiments the protocol command set may be a superset of the possible intercepted display interface commands.

For each intercepted GDI command and affected graphical data that must be transmitted to the client agent in order to display the output of the application program on the client s display the server agent queues the related protocol command together with a unique key associated with the affected graphical data. The unique key describes and uniquely identifies the graphical data. In one embodiment the unique key is generated by performing a 64 bit cyclic redundancy check CRC on the graphical data. In another embodiment the 64 bit CRC is generated as two 32 bit CRCs performed on the graphical data sequentially and in opposite directions. Other methods of generating a unique key associated with graphical data as known to one skilled in the art may also be used. The protocol command and the unique key are queued at the server together with other command unique key sets. The queued commands are then scanned to ascertain whether later issued commands i.e. those near the back of the queue supersede earlier issued commands i.e. those closer to the front of the queue . If the earlier issued commands are superceded then the server agent removes them from the queue and thus avoids having to transmit unnecessary data to the client agent .

For example a series of commands to display the next page of data issued in quick succession need not be displayed individually at the client . All that need be displayed is the last display page issued since this last page of data will overwrite all previous pages of data. By removing the unnecessary commands and unique keys corresponding to the earlier pages from the server s queue the server agent substantially reduces the amount of data that must be processed and transmitted.

In one illustrative embodiment only unnecessary commands and related data pertaining to opaque operations are removed from the server s queue. For example if a previously queued command involving the creation of a rectangular region having coordinates 10 10 50 50 is followed by a more recently queued command involving the creation of a larger covering rectangular region having coordinates 0 0 100 100 then the previously queued command and related data is deemed unnecessary and is removed from the queue.

Table 1 below lists an exemplary set of protocol commands provided in one embodiment of the invention.

In one embodiment the protocol commands and associated graphical data are configured to maximize the repetition of information in the protocol packet stream created by the protocol driver. In one aspect of the invention the graphical data is first encoded step prior to subjecting the encoded graphical data and or protocol commands to a compression algorithm step that takes advantage of the repetitive nature of the protocol stream e.g. a Lempel Ziv compression protocol may be used . In one embodiment and upon the first instance of the graphical data in the client server session an indicia of the graphical data is transmitted together with the corresponding encoded data in the protocol stream so as to reduce the amount of data transferred via the network for future instances of the graphical data occurring during the same client server session. The compressed data is subsequently bundled into the transport protocol packet and transmitted to the client node step for decompression and interpretation.

In one illustrative embodiment the application program executes a GDI command that instructs the server s operating system to draw a bitmap. The server agent intercepts this GDI command step and issues a BITBLT command to the client agent which instructs the client agent to display the application program s output data on the client s display . Prior to issuing the BITBLT command the server agent encodes the output data step and includes the encoded data together with the BITBLT command in the compressed protocol packet stream transmitted to the client agent . In one embodiment the data describing the bitmap is encoded and compressed steps and to take advantage of some of the redundancies present in the bitmap . For example the bitmap may be such that successive raster lines are redundant or adjacent pixels are redundant.

In addition to encoding bitmaps or other discrete graphical data elements based on their internal data redundancies the invention also incorporates caching techniques that further improve the encoding and compression of graphical data that has been previously encountered during a particular client server session. For example when a particular bitmap is first encountered during a client server session it is encoded as described above. For subsequent transmissions of the bitmap during the same client server session indicia of the bitmap can be transmitted rather than the relatively larger encoded bitmap. In one embodiment the indicia correspond to a location within the client s volatile memory that contains the previously transmitted bitmap.

More particularly and with reference to the server agent generates the unique key step as described above and associates the unique key with the graphical data e.g. bitmap . This association essentially defines the bitmap and its related data as a graphical object which is subsequently registered together with its unique key and encoded data step in a data structure e.g. a table stored in the server s volatile memory e.g. the server s cache subsystem . In other embodiments the bitmap related data may be written into the server s persistent storage .

Assuming that the protocol command e.g. BITBLT and associated graphical data are not superceded by later issued commands as described previously the server agent dequeues step the BITBLT command and the unique key from the queue and searches the table stored in the server s volatile memory to determine if the unique key had been previously stored therein. If the unique key is located within the table then the server agent determines that the encoded data has been previously processed by the server . The server agent then searches the table for an index or handle associated with the encoded bitmap . If the index is located then the server agent determines that the encoded bitmap has not only been processed by the server but that it has also been previously transmitted to the client agent . If the index is not located within the table then the server agent determines that the encoded bitmap has not been previously transmitted.

In one embodiment the index identifies a particular location within the client s volatile memory which stores the previously transmitted encoded bitmap . In one embodiment the client agent provides a snapshot of its available volatile memory to the server agent upon initiating a client server session with the server agent . Once the session is established the server agent thereafter controls the allocation of the client s available volatile memory . In this manner the server agent is able to allocate the client s volatile memory to the encoded bitmap and to maintain the index as a pointer or reference to the allocated memory and as an identifier of the previously transmitted encoded bitmap .

If the index is located within the server s table the server agent obtains the index step compresses the index together with the related protocol command step and transmits the compressed data in a packet directed to the client agent via the network . In one embodiment the index is shorter in length e.g. 16 bits than the unique key e.g. 64 bits and consequently consumes less bandwidth when transmitted. Upon receipt and decompression of the compressed packet the client agent accesses the particular memory location in the client s volatile memory that is specified by the index in order to obtain the appropriate graphical data . The client agent subsequently manipulates the obtained graphical data in accordance with the command which accompanied the index in the compressed packet. In this manner the invention avoids having to retransmit relatively large bitmap or other graphical data that have been previously encountered during a particular client server session.

If the index is not located within the server s table and thus has not been previously transmitted to the client agent the server agent allocates a portion of the client s volatile memory for the bitmap and forms the index that identifies the memory location. The server agent then stores the encoded bitmap corresponding to the bitmap the newly formed index and the unique key associated with the encoded bitmap in the server s table . The server agent subsequently compresses the encoded bitmap the index and related command and transmits the compressed data in a packet directed to the client agent . Upon receipt and decompression the client agent decodes the encoded data and stores the resulting bitmap in the memory location identified by the index and manipulates the resulting bitmap in accordance with the accompanying command. Alternatively the client agent stores the encoded data in the memory location identified by the index and only decodes the encoded data when necessary to further manipulate the resulting bitmap . In this manner client memory is more efficiently used.

Although the invention has heretofore been described with the server agent controlling the client s memory allocation and index formation it is also possible that the client agent perform these functions. For example when a bitmap is first encountered during a client server session and is encoded compressed and transmitted to the client agent with the accompanying command but without the index the client agent can determine the particular location within its volatile memory to store the bitmap . In this embodiment the client agent forms an index not shown that uniquely identifies the encoded bitmap and its corresponding memory location and transmits the index to the server agent which stores the index in the appropriate location in the server s table .

Continuing with the embodiment in which the server agent controls the allocation of the client s volatile memory the client agent maintains a circular queue of all indexes specified by the server agent in accordance with queue maintenance instructions also received therefrom. For example the server agent can direct the client agent to disassociate a predetermined block of indexes e.g. corresponding to 128K of memory from their respective graphical data in order to accommodate newly encountered graphical objects when the client s volatile memory is otherwise fully subscribed. Consequently a subsequent new graphical object acquires a previously used index.

The server agent also determines according to predetermined criteria whether to purge or save each graphical object affected by the reassignment of the indexes. The server agent communicates this decision to the client agent . For example if the server agent is reassigning indexes and and determines that the graphical objects associated with handles and are to be deleted or moved into the client s persistent storage and the objects associated with handles and are to be saved the server agent thus instructs the client agent to delete or move and and save and . The client agent then moves the index of each saved object to the tail of the circular queue. At least one index remains available at the queue tail for assignment to the moved object that is in one embodiment the head and tail of the queue do not point to the same index in the circular queue. Consequently a moved object is both stored in a different physical memory location and associated with a different index.

The maintenance actions performed on the client s circular queue will typically become more frequent as the client server session continues and the limited volatile memory of the client becomes full of previously transmitted bitmaps or other graphical objects. Accordingly the number of previously transmitted graphical objects that are moved into the client s persistent storage from volatile memory increases. The present invention further enhances the caching technique described above to search for indicia see fuzzy key below of previously transmitted graphical objects that may be stored in the client s persistent storage when an index to that graphical object is not found in the server s table . If such indicia is found then there is a strong likelihood that the previously transmitted graphical object is still locally resident and accessible to the client agent and that the graphical object may not therefore need to be retransmitted from the server agent to the client agent . It is important to note that locating such indicia provides a strong likelihood but not a certainty that the graphical object is locally resident because other programs or client agents which may share the same persistent storage may have deleted the graphical object from persistent storage e.g. to make room in the persistent storage for a new object .

More particularly and with reference to if the server agent is unable to locate an index for a particular bitmap in the server s index table the server agent searches a second table hereinafter fuzzy database for an entry hereinafter fuzzy key associated with the bitmap step . In one embodiment each fuzzy key is a combination of the unique key in the server s table and the length size of the associated bitmap . The fuzzy key can be formed for example via an XOR exclusive OR of both 32 bit CRCs used to compute the 64 bit unique key in the server s table and the length of the bitmap associated with the unique key . The fuzzy database essentially provides an initial prediction as to whether the persistent storage of the client has a copy of the bitmap stored therein. If the fuzzy database does not contain the fuzzy key associated with the bitmap then the client s persistent storage probably does not have a stored copy of the bitmap and the server agent will therefore need to transmit an encoded version of the bitmap to the client agent as previously described. On the other hand if the fuzzy database contains the fuzzy key for the bitmap then there is a strong possibility that the bitmap is stored in the client s persistent storage .

In more detail when the server agent does not find a fuzzy key in the fuzzy database that is associated with the bitmap the server agent sends an encoded bitmap corresponding to the bitmap to the client agent with a command that requests the client agent to store the bitmap or the corresponding encoded bitmap in the volatile memory step . Also and as described above the server agent adds the fuzzy key associated with the bitmap to the fuzzy database step . Note that the order of steps and can be reversed such that the fuzzy database is updated prior to the transmission of the command and the encoded version of the bitmap . The client agent subsequently copies the bitmap to a particular location within the client s volatile memory as specified by the server agent step .

In one embodiment the server agent does not wait for an acknowledgement from the client agent that the encoded bitmap associated with the bitmap has been successfully received and processed. Rather the server agent assumes that the encoded bitmap has been properly processed and continues to stream protocol commands without awaiting the return of an acknowledgement message from the client agent . The server agent does however track the number of protocol commands issued since the last acknowledgement read. The server agent blocks further transmission of protocol commands if the number reaches a predefined threshold. The threshold enables the client agent to establish an upper bound on the amount of memory needed to queue incoming protocol commands during recovery mode operation as described in more detail below.

When a fuzzy key is found in the fuzzy database the server agent sends a command to the client directing the client agent to copy the bitmap associated with the fuzzy key from the client s persistent storage into the client s volatile memory step . This command is accompanied not only by the fuzzy key which uniquely identifies the bitmap of interest but also by the associated index generated by the server agent as previously described in order to identify the specific location within the client s volatile memory that will receive and store the copied bitmap . By copying the bitmap into volatile memory rather than just maintaining its location in persistent storage the invention can rapidly respond to several requests to draw the bitmap that are received in quick succession or without much intervening cache activity by copying the bitmap on the occurrence of the first request.

If the bitmap is not currently stored in the persistent storage despite the presence of the corresponding fuzzy key in the fuzzy database then the client agent returns a message to the server agent in response to the CACHE READ DISK OBJECT command previously issued by the server agent indicating that the bitmap is missing. Upon receiving this message the server agent retransmits the encoded bitmap data associated with the bitmap to the client agent step . Note that the server agent maintains a sequential list of all such CACHE READ DISK OBJECT commands sent to the client agent for which the server agent has not yet received an acknowledgement so that the server agent can properly associate a received acknowledgement with a particular bitmap so as to properly identify the encoded bitmap that needs to be transmitted .

Meanwhile the client agent enters a recovery mode in which the client agent continues to read the incoming protocol stream but does not process it. Instead the client agent builds a queue for receiving the stream of commands that continue to flow from the server subsequent to the command that failed to find the bitmap in persistent storage . The client agent continues to store these commands in this queue in FIFO first in first out fashion until the encoded bitmap is received and successfully decoded to produce the bitmap . To recognize the missing bitmap in the incoming stream of commands the client agent looks for graphical data accompanying a recovery marker in the protocol stream. In one embodiment the recovery marker is a particular pseudo random number that is XORed with the unique key of the bitmap i.e. the 64 bit CRC and 32 bit length . The server agent creates the recovery marker upon receiving a no acknowledgement message from the client agent . When the bitmap arrives the client agent stores it in its volatile memory step i.e. where the bitmap would have been stored had the object been initially present in the persistent storage and begins to process the commands in the queue. After processing all of the commands in the queue the client agent resumes processing the incoming stream of protocol commands coming from the server over the network .

An advantage to the above described recovery process is that it avoids the time delay penalty incurred by those cache systems that flush the commands in the pipeline upon the occurrence of a cache miss. Also the recovery process causes no disruption to the stream of protocol commands nor any increase in the traffic on the channel by more than a few bytes beyond what the server would have sent to the client had the server agent initially known that the bitmap was not in the persistent storage .

In one embodiment the present invention facilitates the location of the bitmap in the client s persistent storage by storing the bitmap in a file whose file name is formed by encoding the fuzzy key along with least recently used and or least frequently used information associated with the bitmap . In this manner the file name itself provides the information desired and thus avoids having to open and read the file. The encoding of the fuzzy key as part of the bitmap s file name also enables the client agent to rapidly extract the fuzzy key information from the file name and send it to the server agent during an initial boot of the client or at the start of the client server session. The extracted fuzzy keys can be transmitted to the server in an order that for example is based on the least recently used and or least frequently used information that also forms a part of the file name.

In one embodiment fuzzy keys are added to and deleted from the fuzzy database in one of three ways. First at the start up of the client agent or upon establishing a client server session with the server agent the client agent sends commands to the server agent to add a fuzzy key to the fuzzy database for each appropriate bitmap in the client s persistent storage the fuzzy keys accompany the client agent s commands . The client agent can maintain a send list that specifies an order e.g. based on most recently used or most frequently used information determined from prior client server sessions for sending fuzzy keys at startup to the server . The send list can be formed by the client agent upon reading the directory of its persistent storage and keeping a representation of the directory in volatile memory . In one aspect of the invention the client agent extracts fuzzy key information from the file name of the file which contains the bitmap when preparing the representation of the directory. Second at predetermined polling intervals the client agent polls its persistent storage to determine those bitmaps that are currently in its persistent storage e.g. by searching for file names containing a fuzzy key like structure and then sends add and or delete commands to the server agent as needed to update the server s fuzzy database . Third when the server agent sends a command to the client agent to write a bitmap into the client s persistent storage the server agent generates and stores a corresponding fuzzy key in the fuzzy database .

Transmission of bitmap data from the server to the client can take a relatively lengthy period of time particularly when the network connection between the client and server is relatively slow. In one embodiment the invention adapts the server s operation to changing network conditions by determining the relative speed of the network . For example by dynamically assessing the bandwidth of the network the server agent can modify the encoding and compression techniques used to process bitmap data in order to reduce bandwidth requirements when transmitting over a slow network. The invention processes columns of bitmap data from left to right and primes the client cache accordingly. As the encoded bitmap is being transmitted the transmission time can be monitored to determine the performance of the network . If the transmission time exceeds a threshold value the client agent can draw whatever bitmap data has already been stored in its cache and display the remaining portions of the bitmap data either in real time as it is received in the cache or at predetermined intervals. In this manner a user of the client will recognize that the client is still operating on the bitmap data and be able to discern that the client is not in a hung or failed error condition. By approximating the effective network bandwidth to the client and adapting the behavior of the server accordingly the server agent can for example instruct the client agent to use a whole bitmap versus using a whole column mode of display for a particular bitmap.

More particularly the server agent sends a Start StopWatch command followed by encoded bitmap data and a Stop StopWatch command to the client agent . The client agent responds to the Start Stop Watch command by reading the current time tick and writing it into a first array element. After the encoded bitmap is received the client agent responds to the Stop StopWatch command by reading the current time tick and writing it into a second array element. Comparing the difference in time ticks between the Start StopWatch and Stop StopWatch commands provides an estimate of the time that was expended to receive the encoded bitmap data. The resulting time difference is then transmitted back to the server agent . This procedure can be repeated to compute a smoothed moving average from which a reasonable estimate of the effective throughput of encoded bitmap data can be determined. The invention uses the throughput estimate in view of the size of the encoded data for a particular bitmap to decide whether to use whole bitmap mode e.g. if it is likely to take less than 5 seconds or use progressive whole columns e.g. if it is likely to take more than 5 seconds . Note that although this procedure does not result in a 100 accurate throughput estimate it does provide sufficient granularity to detect fast or slow network connections from which different display modes can be determined. A similar technique can be used to time large screen to screen copies at the client end and to build up a similar moving average estimate of the client s performance during these operations which can then be used to slow a producer thread on the server and prevent an overrun at the source when the server generates data faster than the client can handle it.

In one embodiment the invention forms objects that are sufficient in size to contain the data of a whole cache column. For example the maximum object size and the size of the cache can be selected by the server agent upon startup of the client server session to be a function of the size of the connection window and its color depth with larger sizes being allocated for the larger screens and depths. Further current techniques for breaking up a bitmap into columns can result in columns of less than standard width at one or both ends of the bitmap. If these nonstandard columns are too narrow then they may not be large enough to be retained in the client s persistent storage and thus will not be present at the client during subsequent client server sessions. The invention avoids this problem by merging the narrow columns with neighboring columns so that only wide columns are used and thus all parts of a splash screen for example will be contained in the persistent storage . In one embodiment whole columns are then displayed in two phases. The first phase primes the cache with any missing data and the second phase draws the column from the cache which may involve using more than one cached object. The column is therefore displayed on the display screen in an atomic fashion. As previously discussed when the network connection is slow the columns can be displayed atomically one by one to reassure the user at the client that the system is still working. Alternatively the whole bitmap can be displayed atomically using a similar technique when a fast network connection is detected.

The moving average estimate technique discussed above can also be used to mitigate longstanding overscroll problems in an application that is being executed on a fast server and that is being displayed on a relatively slow client. The overscroll problem occurs for example when a user of the client initiates a plurality of scroll commands such as by clicking on the scroll bar or dragging the scrollbar with a mouse a number of times. As the scroll commands are sent to the fast server the server performs the scrolling operations and returns the associated data faster than the slow client or slow network displays the results on its display screen . Consequently when the user at the client eventually views the desired screen position and wants to stop the scrolling by stopping the mouse clicks and or scrollbar dragging the display will continue to scroll beyond the desired screen position. This overscroll condition occurs because the fast server has already processed the scroll commands and has transmitted the appropriate data back to the client but the data has been queued at the slow client and has not yet been entirely processed.

The invention mitigates this overscroll problem by reducing its frequency of occurrence. More particularly the invention periodically times selected scroll events at the server by scrolling the frame buffer and at the client via the StopWatch commands discussed above to compute a moving average estimate of their respective speeds. In this manner the server agent estimates how long a particular scroll event will take speed times the number of pixels involved to process at the server and how long the client is expected to take and if the expected processing time at the client is larger than that of the server the server processing is suspended by the appropriate time differential so as to keep the client and server substantially in step. This approach results in many fewer overscrolls due to the time lag between the client and server as compared to the number of overscrolls occurring when this approach is not implemented.

In addition to manipulating bitmap data the present invention can also remote a text string that is generated on the server to the display of the distant client . With reference to the server executes the application program which generates a text string that needs to be remoted to the client . The server agent intercepts the commands sent from the application program to the server operating system which relate to the text string and causes a display driver of the server agent to process the text related information and to transmit a series of protocol commands to the client agent for displaying a text string on the client s display . For example the application performs procedure calls that set the text color and the background color here Hello . Execution of the TextOut procedure by the application triggers execution of the DrvTextOut procedure of the display driver . As shown the DrvTextOut procedure defines the clip region the bounding rectangle and the text mode including background and text color by executing a sequence of corresponding procedures.

Execution of such procedures cause the display driver to send the appropriate data and protocol commands such as a subset of those provided in Table 1 to the client agent . The protocol commands are received and processed by the client agent which executes procedures that specify the clip region the bounding rectangle the text mode and the glyph associated with each text character to be displayed. Note that the protocol associated with a glyph object encodes not only the glyph bitmap itself but also its relative positioning information. The server can also send other protocol commands to the client agent that direct the client agent to store the associated glyphs in volatile memory and or in the persistent storage as previously described. The client agent creates a bitmap corresponding to the size of the bounding rectangle that surrounds the text string and sets the relative positions of each glyph in its proper position within the bounding rectangle. Once the last glyph is received and its position set the client agent instructs the client operating system to draw render the bitmap on the display screen of the client .

The present invention also supports several different descriptions of paths a set of lines or curves used as part of the description of a line drawing operation or in the case of a closed path to describe a region including ellipses beziers segments strips and styles. Segments refer to line segments that when combined form a path. Similarly segments can be further parsed into strips which are portions of the line segment corresponding to a series of consecutive pixels that exhibit the same angle characteristics. The encoding technique used to represent strips for example uses relative location information and quantized angles to characterize consecutive strips in particular line segments which not only minimizes the amount of graphical line data that needs to be encoded but also results in a more repeatable sequence of data that can be more efficiently compressed. The increase in repeatability is particularly enhanced when representing strips that form a shape such as a rectangle or circle. The protocol used for strips also enables the client agent to accurately reproduce a path independently and without knowledge of the algorithm used by the server agent to convert the path into a sequence of pixels.

With reference to the nonlimiting example in a path comprises two line segments which appear to be perfectly linear. However those skilled in the art recognize that line segments that are not perfectly horizontal vertical or at a 45 degree diagonal must be approximated by a corresponding series of strips when the path is displayed on a display screen . This approximation is necessary because the individual pixels on the display screen are surrounded by at most eight other pixels that are either perfectly horizontal vertical or at a 45 degree diagonal relative to each other and thus any line segments that are at a different overall angle must be approximated by a series of strips. Accordingly and with reference to the exemplary path of segment is comprised of four strips where the individual pixels depicted by square blocks of each strip are organized at 45 degree diagonals relative to each other and segment is comprised of five strips where the individual pixels of each strip are organized horizontally relative to each other.

In one embodiment and with reference to the server agent parses the path into line segments each having a particular length and angle step . An array of line segments is then formed to store quantized segment information hereinafter referred to as a quantized angle or QA for each line segment step . With reference also to rather than computing the absolute angle associated with a particular segment the server agent instead determines in which of the sixteen quantized angles the absolute angle lies. This quantization technique determines in which sixteenth of the circumference the end point lies for a line segment starting at the center of a circle a radius . This information can be expressed as the unsigned delta from the last segment specified in this context mod initialized to 0 . This technique results in a more repeatable sequence than if the absolute angle was used particularly when the segments form a shape such as a rectangle or a circle.

The server agent then parses each line segment into strips respectively step . The length of each strip of a particular segment is subsequently stored in a strip length array for further processing step . In one embodiment the Windows NT algorithm bLine is used to break up the path into an array of strips. The NT algorithm determines the quantized angle of each strip and segment so that there is no ambiguity associated with segments or strips that lie on a boundary between quantized angle regions. The NT algorithm vertically flips a line going up so that the line is always going down the y value keeps increasing and sets the flag FL FLIP V. Similarly a line going to the left is flipped horizontally so that it always goes to the right the x value keeps increasing and sets the flag FL FLIP H. As a result the array of strips output by this algorithm fall into a single quadrant. In this particular embodiment the server agent undoes the flipping operation of the NT algorithm so that the array of strips are flipped back to their previous original quantized angles to ensure that the endpoint of a previous strip and the starting point of the next consecutive strip coincide so as to avoid having to send the starting coordinate of the next consecutive strip.

The server agent then encodes the beginning coordinate of the path together with the quantized angle data in the line segment array and pixel length data in the strip length array to form a protocol stream step . The encoded data is then subjected to a compression algorithm to take advantage of the data redundancies in the protocol stream step and the compressed graphical line data is subsequently transmitted to the client agent for decoding and further processing step .

With reference to the exemplary illustration in and the quantized angle information of the line segment comprises four strips positioned within quantized angle . The beginning coordinate of the path which is transmitted from the server agent to the client agent as part of the compressed graphical line data corresponds to the first pixel in strip positioned at the origin of . The graphical line data further includes the pixel length of each strip in the segment . Since the segment does not correspond to a perfectly horizontal vertical or 45 degree diagonal each consecutive strip and in segment is adjusted by a particular delta value as indicated in in order to properly approximate the overall angle of the segment . In the present example in order to get from the last point in the previous strip to the beginning point in the next consecutive strip the client agent displays strip at substantially the same x value and at an increasing y value. This process is repeated for each strip in the segment as well as for the strips in segment which are positioned within QA .

Accordingly and in one embodiment the protocol stream generated by the present invention when processing strips comprises the starting position of the path an index if any corresponding to a location in the client s volatile memory which may already store a particular strip transmitted some time earlier in the client server session the number of segments in the path the quantized angle of each segment from which the delta values reflected in are determined the length of each strip together with some control information and quantized angle delta information that is added to the quantized angle of a first or prior segment in order to inform the client agent of the quantized angle of subsequent segments. In this manner the invention avoids having to send coordinate and absolute angle information for each strip in the path. Further the strip processing technique discussed above facilitates the efficient compression of graphical line data by leveraging the repetitiveness of the data in the uncompressed protocol stream.

The present invention can also be applied to bitmaps that are displayed in an on screen surface as well as to bitmaps in an off screen surface e.g. that are stored in a video display adapter s memory and or in a pre allocated section of the client s volatile memory that will be operated on by a graphics conversion library . Off screen surfaces are frequently formed by applications such as Microsoft Word that write bitmaps to the off screen surface until the surface is complete at which time the off screen surface is displayed on the display screen of the client in final form as an on screen surface. Therefore off screen surfaces frequently provide the source for on screen surfaces.

In one embodiment and with respect to off screen surfaces the client agent informs the server agent as to the amount of local volatile memory available for off screen surfaces so that the server agent does not form an off screen surface larger than the client s available memory. The server agent subsequently forms an off screen surface and transmits it to the client agent with instructions to store the surface in its volatile memory . The client agent selects and allocates a particular section of its volatile memory to the surface and stores the surface therein. Each off screen surface has a set of associated attributes such as an identifier that uniquely identifies the surface pixel format dimensions drawing attributes protocol state etc.

In one embodiment in order to efficiently use the client s volatile memory the server agent can issue commands to the client agent directing that certain operations be performed to the off screen surface only when the off screen surface interacts with the on screen surface e.g. when updating the on screen surface with bitmap data from the off screen surface . If the only interaction between the on screen surface and the off screen surface is a final copy to the screen then the operations can be targeted to the on screen surface and thus reduce the amount of bitmap data that must be transmitted over the network . Alternatively the source of the on screen surface can be restricted to either correspond to an off screen surface stored remotely at the server or to an off screen surface stored locally at the client . Typical operations to the off screen surface that are requested by the server agent include updating the bitmap in the off screen surface with updated text line or other data.

In one embodiment and with reference to the server agent intercepts calls made to the server operating system which relate to the creation of an off screen surface and the server agent forms a duplicate copy of the surface and stores it along with its attributes in the server s local memory. The server agent then issues a command to the client agent to form the off screen surface in the client s volatile memory step . The command is accompanied by an encoded representation of the off screen surface if this is the first instance of the off screen surface or by an index or fuzzy key if the off screen surface has been previously transmitted during the client server session step . The server agent instructs the client agent to incorporate the graphical data identified by the index fuzzy key indicia or encoded surface into the client s off screen surface step . The client agent responds to the server agent s instructions by copying the identified surface bitmap to the client s off screen surface step . If a BITBLT command issued by the server agent fails for example to form a bitmap in the client s off screen surface such as when a memory allocation error occurs the client agent sends a C2S OSS Error command to the server agent indicating the failed condition step . In response to the error condition the server agent uses its local copy of the off screen surface as the source for updating the client s off screen surface. The client agent uses the information received from the server s local copy to update the off screen surface on the client and to correct any corrupted dirty regions of the off screen surface. Alternatively when an error condition is encountered the server agent transmits its local duplicate copy of the off screen surface step to the client agent and instructs the client agent to use the duplicate surface as the source for updating the client s on screen surface and to discard the corrupted off screen surface at the client step .

Although the present invention has been described with reference to specific details it is not intended that such details should be regarded as limitations upon the scope of the invention except as and to the extent that they are included in the accompanying claims.

