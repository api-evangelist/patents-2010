---

title: Playing digital content from satellite radio media based on taste profiles
abstract: A portable content-playing device which automatically constructs a virtual channel of content consistent with the tastes of the user of the device, where the content originates from one or more satellites. The portable device contains software for computing similarity values between a local taste profile (representative of the songs tastes of the user of the device) by making use of downloaded pattern-matching technology representing each song, and this information is used in choosing the content of the virtual channel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08190082&OS=08190082&RS=08190082
owner: Emergent Music LLC
number: 08190082
owner_city: Portland
owner_country: US
publication_date: 20100823
---
This application is a continuation of U.S. patent application Ser. No. 11 974 634 filed 15 Oct. 2007 U.S. Pat. No. 7 783 249 which is a divisional of U.S. patent application Ser. No. 11 230 274 filed Sep. 19 2005 which is a continuation in part of International Patent Application PCT US2005 02731 filed 27 Jan. 2005 for Enabling Recommendations and Community By Massively Distributed Nearest Neighbor Searching which claims priority from and benefit of the following U.S. Provisional Patent Applications 60 540 041 filed 27 Jan. 2004 for Enabling Recommendations and Community by Massively Distributed Nearest Neighbor Searching 60 611 222 filed 18 Sep. 2004 for Community and Recommendation System and 60 635 197 filed 9 Dec. 2004 for Community and Recommendation System. Applicant hereby claims priority from and benefit of the aforesaid applications 60 611 222 and 60 635 197. Applicant hereby incorporates by reference herein to the fullest extent allowed by law the entire disclosure of each of the aforesaid applications including all text drawings and code whether on paper or machine readable media.

This application includes material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent disclosure as it appears in patent office files or records but otherwise reserves all copyright rights whatsoever.

Applicants hereby incorporate by reference the entire contents of the material on the compact disc submitted concurrently herewith and as listed below. The disc was created on 17 Sep. 2005. Applicants submit herewith two individual compact discs each being identical to the other.

The present invention is in the fields of collaborative filtering and online community typically as implemented on networks of communicating computers.

Collaborative filtering systems are well known as are online community systems. Examples of the former include Amazon.com s recommendation technology and other similar systems such as eMusic.com s. Examples of the latter include Google Groups.

However none of the existing solutions effectively leverages the fact that users of online recommendations systems and online community systems typically own their own computers and have the opportunity to make the central processing units of those computers available for making such systems more useful and enjoyable.

In particular the task of matching people with extremely similar tastes and interests becomes very computationally difficult as the number of people increases and as the complexity of the similarity measure increases. With hundreds of thousands or even millions of people such as are typically enrolled in major online services limitations of server hardware resources constrain the system s ability to find the best matches between people based on taste and interest.

To the degree that such matches are made with real accuracy neighborhoods of individuals with extremely similar interests may be formed that can be used for purposes of recommendation and community.

What is needed then is an effective way of leveraging the computers owned by end users of a community and recommendation system for the purpose massively distributed similarity searching.

The present invention puts the computer used by a particular end user the client computer or client machine to work in finding his or her best matches thus offloading that computational load from the server. In some variants some users computers may do that work for a manageable number of Other users for purposes of example this summary will not discuss those details. 

To enable the computations to occur in the client machines the necessary data needs to be transported there. This data consists at least in part of profiles of various users. Various embodiments do this in different ways the common denominator being that profiles that are relatively likely to be matches to the user for whom neighbors are being sought arrive first.

Then the client computer conducts a substantially or completely exhaustive search of that available data for the very best matches.

Typically at least part of the profile data performs a dual purpose. First it is used for similarity calculations. Second it is used for display purposes so that a user can view taste information pertaining to his neighbors. For instance in a typical music application this will include song title and artist information for songs in the neighbors collections.

This disclosure will make use of a detailed listing of key aspects followed by a glossary containing definitions for terms used therein.

ASPECT 1. A networked computer system for supplying recommendations and taste based community to a target user comprising 

networked means for providing representations of nearest neighbor candidate taste profiles and associated user identifiers in an order such that said nearest neighbor candidate taste profiles tend to be at least as similar to a taste profile of the target user according to a predetermined similarity metric as are subsequently retrieved ones of said nearest neighbor candidate taste profiles 

means to receive said representations of nearest neighbor candidate taste profiles and associated user identifiers on at least one neighbor finding user node 

said neighbor finding user nodes each having at least one similarity metric calculator calculating said predetermined similarity metric 

at least one selector residing on at least one of said neighbor finding user nodes using the output of said at least one similarity metric calculator for building a list representing the nearest neighbor users 

said list representing said nearest neighbor users providing access to associated ones of said candidate profiles 

a nearest neighbor based recommender which uses said associated ones of said candidate profiles to recommend items 

means to select at least one of said nearest neighbor users from said display of identifiers of a plurality of nearest neighbor users 

a display of information relating to at least one of the items in said nearest neighbor user s collection 

whereby massively distributed processing is harnessed in a bandwidth conserving way for finding the best neighbors out of the entire population of users and the same neighborhood is leveraged to provide recommendations as well as highly focused taste based community for sharing the enjoyment of items including recommended items

ASPECT 2 The networked computer system of ASPECT 1 further including means to facilitate communication with at least said nearest neighbor users where the type of communication comprises at least one selected from the group consisting of online chat email online discussion boards voice and video.

ASPECT 3 A networked computer system for supplying recommendations and taste based community to a target user comprising

an ordered plurality of nearest neighbor candidate taste profiles and associated user identifiers such that said nearest neighbor candidate taste profiles tend to be at least as similar to a taste profile of the target user according to a predetermined similarity metric as are subsequently positioned ones of said nearest neighbor candidate taste profiles 

networked means to receive said nearest neighbor candidate taste profiles and associated user identifiers on at least one neighbor finding user node 

said neighbor finding user nodes each having at least one similarity metric calculator calculating said predetermined similarity metric 

at least one selector residing on at least one of said neighbor finding user nodes using the output of said at least one similarity metric calculator for building a list representing the nearest neighbor users 

said list representing said nearest neighbor users providing access to associated ones of said candidate profiles 

a nearest neighbor based recommender which uses said associated ones of said a nearest neighbor based recommender which uses said associated ones of said candidate profiles to recommend items 

means to select at least one of said nearest neighbor users from said display of identifiers of a plurality of nearest neighbor users 

a display of information relating to at least one of the items in said nearest neighbor user s collection 

whereby massively distributed processing is harnessed in a bandwidth conserving way for finding the best neighbors out of the entire population of users and the same neighborhood is leveraged to provide recommendations as well as highly focused taste based community for sharing the enjoyment of items including recommended items

ASPECT 4 The networked computer system ASPECT 1 further including a single downloadable file that contains software that executes all necessary non server computer instructions.

REPRESENTATION In the above discussion of aspects representations may be the user profiles themselves including the taste profiles or just the taste profiles which should include an identifier of the user or they may be user ID s of the users or URL s enabling the data to be located on the network or any other data that allows taste profiles and associated user ID s to be accessed. These are all functionally equivalent from the standpoint of the invention.

TASTE PROFILE This term refers to data representing an individual s tastes or interests. It can take many forms. It may be the XML file generated by Apple s iTunes application which contains a list of music files in the user s collection as well as how many times he has played each one and other related information. This is a fairly complete profile having the disadvantage that it tends to consume a fairly large number of bytes that thus take significant bandwidth to download.

Other profile types include simple lists of song identifiers or album or artist identifiers or various combinations thereof. In non music domains other examples include book ISBN s or author names or combinations thereof or weblog URL s or weblog posting identifiers or combinations thereof of any of a multitude of other represenations of a user s tastes and or interests.

Just as different profile types may contain various different types of data there are many formats that can be used for representing such data to be processed by a computer. XML is one but such specifications as CORBA and many others provide ways that data objects can be represented and transported across a network and in general such formats as vectors or other binary or text based formats can be used.

A taste profile is data that represents a user s tastes and or interests. The format and contents are particular to particular embodiments and it must not be construed that the present invention is limited in scope to particular contents or formats as long as the data comprises a user s tastes and or interests or some useful summary thereof.

Further it should be noted that a user may have a plurality of taste profiles. For instance a user may have one type of music he likes to listen to while studying and another type he likes to listen to while dancing. Preferred embodiments of the invention allow the user to choose different taste profiles and correspondingly different nearest neighbors and recommendations according to mood.

Still further note that taste profiles may be either manually or passively generated. For instance the iTunes application captures user activity in the course of playing music and stores it to its associated XML file. The user does not have to make any separate effort to cause a taste profile to be generated based upon that data. On the other hand taste profiles can be manually generated by manually supplying ratings to items such as songs movies or artists. A playlist a list of songs a user likes to play together and which has usually been generated manually can be considered in some embodiments to be a taste profile. Some embodiments use taste profiles that incorporate a combination of passively and actively collected data. For instance a profile may include manually generated ratings of songs as well as the number of times each song has been played.

Finally note that taste profiles do not necessarily include data directly entered by the user they can instead be a computer derived representation. For instance in embodiments which associate information such as genre or tempo for songs software developers of ordinary skills will be able to see how to summarize data for songs the user has in has his collection to create a profile showing which genres or tempos the user likes most that information may then comprise the user s taste profile. Or in certain embodiments with numeric values for attributes the log of the values may be used.

TARGET USER The aspect discussion describes the invention in a way that focuses on serving a particular user who we call the target user. There are a plurality of users who could be considered to be target users but for descriptive purposes we focus on one such user.

USER PROFILE A user profile contains information related to the individual such as his name contact information and biographical text. It also contains his taste profile. An embodiment may make all some or none of this information publicly available.

SIMILARITY METRIC Degrees of similarity are computed according to a similarity metric which is not necessarily a metric in the formal sense of a metric space as that term is used in mathematical literature for instance http en.wikipedia.org wiki Metric space . A very great variety of similarity metrics are available. There is necessarily a correspondence between the nature of the similarity metric and the taste profile because similarity metrics often require particular types of data.

For instance if ratings data is present where numerical values are given such as on a scale from 1 to 7 where 1 is poor and 7 is excellent such simple methods can be used as computing average difference between the ratings of the items which have ratings in both taste profiles. Other techniques include computing a Euclidean distance Mahalanobis distance cosine similarity or Pearson s r correlation using that data 13 15 . Another approach is given in 16 beginning column 20 line 59. Any other computation that results in a metric that tends to be indicative of similarities of taste between the two users can be used.

In many embodiments data is massaged to make it more appropriate use with certain popular similarity metrics. For instance in a music application when song play counts are included in the taste profile the songs may be ranked in order of frequency of play songs in the top seventh have an implied rating of 7 songs in the next seventh have an implied rating of 6 etc. This data can then be used with similarity metrics such as those mentioned above.

Note that some similarity metrics such as Pearson s r enable the computation of levels of probabilistic certainty or p values with respect to a null hypothesis. In many cases such as r it is possible to state a null hypothesis that roughly corresponds to the concept the two users have no particular tendency to agree. This enables the system to take into account the fact that some pairs of users have more data to base the metric on then others and thus more reason to have confidence. This is a significant advantage over many of the simpler techniques. However this approach nevertheless has a drawback. As an example consider two users with a very large number of items in common which they have each rated where a p value derived from r is used as the metric. Suppose further that on average there is a slight tendency to agree rather than disagree. Then simply due to the large number of items with ratings in common the p value may be extremely indicative of rejection of the null hypothesis even though on average there isn t a very unusual amount of agreement between ratings. In practical use with a large number of users where not too many nearest neighbors need to be found this effect is normally not a major problem because there will also be users who do have a lot of agreement and who also have a high number of rated items in common and such pairings will result in even greater extremities of p values. In such cases there can be a lot of confidence that the similarity metric is finding users who are actually very similar in taste even though their may be other pairings with even more similarity that are left behind due to not having as much data for comparison.

The immediately preceding paragraphs focus on situations where degrees of agreement can be discerned for each item. Another type of profile involves presence absence data where all that is known about each item is whether a user is associated with it or not for instance whether a user has a particular song in his collection or not. In such cases such calculations as the well known Jaccard s Index Sorensen s Quotient of Similarity or Mountford s Index of Similarity can be useful.

Some embodiments combine different similarity metrics. For instance r can be used to compute a degree of similarity in ratings of items that are in common between two users and Jaccard s Index to compute the degree of similarity implied by the numbers of items that are and are not in common between the users. An average or geometric mean weighted or not may be used to combine the metrics into one that incorporates both kinds of information other techniques such as p value combining with respect to a null hopothesis 16 can be sued as well by converting the metrics into p values.

Source code described in the file tasteprofileclass.py in Appendix 4 and included in the computer program listingappendix submitted on CD pursuant to 37 C.F.R. 1.96 takes a different approach for computing similarity based on iTunes XML Consider a shared song to be a song that is in the collection of both users. This method calculates an approximate probability that the next shared song to come into existence will be the next song played. That is if user A takes a recommendation from B s collection it will be a song that A doesn t have yet. When he has it it will be another shared song. What is the probability that it will be the next song played once it is in A s collection This is a particularly appropriate similarity measure because it measures similarity of tastes in a way that directly relates to a key purpose of finding nearest neighbors making recommendations that the user will want to play frequently. Details of the algorithm appear in the source code. That algorithm is the currently preferred similarity metric.

The only requirement of the similarity metric is that for a significant portion of pairs users which includes those who tend to be the most similar in taste the following applies if the calculated similarity of two taste profiles A and B is greater than the calculated similarity of two taste profiles A and C then it is likelier than not that users A and B are actually more similar in relevant tastes than are users A and C. This likelihood will be greater for similarity metrics that will be associated with the highest performing embodiments of the invention. For instance simply using the average distance between ratings may be acceptable for some applications but using Euclidean distance is better than a simple average.

There are many ways to calculate similarity. Other than the requirement above the invention has no dependence on the particular similarity metric that may be chosen by a particular embodiment. The invention must not be construed to be limited to a particular similarity metric or type of similarity metric the ones listed here are for reasons of example only. Similarity metrics are interchangeable for purposes of the invention.

MEANS FOR FACILITATING RETRIEVAL OF REPRESENTATIONS There are a variety of ways to provide the functionality needed. It must be stressed that all provide identical or equivalent functionality for the purposes of the invention. While there are several basic structures available there are many variants for each that are only insubstantially different and should not be construed as different in a way that would make them fall outside the scope of the invention.

What is needed is a means for facilitating retrieval of representations of nearest neighbor candidate taste profiles and associated user identifiers in an order such that said nearest neighbor candidate taste profiles tend to be at least as similar to a taste profile of the target user according to a predetermined similarity metric as are subsequently retrieved ones of said nearest neighbor candidate taste profiles.

The representations mentioned in the previous paragraph may be the user profiles themselves including the taste profiles or just the taste profiles which should include an identifier of the user or they may be user ID s of the users or URL s enabling the data to be located on the network or any other data that allows taste profiles and associated user ID s to be accessed. These are all functionally equivalent from the standpoint of the invention.

It is important to note that the means for facilitating this retrieval does not need to make use of the predetermined similarity metric or a calculator that can calculate it. In particular it isn t required that the retrieval of representations is exactly in the same order that would be given by the similarity metric.

One implication of this is that even if the similarity metric is not a metric in the sense of a metric space a metric space based metric can be used in the means for facilitating this retrieval. This makes available a large number of algorithms in the literature for facilitating the retrieval.

In preferred embodiments the data used in facilitating this retrieval is a subset of the data used in the similarity metric or a summary derived from that data or a combination of the two in order to lower computational costs.

Data structures may be created that provide the foundation for retrieval in the necessary order or sequence. For instance clustering may be done using a variety of methods. See for example 1 and 2 which apply to metric spaces that is a structure involving a distance function where the function used to compute the distance between any two objects satisfies the positivity symmetry and triangle inequality postulates. Such a distance function can be a similarity metric examples include Euclidean distance.

See also 3 which works on large binary data sets where data points have high dimensionality and most of their coordinates are zero. For instance this can be used to cluster based upon attributes consisting of indicators of whether or not a user has a particular song in his collection. See also 4 .

Appendix 4 describes source code genrerankhandler.py which appears on the computer program listing appendix and which contains an algorithm which uses genre data genrerankhandler.py but a practitioner of ordinary skill in the art will see how to modify it for use with other kinds of data which is of limited dimensionality.

For a given clustering scheme practitioners of ordinary skill in the art will know how to compare a particular taste profile to a particular cluster of taste profiles and thus determine an affinity between each cluster and the taste profile.

Then the cluster with the most computed affinity to the given taste profile is first in the retrieval order the cluster with the next most computed affinity is the returned next etc. Of course there can be some degree of difference from this strict order without violating the spirit of the invention or moving outside its scope. When we discuss retrieving a cluster we mean either a set of representations of nearest neighbor candidate user profiles or a representation of such representations. For instance such a representation can be the name or Internet address of a file containing the representations of candidates.

Clusters are not the only kind of structure that can be used. See for example 6 and 4 . Practitioners of ordinary skill will see how to use such structures for retrieving in an order consistent with the needs of the invention. Many such structures with different details of implementation but these details are not substantial differences for the purposes of the invention. It is not possible to list all possible combinations of such details and it must not be construed that one can move outside of the scope of the invention merely by finding such variations on the structures listed here which it cannot be stressed enough are listed for reasons of example only.

The source code in Appendix A provides the exemplary key aspects of one particular method for causing the representations to be retrieved an order consistent with the needs of the invention. See the explanatory text in the section for clusterfitterclass.py.

Of course preferred embodiments update or replace these structures over time as taste profiles associated with users change and users are added to or removed from the database associated with the embodiment.

Note further that the data structure may be built and stored on a central server on machines owned by end users of the invention which communicate their results directly to a server and or to other end user machines via peer to peer means or on a combination. It must not be construed that a system falls outside of the scope of the invention merely because the necessary computational and storage resources for the foundation for retrieval are provided at one location or set of locations rather than another or one type of network node rather than another.

As one example of a combined approach consider 7 . That paper provides an algorithm to do clustering based on nearest neighbors. It can be leveraged to produce a combined approach as follows.

Use a peer to peer system such as the Gnutella protocol or any other protocol that enables one to search for a file. Each end user machine is a node in such a network also known as a cloud. 

Each end user machine then conducts a search for each file or a substantial subset of files that are already in that machine s collection using the words in the name of each fie or a substantial subset of them . A hit occurs when the protocol returns an identifier of a node that has a file with matching words in its name.

For purposes of the algorithm in 7 nearest neighbors will have a different definition than the one involving the predetermined similarity metric of the present invention. It involves a couple of components.

The first component is hit nearness. Suppose a query returns only 1 hit. That means that the node identified by that hit is considered to be in the first tier of hit nearness. If it returns 2 hits each of the nodes are considered to be in the second tier of hit nearness. And so on. The tiers are ranked and the ranks are divided by the number of tiers. If T is the number of tiers the best hit nearness is 1 T the next best is 2 T and the worst is T T 1 .

The next component is quantity nearness . We count the number of times a particular node s identifier is retrieved in the process of seaching for files. We create tiers based on those numbers using the same tiered approach as for hit nearness and again resulting in a number between 0 and 1 where the worst node the node with the smallest number of hits has a quantity nearness Q of 1.

Then the distance of a node to the node doing the search is the square root of T Q. So the ordering of each node s the neighbors for the algorithm in 7 is laid out that way.

The work of finding neighbors for 7 is thus carried out on the end user machines. Then that nearest neighbor information is uploaded to the server from each node and the algorithm in 7 is carried out there.

For instance the algorithm could include Gnutella protocol code and use the procedure described above to cluster similar taste profiles together where similarity is determined by having more neighbors in common rather than by our predetermined similarity metric .

Then to determine the order in which clusters should be downloaded to a particular user s node the one that contains the greatest number of his neighbors should be downloaded first then the one that has the next greatest number of his neighbors etc.

Instead of or in combination with pre existing data structures such as described above many embodiments use dynamic searches.

Probably the simplest example of this is a server based system with a table of attributes culled from the taste profiles one row per user. In one embodiment these attributes are bits representing the presence or absence of particular genres. So if there are 100 defined genres each row has 100 bits.

Then to determine the order in which taste profiles should be downloaded the server simply checks each row and counts the proportion of matching genres to total genres in the other user s taste profile. The representations of taste profiles with the highest proportions are retrieved first. The table could be a RAM based bitmap a database such as based upon SQL or any other convenient configuration. Of course they data used wouldn t have to be genres. It could be a selection of artists or songs or albums or in non music domains book titles web logs paintings news articles school subjects course numbers etc.

In another set of embodiments there is virtually no server based processing at all the only server processing is to supply network addresses for a set of seed nodes that may be online at the time which may in fact be included with the download of the software that executes the computer steps involved in the invention.

In these embodiments a peer to peer protocol such as Gnutella s is used to conduct searches for files as described above in this text. Note that if a pre existing popular protocol such as Gnutella s is used it should be modified so that a node can respond to a request for a complete taste profile if that does not include a list of all or a substantial subset of items on the node s machine then nodes should also be able to respond to a request for such items.

As described elsewhere in this specification a node we will refer to it as the target node initiates searches for files it has in its collection. Nodes that are the subject of hits are candidate nearest neighbors. Nodes that have more files matching the target nodes files than others are statistically more likely to be hit before nodes with a smaller number of files. The representation that comes along with the hit is then used the taste profile and if necessary the list of files. So that satisfies the requirement of the means for facilitating retrieval in the desired order. No other server activity is required.

Note that to increase the performance over protocols such as Gnutella that are popular at the current time currently preferred embodiments use the peer to peer method described in 12 . Also at the time that user machines connect for a new session in the peer to peer network they should connect to randomly chosen seed nodes in order to increase the randomness of results obtained from searches.

It must not be construed that the scope of the present invention is limited to the particular techniques listed here.

Whether the means for facilitating retrieval is based upon a pre existing data structure or whether dynamic computations are done there is still the question of actually delivering the representations of nearest neighbor candidate profiles and if separate the profiles themselves.

In some embodiments these come directly from the server. In others such as peer to peer techniques like those described above they may be the result of direct communication with the machine owned by the user whose profile is required.

In some embodiments caching solutions such as BitTorrent 8 FreeNet 9 FreeCache 10 and Coral 11 are used to distribute the represenations and or the profiles. It is preferred to use BitTorrent to distribute cluster files where the clusters contain the profiles.

It must not be construed that the scope of the invention is limited to the specific examples which are listed here for explanatory purposes. The requirement is that profile representation are retrieved s in an order such that the nearest neighbor candidate taste profiles tend to be at least as similar to a taste profile of the target user according to a predetermined similarity metric as are subsequently retrieved ones of said nearest neighbor candidate taste profiles. The intent is not to carry out the impossible task of listing every possible way to achieve that. The intent is to teach a number of ways to achieve that end other techniques that achieve that end are equivalent for our purposes. That is such techniques are interchangeable in the sense that they will result in an embodiment of the invention that falls within the scope.

NEAREST NEIGHBOR A target user profile s nearest neighbors are the other user profiles whose taste profiles are closest to the target user profiles according to the predetermined similarity metric. However in preferred embodiments there are exceptions users can cause entries to be added to the nearest neighbor list that may not be ones that have the most computed similarity and they may delete entries from the list and they may cause an entry to become permanent though manually deleteable . They can do these actions manually or through automatic means such as a program that runs through ones email address book and makes the user profiles associated with email address found there permanenty. Such features may detract from recommendation accuracy while adding to the user s pleasure in the nearest neighbor community.

NEAREST NEIGHBOR BASED RECOMMENDER Nearest neighbor based recommendation algorithms are well known in the literature. See for example 13 and 14 . The source code file recommenderclass.py described Appendix 4 and included the computer program listing appendix also includes a technique.

The scope of the present invention should not be construed as limited to any particular nearest neighbor based recommendation algorithm. They are fundamentally interchangeable for the intents and purposes of the invention although some will have better accuracy than others. The currently preferred technique is given in recommenderclass.py.

SERVER The term server as used in this specification means one or more networked computers incorporating a central processing unit and temporary storage such a RAM and also persistent storage such as hard disks. They perform central functions such as storing a central list of users. While there may be more than one server they usually do not have to be separately accessed by user associated computers rather they present a unified interface. One such example of multiple servers working together is the case of a server computer running software that interacts with client software running on user associated computers which uses other computers for database storage and to provide database redundancy.

USER NODE The computer also referred to as the machine associated with a human user of the computer providing one or more input devices such as a keyboard and one or more output devices such as LCD screen. It is networked preferably through the Internet to other user nodes. A common protocol such as TCP IP is used for communication with other user nodes.

NEIGHBOR FINDING USER NODE In currently preferred embodiments all nodes are essentially the same and play the role of neighbor finding user nodes but in some embodiments certain tasks are relegated to certain of the user nodes. For instance it may be that certain users are willing to make their computational and bandwidth resources available to others and that others are less willing for instance those who are willing may get a price break.

In such embodiments neighbor finding user nodes take it upon themselves to do work for multiple users. For purposes of neighbor finding they work either independently of the user nodes they are helping or in concert with them. For instance they may receive the candidate nearest neighbors for other users and use their taste profiles to compute the similarity according to the similarity metric and then pass on only the most similar nearest neighbors to the user nodes across the network.

IDENTIFIERS FOR DISPLAY Identifiers of items and nearest neighbors are displayed in such visual constructs on a visual computer display as tables in a window or menus such as pop up menus. Some embodiments may use audio means as a kind of display when visual display is not possible. The identifiers may be identifiers used internally to keep track of the items and users or they may be special public identifiers supplied by the users or item producers or any other identifier that is thought would be convenient for the users.

While this specification focuses on the example of music recommendation and communities that is for purposes of example and ease of explanation only. It applies just as completely to other domains such as books web logs web sites movies news educational items discussion groups and others. Embodiments in all of these domains and other domains which could benefit from taste based recommendations and communities. Occasionally in this specification the word item is used inclusively to represent the various types of objects of taste or interest.

The word taste as used in this specification should not be construed to imply that the invention s scope is limited to artistic works. It applies equally well to information such as news sources. The word interest should be considered a synonym for taste for purposes of this specification.

Other information besides the taste profiles may be used in finding nearest neighbors. As one example some embodiments allow the list of nearest neighbors to be restricted to individuals who live in particular physical localities.

This disclosure contains several additional sections each designated as an Appendix and together with the rest of the text and computer code presented herein forming a unified disclosure of the present invention. As one alternative way of achieving the desired ordering of profiles see the distributed profile climbing technique described in Appendix 3.

The profiles are received at the user nodes . The similarity of each one to the local user is calculated . The ones that are similar enough to the current user for instance by being more similar than the least similar current member of the nearest neighbor list are put into the appropriate position in the nearest neighbor list. In preferred embodiments that position is consistent with an ordering by similarity.

In the nearest neighbor list is put to use. Combined with the local user profile recommendations are generated for the user see for example recommenderclass.py described in Appendix 4 and included on the computer program listing appendix for an example of how to accomplish that .

Interactive communications are also enabled . For instance preferred embodiments display the user identifiers of nearest neighbors in a list on a computer display. An interaction means such as clicking on a particular icon enables an email to be automatically generated addressed to the neighbor and indicating that the sender is the current user the user then fills in the message text and sends it.

BIBLIOGRAPHY References Listed Below in this Section are Hereby Incorporated by Reference in their Entireties to the Fullest Extent Allowed by Law

This appendix describes another description of key functionality of the invention including but not limited to facilitating retrieval of representations of nearest neighbor candidate taste profiles and associated user identifiers in an order such that said nearest neighbor candidate taste profiles tend to be at least as similar to a taste profile of the target user according to a predetermined similarity metric as are subsequently retrieved ones of said nearest neighbor candidate taste profiles.

The specification describes a product named Goombah. However the focus on Goombah is for clarity and descriptive purposes only and it must not be construed that the scope of the invention is limited to that particular embodiment or to the field that Goombah operates on music .

Goombah s first purpose is to build a list of nearest neighbors for each user. They then form a community of like minded people for communication purposes and they also form a source for recommendations of items if you have extremely similar tastes to me and you have an album I don t have and you play it all the time I should probably give it a try. So that s the basis of the recommendations. To find nearest neighbors exactly correctly is an O N 2 problem if simple technology is used and we hope to have hundreds of thousands or millions of users whose profiles are constantly being updated so we wanted to do better than O N 2 .

There are probabilistic nearest neighbor algorithms that reduce this complexity hugely but at a loss in reliability in finding the true nearest neighbors. We wanted to do better.

The key idea behind Goombah whose purpose is to solve the above problem is that the computations for finding the local user s nearest neighbors are carried out on that user s machine. So if we have a million users we have a million CPU s doing the work of finding nearest neighbors.

There are three reasons why such an approach is within now the realm of feasibility where it wasn t a few years ago 

So essentially the idea when a local user wants to find his nearest neighbors is to download the profiles of all other users who could reasonably be considered to be candidates to be nearest neighbors of that local user. Then the local user s Goombah application does a search of all those profiles to find the best matches.

Instead of downloading individual profiles Goombah will download a single very large file 10 s or even 100 s of megs that contain the candidate profiles. This will happen by means of BitTorrent.

We will find clusters of similar users which are large enough to contain most reasonable nearest neighbor candidates for each general type of musical taste. They will be large enough to fill that need and small enough to download in a reasonable time on a high speed connection and not take a problematic amount of space on the user s hard drive.

So the local user will download a large BitTorrent file containing all nearest neighbor candidates and do an exhaustive search on his machine for nearest neighbors.

The clustering algorithm can be any clustering algorithm that is capable of clustering a large number of users according to their degree of interest in a large number of subject items. Where the degree of interest may be indicated by real valued binary integer or any other that can represent a degree of interest. 

As one example the commonly used C4.5 algorithm can do this. For example the open source Java software WEKA has a module weka.classifiers.trees.j48 which implements C4.5. In the context of using this module in a music setting each user is an Instance and the song identifiers such as strings containing the artist name album name if any and song title are used as the values of a nominal attribute representing the songs.

The step of using the local CPU to find nearest neighbors can be conducted in various ways. Any sub algorithm which accomplishes the function find nearest neighbors out of the downloaded large file is considered equivalent for the purposes of the present invention. Possible ways to do it include an exhaustive search for the other users that are most similar to the local user according to some similarity metric. The attached Python scripts recommenderclass.py and tasteprofileclass.py contain code for generating a similarity metric. However it must be stressed that there are innumerable ways of generating a similarity metric for nearest neighbor purposes and they are all functionally equivalent from the standpoint of the present invention and all fall within the scope of the present invention. We can use any metric that results in reasonable likelihood that two users that are considered more similar than another pair of users actually have more shared interests in the targeted interest domain such as music than another pair of users with lesser similarity. Note further that we aren t using the word metric in its most rigorous sense but in its general sense as a quantity used for measurement and comparisons. 

Another way to find the nearest neighbors from the downloaded large file is to use the vp tree technique introduced by Peter N. Yianilos in his paper Data Structures and Algorithms for Nearest Neighbor Search in General Metric Spaces . The large file to be downloaded would be formatted as a vp tree and thus very fast nearest neighbor searches would be facilitated on the local machine. Again any technique used to find the nearest neighbors is functionally equivalent from the standpoint of the invention and falls within the scope of the invention.

The step of using peer to peer techniques for downloading the large files can also occur in various ways which are functionally equivalent from the point of view if the current invention. In fact the invention does not depend on any particular technique for getting files from peers and all such techniques should therefore be considered functionally equivalent from the point of view of the invention. For instance while BitTorrent provides a particularly compelling model for how this may be accomplished the Gnutella provides an alternative model.

A difference between the BitTorrent and Gnutella approaches is that with BitTorrent each file has a distinct URL which is understandable by a server machine which runs BitTorrent tracker software. By means of this URL client software is told by the tracker which peers store the file or parts of the file so that the client can cause downloads to be started from a subset or all of those peers. With the Gnutella approach there is no central server and the local computer sends queries into the cloud of known peers and machines known to those peers looking for files with particular filenames. Then normally one of those peers is chosen to be the source of the download.

The commonality between all these various techniques is that the large files each represent a group of similar profiles or alternatively all available profiles there are a fixed set of such files at any point in time and the user causes one or more to be downloaded that is are particularly likely to contain worthy nearest neighbor candidates these files are usually downloaded from one or more peers rather than from a central server. All techniques which satisfy these requirements are functionally equivalent from the perspective of the present invention and thus fall within the scope.

One key step is determining which large file a particular client should download in order to meet the needs of its user. Of course in embodiments where all the profiles are in one large cluster there is no issue. When they are divided into clusters and each cluster is represented by a particular large file however this step needs to be carried out.

When a system is first set up to embody this invention it will usually only have a relatively small number of users on Day 1. Thus there is no need to divide the population into separate clusters for downloading. As the user population grows in size a single file is used for download purposes.

Finally a point may arrive at which it is deemed due to the relative of expense of bandwidth and diskspace that the user population should be divided into two clusters. At that time a clustering algorithm is run and the user population is divided into two clusters. Each of the two clusters is given a name for instance U0 and U1 .

Now as time goes on we do not regenerate those clusters from scratch. Rather as new users are added to the system they are added to the most appropriate cluster. This may be done in any number of ways. A centroid for the cluster may be calculated and the new user added to the cluster whose centroid it is most similar to. Or the average similarity between the user and each cluster member may be calculated for each candidate cluster and the most appropriate cluster chosen on that basis. Or the change in entropy that would arise in the system as a whole due to each possible choice of cluster can be calculated and the choice taken that minimizes the change in entropy. Any of these techniques and all other techniques that cause the user to be placed in one of the existing clusters are functionally equivalent from the point of view of this patent as long as they have put the user in a cluster that is highly likely to result in a good degree of similarity between the new user and other members of the cluster.

In this way clusters have consistent meaning over time and the user can stay in the same cluster until a further split is deemed necessary. In preferred embodiments this is handled by the expected large file simply not existing at a particular point in time and this is detected by the client which thus assumes it needs a new cluster assignment. It then queries the server system for a new assignment. For a pre existing user this is easily determined because the new assignment was made during the split process so the server returns another cluster identifier consistent with that split. For example if a user was in cluster U0 he may now be in cluster U01 where the leading 0 represents the lineage . Of course any cluster naming convention can be used but preferred ones encode the lineage in the name .

Other embodiments which use a fast enough clustering approach regenerate the clusters from scratch on a regular basis. In such embodiments the client either requests a new identifier for the cluster file or one is sent automatically by the server when the client and server are in communication. Note that this communication can actually take a number of forms. Rather than sending text strings numeric or other identifiers can be sent which are in turn used by the client to build the necessary handle to access the file. Two examples In a Gnutella style system this handle would probably be a search term. In a BitTorrent style system the handle might be the URL for the torrent. 

Still other embodiments have relatively stable clusters but continuously work to refine them by moving users from one cluster to another if such a movement provides superior clustering. For instance periodically each user may be considered again as if it were a new user and a decision made about what cluster it should go into. If it changes then that will be reflected in future communications between the client and the server although the change does not need to be reflected immediately .

In some embodiments the client has no persistent knowledge about what cluster the user is in and when it s time to get a new cluster queries the server for the information required to start a download of the appropriate one.

In some embodiments users may be assigned to more than one cluster. As one example of how that might be done a number of standard clustering approaches such as C4.5 assign probabilities for cluster assignments thus a user might with a higher probability reside in one cluster than another. It would be possible to take the two clusters with the highest probability for a given user and say that he resides in both of them. The invention is not limited to any particular approach to putting users in more than 1 cluster. The functionality is simply that the user would go in the clusters that provide a high match to his interests and any technique that accomplishes that is functionally equivalent from the perspective of the present invention and is therefore within the scope.

In some embodiments different clustering arrangements exist for different genres. For example a user who has both classical music and jazz in his collection might benefit from different nearest neighbor communities generating different recommendations in each area. So the entire clustering and downloading structure and steps in some embodiments are carried out more than once. In other preferred embodiments each user still is in only one or a small group of cluster s but his client software finds different nearest neighbor sets depending on genre from within those clusters. Of course in non music applications this concept is extended by means of the analogous principle to genre that exists in that other subject area. For instance if the items are weblogs then an individual might be interested in weblogs about Perl scripting and also weblots about Republican politics. These different subject areas are handled analogously to genres in the music world.

In order for the system to respond to the needs of users who are continually buying new music viewing new weblogs etc in preferred embodiments it is possible for neighborhoods to be updated according accordingly. This means that the large files representing clusters need to be either re downloaded or updated periodically. We will discuss below some of the ways this is accomplished in various embodiments. The scope should not be construed to be limited to these particular techniques. Rather any technique that enables the potential neighbor files to be updated or replaced often enough to increase the accuracy and pleasure in using the system equally fulfils the required function and is thus considered to be in the scope.

In some embodiments download file identifiers which may be URL s terms etc. are constructed based on two pieces of data the cluster identifier plus the date. For instance a user might be in cluster U011. If the date is Jan. 27 2004 the download file identifier might be U01120040127. The client can then get an update by for instance downloading the file containing that string in its name or by constructing a BitTorrent URL based on that string.

The client machine can then download the file upon whatever schedule is most consistent with the user s needs and desires. Bandwidth will be a constraint so there is reason not to download the files too frequently. In preferred embodiments there is a choice in the preferences section of the program whereby the user can specify how often he wants to update the file. He will probably do so less frequently if he has a dialup modem connection than if he has a cable modem. Some embodiments use information available in the computer for instance provided by the operating system to determine the connection speed and automatically choose a download schedule accordingly. Some ask the user to specify the download speed and automatically choose a download schedule accordingly. Other ways of determining a download schedule including the user s manually starting each download are all functionally equivalent and within the scope.

Some embodiments automatically cause files of different sizes to be downloaded according to connection speed or at the choice of the user . One way this is done is for the server to store a tree of cluster arrangements. For instance suppose clusters are arrived at by splitting bigger clusters in half and the lineage of the cluster is represented in the file name. Then for example U0 might be the parent of U01 and U01 might be the parent of U011. Then a client with less bandwidth available to it might retrieve cluster U011 and one with a great amount of bandwidth but with a user with a very similar taste profile to the first client might retrieve cluster U0. The difference is that the larger the downloaded cluster the more likely it is that the true most similar neighbors out of the whole universe of neighbors will be found by the client.

In some preferred embodiments it is possible to either download a cluster as a whole or download updates. For instance using the naming convention we have used above U01120040127 20040126 might be the identifier of the file that contains the difference data between an up to date representation of cluster U011 as it appeared on Jan. 26 2004 and the version that was current on Jan. 27 2004. Then a preferred embodiment will automatically choose whatever method will result in getting current more quickly. For instance if no update has occurred in a number of days it may be more efficient to download the complete file. But if the last update was recent it may be more efficient to download a series of daily updates.

In a preferred embodiment making use of BitTorrent the server stores for each cluster files representing the current complete cluster individual updates for the last 6 days and the last 4 weekly update files files that update for a whole week . BitTorrent requests for any of these files cause them to be loaded to client machines where they are henceforth made available in a peer to peer manner. Any such manner of scheduling updates is functionally equivalent.

Those skilled in the art will know how to create such update files. There are general patching software technologies but more particularly it is easy to create custom approaches. For instance if the cluster file contains a list of user ID s with each user ID followed by a list of the songs found on his or her computer an update file may consist of a list of user ID s of users who downloaded new songs in the corresponding time interval with each user ID followed by a list of the new songs and a list of songs that used to be on the user s disk and no longer are. All such representations are functionally equivalent and fall within the scope of the invention.

Another aspect is the fact that changes on the user s machine need to be uploaded to the server. In some embodiments this is done on a regular schedule when there are changes to upload. Preferred embodiments only send changes since the last upload rather than uploading the entire interest profile. Preferred embodiments don t send changes until sufficient changes have accrued that it is worthwhile to do an update. For instance in embodiments where taste profiles include information about the number of times a song has been played it makes a big difference when that count goes from 0 to 10 but very little difference when it goes from 1000 to 1001. A simple way to determine significance is to have a cutoff for the percentages involved. For instance if play counts are used the if overall they have changed by 1 that might be considered significant. If simple presence absence data is used than a 1 difference in that data might be considered significant. Alternatively the entropy of the data may be used. For instance entropy can be calculated based on the exercise of choosing a play at random and computing the probability that such a randomly chosen play instance would arrive at a particular song. So there is one probability for each song. Based on those probabilities the song entropy may be calculated. Then significance may be determined by a particular amount of change in entropy occurring either on a percentage basis or based on a fixed minimum change in value. Any technique that determines that a desirable amount of change has occurred is considered functionally equivalent from the standpoint of the invention and thus falls within the scope.

In some embodiments the user can determine how much significance is required before an update occurs in others it is automatically determined based on bandwidth in others it is determined on a global basis by the server in others some combination is used such as a maximum upload frequency being determined by the server with the user having the ability to set the frequency or significance required as long as it is below the global value any number of other techniques are possible and considered functionally equivalent within the scope of the invention.

Note Music is discussed in this specification for reasons of example only. The invention applies to other areas just as well including text documents videos weblogs and indeed any type of item where user interest can be determined by means of his association and or degree of association with a number items of potential interest. Software developers will readily see how to create these alternative embodiments. It must not be construed that the invention is limited to the specific examples described in this specification.

The overall invention in broadest form consists of a server or networked group of servers that stores the cluster files containing interest profiles and distributes them to client machines and client machines that then distribute those files to other client machines the nearest neighbors are then chosen on client machines and used for purposes of recommendation and community.

Clusters should be large enough to include most users whose profiles are reasonably likely to be global nearest neighbors for any given local user.

It would be worth while to discuss one further sample application of the technology. That is one where users are purchasers of DVD s for viewing videos. The interest profile would consist of the list of DVD s owned by the user perhaps with additional entries that are liked or particularly disliked by the user optionally associated with the ratings. Numerous technologies are available for finding nearest neighbors based on such data such as those used by Firefly or the movie recommendation patents of John Hey or the present inventor s U.S. Pat. No. 0 588 4282. All such algorithms are functionally equivalent from the standpoint of the present invention. This profile data is usually manually entered by the user.

In addition to forming communities and recommendations as already described this embodiment adds functionality for making it visible to other users that one has DVD s one is willing to lend out and for keeping track of DVD s that have been lent. Additionally preferred embodiments have functionality for rating lenders of DVD s according to their reliability much as is done on eBay or various action sites with respect to sellers . Skilled practicioners of the art of Web programming will immediately see how to create appropriate user interfaces.

In some embodiments this lending data is stored on the server for easy access by various clients and in others it is made available by peer to peer means.

The idea is that when the system finds people who have similar tastes they will be able to help each other by lending DVD s to each other. Because they have similar tastes they will be able to lend multiple DVD s. They may also email each other or chat with each other about DVD s of interest through addresses made available through the interface or through automatic means. These factors lead to a relationship of trust which minimizes the risk in sharing DVD s. So such a service has the potential to do what netflix does but since there is no central repository of DVD s at much lower cost.

Of course other physical objects of interest than DVD s are the subject of other embodiments CD s is one applicable subject area.

This appendix describes another way of implementing key functionality of the invention including but not limited to facilitating retrieval of representations of nearest neighbor candidate taste profiles and associated user identifiers in an order such that said nearest neighbor candidate taste profiles tend to be at least as similar to a taste profile of the target user according to a predetermined similarity metric as are subsequently retrieved ones of said nearest neighbor candidate taste profiles.

The representations mentioned in the previous paragraph may be the user profiles themselves including the taste profiles or just the taste profiles which should include an identifier of the user or they may be user ID s of the users or URL s enabling the data to be located on the network or any other data that allows taste profiles and associated user ID s to be accessed. These are all functionally equivalent from the standpoint of the invention.

The present invention is a new approach to dynamically creating online groups of similarly minded people for both community building and generating recommendations of items of interest to the communities.

The invention is a form of distributed computing for searching which we will refer to as distributed profile climbing or DPC . In preferred embodiments it is a kind of middle ground between a server based Internet service and a peer to peer one.

The invention consists of a networked computer system running special software. The network is typically the Internet but can be any network which interconnects computers and the computer can be a broad range of computer hardware that a user might own a typical personal computer running with 256 megabytes of RAM a Pentium processor being one example. The connection to the network may be a direct connection or may be wireless based on radio light Ethernet cabling etc.

Peer to peer networks are a popular way to handle such challenges as sharing files between many users. The main problem is that not everyone who wants to participate in such a network can do so fully. This is for a number of reasons computers may not be on all the time or they may be portable or they may have firewall and or network address translation issues.

Pseudo peer to peer networks handle that problem by creating proxies for the machines of each user who wants to participate. These proxies exist on server systems but typically the technical requirements for those servers are light because the proxies merely store and transmit data related to the machine they are proxying.

An example of this is Radio UserLand s upstreaming . Radio UserLand is a software package that runs on end user computers and lets users create weblog entries. Those entries may then be sent upstreamed to UserLand s servers. Web users who wish to view a Radio UserLand customer s weblog can then look at the proxy data on UserLand s servers. Note that in a world where everyone had computers always able to allow access to other users there would be no need for this upstreaming to take place. Each weblog writer s machine could serve their weblogs to the rest of the world. But we are not in such a world so the practical solution is to send the weblog data somewhere where can be always available to other people in the form of a data object which is located at a particular URL on a reliable server. This data object is the proxy for the user s machine.

DPC networks share a common foundation with pseudo peer to peer networks like UserLand Radio in the sense that each user s data is represented by a proxy data object located on a remote server. However in DPC networks this data contains a profile of the user in order to compare similarity of interests. In preferred embodiments the proxy object for a user further contains key information for other users who have already been found to be similar in interests to that user. This key information is sufficient to enable the proxies of those other users to be accessed typically this would be by means of constructing a URL that accesses the proxies .

One very important aspect of searching for similar profiles is intelligently handling users that have already been compared at least once. In some cases it may be desired to never compare them again in others it may be desired to compare them again after a certain amount of time or a certain number of updates have occurred. Most approaches for taking care of this involve storing representations of which pairs of profiles have already been compared.

For instance some solutions store a table with a concatenated key containing the logon ID s of the two users that have been compared. But this is a problem. If we assume that over time every user will be compared to every other ignoring the expense of those comparisons for now and there are 10 000 000 users in the database the result is a table with 100 000 000 000 000 records. That is not within the realm of reasonable possibility for affordable server installations.

However now assume there are 10 000 000 users each with their own machine and each machine stores the logon ID s approximately the approximately 10 000 000 users it may have been compared to over time. This is entirely within reason given the most computers being sold today are equipped with 10 s of gigabytes of storage. This is the way DPC handles the problem in embodiments which involve such lists. Preferred such embodiments contain the calculated similarity metric for each comparison as well as the date and time of the comparison and other pertinent information may be included as well.

Moreover for embodiments that handle previously checked lists there is no need for the kind of very sophisticated highly scalable database software that would be required to store that data on a central server.

Furthermore in most DPC systems the similarity metrics are computed on the user s machines rather than on the server. This is not a requirement but it does help to distribute the workload and simplify the scalability issues for the server.

As a matter of practical implementation preferred embodiments where there are large numbers of users divide the proxies for various users among separate servers residing in one or more physical hosting sites. Usually the proxies are divided up in such a way that a hash function based on the user s ID can be used to determine which server or subgroup of servers hosts that user s proxy. The benefit of dividing the server side up this way is one of simplicity and cost there is no need for a high performance central database system. Instead the servers can operate in relative isolation to each other even storing all data in local RAM for speed using communicating with other server hardware for control and backup purposes.

An algorithm for one embodiment of the invention is shown below. Steps are carried out in the order shown. Deeper indentation is used in the representation of repeated groups of operations or operations that are dependent on the result of an if test.

An else relates to the previous if at the same indentation level. A break causes the process to immediately terminate the currently innermost loop while allowing outer loops to continue undisturbed. The operations depicted carried by the software operating on end user machines except that the server is invoked to provide data on occasion.

First we will introduce some terms. THISUSER is the user whose machine the algorithm is running on. Each user has an associated NEIGHBORBAG which is his current list of ID s of similar users. In this example embodiment the NEIGHBORBAG has a fixed maximum size. PREVIOUSLYCHECKEDBAG is collection of users that have already been checked as potential neighbors members of NEIGHBORBAG .

In the example which will follow all similarities are between 0 and 1 and higher similarities are better. When similarities between THISUSER and another are considered it is implied that one of the following happens a the user s machine requests that the server send the other s user s taste profile such as an encoded version of the relevant data from his iTunes Music Library database and the taste profiles of the two users are compared on THISUSER s machine or b the server compares the two users using that same data and returns the result to THISUSER s machine. The former has the overhead that the profiles need to be sent to the user s machine which consumes network bandwidth. The latter adds more work that must be done on the server side increasing the complexity of the server. Different embodiments need to trade off these factors.

Note that this invention must not be construed as being limited to the algorithm above which is presented merely as one of the more simple ways of implementing the invention.

However all approaches that fall within the scope of the invention have in common that profiles arrive at the client node in an order that tends to receive the profiles most similar to the current user first. Accordingly processing is included above whereby a profile isn t retrieved again until a sufficient time period has passed for the profile to have appreciably changed. In the short term the most similar matches will exhaust themselves and less similar matches will follow.

At the beginning the retrieved profiles are essentially random but the process quickly climbs to strong matches. The process therefore will not retrieve profiles in exactly the ideal order however it the techniques used do not generally retrieve the profiles in exactly the ideal order. This method will retrieve proviles in a good enough order that once climbing has reached a high level of similarity and profiles are not being retrieved because they already have been we have the required general decreasing similarity.

The climbing is accomplished by means of calculating the similarity metric with respect to the nearest neighbors of a user for which the similarity has previously been calculated where the latter was found to be at a level high enough that it is worth the expense of going on to retrieve the interest profiles for that user s neighbors to determine whether one or more of them will have an even greater similarity to the target user.

Some peer to peer networks such as the Morpheus file sharing network have an architecture which causes data which would traditionally be stored on a server to instead be stored on a subset of user computers. We will refer to such servers in the context of this invention not necessarily in the Morpheus context as user associated servers. In the conduct of the illegal file trading of copyrighted files the main advantage of this technique is arguably that there is no company which controls the master index and which can therefore be prosecuted or sued.

However from the point of view of the present invention there is another reason and that is to completely or almost completely eliminate the expense associated with a central server. If there is a central server or server network separate from user associated servers then some entity has to pay for maintaining it providing the bandwidth etc. Without one that necessity disappears. Eliminating that necessity enables this invention to be embodied in a sense in pure software such as an open source software project instead of needing to embody it in a project run as a business in order to pay for the servers. Based on the experience of the file sharing networks there are enough users who do not have severe firewall or connectivity issues and who are willing to help others by making their resources available that this is a feasible solution. Moreover unlike file sharing networks there is little real problem if a user associated server becomes temporarily or permanently unavailable because the searching is normally done in the background rather than in real time.

Note that this specification has already described how a hash of the user s ID can be used to determine which server to access for his data. In order to extend that to using user associated servers more is required and the already described hash may or may not be part of that .

In one set of embodiments there is still a central server but rather than serving the taste profiles it contains a list of identifiers which can be used to construct the URL s where the taste profile for each user may be found. So the actual amount of data that needs to be stored on and sent from the server is far less than in the earlier description. For many implementations the load will be light enough that a single desktop computer with cable modem or DSL or similar connection to the Internet will be enough.

The Gnutella network for example provides a cloud of user associated servers many or all of which store the URL s or data that can be used to construct the URL s of many or all of the other user associated servers. When a user obtains Gnutella compliant software whether by download or by other means it normally is distributed with a list of user associated servers that are frequently available. The software then contacts those servers and can get lists from them of other such servers. The local node is then updated with this information and it is available to other nodes that might eventually contact this node. Thus no single central server is required.

This specification will not describe the construction of such networks in detail rather the technical descriptions for Gnutella and other such networks readily found online using such search tools as Google should be used. Use such existing networks as a model for constructing a cloud of nodes which point to each other and obviate the need for a central server.

Preferred embodiments of the invention where the profile data is stored on user associated servers generally use the same computers for storing that data as are used by their associated users as their day to day computers with the exception that they must be accessible to inbound connections i.e. few if any Firewall or NAT issues should apply and they should be connected to the Internet and turned on a substantial amount of the time .

For preferred such embodiments the step of retrieving a random user ID is modified so that instead of asking a central server first a random user associated server in the cloud or semi random influenced by the fact that only a subset of the cloud may be known to the node at the time is chosen and then that server is asked to provide a random user ID of those whose profiles and neighbor lists are stored on that computer. Then the algorithm proceeds as before with the exception that instead of retrieving just the ID of other users enough data is retrieved to construct a URL where that user s information is available. Then it is accessed at that location. Further if an access fails because the URL doesn t respond or the data that is supposed to be there isn t a break is executed and the innermost loop explicitly spelled out in the pseudocode is exited.

Further embodiments lower the percentage of times non response or not found errors occur by providing multiple URL s where the same data can be found on different user associated servers. Then if one fails one or more fallback machines can be tried.

In preferred embodiments user associated servers take responsibility for serving the nearest neighbors of that particular user to the broader community. This causes data for similar users to be gravitate toward being stored on the same machines. One advantage of this technique is that if user associated server A is being accessed and provides a NEIGHBORBAG for similarity testing it is likely that when the accessing node wants to get the taste profiles for the users in the bag seconds or minutes later that machine will still be available on the network.

A further improvement is that instead of sending the taste profiles for the accessing user for the similarities to be calculated they can be calculated on the user associated server in cases where it is judged that it would be more efficient when data transmission expenses are calculated to send the data there. In such a case the querying node would upload its taste profile to the user associated server so that multiple comparisons can be carried out there without further need for network data transmission.

In further embodiments such user associated servers not only store the neighbors of their associated users but also other neighbors with relatively high similarity to other users that are stored on that user associated server. For instance in some embodiments a centroid may be calculated that represents an average of the taste profiles of the users stored on that server. One type of taste profile contains identifiers for every song a user has played on a particular target platform such as Apple s iTunes together with the date it was first added to the user s collection and the number of times he has played it. A centroid averaging a number of such user profiles might contain the identifiers for all the songs played by any of the associated users together with for each song the average of the dates it was added to the system and the average number of plays of that song per user.

The algorithm described above to find the most similar neighbors for a user may be carried out but with respect to this centroid rather than with respect to the user. The ID s of the users most similar to this centroid are stored in a neighbor list for the centroid and their profiles and neighbor lists together their proxies are the ones that that particular user associated server takes responsibility for serving to the community. But it should not be construed that the invention is limited in scope to the concept or centroid or averaging. Any summary of multiple user s profile information that is comparable via a similarity metric to an individual user s profile is equivalent for the purposes of the invention.

For example in some embodiments that involve user s interests with respect to text documents a user s interests may be captured in a list of the most unusual keywords that regularly turn up in text they read. For instance a paleontologist might read text containing the word archaeopteryx fairly frequently. The exact frequency isn t as important as the fact that the population at large very rarely reads text with that word whereas the paleontologist frequently does. So the paleontologist s interest profile can be realistically represented by a list of such words that meet certain predetermined thresholds for unusualness with respect to the general population and frequency with respect to the user himself. Extending that concept to a group of users rather than a single user it is clear that the interests of a group of similarly minded individuals can be represented by a list that contains all the words that are in any of the individuals personal word lists or that are in some predetermined proportion of such lists . This is a completely different approach from using averaging to create a centroid but it falls equally within the scope of the invention as do all other approaches which serve the purpose of representing an individual s interest where individuals are concerned and summarizing such interests for a group where groups are concerned as long as it is possible to compare the interest profiles of individuals to each other or individual interest profiles to summary interest profiles or summary interest profiles to summary interest profiles and calculate appropriate similarity metrics. With respect to the word list a simple similarity metric is to calculate the percentage of words out of the total pool of words formed when the lists are combined are held in common. A more sophisticated approach is to consider every word in the combined list to be a trial with success being that the word is held in common the similarity metric is then the posterior mean based on a binomial distribution and a beta prior. Note that this process may frequently result in more than one user associated server hosting the proxy of a given user. That is good because that allows for redundancy in the system for times when a user associated server is not available. Moreover there is more redundancy for users who are similar to a lot of users then for users who are similar to only a few others. This allows for providing the most reliable and efficient service to the most people.

As a further example in some embodiments the summary is simply the taste profile of the user associated with the user associated server that is directing the search. By finding nearest neighbors to that such a user is also finding neighbors who are relatively similar in taste to other users whose profile is stored on that user associated server as long as the question of whose profile shall be stored is also resolved by virtue of having a high similarity metric with respect to the user associated with the user associated server.

In further embodiments each user associated server carries out searches using an algorithm almost identical to one of those described above with the exception that the search is done with respect to similarity to the collection of users whose proxies whether the proxy contains the taste profile or the user s neighbor list or both and or contains other items are already being served from that particular user associated server. This is as opposed to doing such searches with respect to each individual user whose proxy is stored on the server or facilitating by serving data such searches carried out by the individual user associated nodes. This may be done as described above by comparing other users to a centroid of the collection or it may be done by other summary means all of which fall within the scope of the invention . The standard literature on the subject of data clustering will reveal a number of methods that are equivalent for the purposes of this specification. In preferred such embodiments the user who is associated with the user associated server is always among the users whose proxy would be added to that collection if the user wasn t already there. For instance in the method which involves a centroid produced by averaging the profiles of the users the algorithm would never remove the user associated with the user associated server from the list of users whose profiles are averaged to produce the centroid.

A central server may be not only a single server computer but a set of such computers the distinguishing characteristic not being the number of computers in the central server but rather the fact that they are not associated with a particular user but rather made available on the network to serve data to a substantial number of user associated computers.

When this specification uses the term associated with for the relationship between a user and a computer the computer is the computer that the user normally accesses to get the benefits of the system for instance viewing a list of the users that are more similar to him than any others that have been examined.

The term target user is used occasionally in this specification to refer to a particular user who is using the invention and for whom the invention has found and or is finding other users with similar interests and or tastes.

Preferred embodiments make a display of the individual users who have been found to be most similar to the target user available through a computer user interface. In some embodiments this takes the form of a list in others there are other displays such as images representing the users in 2D or N Dimensional space. In some embodiments the positions such images take with respect to each other in the visual plane represent how similar they are to each other.

Preferred embodiments make recommendations to the target user of specific items based on a list of nearest neighbors that is a list of neighbors who are relatively similar to the target user in taste when with respect to other users of the system.

They do this by processing the preferences of the nearest neighbors in ways that are similar to how this is done in other nearest neighbor based collaborative filtering systems such as for example in the GroupLens Usenet filtering system http www.si.umich.edu presnick papers cscw94 GroupLens.htm incorporated herein by reference or the system described in Upendra Shardanand s 1995 thesis Social Information Filtering Algorithms for Automating Word of Mouth http citeseer.nj.nec.com rd 61053528 2C323706 2C1 2C0.25 2CDownload http citeseer.nj.nec.com cache papers cs 15862 http zSzzSzmas.cs.umass.eduzSz 7Ease ltinezSz791SzSzshardanand.social information filtering.pdf shardanand95social.pdf incorporated herein by reference. Note that those two papers and others describe how recommendations may be made once a list of nearest neighbors has been determined and those and other approaches exemplified by those may be used once such a list has been determined regardless of the particular calculation originally done to determine the degree of similarity another user has and thus how the decision was made about how to add him to the list of nearest neighbors.

However it is important to note that while the papers mentioned above make recommendations based on ratings manually entered by the users the present invention may be used in situations where no such ratings are available. Instead other information may be available such as the fact that the user has purchased particular items or has chosen to experience them a certain number of times for instance has played a musical track a certain number of times . When only purchase data is available a purchase can be considered to be equivalent to a rating of good and no purchase can be considered equivalent to a rating of poor . When the number of times a user has chosen to experience an item is available an easy way to approximate the effect of having ratings is to rank the items by the number of experiences. Then divide the rank by the number of items. This results in a number between 0 and 1 that can be used as a rating equivalent normalized to that interval so that the ratings of all users are on the same. scale. So the techniques mentioned in the afore mentioned papers and others are still usable even where there are no explicit ratings.

However for purposes of example a particular technique of making recommendations for situations where nearest neighbors have been found and number of experiences data is available for each item will be presented here.

This technique is to simply add up the number of experiences for each item for all nearest neighbors. For example assume that out of a universe of 1 000 000 music fans the system has found 100 nearest neighbors for the target user. For each item associated with each fan there is a count of how many times each song has been played. If the system simply adds up these counts for each item the item with the highest total count may be considered to be the most popular item in that community and should be recommended to the target user if he hasn t already experienced it. Equivalently one can compute the arithmetic mean of the number of plays where the number of plays is 0 for users that haven t experienced the item at all.

A variant of the approach described in the previous paragraph that is arguably more reliable is to compute log 1 K for each neighbor item combination where K is the number of times the user has experienced the item in question and then calculate the sum of these values for the population of nearest neighbors. The higher that sum is the more highly the item should be recommended. The advantage of using the log is that for an item to be recommended highly it is more important for the item to be experienced often by a large number of nearest neighbors than it is for a few nearest neighbors to experienced the item a huge number of times.

The same two papers as mentioned above that discuss collaborative filtering and others such as the specification of my own U.S. Pat. No. 5 884 282 herein incorporated by reference describe different ways of creating metrics to capture degrees of similar between two users. All such metrics fall within the scope of the invention. The invention isn t limited to particular metrics rather the focus of the invention is on the structure of the search and where the relevant data is stored.

A similarity metric that is used in preferred embodiments where explicit user entered ratings are not available is the following. Assume user A is the target user and we want to know how similar user B is to user A. We calculate an approximation subject to certain assumptions which are useful to us but may not be true in the real world of a certain probability. This can be loosely summarized as being probability that if a randomly chosen item X not in A s collection but in B s collection is put into A s collection that if we pick a random time in the future when A is experiencing an item from his collection it will be X. An implementation of this concept that teaches the technique is included in the tasteprofile.py module included the computer program listing appendix and described in Appendix 4.

Embodiments of this invention serve the useful purpose of determining which other participating users are most similar to a user who is a participant in the system and storing that information in the computer for purposes of displaying that community and or making recommendations of desirable items. Further embodiments not only store that information but display the community members and or recommendations through the system s user interface.

Some embodiments store each user s profile on their associated computers. Due to issues mentioned above many user associated computers may not be accessible to other users from the internet. So a technique must be provided by which users can serve their profiles when they are stored on user machines. Gnutella style networks provide an example for this. Nodes which are accessible from the Internet allow incoming connections to be made from nodes which are not necessarily connected. Then data on those not otherwise accessible nodes is made available to other nodes on the network through the network accessible nodes which the not otherwise accessible nodes are connected to. In the case of Gnutella this data includes lists of available files and the files themselves. See http www9.limewire.com developer gnutella protocol 0.4.pdf hereby incorporated by reference for more information on the details of the Gnutella approach. In the present invention the network accessible servers usually store lists of the user ID s associated with the nodes they are connected to and when a request arrives for data associated one of those ID s the request is routed to the appropriate connected node the data is retrieved by the network accessible node and then sent by the networkdd accessible node to the requesting node. Most embodiments that use the search algorithm described earlier in this specification modify it when it is used in the configuration described in this paragraph so that if the data for an ID is not available a continue is called in the innermost loop so that control goes to the top of the loop and processing continues as if that information had not been requested. Note that to facilitate hits occurring as frequently as possible nodes normally try to connect to network accessible computers who are on their nearest neighbors list. This makes it likely that network addressable nodes will be connected to some of their associated users s nearest neighbors so that when the interest profiles of neighbors are needed by the algorithm they can more often be retrieved. In general the presented algorithm is modified so that where originally ID s of similar users are requested information is provided that can be used to construct a one or more URL s where the information can be found. If the information is not found on a directly network accessible computer the URL of a network accessible one such as the one providing the URL can be given which includes parameters such as the ID of the user whose information is desired to tell that node which possibly connected node to get the information from. An individual of ordinary skill in the art of peer to peer software development will understand how to create the necessary software in accordance with this description. It should be stressed that this paragraph is for example only and that there are many equivalent variants that involve for instance caching data on intermediate user associated nodes transporting profiles to other nodes for comparison etc. This invention s scope must not be construed as being dependent on specific techniques for making the data and computations available in a peer to peer setting.

In some embodiments two forms of interest profiles are created and stored. One is a very small in terms of the amount of data representation. For example if the main interest profile contains the song names and artist names for songs in the user s collection and the number of times he has played each one which could have thousands of entries this miniature profile may contain only the user s most frequently played 10 songs identified by a hash such as that generated by Python s built in hash function. Preliminary screening including climbing happens as described elsewhere in this specification using the miniature rather than the full profile. Then as a last step before adding another user to the target user s nearest neighbor list the full profiles are checked to be sure the similarity metric is really high enough that the user should be a nearest neighbor for instance that it s higher than the metric associated with the least similar neighbor . If it doesn t meet this final test it doesn t go on the list.

When a miniature profile is used any technique that serves to produce a relatively small from the perspective of number of bytes not necessarily complete representation of the data in the interest profile may be used. The scope of the invention is not limited to particular miniaturizing technologies. For instance in addition to the simple approach described above applicable approaches include using all of the item hashes without any counts using a random selection of items and including the song name itself rather than a hash and optionally further using standard compression algorithms such as are in the standard Python zlib library.

 Neighbors users and similar terms are often used in this specification to represent their interest profiles ID s etc. the meaning is clear in the context.

The source code is contained on the computer program listing appendix. Notes about several specific modules follow 

The pair of classes appearing in this module CalcData and TasteProfile are tightly connected. Each TasteProfile object may have a number of associated CalcData objects. The CalcData objects represent one song in the collection of the user whose TasteProfile it is.

Methods are provided for loading the object from various sources a programmer of ordinary skill will readily infer the formats from the input code.

It is worth noting that for convenience and to save memory songs are frequently identified by an MD5 hash based on combining and normalizing their artist album and song names.

The most important method is probably TasteProfile.calculateSimilarity which compares the current called TasteProfile object with another one passed to it as a parameter. Usually this is used for the local user to sequentially compare his profile to those of other users in order to find the best ones the nearest neighbors.

In such usage a nearest neighbor list is maintained of a predetermined length is maintained and when a profile of greater similarity to the local user comes along compared to the least similar of the current nearest neighbors the least similar one is removed from the list and the new one added.

This module handles the task of using the list of nearest neighbors and their associated profiles for recommendation purposes.

It makes recommendations subject to an adventurousness control. When the control is at one extreme it looks for consensus among neighbors as it moves toward the other extreme it is more and more sensitive to opinions of individual users. In the current embodiment these opinions are expressed passively simply by recording how many times each song is played. 

The code in this module represents one way of clustering cluster data containing songs where the songs or most of the songs have associated genre information. Of course it can be used analogously for other subject areas for instance in the area of academic research it could make use of the papers in the users collections rather than songs and their associated keywords rather than genres .

This algorithm has the advantage that it is much faster than most general clustering algorithms due to making use of the effort that originally went into creating the genre information. Furthermore programmers of ordinary skill in the art will readily see various ways of improving the speed of the code further at the cost of more code complexity .

On a server this is a helper class for genrerankhandlerclass.py. However it has another use as well. On the client it serves to tell the clients which identifier is associated with the cluster a client should download first. That is it outputs a sorted list of clusters with the ones most likely to yield high similarity to the local user.

It does that by means of summary data the xInitData parameter on the  init  method that is sent to the client from the server which contains data that summarizes the differences between the clusters.

In the current embodiment from which this code is derived this enables clients to request the clusters that are most likely to have good similarity matches first this downloading is accomplished via BitTorrent. We do not include the BitTorrent related code here because techniques for accomplishing a BitTorrent download are readily apparent to a programmer of ordinary skill.

This Appendix describes a class of embodiments wherein some of the user nodes run software that has only a one way connection to the other nodes and server if one exists . These embodiments include cases where the connections to the other nodes and server if one exists involve more than one medium. We will focus on a specific example where some of the user nodes which may be full personal computers or may be hand held devices such as Apple Computer s iPod have radio circuitry incorporated into them which allow them to receive transmissions from terrestrial or satellite radio broadcasters. In the case of satellite transmitters these may include the specific hardware associated with the Sirius or XM satellite radio services. 

In the prior art the time of this writing Sirius Satellite Radio has announced a handheld device to be called the S50 which will work with its satellite network and save songs on its internal data storage. It does not have the ability to receive satellite signals on its own. Rather it can only receive songs when attached to a docking device. Samsung has announced its neXus XM Satellite Radio MP3 Players. Users will be able to tag songs they hear on the radio for purchase through the XM Napster online service. The neXus unit will not have a built in antenna rather it will connect to a dock which has an antenna and will record songs from the satellite service for later play without the dock attached.

XM Satellite Radio sells a Delphi XM SKYFi2 units which includes internal storage for pause and 30 minute replay although the antenna is separate. It has announced a Delphi XM MyFi unit which is handled and includes an internal antenna.

What is missing from the prior art is a way to enable the user to receive personalized recommendations or a virtual channel constructed automatically for the benefit of that user to enable him to have the experience of a radio channel specifically geared towards his or her individual tastes.

In this set of embodiments the nodes with two way connections work as described elsewhere in this specification. On the local node reference data is collected nearest neighbors found recommendations are generated and the taste profile of the local user is distributed to other user nodes to be used by them in a similar way if they are deemed by the software to be similar enough in represented taste and interests to those local users. Not all embodiments of this variant that fall within the scope have the nodes with two way connections receiving the taste profiles in an order related to likely similarity to the local user s tastes. Typically these nodes are connected by a network such as the Internet which readily handles two way communication.

The nodes with one way connections in preferred embodiments receive taste profiles via satellite radio. Satellite radio uses digital signals that can easily send taste profile data on one or more channels while sending audio and or video content such as podcasts on others and or it can send a subset of those types of data on a single channel by transmitting one type at one time and other types at other times.

In preferred such embodiments the one way nodes which in further embodiments may be one way at some times and two way at other times are hand held devices like the Apple iPod which include a CPU and memory to store content data such as audio and video data where such memory will include RAM and may include hard drives flash memory or other kinds of persistent storage. Hand held devices are meant to be carried from place to place by an individual and many such devices do not have ongoing two way communication abilities due to the difficulties and expense of maintaining network connections from remote locations. For such devices satellite radio provides an excellent transmission medium for the taste profile and digital content information used by the present invention.

The one way devices which may in some embodiments have two way connections at other times receive taste profile and content information. They also have at least one way of inferring the user s tastes and interests. In various embodiments these may include buttons to rate content he is hearing and or viewing or they may include monitoring which content the user stops prematurely or skips over using a mechanism such as a fast forward button and which content the user repeats. Some embodiments monitor whether a user uses a rewind like button to experience portions of content more than once for instance in a listening to spoken word content the user may want to hear some of it more than once to aid his understanding. Preferred embodiments have an input mechanism such as a button that indicates that a user likes a unit of content such as a song and would like to hear it again.

By using such mechanisms input is provided to the software whereby the software creates a profile indicating certain likes and or dislikes of the user.

Taste profile data received via the one way medium is then processed as described elsewhere in this specification. Taste profiles that are similar to those of the local user are stored and used for recommendation purposes. User profile information may also be used for community purposes for instance in a cell phone embodiment a telephone number or address may be provided whereby the local user can call the other user whose taste profile matched. In some such embodiments additionally a contact recipient will receive bio and or taste profile information from the local user and hear or view it before deciding whether to take the call in further such embodiments the receiver has criteria set in his software that automatically screen for certain biographical characteristics or a certain degree of similarity before the user is alerted to the incoming call. In further such embodiments location data such as GPS information is used so that the local user is made aware of the location which may not be current of the remote user or the software screens on location data so that the local user is only alerted to profiles associated with nearby locations and or alternatively the remote user s software screens attempted contacts based on the location of the local user.

Note that preferred such devices have both satellite radio receiving and cell phone capabilities. Satellite radio reception may be maintained with typically lower consumption of bandwidth and energy resources than cell phone connections and typically have higher data transfer rates so it is helpful to receive a stream of data from the satellite while also having the hardware required to allow the user to make a cell phone call.

A key to this class of embodiments is the fact that the overall network contains both one way and two way nodes at a given instant in time again some of these nodes may change roles at other times . This enables taste profile and in preferred embodiments biographical information or other data such as location to be sent on the network to be received and used by the one way receive only nodes. Because of this mix of node types it is practical to collect the taste profile data on the two way nodes which is used to make recommendations on the one way nodes.

In preferred embodiments of two way nodes containing a broadcast for instance satellite radio receiver as well as wi fi ethernet or other connection to a typical Internet service such as a dial up service cable modem or DSL data derived from other users is substantially or wholly received via the broadcast radio receiving circuitry while data is uploaded via the Internet. This minimizes the use of limited Internet bandwidth for receiving large amounts of data.

Software incorporating all or much of the software contained in this specification runs on a large number of desktop personal computers connected to the Internet. We will refer to it as the Goombah software since there is presently software of that name that incorporates much of that code. The users of those computers use Apple Computer s iTunes software to play music. iTunes writes an XML file on disk containing the identifiers for each track in the user s collection. The Goombah software reads this XML file and uses it as the user s taste profile data. This data is sent to a server under the control of which the data is communicated not only to other personal computers but to a terrestrial radio transmitter that sends the data to the satellite or satellites being used to facilitate a satellite radio service such as XM or Sirius. From the satellites it is broadcast to portable units which could be for instance Sirius or XM enabled versions of Apple Computers iPod device.

On the other personal computers the taste profiles contained in the data play the role of candidate nearest neighbors the nearest neighbors are selected and used to provide content recommendations as described elsewhere in this specification.

On the portable devices an analogous process of neighbor selection and recommendation occurs. However in the embodiment currently being described the recommended music takes the form of at least one virtual channel. That is from the user s point of view it behaves much like a standard satellite radio channel but at least much of the time the content is selected scheduled and played on the user s local portable device.

In this embodiment there is an easily accessible Save button. When the user first starts using the device he tunes into one of the standard satellite channels which he thinks is likely to be a good approximation to his tastes. When he hears content for instance a song that he particularly likes he presses Save. In some other embodiments there is a button for the explicit purpose of enabling the user to indicate that he likes a song there may be another one to indicate dislike or there may be an input mechanism such as physical radio buttons which allow only one to be pressed at a time allowing a degree of liking a song to be expressed other variants are also applicable. In further embodiments there is not a dedicated physical button for this purpose but instead controls are provide whereby the user can navigate through a menuing system to choose a Save option. Samsung s neXus player will have a mechanism through which the user can tag a song for purchase since available photographs do not show a dedicated button for this purpose but rather an input machanism that appears similar to the iPod s for navigating a menu system. The tagging function is undoubtedly activated through that menu system. In the context of the neXus device tagging a song implies the user probably likes it because most people will tend to buy songs that they like although some will buy songs for others such as their children still the statistical likelihood that tagging implies liking a song makes it appropriate for our purposes . So embodiments built into an improved neXus device may use the tag function for this purpose. Alternatively or in addition a separate I like this option may be available through the same menu structure which would serve the purpose here attributed to the Save button. Ideally such a future device will have a built in antenna akin to the Delphi XM Myfi s antenna. All such variants fall within the scope of the present invention. 

The song has been stored in RAM even after the earlier parts of the song were played. So it is in RAM and available to be moved to persistent storage such as flash memory or a hard drive when the Save button is pressed. Typically there is a pause between songs and pressing Save during that pause causes the previously played song to be saved. When a song is Saved it can be played again later with greater frequency than would be the case if the user simply waited for the satellite channel to broadcast it again. The portable device automatically schedules the song to be played again later and does the same for other Saved songs. For instance Saved songs may be played daily for the first week then every other day for the next week then every third day for the first week etc. An unlimited number scheduling variants are possible. The embodiment described here additionally mixes songs from the user s favorite satellite channels with stored songs this is one way the user hears new songs that he can decide to Save or not.

Also since the device described in this embodiment has iPod like functionality the Saved song may be found and played again at the user s will by means of the iPod s standard navigation features including being played automatically in the device s Shuffle mode.

So the Save button has easily understood use and value for the user. However it also serves the purpose of being an input for taste profile data. When the user Saves a song it goes into his taste profile. Unsaved songs may not go there although in some variations of this embodiment satellite songs that the user has heard in their entirety i.e. he didn t turn the device off select a song to play from the device s internal library switch to another satellite channel or perform some other action that cuts the song off it is stored in the profile with diminished mathematical weight. And in some variants songs that were cutoff are stored as songs that are disliked.

If the device is permanently one way that is it never has a direct or indirect through a PC ability to send data onto the Internet or another network the taste profile built by the Save button and or other techniques is never made available to other users. However for the local user s benefit it enables him to discern which candidate neighbors are received from the satellite are nearest neighbors and the device can therefore generate recommendations in the usual way.

As the taste profile for the user of the portable device grows because of the use of the Save button the recommendations that can be generated in the usual manner become more and more accurate.

The embodiment currently being discussed involves a unique identifier for each song which is an md5 hash of a concatenation of the song artist name album defined by the makeSongHash functioned in the accompanying code. Other variants use other techniques such as fingerprints of the audio data an md5 hash of a text representation of the audio data etc. This identifier is contained in the taste profiles for the user and is used as the representation of the song in that data or as one such representation .

When a song is recommended it goes into a list in the device s storage and is checked against a broadcast schedule transmitted periodically by the satellites and received by the device. The device then knows to record certain songs sent on certain channels in the future and does so when the time comes saving the song data into persistent storage and adding the song to the device s music library. In this way the device builds a library of music that the user is likely to enjoy. This music is added to the user s virtual channel and also available to play at his will through the device s song navigation mechanisms.

With regard to the virtual channel the result is as if there a radio channel dedicated exclusively to that individual user s tastes which gets more and more finely tuned over time.

When the portable device is connected to a personal computer for instance via FireWire USB BlueTooth Ethernet or wi fi songs downloaded from the satellite may be transferred to the computer either for long term storage in that computer or played using the computer s hardware using data only persistently stored on the device.

In subscription mode the user pays a set fee per month and can store as much music downloaded from the satellites and or from other sources as well fit in the device s storage and they may be played as frequently as the user desires. In some variants there is a tiered subscription service where for a particular monthly fee a particular number of songs or artists s music may be stored persistently or a particular amount of storage may be allocated or songs from the satellites may be played only a particular number of times. 

In purchase mode Saving a song causes the song to be purchased. In some variants the Save button is labelled Purchase . When the device is eventually connected to a two way network or to a wireless enabled financial smart card with debit capabilities or to analogous financial technologies the cost is deducted.

Rather than receiving a schedule from the satellites the schedule may be received over the Internet or other network for devices that sometimes have connections to such networks. In further embodiments no schedule is available and instead a directory is provided of channels together with taste descriptive data such as a list of genres that each channel focuses on or a list of representative artists which is used to determine which channels are likely to contain songs the user will want to hear and or are or will be recommended.

In typical embodiments taste profile data contains genre info for songs in the taste profile or the service provides a look up table mapping song identifiers to genres. When the channels have associated genre information they can use that information for recommended songs to choose likely channels to listen to to receive the songs. When information such as representative artists is used to describe channels the artists that most frequently appear in taste profiles having the recommended song can be matched against the lists of artists describing different channels and the channels that best match the currently recommended but not yet downloaded songs are the ones that the device focuses on in waiting for the song to arrive.

Some embodiments use sonic descriptors of each channel to describe it. For instance the companies Savage Beast and SoundFlavor describe each song by a set of attributes including such factors as tempo instrumentation sex of the singer and hundreds of others. Some them are human generated and some are software generated the software examines the audio data or generated with the aid of software. It is obvious that with such a collection of attributes average values or other kinds of summarizations may be generated for each channel that tends to describe the music played on that channel. And a vector or other structure may be provided that enables the attributes associated with recommended songs to be determined.

Such structures may be downloaded via the Internet or from the satellites. On a special channel or interspersed with other data the satellites can send the attributes associated with each song either at the same time as a song s audio data is transmitted or separately this occurs in preferred embodiments.

In some embodiments the attributes associated with songs the user likes for instance as signified by pressing the Saved button are summarized by software within the handheld device. For example average values of the attributes can be calculated using arithmetic or geometric averaging or only the attributes most frequently associated with liked songs may be counted or other summarization techniques may be used these comprise a taste profile of the user instead of or in addition to the taste profile built from identifiers of liked songs where liked songs may also be signified by being already owned by the user . In some embodiments there is an additional input device such as a button that signifies that the user does not like a song then the averages and or presence absence counts used to generate the taste profile may be adjusted negatively by that control in association with a particular song.

In some embodiments each user is associated with a song attribute and the value of the attribute depends on whether the associated user has the song or not and or on how often the user plays the song. So each song has an associated list of attributes corresponding to users either instead of or in addition to other attributes such as ones derived from the sonic content.

In embodiments where there are too many song attributes to be downloaded without using too much bandwidth and where the attributes are statisitically correlated factor analysis may be used to reduce the number of attributes into principle components. Based on a calculations generated on a server or using distributed systems the local device can use these calculations to generate the principal components from locally produced data such as the identifiers of the other users who have each song as determined by their incoming profiles these can be summarized to produce a taste profile for the user. Thus it is possible to arrive at a manageable number of attributes for individual songs and local taste profiles. Those of ordinary skill in the art of statistical factor analysis will see how to do this.

In many embodiments having attributes associated with each song comprising a song taste profile which correspond well enough to the attributes of a summarized taste profile for the local user that similarity can be measured between the two types of taste profiles recommendations are generated by using the songs whose taste profiles most closely match the local user s taste profile. Thus instead of the process of finding nearest neighbor users and deriving recommendations from their likes and interests the nearest neighbors are themselves recommendable items and the nearest ones are therefore recommended.

Some embodiments need no two way nodes. The portable devices calculate which incoming songs are nearest neighbors without any data from other user nodes. Note that while human input may be used to decide on the appropriate attribute values for each song this input need not be done on user nodes as we use the term elsewhere in this specification. Rather that data may be input through software specially designed for the manual entry of such data by a someone whose job it is to do that analysis work.

To envision a more concrete example of the invention described in the previous paragraph satellites broadcast taste profile information for each song. These may be broadcast at the same time as the songs by interleaving the music data with the song data or by using another channel or they may be broadcast at other times. In a system where a broadcast schedule is broadcast in advance of broadcasting the songs it is preferable that the song taste profiles are broadcast a substantial amount of time before the songs themselves so that software may automatically schedule the future recording of very similar songs. As described earlier the user s local tasteprofile is refined over time due to input from a Save button or other passive or active indications of taste and the portable device may never have any two way connectivity. So using the portable device s CPU to find nearest neighbor songs based on user taste profiles built up on the local machine and compatible taste profile broadcast from the satellites produces a situation where analysis of each song using human and or software input empowers portable devices to adaptively provide ever more appropriate listening material for users.

It should be noted that the above example if for example only and must not be construed to limit the scope of the invention. The role of portable device in the example may be played by any CPU enabled device including a desktop PC or a unit built into an automobile or airplane.

When the term satellite or satellites is used in this specification it should be noted that whether there is one or more than one satellite makes no difference from the standpoint of this invention. Although of course a collection of satellites will provide a broader range of coverage than a single satellite. One advantage of the techniques described here is that especially in embodiments where the song taste profiles are transmitted in close temporal proximity to the song data a portable device is enabled to acquire a library of satellite downloaded music that the user may continue to enjoy even if the device goes out of range of the satellite s for some time.

In another set of variations no taste profiles are sent from the satellites. Instead a software analysis of each song is done in the portable device itself determining values for attributes such as tempo. Software to do this sort of thing exists today in for example the Polyphonic HMI s Hit Song Science technology. Any engineer of ordinary skill and access to such software will see how to use integrate it into the present invention. Thus song taste profiles generated by such software play the same role as downloaded song taste profiles do in other embodiments described above. However there is a substantial advantage to downloading the song taste profiles present software does not have the ability to examine song data for such attributes as sense of humor in the lyric. There are many such qualities that pertain to recorded music that software is not currently capable of analyzing. So embodiments based wholly on software analysis of the music can be expected not to produce as much user benefit as embodiments involving at least some human analysis of the songs. For spoken word content speech to text software can determine many of the words spoken and those can be mapped to content vectors as is often done for document analysis that can comprise the item taste profiles.

While the above specification focuses on songs for reasons of example the same approach will also accrue to spoken word recordings podcasts involving music played at intervals with spoken word in between and video and even purely visual content.

For example one set of embodiments is based upon an LCD plasma or nanotube display hanging on a wall. It displays different images which may be moving or still which it receives from a satellite. Taste profiles are downloaded which contain attributes pertaining to each visual item in some embodiments the taste profiles contain identifiers of other users who like the visual item supplied by users with two way network connections in other cases or in combination with such human identifiers taste profiles containing attributes such as indications of the presence of various colors hard or soft edges and whether the image is realistic or abstract landscape or portrait etc. in some embodiments software analysis within the local device produces a taste profile for instance such information as color is simple to extract from digital image data there is existing software used to block pornographic sites which can discern such characteristics as the presence of bare human skin.

There is a Save button that protrudes slightly from a frame that surrounds the picture . When the user sees an image he particularly likes he presses Save and then that image is stored into persistent storage by a CPU which is embedded into the device and displayed later. The CPU also makes use of that information to improve a local taste profile representing the user s tastes. This enables the device to acquire more visual items that the user will enjoy as described above for music.

Another set of variations of the invention here as it relates to one way devices but also as it relates to purely two way node embodiments described elsewhere in this specification is similarity matching by means of pattern matching technologies. For example a song would be represented instead of or in addition to a taste profile containing a list of attributes by a pattern matching software. For instance it could be represented by a neural net with the number of layers and nodes and the numerical values that are intrinsic to the net being defined in a way that takes a local user s taste profile information and outputs a high value if the song is likely to match the user s tastes and a low value if it is not. As one way of finding the necessary values the neural net can be trained using taste profile data of users who had two way connections enabling the profiles to be communicated to a central server. The neural net is trained so that it takes the taste profiles as input and outputs high or low values depending on whether the user that is currently trained on liked the song or not for instance based on whether he pressed a Save button or did nothing or fast forwarded past a song and never listened to it in its entirety in such a case the net would preferably be trained to output a numerical value with a high value in the first case a middle value in the second and a low value in the third . In order that there are input values to train the neural nets taste profiles based on song attributes are also provided and a user taste profile to be input into the artificial intelligence unit is generated based on the ones associated with the songs the user likes and or does not like .

In some embodiments content items such as songs are accompanied by lists of identifiers of other songs that are considered to be likely to be enjoyed by the same people as the current song as determined for example either by having similar sonic and or lyrical attributes or tending to be liked or purchased by the same people. These identifiers may be used as attributes for nearest neighbor matching but they may also be used as simple indicators that the listed song identifiers may be used to schedule the acquisition of those other songs if the user likes the current one as indicated for example by pressing a Save button while listening to it .

In some embodiments incorporating the virtual channel concept described above when the user first starts the player and selects a virtual channel if there aren t many songs or are no songs stored in the device yet it may start playing the currently being broadcast song from one of the user s favorite channels and follow that up with a song from storage if one is available or play a song from one of the user s favorite channels.

When playing songs from the user s favorite channels it may receive broadcasts from more than one channel at a time and play one song while simultaneously caching another song from another channel into RAM of persistent storage after the first song is complete it may play a song from another channel.

This Appendix describes a class of embodiments wherein there is two way communication between nodes but it is limited to a particular geographical area being enabled by such wireless technologies as Wi Fi or Bluetooth or the like.

When two wireless enabled portable devices are in close enough proximity that communications may be automatically established a link is set up between the two devices. Communications may occur between more than two devices simultaneously but for simplicity of example we are focusing the interactions between one pair at a time. For instance a link may be established between two devices in different automobiles or between two handheld devices such as cellular phones.

All or a substantial portion of the music library identifiers in each device comprises the taste profile of that devices. It is communicated to the other device by wireless means. The similarity of the other user to the local user is calculated by means of the taste profiles by local user we mean the person whose information is in one of the two devices . If the other user s taste profile makes it one of the N most similar ones seen by the local user s device where N is a predetermined number the taste profile is stored and used for recommendation purposes as described elsewhere in this specification.

Note that very similar but older taste profiles may be deleted and thus there may be more N chosen for storage over the course of time.

In preferred embodiments for a subscription fee the devices are allowed to copy music from one device to another. If a track residing on a device to which the local user is currently connected has a highly recommended song on it it is transferred to the local device either automatically or after suggesting the transfer and waiting for the user to OK it for instance by pressing a button on the device in response to an onscreen notification . In other embodiments the device keeps track of how many times the user has played a song and to play it more than for instance three times the user must buy the track. This transaction occurs at the time it is connected to the wired Internet either through a wireless base station a direct Ethernet connection or a connection via USB FireWire or the like to a desktop PC which is connected to the Internet .

In further preferred embodiments the data corresponding to each song may contain an indicator such as a bit or particular byte value indicating that certain songs are free in other words they can be legally transferred between devices without legal or copyright hindrance. In that case transfers occur as described above but in the absence of a paid subscription only the free songs may be transferred.

Practicioners of the art of creating wireless networking hardware and software such as Bluetooth and Wi Fi will readily see how to handle the connectivity aspects described in this Appendix.

The present invention is desirably implemented at least in part via a public network or internet although some embodiments make use of satellite transmissions and or wireless transmissions directly from device to device. It may for example be coupled to a private network or intranet through a firewall server or router. As used herein the term internet generally refers to any collection of distinct networks working together to appear as a single network to a user. The term Internet on the other hand refers to a specific implementation of internet the so called world wide network of networks that are connected to each other using the Internet protocol IP and other similar protocols. The Internet provides file transfer remote log in electronic mail news and other services. The system and techniques described herein can be used on any internet including the so called Internet.

One of the unique aspects of the Internet system is that messages and data are transmitted through the use of data packets referred to as datagrams. In a datagram based network messages are sent from a source to a destination in a manner similar to a government mail system. For example a source computer may send a datagram packet to a destination computer regardless of whether or not the destination computer is currently powered on and coupled to the network. The Internet protocol IP is completely sessionless such that IP data gram packets are not associated with one another.

The firewall server or router is a computer or item of equipment which couples the computers of a private network to the Internet. It may thus act as a gatekeeper for messages and datagrams going to and from the Internet .

An Internet service provider ISP is also coupled to the Internet. A service provider is an entity that provides connections to a part of the Internet for a plurality of users. Also coupled to the Internet are a plurality of web sites or nodes. When a user wishes to conduct a transaction at one of the nodes the user accesses the node through the Internet.

For Internet enabled embodiments each node is configured to understand which firewall and node to send data packets to given a destination IP address. This may be implemented by providing the firewalls and nodes with a map of all valid IP addresses disposed on its particular private network or another location on the Internet. The map may be in the form of prefix matches up to and including the full IP address.

Also coupled to the Internet is a server containing an information database with representations of user profiles and associated user identifiers . The information may be stored for example as a record or as a file. The information associated with each particular user is stored in a particular data structure in a database. One exemplary database structure is as follows. The database may be stored for example as an object oriented database management system ODBMS a relational database management system e.g. DB2 SQL etc. a hierarchical database a network database a distributed database i.e. a collection of multiple logically interrelated databases distributed over a computer network or any other type of database package. Thus the database and the system can be implemented using object oriented technology or via text files.

A computer system on which the system of the present invention may be implemented may be for example a personal computer running Microsoft Windows Linux Apple Macintosh or an equivalent operating system. Such a computer system typically includes a central processing unit CPU e.g. a conventional microprocessor a random access memory RAM for temporary storage of information and a read only memory ROM for permanent storage of information. Each of the aforementioned components is coupled to a bus. The operating system controls allocation of system resources and performs tasks such as processing scheduling memory management networking and I O services. Also coupled to the bus is typically a non volatile mass storage device which may be provided as a fixed disk drive which is coupled to the bus by a disk controller.

Data and software may be provided to and extracted from computer system via removable storage media such as hard disk diskette and CD ROM. For example data values generated using techniques described herein may be stored on storage media. The data values may then be retrieved from the media by the CPU and utilized to recommend one of a plurality of items in response to a user s query.

Alternatively computer software useful for performing computations related to enabling recommendations and community by massively distributed nearest neighbor searching may be stored on storage media. Such computer software may be retrieved from the media for immediate execution by the CPU or by processors included in one or more peripherals. The CPU may retrieve the computer software and subsequently store the software in RAM or ROM for later execution.

User input to the computer system may be provided by a number of devices. For example a keyboard and a mouse are typically coupled to the bus by a controller. The computer system typically also includes a communications adapter which allows the system to be interconnected to a local area network LAN or a wide area network WAN . Connections may be wireless or wired Thus data and computer program software can be transferred to and from the computer system via the adapter bus and network although it should be noted that in embodiments without two way connectivity the device manufacture may load the software onto the device.

