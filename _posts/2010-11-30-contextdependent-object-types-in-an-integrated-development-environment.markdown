---

title: Context-dependent object types in an integrated development environment
abstract: A method is provided to display indicia of an object type for a service within a user interface of a software development system that runs on a computer, the method comprising: obtaining runtime context information that includes an identification of a respective service and an indication of a user role; providing a plurality of corresponding object types; using context dependent rules to determine which respective object types are within scope of a service; and generating a user interface that includes respective indicia of respective object types determined to be within the scope of the service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08869052&OS=08869052&RS=08869052
owner: SAP SE
number: 08869052
owner_city: Walldorf
owner_country: DE
publication_date: 20101130
---
Integrated development environment IDE applications abstract the computer programming complexities and reduce software applications development time so as to enhance the productivity. An IDE allows a developer to concentrate more on the functionality of the application that is being created rather than concentrating on the writing code. An IDE may include a variety of components such as a source code editor a compiler or interpreter build automation tools and a debugger and tools to build an executable for example. Versioning control may be included to assist computer programmers manage the history of the development objects e.g. source code. An IDE for object oriented programming OOP often includes a class browser tools to produce class hierarchy diagrams and an object inspector for example. An IDE can assist a developer in developing applications by allowing him to easily drag and drop objects onto a form or onto a canvas of the application that is under development. Thus a developer may be required to write fewer lines of code which reduces the time required to create an application. An IDE may combine several editor tools each tool tailored to process objects of a specific type. State of the art IDEs often provide plug in options which allow users or commercial developers to integrate external tools and new object types.

However not all of tools object types and operations are intended to be used by anybody anywhere. Depending upon user authorizations user role system configuration client specific customizing and other context information access to certain types and operations and tools may be forbidden or restricted. FIGS. and A B provide illustrative examples of user interfaces that are not especially well matched to the particular context in which they are used.

With the increasing complexity of IDEs there has been a need for improvement in the ability to flexibly generate different user interface displays for use within an IDE that support differences in the availability and prominence of the displays of different object types and operations to different users in different situations.

In one aspect a method is provided to display indicia of an object type for a service within a user interface of a software development system. In another aspect a method is provided to display a user interface menu within a user interface of a software development system. In yet another aspect a method is provided to display indicia of an object type within a hierarchical user interface of a software development system. Runtime context information is used in concert with information structures in computer readable storage device that indicate context information dependent rules to determine a display to be generated. A user interface display is generated consistent with the runtime context and context dependent rules.

These and other features and advantages will be understood from the following detailed description of embodiments in conjunction with the appended drawings.

The following description is presented to enable any person skilled in the art to create and use a computer system configuration and related method and article of manufacture to enable different object types object type operations and object type display presentations within different contexts. Various modifications to the preferred embodiments will be readily apparent to those skilled in the art and the generic principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the invention. Moreover in the following description numerous details are set forth for the purpose of explanation. However one of ordinary skill in the art will realize that the invention might be practiced without the use of these specific details. In other instances well known structures and processes are shown in block diagram form in order not to obscure the description of the invention with unnecessary detail. Thus the present invention is not intended to be limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features disclosed herein.

In accordance with some embodiments object types are comprehensively specified at design time. An object type specification designates applicable functional scope and operations as well as requirements to access operations on an object type. An object type specification also may include options and conditions for displaying on the UI.

At runtime the IDE uses the object type specifications in conjunction with runtime context information e.g. system client user profile object state to determine the availability of object types specific objects and operations. The availability is checked before those entities types objects and operations are presented on screens or in menus. Based upon the availability of object types objects and operations the IDE flexibly and dynamically generates situation specific screens and menus. Generation of user interface displays once a determination of object types or elements to be represented in the user interface is well known to persons skilled in the art and is not described in detail herein.

Object type definitions are provided that set forth runtime context dependent rules for the use of object types in an IDE. Runtime criteria may include user role system configuration user authority for a particular operation for example. is an illustrative flow diagram representing interaction between a user an integrated development environment IDE and an object type provider OTP in accordance with some embodiments. The OTP acts as an interface between the IDE and the object type definitions. But the Object Type Provider is more than a simple API Application Programming Interface it also evaluates the dynamic availability and significance of the individual object types by accounting for the complex runtime situation. A machine is configured according to program code to act as an IDE that is responsive to user commands. The machine is further configured according to program code to act as an object type provider that is responsive to the IDE. It will be appreciated that although the OTP and IDE are shown as separate components the OTP may be implemented as integral with the IDE.

A characteristic of an IDE is that it provides an infrastructure in general a set of services which eases the development process and supports the user. These services refer to functional scopes such as Active Inactive Handling Version Management Transport Management Where used list . Functional scopes are rather coarse grained entities whereas the operations or functions are rather fine grained entities For example the functional scope Version Management includes operations such as Display version Compare versions Retrieve version . Object type definitions specify to which of the services or functional scopes an object type may be associated and which of the operations may be applicable to the object type.

An OTP is programmatically integrated at many locations in the source code of the IDE these locations representing functional scopes . Then at runtime the OTP dynamically determines the availability visibility and UI presentations of the object types objects and operations. These determinations depend upon context information indicative of the current dynamic situation e.g. user profile user authorizations system or client customizing and settings e.g. switch settings object state locked saved active inactive hardware or software parameters backend engine etc. With the aid of the OTP the IDE generates menus and screens.

At runtime the process of evaluates pre defined object type definitions in view of runtime context information to determine the availability of object types operations that can be performed on those object types and the position of visible indicia of those object types in a display screen. In user block a user requests to start the IDE and opens a general view or display screen e.g. a browser view. In response to the user request IDE block requests from the OTP all available i.e. visible object types. In response to the IDE request OTP block evaluates runtime context e.g. object type specifications user authorities for the activity DISPLAY user role system configuration etc. and returns the available object types. IDE block generates a user interface screen that displays indicia of the object types available to the user. In user block the user requests a menu for an object type shown on the screen display. In response to the user request IDE block requests from the OTP available operations for the selected object type. In response to the IDE OTP block evaluates runtime context e.g. object type specification user authorities user role object state etc. and returns available operations. IDE block generates the specific menu using the returned operations. In user block the user selects an operation on the object type. In response to the user request IDE block requests from the OTP the appropriate tool for the selected operation and object type. In response to the IDE request OTP block loads and returns the proper tool according to the type specification. IDE block invokes the returned tool to process the selected operation.

As explained in the following paragraphs each object type specification may provide context dependent rules that determine what shall be referred to herein as a functional scope to which the object type is connected may provide context dependent operations that are applicable on the object type and may provide context dependent information that determines where positioning e.g. within a hierarchy and how prominently the object type is to be presented in an output device e.g. a user interface display. These object type data scope operations positioning may be coupled as part of an overall object type specification to some context based requirements or conditions that are checked evaluated at runtime to determine whether a given object type is within the scope of the request to determine which operations are to be offered and to determine positioning of indicia of the object type and the operations offerings within the output.

The example object type data model structure includes an OBJTYPE REGISTRY table and an OBJTYPE TEXTS table that provide what shall be referred to herein as formal data that provide general information concerning the object type and its display. In the illustrated embodiment the OBJTYPE REGISTRY structure provides a technical name for the object type which may involve a multi component key e.g. transporttype subtype an edit date EDATE and identification of an icon i.e. pictogram to act as visual or graphical indicia of the object in a user interface display screen. In the illustrated embodiment the OBJTYPE TEXTS structure provides a display name for the object type. In some embodiments a language dependent text table is provided that contains the object type name in different languages and character sets in different grammatical cases e.g. singular and plural nominative case accusative case and with different character lengths to cope with different field lengths on the UI . The IDE uses these name related data to generate certain screen displays and menu displays that incorporate visual indicia e.g. an icon representing the object type . In some embodiments an object type may be declared to be normal abstract and or derived . Moreover an object type may be derived from another type which may be abstract or not . In order to derive an object type the parent object type must be named. Derived data can be redefined or overwritten . Furthermore an object type may belong to a category or class of object types or may be part of a type hierarchy.

The OBJTYPE SCOPES table and the OBJTYPES SCOPES REQUIREMENTS table provide first data sets that provide coarse high level rules for control or filtering of the context dependent functional scope that is enabled for the object type. The functional scope signifies services or areas or components of the IDE where an object type may be integrated Active Inactive Handling Version Management Transport Management Where used list etc. A functional scope also may signify a hidden or dark function such as Automatic Backup where objects of the given type are to be involved but are not directly accessible to the user and may have no corresponding visual indicia in a UI display. For example an object type that is defined to be picked up in the Automatic Backup job of the IDE. For a common developer this batch job has no visibility on the UI.

Table 1 provides example detailed rules that may be provided within the OBJTYPE SCOPES table structure and within the OBJTYPES SCOPES REQUIREMENTS table structure of . Scope requirements information provided in the OBJTYPES SCOPES REQUIREMENTS table corresponds to information provided in the first and second columns of Table 1. The first and second columns of Table 1 respectively indicate functional scopes in which the object type may be available and conditions or requirements for availability within a given functional scope. For example referring to the first data containing row of Table 1 the example object type is available within the functional scope Active Inactive Handling provided that the condition that the current user is in the Developer role is satisfied. In this example Active Inactive Handling is a functional scope. When no requirements are defined for a certain scope e.g. Transport Management then the object type has unconditioned access to that scope. Processor tool information provided in the OBJTYPE SCOPES table corresponds to the third column of Table 1 which indicates the processor tool provided within each functional scope. Thus the example OBJTYPE SCOPES table structure and the OBJTYPES SCOPES REQUIREMENTS structure determine the context dependent conditions in which a given object type may be available within a given functional scope and also determine the processor tool s available for use with the object type within that functional scope.

Note that in the middle column of the Table 1 the Required User Role is one example for a context dependent requirement.

A processor tool is the software tool to be called by the runtime environment in order to process the object type in the context of the respective Functional Scope .

Typically a processor tool is decoupled from the IDE framework. Upon a request the IDE framework searches through some registry to determine the right tool. For example in order to display some Graphical Model object the appropriate processor tool will be a Graphical Editor . In the present embodiments described herein the object type specifications include information on the processor tools the set of object type specifications therefore implicitly establishes a tool registry. In an alternative embodiment the processor tools might be registered separately from the object type specifications.

In an object oriented programming language such a processor tool or editor is a class which implements a certain interface. The runtime environment will call the tool class via the interface. For any Functional Scope an individual tool or a shared tool may be registered as processor tool.

The OBJTYPE FUNCTIONS and OBJTYPE FUNCTIONS REQUIREMENTS tables provide second data sets that provide rules for finer lower level control or filtering of context dependent operations that are enabled for the object type. The example second data set identifies context dependent operations associated with the object type and the conditions or requirements under which the operations are available to be accessed used. Table 2 provides example detailed information that may be provided within the OBJTYPE FUNCTIONS and the OBJTYPE FUNCTIONS REQUIREMENTS table structures of . In some embodiments a first data set such as that of Table 1 is used to determine whether a given object type is within the scope of some service component or area of the IDE for a given context. Assuming that the object type is within the scope then a second data set such as that of Table 2 is used to determine which operations associated with the object type are available for the given context.

The first and second columns of Table 2 respectively indicate operations that are available and conditions for availability. For example referring to the second data containing row of Table 2 the example operation DISPLAY is available provided that the condition User has authorization S DEVELOP is satisfied. A user role is associated with a distinct set of authorizations. An authorization may refer to an authority object and an activity . The IDE may check whether the current user in his current role has the required authorization. 

A combination of context dependent conditions linked with AND or OR or combinations may be specified for an operation. Requirements may include user authorization level hardware parameters or the existence installation of a certain backend software engine for example.

For example consider the operation EXECUTE which means to execute specific objects of the given type. Example To execute a compiled program means to run the program. A context dependent rule for the EXECUTE operation may involve two requirements specified in an object type specification 

1. The user account must have some technical authorization in the software system characterized by some authority object S DEVELOP and activity EXECUTE .

Both conditions may be defined and linked with AND in the object type definition at design time. At runtime the system will evaluate them. The result is that operation function EXECUTE will be available e.g. visible and selectable on the User Interface only if both conditions are fulfilled at runtime.

Note that in some embodiments requirements may be specified as being mandatory or sufficient which is roughly equivalent to combining requirements with AND or OR .

The third column of Table 2 indicates whether at runtime indicia of the object type or operation is visible on the user interface when the context condition is not satisfied and the operation is unavailable. For example indicia of the DISPLAY operation is visible even if the DISPLAY operation is unavailable but indicia of the CREATE operation is not visible if the CREATE operation is unavailable. Note that information in the third and fourth columns Display Mode and Processor Tool is not required to determine whether condition dependent operations are available. The Display Mode can be defined as a general setting which holds for any operation or even for any object type the Processor Tool may already be defined with respect to the Functional Scope i.e. on a higher level so there might be no need to override it here .

In Table 2 the second column Required Authorization is one example for a context dependent requirement.

The OBJTYPE POSITIONS and OBJTYPE POSITIONS REQUIREMENTS tables provide third data sets that provide rules for control or filtering of context dependent UI display presentation e.g. position of visible indicia of a given object type. The example third data set identifies context dependent object type display presentations and the conditions that determine which presentation is generated. Table 3 provides example detailed information that may be provided within the OBJTYPE POSITIONS and the OBJTYPE POSITIONS REQUIREMENTS table structures of . The Table 3 example refers to general views i.e. views of sets of object types as shown in Browsers . Moreover positions may be characterized by abstract Levels or by technical identifiers e.g. Root node in Explorer Tree . In the Table 3 example the importance of a certain object type is relative since it depends on the role or profile of a user or on other parameters. Accordingly the object type is to be presented more or less prominently within a set of object types on the UI depending upon a user s role.

It will be appreciated that some object types may require categories of information in addition to that shown in the data model of the general structure shown in in order to instantiate the object type. For example the access of an object type to functional scope Active Inactive Handling may require further detailed data such as a list of dependent object types i.e. objects which have to be activated synchronously with objects of the present type Activation phase at runtime where objects of the present type have to be activated e.g. Pre Activation or Standard Activation or Post Activation . As another example access of an object type to functional scope Transport Management may require further detailed data such as to indicate whether objects of this type are to be automatically transported to other systems in the transport landscape or manually transported to indicate whether this is a main transport type or a subordinate transport type The latter means Objects of this type are transported as a part of another object. and to indicate the transport layer in which objects of this type are transported. As yet another example access of an object type to functional scope Where Used list may require further detailed data such as which objects object types may be used by objects of the present type and which objects object types may use objects of the present type.

In some embodiments an Object Type Editor tool is provided to support persons who design object types and object type specifications. By providing admission control edit locks automatic entry help and entry checks as well as comprehensive checks an Object Type Editor tool can assure that object type specifications are consistent plausible and complete. In general functional scope operations functions and UI positioning for a given object type are interdependent. The Object Type Editor can check for any conflicts. For example an object type which allows operation Transport should have access to the functional scope Transport Management . Object types can be comprehensively specified at design time. Authority checks and other availability checks at runtime can be delegated from the tools to the Object Type Provider . In effect the object types and tools in the IDE can be centrally controlled and the usability of the IDE is improved. Screens and menus on the User Interface are more homogeneous.

An alternative object oriented programming approach to comprehensively specifying scope operations and or presentation of an object type is to represent object type specifications as classes implementing well defined interfaces. At design time comprehensive properties of an object type are written in the source code of such a class. In this alternative embodiment there is no need for a specific editor tool for object types.

Referring again to additional illustrative details of the process of block are shown in . Additional illustrative details of the process of block are shown in . Additional illustrative details of the process of block F are shown in .

More particularly is an illustrative flow diagram showing details of a first OTP process performed in response to an IDE block requests for all available i.e. visible object types. It will be understood that a machine may be configured with program code to implement acts represented by the illustrative modules of . In response to a request from the IDE which is responsive to a user request to start a service for example module accesses a corresponding object type definition from an object type definition database which stores a multiplicity of object type definitions. Referring to module uses OBJTYPE REGISTRY table information to retrieve the object type definition. Module accesses saved context information to obtain context data that is required to evaluate the context dependent scope conditions within the OBJTYPE SCOPES table and the OBJTYPES SCOPES REQUIREMENTS table of the selected object type definition. As explained below the context information is not persistently stored but rather is saved only temporarily. Decision module evaluates the context dependent conditions specified by the object type definition for the selected object type to determine whether the selected object is within the scope function.

Note that the object type information in definition database is persistently stored whereas the context information relates to the runtime situation e.g. system state date time user role etc. which comprises transient data. If decision module determines that the selected object type is within the functional scope then decision module evaluates context dependent conditions specified by OBJTYPE POSITIONS and OBJTYPE POSITIONS REQUIREMENTS tables of in view of context information to determine whether a special display rule is to be applied to the selected object type. If decision module determines that a special display rule is to be applied to the selected object type then module returns the selected object type and the special display rule to the IDE module which integrates the selected object type into generation of the user interface in accordance with the special display rule. Referring to Table 3 for example the special rule might specify that the object type is to be displayed as the root node in the tree. If decision module determines that no special display rule is to be applied then module returns the selected object type and a default display rule to the IDE module which integrates the selected object type into generation of the user interface in accordance with the default display rule. Following a determination by decision module that the selected object type is not within the functional scope a return by module or a return by module whichever the case decision module determines whether the last object type has been evaluated for it s being within the functional scope. If not then control flows back to module and the process repeats. If decision module determines that all object types to be evaluated have been evaluated then the process ends.

Referring again to for example the first OTP process of can be used to determine whether and where a Check Configuration object type is incorporated within a user interface. For the illustrative user interface of for example decision module would have determined that the Check Configuration object type is within the functional scope decision module would have determined that a special display rule applies to the Check Configuration and module would have returned to the IDE indications that the Check Configuration object type is to be displayed according to the special display rule. In the case of the example user interface of the special display rule specified that the Check Configuration object type is to be displayed in a top level of a display hierarchy.

Referring to the user interface display screen of for example decision module would have determined that the Check Configuration object type is within the functional scope decision module would have determined that no special display rule applies and module would have returned to the IDE indications that the Check Configuration object type is to be displayed according to a default display rule. Accordingly the example user interface of displays the Check Configuration object type in a lower level of a display hierarchy beneath the package node.

Referring to the user interface display screen of for example decision module would have determined that the Check Configuration object type is within the functional scope decision module would have determined that a special display rule applies and module would have returned to the IDE indications that the Check Configuration object type is to be displayed according to a special display rule. in this example the special display rule specifies that the Check Configuration object type is not to be visible at all in the user interface. Accordingly the example user interface of omits the Check Configuration object type altogether.

Referring again to for example the second OTP process of can be used to determine whether the Create operation is available for the Check Configuration object type within different contexts. For the illustrative user interface screen display of for example decision module would have determined that the Create operation is available for the Check Configuration object type within the context given for the user interface of which includes a user in the role of quality manager. Module would have returned to the IDE indications that the Create operation is to be displayed in a menu of operations for the Check Configuration object type. Referring to the user interface display screen of for example module would have determined that the Create operation is not available for the Check Configuration object type within the context given for the user interface of which includes a user in the role of developer. Module also would have determined that the Create operation is to be displayed with indicia that it is unavailable i.e. displayed as grayed out or dimmed . Referring to the user interface display screen of for example module would have determined that the Create operation is not available for the Check Configuration object type within the context given for the user interface of which includes a user in the role of customer developer. Module also would have determined that the Create operation is not to be displayed. In the absence of any visible indicia of the unavailable Create operation is indicated by the empty space enclosed within the dashed lines.

Embodiments may also for example be deployed by Software as a Service SaaS Application Service Provider ASP or utility computing providers in addition to being sold or licensed via traditional channels. The computer may be a server computer a personal computer PC a tablet PC a set top box STB a Personal Digital Assistant PDA cellular telephone or any processing device capable of executing a set of instructions sequential or otherwise that specify actions to be taken by that device. Further while only a single computer is illustrated the term computer shall also be taken to include any collection of computers that individually or jointly execute a set or multiple sets of instructions to perform any one or more of the methodologies discussed herein.

The example computer processing system includes processor e.g. a central processing unit CPU a graphics processing unit GPU or both main memory and static memory which communicate with each other via bus . The processing system may further include video display unit e.g. a plasma display a liquid crystal display LCD or a cathode ray tube CRT . The processing system also includes alphanumeric input device e.g. a keyboard a user interface UI navigation device e.g. a mouse touch screen or the like a mass storage disk drive unit a signal generation device e.g. a speaker and a network interface device .

The disk drive unit includes computer readable medium on which is stored one or more sets of instructions and data structures e.g. software embodying or utilized by any one or more of the methodologies or functions described herein. The software may also reside completely or at least partially within the main memory and or within the processor during execution thereof by the processing system the main memory and the processor also constituting computer readable tangible media.

Object types database may be stored persistently in mass storage for example. Context information can be saved in main memory for example. Program code corresponding to processes of FIGS. and may be encoded in main memory when the processes run on processor for example.

The software may further be transmitted or received over network via a network interface device utilizing any one of a number of well known transfer protocols e.g. HTTP .

While the computer readable medium is shown in an example embodiment to be a single medium the term computer readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term computer readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the computer and that cause the computer to perform any one or more of the methodologies of the present application or that is capable of storing encoding or carrying data structures utilized by or associated with such a set of instructions. The term computer readable medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media.

While the invention s is are described with reference to various implementations and exploitations it will be understood that these embodiments are illustrative and that the scope of the invention s is not limited to them. In general techniques for maintaining consistency between data structures may be implemented with facilities consistent with any hardware system or hardware systems defined herein. Many variations modifications additions and improvements are possible.

Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention s . In general structures and functionality presented as separate components in the exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements fall within the scope of the invention s .

