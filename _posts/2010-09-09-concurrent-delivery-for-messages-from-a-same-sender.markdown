---

title: Concurrent delivery for messages from a same sender
abstract: An apparatus and a method for processing messages. A transport protocol stack receives messages from senders. The transport protocol stack comprises a concurrent stack having an out of band thread pool and a non-out of band thread pool. A channel is formed with a thread from the non-out of band thread pool of the concurrent stack for each sender. Non-out of band messages are processed in parallel for each scope of an application with a non-out of band thread. Non-out of band messages pertains to processes of the application from a same sender. Processes from a scope of the application are unrelated to processes from another scope of the application. Non-out of band messages within a same scope are processed in a predefined order.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08782147&OS=08782147&RS=08782147
owner: Red Hat, Inc.
number: 08782147
owner_city: Raleigh
owner_country: US
publication_date: 20100909
---
Embodiments of the present invention relate to computing systems and more particularly to parallel processing of messages.

Group communication protocol designed for multicast communication may be used to communicate messages between endpoints forming a group. Communication endpoints can be processes or objects or any entity that can send and receive messages to and from a group.

Nevertheless messages from different senders are conventionally processed in a First In First Out FIFO order in a single queue. The messages are processed sequentially in the order they were sent. A bottleneck may thus be formed since every message has to wait for its turn to be processed accordingly.

Described herein is an apparatus and a method for processing messages. A transport protocol stack receives messages from senders. In one embodiment the transport protocol stack includes a concurrent stack having an out of band OOB thread pool and a non out of band thread non OOB pool. A channel is formed with a thread from the non out of band thread pool of the concurrent stack for each sender. Non out of band messages are processed in parallel for each scope of an application with a non out of band thread. Packets marked as OOB are dispatched to the OOB thread pool. All other packets are dispatched to the regular non OOB thread pool. OOB packets are processed independently from non OOB packets. Non OOB messages pertains to processes of the application from a same sender. Processes from a scope of the application are unrelated to processes from another scope of the application. Non OOB messages within a same scope are processed in a predefined order.

A computer system may be for example a server a client or any other computing device configured to communicate with other computing devices. Computer system includes a processing device to generate processes from an application . Processing device represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processing device may be complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor or processor implementing other instruction sets or processors implementing a combination of instruction sets. Processing device may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. Processing device is configured to generate processes for performing the operations and steps discussed herein with. In one embodiment application may be include hardware or software or a combination of both. In another embodiment a storage device stores program instructions corresponding to application executable by processing device .

The processes can join a group send messages to all members or single members and receive messages from members in the group. Computer system keeps track of the members in every group and notifies group members when a new member joins or an existing member leaves or crashes.

A group can be identified by its name. Groups do not have to be created explicitly when a process joins a non existing group that group will be created automatically. Member processes of a group can be located on the same host computing system within the same LAN Local Area Network or across a WAN Wireless Area Network . A member can be part of multiple groups.

The group communication architecture may be composed of three parts 1 a channel API used by application programmers to build reliable group communication applications 2 building blocks which are layered on top of channel and provide a higher abstraction level and 3 a protocol stack which implements the properties specified for a given channel. In one embodiment a network interface comprises the protocol stack . Processing device communicates messages to network interface .

Network interface provides an interface between processing device and network . In one embodiment network interface comprises a protocol stack .

Whenever application sends a message channel passes the message on to protocol stack that comprises several protocol modules . The topmost protocol processes the message and the passes it on to the protocol below it. Thus the message is handed from protocol to protocol until the bottom protocol puts it on the network . The same happens in the reverse direction the bottom transport protocol listens for messages on network . When a message is received it will be handed up protocol stack until it reaches channel . Channel stores the message in a queue until application processes the message.

When application connects to channel protocol stack will be started and when it disconnects protocol stack will be stopped. When channel is closed the corresponding protocol stack will be destroyed releasing its resources.

To join a group and send messages a process has to create a channel and connect to it using the group name all channels with the same name form a group . Channel is the handle to the group. While connected a member may send and receive messages to from all other group members. The client leaves a group by disconnecting from the channel. A channel can be reused clients can connect to it again after having disconnected. However a channel may allow only one client to be connected at a time. If multiple groups are to be joined multiple channels can be created and connected to. A client signals that it no longer wants to use a channel by closing it. After this operation the channel may not be used any longer.

Each channel has a unique address. As such channels can know who the other members are in the same group a list of member addresses can be retrieved from any channel. This list is called a view. A process can select an address from this list and send a unicast message to it also to itself or it may send a multicast message to all members of the current view. Whenever a process joins or leaves a group or when a crashed process has been detected a new view is sent to all remaining group members. When a member process is suspected of having crashed a suspicion message is received by all non faulty members. Thus channels receive regular messages view messages and suspicion messages. A client may choose to turn reception of views and suspicions on off on a channel basis.

A listener callback can be registered with Channel . Whenever a message is received that callback receive is called.

Channel may be implemented over a number of alternatives for group transport. Therefore a channel is an abstract class and concrete implementations are derived from it e.g. a channel implementation using its own protocol stack or others using existing group transports such as Jchannel. Applications only deal with the abstract channel class and the actual implementation can be chosen at startup time.

In one embodiment the properties for a channel may be specified in a colon delimited string format. When creating a channel JChannel a protocol stack will be created according to these properties. All messages will pass through this stack ensuring the quality of service specified by the properties string for a given channel.

Channel provides asynchronous message sending reception similar to UDP. A message sent is essentially put on network and the send method will return immediately. Conceptual requests or responses to previous requests are received in undefined order and application has to take care of matching responses with requests.

Also application can actively retrieve messages from a channel pull style it is not notified when a message has been received. Application can also have a pull style message reception that often needs another thread of execution or some form of event loop in which a channel is periodically polled for messages.

Group offers building blocks that provide more sophisticated APIs on top of a Channel. Building blocks either create and use channels internally or require an existing channel to be specified when creating a building block . Applications communicate directly with the building block rather than channel . Building blocks are intended to save the application programmer from having to write tedious and recurring code e.g. request response correlation.

In one embodiment JGroups provides its own channel based on a Java protocol stack. This protocol stack may contain a number of protocol layers in a bidirectional list. As illustrated in protocol stack can include the following procotols CAUSAL GMS MERGE FRAG UDP .

All messages sent and received over the channel have to pass through protocol stack . Every layer may modify reorder pass or drop a message or add a header to a message. For example a fragmentation layer might break up a message into several smaller messages adding a header with an id to each fragment and re assemble the fragments on the receiver s side.

The composition of protocol stack i.e. its layers is determined by the creator of the channel a property string defines the layers to be used and the parameters for each layer . This string might be interpreted differently by each channel implementation in JChannel it is used to create the stack depending on the protocol names given in the property.

Knowledge about protocol stack is not necessary when only using channels in application . However when application wishes to ignore the default properties for protocol stack and configure their own stack then knowledge about what the individual layers are supposed to do is needed. Although it is possible to stack any layer on top of each other they all have the same interface this does not make sense semantically in most cases.

Data is sent between members in the form of messages. A message can be sent by a member to a single member or to all members of the group of which the channel is an endpoint. illustrates an example of a structure of a message . In one embodiment message may contain five fields headers destination address source address flags and payload .

A list of headers can be attached to a message. Anything that should not be in the payload can be attached to message as a header. Methods putHeader getHeader and removeHeader of message can be used to manipulate headers .

Destination address may include the address of the receiver. If null the message will be sent to all current group members.

Source address may include the address of a sender. It can be left null and will be filled in by the transport protocol e.g. UDP before the message is put on the network .

Payload may include the actual data as a byte buffer . The message class contains convenience methods to set a serializable object and to retrieve it again using serialization to convert the object to from a byte buffer.

Message may be similar to an IP packet and consists of the payload a byte buffer and the addresses of the sender and receiver as addresses . Any message put on the network can be routed to its destination receiver address and replies can be returned to the sender s address.

A message does not need to fill in the sender s address when sending a message this is done automatically by the protocol stack before a message is put on the network. However there may be cases when the sender of a message wants to give an address different from its own so that for example a response should be returned to some other member.

The destination address receiver can be an Address denoting the address of a member determined e.g. from a message received previously or it can be null which means that the message will be sent to all members of the group. A typical multicast message sending string Hello to all members would look like this 

When a channel is first created at it is in the unconnected state . An attempt to perform certain operations which are only valid in the connected state e.g. send receive messages will result in an exception. After a successful connection by a client it moves to the connected state . Now channels will receive messages views and suspicions from other members and may send messages to other members or to the group. Getting the local address of a channel is guaranteed to be a valid operation in this state see below . When the channel is disconnected it moves back to the unconnected state . Both a connected and unconnected channel may be closed which makes the channel unusable for further operations. Any attempt to do so will result in an exception. When a channel is closed directly from a connected state it will first be disconnected and then closed.

Concurrent stack consists of two thread pools an out of band OOB thread pool and a non OOB thread pool . Packets are received from Multicast receiver Unicast receiver or a Connection Table TCP TCP NIO . Packets marked as OOB with Message.setFlag Message.OOB are dispatched to the OOB thread pool and all other packets are dispatched to the regular non OOB thread pool . OOB packets are processed independently from non OOB packets.

When a thread pool is disabled then the thread of the caller e.g. multicast or unicast receiver threads or the ConnectionTable is used to send the message up the stack and into the application. Otherwise the packet will be processed by a thread from the thread pool which sends the message up the stack. When all current threads are busy another thread might be created up to the maximum number of threads defined. Alternatively the packet might get queued up until a thread becomes available.

The advantage of using a thread pool is that the receiver threads does not have to do de serialization of a message and therefore can remove packets from a socket resulting in fewer dropped packets and costly retransmission due to full buffers in sockets.

In contrast previously all messages received were processed by a single thread even if the messages were sent by different senders. For instance if sender A sent messages and and B sent message and and if A s messages were all received first then B s messages and could only be processed after messages from A were processed.

Now messages from different senders can be processed in parallel e.g. messages and from A can be processed by one thread from the thread pool and messages and from B can be processed on a different thread. As a result a speedup of almost N for a cluster of N if every node is sending messages may be obtained. The thread pool may be configured to have at least N threads.

For example in the case where an application which replicates HTTP web sessions X web session Y and web session Z at a sender . Updates to these web sessions are delivered through channel in the order in which they are performed. For example X X X Y Z Z Z Y Y and X each representing a corresponding web session update .

Previously this used to mean that update Y has to wait until updates X X and X have been delivered. If these updates take time lock acquisition or deserialization then all subsequent messages are delayed by the sum of the times taken by the messages ahead of them in the delivery order.

Also the use of OOB message to deliver messages concurrently does not guarantee that the order of updates being delivered within a thread. For example if messages X X and X are marked as OOB messages and are sent in the order X X X. Their order would be undefined since they are all marked as OOB messages. For example X could be delivered before X.

In accordance with one embodiment transport protocol stack provides for concurrent delivery messages from the same sender for each web session. Because updates to different web sessions are completely unrelated to one another they should be delivered concurrently. For instance a modification to web session X should not have any effect on web session Y and web session Z . Therefore updates to web session X web session Y and web session Z can be delivered concurrently.

In the example of web updates X Y and Z are delivered concurrently at transport protocol stack for their respective web session. Furthermore messages pertaining to a given web session are all delivered concurrently between sessions and ordered within a given web session. As such within each web session the corresponding web updates are delivered in the order they were sent e.g X X X and X for web session Y Y and Y for web session and Z Z and Z for web session . In one embodiment the group of web updates for a corresponding web session may be referred to as a scope within transport protocol stack .

A non OOB thread for channel A allows concurrent processing of web session updates W and X. In other words web session updates and operate in parallel. However within each web session the web session updates are processed in the order they are received W W W for web session W within scope and X X X for web session X within scope . As such for example X does not have to wait for W to be processed.

Similarly another non OOB thread for channel B allows concurrent processing of web session updates Y and Z. In other words web session and operate in parallel. However within each web session the web session updates are processed in the order they are received Y Y Y for web session Y within scope and Z Z Z for web session Z within scope . As such for example Z does not have to wait for Y to be processed.

In another embodiment as illustrated in non out of band messages from different senders are processed in parallel with their corresponding thread. As such messages within a scope of each web session from the same sender are processed with the corresponding thread in the order the messages are received for the corresponding web session.

As previously described messages marked as non out of band are processed with the non out of band thread pool. illustrates a flow diagram for processing OOB messages. At OOB messages are received. At a channel is formed with a thread from OOB thread pool. OOB messages marked as out of band are processed with the OOB thread pool. At in another embodiment another thread is formed when all threads from the OOB thread pool are busy. At messages marked as Out of Band are processed with the Out of Band thread pool before processing all other messages with the non out of band thread pool.

In another embodiment the network architecture of group communication illustrated in includes a storage device coupled to processing device . Storage device stores instructions for application building blocks and channel API . Storage device may include a computer readable storage memory. While the computer readable storage medium is shown in an exemplary embodiment to be a single medium the term computer readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term computer readable storage medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term computer readable storage medium shall accordingly be taken to include but not be limited to solid state memories optical and magnetic media.

In the above description numerous details are set forth. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details. In some instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the present invention.

Some portions of the detailed descriptions above are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or forming or determining or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The present invention also relates to apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. The scope of the invention should therefore be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

