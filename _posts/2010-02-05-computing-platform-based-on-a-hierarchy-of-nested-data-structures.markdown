---

title: Computing platform based on a hierarchy of nested data structures
abstract: Embodiments of the invention may provide a computing platform, a business rules engine, a method, a system, and a user interface for building a computing platform, where each is based on a hierarchy of nested data structures and an application programming interface defining functions. The functions comprise at least one function for nesting one or more data structures within the contents of an enclosing data structures such that nesting the one or more data structures within the contents of the enclosing data structures results in a hierarchy of nested data structures; at least one function for removing one or more data structures from the contents of the enclosing data structures; at least one function for retrieving one or more data structures from the contents of the enclosing data structures; and at least one function for modifying the contents of one or more data structures. Each of the functions may receive a data structures as a parameter. The functions for retrieving and removing receive a pattern as the parameter, the pattern having a head concept and nested concepts. The functions match the contents of the data structures against the pattern in a recursive manner, wherein the matching is first by the head concept and then by the zero or more nested concepts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08401992&OS=08401992&RS=08401992
owner: IT Actual, Sdn. Bhd.
number: 08401992
owner_city: Serdang, Selangor
owner_country: MY
publication_date: 20100205
---
The described embodiments relate to a computing platform rules engine user interface system and method based on a hierarchy of nested data structures and in particular to an application programming interface for use in generating a hierarchy of nested data structures the contents of which may be matched against a pattern in a recursive manner by concept.

A tuple space is a repository of tuples designed to support the associative memory paradigm commonly referred to as the Blackboard Metaphor. A tuple space coordinates producers and consumers via a publish and subscribe mechanism producers publish entries to a tuple space and consumers receive notifications of tuples matching their subscription. Implementations generally support a query by template mechanism which supports matching of entries in a space against subscriptions by concept. Tuple space query languages have been developed to support more sophisticated matching of entries against subscriptions.

A business rules engine is a matching system that finds combinations of facts in working memory that satisfy conditions within rules. A business rules engine is generally composed of a rule base or rule repository for storing rules and a working memory for storing facts and for storing partial matches of facts against rules. A commercial business rules engine will frequently support the definition of domain specific languages which allow business experts to configure and manage rules.

An expression language is the common term for a programming or scripting language within which expressions may be composed and evaluated within some context. Expression languages EL commonly have an evaluation function of the form .evaluate where is an object representation of an Expression and where is an object representation of a container within which the expression will look for and manipulate variable bindings.

In a first aspect some embodiments of the invention provide a computing platform configured as a hierarchy of nested data structures the computing platform comprising a processor and memory storing instructions the instructions being executable to configure the processor to provide an application programming interface for a data structure wherein each data structure comprises contents. The data structure is selected from the group consisting of a tuple space an object and an atomic data type. The application programming interface defines at least one function for nesting one or more data structures within the contents of an enclosing data structure such that nesting the data structures within the contents of the enclosing data structure results in a hierarchy of nested data structures at least one function for removing one or more data structures from the contents of the enclosing data structure at least one function for retrieving one or more data structures from the contents of the enclosing data structure and at least one function for modifying the contents of one or more data structures wherein each of the plurality functions receives one or more data structures as a parameter wherein the function for removing and the function for retrieving receives as the parameter a pattern defining a template for one or more data structures of interest the pattern having a head concept and zero or more nested concepts wherein the concept is an ordered list of elements identifying a concept name and structure and wherein the function for removing and the function for retrieving matches the contents of the enclosing data structure against the pattern in a recursive manner matching first by the head concept and then by the zero or more nested concepts.

The computing platform of claim wherein the function for removing and the function for retrieving are operable to return a hierarchy of nested data structures from the contents of the enclosing data structure and wherein the returned hierarchy of nested data structures can be queried using the functions defined by the application programming interface.

In another aspect some embodiments of the invention provide a business rules engine comprising a working memory wherein the working memory is implemented as a hierarchy of nested data structures a processor configured to interface with the application programming interface a rulebase comprising a plurality of rules wherein each rule is a data structure and comprises a nested data structure for storing the antecedent conditions of the rule a nested data structure for storing the consequent actions of the rule and a nested data structure for storing the state of a matching algorithm wherein in operation facts can be asserted into the working memory wherein each fact is a data structure and wherein in operation the plurality of rules operate on the facts in the working memory to generation one or more productions.

In another aspect some embodiments of the invention provide a user interface for building a computing platform based on a hierarchy of nested data structures. In another aspect some embodiments of the invention provide a method for building a computing platform based on a hierarchy of nested data structures comprising defining an application programming interface for a data structures by defining the plurality of functions as described herein nesting one or more data structures within the contents of an enclosing data structure using the application programming interface in order to generate a hierarchy of nested data structures and matching the contents of the hierarchy of nested data structures against a pattern in a recursive manner wherein the matching is first by the head concept and then by the one or more nested concepts wherein each concept is a template for a data structures.

In another aspect some embodiments of the invention provide a system for building a computing platform based on a hierarchy of nested data structures comprising at least one machine for defining an application programming interface for a tuple space by defining the plurality of functions as described herein nesting one or more data structures within the contents of an enclosing tuple space using the application programming interface in order to generate a hierarchy of nested data structures and matching the contents of the hierarchy of nested data structures against a pattern in a recursive manner wherein the matching is first by the head concept and then by the one or more nested concepts wherein each concept is a template for a data structure.

It will be appreciated that for simplicity and clarity of illustration where considered appropriate reference numerals may be repeated among the figures to indicate corresponding or analogous elements or steps. In addition numerous specific details are set forth in order to provide a thorough understanding of the exemplary embodiments described herein. However it will be understood by those of ordinary skill in the art that the embodiments described herein may be practiced without these specific details. In other instances well known methods procedures and components have not been described in detail so as not to obscure the embodiments described herein. Furthermore this description is not to be considered as limiting the scope of the embodiments described herein in any way but rather as merely describing example implementations.

Embodiments of the systems and methods described herein may be implemented in hardware or software or a combination of both. For example these embodiments may be implemented in computer programs executing on programmable computers each comprising at least one processor a data storage system including volatile and non volatile memory and or storage elements at least one input device and at least one output device. For example and without limitation the programmable computers may be a mainframe computer server personal computer laptop personal data assistant or cellular telephone. Program code is applied to input data to perform the functions described herein and generate output information. The output information is applied to one or more output devices in known fashion.

Each program is preferably implemented in a high level procedural or object oriented programming and or scripting language to communicate with a computer system. However the programs can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language. Each such computer program is preferably stored on a storage media or a device e.g. ROM or magnetic diskette readable by a general or special purpose programmable computer for configuring and operating the computer when the storage media or device is read by the computer to perform the method steps described herein. The inventive system may also be considered to be implemented as a computer readable storage medium configured with a computer program where the storage medium so configured causes a computer to operate in a specific and predefined manner to perform the functions described herein.

Furthermore the system processes and methods of the described embodiments are capable of being distributed in a computer program product comprising a non transitory computer readable medium that bears computer usable instructions for one or more processors. The medium may be provided in various forms including one or more diskettes compact disks tapes chips wireline transmissions satellite transmissions internet transmission or downloadings magnetic and electronic storage media digital and analog signals and the like. The computer useable instructions may also be in various forms including compiled and non compiled code.

Reference is first made to which shows a block diagram illustrating the components of a system for building a computing platform based on a hierarchy of nested data structures. The system may include wired devices and wireless devices connected via a network and communication means . The computing platform may reside on one wired device and or wireless device or multiple wired devices and or wireless devices distributed over a wide geographic area and connected via e.g. network .

Wired devices and wireless devices may be any networked computing device including a processor and memory such as a personal computer workstation server portable computer mobile phone personal digital assistant laptop smart phone satellite phone WAP phone embedded device or system or a combination of these. Wired devices and wireless devices may include a software application application plug in e.g. a widget instant messaging application mobile device application e mail application online telephony application java application web page or web object e.g. a widget residing or rendered on wired devices and wireless devices in order to access the computing platform directly or via network . Wired devices and wireless devices will be described in more detail herein in relation to .

Network may be any network capable of carrying data and communicating with wired devices and or wireless devices including the Internet Ethernet plain old telephone service POTS line public switch telephone network PSTN integrated services digital network ISDN digital subscriber line DSL coaxial cable fiber optics satellite mobile wireless e.g. Wi F1 WiMAX SS7 signaling network fixed line local area network wide area network and others including any combination of these. Network is any network capable of interfacing with and enabling communication between wired devices and or wireless devices . For example network may include a mobile network implemented using various mobile communication standards such as for example GSM or CDMA and may be integrated with other networks employing various protocols such as a public switch telephone network PSTN .

Communication means allows for wireless communication between network and wireless devices such as a wireless transceiver or tower for example. While only one network and communication means is shown multiple networks and communication means may be distributed over a geographical area in order to enable communication between wired devices and or wireless devices .

Wired devices and or wireless devices may be connected to a persistent store for providing a means for persisting the configuration of a hierarchy of nested tuple spaces. As an illustrative example only one persistent store is shown connected to a wired device however system may include multiple persistent stores connected to multiple devices. The persistent store may be implemented using a server system comprising one or more servers with computing processing abilities and memory such as database s or file system s . For example this may include a mail server web server and database server.

Reference is now made to which shows a block diagram illustrating the components of a wired and or wireless device in further detail.

In an exemplary embodiment wired devices and or wireless devices have associated with them a display an input device a memory store a central processing unit a network interface and one or more optional peripheral devices . The input devices may be any device that allows for input examples of which may include but are not limited to keyboards microphones speakers and pointing devices. The memory store is a permanent storage associated with the device . In one embodiment the memory store may store an instance of the computing platform or a portion thereof and may also provide a means for persisting the configuration of the hierarchy of nested tuple spaces. The central processing unit is used to execute instructions for operation of wired devices and or wireless devices and may exist as a configuration of multiple CPU s. The network interface may be a wired and or wireless network interface that allows the device to connect to the network . The peripheral devices may include but are not limited to devices such as printers antenna transceivers and scanners.

The wired devices and or wireless devices are configured to provide a core library with an application programming interface event model observer component rules engine expression language user interface and ontology component representing concepts. The wired devices and or wireless devices are further configured with a runtime library implementing the application programming interface on the host operating system to interact with the memory store the central processing unit etc. An executable image links the core library user interface library and runtime library into an executable format suitable for the host operating system . The instructions of the executable are configured to examine the wired devices and or wireless devices for configuration resources which may define concepts recognizable to the core library and or user interface and which may include the persistent state of a working hierarchy of nested data structures retained from a previous session.

A user may access the core library by providing the components on the wired devices and or wireless devices or by providing access to the components on a remote server via network. On start up the components of the core library the application programming interface event model observer component rules engine expression language user interface and ontology component are loaded into memory .

The user interface provides a visualization of the hierarchy of data structures on the display . The display is a monitor type device that is used to display information such as a graphical user interface. The user interface may be configured to provide a display adapter user interface adapter library resource adapter to interact with the memory store and central processing unit and a registry of view definitions for rendering patterns and concepts. The registry may be configured as a data structure such as a tuple space. The user interface will track changes to the underlying hierarchy of data structures using the event model . The user interface representation of the hierarchy of spaces may include representations of forms links menus images videos sound clips rules and other concepts from business domains of interest to the user.

As the user interacts with the user interface it operates to configure the underlying hierarchy of data structures in memory . This in combination with the ontology component event model observer component expression language and rules engine may have the effect of causing the user interface component to add remove or modify user interface representations of the hierarchy.

Reference is now made to which illustrates a flow diagram of a method for building a computing platform based on a hierarchy of nested data structures.

At step system defines an application programming interface for a data structure. Generally an application programming interface is a set of functions routines data structures classes and or protocols provided by one or more libraries in order to support the building of applications. The application programming interface for a data structure may define the following functions a one or more functions for nesting one or more data structure within the contents of an enclosing data structure b one or more functions for removing one or more data structure from the contents of an enclosing data structure c one or more functions for retrieving one or more data structure from the contents of an enclosing data structure and d one or more functions for modifying the contents of one or more data structure.

By way of illustrative example the application programming interface for a data structure may define the functions as 

Each function of the application programming interface receives a parameter. The parameter is a pattern that defines a head concept and in some instances nested concepts. A concept is a tuple or ordered list of elements in which the first element identifies a concept name and subsequent elements represent the body structure of the concept. The ontology component defines the relationships between concepts. For example the ontology component may define a link between two concepts such that concept A is a concept B. The link would define the concept membership set of concept A to include the concept membership set of concept B. The ontology component is a common repository shared by the resources on the device .

The hierarchy is built of data structures such as tuple spaces objects atomic data types and the like. The data structure is conceptually a collection or container for other spaces that the system may interact with using the application programming interface. The system may query and manipulate the contents of the data structure using the application programming interface.

For illustrative purposes the data structure will be described herein as a tuple space. The system may query and manipulate the contents of the tuple space using the application programming interface based on the query by template mechanism supported by tuple spaces. The system may implement the data structure natively as a tuple space or it may be an object or atomic data type that is mapped to the application programming interface of a tuple space. For example the system can map object to the application programming interface of a tuple space by using the object attributes as concepts or patterns associated with tuple spaces. For example the system can map an atomic data type to the application programming interface of a tuple space by using an abstract representation of the atomic data type as the concepts or patterns associated with tuple spaces.

By way of background reference is now made to which shows a block diagram illustrating the components of an example tuple space . As noted above tuple spaces are generally designed to coordinate producers and consumers using a publish subscribe model in which producers and consumers interact using data structures which represent concepts within an Ontology commonly understood by the interacting parties.

Producers interact with a tuple space by putting tuples therein using the functions of an application programming interface. For example a trading desk producer may put a trade tuple in the tuple space and a shipping desk producer may put an order tuple in the tuple space .

Consumers interact with the tuple space by querying the tuple space or by subscribing on the tuple space for notifications of tuples matching a specific pattern. For example an order fulfillment service consumer subscribes for notifications of order tuples matching a specific pattern and a trade execution service consumer subscribes for notifications of trade tuples matching a specific pattern.

The tuple space functions as middleware by matching the tuples put into the tuple space by producers against the specific patterns of tuples subscribed by consumers 

Tuple space implementations generally support matching by concept and super concept. For example a concept for a tuple may be employee and a super concept may be person where an employee is defined to be a type of person. Consumers subscribing for notifications of new person tuples put into a tuple space will be notified of new employee tuples.

Tuple space implementations generally support queries and notifications using templates which describe a single concept. Referring to the above example an order fulfillment service consumer only receives notifications of order tuples and a trade execution service consumer only receives notifications of trade tuples . Tuple Space implementations do not typically support a consumer subscribing for notifications of trade tuples and order tuples that are related by an attribute as each tuple is of a different concept. As will be explained herein embodiments of the present invention support correlation of spaces describing multiple concepts.

Referring back to at step system nests one or more tuple spaces within the contents of an enclosing tuple space using the application programming interface in order to generate a hierarchy of nested tuple spaces.

Reference is now made to which shows a block diagram illustrating an example hierarchy of nested tuple spaces according to an embodiment of the present invention.

An enclosing tuple space forms part of the hierarchy of nested tuple spaces and provides a container for the nested tuple spaces and . The contents of the enclosing tuple space may provide additional hierarchies of nested tuple spaces. For example an enclosing tuple space provides a container for nested tuples spaces . The persistent store provides a means for persisting the configuration of the hierarchy of nested tuple spaces. The arrows illustrate inter space interactions. This may have the effect of forwarding notifications between spaces. For example system may provide for inter space interactions by nesting one or more observers into an enclosing space. As another example system may nest rules into an enclosing space. Observers and rules are tuple spaces and manipulated using the application programming interface. System uses rules and observers to cause movement of facts and tuple spaces from one space into another.

At step system interacts with the hierarchy of nested tuple spaces and matches the contents of the hierarchy against a pattern in a recursive manner. The matching is first by the head concept and then by the plurality of nested concepts where as noted above each concept is a template for a tuple space. System may repeat step multiple times in order to interact with the hierarchy by calling the functions of the application programming interface.

Reference is now made to which is a flow diagram of another method for building a computing platform based on a hierarchy of nested tuple spaces according to embodiments of the present invention

At step system defines an application programming interface for a tuple space as explained above in relation to at step . The application programming interface may include a wide range of functions and may be implemented with a programming language. System uses the application programming interface to generate and interact with a hierarchy of nested tuple spaces.

The application programming interface defines a space as a universal data model to provide a container or memory store for a configuration of the hierarchy of nested tuple spaces. Embodiments of the present invention do not distinguish between the class or implementation of the container a tuple space containing the hierarchy of nested tuple spaces and entries tuple spaces within the container. The container and entries within the container are both of the root concept space as will be explained.

At steps to system configures the ontology component . As noted above the tuple space data structure supports a query by template algorithm in which tuples in a space are matched against a pattern or template first by head concept and then by nested concepts. System configures an ontology component to define a common representation of concepts and relationships between concepts to facilitate the pattern matching. There are several ways to implement the ontology component common to system as will be explained herein. In order to implement the ontology component system will associate the pattern defined by the data structures or tuple spaces of the system with one or more concepts e.g. a tuple or ordered list of elements or a Class within an object oriented implementation language .

At step system defines a concept membership set for each tuple space in the hierarchy of nested tuple spaces. A concept membership set is a tuple or ordered list of elements consisting of the concepts that the tuple space is a member of. The concept membership set of a given space may comprise a plurality of concepts as will be explained in relation to steps and .

At step system defines a root concept for each tuple space where the root concept is the most generalized i.e. least specialized concept of the concept membership set. In accordance with embodiments of the present invention the root concept for a tuple space is tuple space or more generally space . System uses the query by template mechanism common to tuple spaces to query an arbitrary space over its entire contents by providing the pattern space to a function of the application programming interface. That is system may query a tuple space for its entire contents by providing the pattern for the root concept tuple space as a function parameter getMultiple for example .

At step system defines a head concept for each tuple space where the head concept is the most specialized concept of the concept membership set for the tuple space. The head concept and the root concept form part of the concept membership set for each tuple space. In some instances the head concept and the root concept may both be space and the concept membership set for the tuple space will be space .

By way of illustrative example a space may consist of the single character 1 which has the head concept 1 the root concept space and the concept membership set 1 integer number space . Similarly a space consisting of the character sequence 1 2 has the head concept 1 2 the root concept space and the concept membership set 1 2 rational number number space . A space consisting of the character sequence I love new york is associated with the concept membership set I love new york string space .

A space may be comprised of a sequence of other spaces or complex spaces. For example a space may include a sequence of nested spaces to define a date of birth. A date of birth includes a day space a month space and a year space. A date of birth has the head concept dob and the concept membership set dob date space .

System may reference concepts by name such as identifier day month and year for example with namespace prefixes in order to differentiate similarly named concepts in multiple domains. Using namespace prefixes provides system with ability to differentiate between similarly named concepts in different domains.

Concepts may be organized or grouped into various vocabularies such that each vocabulary contains one or more concepts. A namespace may be used to reference a vocabulary of concepts. System may use a namespace as a means of differentiating similarly named concepts from distinct vocabularies.

The system may implement the ontology implicitly by assigning the patterns or templates defined by each data structure or tuple space to a concept membership set which includes the head concept of the pattern and the concept space i.e. the broadest concept of system . This method does not require a centralized agreement of the common ontology between the components of system . However the matching of tuples within spaces may be limited to the head concept of the pattern or the root concept space .

The system may implement the ontology component explicitly and declaratively by configuring an ontology registry that defines is a and has a relationships between concepts of interest to system . Referring back to at step system configures the ontology registry by defining the is a relationships between concepts within the ontology component which supports the definition of superclass subclass relationships between concepts and provides a mechanism to define concepts and relationships among concepts. This approach is similar to that taken by object oriented frameworks in which the ontology component is statically defined in the form of precompiled classes. The system may further configure the ontology registry to define has a relationships between concepts.

As another approach the system may implement the ontology component by inferring is a relationships between concepts dynamically by matching patterns against templates of concepts in an ontology registry. For example to determine if a pattern matches a person concept the system would lookup the person concept in the ontology registry and match the person concept against the pattern of interest. This approach is similar to that used in Semantic Web technologies in which is a relationships are inferred via production rules.

Referring now to there is shown a block diagram illustrating a portion of an ontology component defining the structure of concepts and relationships between concepts within a domain of discourse. In this example the ontology component defines a person concept which includes first name last name SSN date of birth and a sex each being a space representative of a concept. The configuration for the space is maintained within the ontology component as a hierarchy of nested tuple spaces. Similarly contractor concept defines rate and term nested concepts and is declared to be a is a person by virtue of the UML generalization relationship between components and in the diagram. Similarly an employee concept defines an emplid and title space which is also declared to be a is a person by virtue of the UMI generalization relationship between concepts and . Within this ontology component the concept membership set for a contractor concept would be reported as contractor person space by an application programming interface designed to compute the concept membership set similarly the concept membership set of an employee concept would be reported as employee person space by an application programming interface designed to compute concept membership set.

The system may include instructions in memory to configure the processor to provide an application programming interface for the ontology component to include one or more function for computing and returning the concept membership set of a specific tuple space. The application programming interface may further include functions for determining and returning the head concept and the root concept of a specific tuple space. The concept membership set the root concept and the head concept returned by the functions are each a tuple space.

Referring back to at step system provides a means of persisting the configuration of the hierarchy of nested tuple spaces e.g. persistent means or .

The application programming interface may include a function for serializing the hierarchy of nested tuple spaces to an intermediate form and from the intermediate form while preserving the configuration the tuple space. This intermediate form may be XML or some other representation.

The application programming interface may include a function for transforming an object form of the hierarchy of nested tuple spaces into a secondary representation e.g. XML suitable for transmission over a network and a function for transmitting the secondary representation over a network. The secondary representation may also be suitable for storage. The application programming interface may further include a function for creating a copy of the hierarchy of nested tuple spaces.

When reconstituted from a secondary representation the configuration will be fully intact including all content and behavior. The configuration may include the partial state of the network implementing the match algorithm for any production rules which may be present in any hierarchically nested space within the space that was serialized.

System takes advantage of the data model tuple space so that an algorithm can transform the object form of a hierarchy of spaces into a 2D representation. A complementary algorithm can transform the 2D representation back into the object form. XML JSON or Lisp Scheme syntax may be used for example.

Referring to at step system integrates an expression language with the application programming interface of a tuple space in order to support more flexible queries. The expression language has an evaluation context that is a tuple space and includes functions and or procedures each of which are themselves tuple spaces. The expression language is for use in evaluating expressions within tuple spaces and the application programming interface provides a means for evaluating expressions within the context of a particular tuple space.

Typically the tuple space query by template mechanism supports equality based existential qualification. The behavior of the existential qualification algorithm is outlined in the table below.

The following is an outline of one possible implementation of the match algorithm in accordance with embodiments of the present invention 

This match algorithm supports the pattern oriented query by template functionality commonly implemented in tuple spaces however it supports equality comparisons only. In order to provide more sophisticated matching capabilities e.g. person tuples having age in the range 30 and 40 a more sophisticated query mechanism is implemented by system .

Expression languages generally have an evaluation function of the form .evaluate where is an object representation of an Expression and where is an object representation of a container within which expression objects look for and manipulate variable bindings.

For example the expression x a b evaluated in the context represented by the set a 1 b 2 produces a binding for x in the modified context based on the bindings for a and b that it finds in that context. The resulting modified context becomes x 3 a 1 b 2 . A similar expression evaluated in the context a 5 b 10 produces the modified context x 15 a 5 b 10 .

Expression languages typically distinguish between the type or class of the expression and the type or class of the evaluation context. For example in implementations of the JavaScript language a scope object acts as a context for expression evaluation and the two objects have disjoint type. A context is essentially a generic container with get put take application programming interfaces like a tuple space whereas an expression is generally not regarded in this manner. Similarly in implementations of the Scheme and Lisp programming languages there is a distinction between an Environment or a Closure which are analogous to a context in JavaScript and between the various objects that make up the object model for expressions including Pairs Symbols and Atoms.

Some embodiments of the present invention treat the concept of an expression and the concept of an evaluation context as having a common superclass i.e. both are kinds of collections that may be queried by template and share the same super class space and tuple space application programming interface . In this embodiment an expression is a kind of tuple space constructed using the put get take application programming interface in the same manner as any other tuple space and in this embodiment a tuple space is also the evaluation context for expressions. This is convenient as expressions can participate in the query by template aspect of the tuple space expressions can be found by template within a space and expressions within a concept can be used as directives for the matching algorithm.

In this embodiment the Expression Language integrated with the Tuple Space uses an evaluate function of the general form Space.evaluate Space context which receives as parameter a space representing the evaluation context variants of this form may include additional parameters for example to support correlation within rules. Alternate embodiments may separate the implementation of the Expression Language from that of the tuple space however the key characteristic of the integration of the tuple space and expression language is that Expressions are kinds of Spaces which may be nested within spaces and which operate on context objects which are themselves kinds of Spaces. A Function library defines various procedures for comparing and manipulating data via the tuple space application programming interface. Integration with this form of the embodiment requires changes to the match algorithm as outlined below 

If a given portion of a pattern does not have a direct counterpart in the tuple space under consideration in this embodiment then the portion of the pattern that failed to match is evaluated as an expression in the context of the tuple space under consideration. In one embodiment if the evaluation returns a particular value for example true or nil then evaluation succeeds and the nested portion of the pattern is considered to match the tuple under consideration. Other embodiments of the present invention may further direct the matching algorithm as to whether a nested Space within a pattern not contained within the enclosing Space should be treated as an expression or not other embodiments may further direct the matching algorithm to allow or prevent a given tuple from matching on more than one corresponding tuple in the pattern etc.

The configuration of the tuple space coupled with the complementary expression language where a tuple space is the native evaluation context and where an expression is a tuple space is advantageous in that it allows the query by template aspect of the tuple space to support much more flexible matching. Features which rely on the core pattern matching capability e.g. observers and conditions within rules inherit the benefit of expression oriented matching and expressions can themselves be content for spaces or queries.

Referring back to at step system provides an application programming interface for deriving a contextual hierarchical address for each tuple space. Each hierarchical address may be unique. The application programming interface provides a function for returning a hierarchical address of a tuple space within the hierarchy of nested tuple spaces.

System supports query and traversal of the ancestor axis of the hierarchy of spaces by defining parenting functions in the application programming interface. For example 

At step system associates a unique identifier with each tuple space. The identifier is an address of the tuple space within an enclosing tuple space where the address is unique between two or more tuple spaces of the same concept or same head concept. In some embodiments of the present invention when the data structure is an atomic data type the system will use the atomic data type as the identifier.

System supports hierarchical addressing of spaces with potentially the same head concept using the identifier. The application programming interface may include 

At step system configures an event model such that in operation the functions of the application programming interface for the data structure e.g. tuple space generate one or more events within an enclosing tuple space describing a query or change in contents of the enclosing tuple space.

System may implement a two phase event model . The type of change may be one of two phases a pre phase for queries or changes that are about to occur in the contents and a post phase for queries or changes that have occurred in the contents.

At step system implements an observer component to define observers. Each observer identifies one or more application programming interface functions of interest and a pattern describing a configuration of a tuple space of interest. For example an observer may provide a configuration of nested spaces defining a pattern of interest application programming interfaces of interest an order of interest and a reference to the space that is to be notified by system . In another embodiment of the invention an observer of multiple correlated concepts can be composed via a rule which looks for some combination of concepts in a space and generates a notification of the occurrence of such combination.

System is operable to nests one or more observers within tuples spaces of the hierarchy of nested tuple spaces such that each observer forms part of the contents of an enclosing tuple space. Each active observer monitors its enclosing tuple space for one or more events associated with the pattern. This allows system to observe any space for events pertaining to an appropriately configured observer therein.

Each observer is a tuple space and system may interact with an observer using the application programming interface for a tuple space. For example system may nest an observer within the contents of an enclosing space using the function put . An observer may invoke a call back handler for providing a notification to subject space when the pattern and function of interest defined by the observer are detected within the tuple space.

Observers observe a subject space for patterns of information appearing or disappearing from the subject space on behalf of the client and notify client data structures when the desired pattern appears in the observed space. Client data structures are described by a hierarchical address which is resolved at the time of notification and which may represent an in memory or out of memory data structure. If the client is in memory the notification will be issued to the client directly via application programming interface invocation if the data structure is out of memory the notification will attempt to use information e.g. protocol host port address contained in the hierarchical address to contact the client data structure. Example protocols include http https ftp and webdav.among others.

System may enable or disable an observer i.e. active or inactive . The status of an observer survives a persistence cycle such that a space with an enabled observer nested therein can be serialized into memory e.g. object form and will retain its enabled status and function. A space that encloses an enabled observer generates events. Observers may also support a recursive mode in which an observer elects to receive events on a matching application programming interface an order and a pattern occurring in any child space. All spaces that are children of the observed space also generate events.

Referring back to at step system implements an event model and propagates events e.g. changes in a space resulting from get put take modify operations to interested observers or tuple spaces. That is system propagates events to active observers of the tuple space where the change in contents originated and then to one or more active observers in one or more enclosing tuple spaces via an application programming interface

In order to propagate events the application programming interface may provide a function for notifying one or more enclosing tuple spaces of a change in the contents of a nested tuple space.

In accordance with some embodiments of the present invention in operation the function for notifying 

System may notify observers only if the event subject order api matches the observer pattern order api.

The function of the two phase event cycle is to permit a change to be blocked by some observer who may wish to object during the pre phase.

For example the pre phase of the event model allows changes to be vetoed by an observer of a space which has the effect of disallowing the change and propagating an exception to the invoker of the application programming interface originating the change.

The post phase of the event model propagates changes to an observer or space at the completion of the change. In each case pre and post application programming interface events propagate in the same manner from the subject space in which some action has occurred outwards to enclosing spaces on the ancestor axis via the parent concept and in each case pre and post observers in an ancestor space are matched to the application programming interface invocation order and subject space using the tuple space matching algorithm which matches the observer pattern and subject by concept and nested concepts not just by the head concept.

In each phase the event model includes a before and after state of the tuple space which is the subject of the application programming interface invocation. The before and after states for each pre phase and the post phase propagate to the enclosing spaces with the event. To optimize the generation of before and after state propagation within the event model embodiments of the invention may utilize a technique by which both states before and after exist simultaneously as a superposition of states within a hierarchy of tuple spaces and the particular state desired for matching is provided as an argument to the matching algorithm application programming interface or derived by other means within the matching api.

For example in operation the function for notifying may first notify the tuple space that is the subject of the change and then notify one or more tuple spaces that are ancestors in the hierarchy of nested tuple spaces.

At step system nests one or more rules within one or more tuple spaces such that each rule forms part of the contents of an enclosing tuple space. System nests rules in order to configure the enclosing space. System implements rules as it does observers.

Thus a rule contains a sequence of condition patterns defining a fact of interest to the rule and a sequence of action expressions.

Nested rules may be inactive or active. System activates a rule to support reasoning or forward chaining within an enclosing tuple space When activated system creates or activates Condition objects which function as observers and begin to receive and process events that match the pattern of interest to the rule.

Each rule is a tuple space and system may interact with a rule using the application programming interface for a tuple space. Rules may find unifications of variable bindings across multiple concepts. That is system uses rules to correlate facts across multiple concepts. System supports pattern matching between facts of multiple concepts.

An example rule is a production rule. Production rules process events to generate productions within the rule each production is a binding set containing zero or more nested tuple spaces. Production rules provide a reasoning mechanism for an enclosing tuple space and when a rule is fired it applies a set of actions to the productions gathered by the Rule.

Before activation in a space the internal structure of a rule is primarily a nested space of conditions and a nested space of actions but may include additional descriptive information for example a name description author etc.

When an active rule condition receives a notification the rule causes the subject of the notification i.e. the fact that has been added removed or changed by the operation of a function to propagate through the pattern matching network e.g. RETE of the rule. This may cause productions to be added to or removed from the terminal node of the Rule or added to or removed from the matching network within the Rule.

Referring back to once notifications have been processed by rules at step system activates an agenda. The agenda implements a conflict resolution algorithm to determine the order to process generated productions.

After an operation of any function the agenda queries an enclosing tuple space for rules that have generated productions. Agenda processes each generated production in an order defined by a conflict resolution algorithm until no additional productions exist.

Firing the rules in a given space causes that space to first look for an agenda which if found is utilized failing that a predefined default agenda will be utilized.

One embodiment of a default agenda processes productions using a simple salience of rules in which rules occurring in a space first are considered to be of higher salience and processed first. In this embodiment of a default agenda the salience of a rule may be increased or decreased by simply moving the rule forward or backward within the sequence defined by the enclosing space.

In some embodiments the default agenda may be replaced by defining a custom agenda as a kind of space and putting it into a space. System may interact with a custom agenda using the tuple space application programming interfaces.

Using rules system may configure a wide range of behaviors including data access control data domain and range constraints forward or backward chained reasoning data validation data transformation data migration from one space to another under the control of expressions driven by rules.

For example system may provide a business rules engine . A business rules engine is a production matching system that supports pattern matching between facts and production rules.

System makes no distinction between the type or class of the rulebase and the type or class of facts or rules within the rule base. The rule base is a tuple space and facts and rules are also tuple spaces. The working memory is also a tuple space. In this configuration rules may be queried by template using the application programming interface of the tuple space. A rule is of the same type or kind as a fact. System can reason about rules and rules may be conditions for other rules.

The business rules engine implements a matching algorithm for matching facts to rules. The matching algorithm may be the RETE algorithm for example. Condition nodes may be nested into an enclosing space and implement the type select alpha memory portions of the RETE network. System forwards matching facts to production rules and implements the beta portions of the RETE network in the form of join and terminal nodes.

In operation system asserts facts into the working memory. Production rules operate on the facts in the working memory to generate one or more productions.

System may support unification of facts against rules by implementing one or more production matching algorithms. The matching algorithm is implemented as a network which includes nodes for intra fact tests an alpha memory nodes for inter fact correlations across two concepts a beta memory and Terminal nodes which hold productions for facts which have passed all intra and inter fact tests for some Rule.

Example matching algorithms include RETE TREAT and LEAPS. The algorithm generally attempts to minimize the number of comparisons that must be incrementally evaluated when the working memory is modified by the assertion or retraction or modification of rules or facts in the business rules engine .

Referring now to there is shown a block diagram illustrating the components of an example pattern matching network. As an example a RETE network is shown.

Facts enter the working memory and into the RETE network . Facts are categorized by type nodes and traverse through a series of select nodes which perform intra fact tests. These do not require correlation with other facts and instead the fact is compared against constants or expressions within the fact. Facts passing all intra fact tests enter an alpha memory and are fed into the top of the beta network.

The beta network is responsible for performing inter fact correlations or unifications. Each join node finds a unification of bindings across two concepts. The network of join nodes and beta memories represent facts which have matched some of the inter fact correlations specified by a set of production rules . Facts which pass all intra and inter fact tests enter a terminal node as binding sets or productions . An agenda operates on one or more productions generated by the production rules .

Given that the pattern matching aspect of a tuple space pertains to a single concept then it is clear that tuple space oriented matching can support only the alpha portion of the RETE network therefore in order to support the kind of inter concept correlations required for production matching the system provides additional application programming interfaces and logic to support the beta portion of the RETE network and inter fact unification as well.

In accordance with other embodiments of the present invention rules may be another form of rule other than production rules. System may treat rules having only have one when clause as if then style event condition action rules rather than production rules. These rules are supported by a simplified matching network consisting of only a condition and a terminal rather than by a network of condition join and terminal nodes. A rule with only one when clause has only one concept of interest and therefore may not require correlation among multiple facts and system is not required to implement a join network and alpha beta memory but is still governed by an agenda.

Reference is now made to which is a UML package and class diagram representation of one embodiment of the present invention. Package core contains representations of key concepts of the invention in class form and may include the following classes 

Package event contains class definitions supporting events and observers and may include the following classes 

In accordance with other embodiments of the present invention system provides a user interface for building software applications based on a hierarchy of nested tuple spaces where the user interface provides a presentation layer for the application programming interface of a tuple space.

Reference is now made to which illustrates a graphical user interface integrated with the application programming interface for a tuple space for building a computing platform based on a hierarchy of nested tuple spaces in accordance with embodiments of the present invention.

Embodiments of the invention support integration of a graphical user interface by associating tuple spaces within a hierarchy of tuple spaces to user interface elements within a hierarchy of user interface elements . A display adapter may display user interface elements using a user interface adapter library specialized for one or more interface technologies such as HTML SVG JavaFx Java2D or Java3D or VoiceXML for example.

The user interface adapter library may transform a plurality of primitive user interface markup concepts for example size x and y position color border font transparency editable pickable and scale concepts onto technology specific application programming interfaces. In this configuration user interface markup concepts within a hierarchy of tuple spaces are rendered in a hierarchical fashion to an associated display device while preserving the semantics of the markup.

For example the space has the head concept TEXT and nested concepts editable transparency x position y position and model. The user interface adapter library uses these concepts to guide the rendering of the associated user interface element i.e. TEXT widget such that the visual representation is that of an editable text box having the x position y position transparency and model concepts specified by the backing space .

As another example the space contains a border concept with nested border width concepts and border color concepts and is generically rendered to the effect of defining a group .

The user interface adapter library may support various intrinsic widget concepts including text lists drop lists images and buttons for example. For example user interface element is a drop list of combo choices associated with space . As another example user interface element is a button associated with space . user interface element is a text box associated with space . The widget concepts may be used to create aggregate components by composing the desired structure of spaces and annotating these with the desired primitive user interface markup core widgets and rules to tie the behavior of the widgets to the contents of the space.

The user interface adapter library may handle user interactivity such that changes originated by a user to user interface elements are reflected in the backing space. For example a user typing into the TEXT widget triggers modify application programming interface calls to the associated model which is described by the backing tuple space . This has the effect of propagating events through the enclosing spaces and . The propagation of events to enclosing spaces may potentially trigger rules within these enclosing spaces based on e.g. the configuration of pattern s in the when clause of each rule.

Rules may have the effect of adding removing or modifying data within the hierarchy of spaces visually displayed which may have the effect of adding removing or modifying widgets displayed on the user interface .

Reference is now made to which illustrates a graphical user interface development environment and User Agent i.e. user interface for a computing platform based on a hierarchy of nested tuple spaces to in accordance with embodiments of the present invention.

The User Agent includes a tree representation of hierarchical Spaces having a root space which is serialized to and from a secondary representation on disk in this embodiment using XML syntax.

The User Agent includes a 2D representation of this hierarchy of spaces which is dynamically rendered in accordance to templates residing within a Template space .

The 2D representation shows various concepts located in the desktop space rendered in 2D fashion including a graphical shortcut forms and with nested controls label edit box button image context menu activator context menu context menu item and combo box .

Components displayed within the 2D representation are associated with spaces and draw their visual rendering cues from those spaces including for example the background image and border which pertain to the viewport displayed by the 2D representation . Additional rendering cues are defined by concepts not shown including Fonts Colors Transparency visible and selectable attributes among others.

The user interface concepts outlined above are interpreted by the 2D representation to the effect that borders colors transparencies images fonts etc can be configured by the end user simply by putting the appropriate user interface concepts into the desired spaces and by adjusting the specific attributes of each and by moving the nested contents of the space in order to establish x y and z positions within the 2D representation .

The User Agent operates using a self contained Service Oriented Architecture in which Services observe a Space for patterns of interest representing requests and in response perform a service on behalf of the consumer. In this realization a copy of the ActivationService is put within the Interactions Space and thereby monitors that space for ActivationRequest concepts.

ActivationRequest concepts represent requests to copy or remove concepts from one space and into another. Such requests are processed by the ActivationService by extracting source and target concepts locating the corresponding concepts and performing the copy move delete as requested. Remote references may also be processed using a specifiable protocol.

To further elaborate on this process a user activating the shortcut causes an ActivationRequest concept to be configured with source concept Simulate Call and target concept Desktop and placed within the Interactions Space .

On receiving an ActivationReqeust the Infractions Space finds interested observer ActivationService and notifies that observer of the request.

The ActivationService responds to the notification by first removing the request from the space as is typical of the blackboard metaphor to prevent another service from duplicating the effort and by subsequently locating the desired source and target spaces and copying the source space into the target space.

As a result of the user activating the shortcut a copy of the Simulate Call space is placed in the desktop space where it is rendered by the 2D representation to the form .

Form contains a number of form elements which are dynamically rendered from a model call concept within the form space in the manner of xforms. Selecting the OK button not visible on form causes a copy of that model to be populated with form data and put into the Handle Calls Space .

The Handle Calls space is configured with rules which trigger the movement via the activation service of a Handle Call concept to the Desktop space for each instance of a ringing call concept detected and to move the call concept into the associated handle call instance. Doing so has the effect of causing the 2D representation to display and which represent distinct call instances.

Within forms and call data is bound to form elements using an xforms oriented data binding model and presented visually in form elements.

Rules within each handle call space maintain options for associated context menu by putting and taking contextMenuItem concepts from the enclosing space based on call state. for example when a call is ringing only the answer option is presented when it is ringing only the release option is presented when it is established the hold and release options are presented .

The context menu is activated by selecting an activator the menu dynamically renders whatever contextMenuItem concepts are present in its enclosing space. When a contextMenuItem is activated the process is similar to the activation process for shortcut .

Within the User Agent the tree representation and the 2D representation of the user interface are in effect different visualizations of a hierarchy of spaces and may be driven by rules which invoke only the get put take application programming interfaces of the hierarchical tuple spaces in order to effect user interface interaction business logic service invocation data modeling and abstraction.

Embodiments of the present invention provide a simple conceptual model and application programming interface for modeling and implementing software applications which may be accessible to a wider range of developers the goal being that if the conceptual framework and application programming interfaces become simple enough conceivably a layperson can become a practitioner with little training.

The present invention has been described here by way of example only. Various modification and variations may be made to these exemplary embodiments without departing from the spirit and scope of the invention which is limited only by the appended claims.

