---

title: Data store including a file location attribute
abstract: A data store including a file location attribute is described. In an embodiment, the location attribute for a data element, such as a file or database record, is stored with the bytes of data and records the geographic location of the data element. Writing to this attribute is limited to a single trusted entity, such as an operating system, to ensure that the location data can be trusted and when a data element is moved or replicated, the attribute is updated to reflect the new location of the data element. This location data is made available to users and applications by a metadata service which tracks the locations of data elements and responds to requests from users. Access control policies can been defined in terms of location and stored at the metadata service and the metadata service can then enforce these policies when responding to requests.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08656454&OS=08656454&RS=08656454
owner: Microsoft Corporation
number: 08656454
owner_city: Redmond
owner_country: US
publication_date: 20101201
---
Existing file systems store attributes which are associated with a file. These attributes may be defined by the file system such as file creation time last modification time and last access time. In addition a file system may allow attributes to be defined by an application developer such that a program can create attributes and these attributes may be referred to as extended attributes .

The embodiments described below are not limited to implementations which solve any or all of the disadvantages of known data stores.

The following presents a simplified summary of the disclosure in order to provide a basic understanding to the reader. This summary is not an extensive overview of the disclosure and it does not identify key critical elements of the invention or delineate the scope of the invention. Its sole purpose is to present some concepts disclosed herein in a simplified form as a prelude to the more detailed description that is presented later.

A data store including a file location attribute is described. In an embodiment the location attribute for a data element such as a file or database record is stored with the bytes of data and records the geographic location of the data element. Writing to this attribute is limited to a single trusted entity such as an operating system to ensure that the location data can be trusted and when a data element is moved or replicated the attribute is updated to reflect the new location of the data element. This location data is made available to users and applications by a metadata service which tracks the locations of data elements and responds to requests from users. Access control policies can been defined in terms of location and stored at the metadata service and the metadata service can then enforce these policies when responding to requests.

Many of the attendant features will be more readily appreciated as the same becomes better understood by reference to the following detailed description considered in connection with the accompanying drawings.

The detailed description provided below in connection with the appended drawings is intended as a description of the present examples and is not intended to represent the only forms in which the present example may be constructed or utilized. The description sets forth the functions of the example and the sequence of steps for constructing and operating the example. However the same or equivalent functions and sequences may be accomplished by different examples.

The location attribute as described above is a tightly bound attribute which is inviolable. Native support for this attribute is provided in the data store e.g. file system or database . When a data element is moved or replicated the attribute moves with the data element and is updated by the single trusted entity e.g. the operating system and consequently replicas are now not an exact copy of the original data element because the location attribute is different. The restriction in relation to which entities can write the location attribute provides a high level of authenticity and the location information can therefore be trusted and used by many different applications for many different purposes as described in more detail below.

In an example the data store may be an NTFS file system and the location attribute may be added to existing attributes which in NTFS are referred to as Attribute Types to distinguish them from FileAttributes which are flags that can mark the file as read only hidden compressed etc and are a subset of the possible attributes a file may have . Examples of existing attribute types in NTFS with the addition of the new attribute type FILE LOCATION are shown in the table below 

In another example the data store may be an SQL Server and in such an example each database record may have an extra location column as shown in the example table below 

It will be appreciated that although each data element has an associated location attribute which identifies a geographical location of the data element in some systems the location attribute may not be explicitly specified such that the location attribute may be left blank or filled with a default or null value. A particular value for the location attribute may be used to indicate that the geographical location is not known and this may be the same as or different from the value which is used in systems which do not actively use the location attribute.

The system shown in also comprises a metadata service MDS which may be separate from the data or co located with the data. The MDS provides access to the location information stored as the location attribute for applications or other users of the data as described in some of the examples given below. The MDS may therefore store location information for each data element which corresponds to the location stored in the location attribute. When the location of a data element changes and the location attribute is updated this change may be propagated to the MDS by the data store e.g. the data store may provide updates to the MDS periodically e.g. every 10 seconds or alternatively the MDS may periodically poll the data store to confirm location information. The MDS may therefore be described as tracking locations of files and receiving location requests from users. Where the location attribute is mirrored in an MDS which is separate from the data the location attribute stored with the data may be referred to as the primary location attribute .

In the examples above there is a separate location attribute for each data element and the location attribute forms part of the file record itself however in some examples a location attribute may reside within the data store general metadata such that a collection of data elements have the same associated location attribute such that each data element still has an associated location attribute but there is not a 1 1 relationship between data elements and location attributes . Where a user has many data elements e.g. files and the data elements are very mobile i.e. they change geographical location frequently it may be more efficient to use this approach as instead of updating the location attribute of each data element the location attribute of the collection is updated.

In order that an application can retrieve the location information for a data element a new API application programming interface call GetFileGeoLocation may be used and an example of such an API call is given below 

There are many applications in which the location attribute described above may be used given that the attribute provides location information which is secure and trustworthy. Applications include access control performance optimization and services which use location and as described in more detail below some of these applications use user location as an additional parameter in addition to the data location . Depending on the level of granularity required in a particular application the user location may be determined based on different technologies and in some examples a user may have a location sensor which is specific to them e.g. a GPS receiver in their mobile phone whereas in other examples user location may be determined based on nearby and possibly fixed location sensors. In an example triangulation in 3D space using wireless near field technologies may be used to determine a user s location in a fine grained manner and this may be useful for applications such as providing location based access control for an open plan area where wireless signals might propagate unimpeded by physical barriers. In another example software defined radio or Ultra Wide Band UWB radio may be used to determine the proximity of physical barriers and so aid in sensing the physical location of a user. In other examples any other form of location sensor technology may be used e.g. camera and microphone sensor technology or technology such as Kinect and this may be coupled with other technologies such as object recognition QR barcodes etc to provide location identification.

Where user location is a parameter APIs such as the ReadFile WriteFile APIs may be augmented with a parameter UserLocation which then passes the geographical location of a user. Unlike the location of data which is stored with the data in the form of the location attribute the user location may be a dynamic parameter which is determined when required e.g. upon request or when the API requires it as an input parameter . In another example however the user location may be stored in a similar manner to the data location through use of a special user file which is stored in the data store and has a location attribute which identifies the location of the user rather than the location of the user file data. In addition or instead the user location may be stored in the MDS and periodically updated checked e.g. the MDS may track users in the same or a similar manner to its tracking of data elements .

In many applications the interaction between the user data element data store and the sensor is secure and time sensitive i.e. cannot be corrupted or masqueraded and the sensor is secured trusted to give a true location indication. Public key encryption and signing of messages between devices sensors with trusted platform modules e.g. PC Palladium chips may be an example solution for gaining this level of trust.

For a user to access a data element the user makes a request to locate the data element to the MDS block as indicated by arrow in and this request contains the location of the user as determined using sensor . The MDS is responsible for periodically keeping track of the location of the data element e.g. this could be implemented using heartbeats as shown by arrow in but the information held by the MDS may be out of date e.g. the data element may have moved somewhere else . Having received a user request in block the MDS makes a decision based on at least one of the stored location of a data element and a location of the user. In this specific example shown in the MDS determines whether the access control policy for the data element requested allows for the user to access it based on the stored location of the data element and or the current location of the user block . If the access control policy is met Yes in block the MDS responds with an appropriately signed response to indicate how the user can contact the data element data store e.g. in the form of an IP address for the data element data store block and arrow . This appropriately signed response may be in the form of a token which may in some examples be cached by the user where as described above this is not intended to refer to the human user themselves but instead to a user client side library . The user can then make an access request to the data element data store block and arrow and in return receive the requested data block and arrow . If the result of the decision regarding the access policy in block is No access is denied block .

In a variation of that shown in and where the operating system cannot access the MDS but still wants to provide local location based access control a scheme for proxy location management may be used. Such a scheme may use similar techniques to permission proxying temporary security token acquisition from a trusted authority and the MDS may be delegated to the local system or the function of the MDS may be delegated to a different MDS.

In some examples the data element data store may also perform the access control policy determined in block since it knows its exact state the MDS might have a stale position . In such an example the data element data store may respond with an access challenge request block which may incorporate the data element s location as reliably determined by the local sensor . This may be in the form of a signed message from the data element data store using the data element data store and the local sensor s private keys. If the access control policy is not met No in block e.g. if either the user or the data element has moved to a new location since the last time the user contacted the MDS for example if the user provides a cached access token that incorporates an old location of the data element the user will be denied access block . The user will then have to go back to the MDS to obtain a new token e.g. in a repeat of blocks and before it will be able to access the data element and this will only be successful where the token is issued after the location has been updated in the MDS which may take several seconds where heartbeats are used .

In the examples described above the credentials for security access are presented to the verification agent by the principal who wishes to gain some particular access control. This has the effect that the data element does not need to understand the infrastructure for trusting entities which for example it would need to do if instead the data element performed access control based on its known location without responding with an access challenge request in block and means that the data element is a more passive entity.

In the methods described herein the operating system handles location information. This has the effect that an application does not have to constantly verify its location before each data read but instead as shown in presents a set of credentials gained from the MDS when it last checked on location access control. If these credentials are out of date or wrong for the current location the operating system will escalate this via an access control error message to the application.

In the example shown in the access control is based on the locations of both the user and the data element however in other examples and other applications e.g. performance optimization proximity service just one entity s location the user or the data element or both may be taken into consideration. The authentication request to allow or deny access to the resource may be initiated by either the user or the data element data store and is only reliant on one of these entities realizing a need to interact with the other based on their location.

In an example application where the access control policy is only defined in terms of the location attribute of the data elements confidential project files may be restricted so that they can only be accessed from a particular location e.g. certain secure offices within a building . The physical disks containing the files themselves could then be moved between locations at will but would not be accessible in transit or in other locations. Such an access control policy would prevent third party access to data if the data was misplaced in transit between locations e.g. if accidentally left on a train .

The system and method shown in may also be generalized to a case where there are multiple users and or resources. If there are multiple users the location of all of them could be sent to the metadata service through the APIs. This allows for example applications that can access data only if a group of users are physically close by or only if one of the users is close by and other users are more than a specified distance away etc.

The access control policy used may be of any form and may be defined in terms of absolute location e.g. the user can only access a data element from a particular location and or the data element can only be accessed when stored in a particular location or in terms of relative location e.g. the user can only access the data element when they are in the same location or a group of users or one of the group can only access a data element when they are all close by or when they are physically separated. In an example a pupil may bring homework files home on a USB stick and an access control policy may be set such that the files can only be accessed when the location of both the files and the user are home . In another example guests to a house who are located in the living room may be allowed to access to digital pictures stored on the home network or any other data set which is defined without the need for a password or requiring the host to set specific read write permissions on every file. In a third example files relating to games e.g. pub quizzes may be restricted so that they are only accessible in the location where the game is to be played e.g. in the pub to prevent cheating.

In addition to or instead of using the location attribute to specify access permissions the attribute may be used to control where data elements can be stored which may be referred to as a data placement policy. The data placement policy specifies the permitted and or not permitted storage locations for the data element e.g. the data element can only be stored in the UK the data element must not be stored outside of the USA etc and therefore defines allowed values of the location attribute. The data store or metadata service can then control placement of data elements and any replicas to ensure the policy is satisfied i.e. storage of a data element is controlled in accordance with the data placement policy . A data placement policy may be used for security for performance optimization or for other reasons and various examples are described below.

The use of a data placement policy in combination with the location attribute described above may be particularly useful in distributed or cloud based data storage where the servers may be geographically distributed and users or organizations may wish to restrict movement of their data. Alternatively an organization could use an access control policy such that although data could be stored in non preferred locations it could only be accessed when stored in a preferred location as described above. A data placement policy may be used to prevent theft of data if a sensitive file is created with a geographical location indication that it can only be stored in location A and a malicious user attempts to transfer the file to location B this will be prevented.

The following example shows a CreateFile call in which both an access control policy and a data placement policy have been instantiated through two optional parameters lpSecurityAttributes and dwDesiredGeoLocation respectively.

Although the parameter in the above example which implements an access policy is referred to as a security descriptor the location attribute and the control of access based on location may be performed for reasons other than security and one example is performance optimization. For example where multiple replicas of a data element are stored in a system e.g. a user may have two replicas of a music file one at home and one in the cloud the data store may determine which replica to read dependent on the current location of the user and this choice may be based on many factors such as network traffic costs latency or security reasons.

Referring to the architecture shown in is a flow diagram of a method of operation of the system which provides performance optimization. The user makes a request to locate the data element to the MDS block as indicated by arrow in and this request contains the location of the user as determined using sensor . The MDS is responsible for periodically keeping track of the location of the data element and any replicas. As described previously with respect to having received a user request in block the MDS makes a decision based on at least one of the stored location of a data element and a location of the user. In this specific example shown in the MDS uses the user location data received in block to identify the most appropriate replica for the user to access block and then responds with an appropriately signed response to indicate how the user can contact the identified replica of the data element e.g. in the form of an IP address for the data element data store block and arrow . The user can then make an access request to the data element data store block and arrow and in return receive the requested data block and arrow .

Another example involving replication can be described with reference to . is a schematic diagram of a storage system which comprises a number of servers a short term versioned store and a metadata service . The servers are connected by a network not shown in which also connects them to the short term versioned store and the metadata service . The arrows in represent some of the communication paths within the system however it will be appreciated that messages and data may flow in directions not shown in . In an embodiment the servers are geographically co located and the network which interconnects them may be a low latency network. This storage system is a variation on the storage system described in co pending U.S. patent application Ser. No. 12 714 223 entitled Reducing Power Consumption of Distributed Storage Systems filed 2 Feb. 2010 which is incorporated herein in its entirety.

The system provides read write access to data objects in units of chunks where the chunk size is a system parameter e.g. 64 MB or 1 MB and consequently the servers may be referred to as chunk servers . These chunk servers may be any form of device which can operate as a server including but not limited to PCs laptop computers or smartphones. Write requests may overwrite existing data and or append new data and client read and writes may be for arbitrary byte ranges within a chunk. A number r of blocks of data derived from a chunk are stored in the system with derived blocks being stored on different chunk servers . In an embodiment of the system which uses replication each block of data derived from a chunk comprises a replica of the chunk and each of the replicas may have different location attributes . There are many ways that chunks may be assigned to chunk servers at chunk creation time however where a data placement policy is defined e.g. as described above the data location specification can be sent to the MDS through the CreateFile API the MDS ensures that a file and its replicas are only placed in chunk servers in the desired location s using the chunk server location information which is stored at the MDS . This location information may be provided through periodic heartbeats and location updates as described above in relation to .

At times of reduced system load the number of active blocks of data derived from a chunk e.g. the number of replicas may be reduced e.g. from r blocks to less than r blocks and those servers in the system which do not store any active blocks are put into a low power state. The system load may be defined in terms of I O requests and may be determined using predictions e.g. based on historic load data and or measurements of current system load. Putting a subset of the servers in the system into a low power state reduces the power consumption of the system however the servers which are in a low power state are unavailable for servicing read and write requests. If at least one replica of a chunk remains active this can be used to service any read requests received but if all replicas are inactive there will be delay while a server exits the low power state a process which may be referred to as waking up before the request can be serviced. If a write request is received for a chunk of data at a time when some of the servers are unavailable the write is stored in the versioned store .

For a given chunk one of the active replicas of a chunk e.g. one of the replicas is denoted as the primary at any given time with the other replicas being secondaries and over time the replica which is denoted as primary may change. At any time a chunk server will be the primary for some of the chunks stored on it i.e. where the chunk server stores a replica of the chunk which is currently considered the primary and a secondary for the others i.e. where the chunk server stores a secondary replica of the chunk . Client read and write requests for a particular chunk or portion thereof are sent to the primary chunk server which determines request ordering and ensures read write consistency. The term primary may be used herein to refer to either the replica which is currently denoted as primary or to the chunk server which holds the replica which is currently denoted as primary. The system may be load balanced by spreading a large number of chunks substantially uniformly over a smaller number of chunk servers and by choosing the primaries for each chunk substantially randomly from the available replicas e.g. replicas of that chunk.

The short term versioned store is used to store writes which may be to the whole of or a part of a chunk when the system is operating in a lower gear and one or more chunk servers are unavailable because the chunk server is in a low power state . A write or each write for a particular chunk has associated version information such that multiple writes for a portion of a chunk can be accommodated and the store maintains substantially the same fault tolerance for data stored in the store compared to data stored in a chunk server e.g. by storing r copies of a write in different locations within the store or by use of error correction techniques e.g. erasure codes . The short term versioned store may use the same coding used by the chunk stores e.g. they may both use replication or erasure coding or different coding may be used e.g. the chunk stores may use erasure coding and the short term versioned store may use replication . When all the chunk servers are available data written to the store is transferred to the chunk servers in a process which may be referred to as reclaim and once this is completed the data in the store can be deleted.

The MDS which may be a centralized metadata service functions as a naming service and maps an object such as a file to its constituent chunks. The metadata service holds location information for all of the chunk servers as described above and also records the location of replicas of a chunk e.g. of each replica of a chunk details of the primary and may also track chunk server availability. Other functions of the metadata service may include reassigning primaries as necessary and initiating recovery actions when a server fails permanently. The metadata service is not on the data path between clients and chunk servers and the state of the metadata service is updated when chunks are created or deleted but does not need to be updated when they are read or written. In an example the MDS may be implemented as an in memory deterministic state machine which can be replicated for high availability using state machine replication techniques.

The operation of the system of in response to read and write requests received from a client can be described with reference to . When a client has a read or write request the metadata service is used to identify the relevant primary chunk server or multiple primary chunk servers where the request relates to multiple chunks e.g. the chunk ID and primary chunk server location block . Where an access control policy has been defined it is determined whether the access control policy is met in block based on the location of the primary and or the location of the client as stored in the client location attribute . The client location may be provided to the MDS in the ReadFile WriteFile API as described above . If the access control policy is met Yes in block the MDS sends details of the primary location to the client block and the client can then send the read write request to the primary chunk server block .

If however the access control policy is not met No in block the MDS determines if the policy could be met if the primary was migrated from the current chunk server to one of the secondary chunk servers and if so Yes in block the primary is migrated block . The primary may be migrated using the following protocol for the chunk C for which S is a primary 

Once the primary has been migrated in block the MDS sends details of the primary location to the client block and the client can then send the read write request to the primary chunk server block . If however the MDS determines that migrating the primary will not allow the access control policy to be satisfied No in block then the read write request is rejected block .

Where the client application is able to send a read write request to the primary block in the case of a read request the primary chunk server uses a local replica of the chunk to satisfy the request block . In the case of a write request and where all the chunk servers storing replicas of the relevant chunk are available Yes in block all replicas of the chunk stored on the different chunk servers are updated with the write block . If however not all the chunk servers are available No in block i.e. a chunk server is in a low power state or has failed the write is written to the short term versioned store block . This data written to the short term versioned store in block is subsequently reclaimed and written to the chunk servers when they are all available.

Availability of chunk servers may be tracked through periodic heartbeats sent from chunk servers to the MDS . In response to a heartbeat the MDS sends the chunk server a lease for the set of chunks that it is currently the primary for and details of the locations of the secondaries for those chunks i.e. details of the chunk servers which store the secondary replicas . Leases are set to expire before the MDS times out the heartbeat and servers send fresh heartbeats before their leases expire. The MDS reassigns primaries on demand for chunks whose primaries have lost their lease. A chunk server with an expired lease will return an error to a client trying to access data on it after a timeout period the client fetches and caches the new chunk metadata from the MDS.

In an example there may be two replicas available for a chunk which a client wants to access. One R may be physically stored at the home PC and the other R may be stored on a work PC and may be the primary. If the access policy is such that a user should only read the replica at home the primary will need to be migrated from replica R to R before the user can read the data.

In another example of a performance optimization which is enabled through the use of a location attribute associated with a data element if data is written to a data store which is distant from the user client the client can decide to compress the data before sending it to the data store. The location information is provided to the client by the MDS e.g. as described above with reference to .

In a further application of the location attribute services may be enabled which use the location information. In an example a file sharing application may only allow sharing of a file between users which are close by e.g. two siblings at home and if the data will remain close by e.g. a user will not copy the data onto the cloud or email it to a friend . This example therefore uses both the location attribute for the data and the user location.

Computing based device comprises one or more processors which may be microprocessors controllers or any other suitable type of processors for processing computing executable instructions to control the operation of the device in order to write location attributes for data elements stored in the device and to implement any access control or data placement policies which may be defined. In some examples for example where a system on a chip architecture is used the processors may include one or more fixed function blocks also referred to as accelerators which implement a part of the method of writing and or managing location attributes in hardware rather than software or firmware . Platform software comprising an operating system or any other suitable platform software may be provided at the computing based device and in some examples this platform software may enable application software to be executed on the device.

The computing based device comprises a data store for storing data elements where each data element has an associated location attribute which is stored in the same location as the data element and in some examples may be part of the data element or part of the general metadata of the data store.

The data store and the computer executable instructions may be provided using any computer readable media that is accessible by computing based device . Computer readable media may include for example computer storage media such as memory and communications media. Computer storage media such as memory includes volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EPROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that can be used to store information for access by a computing device. In contrast communication media may embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism. Although the computer storage media memory is shown within the computing based device it will be appreciated that the storage may be distributed or located remotely and accessed via a network or other communication link e.g. using communication interface .

As described above the location attribute information can only be written by a single trusted entity such as operating system . The location information may be provided to other entities such as application software by a metadata service . The communication interface may be arranged to receive requests from remote clients or users for location information and these requests are handled by the metadata service .

The computing based device may also comprises an input output controller arranged to output display information to a display device which may be separate from or integral to the computing based device . The display information may provide a graphical user interface. The input output controller is also arranged to receive and process input from one or more devices such as a user input device e.g. a mouse or a keyboard . This user input may be used to interact with the operating system and application software but a user cannot write to the location attribute . In an embodiment the display device may also act as the user input device if it is a touch sensitive display device. The input output controller may also output data to devices other than the display device e.g. a locally connected printing device not shown in .

The examples described above provide a data store which includes a file location attribute. Existing data stores however do not incorporate the geographical location of a user or of the data itself Certain current network protocols and devices e.g. firewalls are location aware for example network based access control ensures that files within an organization s firewalls are only accessible from within the organization. However such policies are very coarse grained they either allow or prevent access to all files and are easy to circumvent e.g. by copying a file onto a portable memory device and transporting it outside the organization . Some systems provide services or access control based on location and such services or access control are managed by application software which obtains and tracks location information and can manage user access to data services based on the location information. Such systems however do not provide a high level guarantee of authenticity of the location information as the information may be modified by a user or third party. Some applications are also location aware for example a camera application may record the GPS location where a photograph was taken in the metadata associated with the image file however this location is not where the data is stored. Additionally the image capture location cannot be used by another application which knows nothing about the protocol used by the camera application.

Although the present examples are described and illustrated herein as being implemented in a system as shown in the system described is provided as an example and not a limitation. As those skilled in the art will appreciate the present examples are suitable for application in a variety of different types of computing systems and the data store may comprise a distributed or cloud based data store. A number of APIs are given above as examples of how they may be augmented with location information e.g. user location information . It will be appreciated that other APIs may be similarly augmented. Through use of a location attribute as described above geographic location becomes an intrinsic component of a data store and a system including such a data store.

The systems and methods described herein are not intended to replace any requirements for digital rights management DRM methods to prevent someone copying a file and the systems and methods may be used in combination with DRM to avoid someone copying a file from a location secured place to an unsecured place and taking it away in clear text.

The term computer is used herein to refer to any device with processing capability such that it can execute instructions. Those skilled in the art will realize that such processing capabilities are incorporated into many different devices and therefore the term computer includes PCs servers mobile telephones personal digital assistants and many other devices.

The term user is used above to refer to the user or client device which a user is using to interact with the data store application software etc. Some of the systems and methods described above use user location as an additional parameter. It will be appreciated that the user location data may comprise sensitive user data and therefore consent may be obtained from the user before this information is shared.

The methods described herein may be performed by software in machine readable form on a tangible storage medium e.g. in the form of a computer program comprising computer program code means adapted to perform all the steps of any of the methods described herein when the program is run on a computer and where the computer program may be embodied on a computer readable medium. Examples of tangible or non transitory storage media include disks thumb drives memory etc and do not include propagated signals. The software can be suitable for execution on a parallel processor or a serial processor such that the method steps may be carried out in any suitable order or simultaneously.

This acknowledges that software can be a valuable separately tradable commodity. It is intended to encompass software which runs on or controls dumb or standard hardware to carry out the desired functions. It is also intended to encompass software which describes or defines the configuration of hardware such as HDL hardware description language software as is used for designing silicon chips or for configuring universal programmable chips to carry out desired functions.

Those skilled in the art will realize that storage devices utilized to store program instructions can be distributed across a network. For example a remote computer may store an example of the process described as software. A local or terminal computer may access the remote computer and download a part or all of the software to run the program. Alternatively the local computer may download pieces of the software as needed or execute some software instructions at the local terminal and some at the remote computer or computer network . Those skilled in the art will also realize that by utilizing conventional techniques known to those skilled in the art that all or a portion of the software instructions may be carried out by a dedicated circuit such as a DSP programmable logic array or the like.

Any range or device value given herein may be extended or altered without losing the effect sought as will be apparent to the skilled person.

It will be understood that the benefits and advantages described above may relate to one embodiment or may relate to several embodiments. The embodiments are not limited to those that solve any or all of the stated problems or those that have any or all of the stated benefits and advantages. It will further be understood that reference to an item refers to one or more of those items.

The steps of the methods described herein may be carried out in any suitable order or simultaneously where appropriate. Additionally individual blocks may be deleted from any of the methods without departing from the spirit and scope of the subject matter described herein. Aspects of any of the examples described above may be combined with aspects of any of the other examples described to form further examples without losing the effect sought.

The term comprising is used herein to mean including the method blocks or elements identified but that such blocks or elements do not comprise an exclusive list and a method or apparatus may contain additional blocks or elements.

It will be understood that the above description of a preferred embodiment is given by way of example only and that various modifications may be made by those skilled in the art. The above specification examples and data provide a complete description of the structure and use of exemplary embodiments of the invention. Although various embodiments of the invention have been described above with a certain degree of particularity or with reference to one or more individual embodiments those skilled in the art could make numerous alterations to the disclosed embodiments without departing from the spirit or scope of this invention.

