---

title: Method and apparatus for virtual in-circuit emulation
abstract: A virtual In-Circuit Emulation (ICE) capability is provided herein for supporting testing of Joint Test Action Group (JTAG) hardware. A Virtual ICE Driver is configured for enabling any debug software to interface with target hardware in a flexible and scalable manner. The Virtual ICE Driver is configured such that the test instruction set used with the Virtual ICE Driver is not required to compute vectors, as the JTAG operations are expressed as local native instructions on scan segments, thereby enabling ICE resources to be accessed directly. The Virtual ICE Driver is configured such that ICE may be combined with instrument-based JTAG approaches (e.g., the IEEE P1687 standard and other suitable approaches). The Virtual ICE Driver is configured for receiving a plurality of scan segment operations generated by a plurality of target ICE controllers of at least one ICE host, scheduling the received scan segment operations, based at least in part on a scan chain of the target hardware, to form thereby a scheduled set of scan segment operations, and providing the scheduled set of scan segment operations to a processor configured for executing the scheduled set of scan segment operations for testing the target hardware.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08621301&OS=08621301&RS=08621301
owner: Alcatel Lucent
number: 08621301
owner_city: Paris
owner_country: FR
publication_date: 20100630
---
This application is a continuation in part of U.S. patent application Ser. No. 12 495 237 entitled METHOD AND APPARATUS FOR SYSTEM TESTING USING MULTIPLE INSTRUCTION TYPES U.S. patent application Ser. No. 12 495 295 entitled METHOD AND APPARATUS FOR SYSTEM TESTING USING MULTIPLE PROCESSORS and U.S. patent application Ser. No. 12 495 336 entitled METHOD AND APPARATUS FOR SYSTEM TESTING USING SCAN CHAIN DECOMPOSITION each of which was filed on Jun. 30 2009 and each of which claims the benefit of U.S. Provisional Patent Application Ser. No. 61 157 412 filed on Mar. 4 2009 entitled TEST INSTRUCTION SET ARCHITECTURE which applications are incorporated herein by reference in their entirety.

The invention relates to the field of embedded systems and more specifically but not exclusively to testing of embedded systems using In Circuit Emulation ICE .

In testing of embedded systems In Circuit Emulation ICE is a technique that is used to debug embedded software running on one or more processors. In ICE embedded software is typically debugged using a debugging infrastructure e.g. using a debugger such as the GNU Debugger GDB . In ICE components of the processor can be connected to a JTAG infrastructure so that the debugger can access the components in order to gain knowledge of the remote program execution and modify the remote program execution as needed. For example the debugger may gain knowledge of registers e.g. state and user registers watchpoints memory banks clock control blocks and other elements. While this provides a powerful mechanism for debugging software in its final environment it is inhibited by the actual features of JTAG. For example a typical ICE for a given processor core may need to access dozens of elements and existing embedded designs may be composed of a large number of processor cores. As a result efficient handling of JTAG operations is important and presents a difficult problem given the considerable number of accesses needed in order to perform even the most simple of debug operations.

The existing JTAG based ICE capabilities are deficient in a number of ways. First existing ICE solutions require use of only one JTAG ICE interface at a time or require special isolation logic for each processor core in order to enable multiple ICE interfaces to co exist on the same target board . Second existing ICE solutions rely heavily on Test Generation Tools TGTs for the handling of JTAG operations which in turn rely heavily on user input in order to specify the topology of the scan chain surrounding the processor core. In fact in existing ICE solutions JTAG operations can be done only at the vector level where there is no knowledge of the device internals. Third existing ICE solutions typically rely on boundary scan access in order to access components of the target board thereby requiring generation of complete testing vectors regardless of the testing being performed and further requiring retargeting of testing vectors when multiple devices are present within the boundary scan chain. As a result of such deficiencies the TGT must maintain a complete yet simplified model of the system in order to be able to generate the required vectors and to interpret and decode the results. Disadvantageously this requires a considerable amount of computational power thereby limiting the scalability of the solution especially for resource constrained embedded approaches. Furthermore the embedded controller can only perform basic input output solutions and must make reference to a powerful host computer in order to run the TGT and the interface with the TGT is usually vendor dependent and proprietary thereby resulting in additional costs and loss in flexibility. Thus existing ICE solutions make it virtually impossible to support multiple instances of ICEs.

The existing ICE capabilities are further deficient in that they cannot efficiently support multiple processor cores concurrently. In existing ICE solutions in order to support ICE for multiple processor cores concurrently a substantially more complex TGT and associated model is required in order to support coordination of command requests by each of the ICE instances running on the host machine. This involves a substantial and daunting task of retargeting based on the perspective of the entire scan chain that could change in its topology between each scan operation i.e. the data sent to the target hardware is a variable length bit stream between each scan operation. This is not easily accomplished by existing TGTs that assume fixed length bit stream representations of data vectors to be applied to and recovered from the scan chain of the target hardware. While existing ICE capabilities are deficient in that they cannot efficiently support multiple processor cores concurrently a potential solution for accessing multiple processor cores within a single target processor is the IEEE 1149.7 standard which proposes a standardized ICE JTAG interface to each processor core which can be used by debuggers to access the target processor. Disadvantageously however the complexity involved in handling vectors through the TGT seriously limits the features that may be implemented with the IEEE 1149.7 standard including completely excluding support for concurrency.

Various deficiencies in the prior art are addressed through methods and apparatuses for providing virtual In Circuit Emulation ICE .

In one embodiment a method includes receiving a plurality of scan segment operations generated by a plurality of target ICE controllers of at least one ICE host where the plurality of target ICE controllers are associated with a plurality of components of the target hardware scheduling the received scan segment operations based at least in part on a scan chain of the target hardware to form thereby a scheduled set of scan segment operations and propagating the scheduled set of scan segment operations toward a processor configured for executing the scheduled set of scan segment operations for testing one or more components of the target hardware.

To facilitate understanding identical reference numerals have been used where possible to designate identical elements that are common to the figures.

Various system testing capabilities are provided for use in performing testing of a system under test SUT .

In one embodiment a test instruction set architecture TISA is provided. The TISA is provided for use in performing system testing. The TISA combines computer science capabilities with system testing capabilities to provide improved system testing capabilities including interactive testing capabilities remote testing capabilities and various other capabilities described herein. The TISA is formed by adapting a software based instruction set architecture ISA using system testing capabilities. The software based ISA may utilize any suitable software programming language e.g. C Java and the like as well as various combinations thereof and may be implemented using any suitable processor. The system testing capabilities may utilize any suitable TAP such as IEEE 1149.1 also known as JTAG TAPs or any other suitable TAPs. In general the TISA is formed by combining the atomic operations of a software process with atomic testing operations of a test procedure. In the TISA the algorithmic portions of the test procedure are handled by the software flow such that the algorithmic portions of the test procedure are translated into the atomic testing operations. The TISA is formed by combining the atomic operations of the software process with the atomic testing operations of the test procedure such that the atomic testing operations are treated in the same manner as the atomic operations of the software process that is handling the algorithmic portions of the test procedure. This enables finer grain control of embedded test execution remote test execution and various other improved system testing capabilities as depicted and described herein.

The TS may be any system suitable for testing SUT . The TS is configured for testing SUT . The TS may perform any testing of SUT e.g. testing one or more individual components of SUT one or more combinations of components of SUT one or more interconnections between components of SUT one or more system level functions of SUT and the like as well as various combinations thereof. The TS may perform any of the functions typically associated with testing a system under test such as executing test procedures providing input data to the system under test receiving output data from the system under test processing output data received from the system under test for determining system testing results and like functions as well as various combinations thereof. The design and use of TS for testing a system under test is described in additional detail hereinbelow.

The SUT may be any system which may be tested using TS . The SUT may include any component s at least a portion of which may be tested individually and or in combination by TS . The SUT may include one or more scan chains having one or more sets of associated input and output access pins providing access to the component s to be tested by TS . The manner in which a scan chain s may be utilized in SUT for testing SUT will be appreciated by one skilled in the art. For example SUT may include one or more boards testing of which may be performed using one or more scan chains having associated input and output access pins which may be used for applying input testing signals to SUT and collecting output testing signals from SUT .

As depicted in TS accesses SUT via a test access interface TAI . The test access interface may be implemented using any suitable test access interface which may depend on one or more of the TS the SUT the type of testing to be performed and the like as well as various combinations thereof.

For example TAI may include a Joint Test Action Group JTAG Test Access Port TAP as standardized in IEEE 1149.1 standard which is incorporated by reference herein in its entirety. The IEEE 1149.1 standard defines a TAP that supports the following set of signals Test Data In TDI Test Data Out TDO Test Mode Select TMS Test Clock TCK and optionally Test Reset Signal TRST . The TDI and TDO pins of SUT are interconnected in a boundary scan chain by which TS may access SUT for testing at least a portion of SUT .

It will be appreciated by one skilled in the art that TS TAI and SUT may be implemented in any manner suitable for providing features of the embodiments covered herein.

As described herein the TISA is able to leverage computer science capabilities in combination with system testing capabilities to provide a significant improvement in system testing. A general description of system testing capabilities and computer science capabilities follows followed by a description of the manner in which computer science capabilities and system testing capabilities may be utilized together to provide the TISA.

The TISA improves upon system testing capabilities by leveraging computer science capabilities. The system testing capabilities may include the capabilities generally supported in all stages of the automated test flow which generally includes all of the steps and resources that may be needed to get from a definition of the test algorithm s to actual testing operations .

In order to help test automation test resources often are embedded inside the boards and devices and can be accessed using a standardised interface usually called the Test Access Port TAP . This has the effect of limiting the pin count and rationalising resource access and management. A number of languages are available for describing resources inside a system under test and thus which may be used as inputs to Test Generation Tools TGTs . TGTs can apply algorithms to generate testing sequences which may be used by a Test Control Unit TCU to command the TAP and execute the associated testing operations. The features and performances of the testing operations depend on these three elements the access standard the data format and the TCU implementation.

The TISA is able to leverage computer science capabilities to provide improved system testing capabilities. This may include use of computer science capabilities that are available in all stages of the software development flow which generally includes any or all of the steps and resources that may be needed to get from a software algorithm coded in a software language s of choice to the final debugging and execution on a target processor such as compilation an Instruction Set Architecture ISA interactive debugging and the like as well as various combinations thereof .

The use of compilation in computer science reduces an algorithm defined in a programmer friendly high level abstraction to a series of machine executable instructions. This process can vary greatly depending on the input programming language and project complexity however most if not all of the approaches share the same basic assumption any algorithm can be decomposed into basic instructions regardless of its complexity. This applies to classic languages as well as to more modern high level and object oriented languages such as for example C Java Python and the like.

The Instruction Set Architecture ISA is the core of any processor and the reason for which compilation is so effective. In general each processor offers a set of instructions which define the manner in which the processor can be operated. The instructions form at least part of the ISA of the processor. It will be appreciated that the ISA may be considered to include various constructs associated with the instructions such as registers addressing modes opcodes memory structures and the like as well as various combinations thereof. The ISA enables the processor to execute simple instructions such as reading writing values from to memory perform logical or arithmetical operations on registers handle interruption and the like. This basic behaviour has remained essentially unchanged over time and modern processors achieve exceptional performances because they can efficiently exploit great numbers of resources and thus are able to complete a much larger number of such basic instructions in approximately the same amount of time. Furthermore even higher performances may be reached from the use of co processors e.g. floating point co processors graphical co processors and the like which can help the main processor by hard coding complex operations.

The use of debugging in computer science allows monitoring and verification of the software development and execution process. In general software development is a long and difficult process which is strictly monitored and verified to assure that the final product is free of defaults or bugs are they are usually called. In order to help test software programs the software development flow provides many powerful debug features. For example common software development flow debug features include step by step execution observability controllability of all registers and memory locations use of breakpoints and watchpoints and the like. These debug features as well as various other debug features are more often enabled by algorithms and structures embedded into the final code by the software compiler but may also be assisted by hardware resources available inside of the processor. From this information the debugger can reconstruct the original code and correlate all the ISA level operations to the programming abstraction layer.

The use of automated test execution capabilities and computer science software capabilities together to enable improved system testing capabilities may be better understood by way of reference to and .

The TGT composer accepts system description files as input. The system description files include any suitable description files which may be used by a TGT to produce testing instructions vectors for testing a system under test. For example system description files may include circuit description files board fixture netlist files other description files and the like as well as various combinations thereof. The system description files may be available on TGT and or may be obtained from one or more remote components and or systems.

The system description files may include one or more circuit description files The circuit description files may be specified using any suitable description language s such as the Boundary Scan Description Language BSDL which was developed as part of the IEEE 1149.1 standard for board level JTAG the Hierarchical Scan Description Language HSDL which was developed as an extension of BSDL New Scan Description Language NSDL and the like as well as various combinations thereof.

The system description files may include one or more board fixture netlist files The board fixture netlist files may include files related to the physical description of the device s describing the netlist connections and like information. The board fixture netlist files may be specified in any suitable format such as PCB Gerber and or any other format suitable for board fixture netlist files.

The system description files may include one or more other description files. The other description files may include any other suitable description files which may be used as input for producing a circuit model. For example other description files may include any suitable application specific and or tool specific description language files such as Asset s Macro Language Goepel s CASLAN Language and or any other suitable description language files.

The TGT composer processes the system description files to produce a circuit model . The processing of system description files by TGT composer to produce circuit model may be performed in any suitable manner. The circuit model specifies a model of the system under test or portion of the system under test for which TGT is being run. The TGT composer provides circuit model to TGT algorithms .

The TGT algorithms accept circuit model . The TGT algorithms process the circuit model to produce TGT atomic test operations . The processing of circuit model by TGT algorithms to produce the TGT atomic test operations may be performed in any suitable manner.

The SC front end algorithms accept computer science source files as input. The computer science source files include any suitable computer science source files which may be compiled by a compiler. For example computer science source files may include computer science source files for any suitable computer programming language s such as C Java Python and the like as well as various combinations thereof. For example computer science source files may include one or more of one or more C files one or more C files and or any other suitable computer science source files.

The SC front end algorithms process the computer science source files to produce a program model . The program model specifies an intermediate representation of the computer science source files . The SC front end algorithms provide the program model to the SC back end algorithms .

The SC back end algorithms accept program model as input. The SC back end algorithms process the program model to produce one or more ISA Binary Files including ISA atomic operations . The processing of program model by the SC back end algorithms to form the ISA Binary Files including the ISA atomic operations may be performed in any suitable manner. The ISA atomic operations are assembly level instructions supported by the processor for which the TISA is implemented.

As depicted in in addition to the respective processing flows of TGT and SC additional interaction between TGT and SC may be utilized for controlling generation of the TISA atomic operations . In one embodiment SC back end algorithms may initiate one or more vector computation requests to TGT algorithms . The SC back end algorithms may initiate a vector computation request when the SC back end algorithms need to access the TAP. The TGT algorithms upon receiving a vector computation request from SC back end algorithms generate one or more TGT atomic test operations for the TAP based on the received vector computation request . The one or more TGT atomic test operations may then be applied to the TAP in a manner controlled by SC back end algorithms because the TGT atomic test operations are combined with the ISA atomic operations to enable algorithmic control over TGT atomic test operations using ISA atomic operations . In this manner the SC provides algorithmic control of access to the TAP.

As depicted in in addition to TGT and SC TS further includes a TISA composer . The TISA composer accepts the TGT atomic test operations and the ISA atomic operations . The TISA composer converts the TGT atomic test operations into TISA instructions and inserts the TISA instructions into the ISA Binary File s i.e. combining the TISA instructions with the ISA atomic operations to form thereby TISA Binary files including TISA atomic operations . The TISA composer may be part of TGT part of SC split across TGT and SC implemented separate from TGT and SC and the like.

It will be appreciated that the various inputs and outputs depicted and described with respect to may be stored displayed executed propagated and or handled in any other suitable manner as well as various combinations thereof.

As depicted in TS of operates in a manner similar to TS of in that TISA Binary files including TISA atomic operations are generated using interaction between the test generation tool and the software compiler however interaction between the test generation tool and the software compiler in TS of is different than interaction between the test generation tool and the software compiler in TS of .

The TGT composer accepts system description files as input. The system description files include any suitable description files which may be used by a TGT to produce testing instructions vectors for testing a system under test. For example system description files may include circuit description files board fixture netlist files other description files and the like as well as various combinations thereof. The system description files of may include system description files similar to system description files depicted and described with respect to e.g. one or more circuit description files one or more board fixture netlist files one or more other description files and the like as well as various combinations thereof . The system description files may be available on TGT and or obtained from one or more remote components and or systems.

The TGT composer accepts one or more test operation description files collectively test operation description files as input. The test operation description files are generated by SC . The generation of test operation description files by SC is described in detail hereinbelow.

The TGT composer processes the system description files and the test operation description files to produce a circuit model . The processing of system description files by TGT composer to produce circuit model may be performed in any suitable manner. The circuit model specifies a model of the system under test or portion of the system under test for which TGT is being run. The processing of system description files in conjunction with test operation description files enables the TGT composer to produce circuit model in a manner for enabling TGT to produce appropriate TAP atomic operations. The TGT composer provides circuit model to TGT algorithms .

The TGT algorithms accept circuit model . The TGT algorithms process the circuit model to produce TGT atomic test operations . The processing of circuit model by TGT algorithms to produce the TGT atomic test operations may be performed in any suitable manner.

As depicted in in addition to TGT and SC TS includes a TISA translator . The TISA translator receives the TGT atomic test operations . The TISA translator translates TGT atomic test operations to form TISA atomic test operations . The TISA translator provides TISA atomic test operations to SC for inclusion in the software compilation process. The use of TISA atomic test operations by SC is described in detail hereinbelow. The TISA translator may be part of TGT part of SC split across TGT and SC implemented separate from TGT and SC and the like.

The computer science source files include any suitable computer programming source files which may be compiled by a compiler. For example computer science source files may include computer programming source files for any suitable computer programming language s such as C Java Python and the like as well as various combinations thereof. IFor example computer science source files may include one or more of one or more C files one or more C files and or any other suitable computer science source files.

The SC pre compiler processes the computer science source files producing therefrom pre processed computer science source files . The computer science source files may be pre processed by SC pre compiler to form pre processed computer science source files in any suitable manner. The SC pre compiler provides the pre processed computer science source files to front end algorithms .

The SC pre compiler detects test operations during processing of the computer science source files and generates the test operation description files . The test operation description files may be specified using any suitable test description language e.g. using one or more standard test description languages using a test description language specific to the TGT and the like as well as various combinations thereof . The SC pre compiler provides the test operation description files to TGT illustratively to the TGT composer of TGT which processes the test operation description files in conjunction with the system description files to produce circuit model .

The SC front end algorithms accept pre processed computer science source files . The SC front end algorithms also accept the TISA atomic test operations which are produced by TISA translator using TGT atomic test operations produced by TGT from the test operation description files . The SC front end algorithms compile the pre processed computer science source files and TISA atomic test operations to produce a program model . The program model specifies an intermediate representation of the pre processed computer science source files which includes TISA atomic test operations such that TISA atomic test operations may be integrated within the ISA atomic operations to form TISA atomic operations. The SC front end algorithms provide the program model to the SC back end algorithms .

The SC back end algorithms accept program model . The SC back end algorithms process program model to produce one or more TISA Binary Files including TISA atomic operations . The processing of program model by the SC back end algorithms to form the TISA Binary Files including the TISA atomic operations may be performed in any suitable manner.

The TISA atomic operations include ISA atomic operations i.e. assembly level instructions supported by the processor for which the TISA is implemented and TISA atomic test operations .

The TISA atomic operations provide algorithmic control using ISA atomic operations over TGT atomic test operations i.e. in the form of the TISA atomic test operations thereby enabling improved system testing of the system under test to which the TISA atomic operations are to be applied. Thus the TGT atomic test operations i.e. in the form of the TISA atomic test operations may be applied to the TAP in a manner controlled by SC back end algorithms because the TGT atomic test operations are combined with the ISA atomic operations to enable algorithmic control over TGT atomic test operations using the ISA atomic operations. In this manner the SC provides algorithmic control of access to the TAP.

It will be appreciated that the various inputs and outputs depicted and described with respect to may be stored displayed executed propagated and or handled in any other suitable manner as well as various combinations thereof.

With respect to and although primarily depicted and described with respect to specific numbers of input files intermediate files models output files and the like it will be appreciated that the embodiments of and as well as various associated teachings provided herein may be implemented using any suitable numbers of input files intermediate files models output files and the like.

Referring to it will be appreciated that the capabilities and features of the TISA are defined by its abstraction level i.e. the finer the definition of the TISA atomic operations the better performance the TISA will provide.

In one embodiment in which TISA is implemented in a JTAG architecture three abstraction levels may be supported for scan operations.

The first abstraction level is the Vector Level. The Vector Level is the coarsest grain of the three abstraction levels where the atomic operations are inputs and outputs of scan vectors. The Vector Level is best represented in a vector format such as Serial Vector format SVF or any other suitable vector format and gives the highest level control.

The second abstraction level is the TAP Level. In the TAP Level the atomic operations are enhanced to allow full control over the TAP state machine. This enables more refined control over scan operations support of non standard sequences e.g. like the ones required for instance in the Addressable Shadow Protocol or other similar protocols .

The third abstraction level is the Scan Segments Level. The Scan Segments Level is the finest grain of the three abstraction levels. The Vector Level and TAP Level abstraction levels use the scan vector as the atomic data format which is sufficient for traditional continuity tests where the entire scan chain is involved but is cumbersome for instrument based testing where there is a need for fine grain control over the tens or hundreds of instruments that compose the scan chain. The Scan Segments Level allows the definition of scan segments inside the overall scan path which can be handled separately thereby providing a flexible and powerful set of primitives that can be used to define scan operations directly in the problem space and resolve the scan operations at implementation time. This approach is advantageous in embedded applications where the available computational resources may be quite limited. The use of Scan Segments Level is depicted and described in additional detail hereinbelow.

As depicted in and regardless of the abstraction level of the scan operations the resulting TAP atomic operations illustratively TGT atomic test operations and TGT atomic test operations computed by the TGT are converted into corresponding TISA atomic test operations and inserted into the binary executable i.e. into the ISA atomic operations generated by the SC .

Referring to TGT atomic test operations and ISA atomic operations can be processed to form the TISA atomic operations in the TISA binary executables illustratively TISA binary files . The TISA atomic operations include TISA atomic test operations and ISA atomic operations.

Referring to TISA atomic test operations generated by TISA translator from TGT atomic test operations produced by TGT can be input into the SC front end as pre compiled assembly instructions without any need to modify the SC front end of SC . It will be appreciated that almost all programming languages allow for such operations. In C for example this operation is obtained using the asm command. In one embodiment minor modifications to SC back end algorithms may be required e.g. to handle binary conversion of the TISA assembler instructions . An example of such a process is depicted and described herein with respect to .

Although primarily depicted and described with respect to levels of granularity of TISA atomic operations in a JTAG architecture it will be appreciated by one skilled in the art that the same levels of granularity of TISA atomic operations may be utilized in other architectures that different levels of granularity of TISA atomic operations may be utilized in a JTAG architecture and or other architectures and the like as well as various combinations thereof.

As described hereinabove the TISA may be implemented using any suitable instruction set architecture ISA . For example the TISA may be implemented using the SPARC V8 ISA an INTEL ISA and the like.

For purposes of clarity in describing implementation of the TISA an exemplary implementation of the TISA using a SPARC V8 ISA is depicted and described herein with respect to . In this exemplary implementation the TISA is implemented as a Vector Level TISA which allows direct coding of the instructions that compose the SVF format however as described hereinabove it will be appreciated that implementation of the TISA using the SPARC V8 ISA also may be performed where the TISA is implemented as a TAP Level TISA or a Scan Segment Level TISA.

The SPARC V8 ISA is implemented in many products such as the open source soft processor family Leon 2 and Leon 3.

A review of The SPARC Architecture Manual Version 8 published by SPARC International Inc 1992 hereinafter SPARC Architecture Manual reveals that there are many code words not exploited by the SPARC V8 ISA. This is evident at least from a review of the opcodes and condition codes of Appendix F.

The SVF instructions allow for multiple parameters which need to be coded inside the final code. In order to represent the parameters and in the interest of the usual architectural best practice of keeping instruction and data separated register based parameter passing is defined for this exemplary implementation of a Vector Level TISA. Thus the Vector Level TISA presents six dedicated 32 bit registers GENERIC1 GENERIC2 TDI TDO MASK and SMASK. The six dedicated 32 bit registers are depicted in . The usage of the six dedicated 32 bit registers is described in detail hereinbelow but as a general rule these registers are used either to store a parameter or to point to the memory location in which a parameter is stored. Thus at compilation time normal ISA instructions can be used to load these registers before the TISA instruction is invoked. More specifically in this SPARC V8 ISA implementation of the TISA coprocessor registers may be used directly as parameters for the usual load store instructions.

The SVF instructions which may be utilized in this SPARC V8 ISA implementation of the TISA include ENDDR ENDIR STATE FREQUENCY PIO PIOMAP HDR HIR TDR TIR SDR SIR and RUNTEST. These SVF instructions may be better understood by way of reference to the Serial Vector Format Specification by ASSET InterTech Inc. 1997 hereinafter referred to as the SVF Manual which is herein incorporated by reference in its entirety. The use of these SVF instructions in this SPARC V8 ISA implementation of the TISA is described in more detail hereinbelow.

The ENDDR and ENDIR instructions indicate the TAP state at which the TAP interface ends its operation. The STATE instruction forces the TAP interface to a specified state. In this exemplary implementation of the TISA the SVF codings for the ENDDR ENDIR and STATE instructions are 000000 000001 and 000010 respectively as depicted in . The SVF coding of these SVF instructions may be performed using the TAP STATE file i.e. the exemplary bit coding of the TAP states as depicted in as needed. It will be appreciated at least from a review of the SVF Manual that the STATE instruction can optionally take the explicit sequence of states as parameters. In this exemplary implementation of the TISA taking the explicit sequence of states as parameters would be coded by a series of instructions one for each state in the sequence.

The FREQUENCY instruction is used to specify the working frequency of the TAP interface. The FREQUENCY instruction is expressed as a 32 bit integer of Hz cycles. In this exemplary implementation of the TISA the SVF coding for the FREQUENCY instruction is 000011 as depicted in . The value for the FREQUENCY instruction is stored in the GENERIC1 register.

The PIO instruction can be used to handle parallel vectors in a format previously set by a call to PIOMAP. In this exemplary implementation of the RISA PIOMAP is seen as a pre processor directive that generates the appropriate commands to set up the TAP interface. Thus the PIO instruction merely needs to express the parallel vector which can be expressed by indicating in the GENERIC1 register the address in which the parallel vector is stored. The number of words n that compose the vector is specified in bits of the instruction and thus the vector has an upper size limit of 2 8K words 32 Kbytes. If the vector size is not an exact multiple of a word padding and re alignment may be provided in memory as needed. In this exemplary implementation of the TISA the SVF coding for the PIO instruction is 000100 .

The roles of the HDR HIR TDR and TIR instructions are different. Here these SVF instructions are considered together because 1 these SVF instructions are functionally similar i.e. they all command shift operations even if they are of a different nature and 2 these SVF instructions accept the same parameters 

 4 MASK optional a mask to be used when comparing actual values with TDO. A 1 indicated a care a 0 a don t care and

 5 SMASK optional a mask to mark which bits are to be considered in TDI. 1 indicates a care 0 a don t care.

In this exemplary implementation of the TISA the SVF codings for the HDR HIR TDR and TIR instructions are 000110 000111 001010 and 001011 respectively as depicted in .

 2 O1 is 1 when TDI is present 0 otherwise. If set the TDI register contains the address at which the input vector is stored 

 3 O2 is 1 when TDO is present 0 otherwise. If set the TDO register contains the address at which the expected output is stored 

 4 O3 is 1 when MASK is present 0 otherwise. If set the MASK register contains the address at which the output mask is stored and

 5 O4 is 1 when SMASK is present 0 otherwise. If set the SMASK register contains the address at which the output mask is stored.

The SDR and SIR instructions have the same syntax as the HDR HIR TDR and TIR instructions but have a functional difference SDR and SIR trigger the actual scan operation on the TAP. In interactive testing the actual output vector read from the system is fundamental for the algorithm so the TISA offers the possibility of storing the actual output vector in memory. When the TAP STATE field bits as depicted in is different than zero the GENERIC2 register indicates the storage location of the actual output vector. Thus SDR and SIR can support a maximum of seven parameters. If TDO is specified and the actual output vector is different from the expected output vector an overflow flag is set in the Processor State Register PSR as described in Section 4.2 of the SPARC Architecture Manual.

The RUNTEST instruction forces the TAP interface to run a test at a specified state for a specified amount of time and is used mainly to control RUNBIST operations e.g. as defined in IEEE 1149.1 . The RUNTEST instruction accepts one or more of the following parameters all of which are optional 

In this exemplary implementation of the TISA the SVF coding for the RUNTEST instruction may be 000101 or 100101 .

 3 O2 1 if min count is specified 0 otherwise. If set the GENERIC1 register contains the 32 bit unsigned representation of min count 

 4 O3 1 if max time is set 0 otherwise. If set the GENERIC2 register contains the 32 bit unsigned representation of max count 

 6 Bits if run count is specified expressed as an unsigned integer max run count 2 1024 . If this field is not 0 then Bit indicates run clock 1 TCK 0 SCK .

Although primarily depicted and described herein with respect to use of specific SVF instructions in this SPARC V8 ISA implementation of the TISA i.e. namely ENDDR ENDIR STATE FREQUENCY PIO PIOMAP HDR HIR TDR TIR SDR SIR and RUNTEST it will be appreciated that fewer or more SVF instructions may be used.

Although primarily depicted and described herein with respect to an implementation of the TISA using the SPARC V8 ISA it will be appreciated that various other ISAs may be utilized to implement a TISA in accordance with the TISA teachings depicted and described herein.

In interactive testing approaches the data handoff point is quite important. As described hereinabove a test program is composed of two main portions the algorithmic portion as represented by the software compiler and the test access portion as represented by the test generation tool . During a test operation using a testing program there will be moments when the test program is accessing the system under test and moments when the test program is examining the testing results and deciding the next step s required. The hand off between these two operations is important for obtaining efficient interactive testing.

In existing script based approaches such as SVF and STAPL a script takes care of all TAP operations at the Vector Level. At this level the interface or player is able to communicate with the TAP protocol and send receive vectors to from the system under test. Furthermore STAPL also allows some basic flow control if then else and algorithmic operations on the bit vectors. If there is need for more sophisticated processing e.g. identifying a register inside a received vector or computing the vector to access a specific device the player hands control over to the algorithmic portion. In STAPL this is done through the export command. Disadvantageously however neither SVF nor STAPL has a standardized format for this e.g. in the case of STAPL the handoff process is usually proprietary to a given vendor .

In existing embedded approaches like Master Test Controller MTC from Ericsson and the System BIST Processor the same partitioning between the algorithmic portion and the test access portion is used. In such embedded approaches the algorithmic portion and the test access portion are executed by different coprocessors that must be programmed separately. Furthermore the memory spaces of the algorithmic portion and the test access portion are physically different such that the resulting handoff mechanisms are similar to the handoff mechanisms of STAPL. The result is that the coprocessor for the test access portion is forced to store a lot of scan operations before handoff to the algorithmic portion which given the increasing size of scan chains may require a huge amount of resources.

In contrast with existing approaches to integrated testing e.g. script based approaches such as SVF and STAPL and embedded approaches such as MTC and System BIST Processor the TISA integrates the test access portion i.e. the test operations inside the algorithmic portion i.e. the classical ISA such that the test access portion and the algorithmic portion share the same physical memory space thereby making handoff and thus data passing between the test access portion and the algorithmic portion automatic. In TISA handoff between the test access portion and the algorithmic portion is made at the instruction level such that the processor can freely mix scan and algorithm i.e. freely mix test operations and algorithmic operations as required according to the associated scheduling strategy.

In this exemplary implementation of the TISA using the SPARC V8 ISA all operations handling vectors use absolute addressing as described hereinabove with respect to the SVF instructions . As a result testing vectors may be used like normal variables inside the ISA program thereby making the interface between the test access portion and the algorithmic portion automatic. As an example based on the exemplary implementation of the TISA using the SPARC V8 ISA as described hereinabove the following steps exemplify an archetypical testing sequence 

 1 An SDR instruction is used to obtain testing output data from the system under test. The resulting output data is placed in a specific memory location e.g. the actual parameter in the GENERIC2 register 

 3 Once the output data is loaded in the register arithmetic operations and or logical operations may be used to process the output data note that since the SPARC V8 ISA is a load store architecture all data must be loaded into a register before being handled 

 5 An SDR instruction can send new testing input data to the TAP e.g. using the TDI parameter in the TDI register .

Note that the classical algorithmic operations 2 through 4 are standard for any ISA algorithm implementation and are not modified in any way by the TISA.

Thus from this simple example it is clear that TISA can be supported using any given algorithm or computer program with a natural and efficient hand off between the algorithmic portion and the test access portion.

In this exemplary implementation of the TISA using the SPARC V8 ISA absolute addressing is used for purposes of clarity in describing the TISA however one skilled in the art and informed by the teachings herein would be able to modify this exemplary implementation of the TISA to support all legal SPARC V8 addressing modes described in the SPARC Architecture Manual.

Although primarily depicted and described herein with respect to an exemplary implementation of the TISA in which SVF is used SVF was used in the exemplary implementation because it is a well known format proven to provide a complete even if basic handling of 1149.1 TAPs. It will be appreciated by one skilled in the art and informed by the teachings herein that the TISA may be implemented using any other suitable control formats many of which may allow finer grain control of the TAP state machine and support more sophisticated testing operations.

Although primarily depicted and described herein with respect to an exemplary implementation of the TISA in which the abstraction level is the Vector Level it will be appreciated by one skilled in the art and informed by the teachings herein that the exemplary TISA implementation depicted and described herein may be modified such that the abstraction level of the TISA is the TAP Level or the Scan Segment Level.

For purposes of clarity in describing the TISA an exemplary use of the TISA to perform testing on an exemplary system under test is depicted and described herein with respect to . In this exemplary use of the TISA the TISA is implemented as a Vector Level TISA using a SPARC V8 ISA and SVF i.e. in continuation of the exemplary implementation depicted and described with respect to .

The JTAG TAP provides test access to a system under test . The JTAG TAP provides test access to the system under test for sending input data to system under test and receiving output data from system under test . The JTAG TAP includes an instruction register IR which is an 8 bit instruction register.

The JTAG TAP is controlled by a testing system e.g. such as testing system depicted and described with respect to which is omitted for purposes of clarity .

The system under test includes a first board denoted as B and a second board denoted as B . The first board includes a transmitter denoted as T . The second board includes a receiver denoted as R . The transmitter sends data on a connection to receiver . In this example the connection is an 8 bit connection.

As depicted in each board is accessible from JTAG TAP via its own scan chain. Namely first board is accessible via a first scan chain and second board is accessible via a second scan chain . The first scan chain and second scan chain are selectable by the IR of JTAG TAP e.g. IR 0 selects first board B IR 1 selects second board B . The transmitter and the receiver are not alone on their boards rather they are part of wider scan chains e.g. for purposes of this example 24 bits and 16 bits respectively .

In a test program input data is sent to transmitter via the first scan chain and the resulting output data is collected from the receiver by exploiting the second scan chain . In order to perform an exhaustive test all possible values are sent through the connection such that 2 256 vectors are sent through the connection . Using C an exemplary program could be the following 

In this program line 2 includes the C module that is handling JTAG operations where the functions apply JTAG and Read JTAG used in lines 12 and 13 respectively are defined. The pre compiler of SC recognizes these functions and generates test operation description files for TGT . The format of the test operation description files may vary depending on the actual implementation of first board and second board . For example if first board and second board both are IJTAG compliant test operation description files could be specified for example using New Scan Description Language NSDL code. The TGT using test operation description files generates TGT atomic test operations which are translated by TISA translator into TISA atomic test operations . The TISA atomic test operations are provided to front end of SC . The TGT atomic test operations the associated TISA atomic test operations and the resulting TISA binary code are depicted in .

As depicted in the mapping from C commands to TISA coding is represented using a table having four columns a C command column an SVF instructions column a TISA assembler column and a TISA coding column . The table from left to right illustrates the manner in which a C command can be translated into an SVF instruction which can be translated into TISA assembler which can be coded into TISA binary coding.

The Apply JTAG value B.T command is translated into two SVF instructions SIR TDI 00 and SDR TDI value .

The Read JTAG value B.R command is translated into two SVF instructions SIR TDI 01 and SDR ACTUAL value .

The TISA coding of the SET operations is not specified because the SPARC V8 Manual identifies them as pseudo instructions which can have a different coding following the implementation of the processor.

Using the determined TISA codings the pre compiler may now substitute the high level JTAG accesses with their associated TISA assembler instructions. The result is the following code specified using C in which the calls to the JTAG TAP have been replaced by the associated TISA assembler coding 

This code can be input into the front end algorithms which will generate the program model . The program model can be input into the back end algorithms which will generate the executable TISA binary file s including the TISA atomic operations .

The TISA coding column of table depicts the binary coding of the TISA assembler instructions e.g. using the various rules defined with respect to the exemplary implementation of the TISA using a SPARC V8 ISA as depicted and described with respect to .

As described herein the TISA provides complete freedom regarding test granularity in performing testing of a system under test i.e. from TAP Level through Scan Segment Level . As depicted in and and further explained using the exemplary TISA implementation of and test patterns may be computed using explicit queries by the Software Compiler to the Test Generation Tool such that the only limit for the software algorithm is the resolution of the queries themselves.

As an example at a coarse level queries from the SC to the TGT may involve the entire scan chain of the system under test e.g. such as in classical BSDL based Boundary Scan testing .

As an example at a fine level queries from the SC to the TGT may involve registers or even bits. For example dedicated Scan Segment primitives could significantly accelerate instrument access and TAP reconfiguration boost code reuse and provide various other advantages.

As an example at a middle level somewhere between the coarse and fine levels queries from the SC to the TGT may be done functionally e.g. using standards such as IJTAG and other suitable standards and using description languages such as NSDL and other suitable object oriented description languages .

In this manner the TISA does not force device register access to be resolved at the model space i.e. in the TGT but rather allows developers to handle device register access at the problem space i.e. in the SC thereby enabling developers to adapt the analysis grain to their needs and to the available resources.

Furthermore in embodiments in which the TISA processor has sufficient resources e.g. such as in the case of Automated Test Equipment ATE at least a portion of the circuit model may be implemented within the program model thereby enabling the TISA machine to directly compute the vector patterns.

Furthermore the TISA enables support for various other system test capabilities not previously possible without TISA such as interactive testing including interactive debugging locally and or remotely concurrency portability and the like as well as various combinations thereof. These additional capabilities are now addressed in additional detail.

As depicted in TISA based testing environment includes a host computer HC a testing system TS and a system under test SUT .

The HC is configured to control TS for controlling testing of SUT . The HC includes a processor coupled to a memory . The processor and memory may be any suitable processor and memory.

The memory stores one or more debugger control programs . The debugger control program s enable HC to trace and where desired or necessary alter the execution of computer program s running on TS . For example debugger control program s may include one or more of the GNU Debugger GDB the dbx debugger the Perl debugger the Bash debugger the Python debugger and like suitable debugger programs as well as various combinations thereof.

The memory also may store one or more debugger display programs . The debugger display program s enable HC to display information associated with the debugger control program s . The information associated with debugger control program s may be displayed by debugger display program s in any suitable manner e.g. using one or more display devices . For example debugger display program s may include one or more of Insight which is a graphical user interface to GDB the Data Display Debugger DDD which provides a graphical user interface for various command line debuggers such as GDB and others and like suitable debugger display programs as well as various combinations thereof.

The TS is controlled by HC for purposes of testing SUT . The TS is configured to function in a manner consistent with the TISA e.g. such as depicted and described with respect to TS of . and further is configured to support interactive testing e.g. by enabling access by debuggers running on HC .

The TS includes a TISA processor coupled to a memory . The TISA processor may be implemented using any suitable processor such as SPARC V8 as depicted and described hereinabove with respect to and INTEL and the like. The memory may be any suitable memory.

The memory stores one or more debugger program stubs . The debugger program stubs understand the debugger protocol of the corresponding debugger control program s running on HC thereby enabling HC to communicate with TS . For example debugger stub s may include one or more of GDB stub a DBX stub a Perl stub a Bash stub a Python stub and like suitable debugger program stubs as well as various combinations thereof.

The memory stores TISA Binary Files . The TISA Binary Files are generated by TS in a manner as depicted and described herein with respect to and . The TISA Binary Files are executed by TISA processor to perform testing on SUT .

The TS also includes a Test Access Port TAP coupled to TISA processor . The TAP provides a test interface between TISA processor and SUT for enabling TISA processor to perform testing of SUT while being controlled by HC . The TAP may be any suitable TAP e.g. an 1149.1 TAP .

The TISA processor interfaces with TAP using an interface . The interface may be any suitable interface between a TAP and a system under test e.g. such as an interface that supports TCK TMS TDI TDO and optionally TRST where TAP is implemented as an 1149.1 TAP .

As depicted in there is an interface between HC and TS . The interface may support local communications and or remote communications between HC and TS . Thus HC may control interactive testing of SUT via TS locally and or remotely.

For example for local testing interface may be implemented as one or more of a Universal Asynchronous Receiver Transmitter UART interface serial interface and the like as well as various combinations thereof.

For example for remote testing interface may be implemented using any suitable communications capabilities such as Transmission Control Protocol TCP Internet Protocol IP or any other suitable communications protocols. This enables remote testing in which the HC and TS may be separated by large geographical distances and HC will still be able to control TS for purposes of performing testing of SUT .

In the TISA based testing environment the HC is able to control step by step test execution on SUT by controlling operation of TS via a standard connection e.g. UART TCP IP and the like thereby enabling interactive testing and debugging capabilities.

Although omitted for purposes of clarity it will be appreciated that HC and TS may include various other components such as additional processors additional memories internal communications buses input output modules additional support circuits e.g. power supplies and the like as well as various combinations thereof.

Although omitted for purposes of clarity it will be appreciated that SUT may be any system under test which may be tested using the TISA.

Although primarily depicted and described with respect to specific types of debugger control programs debugger display programs interfaces and the like it will be appreciated that TISA based testing environment may be implemented in a manner enabling fully interactive testing capabilities using various other debugger control programs debugger display programs interfaces and the like as well as various combinations thereof.

As depicted in exemplary TISA based testing environment of is an implementation of the TISA based testing environment of in which the GNU Tool Suite is used to support interactive testing of the exemplary system testing environment of .

As depicted in exemplary TISA based testing environment includes a host computer HC a testing system TS and a system under test SUT .

The HC includes a processor and a memory . The HC of is an implementation of HC of in which debugger control program s is implemented using GDB GDB and debugger display program s is implemented using DDD DDD .

The TS includes a TISA processor and a memory . The TS of is an implementation of TS of in which the TISA processor is implemented using a SPARC V8 ISA denoted as SPARC V8 TISA processor debugger program stub s is implemented using a GDB stub GDB stub and the TISA Binary Files are generated based on the SPARC V8 ISA associated with SPARC V8 TISA processor TISA Binary Files .

The TS also includes a Test Access Port TAP coupled to SPARC V8 TISA processor . The TS of is an implementation of TS of in which the TAP is implemented using a 1149.1 TAP 1149.1 TAP .

The SPARC V8 TISA processor interfaces with 1149.1 TAP using an interface . The interface is a standard 1149.1 interface that supports TCK TMS TDI TDO and optionally TRST.

The SUT is the SUT of . The SUT includes a transmitter and receiver on different boards as in SUT of .

The 1149.1 TAP provides a test interface between SPARC V8 TISA processor and SUT for enabling SPARC V8 TISA processor to perform testing of SUT while being controlled by HC .

As depicted in there is an interface between HC and TS . The interface may support local communications and or remote communications e.g. via a network between HC and TS . Thus HC may control interactive testing of SUT via TS locally and or remotely.

In the exemplary TISA based testing environment the HC is able to control step by step test execution on SUT by controlling the operation of TS via interface thereby enabling interactive testing and debugging capabilities.

It will be appreciated that most of the left hand side of reuses existing Computer Science elements namely the entire HC as well as the GDB stub on TS . It is the same for the central part of where analogies between HC and TS as well as their associated sub elements are evident. The TISA allows this entire infrastructure to be leveraged to provide system testing.

As an example in reference to the system test environment of including the associated exemplary C programs SVF instructions TISA assembler instructions and TISA codings there are many interactive test operations that the TISA can enable by leveraging on GDB or any other suitable debuggers such as a step by step execution while monitoring the variables sent value and received value b on the fly modification of the value to be sent to the tap variable sent value c modification of the looping end condition d monitoring of all variables and the like as well as various combinations thereof. These interactive test operations are standard operations for GDB and the TISA can directly use them due to the ability of the TISA to automatically hand off control between the algorithmic and test access portions as described hereinabove. In the absence of the TISA special tooling would need to be developed and adapted to each hand off implementation.

Although exemplary TISA based testing environment of is primarily depicted and described herein with respect to using the GNU Tool Suite to support interactive testing of a specific system under test it will be appreciated by those skilled in the art and informed by the teachings herein that interactive testing capabilities in a TISA based test environment may be realized using any suitable tool suites for testing any type of system under test.

Although TISA based testing environment of and exemplary TISA based testing environment of are primarily depicted and described herein with respect to linear test procedures where testing is done step by step following a pre determined algorithm for purposes of clarity in describing the interactive testing capabilities that are enabled by TISA it will be appreciated that other more complicated interactive testing scenarios are possible due to the leverage of Computer Science experience and techniques enabled by TISA. An example of a more complicated interactive testing scenario enabled by TISA is depicted and described herein with respect to . It will be appreciated that this is merely one example and that one skilled in the art and informed by the teachings herein may use TISA in many other interactive testing scenarios and applications.

As described herein in addition to supporting both granularity and interaction the TISA also supports concurrency.

The TISA naturally and fully merges the system testing flow with the computer science software flow and therefore can leverage the best aspects of both flows. As an example approaches such as STAPL have difficulty in handling concurrent control of instruments because such approaches are by definition fully sequential. Furthermore approaches such as the MTC and SystemBIST are intrinsically sequential and single task and thus it would be difficult and awkward to program such approaches to support concurrency. By contrast concurrent execution is a well known problem in Computer Science and is now for instance at the base of all operating systems. A large number of libraries supporting concurrent execution are available e.g. the POSIX suite the BOOST suite and the like and most modern processors are designed to efficiently support multi tasking and context switching e.g. the SPARC V8 for instance implements a rotating register window . The natural interaction between the system testing flow and the computer science software flow that is enabled by the TISA allows the TISA to completely leverage such computer science approaches to concurrency.

The support of concurrency capabilities by the TISA may be better understood by way of an example. As an example consider the problem of optimizing the data transfer rate of the T R channel between the transmitter and the receiver of the system under test of and . This would involve transmitting a stream of data patterns from transmitter on first board receiving a corresponding stream of data patterns at receiver on second board and comparing the transmitted and received streams of data patterns to compute bit error rates and to tune parameters of transmitter and or receiver accordingly. This optimization may be performed efficiently using three programs operating concurrently.

As depicted in exemplary program architecture includes a pattern generator a pattern receiver and a comparator . The pattern generator pattern receiver and comparator cooperate to optimize the data transfer rate of the T R channel between the transmitter and the receiver of the system under test of and .

The pattern generator sends the appropriate input data patterns to the transmitter T on first board . The pattern generator can access the TAP illustratively TAP in TAP in in order to provide the input data patterns to transmitter via the scan chain of first board B . The pattern generator may provide the input data patterns to the transmitter in any suitable manner e.g. as specified in lines 12 13 of the code described herein with respect to . The input data patterns may be any data patterns suitable for optimizing the T R channel between transmitter and receiver . For example the input data patterns may be pre computed patterns random patterns and the like as well as various combinations thereof.

The pattern receiver collects the appropriate output data patterns from the receiver R on second board . The pattern receiver can access the TAP illustratively TAP in TAP in in order to collect the output data patterns from receiver via the scan chain of second board B . The pattern receiver may collect the output data patterns from the receiver in any suitable manner e.g. as specified in lines 14 15 of the code described herein with respect to .

The comparator communicates with pattern generator and pattern receiver . The comparator compares the input data patterns and the output data patterns. The comparator evaluates the bit transmission rate and the bit error rate of the T R channel and based on the results of the comparison can access the control registers of both the transmitter and the receiver omitted from and for purposes of clarity to optimize the parameters of the T R channel.

In order to perform such an optimization testing procedure pattern generator pattern receiver and comparator need to work in parallel and each must be able to access the TAP independently of the others. This type of control structure is very difficult to code in traditional environments which are developed only to support one point serial handoff control over the TAP. This type of control structure also is very difficult to code in environments employing MTC or other such approaches which also share the same serial TAP access paradigm. By contrast the TISA is not designed with any such assumption regarding test access rather in the TISA test access is handled in a manner similar to other processor resources and test access instructions are mixed directly with classical ISA instructions. Using the TISA the optimization testing procedure of may be executed by any multitasking Operating System using standard constructs like processes threads inter process communications IPC and the like as well as various combinations thereof. In this manner pattern generator pattern receiver and comparator can share access to the TAP and can resolve any eventual TAP sharing issues as is done for all processor resources e.g. using well known constructs and algorithms such as for example Dijkstra s semaphores. Thus whereas existing system testing capabilities do not support concurrency it is clear that the TISA easily and fully supports concurrency.

As described hereinabove the TISA does not make any assumptions regarding the test access method or the associated test program partitioning rather test instructions are treated in the same manner or substantially the same manner as classical ISA instructions without any a priori separation between the two. This enables the TISA to be completely compatible with all existing and most likely future computer science algorithms and constructs something that no existing test processor approaches can support.

Thus it will be appreciated that any existing software libraries can be ported into the TISA architecture. For example it would be easy to obtain multitasking and concurrency e.g. as depicted and described herein with respect to by exploiting the POSIX and BOOST suites. Further it will be appreciated that where the TISA is obtained as a generalization of an existing ISA e.g. as depicted and described with respect to the exemplary SPARC V8 TISA implementation depicted and described with respect to the and porting may not even be necessary since the ISA that the TISA has been developed from will already include such software libraries.

Furthermore it will be appreciated that various other computer science techniques may be utilized for providing improved system testing using the TISA. For example some examples of such computer science techniques which may be leveraged for the TISA include a use of platform independent coding styles b use of ISA to ISA converters c use of a Virtual Machine approach e.g. like for Java to obtain platform independent bytecode or even extension of the Java Virtual Machine itself to become a TISA and d use of an Application Programming Interface API to standardize some TISA software interfaces which would then be translated into primitives by the appropriate drivers. It will be appreciated that these examples are merely a few examples of computer science techniques which may be leveraged for the TISA.

Although primarily depicted and described herein as being performed serially at least a portion of the steps of method may be performed contemporaneously or in a different order than depicted and described with respect to .

At step a first set of instructions is generated. The first set of instructions includes ISA instructions supported by the processor i.e. ISA instructions being leveraged to provide the TISA for the processor .

At step a second set of instructions is generated. The second set of instructions includes test instructions associated with the system under test. The second set of instructions may be generated in any suitable manner e.g. as depicted and described with respect to TGT of as depicted and described with respect to TGT of and or using any other suitable method of generating test instructions.

At step the first set of instructions and the second set of instructions are integrated to form thereby TISA instructions. The TISA instructions provide the TISA for the processor.

At step the TISA instructions are stored displayed propagated and or executed or any combination thereof. The TISA instructions may be handled in any other suitable manner.

The TISA may be formed in any suitable manner e.g. as depicted and described with respect to method of as depicted and described with respect to the test system of and associated method of as depicted and described with respect to the test system of and associated method of and or using any other suitable method of forming a TISA.

At step a first set of instructions is generated. The first set of instructions includes instructions generated by compiling at least one computer science software file e.g. ISA instructions of an ISA supported by a processor .

At step a second set of instructions is generated. The second set of instructions includes test instructions generated by compiling at least one description file associated with the system under test.

At step the first and second sets of instructions are combined to form a combined set of instructions. In the combined set of instructions the instructions of the first set of instructions are adapted for use in controlling execution of the test instructions of the second set of instructions.

At step the combined set of instructions is stored displayed propagated and or executed or any combination thereof. The combined set of instructions may be handled in any other suitable manner.

At step a program model is generated. The program model is generated by compiling at least one computer science software file e.g. ISA instructions of an ISA supported by a processor where the at least one computer science software file includes at least one call.

At step a first set of instructions is generated. The first set of instructions is generated using the program model. At least one computation request also is generated using the at least one call included in the at least one computer science software file.

At step a circuit model is generated. The circuit model is generated by compiling at least one system description file associated with the system under test.

At step a second set of instructions is generated. The second set of instruction is generated using the circuit model and the at least one computation request.

At step the first and second sets of instructions are combined to form a combined set of instructions. In the combined set of instructions the instructions of the first set of instructions are adapted for use in controlling execution of the test instructions of the second set of instructions.

At step the combined set of instructions is stored displayed propagated and or executed or any combination thereof. The combined set of instructions may be handled in any other suitable manner.

At step method ends. depicts one embodiment of a method for generating instructions adapted for use in testing at least a portion of a system under test. Although primarily depicted and described herein as being performed serially at least a portion of the steps of method of may be performed contemporaneously or in a different order than depicted and described with respect to . may be better understood by viewing it in conjunction with and the associated description of .

At step at least one pre processed computer science software file and at least one test operation description file are generated by pre processing at least one computer science software file.

At step a circuit model is generated. The circuit model is generated by compiling at least one system description file associated with the system under test and the at least one test operation description file.

At step a set of test operations is generated. The set of test operations is generated using the circuit model. The test operations from the set of test operations are described using a set of test primitives e.g. test primitives defined by a test generation tool which generates the circuit model . The set of test primitives includes test operations adapted for use in testing the system under test.

At step the set of test operations is translated into a set of test instructions by translating the test primitives of the set of test operations into test instructions adapted for use in combination with software instructions of an instruction set architecture.

At step a program model is generated. The program model is generated by compiling the at least one pre processed computer science software file and the set of test instructions.

At step a combined set of instructions is generated. The combined set of instructions is generated using the program model. The combined set of instructions includes a software instructions determined from the at least one pre processed computer science software file and b test instructions from the set of test instructions.

At step the combined set of instructions is stored displayed propagated and or executed or any combination thereof. The combined set of instructions may be handled in any other suitable manner.

The TISA processor may be any processor that is suitable for performing system testing using a TISA such as a SPARC V8 processor an INTEL processor or any other suitable processor.

The memory may include any memory suitable for use by TISA processor to support system testing using a TISA including one or more of random access memory persistent memory and the like as well as various combinations thereof. The memory may store any information required for performing system testing using a TISA such as test programs TISA instructions testing data and the like as well as various combinations thereof.

In one embodiment for example TISA processor architecture of may support the TISA flows depicted and described with respect to and .

In one embodiment for example TISA processor architecture of may operate in a manner similar to TISA processor and memory of testing system depicted and described with respect to . For example TISA processor architecture of may be implemented using a SPARC V8 TISA processor and associated memory such as in the testing system depicted and described with respect to . In such an embodiment the TISA processor itself interprets and executes both the ISA and TISA instructions.

In one embodiment an apparatus for use in testing at least a portion of a system under test via a Test Access Port TAP includes a memory for storing a set of instructions of a test instruction set architecture and a processor executing the set of instructions of the test instruction set architecture for testing at least a portion of the system under test via the TAP. The set of instructions of the test instruction set architecture includes a first set of instructions comprising a plurality of instructions of an Instruction Set Architecture ISA supported by the processor and a second set of instructions comprising a plurality of test instructions associated with the TAP where the instructions of the first class of instructions and the instructions of the second class of instructions are integrated to form thereby the set of instructions of the test instruction set architecture.

In one embodiment a TISA processor for use in testing at least a portion of a system under test via a Test Access Port TAP includes a first class of instructions including instructions of an Instruction Set Architecture ISA supported by the processor and a second class of instructions including test instructions associated with the TAP wherein the ISA instructions of the first set of instructions and the test instructions of the second set of instructions are integrated to form a TISA adapted for testing at least a portion of the system under test.

In one embodiment a computer processor for testing a system under test SUT via a Test Access Port TAP includes circuitry configured to process instructions according to a test instruction set architecture TISA having semantics that enable interaction with the system under test via the TAP. The TISA includes a plurality of instructions of a first type and a plurality of instructions of a second type where the first type of instructions include instructions of an instruction set architecture ISA supported by the computer processor and the second type of instructions include test instructions for testing the system under test via the TAP.

Although primarily depicted and described hereinabove with respect to embodiments in which the TISA processor is defined in a particular manner e.g. using particular language to describe different classes and or types of instructions it will be appreciated that a TISA may be defined in other ways that are fully supported by the depiction and description of various TISAs as provided herein.

Although primarily depicted and described herein with respect to embodiments in which the TISA processor architecture is implemented using a single processor to support the TISA in other embodiments the TISA processor architecture may be implemented using multiple processors.

As depicted in test processor architecture includes a primary processor and a secondary processor in communication via a communication path .

The primary processor may be any processor suitable for supporting system testing such as a SPARC V8 processor an INTEL processor or any other suitable processor. The primary processor executes instructions for testing a system under test. In one embodiment for example primary processor may support testing functions similar to the functions supported by CPU of TISA processor architecture of e.g. where test processor architecture utilizes a TISA . In one embodiment for example primary processor may support testing functions supported by testing processors in test processor architectures that do not utilize a TISA. The primary processor may support various other testing capabilities.

The secondary processor may be any processor suitable for supporting system testing such as a SPARC V8 processor an INTEL processor or any other suitable processor. The secondary processor supports a Test Access Port TAP interface to the system under test which is omitted for purposes of clarity . The TAP interface may interface with any suitable TAP. For example the TAP interface may provide an interface to an IEEE 1149.1 TAP or any other suitable TAP which may be used for testing a system under test.

The primary processor and secondary processor cooperate to perform testing of at least a portion of a system under test.

The primary processor executes test instructions for testing a system under test. The test instructions may be test instructions of a TISA where test processor architecture utilizes a TISA or test instructions not associated with a TISA where test processor architecture does not utilize a TISA . The primary processor during execution of the test instructions detects instructions related to control of the TAP of the system under test e.g. such as instructions for loading input data to a TAP controller of the system under test instructions for reading output data from a TAP controller of the system under test and like instructions as well as various combinations thereof . The primary processor provides the TAP related instructions to secondary processor . The secondary processor receives the TAP related instructions from primary processor . The secondary processor executes the TAP related instructions. The primary processor continues executing test instructions while secondary processor executes the TAP related instructions received from primary processor . In this manner primary processor may perform a context switch and continue operating while secondary processor controls scan operations via the TAP of the system under test. This is difficult using a single processor approach because while the single processor is controlling the TAP the single processor is prevented from performing other operations. Therefore the use of multiple processors as in the test processor architecture provides a significant improvement in testing efficiency without a need to use high end processors especially considering that operations over the TAP typically take a long time compared to the time required for a processor to perform a single operation.

The cooperation between primary processor and secondary processor to perform testing of at least a portion of a system under test is facilitated by communication path . The communication path may be implemented using any suitable means of communication between primary processor and secondary processor which may depend on the type of multi processor architecture with which the test processor architecture is implemented. For example communication path may include one or more of a main processor interface bus an auxiliary processor interface a communication interface e.g. such as a serializer deserializer SERDES interface or other suitable communication interface and the like as well as various combinations thereof.

Although omitted for purposes of clarity it will be appreciated that the test processor architecture will include memory e.g. random access memory persistent memory cache memory and the like as well as various combinations thereof . The memory of test processor architecture may include one or more of memory shared by primary processor and secondary processor memory dedicated to primary processor memory dedicated to secondary processor and the like as well as various combinations thereof.

Although omitted for purposes of clarity it will be appreciated that the test processor architecture may include various other support circuits such as buses I O circuits and the like as well as various combinations thereof.

In one embodiment for example the test processor architecture may use a test co processor unit architecture in which a central processor unit CPU cooperates with a test co processor unit TCPU in order to support system testing. An exemplary embodiment is depicted and described with respect to .

In one embodiment for example the test processor architecture may use a test adjunct processor unit architecture in which a central processor unit CPU cooperates with a test adjunct processor unit TAPU in order to support system testing. An exemplary embodiment is depicted and described with respect to .

The test co processor architecture includes a central processor unit CPU a test co processor unit TCPU a main memory and a flash memory .

The test co processor architecture includes a main processor interface bus . The CPU TCPU main memory and flash memory each are coupled to or otherwise configured to be able to communicate with the main processor interface bus .

The test co processor architecture also may include an auxiliary processor interface which directly couples CPU and TCPU thereby enabling direct communications between CPU and TCPU .

The CPU may be any CPU suitable for performing system testing of a system under test. The CPU supports testing capabilities supported by primary processor depicted and described with respect to .

The TCPU may be any CPU suitable for facilitating system testing of a system under test. The TCPU supports a Test Access Port TAP interface which may interface with any suitable TAP e.g. such as an IEEE 1149.1 TAP or any other suitable TAP used for testing a system under test . The TCPU supports testing capabilities supported by secondary processor depicted and described with respect to .

The CPU and TCPU cooperate to perform testing of at least a portion of a system under test in a manner similar to primary processor and secondary processor depicted and described with respect to . The CPU and TCPU utilize instruction exception handling in order to enable CPU to continue operating to process test instructions while TCPU executes TAP related instructions for controlling the TAP of the system under test during testing.

The CPU executes test instructions for testing a system under test. The CPU during execution of the test instructions detects instruction exceptions i.e. instructions related to control of the TAP of the system under test and provides the instruction exceptions to TCPU . The TCPU receives the instruction exceptions from CPU and processes the instruction exceptions such that the TCPU may handle the instruction exceptions while CPU continues to operate to perform other tasks e.g. executing other testing instructions . In other words CPU and TCPU cooperate during system testing such that CPU may switch context and continue to operate to perform other tasks while TCPU handles instruction exceptions detected by CPU thereby improving system testing efficiency.

In one embodiment the TCPU includes a direct memory access DMA unit which may be any type of DMA unit suitable for use in support system testing. In one embodiment for example DMA unit is a scatter gather SIG DMA unit. The TCPU may utilize DMA unit for purposes of handling instruction exceptions received from CPU and for efficiently accessing sensible data stored in memory. In one embodiment CPU may configure S G DMA tables prior to encountering an instruction exception.

In one embodiment the TCPU supports a set of specialized TCPU instructions. The set of specialized TCPU instructions may support TAP access and control. The set of specialized TCPU instructions may be used by TCPU to perform specific TAP operations on the TAP State Machine.

The CPU and TCPU utilize main memory and or flash memory for performing various testing functions such as execution of test instructions by CPU instruction exception handling by TCPU execution of TCPU instruction by TCPU and the like as well as various combinations thereof. The main memory may be any suitable processor memory. The flash memory may be any suitable flash memory or any other suitable form of persistent memory. The CPU and TCPU share the memory with arbitrated access. The CPU and TCPU also may share the memory for purposes of exchanging information. Although primarily depicted and described with respect to specific numbers and types of memory it will be appreciated that various other memory schemes may be used for supporting the functions performed by CPU and TCPU .

The CPU and TCPU perform testing of the system under test using communication between CPU and TCPU and communication between CPU and or TCPU and other components of test co processor architecture e.g. main memory flash memory and other components and the like as well as various combinations thereof. The communications may be supported using one or both of the main processor interface bus and the auxiliary processor interface . The communications between CPU and TCPU may include communications associated with instruction exception notification interrupt access DMA arbitration and the like as well as various combinations thereof. The communications between CPU and TCPU and other components of the test co processor architecture may include communications associated with reading from memory writing to memory and or any other tasks which may be performed in support of testing the system under test.

The test adjunct processor architecture includes a central processor unit CPU and a test adjunct processor unit TAPU . The CPU and TAPU may reside on the same board or may reside on different boards.

The CPU may be any CPU suitable for performing system testing of a system under test. The CPU supports testing capabilities supported by primary processor depicted and described with respect to .

The CPU has a main memory a flash memory and an input output module associated therewith. The CPU has a main processor interface bus associated therewith. The CPU main memory flash memory and input output module each are coupled to or otherwise configured to be able to communicate with the main processor interface bus .

The TAPU may be any CPU suitable for facilitating system testing of a system under test. The TAPU includes an input output module . The TAPU supports a Test Access Port TAP interface which may interface with any suitable TAP e.g. such as an IEEE 1149.1 TAP or any other suitable TAP used for testing a system under test . The TAPU supports testing capabilities supported by secondary processor depicted and described with respect to .

The TAPU has a local test memory associated therewith. The TAPU has an internal interface bus associated therewith. The TAPU and local test memory each are coupled to or otherwise configured to be able to communicate with the internal interface bus .

The input output module associated with CPU and the input output module of TAPU support a communication interface enabling communications between CPU and TAPU . The communication interface supports streaming of TAP related commands from CPU to TAPU .

In one embodiment the input output module associated with CPU and the input output module of TAPU support Serializer Deserializer SERDES communications capabilities and therefore the communications interface is a SERDES based communications interface. In this embodiment the SERDES based communications interface may be implemented using any suitable SERDES communications protocol e.g. such as Gigabit Ethernet GigE Serial Rapid IO SRIO Peripheral Component Interconnect Express PCIe and the like . Although primarily depicted and described herein with respect to using SERDES based communications between the CPU and the TAPU other suitable communications capabilities may be used in order to support communications between CPU and TAPU .

The CPU and TAPU cooperate to perform testing of at least a portion of a system under test in a manner similar to primary processor and secondary processor depicted and described with respect to . The CPU and TAPU utilize command streaming via the communication interface in order to enable CPU to continue operating to process test instructions while TAPU executes TAP related instructions for controlling the TAP of the system under test during testing.

The CPU executes test instructions for testing a system under test. The CPU during execution of the test instructions detects instructions related to control of the TAP of the system under test. The CPU propagates the TAP related instructions to the TAPU via the communication interface i.e. from CPU to input output module via the main processor interface bus for propagation via communication interface . The TAPU receives the TAP related instructions from CPU and processes the TAP related instructions such that the TAPU may handle control of the TAP while CPU continues to operate to perform other tasks e.g. executing other testing instructions . In other words CPU and TAPU cooperate during system testing such that CPU may switch context and continue to operate to perform other tasks while TAPU handles TAP related instructions detected by CPU thereby improving system testing efficiency.

In one embodiment the TAP related instructions detected by CPU and processed by TAPU are packetized by the CPU for propagation to TAPU .

In one embodiment the TAP related instructions detected by CPU and processed by TAPU include opcodes supported by TAPU . In one such embodiment the TAP related instructions also may include one or more extension commands adapted for use in performing block memory copies between memory associated with the CPU and memory associated with the TAPU e.g. between main memory and local test memory .

The CPU utilizes main memory and or flash memory for performing various testing functions such as execution of test instructions detection of TAP related instructions packetization of TAP related instructions and the like as well as various combinations thereof. The main memory may be any suitable processor memory. The flash memory may be any suitable flash memory or any other suitable persistent memory.

The TAPU utilizes local test memory for performing various testing functions such as storage of TAP related instructions received from CPU processing of TAP related instructions received from CPU and the like as well as various combinations thereof. The local test memory may be any suitable processor memory. In one embodiment the local test memory may be relatively small since it handles processing of scan chain segments of the scan chain of the system under test rather than the entire scan chain as may be required in an on chip memory .

Although primarily depicted and described with respect to specific numbers and types of memory it will be appreciated that various other memory schemes may be used for supporting the functions performed by CPU and TCPU .

Although primarily depicted and described herein with respect to use of a co processor architecture or an adjunct processor architecture to implement the TISA it will be appreciated that the TISA may be implemented using any suitable processor architecture which may include processor architectures other than the co processor architecture or the adjunct processor architecture. Thus the TISA processor architecture may be implemented using multiple processors in various other ways at least some of which may include use of more than two processors for supporting the TISA.

Although primarily depicted and described herein with respect to use of the co processor architecture or the adjunct processor architecture in order to implement the TISA architecture it will be appreciated by one skilled in the art and informed by the teachings herein that the co processor architecture and the adjunct processor architecture each may be used to implement other types of testing architectures i.e. other testing architectures that do not employ TISA .

It will be appreciated that the test co processor architecture and the test adjunct processor architecture are functionally similar in that each enables a TISA to be executed by two communicating processors. In a given application the choice between the two architecture may be made by the designer on the basis of implementation dependent parameters such as available resources costs performances physical constraints integration in the same chip in different chips and or boards or any combination thereof as well as any other implementation parameter. Although primarily depicted and described herein with respect to test co processor and test adjunct processor architectures it will be appreciated by one skilled in the art and informed by the teachings herein that these implementation considerations will apply to any other types of testing architectures infrastructure.

The TISA processor architectures depicted and described herein may employ any suitable TISA for use in performing system testing.

A description of one exemplary embodiment of a TISA adapted for use with the TISA processor architectures follows. This exemplary embodiment of a TISA is an implementation of Scan Segment Level primitives depicted and described herein. In a Scan Segment Level abstraction level the overall scan chain of the system under test is divided into segments which are then used as the data atom of the algorithm. It will be appreciated that the system under test may be partitioned into the scan segments by the algorithm developer which may be a human and or an automated tool. A more general description of the use of TISA to enable scan operations to be performed at the Scan Segment Level i.e. a description that is independent of this exemplary TISA implementation is provided detail hereinbelow.

The following embodiment of a TISA proposes a set of registers and instructions able to define and handle those scan segments. The following embodiment is based on a 32 bit sized TISA but it could be adapted to any other word size e.g. 16 bit 64 bit or any other suitable word size .

As depicted in the third register set R includes the following Scatter Gather Segment Descriptions registers 

As depicted in the fourth register set R includes the following MultiBlock Scatter Gather Segment Descriptions registers 

It will be appreciated that the exemplary TISA register sets may be modified in any suitable manner. For example each of the exemplary register sets may be modified to include fewer more and or different registers. For example the exemplary registers may be regrouped into fewer more and or different sets. For example fewer more and or different register sets may be used. In other words the exemplary TISA register sets may be replaced with any other TISA register set s suitable for use with TISA instructions sets to implement a TISA processor architecture.

The exemplary TISA may employ any suitable TISA instruction set i.e. command dictionary for use in performing system testing.

The exemplary TISA instruction set includes the following opcodes which may be utilized to manipulate register sets R through R depicted and described with respect to as well as the original ISA register sets depicted and described herein 

The exemplary TISA instruction set includes the following register modification instructions that use explicit values 

The exemplary TISA instruction set includes the following register modification instruction that use implicit values 

The exemplary TISA instruction set includes the following instructions for extending support for streaming for an embodiment using the adjunct processor architecture 

It will be appreciated by one skilled in the art and informed by the teachings herein that various other TISA implementations may be used with the TISA processor architectures depicted and described herein. For example other TISA implementations may use fewer more and or different registers may use fewer more and or different instruction sets and the like as well as various combinations thereof. In one embodiment other TISA implementations may be utilized where different processor architectures are used in order to provide TISA implementations better suited to specific applications and or for any other suitable reasons.

As described hereinabove use of TISA in a JTAG architecture enables scan operations to be performed at the Scan Segments Level which allows the definition of independently controllable scan segments inside the overall scan path thereby providing a flexible and powerful set of primitives that can be used to define scan operations directly in the problem space and resolve the scan operations at implementation time.

In general JTAG operations are based on the scan operation in which all bits are scanned in serially one by one while at the same time bits are being scanned out serially one by one. This means that in order to be able to perform a scan operation knowledge of which value is needed for each bit in the scan chain i.e. the input and output vectors is required. TGTs typically provide this capability for traditional structural testing by computing the required vectors from a system model obtained through description languages such as BSDL. Additionally formats like SVF and STAPL mirror this as they allow the user to manipulate those vectors. While testing in this manner is sufficient for structural and other types of testing testing in this manner is highly inefficient for interactive setups in which there is no real need to access the whole scan chain. The inefficiency may be seen by considering an example.

For example consider a scan chain composed of 100 instruments each one having 16 bits. If the user needed to write 0x1234 in the registers of the 76instrument in the scan chain the TGT would need to generate the vector for the whole scan chain 100 16 1600 bits and send it to the TAP interface to be input into the scan chain. Similarly if the user wanted to read the associated output the TGT would need to receive the entire 1600 bit vector before being able to extract the desired output information. In this example the fact that a majority of the scan bits are useless is not important as scan efficiency is not one of the goals rather in this example the goal is primarily to be able to efficiently access one particular entity of the scan chain .

This type of approach is a problem at least for the following reasons a there is the computational need of handling long vectors e.g. lots of memory transfers have a high impact on performances b there is a need to store the entire vector s in memory which may be a problem for long chains c memory storage is not limited to data inputs and data outputs but also includes expected data input and output mask and the like thereby multiplying memory requirements which are already potentially strained just from the input and output data and d the transformation from instrument vector instrument must be made each time which demands computational power and time .

The Scan Segments Level abstraction level is a powerful tool for providing efficient access to individual entities or groups of entities of the scan chain of a system under test without any special emphasis on scan efficiency even if of course still enabling it if needed .

In one embodiment Scan Segments Level abstraction is implemented by decomposing a scan chain into a succession of segments and defining one or more scan operations on each of the segments. The scan chain is composed of a plurality of elements and each segment includes at least one of the elements of the scan chain. The elements may be defined at many levels of the system under test e.g. elements may be devices instruments registers segments of a register and the like as well as various combinations thereof and thus that the segments into which the scan chain is decomposed may be defined at many levels of the system under test e.g. segments may include one or more devices a portion of a device s one or more instruments a portion of an instrument s one or more registers a portion of a register s one or more register segments and the like as well as various combinations thereof . In this manner a segment may represent the smallest control unit of the scan chain.

In one embodiment decomposition of a scan chain into segments may be hierarchical. For example the scan chain may be decomposed into segments at least some of which may be composed by sub segments at least some of which may be composed by sub segments and so forth. In this manner the hierarchical decomposition of the scan chain may be viewed as having a tree based structure in which a segment may be composed of other segments. In one such embodiment the segments at the leaves of the tree may be referred to as segments in that they represent the smallest control unit of the scan chain which the segments located above the leaves of the tree may be referred to as super segments. It will be appreciated that in one embodiment one or more of the segments of the scan chain may be composed of virtual sub segments which are controllable but only in a manner that is transparent to the user system. The hierarchical decomposition of a scan chain may be defined in any other suitable manner.

The use of segmentation enables definition of entities for types of segments and or types of segment combinations. An entity is a generic description of a type of target which is valid for and may be reused for each physical instance of that type of target. For example an entity may define a description of a device a group of devices a portion of a device an instrument a group of instruments a portion of an instrument and the like as well as various combinations thereof. Thus since a scan chain may be decomposed such that segments of the scan chain include specific elements or combinations of elements entities may be defined for respective segments and or respective combinations of segments of a scan chain. For example where a scan chain is decomposed such that a segment includes an instrument an entity may be defined for that type of segment i.e. each segment including that type of instrument such that the entity may be reused for each physical instance of that type of segment in the scan chain. Similarly for example where a scan chain is decomposed such that a segment includes multiple instruments an entity may be defined for that type of segment i.e. each segment including that type combination of instruments such that the entity may be reused for each physical instance of that type of segment in the scan chain. This enables additional features and functions to be supported as described below.

The use of segmentation allows an entity i.e. a description of a type of segment under control to be correlated with a physical protocol that is used to communicate with the entity. As a result description languages e.g. such as NSDL P1687 IJTAG PDL and the like could be written specifically for the entity and the connectivity description portion e.g. the structure of the NSDL or the IJTAG HDL would describe the ordering of the segmentation instructions.

TISA provides a reusable modularity that can be defined once for all occurrences of a particular entity type as the TISA instructions are segment based operations rather than model based operations. Thus since TISA is both modular and autonomous for the entity under test in a particular segment TISA provides significant advantages over existing architectures.

TISA enables a direct mapping of the Test Data Register definition into a reusable and portable module that may be plugged into the execution flow at any point in the scan process in any order that is necessary without needing to define the entire connectivity as a static model up front as existing tools require. TISA enables integration of the port signal interfaces that are non scan with the scan operations as a single solution space architecture based on a unified control flow and standard computer science techniques providing significant advantages over solutions in which native language constructs are used to provide access to non scan operations .

TISA enables reuse of instruction sequences for multiple instances of the same entity thereby enabling a reduction in code storage requirements in the system. For example a generalized function which maps to description language functions which are called by a managing program may be written. In this example each of the functions are methods of native language objects that represent the entity and there may be separate instances of these objects for each entity defined in the system but there could be a single copy of code used to communicate with each of these instances. In this manner the native language implementation models directly control the description language used to specify the connectivity and functionality of the circuit.

In reference to the example given above use of Scan Segments Level abstraction would enable definition of three segments as follows segment S including instruments through segment S including the instrument and segment S including instruments through . In this manner access to instrument is greatly simplified. For example access to instrument could be obtained by making a dummy shift e.g. ScanBlockZero for segment S executing the instruction s for segment S i.e. instrument making another dummy shift for segment S and then terminating with an update. In such a sequence access to segment S i.e. to a specific instrument in the scan chain is provided without a need of any knowledge of segment S or segment S apart from their length. It will be appreciated that this is merely one example and thus that other decompositions of the 100 instrument long chains are possible to enable access to other instruments or instrument groups.

The exemplary SUT includes four devices collectively devices and denoted in as Device Device Device and Device respectively . The devices are arranged serially within SUT to form a scan chain . The scan chain is as follows the TDI of the TAP is connected to the input port of device the output port of device is connected to the input port of device the output port of device is connected to the input port of device the output port of device is connected to the input port of device and the output port of device is connected to the TDO of the TAP.

In the exemplary SUT each of the devices includes 1 an input de multiplexer providing inputs to a test instruction register TIR and a test data register TDR and 2 an output multiplexer for collecting outputs from the TIR and the TDR. The TIR and TDR of each device are parallel registers. The device includes one additional TDR such that the input de multiplexer provides inputs to one TIR and two TDRs and collects outputs from the one TIR and the two TDRs where the one TIR and two TDRs are all in parallel. The TIRs and TDRs each are depicted as serial shift registers each including nine associated elements e.g. flip flops . In this manner a the TIRs form one scan chain denoted as an test instruction scan chain that includes thirty six serial elements and b the TDRs form another scan chain denoted as a test data scan chain that includes forty five total elements and thirty six serial elements i.e. because the two TDRs of device are in parallel .

In the exemplary SUT the test instruction scan chain has been decomposed into four segments follows a first segment SI which includes the nine elements of the TIR of device a second segment SI which includes the nine elements of the TIR of device a third segment SI which includes the nine elements of the TIR of device and a fourth segment SI which includes the nine elements of the TIR of device . In this manner the testing system may access any of the TIRs of SUT individually or in combination with minimal knowledge of the other TIRs of SUT other than the number of elements of which they are composed .

In the exemplary SUT the test data scan chain has been decomposed into six serial segments seven total segments as follows a first segment SD that includes the nine elements of the TDR of device a second segment SD that includes the nine elements of the TDR of device a third segment SD that includes either the nine elements of the first TDR of device denoted as sub segment SD. or the nine elements of the second TDR of device denoted as sub segment SD. where these are counted as separate segments for purposes of counting the total number of segments and a fourth segment which is further decomposed into three serial sub segments as follows a first sub segment that includes the first three elements of the TDR of device denoted as sub segment SD. a second sub segment that includes the next four elements of the TDR of device denoted as sub segment SD. and a third sub segment that includes the last two elements of the TDR of device denoted as sub segment SD. . In this manner the testing system may access any of the TDRs of SUT or even sub portions of the TDR of device individually or in combination with minimal knowledge of the other TDRs of SUT other than the number of elements of which they are composed .

It will be appreciated that SUT of is merely one example of the manner in which the scan chain s of a system under test may be decomposed for use in providing Scan Segments Level abstraction. Although depicted and described herein with respect to specific types numbers and arrangements of elements components and the like it will be appreciated that a system under test for which a scan chain s is decomposed may be include various other types numbers and or arrangements of elements components and the like.

As described herein decomposition of the scan chain of a system under test enables scan operations to be defined on the segments thereby improving testing efficiency. A method according to one embodiment for generating a set of instructions including scan operations for segments of a decomposed scan chain is depicted and described herein with respect to .

A more detailed example of scan decomposition and generation of scan segment operations is provided follows.

As a general example consider a scan chain that includes three boards where each board includes a segment denoted as segments A B and C associated with a first board a second board and a third board respectively . In this example where the scan segments are hierarchical the segment A on the first board may be composed of a plurality of sub segments e.g. sub segments Athrough A the segment B on the second board may be composed of a plurality of sub segments e.g. sub segments Bthrough B and or the segment C on the third board may be composed of a plurality of sub segments e.g. sub segments Cthrough C .

As a more specific example following the application and the SUT a segment could be one or more registers inside an instrument an instrument a cluster of registers one or more boards and the like as well as various combinations thereof.

The overall scan operation is therefore decomposed in a series of segment scan operations. As a result all that is required in order to obtain the final scan chain operation is a series of simple atomic operations. Thus the embodiments of Scan Segments Level abstraction while not exclusively limited to are especially effective in implementations in which the atomic test operations are treated like processor operations e.g. such as in the various TISA implementations depicted and described herein or in any other similar implementations in which atomic test operations are treated like processor operations .

In such embodiments of Scan Segments Level abstraction the actual implementation of the Scan Segments Level scan operations may require that one or more technological constraints linked to JTAG be addressed. For example constraints such as the need to define the state of the TAP machine and the risk of using the Pause DR state not always implemented among others may need to be addressed.

In order to identify instrument segment outputs in the output bitstream received via the scan chain based on the position of the instrument segment in the scan chain the scan chain may be treated as a first in first out FIFO system given its serial nature such that the first segment that is scanned in is also the first segment that is scanned out as it is closest to the end of the scan chain .

In order to make the SUT experience the sequence of scan segment operations like a single scan operation the TCK may be frozen between segment operations. As all elements inside the scan chain are synchronous the effect of freezing TCK in this manner is that the scan chain is frozen together with TCK.

The use of Scan Segments Level in a TISA based testing system may be better understood by way of a few examples In the examples that follow assume that a system under test SUT is composed of three segments denoted as A B and C in that order and that a user needs to write a value V inside of segment B.

As a first example assume that the three segments of the system A B and C are implemented inside the same JTAG device. In this first example once the three segments are defined in memory the TISA operations would become 

With respect to the first example keeping the TAP Finite State Machine FSM in the ShiftDR state ensures that there is no update on the scan chain. This may be seen from the first example in which keeping the TAP FSM in the ShiftDR state from step i to step ix ensures that there is no update on the scan chain given that the UpdateDR State will be reached only once leaving ShiftDR.

Further with respect to the first example the scan clock TCK is active only during the scan operations i.e. steps iii vi and ix and is frozen in the remaining states. The effect is that the SUT from the point of view of the SUT based on operations synchronous with TCK will see steps iii vi and ix as a continuous bitstream.

Further with respect to the first example the bypass sequence is a property of the scan segment and can be for instance a given sequence all zeros all ones or any other suitable sequence or don t care where it is up to the TGT to decide such sequence.

As a second example assume that the three segments of the system A B and C are implemented on different JTAG devices in one or more cards . In this second example once the three segments are defined in memory the TISA operations would become 

In comparing the first example and the second example it will be understood that the additional complexity associated with the second example comes from the need to use the Instruction Register IR of each JTAG device to select deselect the segments. In that case unused segments are directly taken out of the chain by putting the related JTAG device in the BYPASS mode of the 1149.1 standard as indicated in steps iii and xvii of the second example .

It will be appreciated that all compositions of the above two examples are possible with any number of segments defined on one or more JTAG devices. It will be further appreciated that the above two examples are merely examples provided for the purpose of illustrating use of the Scan Segments Level for testing a system under test and thus that embodiments in which the Scan Segments Level is used for testing a system under test are not intended to be limited by these examples.

In such embodiments the actual sequence of TISA instructions can have multiple origins including one or more of the following 1 the TISA instructions may be statically computed by the TGT in which case each time the user wants to access a segment the entire chain must be scanned it will be appreciated that while this solution is not optimized for scan time it can be useful for embedded systems with limited computational resources and little or no time constraints 2 the TISA instructions may be issued by a software scheduler which receives access requests and composes them into scan operations and or 3 the TISA instructions may be issued by a hardware scheduler e.g. such as but not limited to what is done for instruction reordering and bypass in some high performance processors . It will be appreciated that TISA instructions associated with Scan Segments Level control may be issued in any other suitable way which may include a combination of the methods described above and or one or more other suitable methods which may be used in place of or in addition to one or more of the methods described above.

The Scan Segments Level abstraction level is a powerful tool for handling dynamic topologies such as the ones proposed by the IEEE P1687 standard and other dynamic topologies. If a section of the scan chain can be taken in and out the active scan path e.g. using an SIB cell proposed by the IEEE P1687 standard or any other suitable hierarchy enabling component s that section can be marked as one or more segments. The testing scheduler then has knowledge from the system state as to whether or not this segment s is active and therefore if the segment should be included in the TISA instruction scheduling. It will be appreciated by those skilled in the art and informed by the teachings herein that this principle also may be used for other dynamic elements such as hot swap boards e.g. by detecting their presence from a status register or any other suitable dynamic elements.

Although primarily depicted and described herein as being performed serially at least a portion of the steps of method may be performed contemporaneously or in a different order than depicted and described with respect to .

At step the scan chain is decomposed into a plurality of segments. The scan chain is composed of a plurality of elements and each segment includes at least one of the elements of the scan chain. The scan chain may be decomposed into segments in any suitable manner as described hereinabove. As described herein decomposition of the scan chain into segments may be applied anywhere in the development flow e.g. by the test developer by the test generation tool by an embedded circuit model and the like .

At step a set of instructions is generated. The set of instructions includes processor instructions associated with an ISA and test instructions for testing the portion of the system under test. The test instructions include for each of the segments of the scan chain at least one scan operation to be performed on the segment. The test instructions may be any type of test instructions such as conventional test instructions test instructions of a TISA and the like and thus may be generated in any suitable manner. The set of instructions may be generated in any suitable manner e.g. in a manner the same as or similar to as depicted and described hereinabove respect to

At step the set of instructions is executed for testing the portion of the system under test. The set of instructions may be executed in any suitable manner which may depend on the type of instructions of the set of instructions.

Although primarily depicted and described herein with respect to embodiments in which embodiments of TISA are used to enable scan operations to be performed at the Scan Segments Level it will be appreciated that one or more of the Scan Segments Level embodiments depicted and described herein also may be provided in environments using TISA like instructions architectures non TISA instruction architectures and or non TISA testing environment implementations and the like.

Although references are made herein to the TISA for purposes of describing the enhanced system testing capabilities enabled by exemplary embodiments of TISAs which may be formed and utilized as depicted and described herein it will be appreciated that many different TISAs may be formed depending on various factors such as one or more of the ISA of the processor for which the TISA is formed characteristics of the SUT for which the TISA is formed characteristics of the test algorithm the TISA is supposed to execute and the like as well as various combinations thereof. Thus references made herein to the TISA also may be read more generally as a TISA in that many different types of TISAs may be formed.

A virtual In Circuit Emulation ICE capability is provided herein for supporting testing of Joint Test Action Group JTAG hardware. In one embodiment virtual In Circuit Emulation ICE capability includes a Virtual ICE Driver various embodiments of which are depicted and described herein. The Virtual ICE Driver is configured to enable any standard debug software to interface with JTAG enabled hardware in a flexible and scalable manner. The Virtual ICE Driver is configured such that the test instruction set used with the Virtual ICE Driver is not required to compute vectors as the JTAG operations are expressed as local native instructions on scan segments thereby enabling ICE resources to be accessed directly. The Virtual ICE Driver is configured such that ICE may be combined with instrument based JTAG approaches e.g. such as the IEEE P1687 standard and other suitable approaches . The Virtual ICE Driver provides various other capabilities and advantages as will be understood from the description of the Virtual ICE Driver provided herein. Although primarily depicted and described herein within the context of embodiments in which the Virtual ICE Driver is utilized with the Test Instruction Set Architecture TISA it will be appreciated that the Virtual ICE Driver may be utilized with any suitable test instruction set.

In TISA the concurrent control of registers can be performed using high level software calls leveraging high level programming languages and operating systems. As a result with TISA ICE interfacing may be reduced to a set of coordinated queued command calls to a TISA based Circuit Control Model which manages the issuance of TISA scan segment operations according to the scan topology of the Target Hardware. Thus with TISA each of the ICE interfaces may be written as a standalone yet hierarchical set of operations on the device registers which map to TISA opcodes. In other words each of the ICE interfaces can be seen as an autonomous instrument register and due to the JTAG abstraction level supported by the TISA the TISA can control each of these registers autonomously by representing them as independent scan segments. This is much simpler than the circuit models used by TGTs to handle vectors because the TISA Processor only needs to schedule the scan segment operations rather than retargeting testing vectors as is required in existing solutions .

These and various other embodiments of the Virtual ICE Driver and associated Virtual ICE Driver capabilities may be better understood by way of reference to .

As depicted in system includes a Target Hardware a TAP Interface a Virtual ICE Driver and an ICE Host .

The Target Hardware includes a plurality of JTAG accessible devices collectively JTAG accessible devices . The JTAG accessible devices include a first Central Processing Unit CPU a second Central Processing Unit CPU and four Instrumented Application Specific Integrated Circuits ASICs Instrumented ASICs . Although depicted and described as having particular types and numbers of JTAG accessible devices it will be appreciated that Target Hardware may include any suitable types and numbers of JTAG accessible devices .

The CPUs may be any JTAG accessible CPUs. For example one or both of CPU and CPU may be 1149.1 ICE targets. For example one or both of CPU and CPU may be 1149.7 ICE targets having multiple processor cores that need to be accessed independently. The CPUs may include any other suitable types of CPUs.

The Instrumented ASICs may be any JTAG accessible ASICs. For example one or more of the Instrumented ASICs may be P1687 ICE targets. In the example of each of the Instrumented ASICs is a P1687 ICE target.

The Target Hardware has a scan chain topology associated therewith and each of the JTAG accessible devices forms part of that scan chain topology.

The JTAG accessible devices of Target Hardware are commanded via TAP Interface which is connected to Virtual ICE Driver .

The TAP Interface provides an interface between Target Hardware and Virtual ICE Driver thereby enabling Virtual ICE Driver to access the JTAG accessible devices of Target Hardware . The TAP Interface may be implemented using any suitable TAP such as an 1149.1 TAP or other suitable TAP.

The Virtual ICE Driver includes a Queued State Machine and a TISA Processor . The Virtual ICE Driver facilitates access to Target Hardware by ICE Host .

The ICE Host includes a plurality of Target ICE Controllers including a first Target ICE Controller associated with CPU of Target Hardware a second Target ICE Controller associated with CPU of Target Hardware and a third Target ICE Controller associated with Instrumented ASICs of Target Hardware . The Host ICE may include fewer or more such Target ICE Controllers. The ICE Host also includes a Host Messaging API configured to facilitate communication between each of the Target ICE Controllers of ICE Host and the Virtual ICE Driver .

The first Target ICE Controller includes a GBU GUI for CPU and a Target ICE Manager . The GBU GUI for CPU provides an interface via which a tester may configure tests to be performed for testing CPU on Target Hardware . The Target ICE Manager has information including a circuit model that describes the registers included within CPU the manner in which the various registers of CPU are arranged within CPU and information for enabling access to the registers of CPU if CPU were the only device in the scan chain of Target Hardware . The Target ICE Manager also has information defining the mapping of registers of CPU to scan segments for CPU. The GBU GUI may be used to specify operations to be performed over the registers of CPU. The Target ICE Manager generates appropriate scan segment operations for accessing and testing CPU on Target Hardware . The Target ICE Manager provides the generated scan segment operations for accessing and testing CPU on Target Hardware to Host Messaging API which in turn communicates the generated scan segment operations to Virtual ICE Driver .

The second Target ICE Controller includes a GBU GUI for CPU and a Target ICE Manager . The GBU GUI for CPU provides an interface via which a tester may configure tests to be performed for testing CPU on Target Hardware . The Target ICE Manager has information including a circuit model that describes the registers included within CPU the manner in which the various registers of CPU are arranged within CPU and information for enabling access to the registers of CPU if CPU were the only device in the scan chain of Target Hardware . The Target ICE Manager also has information including the mapping of registers of CPU to scan segments for CPU. The GBU GUI may be used to specify operations to be performed over the registers of CPU. The Target ICE Manager generates appropriate scan segment operations for accessing CPU on Target Hardware . The Target ICE Manager provides the generated scan segment operations for accessing CPU on Target Hardware to Host Messaging API which in turn communicates the generated scan segment operations to Virtual ICE Driver .

As described above GDB GUIs provide interfaces via which testers may configure tests to be performed for testing devices on Target Hardware . In general for ICE purposes debuggers including GDB debuggers such as GBU GUI for CPU and GBU GUI for CPU essentially see a target machine as an abstraction model including three basic elements a back of registers a block of memory and a stack frame. A target machine description of the target machine may then be used to map the abstraction model to the real hardware of the target machine via the ICE infrastructure. In a JTAG accessible system such as Target Hardware the real hardware is represented as JTAG accessible registers on one or more scan chains. In GDB an application programming interface API may be composed of 1 a set of functions to read write indexed registers 2 a set of functions to read write memory 3 a set of functions to read write the program counter register and 4 a set of functions to read write a stack pointer register. In GDB these functions translate GDB access requests initiated via the GDB GUI e.g. GBU GUI for CPU and GBU GUI for CPU into access commands for the target ICE e.g. for registers of CPU and CPU of Target Hardware . The access commands are scan segment operations where the scan segment operations are designed over scan segments defined based on the registers of the embedded components of Target Hardware . In this sense each scan segment becomes a subset of an overall ordered set of registers of Target Hardware available for testing.

Although primarily depicted and described herein with respect to use of GDB for testing JTAG accessible devices of Target Hardware it will be appreciated that any suitable debugger may be utilized for testing JTAG accessible devices of Target Hardware .

The third Target ICE Controller includes a P1687 Application for Instrumented ASICs . The P1687 Application for Instrumented ASICs provides an interface via which a tester may configure tests to be performed for testing one or more of the Instrumented ASICs on Target Hardware . The P1687 Application for Instrumented ASICs provides capabilities similar to those of GDB. The P1687 Application for Instrumented ASICs generates appropriate scan segment operations for accessing Instrumented ASICs on Target Hardware . The P1687 Application for Instrumented ASICs provides the generated scan segment operations for accessing Instrumented ASICs on Target Hardware to Host Messaging API which in turn communicates the generated scan segment operations to Virtual ICE Driver .

As indicated herein each Target ICE Controller is configured to generate an ordered set of scan segment operations i.e. a set of ordered instructions defined into one or more segments inside the related Target Hardware .

The Host Messaging API facilitates communication between each of the Target ICE Controllers of ICE Host and the Virtual ICE Driver .

The Host Messaging API facilitates communication from the Target ICE Controllers of ICE Host to the Virtual ICE Driver of the ordered sets of scan segment operations generated by the Target ICE Controllers .

The Host Messaging API may use any suitable communications capabilities for facilitating communication between the Target ICE Controllers of ICE Host and the Virtual ICE Driver . For example Host Messaging API may utilize communications capabilities such as physical connections e.g. PCI Serial and the like networked connections e.g. Ethernet based connections Internet Protocol IP based connections and the like software applications e.g. pipes files messages inter process communications and the like and the like as well as various combinations thereof.

Although primarily depicted and described herein with respect to embodiments in which the Target ICE Controllers reside on a single ICE Host i.e. ICE Host in other embodiments the Target ICE Controllers of ICE Host may reside on multiple ICE Hosts. The Target ICE Controllers may be distributed across the multiple Hosts in any suitable manner e.g. each Target ICE Controller is implemented on its own dedicated Host at least some of the Target ICE Controllers share one or more Hosts and the like as well as various combinations thereof . In such embodiments Host Messaging API is configured to facilitate communications for the distributed Target ICE Controllers e.g. via physical connections via networked connections such as IP connections and or any other suitable networked connections and the like as well as various combinations thereof .

The Queued State Machine operates as an interface between ICE Host and TISA Processor . The Queued State Machine receives ordered sets of scan segment operations from the Target ICE Controllers of ICE Host . The Queued State Machine processes the ordered sets of scan segment operations to produce scheduled sets of scan segment operations which may be performed by accounting for the position of each scan segment inside the Target Hardware . The Queued State Machine is configured for scheduling the scan segment operations using a schedule that is necessary and or efficient for the JTAG scan chain of Target Hardware . The Queued State Machine provides the scheduled set of scan segment operations to TISA Processor .

In one embodiment for example Queued State Machine includes an Event Loop a Command Handler and a Circuit Control Model .

The Event Loop receives ordered sets of scan segment operations from Host Messaging API of ICE Host . The scan segment operations include scan segment operations issued by one or more of the Target ICE Controllers of ICE Host . The Event Loop provides the ordered sets of scan segment operations to Command Handler .

The Command Handler receives the ordered sets of scan segment operations from Event Loop . The Command Handler provides the ordered sets of scan segment operations to Circuit Control Model .

The Circuit Control Model receives the ordered sets of scan segment operations from Command Handler and generates a scheduled set of scan segment operations to be provided to TISA Processor .

The Circuit Control Model includes the circuit model information of each of the circuit models of each of the Target ICE Controllers and manages the information as an aggregate for enabling handling of scan segment operations issued by each of the Target ICE Controllers .

The Circuit Control Model includes scan topology information for modelling the scan topology of Target Hardware including information such as the scan topologies of each of JTAG enabled devices the scan topology via which the JTAG enabled devices are interconnected and the like as well as various combinations thereof. At each given moment the state of the Circuit Control Model mirrors the state of the Target Hardware .

The Circuit Control Model includes ordered collections of scan segment models which also may be referred to as scan segment sets where each of the scan segment sets may themselves be subsets of other scan segment sets and where each of the scan segment subsets may manage themselves in terms of their ordering. The object oriented capabilities of TISA enable delegation to the scan segment sets of the ordering of when the scan segment sets are to perform their respective scan segment operations and further enables the scan segment sets to move anywhere within the overall hierarchy while the associated code remains unchanged.

The Circuit Control Model schedules the scan segment operations from the ordered sets of scan segment operations based on the scan topology of Target Hardware as determined from the scan topology information. The Circuit Control Model processes each of the received scan segment operations. The Circuit Control Model upon receiving a scan segment operation processes the scan segment operation for recognizing an intended destination of the scan segment operation e.g. one of the JTAG accessible devices of Target Hardware . The Circuit Control Model delegates the scan segment operation to a portion of the Circuit Control Model that is associated with the intended destination of the scan segment operation e.g. to the scan segment set that is configured to create a call s to an appropriate function s for the scan segment operation where the called function s have the associated TISA processor instructions for executing the scan segment operation.

It will be appreciated that since the Circuit Control Model only requires information needed to perform the scheduling of the scan segment operations the Circuit Control Model can be significantly simpler than the models used for vector retargeting.

The TISA processor is configured to control the JTAG accessible devices of Target Hardware via TAP Interface . The TISA Processor is configured to control the JTAG accessible devices of Target Hardware using TISA Instructions supported by TISA Processor . The TISA Processor receives a scheduled set of scan segment operations from Queued State Machine and executes the scheduled set of scan segment operations via TAP Interface and the scan topology of Target Hardware for debugging the software of the associated JTAG accessible devices of Target Hardware . From the perspective of the TISA processor the Target Hardware is simply a set of scan segments regardless of the actual complexity of the Target Hardware . The operation of TISA Processor may be better understood by way of reference to .

The Virtual ICE Driver may be better understood by considering an example. For example assume that GBU GUI for CPU associated with CPU of Target Hardware issues a command requesting an update of the value of the program counter in CPU. The Target ICE Manager passes the command to Event Loop . The Event Loop passes the message to Command Handler . The Command Handler passes the command to Circuit Control Model which recognizes that the command is intended for CPU and as a result generates the TISA instructions needed to access CPU in the current state of the Circuit Control Model and of the Target Hardware . If needed Command Handler also generates the instructions needed to bring the Circuit Control Model to a state in which CPU is accessible. The Circuit Control Model then delegates the command to the scan segment set of Circuit Model that is associated to CPU so that it can write to that particular register within CPU. The scan segment set which is configured for applying the appropriate vector to CPU creates a call to the appropriate register function that is called to write to the program counter register of CPU. The register function that is called to write to the program counter register of CPU has the appropriate TISA processor instructions for applying the specific data of the scan segment command for writing the specific data to the program counter register of CPU. Thus the data can change over time while the function which controls the manner in which the data is written to the register stays the same over time.

The Virtual ICE Driver by utilizing TISA is able to handle each of the JTAG accessible devices of Target Hardware as independent autonomous scan segments. This is at least partially due to the capability of TISA to enable the TCK clock of the 1149.1 TAP to be paused at any desired point in the instruction set thereby obviating the need for the 1149.1 TAP to switch to a stable state in order to pause the scan operation i.e. typical 1149.1 TAP interface only gate the TCK clock i.e. turn off the clock in one of the four stable states . This in conjunction with the properties of the Scan Segment primitives ensures that the Circuit Control Model simply has to schedule the TISA instructions that it receives from the Command Handler based on this own internal state and that it has no need to modify them. This is a huge simplification compared to vector retargeting of existing ICE approaches.

The Virtual ICE Driver by utilizing TISA is able to provide synchronization between embedded components of Target Hardware by synchronizing scan segment operations executed on the embedded components of Target Hardware . Thus Virtual ICE Driver by utilizing TISA merely has to order and execute scan segment operations as opposed existing ICE approaches in which Target ICE Controllers would need to retarget scan chain vectors i.e. the Virtual ICE Driver directly retargets the software functions rather than having to generate and retarget scan chain vectors which would require use of a Test Generation Tool TGT .

The Virtual ICE Driver enables concurrent access to and testing of multiple JTAG accessible devices of Target Hardware where the JTAG accessible devices may include different types of devices e.g. CPUs ASICs and the like as well as various combinations thereof eliminating the requirement of existing ICE mechanisms that such device types be handled in isolation from each other and thus enabling various optimizations over existing ICE mechanisms e.g. sharing of resources of Target Hardware parallelization of access to and testing of components of Target Hardware and the like as well as various combinations thereof .

The Virtual ICE Driver enables concurrent access to and testing of multiple JTAG accessible devices of Target Hardware by multiple Target ICEs Controllers eliminating the requirement of existing ICE mechanisms that at any given time only a single Target ICEs Controller may access and test only a single JTAG accessible device of Target Hardware and thus obviating the need for retargeting of scan chain vectors.

The Virtual ICE Driver obviates the need for pre processing of testing data by Target ICEs Controllers e.g. for every directive from Target ICE Controllers in order to obtain the entire scan chain vector set for all target devices of Target Hardware where all target devices are on the same scan chain a capability which is difficult or even impossible to provide with existing ICE approaches. It will be appreciated that this limitation of existing ICE approaches does not come from theoretical reasons but rather from practical ones. In fact vector retargeting for such applications can be highly complex both in terms of computational requirements and modelling needs. As a result most existing Test Generation Tools do not allow such situations or force the system to pre defined simplified configurations. By contrast TISA reduces this process to a scheduling problem which is a classical and well know Information Theory problem having many known and optimized solutions.

As a result the Virtual ICE Driver enables such processing to be performed in real time as Target ICEs Controllers issue commands for testing various components of Target Hardware .

The Virtual ICE Driver provides a flexible and scalable ICE capability enabling any 1149.1 enabled target hardware and or 1149.7 enabled target hardware to be connected to the control software without a need to modify the underlying architecture and further enabling the control software to grow as big as necessary and to exploit all of the resources of ICE Host .

The Virtual ICE Driver enables ICE based testing of Target Hardware without requiring any modification of GDB or the P1687 applications hosted on ICE Host .

The Virtual ICE Driver and thus the system of may be implemented in any suitable manner which may include any suitable groupings and or partitioning of elements functions.

In one embodiment for example Virtual ICE Driver is implemented as a standalone device or devices disposed between ICE Host and Target Hardware .

In one embodiment for example Queued State Machine and ICE Host are implemented within a host machine which may be connected to TISA Processor through any suitable interface connection e.g. PCI Serial Ethernet and the like . In this embodiment the TISA Processor is then connected to Target Hardware via a standard JTAG connection. In this embodiment the Host Messaging API may be implemented using any suitable Computer Science construct s e.g. message queues mailboxes and the like as well as various combinations thereof .

In one embodiment for example Virtual ICE Driver may be implemented such that the Virtual ICE Driver is completely embedded within Target Hardware .

In one embodiment for example ICE Host may be a TISA processor. In this embodiment TISA Processor is implemented as a TISA co processor as depicted and described herein with respect to .

It will be appreciated that various combinations of such embodiments may be implemented and or that any other suitable implementations may be employed.

Although primarily depicted and described herein with respect to embodiments in which ICE Host includes multiple Target ICE Controllers where multiple Target ICE Controllers may access Target Hardware concurrently in other embodiments the ICE Host may include multiple Target ICEs where only one of the multiple Target ICEs Controllers is active at any given time or the ICE Host may include only one Target ICE Controller . In such embodiments Virtual ICE Driver does not require the use of Queued State Machine and thus this element may be omitted from Virtual ICE Driver . In such embodiments Virtual ICE Driver includes TISA Processor and the scan segment operations provided by the active only Target ICE Controller may be provided directly to TISA Processor i.e. without use of Queued State Machine .

Although primarily depicted and described with respect to embodiments in which the Virtual ICE Driver interfaces with the Target Hardware via a single TAP Interface in other embodiments the Target Hardware may include multiple input ports e.g. 1149.1 TAPs which may have multiple Target ICE Controller connected thereto. In such embodiment the Virtual ICE Driver is configured to manage routing of scan vectors received via each of the multiple TAP Interfaces of Target Hardware to the appropriate JTAG accessible devices of Target Hardware . In such embodiments the Target ICE Controller believes that it is communicating with its own device in its own scan chain when in reality it is communicating with the TISA processor that would be remapping those data vectors as scan segment calls for the TISA processor to the appropriate point in the Target Hardware . Thus in such embodiments if there are changes in the Target Hardware no corresponding changes are required in the Target ICE Controller rather the only step that would be required to support the changes in the Target Hardware would be to reload the circuit model for the TISA processor.

Although primarily depicted and described herein with respect to embodiments in which the Virtual ICE Driver is used to debug software of target hardware in other embodiments the Virtual ICE Driver may be used to perform remote updates to communication devices having 1149.1 TAP interfaces embedded therein e.g. computers smartphones and the like .

At step scan segment operations are received. The scan segment operations are generated by a plurality of target ICE controllers of at least one ICE host. The target ICE controllers are associated with a plurality of components of the Target Hardware.

At step the scan segment operations are scheduled for form a scheduled set of scan segment operation. The scan segment operations are scheduled based at least in part on a scan chain of the Target Hardware.

At step the scheduled set of scan segment operations is propagated toward a processor configured for executing the scheduled set of scan segment operations for testing one or more components of the Target Hardware.

It should be noted that system testing functions depicted and described herein may be implemented in software and or in a combination of software and hardware e.g. using a general purpose computer one or more application specific integrated circuits ASIC and or any other hardware equivalents. In one embodiment system testing process can be loaded into memory and executed by processor to implement and or support implementation of at least a portion of the system testing functions described hereinabove. Thus system testing process including associated data structures can be stored on a computer readable storage medium or carrier e.g. RAM memory magnetic or optical drive or diskette and the like.

It is contemplated that some of the steps discussed herein as software methods may be implemented within hardware for example as circuitry that cooperates with the processor to perform various method steps. Portions of the functions elements described herein may be implemented as a computer program product wherein computer instructions when processed by a computer adapt the operation of the computer such that the methods and or techniques described herein are invoked or otherwise provided. Instructions for invoking the inventive methods may be stored in fixed or removable media transmitted via a data stream in a broadcast or other signal bearing medium and or stored within a memory within a computing device operating according to the instructions.

Although various embodiments which incorporate the teachings of the present invention have been shown and described in detail herein those skilled in the art can readily devise many other varied embodiments that still incorporate these teachings.

