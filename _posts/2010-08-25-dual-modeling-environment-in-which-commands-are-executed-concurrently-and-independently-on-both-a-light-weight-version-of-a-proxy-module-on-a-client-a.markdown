---

title: Dual modeling environment in which commands are executed concurrently and independently on both a light weight version of a proxy module on a client and a precise version of the proxy module on a server
abstract: A method, apparatus, system, article of manufacture, and computer readable storage medium enable a dual modeling environment. A client application is created that has proxy modules. Each of the proxy modules is a light weight version of a corresponding precise module in a server application. Commands are executed in the client application to produce client output data. The same commands are transmitted to the server application that is executed concurrently with and independent from the client application and produces server output data. The client output data is synchronized with the server output data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09002946&OS=09002946&RS=09002946
owner: Autodesk, Inc.
number: 09002946
owner_city: San Rafael
owner_country: US
publication_date: 20100825
---
The present invention relates generally to web enabled applications and in particular to a method apparatus and article of manufacture for executing applications in a network environment while providing a full complement of features and precision of a stand alone application.

Web based applications are often executed on thin client devices such as mobile telephones personal digital assistants PDAs computers with limited processing capabilities etc. However it is desirable to build web applications that are progressively full featured and interactive while presenting results that involve precision and processing capabilities that have been traditionally relegated to stand alone systems. Prior art systems fail to provide such web based applications. To better understand such problems it is useful to describe prior art web applications and their limitations.

There are two general approaches to building web applications in the prior art. In the first approach a native web application is built using current technology e.g. HTML hyptertext markup language Flash third party development tools etc. . Most such web applications take advantage of a server that executes the application and performs the majority of the processing. The client computer is used to transmit commands via a user interface to the server.

In the second approach a traditional desktop application is created and the developer determines where the application processing should be split. For example the developer may determine that the graphics user interface elements are processed on the client desktop window while other processing is performed by the server. Such a developer would further develop a protocol for sending command bits events back to the server that processes and transmits the appropriate information back to the client.

In view of the different approaches one may see that an application can be built entirely on the browser client that is not as precise accurate. In other words such an application may execute quickly but may not have the full processing capabilities of a server and hence may not provide the results desired. Thus there is a tradeoff in the prior art between speed and accuracy.

Viewed another way in the prior art interactive applications are often built with a single behavioral and semantic stack. For example user input may be accumulated processed by various modules executed on existing data to produce more data followed by the updating of one or more views on the client browser. Almost always one instance of any particular class of module e.g. visual editing kernel numerical solver etc. is used. Such prior art implementations tend to only have the capacity to scale in terms of the manipulate compute display response profile as a function of computation resources upon which the application runs executes. In other words as the resources increase with respect to memory processing cores faster processors etc. better performance may be achieved.

The corollary to this statement is that by reducing data to those algorithms that are sensitive to it performance can be increased as well. For example if coarser meshes are used for analysis less triangles and effects result for the display and larger error tolerances for solvers may result.

Such conditions may be exacerbated when moving these application architectures to client server and other distributed models. Further when the client side environment is in some way more constrained i.e. less computations result in less capabilities decisions must be made with respect to the interactive experience performance versus fidelity and accuracy of the data.

In view of the above it is desirable to provide an application architecture that enables new mechanisms for scalability and the means to improve interactivity with less compromise on the fidelity of the data. It is further desirable to enable the development and delivery of real interactive three dimensional 3D editing and design applications on the web and mobile devices.

One or more embodiments of the invention overcome the problems of the prior art by providing a dual modeling environment. Lightweight versions of an application s modules are created. The lightweight modules are executed on a client computer concurrently with the full more precise version of the modules on a server computer. The lightweight modules enable the user to view results quickly but without the high fidelity required needed for final output results.

To ensure accurate final output data the client output data is synchronized with the server output data. Such synchronization may occur without reconciling any data by reconciling after the execution of every command on the server or at any level in between. The timing of the reconciliation synchronization process may also be determined specified by the user e.g. after an accuracy threshold has been exceeded every five minutes never etc. .

Accordingly the dual modeling framework enables developers to design mobile and web applications that provide both speed and fidelity within the same application session while utilizing a dynamic mechanism to synchronize data between concurrently executing modules on a client and server.

In the following description reference is made to the accompanying drawings which form a part hereof and which is shown by way of illustration several embodiments of the present invention. It is understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the present invention.

In one embodiment the computer operates by the general purpose processor A performing instructions defined by the computer program under control of an operating system . The computer program and or the operating system may be stored in the memory and may interface with the user and or other devices to accept input and commands and based on such input and commands and the instructions defined by the computer program and operating system to provide output and results.

Output results may be presented on the display or provided to another device for presentation or further processing or action. In one embodiment the display comprises a liquid crystal display LCD having a plurality of separately addressable liquid crystals. Each liquid crystal of the display changes to an opaque or translucent state to form a part of the image on the display in response to the data or information generated by the processor from the application of the instructions of the computer program and or operating system to the input and commands. The image may be provided through a graphical user interface GUI module A. Although the GUI module A is depicted as a separate module the instructions performing the GUI functions can be resident or distributed in the operating system the computer program or implemented with special purpose memory and processors.

Some or all of the operations performed by the computer according to the computer program instructions may be implemented in a special purpose processor B. In this embodiment the some or all of the computer program instructions may be implemented via firmware instructions stored in a read only memory ROM a programmable read only memory PROM or flash memory within the special purpose processor B or in memory . The special purpose processor B may also be hardwired through circuit design to perform some or all of the operations to implement the present invention. Further the special purpose processor B may be a hybrid processor which includes dedicated circuitry for performing a subset of functions and other circuits for performing more general functions such as responding to computer program instructions. In one embodiment the special purpose processor is an application specific integrated circuit ASIC .

The computer may also implement a compiler which allows an application program written in a programming language such as COBOL Pascal C FORTRAN or other language to be translated into processor readable code. After completion the application or computer program accesses and manipulates data accepted from I O devices and stored in the memory of the computer using the relationships and logic that was generated using the compiler .

The computer also optionally comprises an external communication device such as a modem satellite link Ethernet card or other device for accepting input from and providing output to other computers .

In one embodiment instructions implementing the operating system the computer program and the compiler are tangibly embodied in a computer readable medium e.g. data storage device which could include one or more fixed or removable data storage devices such as a zip drive floppy disc drive hard drive CD ROM drive tape drive etc. Further the operating system and the computer program are comprised of computer program instructions which when accessed read and executed by the computer causes the computer to perform the steps necessary to implement and or use the present invention or to load the program of instructions into a memory thus creating a special purpose data structure causing the computer to operate as a specially programmed computer executing the method steps described herein. Computer program and or operating instructions may also be tangibly embodied in memory and or data communications devices thereby making a computer program product or article of manufacture according to the invention. As such the terms article of manufacture program storage device and computer program product as used herein are intended to encompass a computer program accessible from any computer readable device or media.

Of course those skilled in the art will recognize that any combination of the above components or any number of different components peripherals and other devices may be used with the computer .

Although the term user computer or client computer is referred to herein it is understood that a user computer may include portable devices such as cellular phones notebook computers pocket computers or any other device with suitable processing communication and input output capability.

A network such as the Internet connects clients and or thin client devices to server computers . Network may utilize ethernet coaxial cable wireless communications radio frequency RF a cellular network etc. to connect and provide the communication between clients thin client devices and servers . Clients including thin client devices may execute a client application or web browser and communicate with server computers executing web servers . Such a web browser is typically a program such as MICROSOFT INTERNET EXPLORER MOZILLA FIREFOX OPERA APPLE SAFARI etc. Further the software executing on clients thin client devices may be downloaded from server computer to client computers and installed as a plug in or ACTIVEX control of a web browser. Accordingly clients may utilize ACTIVEX components component object model COM or distributed COM DCOM components to provide a user interface on a display of client . The web server is typically a program such as MICROSOFT S INTERNET INFORMATION SERVER .

Web server may host an Active Server Page ASP or Internet Server Application Programming Interface ISAPI application which may be executing scripts. The scripts invoke objects that execute business logic referred to as business objects . The business objects then manipulate data in database through a database management system DBMS . Alternatively database may be part of or connected directly to client instead of communicating obtaining the information from database across network . When a developer encapsulates the business functionality into objects the system may be referred to as a COM system. Accordingly the scripts executing on web server and or application invoke COM objects that implement the business logic. Further server may utilize MICROSOFT S Transaction Server MTS to access required data stored in database via an interface such as ADO Active Data Objects OLE DB Object Linking and Embedding DataBase or ODBC Open DataBase Connectivity .

As an alternative to the above different computing environments may also be used in accordance with embodiments of the invention. For example a Linux or other operating system and corresponding components may be utilized.

Generally these components all comprise logic and or data that is embodied in or retrievable from device medium signal or carrier e.g. a data storage device a data communications device a remote computer or device coupled to the computer via a network or via another data communications device etc. Moreover this logic and or data when read executed and or interpreted results in the steps necessary to implement and or use the present invention being performed.

Although the term user computer client computer thin client device and or server computer is referred to herein it is understood that such computers and and thin client devices may include portable devices such as cellular phones notebook computers pocket computers personal digital assistants or any other device with suitable processing communication and input output capability.

Of course those skilled in the art will recognize that any combination of the above components or any number of different components peripherals and other devices may be used with computers and and thin client devices .

Embodiments of the invention are implemented as a software application on a client thin client device and or server computer . As described above it is desirable to enable a fast application on a client browser while also enabling the numerical precision desired in such an application. Further it is desirable to provide interactive capabilities on a browser client application that looks and feels like a native application e.g. an application executing on a stand alone computer . However when an application is designed the capabilities of the client browser are unknown at design time i.e. the developer may not know the capacity or processing capabilities of the thin client device . Similarly it is undesirable to implement all operations on a server with the result presented to the user on a client mobile device because such results would not be acceptable in terms of speed and potentially the graphics limitations may present conflicts i.e. transmission limitations may exist and the results may be processed more slowly on the server due to the level of precision fidelity of the data . Consequently it is desirable to provide a hybrid model that utilizes both the client and server .

To provide a hybrid model an application may be viewed as a series of modules chunks of code. One module performs an operation and passes results to a different module. In one or more embodiments of the invention the different modules functionalities are duplicated on both the client and server . Thus embodiments may have two different modules performing the same job 1 client based module performed very rapidly without the resource constraints but may not provide results that are visually appealing and 2 a server based module that enables the full processing of the modules including the numerical precision desired .

The different modules executing on the client and server offer different experiences to an end user developer. For example a module executing on a client may not look visually appealing but may still provide a satisfying experience. Further the client based module may synchronize itself with the second server based module. In this regard the application may be designed to execute entirely on a client browser that is not as accurate but fast i.e. executes quickly . All commands and processes provided to the client based module are backed up to a matching module on the server where the real information i.e. numerically precise data is processed.

Once the data is processed on both the client and server embodiments of the invention enable the synchronization of the different modules. Such synchronization is necessary due to functional differences and potential mathematical errors that may occur in a trivial or significant manner i.e. on the client . The synchronization in accordance with embodiments of the invention allows the server to correct the client or notify the client that a threshold difference is being exceeded. In other words the problem notification of the problem may be pushed from the server to the client where the problem may be corrected.

An exemplary environment for utilizing such a dual modeling environment where modules are executed on both the client and server exists in a solid modeling application. For example a circle may be sketched drawn and an extrusion performed thereby creating a cylinder. Locally in the browser on the client the math may be performed triangles generated and instructions provided to draw the cylinder. At the same time the sketch draw circle and extrusion command are transmitted to the server where a more powerful and complete solid modeling engine may be used to the compute the information. Thus the real and more accurate data exists on the server while a modified version that may involve various shortcuts to expedite the processing is performed on the client . In this regard due to the content and actions used to create the modified version such a modified version may not be stable and does not include the details from the full version that exists on the server .

In another example if modeling a constraint system with many moving parts e.g. a box on a conveyor belt or spheres rolling on a floor a simple physics engine may exist on the client. Such a simple engine may include some randomness and other influences to expedite the processing properties that do not exist on the server based version. Such randomness and other influences on the client likely result in errors that can accumulate over time. Once a defined period of time has passed or once an error threshold has been exceed the server may transmit corrections to update the data on the client . Accordingly the user on the client can continue to work without paying the cost for the high fidelity and more precise engine calculations that are being performed on the server .

Accordingly the multiple implementations of the functional modules engines are synchronized over a network distribution channel to provide a richer functional experience on the mobile web client without sacrificing precision and the accuracy of the data. The timing of the synchronization may be configured by the user. For example any errors may be constantly transmitted from the server to the client once determined. Alternatively such updates can be delayed if the errors may not impair the user s activities. In this regard different synchronization protocols timing may be utilized depending on the activity and content of the modules being executed. As a result the code executing on the client may be far lighter and have less restrictions with regards to resources and capacity required compared to that of a full desktop application.

In general the invention is the idea that the linear application stack described above is not always required and that applications can be constructed with pairs of proxy and precise modules with synchronization and correction semantics.

Specifically for web applications embodiments of the invention provide a system where functionality is duplicated both on the client and the server at a module level. On the client a fast approximating component is used to deliver the desired interactivity. On the server a numerically precise slower component resides and receives the exact same command set as that received on the client .

The next piece of the architecture is the mechanism that synchronizes the client module with the server module to correct accumulated errors. The application can thus be tuned synchronization frequency module by module to obtain a desirable mix of interactivity and visual appeal. The data that is ultimately the output of the application always comes from the accurate server model the client side data is always considered transient.

One exemplary implementation is that of an interactive 3D solid modeling application. Such an application may be composed of two modeling kernels a modeler kernel referred to herein as AModeler runs in the context of a browser plug in and a shape manager kernel e.g. ASM Autodesk Shape Manager available from the assignee of the present invention runs on the server .

The client component is lightweight and fast for certain data sets and operations and thus can be used as a proxy for the high quality representation the real data in the cloud server . The application framework manages the collection and dispatch of commands say in this particular case modifiers along the kernel bus so that the AModeler responds locally and ASM processes them concurrently remotely. Basically this enables each module to process the modifiers independently to any different degree of accuracy.

Additionally certain tricks can be employed in the local module i.e. client module to improve interactivity such as reducing tesselation refinement during direct manipulations and operations. For example on a mouse up command received from the user the local environment can be updated or synchronized from the server that will not be engaged in the lower fidelity computation.

As previously noted the synchronization points can be tuned between the following extremes 1 the result of each command is reconciled from the server most accurate local representation to 2 no synchronization is performed and the local proxy is always used for visual feedback .

Another corollary to the invention is the notion of gracefully handling semantic synchronization errors. These are errors that occur when the capabilities of the two modules are different enough that a non trivial non recoverable modeling error would result if allowed to complete. A simple example can be thought of in terms of the numerical precision differences between the local proxy i.e. on client and server module. An operation might appear to succeed locally but when processed by the precise kernel in fact violates a region of numerical stability. A more complicated example might be when one or more modifiers that produce a valid result locally cannot actually be performed with integrity on the server.

To manage the above identified situations an application framework of embodiments of the invention marks commands or sets of commands not unlike the notion of a transaction though these are not transactions . The framework on the client side will manage a stack of these command sets that will continue to grow until each is acknowledged by the server side of the framework. This can happen via a full synchronization including data or a simple ACK acknowledge command . As the server processes the same commands it can inform the framework as to their success validity.

If an error occurs the client is informed and can immediately identify the user. Since the client maintains the stack of unconfirmed commands available the client can not only return to the last stable state but can also play back the steps that produced the error. Armed with this data embodiments of the invention can 1 provide useful visual feedback to the user 2 use exact data from the server to constrain the operators in the local environment to guide the operators to a real solution 3 automatically reduce the synchronization times to provide accurate though slower realtime feedback in the tools and or 4 improve the local kernel the protocol and the system in general offline .

Another aspect of the invention involves more complex manipulations and computationally more expensive operations such as constraints. In a local environment where speed is important these computations may not be calculated with as much accuracy as the user desires. Errors will eventually accumulate and correction will be required. This is not the case for a scene in the cloud where computation power is not limited. When computation power is not limited calculations are performed with accuracy and saved. In further embodiments of the invention once an accuracy threshold is exceeded in the local environment the model from the cloud is retrieved correcting the accuracy issues.

At step one or more commands e.g. received from a user are executed in the client application to produce client output data. The client output data may provide interactivity to a user of the client application and may further consist of transient i.e. non permanent data.

At step the same one or more commands are transmitted to the server application that is configured to utilize the commands during execution. The server application executes the commands concurrently with and independent from the client application to produce server output data while being part of the same application session .

At step the client output data is synchronized with the server output data. The synchronization process may be performed a variety of ways. In one or more embodiments a level of synchronization is selected e.g. by the user . The level selected may lie between or at the endpoints of two extremes. On one end the server output data produced from the execution of each and every one of the commands from the server application is reconciled with the client output data i.e. all updates may be performed in real time once a command s execution has completed on the server . On the other end the synchronization process may entail utilizing the client output data without reconciling with the server output data at all i.e. the client output data is used and no updates reconciliation are needed performed .

In an alternative embodiment the synchronization process maintains a client command stack consisting of a subset of the commands. The subset includes and may only include those commands that would result in a modeling error if allowed to complete execution in the server application. The client command stack would continue to grow until each command in the stack is acknowledged by the server application as described above .

In an additional embodiment the synchronization process may include determining in the client application when an accuracy threshold has been reached. Such an accuracy threshold may be a threshold based on an accuracy of the execution of the commands in the client application. Once the threshold has been reached the server output data may be retrieved e.g. pulled or pushed from the server and reconciled with the client output data. In other words errors in the accuracy as determined by the client or server may accumulate until a threshold level has been reached at which point the reconciliation process may initiate. The commencement of the reconciliation process may be initiated by the client user or may occur automatically without any additional user input.

In view of the above the dual modeling environment provides for dual execution on both the client of a lightweight module and the server of a more precise module that occur concurrently and independently from each other. The client based modules allow the user to view data quickly but may lack the fidelity of a more complete server based module. Accordingly the client based data and server based data are eventually synchronized with each other to produce both visually appealing and precise output data to the user.

The development of the different modules may be performed by a developer when creating the application to be executed. Alternatively a modeling environment of the invention may automatically create i.e. without additional user input the lightweight client version of the modules based on the complete server modules or vice versa . In an automated environment the functions to be performed by the client modules may strictly include visual data. In this regard such a modeling environment may analyze the details needed to produce a visually appealing result on the client application and extract such functionality from the server module to produce the client module.

In one or more embodiments a set of criteria may be utilized to determine the level of detail incorporated into each module. For example a frame rate requirement may be established. If the frame rate cannot be maintained by the client version of the module the server may perform some of the rendering painting. The application developer author may make the determination and establish the requirements for performing the various levels of detail set forth in the lightweight client version of the modules. Accordingly different modules may be utilized for different capacities platforms. The appropriate platform may be selected either dynamically at runtime or in advance by a developer based on a client s processing capabilities that may also be determined dynamically at runtime . Such a dynamic determination and utilization of a particular client version of a module may be performed automatically without additional user developer input. Embodiments of the invention are not intended to be limited by the method used to identify the functionality used in a client lightweight module but is limited by the claims specified herein.

This concludes the description of the preferred embodiment of the invention. The following describes some alternative embodiments for accomplishing the present invention. For example any type of computer such as a mainframe minicomputer or personal computer or computer configuration such as a timesharing mainframe local area network or standalone personal computer could be used with the present invention.

In summary embodiments of the invention provide for more than one component e.g. client and server performing the same job with different levels of precision and speed in distributed applications to enable a more viable and modern approach to developing interactive design on the web and on mobile devices the latter particularly being more highly resource constrained. In other words embodiments of the invention enable maintaining dual modeling environments of the same data within the context of the same application session that can change at different rates. Further embodiments provide in an interactive distributed application a dynamic mechanism to synchronize visual and numerical data provide tunable error correction as well as error detection and dynamic user feedback and guidance.

The foregoing description of the preferred embodiment of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description but rather by the claims appended hereto.

