---

title: Automatically redirecting method calls for unit testing
abstract: A unit testing system allows testing of multiple types of method calls using an unmodified software application module. The system dynamically copies byte code of the tested method, clones the byte code, and executes the cloned byte code. During cloning, the system instruments the code so that method calls are redirected into a system method, where the system can determine whether a mocked method should be called instead. The result is that the developer does not need to modify the original methods in order to redirect method calls to mock methods. The developer can simply reference a test module of the unit testing system and easily write tests that redirect any method they wish. Thus, the unit testing system provides a framework for building more useful unit tests that cause less interference with production-ready code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08954929&OS=08954929&RS=08954929
owner: Microsoft Corporation
number: 08954929
owner_city: Redmond
owner_country: US
publication_date: 20100329
---
Modern software typically involves many components often developed by large teams of software developers. The days of procedural programming in which a single developer could write an application that simply executed from start to finish performing a single well defined task are gone. A software developer often uses libraries components frameworks and other bodies of code written by other developers. The chances for mistakes or misunderstanding how to use a particular external function or module are higher than ever.

One verification method for increasing the correctness of software is called unit testing. When unit testing a software developer attempts to isolate a particular unit of the software from external influences in a way that the unit can be tested in isolation. In theory if each unit of a software application is correct then the only room left for error is in communication between components so unit testing can dramatically reduce software error rates. Unit tests often replace externally invoked libraries or components written by other developers with stubs or replacement objects that mimic the functionality of an external component but feed directed responses into the unit under test to test the unit s reaction to particular return values operating conditions and so forth.

When writing a unit test that invokes methods on objects where the method pointers are determined at compile time i.e. non virtual or static there is currently no way to redirect or mock these method calls so that they invoke fake methods instead. This makes it very difficult to test methods that call other methods that are non virtual because it is not possible to redirect these method calls without recompiling them so that they can be redirected at runtime. Existing solutions to this problem dynamically generate subclasses of classes a developer wants to mock and inject the generated subclasses into the class the developer wants to test. This method exploits polymorphism so that the invoked methods are determined at runtime but the method only works if the base class methods are declared virtual. Another cumbersome solution is to use the Common Language Runtime CLR profiler application programming interface API which attaches to the MICROSOFT .NET runtime to intercept all method calls.

A unit testing system is described herein that allows testing of multiple types of method calls using an unmodified software application module. The system dynamically copies byte code of the tested method clones the byte code and executes the cloned byte code. During cloning the system instruments the code so that method calls are redirected into a system API where the system can determine whether a mocked method should be called instead. The result is that the developer does not need to modify the original methods in order to redirect method calls to mock methods. The developer can simply reference a test module of the unit testing system and easily write tests that redirect any method they wish. There is a strong demand for the ability to redirect every method call in a unit test but also to be able to do so without having to alter one s development environment. Thus the unit testing system provides a framework for building more useful unit tests that cause less interference with production ready code.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

A unit testing system is described herein that allows testing of multiple types of method calls using an unmodified software application module. The system dynamically copies byte code of the tested method clones the byte code and executes the cloned byte code. During cloning the system instruments the code so that method calls are redirected into a system API where the system can determine whether a mocked method should be called instead. The result is that the developer does not need to modify the original methods or the methods in other assemblies that the developer s code invokes in order to redirect method calls to mock methods instead of the ones they compiled against. The system relies on dynamically altered byte code rather than relying on polymorphism or the CLR profiler. Unlike the polymorphism approach the system can intercept calls to any type of method whereas polymorphism can only intercept virtual methods. Unlike the CLR profiler or other management layer APIs the system is stand alone and does not involve installation or setup.

The result is that a developer can simply reference a test module of the unit testing system and easily write tests that redirect any method they wish. There is a strong demand for the ability to redirect every method call in a unit test but also to be able to do so without having to alter one s development environment. In some embodiments the system clones the methods in a way that allows them to still be debugged as usual in a development environment e.g. MICROSOFT Visual Studio . The ability to use the unit testing system with a familiar development environment allows developers to quickly resolve coding errors identified by unit testing. Thus the unit testing system provides a framework for building more useful unit tests that cause less interference with production ready code.

In some embodiments the unit testing system generates an interception method for each call identified within a method. After copying the byte code of a method the system can modify the method to change the destination of calls within the method. The interception method has the same signature as the method it replaces which means no other byte code needs to be altered. Whenever a method is redirected into an interception method the system can determine whether the developer has provided a unit test and wants the call to be redirected to a mock object or method. If the developer has provided a mock object then the interception method invokes the mock object otherwise the system invokes the original method. This way the unit testing system can dynamically redirect any method calls to any object without needing to modify the original code and without using any profiling tools.

The method identification component identifies methods in a software application. For example if the software application is provided in a module containing byte code then the component may load the module interpret the byte code and identify methods defined within the byte code. For example software applications managed by the MICROSOFT .NET Framework are stored in modules e.g. dynamically linked libraries DLL executables EXE or other formats that contain byte code that can be compiled by a just in time JIT compiler before execution. The method identification component can use APIs provided by the .NET Framework to identify methods within a stored application module. The methods may include static functions virtual functions global functions class member functions or other types of methods within the module.

The method cloning component clones an identified method to create a modifiable copy of the method for unit testing. The method identification component may provide beginning and ending locations for an identified method within a software module so that the method cloning component can copy the identified method by copying bytes starting at the beginning location and ending at the ending location to a new location such as memory allocated by the system . By copying the identified method the system can manipulate and modify the method in ways that enhance testability without requiring modifications to the original methods e.g. by the developer . Instead of creating a build of an application targeted just for unit testing a developer can use the system to test a production ready version of the application and the system can modify the methods to produce versions that are unit testable.

The call identification component identifies calls to one or more other methods within an identified method. Opportunities for unit testing are often found at locations where a method calls another method. For example a developer may want to test that the outer method behaves correctly when the inner method returns an error code. The developer can use the system to replace the inner method with a mock method having a similar signature e.g. number of parameters calling convention return type and so forth as the original and the mock method can return the error that the developer wants to use to test the outer function behavior. Another reason to identify external calls is that the calls may represent subsystems that are not available during unit testing. For example a software application may be written to expect a database other servers and other infrastructure that are not available in a typical single machine unit test environment. Accordingly the call identification component can identify such calls and the developer can provide replacement versions of objects or methods that use a different paradigm. For example a developer may replace a database call with a method that returns a predefined set of data.

The call redirection component replaces an identified call to a method with a call to an intercept method. The intercept method invokes the system to allow the system to perform processing during handling of the method call such as calling a unit test to modify behavior of the intercepted method. The unit test or intercept method may call the original method before or after performing unit test processing. For example a unit test may retrieve a return value from the original method by calling the original method and then modify the return value in some manner before passing the value back to the calling function. As another example the unit test may replace the original method entirely and substitute its own processing for that of the original method. For methods for which the developer provides no unit test the call redirection component may generate an intercept method that simply calls the original method or may decline to redirect the method leaving the original method call in place in the cloned version of the method.

The system may create a separate intercept method for each call that contains information specific to that call location such as an identification of the original call target. Alternatively or additionally the system may provide a generic intercept method that receives variable arguments e.g. varargs in C . The arguments can include the original arguments of the call as well as additional parameters for passing information from the system to the intercept method e.g. the original target function address .

The unit test store is a data store that stores one or more unit tests for testing the software application. The unit test store may include a declarative store of unit tests e.g. an extensible markup language XML file a separate testing module e.g. a DLL with unit tests or other forms of storing testing functions. The unit tests may also be stored in a database a file system a cloud based storage service or other manner of persisting data. For example for a software project worked on by a team of developers the team may place unit tests in a location accessible by each of the developers so that modifications to the software application can be tested using each developer s unit tests to verify correctness of the modifications.

The intercept handling component receives calls to intercept functions and invokes the system to perform unit testing. For example upon receiving an intercept call the component may identify a mock unit test object a developer provided to replace an original object in the software application and invoke the mock unit test object to perform unit testing. By cloning methods of the application and modifying the cloned methods to intercept external calls to other methods the system ensures that a developer provided unit test function is called regardless of the type of the original method e.g. virtual static and so forth without any additional effort on the developer s part. The intercept handling component receives notification that an intercepted function was called and provides the developer s unit tests with an opportunity to run and influence the behavior of the called method so that the software application can be successfully testes.

The computing device on which the unit testing system is implemented may include a central processing unit memory input devices e.g. keyboard and pointing devices output devices e.g. display devices and storage devices e.g. disk drives or other non volatile storage media . The memory and storage devices are computer readable storage media that may be encoded with computer executable instructions e.g. software that implement or enable the system. In addition the data structures and message structures may be stored or transmitted via a data transmission medium such as a signal on a communication link. Various communication links may be used such as the Internet a local area network a wide area network a point to point dial up connection a cell phone network and so on.

Embodiments of the system may be implemented in various operating environments that include personal computers server computers handheld or laptop devices multiprocessor systems microprocessor based systems programmable consumer electronics digital cameras network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and so on. The computer systems may be cell phones personal digital assistants smart phones personal computers programmable consumer electronics digital cameras and so on.

The system may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures and so on that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

Continuing in block the system copies byte code of the selected method to a modifiable location. Software functions are often stored in the software application module in compiled byte code. The system copies the byte code to a new location such as memory allocated by the system for that purpose. At the new location the system can modify the byte code of the method to intercept calls and place hooks in the byte code to aid unit testing. Continuing in block the system identifies calls to one or more inner methods in the copied selected method. Locations where one method calls another are often good locations to hook for unit testing. The system identifies calls by walking through the byte code of the selected method either internally or by calling an API for interpreting byte code. Upon identifying a call the system stores the original target of the call and inserts an intercept method as described herein. Continuing in block the system selects the first identified inner method. In subsequent iterations the system selects the next inner method for processing.

Continuing in block the system creates an interception method to replace an original target method of the selected inner method. The interception method may include a hook function that invokes the system to identify mock objects provided by a developer to use for unit testing of the software application. The system provides an identification of the original method to the interception method such as by hard coding it within a specific interception method or by passing an extra parameter to a generic interception method. Continuing in block the system replaces the originally called inner method in the copied byte code with the created interception method so that when the selected function is invoked the interception method will be called. A method is often identified by a memory address at which the method is located and the system can replace calls to such methods by replacing a target address with the memory address of the interception method. Because the system has cloned the original code of the selected method the system can modify the cloned copy without harming the original method or running into memory access problems e.g. read only code regions of memory .

Continuing in decision block if there are more calls to inner methods then the system loops to block to select the next identified inner method else the system continues at block . Continuing in decision block if there are more identified methods in the software module then the system loop to block to select the next identified method for processing else the system completes. After block these steps conclude. Following these steps the software module is ready for unit testing and the system will be able to hook any method calls and insert the developer s unit testing code throughout the application s execution path.

Continuing in block the component determines whether a mock object associated with the received interception method exists. A mock object may include a replacement function for the original method that the interception method replaced or a data object that is a parameter or otherwise related to the called location. For example a developer may want to replace a called function with a new function during unit testing or may want to call an original function with different data during unit testing. Continuing in block if a mock object exists then the component continues at block and invokes the mock object else the component continues at block .

Continuing in block the component invokes an original target associated with a location of the received call to the interception method. The interception method replaces an original target and provides an opportunity to hook application behavior at that location for testing. If no modification to application behavior is provided for that location then execution simply continues as originally designed by the application. After block the component completes.

Continuing in block the component substitutes a mock object for an original target associated with a location of the received call to the interception method and invokes the mock object. The interception function includes logic for locating a mock object invoking the mock object and providing one or more results of invoking the mock object back to the callee method. After block these steps conclude.

For existing unit test frameworks the method MockMe is difficult or impossible to hook if mClassToTest is a sealed class or if MockMe is not a virtual method. Some frameworks attempt to dynamically create a subclass of mClassToTest that is modifiable but this has limited success and will not work in many common cases. The unit testing system described herein uses the .NET Reflection API or other APIs to locate the byte code for TestMe and then clones the byte code to a new location where it can be modified to do anything that the unit test author wants it to do. An example of an intercept function inserted into the cloned method follows.

Inside the intercept function the system can invoke mock objects provided by the developer for unit testing. The system may also pass additional parameters to the mock object such as reflection information retrieved using the Reflection API of an application framework such as .NET.

Following is a real world example of how the unit testing system can be used to unit test software application code. Imagine a developer has a very simple Windows Presentation Framework WPF window with a CheckBox 

Normally testing the OnButton1Clicked event handler might be very difficult if the developer wanted to mock up the ComboBox. This is because none of ComboBox s properties or methods is virtual so they cannot be mocked without doing lots of additional work. The unit testing system can make testing GUIs in this circumstance as trivial as using regular mock objects 

And unit tests look exactly the same in this case as if the developer was using standard mock objects without cloning 

In some embodiments the unit testing system performs additional processing to overcome access checks by an application framework on data marked private by an application developer. For example some versions of the .NET CLR verify access to private data at runtime such that it is difficult to mock method parameters that are marked private. To overcome this the system can use the Reflection API or other APIs to dynamically locate class arguments and access the data intended. An access to the data through reflection is allowed by the framework even when a typical access is denied by access checking. For example consider the following code in a unit test this.mField 12 if mField is private then the set may not work at runtime. The system can replace this line in the byte code with a new function SetmField that uses reflection to achieve the same result.

The unit testing system may also modify method calls that return a structure e.g. struct in C to overcome framework checking that would otherwise thwart unit testing. Instead the system can provide a new method with a void return that passes the structure by reference e.g. static void GetmField Object this struct s . When code is encountered that accesses the field e.g. int i this.Field the system replaces the byte code with a call to the static function so that using .NET Intermediate Language IL 

In other words the system replaces the direct access of the field with a call through GetField which can use reflection to avoid access checking.

In some embodiments the unit testing system hooks methods for unit testing by adding additional parameters to the methods that include mock object provided by the developer. For example the system can include a class parameter that describes a mock object and replace calls to methods of an original class with calls to the mock object in lieu of inserting an intercept function . For example consider the following.

At runtime the unit testing system replaces mClass with the mock class so that the CallMe call goes to the mocked class instead of the original class.

From the foregoing it will be appreciated that specific embodiments of the unit testing system have been described herein for purposes of illustration but that various modifications may be made without deviating from the spirit and scope of the invention. Accordingly the invention is not limited except as by the appended claims.

