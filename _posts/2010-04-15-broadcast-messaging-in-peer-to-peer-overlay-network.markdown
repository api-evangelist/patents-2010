---

title: Broadcast messaging in peer to peer overlay network
abstract: Broadcast messages are efficiently directed to nodes of an overlay network. Broadcast messages include an End ID parameter specifying the range of key values for nodes that should receive the broadcast message. Each node of an overlay network maintains a list of finger nodes and their respective key values. Upon receiving a broadcast message, a node assigns a finger node a new End ID value based upon the End ID value of the broadcast message or the key value of an adjacent finger node. The node compares a finger node's new End ID value with the finger node's key value to determine whether to forward the broadcast message to that finger node. A broadcast message forwarded to a finger node includes an End ID parameter equal to the new End ID value determined for the finger node. Nodes can aggregate response messages from its finger nodes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07969906&OS=07969906&RS=07969906
owner: Sony Computer Entertainment Inc.
number: 07969906
owner_city: Tokyo
owner_country: JP
publication_date: 20100415
---
The present application is a continuation application of and claims priority to U.S. Non Provisional Application No. 12 330 267 filed Dec. 8 2008 now issued U.S. Pat. No. 7 729 280 which is a continuation application of and claims priority from U.S. Non Provisional Application No. 11 291 121 filed on Nov. 29 2005 now U.S. Pat. No. 7 468 952 issued Dec. 23 2008 both entitled Broadcast Messaging in Peer to Peer Overlay Network which are hereby incorporated herein by reference.

The present disclosure relates to the field of data networks and in particular to peer to peer overlay networks. Peer to peer networks are distributed data networks without any centralized hierarchy or organization. Peer to peer data networks provide a robust and flexible means of communicating information between large numbers of computers or other information devices referred to in general as nodes.

An overlay network is a logical or virtual network organization that is imposed on nodes connected by one or more types of underlying physical network connections. In an overlay network nodes are connected by virtual or logical links each of which can correspond with one or more paths in an underlying physical network. Overlay network are typically implemented in hardware and or software operating in the application layer or other top level layer of an OSI network stack or other type of networking protocol.

One class of peer to peer overlay networks are referred to as distributed hash table networks. Distributed hash table overlay networks use a hash function to generate and assign one or more key values to a unique node. The set of all possible key values is referred to as a hash space. Nodes are organized in the hash space according to their assigned key values. The hash function is selected so that nodes are approximately evenly distributed throughout the hash space. Distributed hash table overlay networks are typically highly scalable often supporting millions of nodes robust allowing nodes to join or leave frequently and efficient routing a message to a single destination node quickly.

There are numerous different types of distributed hash table overlay networks. One type of peer to peer overlay network is a chord network. The chord overlay network protocol is described in detail in Chord A Scalable Peer to peer Lookup Protocol for Internet Applications Ion Stoica Robert Morris David Liben Nowell David R. Karger M. Frans Kaashoek Frank Dabek Hari Balakrishnan Vol. 11 No. 1 pp. 17 32 February 2003.

Although distributed hash table overlay network protocols such as the chord protocol provide efficient distribution of a message to a single destination node they do not allow for a single message to be efficiently distributed to multiple destination nodes referred to as broadcasting a message.

In one typical implementation a node desiring to broadcast a message to all of the other nodes must send a message to each node separately. As each node only has direct knowledge of a limited number of nodes a node initiating a broadcast message referred to as an initiating node must blindly send messages to all possible key values. For distributed hash table networks this entails sending a separate message to each possible key value. For a distributed hash table network with a hash space of 2 160 arising from the use of a 160 bit hash function such as SHA 1 this is unfeasible.

In another typical implementation a flooding approach is used to distribute a broadcast message. An initiating node sends a message to all of the nodes directly connected with the initiating node in the overlay network. Upon receiving the message each receiving node in turn forwards the message to any additional nodes directly connected with each receiving node in the overlay network. This implementation is inefficient as some nodes receive redundant messages. Moreover this implementation consumes a large amount of network bandwidth and takes a large amount of time to operated.

To reduce the bandwidth required by flooding broadcast messages a modified flooding scheme assigns a time to live TTL value to each broadcast message. Each time a copy of a broadcast message is forwarded to additional node its TTL value is decremented. When the TTL value reaches 1 the broadcast message is no longer forwarded. Although this modified flooding scheme reduces the amount of wasted network bandwidth and the number of duplicate messages it cannot ensure that the broadcast message will be routed to all nodes.

It is therefore desirable for a system and method to guarantee each node in a peer to peer overlay network receives a broadcast message. It is further desirable that the system and method guarantees that each node in a peer to peer overlay network receives only one copy of a broadcast message thereby ensuring that network bandwidth is efficiently utilized. It is further desirable that the system and method require minimal time and bandwidth resources from a node initiating a broadcast message. It is also desirable that the system and method enable broadcast messages to be selectively directed to portions of the overlay network with no additional network bandwidth overhead. It is desirable for the system and method to deliver broadcast messages to all or a selected portion of the peer to peer overlay network within a minimal time period. It is desirable for the system and method to enable efficient aggregation of query results from nodes in a peer to peer overlay network.

An embodiment of the invention efficiently directs broadcast messages to nodes of an overlay network without wasting network bandwidth on duplicate messages or unintentionally omitting any nodes. Broadcast messages include an End ID parameter. The End ID parameter specifies the range of key values for nodes that should receive copies of the broadcast message. Each node maintains a list of finger nodes and their respective key values. Upon receiving a broadcast message a node assigns each finger node a new End ID value based upon the End ID value of the received broadcast message or the key value of an adjacent finger node. The node compares each finger node s new End ID value with the finger node s key value to determine whether to forward the broadcast message to that finger node. A broadcast message forwarded to a finger node includes an End ID parameter equal to the new End ID value determined for the finger node. Nodes can respond to broadcast messages and aggregate response message from its finger nodes.

In an embodiment a method of processing a broadcast message in an overlay network includes receiving a broadcast message including an End ID from a sending node. The End ID specifies a range of key values for finger nodes that should receive copies of the broadcast message. The method selects an entry of a finger table. Each entry of the finger table includes a reference to a finger node and a key value associated with the finger node.

An embodiment of the method determines if there is a following entry of the finger table. The following entry includes a key value adjacent to the key value of the selected finger table entry according to a node order. The method sets a new End ID value to the key value associated with the following entry in response to the determination that there is a following entry of the finger table. The method sets a new End ID value to the End ID of the received broadcast message in response to the determination that there is not a following entry of the finger table. The method comparing the key value of the selected finger table entry with the new End ID value and forwards a copy of the broadcast message with the new End ID value to the finger node of the selected entry in response to a determination that the key value of the selected finger table entry is within the range of key values specified by the new End ID value.

In a further embodiment the finger table includes two or more entries arranged according to their respective key values. In an embodiment the node order is ascending according to key values. In another embodiment the node order is descending according to key values.

In an additional embodiment the method stores a reference to a sending node communicating the broadcast message. The method receives a response message from at least one finger node in response to the forwarded copy of broadcast message and aggregating the received response messages into a combined response message. The combined response message is forwarded to the sending node.

In still another embodiment the method can receive a response to the broadcast message and include the response in the combined response message. In yet another embodiment the combined response message includes response messages from one or more nodes in a compact representation created using a frequency domain transformation.

The nodes of the overlay network are arranged by their assigned key values in the hash space or set of all possible key values. In the hash space is shown as a ring configuration of all possible key values from 0 to 2 with N being the number of bits allocated for a key value. In some implementations N equals 160 bits which is the size of the output of typical hash functions such as SHA 1 and is sufficiently large to avoid hash collisions. In this implementation the chord overlay network supports up to 2nodes and a typical chord overlay network can include millions of active nodes. Other implementations can use more or less hash bits.

In some implementations each node is assigned a key value randomly. In some implementations each node is assigned a key value based upon the results of a hash function of one or more attributes of the node. The hash function is selected so that nodes are approximately evenly distributed throughout the hash space . In additional implementations the assignment of key values to nodes is based at least in part on the topology of the underlying physical network. In these implementations nodes are distributed approximately evenly throughout the hash space however the overlay network attempts to ensure that nodes located in close proximity in the physical network are also located in close proximity in the hash space of the overlay network as well.

Based upon the arrangement of nodes in the hash space each node includes a reference to one or more adjacent nodes. In some implementations of a chord overlay network each node includes a reference to the preceding and succeeding adjacent nodes. For example node with a key value of 60 can include references to nodes and having key values of 45 and 115 respectively. If a new node is added with a key value between that of nodes and such as a key value of 100 the appropriate reference of node will be adjusted accordingly.

In a further implementation each node includes a finger table including references to one or more nearby nodes. Each finger table entry references the node nearest to a key value specified by an offset from the key value of the present node. In some of these implementations each finger table entry s offset corresponds with a binary place value. For example a first finger table entry has an offset value of one 2 a second finger table entry has an offset value of two 2 a third finger table entry has an offset value of four 2 a fourth finger table entry has an offset value of eight 2 and so forth. In other implementations different offset values can be associated with each finger table entry.

Finger tables can have any arbitrary number of entries. Larger finger tables can decrease routing time for messages at the expense of more complicated maintenance overhead for adding or removing nodes. For example if a key value is comprised of N bits each node may have a finger table with N entries. In other implementations other finger table sizes may be optimal depending upon the application.

In this implementation of an overlay network each node only knows the location of the nodes specified by references in its finger table. However nodes are capable of sending messages to any other node in the overlay network via one or more intermediate nodes. illustrates an example routing of a message in an overlay network according to this implementation.

In the example of node having a key value of 0 directs a message to node having a key value of 6. The finger table of node has references to nodes and having key values of 1 2 4 and 8 respectively. To deliver a message to node with a key value of 6 node forwards the message to the node in its finger table having the largest key value less than or equal to the key value of the destination node. In this example node forwards the message to node having a key value of 4. In the finger table of node node has the largest key value 4 that is less than or equal to the destination node key value of 6.

Upon receiving a message directed to node with a key value of 6 node uses its own finger table to identify a node having the largest key value less than or equal to the destination node key value. In this example node with a key value of 4 has a finger table with references to nodes and having key values of 5 6 8 and 12 respectively. Based on its finger table node forwards the message to node having a key value of 6 which is the desired destination key value.

Although the overlay networks described above can route messages to single nodes efficiently there is no mechanism for efficiently forwarding broadcast messages to all or a substantial portion of the overlay network. Each node has direct knowledge of only the nodes in its finger table. Thus to send a message to all of the nodes in the overlay network a node initiating a broadcast message referred to as an initiating node must send separate messages to each possible key value. For a hash space of 2 there is an astronomical number of key values which makes this approach impractical.

As described above a flooding approach to directing broadcast messages wastes network bandwidth and may not guarantee that the broadcast message will be routed to all nodes. In a flooding approach each node forwards a received broadcast message to all of the other nodes that it is connected with. Thus in the overlay network node would forward a broadcast message to nodes and . Each node in turn would forward the received broadcast message to the nodes in its finger table. For example node would forward the broadcast message to nodes and . As can be seen in node receives the broadcast message at least twice from node and then from node .

Method is initiated upon a node receiving a broadcast message. In an embodiment each broadcast message includes an End ID parameter. The End ID parameter represents the range of key values of nodes that the broadcast message may be forwarded to. For example if a node receives a broadcast message with an End ID value of 17 then the node may forward a copy of the broadcast message to any node in its finger table with a key value less than 17. Furthermore each forwarded copy of the broadcast message is assigned an End ID value according to method to prevent duplicate messages from being sent to nodes.

A received broadcast message is processed by a node as follows. In step the node sets an index value i to the first entry of the node s finger table. In decision block the node determines whether the finger table entry specified by the index value i referred to as the selected finger table entry is the last entry of the node s finger table. If so then method proceeds from decision block to step . Step assigns the parameter newEndID to be equal to the End ID of the received broadcast message.

Conversely if the node determines that the selected finger table entry is not the last entry of the node s finger table method proceeds from decision block to step . Step assigns the parameter newEndID to be equal to the key value of the next finger table entry i.e. the finger table entry specified by index i 1 or the End ID of the received broadcast message whichever is closer to the current node in the hash space. The distance between the current node and a key value such as the next finger table entry or the current End ID can determined in an embodiment by subtracting the current node s key value from the other key value.

In this embodiment of step it is assumed that the entries of the finger table are arranged in order of the key values of their respective nodes and that broadcast messages are to be communicated to nodes in order of increasing key values. However in alternate embodiments the finger table can be arranged in a different order. In these embodiments step assigns the parameter newEndID to be equal to the finger table entry key value greater than and closest to the key value of the selected finger table entry. This embodiment communicates broadcast messages to nodes in order of increasing key values. In a further embodiment if broadcast messages are to be communicated to nodes in order of decreasing key values then step assigns the parameter newEndID to be equal to the finger table entry key value less than and closest to the key value of the selected finger table entry.

Following step or step method proceeds to decision block . In decision block the node determines if the key value of the selected finger table entry is less than the value of the newEndID parameter. If so method proceeds to step . Otherwise method proceeds directly to decision block .

Step forwards a copy of the broadcast message to the node associated with the selected finger table entry. The forwarded copy of the broadcast message includes an End ID value set to the value of the newEndID parameter.

Following decision block or step method proceeds to decision block . Decision block determines if the selected finger table entry is the last entry of the node s finger table. If so then method ends and the node is finished forwarding the broadcast message.

If decision block determines that the selected finger table entry is not the last entry of the node s finger table method proceeds to step . Step increments the index i thereby selecting the next finger table entry of the node s finger table. Following step method proceeds back to decision block . Steps and may be repeated as many times as necessary to evaluate all of the entries of the node s finger table.

Node does not forward its received broadcast message to any nodes. In the first phase node received a broadcast message with an End ID of 9. As there are no finger nodes between node with a key value of 8 and its received End ID value of 9 node has no nodes to forward its received broadcast message to.

In the example of key values 3 5 10 and 11 assigned to locations and respectively are not assigned to any nodes. Thus the first entry of the finger table of node references node which as a key value of 12. However node received a broadcast message in phase with an End ID value of 12. As node does not have any nodes in its finger table closer than the End ID value of 12 node does not have any nodes to forward its received broadcast message to.

Because of the End ID values of their received broadcast messages in phase nodes and will not forward any broadcast messages in phase . Similarly the broadcast messages received by nodes and in phase will not be forwarded to any other nodes in the overlay network due to their respective End ID values.

As can be seen from the example of every node in the overlay network receives a copy of the broadcast message. Additionally no node in the overlay network receives a duplicate of the broadcast message. Furthermore the initiating node only requires enough network bandwidth to send a copy of the broadcast message to each node in its finger table regardless of the total number of nodes in the overlay network. For the example of this is only four broadcast messages. In an overlay network having nodes with 160 entry finger tables corresponding to a hash space of 2 the initiating node only needs to send 160 copies of the broadcast message to reach potentially millions of nodes.

Moreover it can be proven that the method is capable of directing a broadcast message to all of the nodes of an overlay network in O logN time where N is the number of the nodes in the overlay network. For the example of this corresponds to log 10 3.32 time or approximately three phases of forwarding and receiving broadcast messages. For an example overlay network with a 160 bit hash space with 1 000 000 nodes method can direct a broadcast message to all of the nodes in approximately 20 time or 20 phases of forwarding and receiving broadcast messages.

In a further embodiment broadcast messages can be directed to only a portion of the nodes in an overlay network. In an embodiment each broadcast message includes a Start ID parameter in addition to an End ID parameter. The Start ID parameter represents the beginning of a range of key values of nodes that are intended to receive and process the broadcast message. As explained in detail below additional nodes outside of this range of key values may receive and forward broadcast messages to ensure that all of the nodes within this range of key values receive the broadcast message. In this embodiment the Start ID and End ID together specify that the nodes of a contiguous portion of the hash space should receive a broadcast message. An initiating node can direct a broadcast message to discontiguous sets of nodes in the overlay network by sending multiple broadcast messages each with Start ID and End ID values specifying different contiguous portions of the hash space.

Conversely if the node determines that the selected finger table entry is not the last entry of the node s finger table method proceeds from decision block to step . Step assigns the parameter newEndID to be equal to the key value of the next finger table entry i.e. the finger table entry specified by index i 1 or the End ID of the received broadcast message whichever is closer to the current node in the hash space. The distance between the current node and a key value such as the next finger table entry or the current End ID can determined in an embodiment by subtracting the current node s key value from the other key value.

In this embodiment of step it is assumed that the entries of the finger table are arranged in order of the key values of their respective nodes and that broadcast messages are to be communicated to nodes in order of increasing key values. However in alternate embodiments the finger table can be arranged in a different order and broadcast messages can be communicated in increasing or decreasing order of key values.

Following step or step method proceeds to decision block . In decision block the node determines if the key value of the selected finger table entry is less than the value of the newEndID parameter and if the Start ID parameter of the received broadcast message is closer than the newEndID parameter. If both of these conditions are true then method proceeds to step . Step sets a newStartID parameter to be equal to the key value of the selected finger table entry or the StartID parameter of the received broadcast message whichever is further from the current node in the hash space.

Following step step forwards a broadcast message to the node corresponding with the selected finger table entry. The forwarded broadcast message includes a start ID equal to the newStartID parameter and an end ID parameter equal to the newEndID parameter.

Following decision block or step method proceeds to decision block . Decision block determines if the selected finger table entry is the last entry of the node s finger table. If so then method ends and the node is finished forwarding the broadcast message.

If decision block determines that the selected finger table entry is not the last entry of the node s finger table method proceeds to step . Step increments the index i thereby selecting the next finger table entry of the node s finger table. Following step method proceeds back to decision block . Steps and may be repeated as many times as necessary to evaluate all of the entries of the node s finger table.

Broadcast messages can carry any type of information to all or a portion of the nodes of the overlay network. Additionally one or more nodes can respond to broadcast messages by directly contacting the node initiating the broadcast message. If large numbers of nodes can potentially respond to a broadcast message the initiating node and its network connection may be overwhelmed.

A further embodiment of the invention alleviates this problem by aggregating response messages along the same routes used to distribute a broadcast message. In this embodiment when each node receives a broadcast message that potentially requires a response from itself or another node the receiving node remembers the location of the node sending the broadcast message referred to as the sending node which may be the node initiating the broadcast message or an intermediate node forwarding the broadcast message. If the receiving node determines that a response to the broadcast message is necessary the receiving node forwards its response back to its respective sending node. As a node can receive a broadcast message from potentially any node in an embodiment each node remembers the sending node associated with each broadcast message it receives.

When a node receives a response message from one or more nodes the node aggregates the response messages into a new response message which is then forwarded back to its sending node. In an embodiment nodes can choose not to respond to a broadcast message. For example if the broadcast message is a search query a node can choose to response only if the node satisfies the search query.

A node can aggregate response messages using any algorithm for compressing or aggregating data known in the art. For example if nodes and both respond to a broadcast message then node will receive both responses. Node can aggregate these responses along with the response of node and or its own response if any into a combined response message. Node then forwards the combined response message back to node .

In an embodiment a node aggregates these responses by determining a compact representation of the set of responses. For example a frequency domain transformation such as a discrete cosine transformation fast Fourier transform or wavelet transformation can be applied to determine a compact representation of the set of responses to a broadcast message. In this example a node can receive one or more frequency domain representations of sets of message responses inverse transform these representations combine these representations along with the nodes own response if any create a new frequency domain representation of the combined sets of message responses and forwards the combined frequency domain representation back to its sending node.

In a further embodiment some devices of overlay network may have restricted capabilities. For example only a limited subset of nodes of overlay network may be allowed to initiate broadcast messages. The remaining nodes are only permitted to forward and or process broadcast message. In still a further embodiment all or a subset of the nodes of overlay network are capable of authenticating broadcast messages. This embodiment prevents the spread of unauthorized broadcast messages. Upon receiving a broadcast message a node first determines whether the broadcast message is authentic for example by checking a cryptographic signature. If a broadcast message is authentic it is processed and potentially forwarded to other nodes as described above. Otherwise the broadcast message is ignored.

Overlay network includes processors and . In further embodiments overlay network can include thousands or millions of processors. Each processor can be a microprocessor microcontroller system on a chip processor digital signal processor ASIC programmable logic device and or any other type of information processing device. Each processor can further include one or more processing units capable of independently executing sequences of information processing instructions or processing information according to a fixed algorithm. Each processor can include local data storage as well as access to common or shared data storage.

A graphics subsystem is further connected with data bus and the components of the computer system . The graphics subsystem includes a graphics processing unit GPU and graphics memory . Graphics memory includes a display memory e.g. a frame buffer used for storing pixel data for each pixel of an output image. Graphics memory can be integrated in the same device as GPU connected as a separate device with GPU and or implemented within memory . Pixel data can be provided to graphics memory directly from the CPU . Alternatively CPU provides the GPU with data and or instructions defining the desired output images from which the GPU generates the pixel data of one or more output images. The data and or instructions defining the desired output images can be stored in memory and or graphics memory . In an embodiment the GPU includes 3D rendering capabilities for generating pixel data for output images from instructions and data defining the geometry lighting shading texturing motion and or camera parameters for a scene. The GPU can further include one or more programmable execution units capable of executing shader programs.

The graphics subsystem periodically outputs pixel data for an image from graphics memory to be displayed on display device . Display device is any device capable of displaying visual information in response to a signal from the computer system including CRT LCD plasma and OLED displays. Computer system can provide the display device with an analog or digital signal.

Further embodiments can be envisioned to one of ordinary skill in the art from the specification and figures. In other embodiments combinations or sub combinations of the above disclosed invention can be advantageously made. The block diagrams of the architecture and flow charts are grouped for ease of understanding. However it should be understood that combinations of blocks additions of new blocks re arrangement of blocks and the like are contemplated in alternative embodiments of the present invention.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

