---

title: Tracing flow of data in a distributed computing application
abstract: A method is provided for tracing dataflow in a distributed computing application. For example, the method includes incrementally advancing a dataflow in a dataflow path of one or more dataflow paths according to two or more directives encoded in two or more data messages. The method further includes performing the two or more directives. The dataflow path includes one or more operators including at least one merge operator operative to merge the two or more data messages and merge the two or more directives. One or more of the incrementally advancing of the dataflow and the performing of the two or more directives are implemented as instruction code performed on a processor device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08656369&OS=08656369&RS=08656369
owner: International Business Machines Corporation
number: 08656369
owner_city: Armonk
owner_country: US
publication_date: 20100524
---
This invention was made with Government support under Contract No. H98230 07 C 0383 awarded by Department of Defense. The Government has certain rights in this invention.

The present invention relates generally to distributed computing applications and more particularly to debugging flow based distributed computing applications according to data paths of the distributed flow based applications.

Distributed computing is performed on distributed computing systems. A distributed system may comprise multiple autonomous computers communicating through a computer network. The computers may interact with each other in order to achieve a common goal. A distributed application is a computer program that runs on a distributed system. For example a distributed application running on a distributed computing system may be used to solve computational problems that are divided into a plurality of tasks. Each task may be solved by one computer of the distributed computing system.

Applications are computer software operable to help a user perform a singular or multiple related specific tasks. Typical examples are word processors spreadsheets media players and database applications. Applications may be for example execution flow based or data flow based.

Debugging is a methodical process of finding and reducing a number of bugs or defects in an application in order to make the application behave as intended. Debugging may involve interactive debugging control flow integration testing log files monitoring memory dumps and or statistical process control. Conventional debugging may step through follow or manipulate an execution flow of an application.

Tracing is a process related to debugging in which the flow of execution through an application or between components of a distributed application is tracked by the application developer. When tracing developers follow or record the execution flow or changes to the data as it transits specific parts of the application or responds to specific application events. The data captured while tracing may include snapshots of the application s state as well as timestamps. This information is helpful for enhancing application understanding and diagnosing performance problems or data transformation errors.

Principles of the invention provide for example methods apparatus and systems for tracing dataflow in a distributed computing application.

In accordance with a first aspect of the invention a method for tracing dataflow in a distributed computing application is provided. The method comprises incrementally advancing a dataflow in a dataflow path of one or more dataflow paths according to two or more directives encoded in two or more data messages. The method further comprises performing the two or more directives. The dataflow path comprises one or more operators comprising at least one merge operator operative to merge the two or more data messages and merge the two or more directives. One or more of the incrementally advancing of the dataflow and the performing of the two or more directives are implemented as instruction code performed on a processor device.

In accordance with a second aspect of the invention a system for tracing dataflow in a distributed computing application is provided. The system comprises modules for implementing the above method.

In accordance with a third aspect of the invention apparatus for tracing dataflow in a distributed computing application is provided. The apparatus includes a memory and a processor coupled to the memory. The apparatus is configured to perform the above method.

In accordance with a fourth aspect of the invention an article of manufacture for tracing dataflow in a distributed computing application is provided. The article of manufacture is tangibly embodying a computer readable program code which when executed causes the computer to carry out the above method.

Advantageously an illustrative embodiment of the present invention may be utilized by a debugging tool to step through and trace a data path of a distributed flow based application. The debugging tool may for example localize and diagnose application defects for large scale distributed applications that process data at high frequencies while only minimally impacting the performance of the application. The debugging tool may be applied to for example stock market analytics operating at market transaction rates and monitoring manufacturing systems. The debugging tool may be used in conjunction with tools that visualize the topology of the distributed application and data flow paths performance and memory profiling tools and source code debugging tools.

These and other features objects and advantages of the present invention will become apparent from the following detailed description of illustrative embodiments thereof which is to be read in connection with the accompanying drawings.

Principles of the present invention will be described herein in the context of illustrative embodiments of methods apparatus and systems for debugging visualizing profiling and understanding computing application according to a data path in a flow based computing application. It is to be appreciated however that the principles of the present invention are not limited to the specific apparatus systems and methods illustratively shown and described herein. Rather the principles of the invention are directed broadly to techniques related to tracing data messages in a flow based computing application. For this reason numerous modifications can be made to the embodiments shown that are within the scope of the present invention. That is no limitations with respect to the specific embodiments described herein are intended or should be inferred.

As used herein the term application generally refers to a computing application which typically performs or helps to perform one or more specific tasks. Applications are usually expressed in software code or instructions e.g. software code stored in memory and performed by a processor device coupled to the memory but may be expressed in firmware. Applications are usually considered to be exclusive of system software infrastructure or middleware computer services processes integrators . System software and middleware are involved in integrating various capabilities of a computing device but typically do not directly direct the capabilities in performing tasks that benefit the user. An application typically applies or directs the capabilities to perform tasks for a user.

As used herein a distributed application generally refers an application configured to run on a system of multiple autonomous computing devices e.g. computers for example computing devices that communicate through a computer network e.g. the Internet . The computing devices interact with each other in order to achieve a common goal for example the goal of the distributed application. Distributed applications may comprise for example hundreds of operators thousands of possible data paths and millions of messages per second.

An application comprises a collection of operators e.g. components for performing specific computing functions that carry out data transformations such as filtering aggregations correlations etc. or specific data analytics such as data classification data mining etc. .

As used herein a message generally refers to a message passed within software e.g. an application or software supporting an application . The message may or may not be directly human readable. A hop refers to a connection between two operators. The hop count associated with a message is typically incremented when the message is transferred from the output port of an operator to an adjacent input port of an operator.

As used herein dataflow applications include applications based on dataflow principles and architecture and may be for example modeled as a directed graph of data flowing between operations.

As used herein flow based applications may be considered to be for example applications comprising one or more networks of asynchronous reusable components transforming streams of formatted data objects i.e. data streams . For example flow based applications may comprise one or more networks of black box processes which exchange data across predefined connections e.g. one way connections by message passing. These black box processes may be for example reconnected in different ways to form different applications without having to change the black box processes internally. Thus flow based applications are component oriented. Flow Based applications are based on the concept of multiple asynchronous processes communicating by means of data streams. For example a flow based application may be viewed as a system of data streams being transformed by processes. None of the processes need be aware of what other processes are coupled to it. Communication between processes is according to connections defined external to the processes allowing components e.g. processes to be considered to be black boxes. 

Flow based applications may be considered for example a type of dataflow application therefore as used herein references to flow based applications are implicitly references to dataflow applications. Dataflow and flow based applications may be for example distributed applications.

As used herein a breakpoint includes an intentional interrupting point e.g. stopping or pausing point in a program put in the program for for example debugging purposes. More generally a breakpoint is a means of acquiring knowledge about a program during execution of the program. During the interruption a programmer may inspect the test environment of the program logs memory files etc. to obtain information e.g. to find out whether the program is functioning as expected . A breakpoint may be non conditional halting operation at a specified breakpoint without condition. Alternately a breakpoint may include one or more conditions that determine when execution of the program should be interrupted. A conditional breakpoint may be conditional on an operation for example a reading writing or modification of a specific memory location. As used herein a watchpoint generally refers to a conditional breakpoint that is triggered when a value of a data variable changes.

A tracepoint is a means of recording the internal state or behavior of an application without interrupting the application s execution. For example tracepoints may record when a particular instruction is executed and may also record the value of the program s data variable. Like breakpoints tracepoints can be conditional or non conditional.

It should be noted that as used herein the term debug directive encompasses encodings of both debug operations such as setting a breakpoint and trace operations such as cache intercepted data message. The term directive may generally refer to one or more commands instructions orders or directions that encode one or more actions operations or processes for example such actions operations or processes being associated with tracing and or debugging techniques.

Embodiments of the invention comprise methods and tools to step through and trace one or more data paths of a distributed dataflow application e.g. a Message Passing Interface MPI based application a stream processing application etc. . The application may be incrementally performed i.e. run or advanced the data path of messages may be traced directives that enable dataflow based debugging according to the incremental execution and the tracing of the data paths of messages may be encoded and debug directives may be merged and forwarded. The merging and forwarding may be implemented by application programming interfaces APIs and invoked by code generated by a flow based application compiler or invoked by custom code implemented by a developer.

Such methods tools and embodiments of the invention may be used for for example debugging of applications. One embodiment of the invention is a flow based debugger used for debugging flow based applications according to methods systems and techniques of the invention e.g. tracing data messages in a flow based distributed application .

Advantageously using the debugging tool a developer can debug inspect and interact with the dataflow application at a level of abstraction that is consistent with a programming model employed by the application. Such programming models may comprise for example operators that perform data transforms e.g. annotation join and aggregation connections between operators on which the data messages flow and or sending and receiving data and control messages.

Techniques for debugging distributed applications include analyzing system and application trace messages invoking a source code debugger to interrupt execution flow and inspecting the application state including objects containing message data using low level capabilities of the source code debuggers. Traditional debug techniques are based on execution flow of the application as opposed to the dataflow of the application. Moreover traditional techniques may involve a developer adjusting the location or content of trace messages by updating or rebuilding application code. Thus traditional techniques may require access to source code a relatively deep knowledge of application internals and a relatively deep knowledge of related distributed communication framework.

Methods of the present invention include for example debugging according to dataflow herein termed dataflow debugging. For dataflow debugging prior knowledge of the data path is not required to set breakpoints and intercept messages. In applications consisting of hundreds of operators and or thousands of connections discerning the data path may be hard and prone to errors. These operators may for example split a dataflow by replicating and routing a single inbound message on multiple outbound connections or aggregate multiple inbound data messages into fewer outbound data messages. Furthermore dataflow debugging may avoid for example source code debugging which may be cumbersome for diagnosing problems specific to composition of application consisting largely of generated code.

Methods of the invention further include for example systems mechanisms and software hooks for flexible and efficient debugging of applications include mechanisms enabling application developers to track the dataflow and include techniques for tracing e.g. generating trace messages at input and output ports of an operator and source debugging of operations along the data path.

An embodiment of the invention comprises i debug and tracing directives that are included in data messages of a dataflow application ii mechanisms for generating additional source code instruments in the application to be debugged and iii a dataflow debugger that intercepts and executes actions encoded in directives. The debugging actions encoded in the directives instruct the dataflow debugger to break execution flow when receiving debug directives encoded in data messages e.g. to intercept the data message and block the corresponding dataflow path and or to trace the message. Tracing the message comprises logging content of the message and forwarding the message without blocking the application i.e. without breaking execution flow . The embodiment also specifies rules for merging and reconciling debug directives received on input data messages to yield a composite output directive. Operations that combine data messages e.g. join split and aggregation operations may exploit these rules to map multiple input directives to a single output directive. The debugging actions are analogous to the definition of breakpoints and tracepoints that may be provided by a source code debugger like the GNU debugger GDB . However unlike GDB the dataflow debugger of the embodiment of the invention does not step through the execution flow of an application but steps through the dataflow of an application.

As previously mentioned operators e.g. components for performing computing functions may carry out data transformations such as filtering aggregations correlations etc. or specific data analytics such as data classification data mining etc. . Operators can receive data messages from other operators as well as produce data messages to be used or consumed by other operators. In many but not necessarily all cases the receipt of a data message by an operator triggers the execution of an operator s internal computational logic. Using a dataflow debugger of an embodiment of the invention a developer may stop on a boundary of an operator e.g. the operator entry point when for example receiving data messages or the operator output when for example producing data messages in the dataflow path and observe the transformations to data of the data message caused by applying logic of the operator to the incoming data message s .

In addition to intercepting and displaying the contents of the data message s at the operator boundaries embodiments of the invention comprise a mechanism for supporting the update of message data attributes which facilitate unit testing validation of boundary conditions and carrying out what if analysis.

By way of a non limiting example only a method of the invention incrementally executes and traces a dataflow in a distributed application. Debugging directives are encoded in data messages. The debugging directives may comprise directives for incrementally advancing the dataflow to a next operator and directives for incrementally advancing the dataflow to a next port. There are rules for merging and forwarding the debug directives when processed by operators that join split aggregate and forward data messages. A dataflow debugger intercepts interprets and executes the directives contained in the data messages.

The rules for merging and forwarding the debug directives comprise merge rules by which operators which combine input data messages each of which contain debug directives generate a single directive embodied in the output data message. Examples of such operators include join and aggregate. The rules for merging and forwarding the debug directives further comprise a rule by which a reset debug directive cancels a debug directive that is in process of being merged by operators that join and aggregate data messages.

Rules for fanning out and forwarding debug directives comprise split rules by which operators which route a single input data message to one or more output data messages and which replicate the debug directive to each output message.

The dataflow debugger can encode and insert debug directives in a data message and can delete debug directives from a data message. The debugger can further report the termination of dataflow when pending the completion of a step to the next operator or a step to the next port and or when the data message is discarded by the operator.

Advantageously embodiments of the invention simplify the debugging of large scale applications e.g. distributed flow based and or dataflow applications . Applications that consist of hundreds of operators and thousands of data paths can be very hard to debug because it is difficult to anticipate the path of a particular dataflow. For example in large applications some fanout operators forward a data message to one of thousands of downstream operators. Methods of the invention enables the developer to incrementally step through the dataflow or message flow of the application and follow the transformation of a particular sequence of messages e.g. data messages without needing to understand the details of a topological organization of operators of an application e.g. routing behavior of operators . For example methods of the invention may validate correctness and performance and diagnose defects of applications by inspecting and or tracking specific data through a chain of transformations e.g. transformations that combine data and may debug large scale distributed applications by localizing and diagnosing application defects for large scale distributed computing applications that process data at high frequencies. Minimizing impact on application performance and or resources is a feature of the invention.

Embodiments of the invention may be relatively inexpensive to implement because only unidirectional point to point interaction between dataflow debuggers using existing flow based and simple directives are used.

Methods of the invention minimize negative impact on performance and or resources. Advantageously there may not be a degradation of resources or performance when methods of the invention e.g. debugging methods are not enabled or when the application is running in production mode. When dataflow debuggers are not enabled or when in production mode the debug directives are not inserted in the data messages and the operator code will neither execute nor contain the code that combines and forwards the directives.

An embodiment of the invention may comprise modules e.g. software modules for example an encoding module an API module a compiler module a dataflow module and a dataflow debugger module. The embodiment of the invention further comprises methods used by flow based operators for forwarding and merging directives.

The encoding module is operative to encode debug and tracing directives for data messages. By way of example only the encoding provides a sequence of bits that are part of a message carrying the application data.

The API module is operative to initialize debug and tracing directives in messages and to implement merge and reconciliation rules that map multiple input debug directives coming from several incoming data messages to a single output directive encoded in the output data message that is produced as a result of carrying out an operation on the multiple incoming data messages. The API module is also operative to implement fanout rules that replicate the debug and trace directives in the output data messages that are produced by carrying out an operation on an incoming data message.

One or more APIs of the API module may be used by the dataflow operators. The compiler module may generate code to merge fanout and forward debug directives between an operator inputs and operator outputs and may generate the dataflow debugging operator code. The generated code may comprise for example logic specific to the algorithm implemented by the operator to handle merging and forwarding the debug directives. The merge and fanout functions are realized by invoking the APIs described above.

A dataflow debugger module operative to perform actions specified by debug directives contained in the data messages and can encode intercept and interpret debug directives contained in data messages. The debugger may intercept data messages as they are received on an input port of an operator and or sent by an output port of the operator. A developer may use an interactive interface to define new debug directives which are inserted and forwarded in the data message.

Using the above modules methods of the invention may be defined for incrementally controlling the execution for the application dataflow for a particular message to the next port or operator in the data path. Using the above modules a trace directive may be implemented to enable the dataflow debuggers to cache and optionally log the contents of the data message without suspending execution of the application. A reset directive is provided so that developers can cancel trace and step directives that are in progress.

As disclosed embodiment of the invention may derive a data path through in the data flow application. Methods of deriving the data path may comprise for example operators having code that inserts trace directives in messages input to an operator input tuples and transfer those directives to the corresponding messages output from the same operator output tuples . Alternately or additionally methods of deriving the data path may comprise inferring a data path between input and output ports of an operator by evaluating properties of data flow that are external to the implementation of the operator. The latter method may be used for example to track data flow across operators in cases where the tracking logic was not introduced into the operator.

Merging and forwarding debug directives may further comprise forwarding passing or transferring one or more debug directives from one or more input ports to one or more output ports of an operator by inferring an association or relationship between the one or more input ports and the one or more output ports according to inference rules associated with evaluating externally observable behavior of the operator. Inference rules may include for example temporal relationships data relationships or a combination of temporal and data relationships.

Temporal relationships may be used between messages received and subsequently sent by an operator to infer a data flow path between one or more input ports and one or more output ports of the operator. The relationships may be expressed as a set of rules and constraints. The rules may be used to identify possible causal relationships between input and messages and the constraints may define boundary conditions used by the rules. An example of such a rule is an output message is causally related to an input message if the output message is produced between X and Y seconds after receiving an input message. The values of X and Y constitute the constraints used to parameterize the rule.

Methods involving temporal relationships may be associated with for example graphical user interfaces that enable the user to i select an operator in the flow based application ii for that operator select among a set of generally useful temporal rules iii parameterize the constraints for those rules and iv use various reports and view the results of applying those rules to data.

Data relationships may be used to compare a data model and data values of messages received and subsequently sent by an operator to infer a data flow path between one or more input ports and one or more output ports of the operator. The comparison may comprise a set predicates that evaluate the data models and values. For example a predicate that compares the value of id attributes contained in the input and output messages may be used to infer a data flow path between an input port and an output port.

Methods involving data relationships may be associated with for example graphical user interfaces that display data models associated with the input and output ports of an operator and enables a user to specify predicates that compare the data model and data values contained in input and output messages.

The application flow corresponding to the STNO directive is shown in . In the application flow proceeds from an output port of a first operator to an input port of a second operator . In this case the STNO directive is performed after intercepting or following a message on the output port of the first operator . In the application flow proceeds from an input port of a first operator to an input port of a second operator . In this case the STNO directive is performed after intercepting or following a message on the input port of the first operator . In a breakpoint on the input port of the second operator is activated when the input port of the second operator receives the message.

The application flow corresponding to the STNP directive is shown in . In the application flow proceeds from an input port to an output port of the same operator . In this case the STNP directive is performed after intercepting or following a message on the input port of the operator . In a breakpoint on the output port of the operator is activated when the output port of the operator receives the message. In the application flow proceeds from an output port of a first operator to an input port of a second operator . In this case the STNP directive is performed after intercepting or following a message on the output port of the first operator . In a breakpoint on the input port of the second operator is activated when the input port of the second operator receives the message.

A compiler option the distributed debug trace option activates when enabled and suppresses when disabled the generation of code that merges fans out and forwards debug directives. The compiler has another option the debug trace activate option. The debug trace active option when activated enables tracking of data message according to embodiments of the invention e.g. activates the flow based debugger . Otherwise if compiled with the distributed debug trace option the debugger directives would transit the operator but not activate the debugger.

A directive may comprise a plurality of fields for example fields indicating debug probe point types e.g. breakpoint and tracepoint fields fields indicating debug action e.g. activate or reset fields fields indicating step directive e.g. next port and next operator fields and fields indicating trace control e.g. input port output port all ports maximum hops current hops and identification id .

Table 1 gives an exemplary description of encoding directives for a flow based debugger according to an embodiment of the invention.

Embodiments of the invention are applicable to for example stock market analytics operating at market transaction rates monitoring manufacturing systems e.g. early identification of anomalies that may imply defects stream processing complex event processing and high performance computing message passing interface HPC MPI based applications.

Buy and sell orders are accepted at by source operators and respectively. Source operator is coupled to split operator and source operator is coupled to split operator . Split operators and segregate the bids accepted by their respective source operators and according to stock symbols e.g. ABC Company has stock symbol ABC . Each split operator and is further coupled to both join operators and . Join operators and each create transactions by joining or matching sell orders i.e. bids to sell stock provided by one or both of the split operators and with buy orders i.e. bids to buy stock provided by one or both of the split operators and . When the stock symbol share price and number of shares match the buy and sell orders are joined by join operator or to create a transaction. Join operator is coupled to sink operator and join operator is coupled to sink operator . Sink operators and perform the transaction created by the respectively coupled join operator or and close the sale of brokerage service for the respective transaction.

Communications between operators is according to the couplings shown and or herein described and is in the form of data messages sent from an output port to an input port.

Certain breakpoints e.g. conditional and or non conditional breakpoints are defined or set at points in the application at sometime during the debugging. These breakpoints are and . The breakpoints are located at input and or output ports of operators indicated by solid black squares located at the port of the breakpoint. For example a breakpoint is at the output port of source operator

Step comprises setting and or activating breakpoints and tracepoints at input and or output ports of one or more operators in the application. The breakpoints and tracepoints may be conditional and or non conditional. The breakpoints and tracepoints may be set and or activated by debug directives.

Step comprises stepping the application to the next operator in order to follow a data path e.g. follow a message from one operator to another operator . Stepping the application may comprise running a relatively small portion of the application in order to proceed form one operator to a subsequent operator e.g. from the output port of one operator to an input port of a subsequent operator . Stepping to the next operator may transfer a message or from one operator to another e.g. from the output port of one operator to the input port of another port . Step may be performed by or according to a STNO debug directive.

Step comprises stepping the application to next port. Stepping to the next port may comprise running a relatively small portion of the application in order to proceed from an input port of an operator to an output port of the same operator. Stepping to the next port may perform the operation of the corresponding operator.

Step comprises continuing to run the application. Step may be performed by or according to a STNP debug directive.

First define a breakpoint at the output port of the source operator that injects stock sell orders into the application . Run the application and inspect data messages until an interesting sell offer is encountered on the output port of source operator . The application may be run for example in a stepwise or piecemeal manner so that the user may examine each message as it appears at breakpoint . The user finds a data message of interest that comprises two sell orders one form Pat to sell 20 shares of ABC Company at 102 or more and the other from Lenny to sell 30 shares of ABC Company at 98 or more. When the user finds the data message regarding the sell orders the dataflow along the data path comprising both source operator and split operator has stopped for the user to examine the data message.

Next define a breakpoint on the input port of the split operator which segregates buy orders by stock symbol. Run application and inspect bids until a bid for ABC is received at the input split operator . The user finds data message a buy order from Kelly to buy 50 shares of ABC at 50 or less.

Step step to the next operator is performed by a STNO debug directive in the sell order data message . The data flow comprising message has now progressed to the input port of split operator . Breakpoint is set step according to the STNO directive.

Step step to the next port is performed by a STNP debug directive in the data message . The data flow comprising message has now progressed to the output port of split operator where message comprises the sell orders. Breakpoint is set and activated step according to the STNP directive.

Step step to the next port is performed by a STNP debug directive in the data message . The data flow comprising message has now progressed to the output port of split operator where message comprises the buy order. Breakpoint is activated step according to the STNP directive.

Step step to the next operator is performed by a STNO debug directive in the data message . The data flow comprising message has now progressed to a left input port of join operator . Breakpoint is activated step according to the STNO directive.

Step step to the next operator is performed by a STNO debug directive in the data message . The data flow comprising message has now progressed to a right input port of join operator . Breakpoint is activated step according to the STNO directive.

Step step to the next port is performed by a STNP debug directive in one or both data message and . The data flow comprising message and the data flow comprising message are merged by the join operator to a common data flow and a common data message at the output port of the join operator . The data flows are merged thus causing the debug directives to be merged resulting in a merged directive for breakpoint which is activated step only if and when a join condition specified by the join operator is satisfied.

Step is performed. The application is run so that the sink operator performs the transaction and closes the sale of brokerage service for this transaction.

Note that when an application stops according to one or more breakpoints the user may examine one or more messages at the one or more breakpoints. The messages appearing at breakpoints may be logged in memory for example a debugger message cache see .

As previously described a breakpoint suspends the application when the condition of the breakpoint is met by the debug directive in the data message. Suspending the application may comprise suspending one or more operators for example the operator associated with the breakpoint may be suspended. Other operators may or may not be suspended. At tracepoints data messages are intercepted and stored in a cache. Tracepoints may be for example activated at the same port as breakpoints. Both breakpoints and tracepoints are considered probe points.

A trace directive is encoded in debug directives embodied in the current breakpoint trace message. A debugger message cache comprises messages observed at tracepoints respectively in the portion of a flow based application shown. The application comprises operator have an output port tracepoint operator having an input port tracepoint and an output port tracepoint operator having an input port tracepoint and an output port tracepoints and operator having an input port tracepoint . The flow path of the portion of the application comprises a first portion originating at the output port of operator tracepoints and terminating at the input port of operator tracepoints a second portion originating at the output port of operator tracepoints and terminating at the input port of operator tracepoints and a third portion originating at the output port of operator tracepoints and terminating at the input port of operator tracepoints .

In the message path is traced and observed at every input port and every output port along the message path within the portion of the application . In another embodiment of the invention the message path is selectively traced by constraining the trace by selecting only certain ports along the path to intercept or observe messages. The certain ports may be selected by for example i selecting some or all of the input ports along the message path ii selecting some or all of the output ports along the message path or iii selecting ports along the path according to the distance between the selected ports along the path e.g. the number of nodes or the number of operators along the path . By way of example referring to messages may be monitored only at input ports and . In this example the debugger message cache would comprise only messages and . By way of another example the path may be monitored at only at the input ports as in the previous example and also monitored at tracepoint as a predetermined starting point for the trace. In this example the debugger message cache would comprise only messages and .

Step comprises incrementally advancing the dataflow in a dataflow path of the one or more dataflow paths of the distributed computing application. Advancing the dataflow is according to directives encoded in the data messages. The directives may include for example a STNO directive operative to incrementally advance the dataflow to a next operator in the dataflow path a STNP directive operative to incrementally advance the dataflow to a next port in the dataflow path and a reset directive operative to cancel a directive that is in the process of being merged by a merge operator. The dataflow path comprises operators for example merge operators e.g. join operators and aggregate operators and or forwarding operators. The merge operator is operative to merge two or more data messages and merge the two or more directives. The forwarding operator is operative to forward data messages and forward directives according to rules for forwarding. Step may be implemented for example as instruction code performed on a processor device.

Step comprises performing the directives. The directives may for example enable dataflow based debugging according to the incremental advancing of the dataflow and tracing of the data paths. The directives may be encoded merged and or forwarded for example by the operators. Performing the directives may comprise for example intercepting interpreting and carrying out the directives by a dataflow debugger. Step may be implemented for example as instruction code performed on a processor device.

Step comprises forming an output data message from two or more input data messages. The output data message is formed by an operator e.g. a merge operator and may be formed according to for example one or more directives contained in the two or more input data messages.

Step comprises foaming an output directive from two or more input directives. The output data directive is formed by an operator e.g. a merge operator and may be formed according to one or more directives contained in the two or more input data messages. Specifies rules for merging forwarding and reconciling debug directives to yield a composite output directive may be received from at least one of the input data messages. There may also be rules for a fan out in which the debug directive and data could be replicated in each of a plurality of output data messages.

Operations that combine data messages e.g. join and aggregate operations may exploit these rules to map multiple input directives to a single output directive. The rules for merging and forwarding the directives comprise merge rules by which operators which take as input two or more input data messages each of which may contain a debug directive and which generate a single directive embodied in the output data message. The rules for merging and forwarding the directives may further comprise a rule by which a reset debug directive cancels a debug directive that is in process of being merged by operators that join and aggregate data messages. At least because the rules for merging and forwarding the directives are used to form directives contained in an output message formed in step the output message may considered to be formed according to the rules.

Step comprises encoding the output directive formed in step in the output data message formed in step . Steps and may be performed by for example a join operator which implements a merge operation. A merge operation may be considered as comprising steps and . A merge operation may be for example a join operator or an aggregate operator. The join operator is operative to join multiple data messages and merge reconcile multiple directives. The multiple data messages comprise the multiple directives and are input to the join operators. The aggregate operator is operative to aggregate multiple data messages and merge reconcile multiple directives. The multiple data messages comprise the three or more directives and are input to the aggregate operator.

Step comprises reporting termination of the dataflow when performing a directive and when a data message is discarded by an operator performing the directive.

Step comprises encoding and or inserting a directive into a data message and or deleting a directive from a data message.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

Referring again to B A B A B C D and the diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in a flowchart or a block diagram may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagram and or flowchart illustration and combinations of blocks in the block diagram and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

Accordingly techniques of the invention for example as depicted in B A B A B C D and can also include as described herein providing a system wherein the system includes distinct modules e.g. modules comprising software hardware or software and hardware . By way of example only the modules may include but are not limited to i an incrementally advancing module operative to incrementally advancing the dataflow in a dataflow path according to directives encoded in data messages ii a directive performing module operative to perform the directives iii an output data message forming module operative to form an output data messages from two or more input messages iv an output directive forming module operative to form an output directive from two or more input directives and v an encoded module operative to encode the output directive in the output data message. These and other modules may be configured for example to perform the steps of described and illustrated in the context of B A B A B C D and .

One or more embodiments can make use of software running on a general purpose computer or workstation. With reference to such an implementation employs for example a processor a memory and an input output interface formed for example by a display and a keyboard . The term processor as used herein is intended to include any processing device such as for example one that includes a CPU central processing unit and or other forms of processing circuitry. Further the term processor may refer to more than one individual processor. The term memory is intended to include memory associated with a processor or CPU such as for example RAM random access memory ROM read only memory a fixed memory device for example hard drive a removable memory device for example diskette a flash memory and the like. In addition the phrase input output interface as used herein is intended to include for example one or more mechanisms for inputting data to the processing unit for example keyboard or mouse and one or more mechanisms for providing results associated with the processing unit for example display or printer . The processor memory and input output interface such as display and keyboard can be interconnected for example via bus as part of a data processing unit . Suitable interconnections for example via bus can also be provided to a network interface such as a network card which can be provided to interface with a computer network and to a media interface such as a diskette or CD ROM drive which can be provided to interface with media .

A data processing system suitable for storing and or executing program code can include at least one processor coupled directly or indirectly to memory elements through a system bus . The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboard display pointing device and the like can be coupled to the system either directly such as via bus or through intervening I O controllers omitted for clarity .

Network adapters such as network interface may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

As used herein including the claims a server includes a physical data processing system for example system as shown in running a server program. It will be understood that such a physical server may or may not include a display and keyboard.

It is understood that even though specific embodiments and examples presented herein relate to for example the dynamic pricing of a single resource embodiments of the invention are not so limited. Techniques and embodiments of the invention may for example address dynamic pricing for a plurality of resources.

It will be appreciated and should be understood that the exemplary embodiments of the invention described above can be implemented in a number of different fashions. Given the teachings of the invention provided herein one of ordinary skill in the related art will be able to contemplate other implementations of the invention. Indeed although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings it is to be understood that the invention is not limited to those precise embodiments and that various other changes and modifications may be made by one skilled in the art without departing from the scope or spirit of the invention.

