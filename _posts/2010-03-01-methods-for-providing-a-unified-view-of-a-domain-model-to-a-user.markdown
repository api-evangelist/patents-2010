---

title: Methods for providing a unified view of a domain model to a user
abstract: Techniques for providing a unified view of a domain model to a user are described herein. In one embodiment, in response to a first search query received from a client via a first search mechanism (e.g., outside of the relational DB) for a list of persistent objects representing data entries of a relational database, it is determined whether the persistent objects have been accessed via a second search query via a second search mechanism based on an object identifier of the persistent object. If the requested persistent object has been accessed via a second search query, an identical instance of the persistent object is returned to the client as a result of the first search query. Other methods and apparatuses are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07978544&OS=07978544&RS=07978544
owner: Red Hat, Inc.
number: 07978544
owner_city: Raleigh
owner_country: US
publication_date: 20100301
---
This application is a continuation of U.S. patent application Ser. No. 11 809 282 now U.S. Pat. No. 7 689 535 filed May 30 2007 which is incorporated herein by reference.

Embodiments of the invention relate to information retrieval systems and more specifically to methods to provide a unified view of a domain model to a user of information retrieval systems.

Full text searching of data is becoming increasingly popular and significant in the computing world. For many years the information retrieval community has had to deal with the storage of documents and with the retrieval of documents based on one or more keywords. Since the burgeoning of the Internet and the feasibility of storing documents on line retrieval of documents based on keywords has become a complex problem. Conventional solutions to this problem typically involve the creation of an inverted index for searching documents. When contents of documents are updated the corresponding index will be updated as well. However there has been a lack of efficient ways to update the index without compromising the performance of the search engines.

In addition when a search engine performs a full text search and a non full text search such as a direct query search in an object oriented computing environment the objects returned from a conventional search engine would be different even though the objects are related to the same physical data entry in a database. As a result an application that initiates the searches may have different views of the same data entry.

In the following description numerous details are set forth to provide a more thorough explanation embodiments of the present invention. It will be apparent however to one skilled in the art that embodiments of the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring embodiments of the present invention.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment.

According to one embodiment API maintains a master search node and various slave search nodes to perform various queries on various databases. Each slave search node maintains a local copy of an index. Note that while commonly store in a directory the actual index data can be store in a different form in memory or a single file the actual implementation supporting directory and single file. An index is about a dataset contained in a database and the index is not per se related to the database. An index may be independent of the database vendor. In one embodiment the master search node maintains a master copy of the index directory. Each slave search node performs a respective search using index information obtained from its local index copy and asynchronously updates the index information on the master copy via the master search node. In addition each slave search node may periodically update its local index copy by replicating the index from the master copy maintained by the master search node. The operations of searches performed by a slave search node index update in the master copy and local index updates from the master copy may be performed asynchronously for example in separate threads although under certain circumstances the search operations may not be performed asynchronously however the index update operations are performed asynchronously.

In addition according to another embodiment of the invention API may keep track which of the persistent objects are being accessed by an application. Since API provides several ways to query a database including a standard SQL query and a full text query according to one embodiment API returns the same instance of a persistent object to various search queries if the same data entry e.g. physical data entry in the database is being accessed. As a result API provides a unified view also referred to as a unified Object Oriented view of a persistent data storage.

Framework includes a variety of components. For example session factory is configured to provide a thread safe immutable cache of compiled mappings for a single database. Session factory is a factory for session and a client of connection provider and it may hold an optional e.g. second level cache of data that is reusable between transactions at a process or cluster level. Session is a single threaded short lived object representing a conversation between the application and the persistent store . Session wraps one or several JDBC connection s and is optionally a factory for transaction . Session holds a mandatory first level cache of persistent objects which are used when navigating an object graph or looking up objects based on an identifier.

Persistent objects are short lived single threaded objects containing persistent state and business function. Persistent objects may be ordinary JavaBeans POJOs plain old Java objects . Persistent objects may be associated with a session e.g. session . As soon as the associated session is closed the persistent objects will be detached and free to use in any application layer e.g. directly as data transfer objects to and from presentation . Transaction is a single threaded short lived object used by the application to specify atomic units of work. Transaction abstract applications from underlying JDBC Java database connectivity JTA Java transaction API and or CORBA common object request broker architecture transactions. A session may span several transactions in some situations.

The JDBC API is the industry standard for database independent connectivity between the Java programming language and a wide range of databases SQL databases and other tabular data sources such as spreadsheets or flat files. The JDBC API provides a call level API for SQL based database access. The JTA specifies standard Java interfaces between a transaction manager and the parties involved in a distributed transaction system such as the resource manager the application server and the transactional applications. The CORBA is a standard defined by the Object Management Group OMG that enables software components written in multiple computer languages and running on multiple computers to interoperate. CORBA wraps program code into a bundle containing information about the capabilities of the code inside and how to call it. The resulting wrapped objects can then be called from other programs or CORBA objects across a network. CORBA uses an interface definition language IDL to specify the interfaces that objects will present to the world. CORBA then specifies a mapping from IDL to a specific implementation language like C or Java.

Referring back to connection provider is a factory for and pool of JDBC connections. Connection provider Session and Transaction abstracts application from underlying data sources or driver managers e.g. JNDI or Java naming and directory interface JDBC and JTA . Transaction factory is a factory for transaction instances. Framework supports a variety of databases including for example Oracle DB2 Sybase MS SQL server MySQL etc.

Further framework brings the power of full text search engines to the persistent domain model through transparent configuration and a common API. Full text search engines such as Apache Lucene allow applications to execute free text search queries. However it becomes increasingly more difficult to index a more complex object domain model keeping the index up to date dealing with the mismatch between the index structure and domain model querying mismatches etc. According to certain embodiments of the invention framework oversees the object index transactions. Framework manages the index keeps changes synchronized with the database and optimizes the index access transparently. The common API allows an application to query and retrieve managed objects as any regular SQL query would do. In one embodiment an ORM usually hides a user from SQL by providing an Object Oriented query API or a Object Query Language e.g. HQL JPA QL OQL etc . Note that some or all of the components as shown in may be implemented in hardware software or a combination of both hardware and software.

In one embodiment each of slave search nodes includes a search engine e.g. search engines and a local copy of index directory e.g. index directories associated with the database . In addition a master search node is used to maintain a master copy of index directory and master search node is responsible for updating the master index in response to any updates to database for example made through Common API by any of the slave nodes . The copies of index and the master index enable the slave search nodes to perform any full text searches initiated from applications.

A search engine is an information retrieval system designed to help find information stored in a database. A search engine uses regularly updated indexes to operate quickly and efficiently. In text retrieval full text search also referred to as free search text refers to a technique for searching any content or databases in a full text search the search engine examines all of the words in every stored document as it tries to match search words supplied by the client. The most common approach to full text search is to generate a complete index or concordance for all of the searchable documents. For each word an entry is made which lists the position of every occurrence of the word within the database of documents.

Referring back to for the purposes of illustration slave search node invokes a search engine or an instance of a search engine to perform a full text search using a local index copy . Specifically when the slave search node receives a full text query the slave search node invokes search engine to perform the search. In response to the query search engine sends a search request via path e.g. a thread to local index based on one or more keywords of the search query. In return search engine receives a list of documents that match at least one queried keyword where the list of documents may be ranked or sorted according to a variety of algorithms. The list may be paginated at the initial client request and the paginated subset is converted into a list of domain objects. This conversion potentially triggers one or several requests to the database the DB access may be optimized using various algorithms. Further search engine sends a request via path to database to retrieve the selected documents more than one usually from database . Thereafter the documents are converted to their object representation.

When an entity is inserted updated or removed to from the database through the common API in one embodiment slave search node schedules an index update event via a message provider such as for example in this example a Java message service JMS provider. In one embodiment it is not an event per entity change the common API may transparently queue several entity changes e.g. per Transaction basis . When the queue is ready e.g. transaction commit or some other event the event containing all the queued changes is sent through JMS. This is important for various reasons such as transaction coherence between the DB and the index index process optimization. Note that throughout this application JMS is used as an example of a message service however other message services may also be utilized. In one particular embodiment when a data entry has been updated e.g. inserted modified or deleted in database search engine as a JMS producer generates an index update event and sends e.g. publish the index update event as well as the index update information via path to a JMS provider not shown which stores the index update event in JMS queue . Note that the update event may be scheduled on a per transaction basis where an update event may be used to update multiple changes of multiple entities.

Meanwhile search engine e.g. an indexing engine of master search node as a JMS subscriber registers with the JMS provider to listen to the index update event. Eventually the JMS provider notifies search engine of master search node regarding the index update event. In response search engine retrieves via path the index update event from JMS queue and updates via path the master copy of index .

According to one embodiment periodically slave search node may update its local index by copying the master index via path . The index replication process may be carried in a variety of ways. For example each of the slave search nodes may periodically poll the master search node to replicate the master copy of index into its local copy. Alternatively the master search node may broadcast the index changes to the slave search nodes . Further similar to the index update process the index replication process may be performed via JMS. For example when there are any updates on the master index the master search node as a JMS producer publishes an index replication event in the JMS queue or a separate message queue . Meanwhile each of the slave search nodes may register as a JMS subscriber to listen to the index replication event. In this way no index replication is needed unless there is an update in the master copy . Note that according to one embodiment only the changes or updates of the master index from a previous replication process may be replicated to the local indexes of the slave nodes.

Note that operations involved in paths may be performed via independent threads which are processed concurrently and asynchronously. As a result each of the slave search nodes can focus on the actual searching of the queries and delegate the index update operations to the master search node . This may greatly improve the performance of each component involved in as well as scalability of the overhaul architecture. Other configurations may exist. Also note that system as described in has been described for the purposes of full text searches however the system may also support ordinary SQL searches via path without having to invoke index databases e.g. local indexes and master index .

In an object oriented programming environment object relational mapping ORM is a common requirement of many software development projects. The activities involved in persisting data are tedious and error prone. As described above with respect to the application framework allows an application to store any kind of objects therefore the application does not need to know that its data will be persisted during the operations of the framework. An object that has been persisted in a database is referred to as a persistent object. A persistent object is typically identified by its type and a unique object identifier which may be automatically generated by a machine e.g. UUID or universally unique identifier .

As described above in connection with a persistent set of object may be queried by a direct SQL query or any of its Object Oriented abstraction e.g. path . In one embodiment the system has the ability to retrieve a particular persistent object if the application knows the object identifier of the persistent object. Alternatively according other embodiments a set of persistent objects can be queried via an index search on one or more keywords e.g. criteria search which returns a list of objects that contain at least one of the keywords e.g. path paginated or not a list of associated persistent objects are returned to the client. However a conventional query system returns different instances of the same persistent object if the client retrieves the same persistent object using different mechanisms e.g. a direct SQL or any of its object oriented abstraction or index search . As a result a client receives two instances e.g. handles of objects even if they were referred to the same persistent object or the same data entry in the database.

Alternatively as described above API can also handle a direct SQL query or any of its object oriented abstraction from client . Referring back to during a direct SQL query or any of its object oriented abstraction client sends via operation a SQL query which is database independent to API . In response API converts the database independent SQL into a database specific e.g. associated with database SQL and sends the converted request via operation to database . In return API receives the data entry via operation from database . API converts e.g. mapping the data entry into a list of objects e.g. a persistent object and sends via operation the list back to the client .

In a conventional non integrated query system the instances of objects returned via operations e.g. full text search and via operations e.g. direct SQL queries would be different even though both instances point to the same persistent object or same data entry in the database . However based merely on the instances of objects returned a user would not be able to tell whether these objects are linked to the same data entry in the database .

According to one embodiment the application framework as described with respect to and maintains information regarding what persistent objects being accessed by an application in a given context e.g. a transaction . For example if an application retrieves a persistent object via a direct SQL query and subsequently the same application retrieves the same persistent object via a full text search query the same instance of the persistent object will be returned to the client such that the client has a unified view of the same persistent object or data entry of the database.

Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments of the present invention also relate to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs erasable programmable ROMs EPROMs electrically erasable programmable ROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method operations. The required structure for a variety of these systems will appear from the description below. In addition embodiments of the present invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of embodiments of the invention as described herein.

A machine readable medium may include any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable medium includes read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices electrical optical acoustical or other form of propagated signals e.g. carrier waves infrared signals digital signals etc. etc.

In the foregoing specification embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of embodiments of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

