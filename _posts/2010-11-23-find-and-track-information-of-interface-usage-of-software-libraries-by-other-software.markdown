---

title: Find and track information of interface usage of software libraries by other software
abstract: A library controller that ranks shared libraries that are available from an operating system is described. In one embodiment, the library controller receives multiple different software, where each of the different software use one or more of the shared libraries. The library controller extracts library usage details for each of the multiple different software and provisioning details from each of the shared libraries. Furthermore, the library controller ranks the shared libraries based on the library usage and provisioning details.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08887122&OS=08887122&RS=08887122
owner: Red Hat, Inc.
number: 08887122
owner_city: Raleigh
owner_country: US
publication_date: 20101123
---
This application is related to co pending U.S. patent application Ser. No. 12 953 285 filed on Nov. 23 2010 and entitled PROCESS OF FINDING OUT IF SOFTWARE WILL RUN ON AN OPERATING SYSTEM WITHOUT INSTALLING THAT SOFTWARE. 

Embodiments of the present invention relate to a method and system for comparing software compatibility on an operating system. Specifically embodiments of the invention relate to find and track software library usage of shared libraries of that operating system.

Software that runs on a computing device can use libraries provided by the operating system of that computing device that are shared among software that is executed on that operating system. For example these shared libraries can be used to access operating system functions e.g. reading files writing files file management network communications inter process communications memory management string manipulations user interface manipulations mathematics functions accessing other resources doing graphical representation on a visual device etc. . In addition these shared libraries can change when the operating system changes or is updated. For example upgrading to a newer version of an operating system can change the functions present in the shared library change versions and arguments used in these functions and or change functionality of some none or all of the library functions. As a result software developed for one operating system may not work on another operating system. In the example above upgrading to the new operating system may cause the software not to work on the new operating system whether the operating system is a different type of operating system or the new operating system is simply an update to an existing operating system. To determine if software is executable on a new operating system the software is typically re compiled and run on the new operating system.

When a new version of the operating is released there can be a problem of whether a customer s software can run on that new version of operating software. If the shared libraries have been updated they may be incompatible with the customer s software. Alternatively software developer s may not know if shared libraries are important to software that runs on an operating system. Consequently by updating a shared library the developer risks breaking existing software.

The present invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that different references to an or one embodiment in this disclosure are not necessarily to the same embodiment and such references mean at least one.

A library controller that ranks shared libraries that are available from an operating system is described. In one embodiment the library controller receives multiple different software where each of the different software use one or more of the shared libraries. The library controller extracts library usage details for each of the multiple different software and provisioning details from each of the shared libraries. Furthermore the library controller ranks the shared libraries based on the library usage and provisioning details.

In one embodiment an ABI is a low level interface between software e.g. customer software and or known software and the operating system. In one embodiment the ABI can include one or more of details about data type size alignment calling convention symbol version system call numbers binary format of object files etc. In one embodiment an API can define a library of routines to call data structures to manipulate and or object classes to use.

In one embodiment customer software is a program developed by organization other than the company that produces the operating system and is software that uses the shared libraries. For example and in one embodiment the customer software can be special purpose software that is used for the organization e.g. media development software for media companies specialized modeling software etc. . This customer software can use the shared libraries to utilize system functions.

When a new or updated operating system becomes available the customer software may not run properly because the one or more of the functions of the shared libraries have changed. For example and in one embodiment an open socket function was in one version of a library and this function was removed in the next version of that same library. In one embodiment library controller compares the library functions usage of customer software with the shared library to determine if these libraries can still support the customer software . Comparing the library usage is further described in below.

In addition the library controller can compare the library functions provided with a plurality of known software to determine which of the functions and or libraries provided by shared libraries are important. For example and in one embodiment important functions and or libraries can be those that are used by the known software libraries more often than other libraries and or functions. In another embodiment important libraries are determined by of library usage and popularity of each of the known software . Determining library importance is further described in below.

As illustrated in the library controller includes additional components blocks . These additional components blocks are described in further detail below.

As described above each of the customer and known software as illustrated in use the functions and or libraries from shared libraries . is a block diagram of one embodiment of software and that use different libraries A B such as libraries in files libc.so.6 A and lib2.so B. In customer software uses functions from libraries lib1 A and lib2 B. In one embodiment customer software includes at A code for declaring variables A . . . An and setting the variable A to zero. Furthermore at A customer software makes a call to function funct. Function funct is a function has code that is part of customer software and is not available to other software.

In addition customer software uses libc.so.6 A function STRCPY by calling this function at B. For example and in one embodiment libc.so.6 is a shared library that provides many common system functions string manipulations etc. . Furthermore customer software uses lib2 B function lib2 functionJ by calling this function at C. In one embodiment lib2 B can be another operating shared library third party shared library etc.

Furthermore known software uses functions from libraries libc.so.6 A and lib2 B. In one embodiment a function in a shared library is a function as known in the art the function is invoked using the function call and can have variable for passing data to and from the function. Furthermore each function can have a version associated with it in which different versions may or may not work the same way. Thus one version of the function may differ than other versions of the same function. For example and in one embodiment a function may be present in one version of the library and absent in the next library version.

As described above each function is a library has an interface a set of symbols and a version. In addition the software includes a table of symbols needed by the software. is a block diagram of one embodiment of symbol tables in software and the library. In software includes version symbol needed table and dynamic symbol table . In one embodiment this table includes the version of the external symbols needed by the software. In one embodiment a symbol such as a library function name can have an associated version. For example and in one embodiment the version symbol needed table lists the different symbol versions referenced in the software. In another embodiment this table gives the respective source file name for each version name.

For example and in one embodiment and referring to the customer software would have a version symbol needed table with the entries for STRCPY and LIB2 FUNCTJ which are symbols for the corresponding function calls at B C. In this embodiment customer software would use version . for example of STRCPY and 5.1 of LIB2 FUNCTJ. Furthermore the version needed table would include the file names of the libraries that hold STRCPY and LIB2 FUNCTJ. In this embodiment the filenames would be LIBC.SO.6 and LIB2.SO respectively. For example and in one embodiment a compile can can be informed as to which libraries are required and the compile can keeps this information in a table.

Shared library includes dynamic symbol table version symbol table and version definition table . In one embodiment the dynamic symbol table includes the symbols referenced in the library. For example and in one embodiment in an Executable and Linkable Format ELF object library the dynamic symbol table is .dynsym table. In one embodiment the version symbol table indicates that a version number is either defined or needed for each of the dynamic symbols in the dynamic symbol table . For example and in one embodiment the version symbol table is an array of integer values. Each value in this table is used as an index into either version definition table or version symbol needed table . In one embodiment the value zero and one have a special interpretation If the value is zero the symbol is local not available outside the object for which the symbol was defined within. If the value is one the symbol is globally available and defined within an object. In one embodiment an object can be an ELF file or other type of library file that is being used to check for symbols and or other data. In one embodiment the version symbol table is the .gnu.version table as used in an ELF object library.

In one embodiment the version definition table is a table that lists the versions defined in the shared library . For example and in one embodiment the version definition table is the .gnu.version d table of an ELF object library. In one embodiment the software can further include the tables as listed in the shared library and visa versa.

Referring to the example above and in reference with the dynamic symbol table would have entries for STRCPY and or LIB2 FUNCTJ which are symbols for the corresponding functions in the libraries of shared library . In one embodiment STRCPY and LIB2 FUNCTJ are in different shared libraries which are in different files. In this embodiment the shared library is for LIB1.SO.6 the dynamic symbol table would include the symbol STRCPY.

Furthermore in this embodiment the version symbol table and version definition table includes an entry for STRCPY and or LIB2 FUNCT. In this embodiment the entry in the version symbol table would be an index into version definition table . For example in one embodiment the version symbol table includes an entry for STRCPY which is an index into the version definition table. This index points to an entry in the version definition table that has the version of the STRCPY function such as a value 2.3 or 3.0. If the value is 2.3 in this embodiment this version of STRCPY matches up with the required version for the customer software . If the value is 3.0 this version of STRCPY does not match up with the required version for the customer software . Because the version does not match this function in this library may not work with the customer software .

Referring to process begins with processing logic receiving a software installer at bock . In one embodiment the software installer include software executable s objects libraries data configuration information installer scripts etc. and other information that is used to install the software on a computer. In one embodiment the software installer is a software package which software packaged in an archive format to be installed by a package management system or a self sufficient installer. In one embodiment the software installer includes customer software as described in above. In this embodiment the software installer includes the software and other components used to install the software files data configuration information etc. . For example and in one embodiment the software installer can be a RedHat Package Manager RPM file a tar file a zip file an executable etc. or any software installation file known in the art. In another embodiment process receives the software instead of the installer for that software. In this embodiment process additionally uses a list of supporting files for this software where the supporting files list the other components used to install the software files data configuration information etc. .

At block process extracts the software from the received software installer. In one embodiment process extracts the software from the software installer using one of the known ways in the art of extracting software RPM package extraction processing the tar image unzipping the file running the executable etc. . In one embodiment process extracts the software by determining the software installer file format and running the appropriate program. In one embodiment the result of extracting the software is a directory of files that includes the desired software.

Process determines the ABI API usage details of the extracted software at block . In one embodiment process executes software that is used to interrogate the extracted software for the ABI API usage details. In one embodiment process invokes a tool that is used to interrogate the symbol tables that are in the extracted software. For example and in one embodiment process uses a tool to read the dynamic symbol table and version symbol needed table of the customer software as described in above.

In one embodiment the tool used by process is dependent on the operating system the software is intended to run on. For example and in one embodiment if the extracted software is to be run on a Linux type operating system and the extracted software is an ELF executable process can use the tool eu readelf to read the dynamic symbol table and the version needed table of an ELF executable. Process can use others tools known in the art to read the dynamic symbol tables readelf objdump nm etc. In this embodiment process reads the dynamic symbol table of the extracted software using the command eu readelf with the s option. For example and in one embodiment to extract the dynamic symbol table for the file listing program ls process runs the command 

Furthermore in this example process extracts the symbol version needed using the eu readelf command with the v symbol. Using the example for the ls program above to retrieve the symbol versions needed process runs the command 

By using the above tools process extracts the ABI and or API of shared libraries that are being used by the extracted software. This can later compared with the ABI and or API provision details of the shared libraries to determine if there is a problem with the extracted software and the version of libraries used by this software. At block process saves the ABI API library usage details required by the extracted software in the database.

Process determines the ABI API provisioning details of the shared libraries for a given operating system at block . In one embodiment process identifies the different shared libraries used by the extracted software and determines the ABI API provisioning details for each of the identified shared libraries. In one embodiment process determines the shared library ABI API provisioning details by retrieving these details from a database that stores these details.

In another embodiment for some or all of the shared libraries used by the extracted software process calculates the shared library ABI API provisioning details. In this embodiment for each shared library to be calculated process invokes a tool that is used to interrogate the symbol tables that are in the extracted software. For example and in one embodiment process uses a tool to read the dynamic symbol table version symbol needed and version definition table of the shared library as described in above.

In one embodiment the tool used by process at block is dependent on the operating system the software is intended to run on. For example and in one embodiment if the extracted software is to be run on a Linux type operating system and the extracted software is an ELF executable process can use the tool eu readelf to read the dynamic symbol table version definition table and the version needed table of an ELF executable. In this embodiment process reads the dynamic symbol table of the extracted software using the command eu readelf with the s option. For example and in one embodiment to extract the dynamic symbol table for the shared library libc.so.6 process runs the command 

Furthermore in this example process extracts the symbol version needed using the eu readelf command with the V symbol. Using the example for the shared library libc.so.6 above to retrieve the symbol versions needed process runs the command 

In addition in this example process extracts the symbol version definition using the eu readelf command also with the V symbol. Using the example for the shared library libc.so.6 above to retrieve the symbol version definitions process runs the command 

Thus by different invocations of the shared library too e.g. eu readelf process extracts the ABI API provisioning details from the shared library. At block process compares the extracted software ABI API usage details determined at block with the shared librar ies ABI API provisioning details. In one embodiment process compares the library names functions names function arguments and functions versions between the ABI API usage details and ABI API provisioning details. Using the example above to illustrate the comparison process would compare the usage detail from the extracted software e.g. customer software with the provisioning details from the shared library e.g. libc.so.6 A . In this example process would compare the symbols argument types and versions between the usage and provisioning details. In the example illustrated above with Reference to process compares the symbols used by customer software which is STRCPY AN A and libc.so.6 which is the same with the symbols STRCPY AN A. In this example the symbols are the same and this comparison would note that the symbols used and provided are the same. However if the symbols were difference or had different types the comparison would determine a difference between the ABI API library usage and the ABI API library provisioning. In one embodiment argument type information is determined using debug information and kept in a separate table.

In addition process compares the version of the library symbols used and provided. For example and in one embodiment if process determines that the version of the library function provided is 3.0 and that the library function used is 2.3 process would determine a difference the ABI API library usage and the ABI API library provisioning. Alternatively if both the library function provided and used are for a version of 2.3 the comparison of the library function versions are the same. Process saves the results of comparison in a database at block .

At block process logs the comparison results. If software is missing any of the required ABI API usage details process further logs an error. For example and in one embodiment process could send an email log an error in a log file etc. Process presents the results at block . In one embodiment process displays the results on a display that can be read by a user.

In process determines if the extracted software is missing any of the ABI API usage details. This process can be used for customized software to determine if this software can run on a given operating system. Process does this by extracting the APBI API usage details of the software and compares this usage details with the provisioning ABI API details of the shared libraries. The system of comparing usage and provisioned ABI APT can also be used to determine which of the shared libraries are important to a set of known software for a given operating system. is a flowchart of one embodiment of a process for determining which libraries are important to known software. The process may be performed by processing logic that may comprise hardware e.g. circuitry dedicated logic programmable logic microcode etc. software e.g. instructions run on a processing device to perform hardware simulation or a combination thereof. In one embodiment the process is performed by an library controller such as library controller of .

Referring to process begins with processing logic determining all of the ABI API provisioning details for known libraries at block . In one embodiment process retrieves or calculates the ABI API provisioning details for each of the known libraries for the given operating system using process as described above in block above. For example in one embodiment process determines the library symbols provided e.g. library names functions names etc. function argument types symbols versions etc. While in one embodiment the known libraries is a list of libraries provided by the operating system in alternate embodiment the known software is a different list of libraries third party libraries etc. . At block process saves the library ABI API provisioning details in a database.

Process receives the known software at block . At block process determines the known software ABI API software usage details. In one embodiment process determines the ABI API usage details for each of the known software as described in block above. For example in one embodiment process determines the known software symbols needed e.g. library names functions names etc. function argument types symbols versions etc. While in one embodiment the known software is a list of software advertised to run on a given operating system in alternate embodiment the known software is a different list of software software in a repository etc. . Process saves the ABI API usage details in the database at block . At block process saves the comparison results in a database.

Process analyzes the comparison results at block . In one embodiment process analyzes the ABI API usage pattern of the known software. For example in one embodiment process find the symbols libraries the software is using and creates result sets. In one embodiment process ranks the shared library usage to determine which of the shared libraries are more important than other shared libraries. For example in one embodiment process ranks libraries based on which of the known software uses a library more than others. In another example and in another embodiment process ranks libraries based on which libraries are used by popular software.

While in one embodiment the modules of library controller are executed on one device in alternate embodiments these modules could be executed by different devices. For example and in one embodiment usage details module could be executed on a different device than the other modules. In this embodiment a customer computer can compute usage details which are saved by a computer being used by an operating system company s computer.

As described above includes a diagram of one embodiment of an library controller that analyzes shared libraries. Within the library controller is a set of instructions for causing the machine to perform any one or more of the methodologies discussed herein. In alternative embodiments the machine may be connected e.g. networked to other machines in a LAN an intranet an extranet or the Internet. The machine can operate in the capacity of a server or a client machine e.g. a client computer analyzing shared libraries and the server computer acting as one of the database management servers in a client server network environment or as a peer machine in a peer to peer or distributed network environment. The machine may be a personal computer PC a tablet PC a console device or set top box STB a Personal Digital Assistant PDA a cellular telephone a web appliance a server a network router switch or bridge or an machine capable of executing a set of instructions sequential or otherwise that specify actions to be taken by that machine. Further while only a single machine is illustrated the term machine shall also be taken to include any collection of machines e.g. computers that individually or jointly execute a set or multiple sets of instructions to perform any one or more of the methodologies discussed herein.

The exemplary library controller includes an library processing device a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a secondary memory e.g. a data storage device in the form of a drive unit which may include fixed or removable computer readable storage medium which communicate with each other via a bus .

Library processing device represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processing device may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor processor implementing other instruction sets or processors implementing a combination of instruction sets. Library processing device may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. Library processing device is configured to execute the library processor for performing the operations and steps discussed herein. The library controller may further include a network interface device .

The secondary memory may include a machine readable storage medium or more specifically a computer readable storage medium on which is stored one or more sets of instructions e.g. the library controller embodying any one or more of the methodologies or functions described herein. The library controller may also reside completely or at least partially within the main memory and or within the library processing device during execution thereof by the library controller the main memory and the library processing device also constituting machine readable storage media. The library controller may further be transmitted or received over a network via the network interface device .

The computer readable storage medium may also be used to store the library controller persistently. While the computer readable storage medium is shown in an exemplary embodiment to be a single medium the term computer readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term computer readable storage medium shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term computer readable storage medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media.

The library controller modules components and other features described herein for example in relation to can be implemented as discrete hardware components or integrated in the functionality of hardware components such as ASICS FPGAs DSPs or similar devices. In addition the library controller modules can be implemented as firmware or functional circuitry within hardware devices. Further the library controller modules can be implemented in any combination hardware devices and software components.

In the above description numerous details are set forth. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details. In some instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the present invention.

Some portions of the detailed descriptions above are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as receiving retrieving comparing presenting ranking determining saving calculating computing or the like refer to the actions and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories registers or other such information storage transmission or display devices.

The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but not limited to any type of disk including optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards Flash memory devices including universal serial bus USB storage devices e.g. USB key devices or any type of media suitable for storing electronic instructions each of which may be coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

A computer readable storage medium includes any mechanism for storing information in a form readable by a computer. For example a computer readable storage medium includes read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices or other type of machine accessible storage media.

Thus a method and apparatus for analyzing shared libraries been described. It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. The scope of the invention should therefore be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

