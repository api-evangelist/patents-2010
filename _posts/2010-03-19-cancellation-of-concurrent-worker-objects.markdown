---

title: Cancellation of concurrent worker objects
abstract: A method of performing a cancellation of concurrent worker objects includes creating a plurality of concurrent worker objects with a manager object. At least one cancellation object is generated with the manager object. The at least one cancellation object includes a cancel method and a register method that support concurrent calls. A callback function is registered by calling the register method with one of the concurrent worker objects. A cancellation of the concurrent worker objects is requested by calling the cancel method with the manager object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08327383&OS=08327383&RS=08327383
owner: Microsoft Corporation
number: 08327383
owner_city: Redmond
owner_country: US
publication_date: 20100319
---
This application is related to U.S. patent application Ser. No. 12 139 515 filed Jun. 16 2008 entitled Unified and Extensible Asynchronous and Synchronous Cancellation and published as U.S. Patent Application No. 2009 0313624 A1 and the entire teachings of which are incorporated herein by reference.

Software programs have been written to run sequentially since the beginning days of software development. Steadily over time computers have become much more powerful with more processing power and memory to handle advanced operations. This trend has recently shifted away from ever increasing single processor clock rates towards an increase in the number of processors available in a single computer resulting in a corresponding shift away from sequential execution toward parallel execution. Software developers want to take advantage of improvements in computer processing power to enable their software programs to run faster as new hardware is adopted. With parallel hardware software developers arrange for one or more tasks of a particular software program to be executed in parallel also referred to as concurrently so that for example the same logical operation can utilize many processors at one time to thereby deliver better performance as more processors are added to the computers on which such software runs.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

A problem addressed herein is how to implement a unified cancellation system such that it is efficient for use by many concurrent processes on multi processor machines. One embodiment provides a unified cancellation system that provides multiple types of efficiency and provides concurrent access to one or more cancellation management types.

One embodiment provides a method of performing a cancellation of concurrent worker objects. The method includes creating a plurality of concurrent worker objects with a manager object. At least one cancellation object is generated with the manager object. The cancellation object includes a cancel method and a register method that support concurrent calls. A callback function is registered by calling the register method with one of the concurrent worker objects. A cancellation of the concurrent worker objects is requested by calling the cancel method with the manager object.

In the following Detailed Description reference is made to the accompanying drawings which form a part hereof and in which is shown by way of illustration specific embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description therefore is not to be taken in a limiting sense and the scope of the present invention is defined by the appended claims. It is to be understood that features of the various exemplary embodiments described herein may be combined with each other unless specifically noted otherwise.

One embodiment provides a cancellation application but the technologies and techniques described herein also serve other purposes in addition to these. In one embodiment the cancellation application provides an efficient unified cancellation system for multi processor systems. A unified cancellation system according to one embodiment is a system with one or more cancellation management types that can be used by disparate application programming interfaces APIs to implement safe timely and composable cancellation and that includes mechanisms that permit polling and registering and deregistering callbacks. In one implementation one or more of the techniques described herein can be implemented as features within a framework program such as the Microsoft .NET Framework or within any other type of program or service that handles parallel operations in programs.

A problem addressed herein is how to implement a unified cancellation system such that it is efficient for use by many concurrent processes on multi processor machines. In this context according to one embodiment efficiency means that 1 adding and removing cancellation callbacks is fast registering and deregistering callbacks may occur many times even when a request to actually perform cancellation never occurs and registering and deregistering may be provided in low level code for which overheads are carefully managed 2 passing objects used for cancellation are cheap as they may be passed down call stacks and across thread invocations 3 the total memory usage for the cancellation objects and their callback tracking data structures is kept to a minimum. One embodiment provides a cancellation system that addresses each type of efficiency listed above and provides concurrent access to one or more cancellation management types.

The cancellation system according to one embodiment includes an efficient algorithm for registering callbacks an efficient deregister mechanism for deregistering callbacks and a cancellation method that orchestrates the execution of extant registered callback methods. One embodiment includes a callback tracking data structure that is lock free and false sharing resistant and provides safe callback management for situations involving restrictive synchronization context targets. One embodiment separates a single logical CancellationType into two separate types to provide a cleaner and safer API for usage particularly when disparate libraries interact and share cancellation objects. The cancellation system according to one embodiment also provides exception management for situations where one or more callback functions throw an exception. These features are described in further detail below.

Computing device may also have additional features functionality. For example computing device may also include additional storage removable and or non removable including but not limited to magnetic or optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any suitable method or technology for storage of information such as computer readable instructions data structures program modules or other data. Memory removable storage and non removable storage are all examples of computer storage media e.g. computer readable storage media storing computer executable instructions that when executed by at least one processor cause the at least one processor to perform a method . Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that can be used to store the desired information and that can be accessed by computing device . Any such computer storage media may be part of computing device .

Computing device includes one or more communication connections that allow computing device to communicate with other computers applications . Computing device may also include input device s such as keyboard pointing device e.g. mouse pen voice input device touch input device etc. Computing device may also include output device s such as a display speakers printer etc.

In one embodiment computing device includes a cancellation application . Cancellation application is described in further detail below with reference to .

Cancellation application includes program logic which is responsible for carrying out some or all of the techniques described herein. Program logic includes logic for generating cancellation objects logic for cancelling concurrent workers logic for registering and deregistering callback functions logic for implementing a callback tracking data structure logic for executing callback functions in specific synchronization contexts logic for managing exceptions thrown by callback functions and other logic for operating the application.

Turning now to techniques for implementing one or more embodiments of cancellation application are described in further detail. In some implementations the techniques illustrated in are at least partially implemented in the operating logic of computing device .

In one embodiment at the time that worker objects are created manager object also creates a CTS object . In the illustrated embodiment CTS object includes Cancel method GetToken method and IsCancellationRequested method . The manager object then calls the GetToken method of the CTS object which creates a CT object that refers back to e.g. includes a pointer that points to the CTS object . In the illustrated embodiment CT object includes IsCancellationRequested method Register method and Deregister method . The manager object then passes the CT object to each of the worker objects . The worker objects may create additional sub worker objects copy clone the CT object and pass it on to these additional sub worker objects.

CTS object and CT object are cancellation objects that are instantiated from one or more types. The following Pseudo Code Example I gives an example of a CancellationType according to one embodiment 

In the embodiment represented by Pseudo Code Example I a single CancellationType is used to provide cancellation functionality. In another embodiment described below this single CancellationType is divided into two cancellation types. An example usage pattern of the CancellationType given in Pseudo Code Example I will now be described. An initial step is to instantiate a CancellationObject based on the CancellationType. A work function is then commenced such as calling a long running function or initiating asynchronous work and the CancellationObject is passed as a parameter to the work function. In the embodiment shown in worker objects are created and CT object is passed to the worker objects . The work function may register and deregister callback functions e.g. using register method and deregister method poll on the IsCancellationRequested Boolean e.g. by calling method and pass the CancellationObject as a parameter to sub operation functions. The sub operation functions may continue to do this recursively. The same CancellationObject may be passed to concurrent operations that run on separate threads of execution. The concurrent operations may also register and deregister callback functions and pass the CancellationObject to sub operations.

If a call is made to CancellationObject.Cancel e.g. calling cancel method the CancellationObject transitions to the canceled state and all currently registered callbacks are executed in response to the cancellation. In one embodiment any callbacks that are subsequently registered are also executed. The IsCancellationRequested boolean enables operations e.g. worker objects to detect that cancellation has been requested and respond to it by terminating their work and releasing their resources in an efficient manner.

Some callback functions may have to execute in a specific synchronization context due to the programming model of the objects involved in the cancelable operations. In one embodiment the Register method in Pseudo Code Example I accepts a UseCurrentSynchronizationContext parameter in addition to the callbackFunc parameter. If the UseCurrentSynchronizationContext parameter is used and has the value true then the callback is run in the context as was visible to the thread of execution that performed the Register operation. If the callback is executed at a later time and in a different synchronization context then the original context is reestablished which may involve thread transitions and lock acquisitions. These considerations are self contained within each SynchronizationContext but the most restrictive is called the SingleDedicatedSequentialThreadSyncContext. For this particular SynchronizationContext all callbacks that target it run on a single dedicated thread and the callbacks are serialized.

One embodiment provides a unified cancellation system that is intended to be used by disparate APIs that can loosely cooperate to observe and react to a single cancellation request . There are two distinct consumers of a CancellationObject 1 a single initiator or manager and 2 one or more listeners. The initiator corresponds to the manager object and the listeners correspond to the worker objects . The manager object is the creator of the cancellation object and provides it to concurrent operations e.g. worker objects on one or more threads of execution. The manager object is also the single caller of the Cancel method . The listeners e.g. worker objects receive the cancellation object observe the IsCancellationRequested property and add remove callbacks. In one embodiment these listeners do not call the Cancel method themselves nor does a worker object have access to the callbacks registered by other worker objects . In one embodiment the cancellation type given in Pseudo Code Example I is divided into two distinct types to address the issue raised by having two distinct consumers of a cancellation object. In one embodiment the cancellation type given in Pseudo Code Example I is divided into a CancellationTokenSource CTS type and a CancellationToken CT type as shown in the following Pseudo Code Examples II and III 

In one embodiment a CTS object is instantiated from the type given in Pseudo Code Example II and a CT object is instantiated from the type given in Pseudo Code Example III. In one embodiment operations that receive a CT object cannot affect other cancellation token objects nor initiate a cancellation request e.g. call the Cancel method themselves. This separation promotes correct usage patterns and promotes isolation of disparate APIs. In one embodiment the CTS object is the only holder of state and the CT object s are pointers to the CTS object albeit with a different API to that available to a true pointer to the CTS object . In another embodiment each CT object maintains state.

One embodiment provides a lock free algorithm that permits concurrent calls to the Register method Deregister method and Cancel method . Each of these methods will now be described in further detail.

In one embodiment the Register method takes the form Register FunctionRef callback bool useSyncContext . If IsCancellationRequested is true when the Register method is called the callback function to be registered is executed synchronously in one embodiment i.e. immediately and before the Register method returns control to the caller . If IsCancellationRequested is false when the Register method is called the callback function to be registered is added to the callback tracking data structure . If IsCancellationRequested is still false after the callback function to be registered has been added to the callback tracking data structure the Register method returns. If IsCancellationRequested is true after the callback function to be registered has been added to the callback tracking data structure the callback function is deregistered from the callback tracking data structure . If the register method was unable to deregister the callback it waits for the callback to complete e.g. via the WaitForCallbackToComplete method and then returns a dummy RegistrationInfo i.e. a null or an empty RegistrationInfo . In the case that the callback is successfully deregistered from the tracking data structure the callback is executed synchronously i.e. immediately and before the Register method returns control to the caller .

In one embodiment the Deregister method takes the form Deregister RegistrationInfo registration . If the RegistrationInfo represents a dummy registration the Deregister method returns immediately. If the RegistrationInfo does not represent a dummy registration the Deregister method performs the following 1 deregister the callback function from the callback tracking data structure 2 If IsCancellationRequested is true AND the attempt to deregister failed e.g. the callback function was no longer in the callback tracking data structure AND the thread executing callbacks is not the same as the thread executing this Deregister method THEN the Deregister method waits for the callback to complete e.g. via the WaitForCallbackToComplete method 3 otherwise the Deregister method returns immediately.

In one embodiment the Cancel method is implemented as follows. A compare and exchange CMPXCH operation is performed to attempt to change cancellationObject.state to canceled . If the state was successfully changed to canceled e.g. a first thread was the first winner out of concurrent callers to Cancel ExecutingThreadID is set to the ID of the first thread such that the Deregister method can observe it and ExecuteCallbackHandlers is performed by repeating the following seven steps until no callbacks remain 1 Take a copy of a callback from the callback tracking data structure 2 if a SyncContext was saved with the callback transition to that SyncContext and continue there with the next step otherwise continue immediately to the next step 3 if a thread transition occurred update the tracked threadID such that calls to the Deregister method can observe it 4 remove the original callback from the callback tracking data structure 5 if the callback existed and was removed successfully then set ExecutingCallback callback such that the WaitForCallbackToComplete method can observe it and call the callback 6 if a SyncContext was used for the previous steps return to the original thread and continue remaining step 7 if a thread transition occurred reinstate the ExecutingThreadID to its previous value i.e. to the ID of the first thread mentioned above . After all of the callbacks have been executed ExecutingCallback is set to null.

There are situations where the cancellation system described herein waits for callback functions to complete. In one embodiment a WaitForCallbackToComplete method is provided that takes the form WaitForCallbackToComplete CallbackReference callback . This method according to one embodiment makes sure that when it exits the callback is not currently executing. If the callback was not executing the method returns immediately. While the callback is executing e.g. While ExecutingCallback callback the method performs a micro wait such as a regular spin wait .

The calls to the WaitForCallbackToComplete method are used in one embodiment so that the following pattern is safe 1 CallbackRegistration cr Register callback 2 do work 3 Deregister cr and 4 dispose and destroy resources that the callback referenced. The WaitForCallbackToComplete method according to one embodiment makes sure that when the Deregister method returns the callback will not subsequently commence and that it is not currently executing. One caveat is made with respect to step 2 of the Deregister method described above i.e. IF IsCancellationRequested is true AND

the attempt to deregister failed e.g. the callback function was no longer in the callback tracking data structure AND the thread executing callbacks is not the same as the thread executing this Deregister method 

THEN the Deregister method waits for the callback to complete e.g. via the WaitForCallbackToComplete method . In one embodiment if the callback is currently running on the same thread that calls the Deregister method then no wait occurs.

As described above with respect to the Register method if IsCancellationRequested is true after the callback function to be registered has been added to the callback tracking data structure the callback function is deregistered from the callback tracking data structure . This step essentially answers the question has the callback been executed and makes sure that if the callback has not yet executed a concurrent call to Cancel will not subsequently execute it. There are various approaches to address this situation such as using flags that are updated via CMPXCH operations but the existence nonexistence of the callback in the callback tracking data structure is an approach that is used in one embodiment and does not involve the use of additional flags.

As described above with respect to the Deregister method IF IsCancellationRequested is true AND the attempt to deregister failed e.g. the callback function was no longer in the callback tracking data structure AND the thread executing callbacks is not the same as the thread executing this Deregister method THEN the Deregister method waits for the callback to complete . Thus this step of the Deregister method according to one embodiment waits for the callback to finish execution if the callback may be running and is not running on the same thread that has called the Deregister method . This means that if a callback attempts to deregister itself the system will not deadlock. The situation of a callback deregistering itself is most likely bad practice but the deadlock should be avoided nonetheless.

As described above with respect to the Cancel method step 1 involves taking a copy of a callback from the callback tracking data structure and step 4 involves removing the original callback from the callback tracking data structure . In one embodiment these steps make sure that the actual act of removing the callback occurs in the context that it will be executed. If this is not done a concurrent usage of the same SingleDedicatedSequentialThreadSyncContext that calls the Deregister method referring to this same callback may cause a deadlock in step 2 of the Deregister method if a wait occurs.

The callback tracking data structure according to one embodiment will now be described in further detail. The callback tracking data structure according to one embodiment provides fast execution for many concurrent executions of the Register method and the Deregister method . is a diagram illustrating a callback tracking data structure according to one embodiment. Data structure includes a set of sparse arrays A D collectively referred to as sparse arrays . Sparse arrays A and C are empty as indicated by the text null . Sparse array B includes a plurality of sparse array segments A and B. Sparse array D includes a plurality of sparse array segments C D and E. Sparse array segments A E are collectively referred to herein as sparse array segments . Each sparse array segment includes a plurality of slots . Each slot is used to store a reference to a CallbackInfo for a particular callback function. For example two slots of segment D are used to store CallbackInfo A and B collectively referred to as CallbackInfo .

In one embodiment the callback tracking data structure is used in a cancellation method as follows 1 multiple sparse arrays are used to hold callback information 2 a thread calling the Register method selects one of the sparse arrays via arithmetic on its ThreadID or otherwise arranges to partition the available sparse arrays amongst calling threads 3 the sparse arrays are allocated to avoid false sharing e.g. in one embodiment the first thread that is assigned a particular sparse array performs the allocation on the assumption that threads allocate data structures from different heaps or at least different heap segments with the intention being that the sparse arrays will not be allocated in adjacent memory locations and hence will avoid false sharing access patterns 4 each sparse array according to one embodiment is a doubly linked list of array segments and each slot in an array segment holds a single pointer to a CallbackInfo structure each segment may either be the same size or increasing in size as shown in to amortize the overheads per segment so each element of a sparse array can be manipulated via CMPXCH operations to permit thread safe additions and removals 5 when a CallbackInfo is added to the data structure a RegistrationInfo object is returned that indicates the sparse array and the slot number where the item was added hence locating a callback for removal is an O 1 operation where O 1 is a Big notation that indicates that the operation executes in the same time regardless of the input data and 6 when adding an item to a sparse array an empty slot is located.

An approach for adding an item to a sparse array according to one embodiment involves the following A start with the tail of the sparse array segment list B track the number of empty slots in each array segment either precisely or approximately C if the number of empty slots exceeds a given threshold then perform a linear scan to locate an empty slot and D otherwise if there is a previous segment set it as the current segment and continue from step A if there is not a previous segment create a new segment attach it to the tail segment set it as the current segment and continue from step A.

The callback tracking data structure according to one embodiment has the following characteristics 1 Additions are fast and tunable via the threshold parameter e.g. the threshold can permit tight memory usage at the cost of time used to scan for free locations or provide amortized fast additions at the cost of higher memory costs 2 locating previously added items is O 1 3 false sharing and general cache contention is significantly reduced over other schemes and 4 no coarse grained locks are used.

In other embodiments a different structure may be used for callback tracking data structure and variants on the above approach may be used. For example linked lists sets of linked lists and various tree structures may be used in other embodiments. Sets of simple arrays with associated empty cell tracking information or fully featured garbage collector schemes may also be used.

Exception handling components will now be described in further detail. When the Cancel method is called a set of callbacks may be executed. Depending on the usage of the CancellationObject two principal usage patterns exist 1 logically execute all of the callbacks and accumulate all of the exceptions that may arise and 2 logically execute the callbacks one by one and if and when a callback throws an exception immediately throw that exception and discontinue execution of remaining callbacks. One embodiment provides one of these two usage patterns. Another embodiment provides both of these usage patterns. Yet other embodiments provide a variant of these usage patterns.

In one embodiment the signature of the Cancel method is changed to Cancel bool throwOnFirstException and the Cancel method is modified as follows. Subsequent to step 5 of the Cancel method described above i.e. if the callback existed and was removed successfully then set ExecutingCallback callback such that the WaitForCallbackToComplete method can observe it and call the callback if throwOnFirstException is true then control is returned to the original thread any cleanup steps are performed e.g. to reclaim memory for the callback tracking data structure and the exception is re thrown. If throwOnFirstException is false the system continues executing callbacks in sequence and collates the exceptions and when all callbacks have been executed the system returns control to the original thread performs any cleanup steps e.g. to reclaim memory for the callback tracking data structure and throws an AggregateException that contains all of the individual exceptions.

It is noted that the mode where throwOnFirstException is true may provide the most detailed tracking information for the exception that is raised but that the mode where throwOnFirstException is false may be more appropriate for situations where the participants that have registered callbacks are disparate and should not miss out on notifications because of exceptions raised by other participants. In general the mode where throwOnFirstException is false is likely to be most generally useful and is used as a default in one embodiment.

In one embodiment the at least one cancellation object in method includes a cancellation token source object and a cancellation token object and the manager object calls a GetToken method of the cancellation token source object to create the cancellation token object . In one embodiment of method the manager object passes the cancellation token object to each of the concurrent worker objects . The concurrent worker objects in method according to one embodiment monitor the cancellation token object to determine whether cancellation has been requested. In one embodiment of method the cancellation token source object includes the cancel method and the cancellation token object includes the register method and the deregister method which are configured to be called by the concurrent worker objects to register and deregister callback functions. The register method according to one embodiment provides for both immediate execution and delayed execution. The deregister method according to one embodiment provides for both immediate deregistration and waiting for concurrently executing callback functions to complete.

The lock free callback tracking data structure in method according to one embodiment comprises a plurality of sparse arrays wherein each sparse array comprises a doubly linked list of array segments and wherein each array segment includes a plurality of slots for storing callback information . In one embodiment of method the register method is configured to accept a parameter that indicates that the callback function is to be executed in a current synchronization context. The method according to one embodiment further includes accumulating exceptions thrown by callback functions and re throwing the accumulated exceptions after execution of the callback functions. The method according to another embodiment further includes executing callback functions one by one and stopping execution of the callback functions when one of the callback functions throws an exception. In one embodiment of method the cancel method is configured to accept a parameter that indicates whether exceptions thrown by callback functions are to be accumulated and re thrown after execution of the callback functions or whether execution of the callback functions is to be stopped upon the throwing of an exception by one of the callback functions.

Although specific embodiments have been illustrated and described herein it will be appreciated by those of ordinary skill in the art that a variety of alternate and or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore it is intended that this invention be limited only by the claims and the equivalents thereof.

