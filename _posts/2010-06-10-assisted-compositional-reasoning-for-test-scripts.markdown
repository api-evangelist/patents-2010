---

title: Assisted compositional reasoning for test scripts
abstract: Assisted compositional reasoning for test scripts is implemented by a Type Inference of GUI Object References (TIGOR). TIGOR makes types of GUI objects explicit in the source code by using the properties of GUI objects as referred to in test script statements to access a GUI object repository for GUI objects that have matching GUI objects properties. TIGOR analyzes the GUI object types of the matching GUI objects in view of a sequence of operations performed on the GUI objects in the test script statements. TIGOR infers a GUI object type for a GUI object when that GUI object type is determined to be valid and/or compatible with a sequence of operations, such as API calls, executed in test script statements that perform actions on the GUI object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08572570&OS=08572570&RS=08572570
owner: Accenture Global Services Limited
number: 08572570
owner_city: Dublin
owner_country: IE
publication_date: 20100610
---
This disclosure relates to analysis and generation of accurate GUI object type inferences for testing applications that contain these GUI objects. The inferences may be used to create composed test scripts for testing applications composed of multiple applications including graphical user interface applications and in particular relates to transforming multiple individual test scripts that are designed to individually test standalone GUI applications into fewer test scripts or a single composed test script for testing a composed application composed of multiple applications.

The relentless pace of advancing technology has given rise to complex computer software applications to help automate almost every aspect of day to day existence. Today applications exist to assist with writing novels to filing income tax returns to analyzing historical trends in baby names. One nearly ubiquitous feature of these applications is that they employ graphical user interfaces GUIs . Another nearly ubiquitous aspect is that applications that incorporate GUIs Graphical user interface APplications GAPs require thorough testing prior to release.

Integrated systems are composed of components that exchange information. These components include different legacy event based applications such as GAPs. To automate testing engineers create test scripts that are programs that interact with GAPs by performing actions on the GUI objects of the GAPS. When testing integrated systems and composed applications in particular it is important to reason about how to compose test scripts whose operations reference these GUI objects.

Successfully combining existing individual test scripts that are designed to test individual applications in order to test composed applications is difficult. The significant complexity of combining test scripts and the permutations and combinations of GUI elements including data types gives rise to an enormous field of potential commands and command sequences that could have bugs of any severity from insignificant to critical failure. As a result even if test scripts exist for the applications it is rarely the case that the test scripts can be easily combined without significant effort to adequately test the composed application. The complexity is further complicated because unlike conventional languages that require programmers to declare types of variables explicitly test script statements reference GUI objects using the properties e.g. location color and size of the GUI objects. The absence of data type information exacerbates the process of composing test scripts making it expensive and prohibitive to test composed systems. These fundamental problems are inherent for most existing Open Source and commercial automated testing tools.

Several fundamental problems make it difficult to type operations that reference GUI objects in test scripts. First specifications for GUI objects are often not available and these objects are created dynamically in the GAPs processes and the contexts of the underlying GUI frameworks e.g. Windows or Java SWT . Black box testing does not provide the option to obtain information about GUI objects from the source code of GAPs. Therefore test engineers use capture replay tools to extract values of properties of GUI objects so that these objects can be later identified on GUI screens by matching these prerecorded values with the properties of GUI objects that are created at runtime. Because complete specifications of GUI objects are not available it is difficult to analyze statically how GUI objects are accessed and manipulated by test script statements.

Manually testing large scale composed applications with composed test scripts is tedious error prone and laborious. Nontrivial GAPs contain hundreds of GUI screens that in turn contain thousands of GUI objects. In order to automate testing of GAPs test engineers write programs using scripting languages e.g. JavaScript and VBScript and these testing scripts drive GAPs through different states by mimicking users who interact with these GAPs by performing actions on their GUI objects. Often test scripts simulate users of GAPs and their statements access and manipulate GUI objects of these GAPs. For example the statement 

locates a window whose caption is Userid and that is created by a Visual Basic based control then a text box is located whose name is txtAgentsName that is a GUI object whose parent is the Userid window. By calling the method Set with the parameter Shawn the value of the text box is set to Shawn .

Commercial tools such as Quick Test Pro QTP Rational Robot and Compuware Test Partner help generate test scripts by tracking pointing of a cursor at GUI objects and performing desired actions. These tools generate scripting code that can replay captured user actions for an individual application. The generated code serves as a skeleton for creating scripts to automate script testing for individual applications. When test scripts are combined to create a composed test script test engineers add code manually to the composed test script so that the composed test script performs actions on the GUI objects as previously exercised by the individual test scripts.

Using manually written code to combine individual test scripts in order to test composed applications makes the composed test scripts more complex time consuming to create and difficult to accurately implement maintain and evolve. Although it is known in advance that the test scripts access and manipulate GUI elements it is not clear how to detect GUI object data types without significant manual analysis and reasoning until compile time which lead to runtime errors.

Using API calls exported by testing platforms remains a primary mode of accessing and manipulating GUI objects of GAPs. Operation statements in the test scripts include API calls that perform actions on GUI objects referenced in the test scripts incorporated in the applications tested by the scripts. When the operation statements fail to properly manage the GUI object data types of the GUI objects referenced in the test scripts these API calls lead to various run time errors.

Checking test scripts for potential flaws caused by API calls that lead to incorrect tests and runtime errors in the test scripts is a difficult technical challenge. Furthermore there are fundamental problems with using API calls to access and manipulate GUI objects. First the API calls take names and property values of GUI objects as string input parameter variables. The values of these input parameters are often known only at runtime making it impossible to apply sound checking algorithms. Second testing platforms export dozens of different API calls and high complexity of these API calls makes it difficult for programmers to understand which API calls to use and how to combine them to access and manipulate GUI objects. These problems lead to a wide range of bugs in the test scripts many of which are difficult to detect during the inspection of the test script source code.

Assisted compositional reasoning for test scripts is implemented by the Type Inference of GUI Object References TIGOR system and method. TIGOR facilitates making types of GUI objects explicit in the source code allowing test engineers to reason more effectively about the interactions between statements in complex test scripts and GUI objects that these statements reference. In one implementation TIGOR includes logic that automatically infers GUI object types referenced in the operational statements of the test scripts. TIGOR provides a tool for developing and testing applications composed with multiple applications that include GUI objects. TIGOR is practical and efficient and yields appropriate GUI objects types that provide error free control of GUI objects referenced in composed test scripts to test composed applications.

Crafting test scripts from scratch for testing new integrated systems is a significant investment. Test engineers implement sophisticated testing logic. Specifically test engineers write code that processes input data uses this data to set values of GUI objects acts on the objects to cause GAPs to perform computations retrieves the results of these computations from GUI objects and compares these results with predetermined answers to determine if GAPs behave as desired. Since multiple test scripts are already created for testing individual GAPs it is highly desirable that these scripts be reused for testing the corresponding integrated systems. Reusing testing logic repeatedly is the ultimate goal of test automation.

However it is difficult to compose test scripts into mega scripts that test newly integrated systems because many of these scripts are difficult to reason about and the test scripts are often out of date and should be fixed before being composed with other scripts. In addition operations in test scripts should be synchronized so that composed scripts can facilitate GAPs to exchange data when GUI objects are exposed to these exchanges. Specifically test engineers should know what types of GUI objects are referenced by expressions in test scripts in order to determine how to move data between test scripts. Scripting languages do not allow programmers to specify types of variables. Unlike conventional languages that require programmers to declare types of variables explicitly test script statements reference GUI objects using their properties e.g. name location color and size .

Test scripts are highly sensitive to the types of GUI objects that the test scripts reference for example changing the type of a GUI object from a list box to a text box will lead to runtime errors in test scripts. Test script statements that access and manipulate GUI objects as failures if these statements are broken because of mismatches between types of GUI objects that methods are invoked on the references of the GUI objects in test scripts statements. Test engineers put a lot of effort into detecting and understanding failures so that the test engineers can fix test scripts to work on modified versions of GAPs.

TIGOR assists compositional reasoning about test scripts by inferring the data types of GUI objects on which a test script performs actions. TIGOR in one implementation operates in combination with a testing tool such as that manufactured by Hewlett Packard Corp. referred to as the Quick Test Pro QTP tool .

Other systems methods features and advantages will be or will become apparent to one with skill in the art upon examination of the following figures and detailed description. All such additional systems methods features and advantages are included within this description are within the scope of the claimed subject matter and are protected by the following claims.

The Type Inference of GUI Object References TIGOR assists compositional reasoning about test scripts by inferring the data types of GUI objects on which a composed test script performs actions.

The TIGOR system architecture includes a GUI object repository or GUI object repositories that stores validated action results for actions performed by the API calls on GUI object types . For example the statement 

locates action result a window whose caption is Userid and that is created by a Visual Basic based control then a text box GUI object type is located whose name is txtAgentsName and is a GUI object whose parent is the Userid window. By calling the method Set with the parameter Shawn the value of the text box is set to Shawn action result in this example sets a value .

The type inferencer logic determines the GUI object types by obtaining from the GUI object repositories mappings of GUI object types where each of the mappings may comprise properties of a GUI object type . Example properties include location color and size of the GUI objects. The type inferencer logic may assign GUI object types to each GUI object according to the API call types in sequence determined to be compatible with the GUI object types in sequence .

In one implementation the TIGOR system architecture includes one or more external GUI object repositories . The object repositories may be provided by an external service provider or providers and may be accessed through the network . The multiple external GUI object repositories store mappings for the GUI objects in applications that do not compose the composed application . These applications may reference the GUI objects referenced in the test script statements . In one implementation the larger the inventory of mappings for GUI objects available in the GUI object repositories including external GUI object repositories the more accurate the inference result . For example an external service provider may offer access to any number of GUI object repositories both GUI object repositories related and unrelated to the applications used to compose the composed application through a network in order to increase the inventory of mappings for GUI objects used by TIGOR to obtain the type inference results . The GUI object repositories store the mapping of names of GUI objects and the physical properties of the GUI objects that describe how those GUI objects are represented.

The type inferencer logic may find multiple GUI object interaction paths that identify API calls that perform actions on the sequential GUI objects. For example the GUI object interaction paths may include the sequence of GUI objects referenced in a sequence of test script statements and composed test script statements . Recall the statement 

locates a window whose caption is Userid and that is created by a Visual Basic based control then a text box is located whose name is txtAgentsName and is a GUI object whose parent is the Userid window. By calling the method Set with the parameter Shawn the value of the text box is set to Shawn . The sequence of GUI objects referenced in this example may include in one path a window GUI object and a text box GUI object. The text box GUI object is the destination GUI object in this example and set is the action results performed on the GUI object .

The GUI object interaction paths may validate useable GUI object interaction paths from the multiple GUI object interaction paths that control the actions performed on the sequential GUI objects and determines a GUI object interactions count in each of the useable GUI object interaction paths . For example the set action result is valid for a text box GUI object type and the set operation counts as a GUI object interactions count in a useable GUI object interaction path .

In one implementation the type inferencer logic may select from the useable GUI object interaction paths a first path having the least number of GUI object interactions of the useable GUI object interaction paths . In another implementation the type inferencer logic selects from the useable GUI object interaction paths a first path having the greatest number of GUI object interactions of the useable GUI object interaction paths . In still another implementation the type inferencer logic selects from the useable GUI object interaction paths a first path having a number of GUI object interactions between the least and the greatest number of GUI object interactions of the useable GUI object interaction paths . The type inferencer logic determines the type of the exposed method in the useable GUI object interaction paths where the useable GUI object interaction paths each extend from a root node e.g. see GUI object to the destination GUI object e.g. see GUI object that exposes the exposed method .

For example the test script statement may include VbWindow State .Select 3. The API call VbWindow is exported by a GUI testing framework . Executing the API call identifies a list box GUI object whose property name e.g. GUI objects properties has the value State e.g. action results . By calling the method Select with the value 3 the third item in its value list is selected. However if the referenced GUI object is not of the GUI object type list box e.g. a special form of a text box type the API call will result in a runtime exception. The absence of typing information in the source code e.g. in the test script statement exacerbate the process of detecting and understanding failures in test scripts making maintenance and evolution of these scripts expensive and prohibitive thus obliterating benefits of test automation . Test engineers often lack time and necessary skills to understand old scripts especially if these scripts were created by other engineers. To be able to compose and synchronize test scripts it is critical for test engineers to understand what types of GUI objects are referenced in the expressions of these scripts . Existing approaches provide lithe help to address this pervasive and big problem.

TIGOR makes types of GUI objects explicit enabling test engineers to reason more effectively about the interactions between statements in complex test scripts and GUI objects that these statements reference. TIGOR provides a way to synchronize test scripts and create composed test script statements in order to test composed applications .

For example a composed application may include E procurement systems EPS that businesses employ that often include different GAPs assisting different steps of the purchasing process. In EPSes the rule of separation of duty requires that operations be separated into different steps that must be done by independent persons agents in order to maintain integrity. With the separation of duty rule in place no person can cause a problem that will go unnoticed since a person who creates or certifies a transaction may not execute the transaction. Implementing this rule results in agents using different GAPs that provide different services for different steps of the purchasing process.

Employees order items using an electronic shopping cart service of the web based application buystuff BS . Department managers review selected items in the shopping cart approve and order them and enter the ordered items into expense tracker ET a third party closed and monolithicWindows GAP that the company uses internally to keep track of purchases. The BS service sends a notification to a company accountant who uses a closed and monolithic GAP called Invoice tracker IT to create invoices for ordered goods. When the ordered goods are received from BS a receiving agent compares them with the entries in ET. The accountant can view but cannot modify records in ET and likewise no other agent but the accountant can insert and modify data in IT. If the received goods correspond to the records in ET the receiving agent marks the entries for the received goods in ET and notifies the accountant. After comparing the invoices in IT with the marked entries in ET and determining that they match the accountant authorizes payments.

Each procurement agent uses different GAPs to accomplish different goals. Sometimes several GAPs should be used to accomplish a single goal and agents have to transfer data between these GAPs and perform other operations manually. Clearly automating these activities is important in order to improve the quality and the efficiency of business services.

Consolidating disparate components into integrated EPSes facilitates enterprises to achieve a high degree of automation of their purchasing processes. One supporting function of an integrated system composed application is to extract information about ordered items from the service BS and create and enter invoices into IT using this information. Once the payments are processed the user marks invoices in IT as paid and the information about these invoices should be extracted from IT and entered as expenses into ET. There are many other functions of the integrated EPS that involve interoperating GAPs with each other.

An important function of testing an integrated EPS is to use individual test scripts that are designed for components GAPs to perform integrated tasks . These scripts may continue to work with legacy GAPs and operations synchronized in order to facilitate GAPs to exchange data. The test scripts and composed test script statements may be synchronized in order to facilitate GAPs to exchange data. In a way composing test scripts mimic how users interact with integrated systems . Composing test scripts this way requires test engineers to reason about types of GUI objects that these scripts reference.

In another implementation TIGOR includes a test automation model that illustrates interactions between test scripts and GAPs . Statements of test scripts are processed by the scripting language interpreter . In one implementation the scripting language interpreter and or script parser logic is supplied with a testing platform. When the interpreter encounters statements that access and manipulate GUI objects the interpreter passes the control to the testing platform that translates these statements into a series of instructions that are executed by the underlying GUI framework and the operating system.

The layers between test scripts and GAPs may be viewed as a reflective connector. A connector is a channel that transmits and executes operations e.g. API calls between test scripts and GAPs . Reflection exposes the type of a given GUI object and facilitates test scripts to invoke methods of objects whose types and classes are not statically known before the GAP is run. A connector between scripts and GAPs is combined with reflection so that test scripts can access and manipulate GUI objects at run time.

Each statement in test scripts which accesses and manipulates GUI objects may include the following operations 1 navigate to some destination GUI object using GUI object properties and 2 invoke methods to perform actions on the GUI objects including getting and setting values . Using implementations of the concepts of reflection and connector statements in test scripts can navigate GUI objects in GAPs and perform operations on these GUI objects .

In one implementation a TIGOR composer discussed in detail under below models the GAPs and . The trees that model GUIs are input to the type inferencer which infers types of references to GUI objects in test scripts and . The script for the GAP and is parsed using the script parser and the parse tree is generated. The parse tree contains an intermediate tree representation of the test script and where references to GUI objects are represented as nodes. Recall that GUI objects are described using unique names with which property values of these objects are indexed in object repositories . The names for the GUI objects are resolved into the values of properties of GUI objects using an OR Lookup into the object repositories . The type inferencer takes the parse tree the GUI tree and values of properties of GUI objects as inputs and produces a dictionary that maps references to GUI objects in test scripts and to their GUI objects types in GAPs and . For example this dictionary can be implemented as comments in test scripts and that accompany references to GUI objects and or messages in an inference message repository .

The TIGOR architecture includes script navigate logic see Table 1 that is executed on the script side to obtain the object v which is contained in the GUI object that is referenced in the test script and using the object o. The properties of the returned object v are defined in the object repositories under the name p. The script navigate breaks an operation into multiple operations locating and navigating to the GUI object in the corresponding applications determine the state of the application when the GUI object is active locates the GUI object by identifying by matching the recorded properties in the test script in a object repository. Next the GUI object type is matched to the operation to be performed as identified by a composed test script.

The test scripts and are combined into a composed test script by implementing statements that exchange data for a composed GUI object that corresponds to GUI objects in the first and the second applications. Composed test script statements in the composed test script pass data from the statements of one test script to the statements of a second test script for the first and second applications. The statements of the first and second scripts process data of the different types of the GUI object as referenced in the multiple applications. The statements pass information from one script to the other script while managing the differences in the types of the GUI objects as referenced in the multiple applications.

For example a first GUI object referred to as user ID represented as a string robert in the first application a second GUI object referred to as user ID represented as an integer 01234567 in the second application and user ID represented in the combined application as a different type of GUI object e.g. an alpha numeric value robert01 . The first GUI object referred to as user ID represented as a string robert in the first application operations performed on the first GUI object may include reading the name from the GUI object and then performing the operation to reverse the string or some other operation. The second GUI object referred to as user ID represented as an integer operations performed on the second GUI object as an integer may be clearly distinct from the operations performed on the first GUI object.

The TIGOR architecture includes Get Object logic see Table 2 that is executed on the GAP side to obtain the collection of objects v which are contained in the GUI object that is referenced in the GAP using the object oG.

The TIGOR architecture includes MCALL logic see Table 3 may evaluate a test script expression test script statement that references a GAP object to wait for the result of the action performed on the GAP .

The TIGOR architecture includes CALLRETURN logic see Table 4 that returns the result of method execution from the GAP to the test script and EXECGAP logic see Table 5 that evaluates the action at the GAP . E stands for the context in which a given rule is applied.

The testing system TS including the GAP G and the test script T which collectively referred to as programs P . These programs may include a set of locations and a set of values . The state S of the testing system TS is the union of the states of the GAP and the test script . The state of a program P is obtained via the mapping function ProgramState. SP in the reduction rules is shorthand for the application of the ProgramState function to obtain the state S of some program P which either the test script T or the GAP G. The evaluation relation is defined by the reduction logic shown in Tables 1 through 5.

The object repository OR lookup computes the set of properties and their values of a GUI object whose entry in the object repository is labeled p. The OR lookup returns a child object whose properties values match given values of the GUI objects referenced in the test script statements . The function type returns the type of a GUI object as it is defined in the GUI framework the function Member checks if a given method is a member of the set of the methods of a given GUI type and the function childOf returns true if the GUI object of the type is a child object of the parent object of the type t otherwise it returns false . The test script T and the GAP G are members of the testing system TS. Executing the expression e with the initial state ST leads to executing the action a with the initial state SG and the system TS transitions to a new system TS. In these rules T and G are programs and S is a state.

Test scripts are run on testing platforms externally to GAPs and therefore cannot access GUI objects as programming objects that exist within the same programs. Using Application Programming Interface API calls exported by testing platforms is a primary mode of accessing and manipulating GUI objects and these API calls lead to various run time errors in test scripts especially when their corresponding GAPs are modified.

For example a test script statement may include API calls VbWindow Login .VbButton Dolt .Click. The API calls VbWindow and VbButton are exported by the QTP testing framework. Executing these API calls identifies a window whose property values match those stored in some OR under the name Login and this window contains a button whose property values match those stored in some OR under the name Dolt . By calling the method Click this button is pressed. Since API calls take names of the property values of GUI objects as string variables and if GUI objects are identified only at runtime it is impossible to apply effective sound checking algorithms. To make matters worse the names of API calls depend upon the types of GUI objects that the parameters of these calls reference e.g. the parameter for the API call VbButton should reference a GUI object of the type button otherwise a runtime exception is thrown. In addition API calls take names of the property values of GUI objects as defined in Ors as string input parameter variables and the values of these input parameters are often known only at runtime making it impossible to apply sound checking algorithms. These problems are rooted in the absence of type information and exacerbate the process of detecting and understanding failures in test scripts making maintenance and evolution of these test scripts expensive and prohibitive.

TIGOR includes a type system that includes a tractable syntactic method for proving the absence of certain program behavior specifically run time type errors by classifying phrases according to the kinds of values they compute. The type system facilitates programmers to maintain and evolve software effectively by among other things detecting errors providing documentation and ensuring language safety. In one implementation the type system of the programming language cannot be used in which the source code of GAPs is written to declare types of references to GUI objects in test scripts . Even if the source code was available the source code may not contain explicit types whose instances are GUI objects for the test scripts on which to perform actions . These objects may be created dynamically in GAPs using API calls that are exported by the underlying GUI frameworks . The parameters to these API calls are variables that contain values of types of GUI objects as defined by the type system of the underlying GUI framework. For example to create GUI objects in Windows programmers invoke the API call CreateWindow passing a string variable that specifies the types of these objects as a first parameter.

TIGOR infers types of references to GUI objects as part of expressions in test scripts and facilitate type checking of these expressions. TIGOR statically detects type errors with a high degree of automation and good precision.

An executed test script expression changes not only the state of the script but also states of other GAPs to which the script is connected i.e. whose GUI objects the script accesses and controls . Each statement in test scripts which accesses and manipulates GUI objects include the following operations 1 navigate to some destination GUI object and invoke methods to perform actions on the object. In one implementation navigation rules are standard. The rules GS navigate and GS get object show how test scripts manipulate the GAP by initiating a user action a on the GAP . These rules are evaluated to the reference to GUI object whose type is c in the test script .

GS navigate operates on composite test scripts and composite GUI objects that represent unique identifiers and have mappings to the first GUI object in the second GUI object in the individual first and second applications . When GS navigate navigates to the composite GUI object synchronizes navigation to the first and second GUI objects by constructing first and second operation statements that navigate to the first and second GUI object and thereby synchronizing operations with the composite GUI object and the first GUI object and the second GUI object so that subsequent operations can be performed on the first GUI object and the second GUI object. The synchronization ensures that the individual applications when exercised by the composite application do not fail. The state of the composite GUI object in the composite application may represent different states in the respective applications. Synchronization allows the composite test script to set the composite GUI object value the states and values for the first and second GUI objects in the first and second applications.

When the names of entries in the object repositories are string constants sound type checking of expressions that reference GUI objects in test scripts may be applied. The type soundness of TIGOR may be shown through two standard theorems preservation and progress. Type soundness implies that the language s type system is well behaved. In TIGOR well typed inferences to GUI objects do not get stuck that is they pass the type checking algorithm successfully or halt with errors progress . If a well typed expression is evaluated then the resulting expression is also well typed preservation . The progress and preservation theorems and proofs are presented below.

To create mappings between these properties and GUI objects the user moves the cursor over some GUI object of a GAP and TIGOR Composer uses the accessibility API calls to obtain information about the GUI objects. To confirm the selection a frame is drawn around the object with the tooltip window displaying the information about the selected object. Then the user clicks the mouse button and drags this object or rather its image onto the TIGOR Composer dataflow palette . After releasing the mouse button the dragged object is dropped onto the TIGOR Composer dataflow palette under the label of the corresponding component. Once the user has dragged and dropped all desired GUI objects these objects are connected with arrows that specify the directions of data exchanges. For example by drawing an arrow between the object Description of the GAP IT and the object optional of ET the user specifies that the data from the corresponding GUI object of GAP IT will be transferred to the GUI object of GAP ET. In one implementation TIGOR produces type inferencer message guides that explain how to transform the data during data exchange between the GAPS . Once dataflow mappings between GUI objects are specified TIGOR uses the information captured for each screen and input objects to locate and type expression in test scripts statements that reference these GUI objects. The information about GUI objects that participate in data exchange is used to locate references to these objects in test scripts statements thereby enabling test engineers to reason effectively about using the test scripts statements to compose composed test scripts .

TIGOR infers GUI objects types. Once the test script is loaded and parsed and the model of the GUI of a GAP is extracted using the accessibility layer the type inference logic resolves types for references to GUI objects in the running GAP. The user can select a reference in the test script to view its corresponding GUI object on the GAPs . When a reference is selected a frame is drawn around the GUI object with the tooltip window displaying the type information about the selected object and subsequently about its reference. In addition the user may cursor over any GUI object. TIGOR composer displays a context menu that allows the user to check to see what references in the test script to which a selected object is mapped.

In the expression VbWindow a .ActiveX e .VbEdit e .Set navigation is started from the GUI object whose object repository reference is named a . Expressions e and e compute values of the intermediate nodes in the traversal path at runtime. These expressions are parameters to the API calls ActiveX and VbEdit respectively and these calls handle GUI objects of the types Control and Edit. If e and e are evaluated to the names c and g then this statement will execute correctly otherwise a runtime exception will be thrown. The type inferencer logic decides which GUI objects should be visited from the node a in the tree in order to reach a destination object that exposes the method Set . When visiting GUI objects in a path expression the types of these objects should match the API calls that reference these objects . By finding all paths leading to destination objects while satisfying type constraints TIGOR determines whether the navigation expression is correct. If no path exists then the expression is incorrect. If one or more paths exists the type inferencer logic outputs the values to which the expressions e and e may be evaluated.

In another example referring briefly to the type inferencer logic may determine an exposed method Set expressed in the test script statement VbWindow a .ActiveX e .VbEdit e .Set. The type inferencer logic may determine a destination GUI object e that exposes the exposed method Set . The element path between sequential GUI objects in a GUI tree e.g. VbWindow a ActiveX e and VbEdit leads to the destination GUI object e . In one implementation the sequential GUI objects e.g. a e e e.g. a b c e e.g. a b e e.g. a c g are characterized by GUI object types e.g. static control button combo edit calendar .

The API call types e.g. static control button combo edit calendar in sequence are analyzed for compatibility with the GUI object types e.g. static control button combo edit calendar in sequence . For example ActiveX includes static and control as API call types and VbEdit includes button combo edit calendar as API call types. API call types in sequence may include a static button sequence a control combo sequence a control edit sequence and a control calendar sequence. The logic to determine the API call types obtains validated action results for actions performed by the API calls on GUI object types stored in the GUI object repositories .

In one implementation the logic finds multiple GUI object interaction paths validated as useable GUI object interaction paths from the multiple GUI object interaction paths that control the actions performed on the sequential GUI objects and determine a number of GUI object interactions in each of the useable GUI object interaction paths. The logic further causes the processor to select from the useable GUI object interaction paths a first path selected having the least number of GUI object interactions of the useable GUI object interaction paths or some combination of GUI object interactions of the useable GUI object interaction paths. The logic further causes the processor to select from the useable GUI object interaction paths a first path selected having the greatest number of GUI object interactions of the useable GUI object interaction paths or some combination of GUI object interactions of the useable GUI object interaction paths. The logic further causes the processor to determine the type of the exposed method in the useable GUI object interaction paths where the useable GUI object interaction paths each extend from a root node representing the destination GUI object that exposes the exposed method. The test script statement references GUI objects using the GUI objects properties of the GUI objects the properties comprising name location color size or any combination thereof.

In one implementation the GUI object repositories are directed to open source subject GAPs based on the following criteria easy to understand domain limited size of GUI less than 200 GUI objects and two successive releases of GAPs with modified GUI objects. Example GAPs useable with TIGOR include Twister version 2.0 is a real time stock quote downloading programming environment that allows users to write programs that download stock quotes mRemote version 1.0 facilitates users to manage remote connections in a single place by supporting various protocols e.g. SSH Telnet and HTTP S University Directory version 1.0 allows users to obtain data on different universities and Budget Tracker version 1.06 is a program for tracking budget categories budget planning for each month and keeping track of expenses.

In one implementation the type inferencer includes a machine readable medium and get object logic stored on the machine readable medium that when executed by a processor cause the processor to identify a first GUI object referenced by a first test script and implemented in a first application and a identify a second GUI object referenced by a second test script and implemented in a second application. The type inferencer may further include script navigator logic stored on the machine readable medium that when executed by the processor causes the processor to obtain the first test script for the first application and the second test script for the second application and a first result and a second result of a first and a second action performed on the first GUI object and the second GUI object implemented in the first application and the second application . The type inferencer may identify a first and a second sequence of operation statements comprising a first and a second operation statement of the first and the second test scripts . The type inferencer may establish a composed GUI object reference that maps the first and the second GUI objects to a composed GUI object in a composed application . The type inferencer logic further causes the processor to retrieve mappings of first and second GUI object types and type constraints for the first and the second GUI objects from a first GUI object and a second GUI object repositories . The type inferencer logic further causes the processor to create a composed GUI object type mapping of the first and the second GUI object types and type constraints to a composed GUI object type and type constraints for the composed GUI object. The type inferencer logic further causes the processor to create a composed test script comprising the first and second sequence of operation statements and a composite sequence of operation statements that when executed by the processor cause the processor to synchronize states of the first the second and the composed GUI objects.

The first result and the second result are obtained by the type inferencer and the first and the second sequence of operation statements are identified by evaluating the sequence of operation statements of the first and the second test scripts to identify those sequence of operation statements that when executed by the processor cause the processor to synchronize the states of the first GUI object and the second GUI object. The first GUI object and the second GUI object are referred to in GAPs that compose a composed application.

The composed application comprises composed operation statements that when executed by the processor cause the processor to perform actions on the first GUI object and the second GUI object of the first and the second applications. The type inferencer logic further causes the processor to store the composed GUI object type mapping in a composed GUI object repository. The first and the second GUI object type and type constraints of the first and the second GUI objects are mapped by identifying the sequence of operation statements comprising the first and second sequence of operation statements that navigate to the first and the second GUI objects and satisfy the type constraints of the first and the second GUI objects in order to validate a navigation expression implemented by the first and second sequence of operation statements when executed by the processor. The first and second test scripts comprise operation statements that when executed by the processor perform actions on the first and the second GUI objects of the first and the second applications.

The type inferencer resolves the GUI type differences between the multiple applications referred to in the composed test script and provides automatic reasoning so that the amount of work that would otherwise be done by manual inspection is significantly decreased. For example where there are two applications and in one application you have a GUI object that holds values of salary as an integer type GUI object and you have a second application that has a text box or combo box that also holds the values of salary but the GUI object type is string. The operations that are performed on these objects and how you treat the values of the objects will be different depending on the GUI object type integer or a string. The type inferencer infers the values of the GUI objects in the multiple applications for the composed test script so that the operations performed on the GUI objects of the multiple applications correspond to and or match the inferred GUI object types data types . The GUI objects transfer data between corresponding applications. When the inferred GUI object type is incorrect for one of the applications as referenced in the composed test script the type inferencer issues a warning and identifies the location in the composed test script where the type of the GUI object must be revised.

Accessibility tools are used to identify and extract information about types of the GUI objects in the multiple individual applications. Analyze the test scripts for the individual applications to obtain information about links objects referred in the test scripts to the GUI objects in the corresponding application. For example a first application in the second application where in the first application the GUI object is a text box and in the second application the GUI object is a combo box for each application there is a corresponding test script that have statements that reference GUI objects in each of the first and the second application. The composed test script includes statements that reference the GUI object as a text box in the first application and that reference the GUI object as a combo box in the second application. Combining the first and the second application into a mega application that implements a uniform GUI that controls and manipulates the two GUIs of the first and second applications. The composed GUI object implements a uniform GUI object that represents the GUI objects in the first and second applications. The composed test script executes the composed GUI object. When the value of the composed GUI object is entered in the composed GUI the value is translated to the proper data type and type constraints are satisfied in the corresponding first and second applications that compose the composed application. The inferencer generates a sequence of composed operations statements that perform actions on the GUI objects in order to properly update the value of the GUI objects in the corresponding applications.

The systems may be implemented in many different ways. For example although some features are shown stored in computer readable memories e.g. as logic implemented as computer executable instructions or as data structures in memory all or part of the systems logic and data structures may be stored on distributed across or read from other machine readable media. The media may include hard disks floppy disks CD ROMs ROM and RAM. The systems may be implemented in software hardware or a combination of software and hardware.

Furthermore the systems may be implemented with additional different or fewer components. As one example a processor or any other logic may be implemented with a microprocessor a microcontroller a DSP an application specific integrated circuit ASIC program instructions discrete analog or digital logic or a combination of other types of circuits or logic. As another example memories may be DRAM SRAM Flash or any other type of memory. The systems may be distributed among multiple components such as among multiple processors and memories optionally including multiple distributed processing systems. Logic such as programs or circuitry may be combined or split among multiple programs distributed across several memories and processors and may be implemented in or as a function library such as a dynamic link library DLL or other shared library.

Choosing manual testing of GAPs versus writing test scripts is a matter of trade offs between the development effort to create test scripts and their projected level of reuse. The GUIs of most GAPs are changed significantly in the first several releases making the effort of writing test scripts worthless. Only when GAPs stabilize the effort that test engineers put in writing test scripts will be amortized over the future use of the test scripts. TIGOR can foster test automation simply because TIGOR gives a certain degree of assurance that test scripts can be reused in later regression testing. Using TIGOR allows test personnel to reduce costs significantly while keeping test development overhead within acceptable limits. Specifically clients may be given an option that they pay additional cost for creating test scripts and this cost may be amortized over the lifetime of the GAPs by using TIGOR that facilitates test scripts to run on consecutive releases of these GAPs.

Accessibility technologies provide different aids to disabled computer users e.g. screen readers for the visually impaired . Most computing platforms include accessibility technologies since it is mandated by the law. Accessibility technologies provide a wealth of sophisticated services required to retrieve attributes of GUI objects set and retrieve their values and generate and intercept different events. The MSAA for Windows however using a different accessibility technology will yield similar results. Even though there is no standard for accessibility API calls different technologies offer similar API calls suggesting slow convergence towards a common programming standard for accessibility technologies.

The main idea of most implementations of accessibility technologies is that GUI objects expose a well known interface that exports methods for accessing and manipulating these objects. For example a Windows GUI object should implement the Accessible interface in order to be accessed and controlled using the Microsoft Active Accessibility MSAA API calls. In TIGOR accessibility serves as a uniform reflective connector that facilitates test scripts to access and control GUI objects of GAPs.

Using accessibility technologies programmers can also register callback functions for different events produced by GUI objects thereby obtaining timely information about states of the GUI objects. For example if a GUI object receives an incorrect input and the GAP shows an error message dialog informing the user about the mistake then a previously registered callback can intercept this event signaling that the message dialog is being created dismiss it and send an illegal input message to the tool that controls the GAP.

When a target GAP is started the accessibility layer loads predefined hook libraries in the process space of this applications and registers addresses of callbacks that should be invoked in response to specified events. Since hooks live in the process spaces of GAPs their callbacks can affect every aspect of execution of these GAPs.

Hooks are user defined libraries that contain callback functions or simply callbacks which are written in accordance with certain rules dictated by accessibility technologies. Hooks are important because they facilitate users to extend the functionality of GAPs specifically to integrate them with GAPs without changing their source code. Writing hooks does not require any knowledge about the source code of GAPs. In our approach a hook library is generic for all GAPs and its goal is to listen to events generated by the GAP into which this hook is injected as well as to execute instructions received from integrated systems. An example of an instruction is to disable a button until certain event occurs. The power of hook libraries is in changing the functionalities of existing GAPs without modifying their source code. Main functions of the generic hook are to receive commands to perform actions on GUI objects to report events that occur within GAPs and to invoke predefined functions in response to certain commands and events. Since accessibility layers are supported by their respective vendors and hooks are technical instruments which are parts of accessibility layers using hooks is legitimate and accepted to control and manipulate GAPs. In addition writing and using hooks is easy since programmers use high level accessibility API calls and may avoid the complexity of low level binary rewriting techniques.

While various embodiments of the type inferencer have been described it will be apparent to those of ordinary skill in the art that many more embodiments and implementations are possible within the scope of the invention. Accordingly the invention is not to be restricted except in light of the attached claims and their equivalents.

