---

title: Auto generation of test utility bots using compile time heuristics of user interface source code
abstract: Methods and apparatus, including computer program products, implementing and using techniques for generating one or more test utility classes for use in testing a web application user interface (UI). Source code for the UI is provided. The source code includes one or more UI elements. The source code is compiled to generate UI elements to be rendered on the UI. The compiling includes invoking a test utility class generator framework and passing a UI object tree that includes the UI elements to the test utility class generator framework. The test utility class framework analyzes the UI object tree to identify a set of basic UI elements on the rendered UI and to compute an extensible markup language path for each UI element in the hypertext markup language rendered for the UI. Based on the analysis, test utility classes are generated for use in testing the UI.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08522212&OS=08522212&RS=08522212
owner: Google Inc.
number: 08522212
owner_city: Mountain View
owner_country: US
publication_date: 20100721
---
The subject matter herein relates to testing of web applications. Web applications are computer software applications that are accessed through a web browser over a network such as the Internet or an intranet. Web applications can also refer to computer software applications that are hosted in a browser controlled environment such as a Java applet or coded in a browser supported language such as JavaScript combined with a browser rendered markup language like HTML HyperText Markup Language and reliant on a conventional web browser to render the application executable. Web applications are popular due to the ubiquity of web browsers and the convenience of using a web browser as a client. Web applications can be updated and maintained without distributing and installing software on potentially thousands of client computers. Web applications also have inherent support for cross platform compatibility which is another reason for their popularity. Some common web applications include webmail online retail sales online auctions wikis and so on.

Before making a web application accessible over the network it is important to test the web application to ensure that it functions properly. A common way to do this is to use bots which are test utility classes. A test invokes the application programming interface API of the bots which allow the bots to simulate user actions. The tests and bots together form a total web application verification system. The programming code used by the bots for each user interface UI must be written manually by programmers based on the XPaths XML Paths of elements such as buttons form fields etc.

A problem with this approach is that whenever the underlying code for a web application changes for example when the user interface changes and certain buttons login boxes etc. are added removed or moved to different parts of a web page this changes the XPaths and thus causes the web application tests to fail. As a result the existing bots can no longer perform the necessary tests and the bot code must be rewritten based on the changed interface. This requires a significant amount of time and programming resources and becomes a tedious issue for the programmers. Also significant portions of code are rewritten by software developers instead of being reused when testing other similar web applications.

In general in one aspect the various implementations provide methods and apparatus including computer program products for generating one or more test utility classes for use in testing a user interface of a web application. Source code for the web application user interface is provided. The source code includes one or more user interface elements. The source code is compiled to generate user interface elements to be rendered on the user interface. The compiling includes invoking a test utility class generator framework and passing a user interface object tree that includes the one or more user interface elements to the test utility class generator framework. The test utility class framework analyzes the user interface object tree to identify a set of basic user interface elements on the rendered user interface and to compute an extensible markup language path for each user interface element in the hypertext markup language rendered for the user interface. Based on the analysis one or more test utility classes are generated for use in testing the rendered user interface.

Implementations can include one or more of the following features. The generated test utility classes can be used in one or more functional tests of the rendered user interface. The source code can include user interface source templates and user interface source classes. Compiling the source code can include compiling the user interface source templates and a static analysis of the user interface source classes can be performed to capture class properties of the user interface source classes. The class properties can include member fields with associated type information. Generating one or more test utility classes can include using shared test utility classes from one or more libraries of basic test utility classes to construct the one or more test utility classes for use in testing the rendered user interface. The test utility classes in the libraries of basic test utility classes can contain information about a relative extensible markup language path rendering of each user interface element in the rendered user interface. The web application user interface code can be written in the JAVA programming language. Compiling can include adding an identifier attribute to each user interface element to be rendered on the user interface. The test utility class framework can compute relative extensible markup language paths for the one or more user interface elements in the user interface object tree.

Various implementations can include one or more of the following advantages. The need to manually program and maintain bots is eliminated by auto generating the bot code from within the UI compiler at compile time. Furthermore code sharing across teams is enabled which further reduces duplicate programming efforts. Since the UI elements object tree is accessed within the compiler during compilation it is possible to add an identifier ID attribute to each of the various HTML elements which further stabilizes the resulting tests and reduces the dependency on XPaths.

The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features and advantages will be apparent from the description and drawings and from the claims.

In accordance with various implementations methods and apparatus including computer program products are provided which enable interpretation of UI elements as objects at compile time of a web application and generation of bots based on compile time heuristics. The bots i.e. test utility classes can then be used in tests of the UI that simulate user actions on the UI. This avoids the need to manually rewrite the bot code when changes are made to the UI and thus reduces or eliminates the high maintenance costs for the bot code. Furthermore it enables code sharing across software teams. Various implementations will be described in further detail below by way of example and with reference to a web application UI written in Java in GWT Google Web Toolkit using UiBinder templates. GWT is a development toolkit for building and optimizing complex web browser based applications and is provided by Google Inc. of Mountain View Calif. It should however be realized that this is only one possible implementation and that the underlying ideas of the various implementations described herein are also applicable to many other programming languages and templates where the source code is written in Java and access is provided to the compiler. UiBinder templates are XML representations of the web application UI. As will be discussed in detail below a hook in the compiler is used to access the XML representation and to generate bots that can be used to test the web application. The XML representation provides information about the appearance of the UI and the bot generator framework in accordance with the various implementations uses these heuristics.

The UI is generated from a UI code base written in the Java programming language using GWT which contains programming instructions for generating and rendering the login box and its elements as well as instructions for generating and rendering the other UI elements . The UI code base includes a UiBinder template for the UI . In LoginBox.ui.xml is the UiBinder template for the login box . The right hand side of the UI code base shows a Java Class LandingPage which holds a LoginBox object .

To test the UI of the login page bots i.e. test utility classes are generated as the source code is compiled. Tests can then be written which invoke the APIs of the generated bots to perform actions that a user would typically perform on the UI of the login page that is entering a username in the username field entering a password in the password field and clicking the submit button . In a conventional testing environment the bots are written by programmers typically using a third party tool which requires the absolute XPath of each UI element and specifically asks for an action to be performed with respect to the UI element. Alternatively a unique ID attribute can be associated with each UI element and the ID attribute can be used when specifying actions to be performed by the bots with respect to the UI element. One example of such a third party tool is Selenium which is a joint development project by a number of independent programmers and can be obtained from . A manually written LoginPageBot that uses Selenium can for example look like 

In accordance with the various implementations described herein no such manual programming of bots is needed. Instead information that can be extracted from the source code for the UI of the login page at the time the login page is being compiled is used to automatically generate bots that are capable of performing the operations needed in testing the UI . In one implementation the object tree representing the UI of the login page is accessed from within the compiler during compilation and an ID attribute is added to each of the HTML elements of the UI . As will be seen below these ID attributes can be used to further stabilize the tests of the UI and to reduce the bots dependencies on XPaths.

Furthermore the compiler in accordance with one implementation does not only compile the source code for the UI but also invokes a bot generator framework during compilation which will be described in further detail below with reference to . The bot generator framework generates a set of test utility classes i.e. bots using one or more libraries for basic UI element bots. These test utility classes can then be used in automated tests of the UI of the web application as described above. In one implementation one bot is generated for each UiBInder template and additional bots are generated for each holder class. Thus in for example the UI for the login box includes a UiBinder template LoginBox.ui.xml and a holder class LandingPage . Hence a LoginBoxBot and a LandingPageBot are generated. A subsequent test can then invoke either of these bots . The container bot automatically exposes the APIs i.e. actions which can be performed on the bot which it holds i.e. the LandingPageBot automatically exposes the APIs which LoginBoxBot exposes.

These automatically generated bots can then be collected into one or more libraries of basic UI element bots which contain bots for various basic UI elements. The libraries of basic UI element bots can be shared across teams and or projects for example by extending third party tools such as Selenium to include the new basic UI element bot libraries. For example there may be a FlowPanelBot for a FlowPanel a ButtonBot for a Button a TextBoxBot for a TextBox and so on. A complete list of GWT basic UI elements for which bots can be generated can be found at 

During the compilation the compiler adds a unique ID attribute to each UI element in the object tree and passes the object tree representing the UI elements to a bot generator using a hook in the compiler. In one implementation the UI elements have ID attributes of the following format If the object tree is such that a container c contains a container c which contains UI element e then the ID attribute for that UI element would be C C E . Of course this is merely one way to represent ID attributes and as the skilled person realizes many variations are possible. The bot generator takes the UI object tree and generates bots to interact with the rendered UI during the subsequent testing phase. By having a unique ID attribute for each UI element in the rendered UI it is possible for the generated bots to use this ID attribute to uniquely identify the respective UI elements. The programmer who writes the web application test that uses the various bots on the other hand does not have to worry or care about the various UI elements specific XPaths as is necessary in today s third party tools.

In one implementation the bots are generated using a set of libraries such as the ones described above which contain basic bots for basic UI elements. Every basic UI element has a specific way in which it is rendered in a browser. For example a FlexTable is rendered as a table and its children are rendered as tr in the final HTML code. Thus a basic bot FlexTableBot knows that the FlexTable s children can be uniquely identified as 

This is one example illustrating how having knowledge of the internal rendering of a basic UI element can be used to predict a relative XPath of child UI elements. This is especially useful in situations where the child elements are dynamically rendered in the final HTML representation at runtime and do not have defined variables in the UI source code. For example a FlexTable might represent a table that displays some search results. At compile time the results are not even defined and hence any generated bots do not know about possible children but through the FlexTableBot there can be an exposed method clickChild int index which ultimately clicks the div id table s id tr index element. Thus these basic bots in the libraries know the relative XPath rendering of each basic UI element and the basic UI element bot libraries need to be updated only when the HTML rendering of any basic UI element changes.

As an example consider that during the compilation the compiler discovers that there is a login box which includes a username field a password field and a submit button . The compiler passes the object tree for these UI elements to the bot generator. The bot generator analyzes the UI object tree bottom up from the leaves which each represent a basic UI element. The relative locations of the UI elements on the login page are determined by the UI object tree. This tree hierarchy is used not only in generating the multiple bots as described above but also in automatically computing the UI elements respective relative XPaths in the actual HTML rendered. The automatic computation of the relative XPaths in combination with the added ID attributes for all the UI elements as described above stabilizes the bots and reduces the XPath maintenance cost. Each time UI source code changes the tree hierarchy XPaths and automatically generated ID attributes will change and updated bots will be automatically generated as described above.

Now extending these ideas to the UI of the entire login page the actions that can be performed on the class LandingPage i.e. the login page is the aggregate of all the actions that can be performed on the individual UI elements held by the LandingPage class . For simplicity only the UI elements in the login box will be discussed here. To find out what UI elements are included in the LandingPage and subsequently generate the appropriate bots a static analysis is performed of the Java Code base . That is the Java code is parsed but not run. The static analysis captures class properties for the LandingPage class such as member fields which allows the bot generator to use the UI element bot libraries and automatically generate the appropriate bots that can interact with the LandingPage to perform the required testing of the login box .

The actual tests of the web application are then performed by writing functional tests which use the generated bots to perform actions and verify the response of the web application. One example of such a test written in Java is illustrated below 

The bot generator framework also handles references to other templates within a template. For example if a UiBinder template A contains a reference to a UiBinder template B then a bot ABot will have methods to perform actions on UI element B using generated methods in a BBot class. ABot is abstracted from the internal structure of UiBinder template B. All that ABot bot knows about UiBinder template B or rendered UI element B is the user level methods that can be simulated on UI element B using the generated BBot.

In order to further improve the understanding of the various implementations a schematic flowchart of a process for generating and using bots is shown in . As was described above it is assumed that one or more basic UI element bot libraries is available which contains bots that know the internal XPath rendering of each UI element in the UI and can perform actions using computed relative XPaths throughout the UI object tree abstracting the invoker from the rendered XPath.

As can be seen in the process starts by patching the UI compiler step . In one implementation this can be done by adding a hooked call to the bot generator which is invoked for each UiBinder template. Next the compiler is invoked to compile the source code and to add ID attributes to the UI elements in the object tree step . Next static analysis on the non template based source code is invoked step . Both of these steps have been described in detail above.

The compilation and static analysis result in bots being generated which can interact with the rendered UI . Finally functional UI tests are written and executed step which completes the process . The functional tests use the methods in the generated bots to simulate real user actions and are abstracted from the XPath details and third party tools. In the event that the UI source code were to change steps and can be invoked anew which causes updated bots to be generated. Thus as a result no manual maintenance is needed.

Finally to illustrate some of the benefits with the various implementations described herein and why it is beneficial to generate higher level bots based on the bots in the basic UI element bot libraries please consider the following example. Assume there is a basic UI element bot library that includes ButtonBot TextFieldBot and CheckBoxBot classes. Further assume a UI which has a button a checkbox and a text field. In order to write a web application test of the UI in terms of basic bots then it would be necessary to know manually that the UI contains these three elements to name the various elements and to manually look up the XPath and or ID attribute from the browser for each UI element as the basic UI element bots in the libraries are generic. A basic manually coded web application test may look like 

Now consider a case where a high level MyUIBot has been generated which already exposes the following methods clickSubmitButton typeName String name and checkRememberMe . In this case the manually coded web application test would look like 

At this point it ought to be clear that using the generated higher level bots such as MyUIBot creates a significant reduction in programming efforts due to their level of abstraction compared to if web application tests were written using basic UI element bots straight from the libraries .

Various implementations can be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. Apparatus can be implemented in a computer program product tangibly embodied in a machine readable storage device for execution by a programmable processor and method steps can be performed by a programmable processor executing a program of instructions to perform functions by operating on input data and generating output. Various implementations can be implemented in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from and to transmit data and instructions to a data storage system at least one input device and at least one output device. Each computer program can be implemented in a high level procedural or object oriented programming language or in assembly or machine language if desired and in any case the language can be a compiled or interpreted language. Suitable processors include by way of example both general and special purpose microprocessors. Generally a processor will receive instructions and data from a read only memory and or a random access memory. Generally a computer will include one or more mass storage devices for storing data files such devices include magnetic disks such as internal hard disks and removable disks magneto optical disks and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices such as EPROM EEPROM and flash memory devices magnetic disks such as internal hard disks and removable disks magneto optical disks and CD ROM disks. Any of the foregoing can be supplemented by or incorporated in ASICs application specific integrated circuits .

To provide for interaction with a user the various implementations can be implemented on a computer system having a display device such as a monitor or LCD screen for displaying information to the user. The user can provide input to the computer system through various input devices such as a keyboard and a pointing device such as a mouse a trackball a microphone a touch sensitive display a transducer card reader a magnetic or paper tape reader a tablet a stylus a voice or handwriting recognizer or any other well known input device such as of course other computers. The computer system can be programmed to provide a graphical user interface through which computer programs interact with users.

Finally the processor optionally can be coupled to a computer or telecommunications network for example an Internet network or an intranet network using a network connection through which the processor can receive information from the network or might output information to the network in the course of performing the above described method steps. Such information which is often represented as a sequence of instructions to be executed using the processor may be received from and outputted to the network. The above described devices and materials will be familiar to those of skill in the computer hardware and software arts.

It should be noted that the various implementations employ various computer implemented operations involving data stored in computer systems. These operations include but are not limited to those requiring physical manipulation of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. The operations described herein that form part are useful machine operations. The manipulations performed are often referred to in terms such as producing identifying running determining comparing executing downloading or detecting.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be made. For example even though the above implementations have been described with respect to web applications written in GWT which use UiBinder templates and generate bots based on basic bot libraries the above concepts can be used in a wide range of situations. For example these techniques can be implemented on any type of UI such as a desktop client UI and user action simulation tools such as WebDriver. Accordingly other implementations are within the scope of the following claims

