---

title: Systems and methods for photon map querying
abstract: In one aspect, photon queries are answered using systems and methods of traversal of collections of photon queries through an acceleration structure, to identify photons meeting a specification of a given query. Such systems and methods can be extended to satisfying similarity queries in an n-dimensional parameter space. Queries can be associated with code (or pointers to code) that are run to achieve closure of that query. Queries can cause further queries to be emitted. Arbitrary data can be passed from one query to another; for example, parameters defined internally to the code modules themselves (e.g., the parameters do not need to have a definition or meaning to the systems or within the methods).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08952961&OS=08952961&RS=08952961
owner: Imagination Technologies, Limited
number: 08952961
owner_city: Kings Langley, Hertfordshire
owner_country: GB
publication_date: 20100629
---
This application claims priority from U.S. Provisional Patent App. No. 61 221 550 filed Jun. 29 2009 and entitled SYSTEMS AND METHODS FOR PHOTON MAP QUERYING and which is incorporated by reference herein for all purposes.

Generally the following relates to systems and methods for accepting and fulfilling queries made of a dataset defined on n dimensions and some particular aspects relate to photon map query fulfillment an API for accepting such queries and n dimensional query fulfillment and API techniques that may find more usage beyond graphics rendering.

Rendering photo realistic 2 D images from 3 D scene descriptions with various techniques is well known in the computer graphics arts. Ray tracing is an example of an approach to visibility determinations that in conjunction with lighting models allows creation of interesting visual effects and highly accurate lighting effects resulting from modeling the physical behavior of the materials and surfaces involved. By contrast rasterization techniques require more artist involvement in determining how objects in the scene affect each others appearance when viewed from a given perspective and under certain lighting conditions.

A lighting modeling technique of interest is called photon mapping . An example of photon mapping is tracing light energy from a light source e.g. a light and determining what surfaces it hits. Then light energy is associated with hit points. Photons from the lights can be reflected refracted and energy from those photons can be split among those events. Ultimately a given photon loses energy and that photon no longer is propagated.

The photons that were deposited by this process then are maintained in one or more photon maps that can be accessed during lighting calculations that can be run for example after identifying an intersection point of a ray in a scene. A variety of further refinements and differences to this basic approach have been proposed such as using different photon maps for caustic photons and the like.

Similar to ray tracing using photon mapping for lighting determinations is quite compute intensive and at its most realistic and most unimplementable could involve attempting to trace each photon coming from a given light source which for an example 60w green light bulb would require a computer about 10times faster than those available at the time 2004 . Thus practical usage of photon mapping has required approximations. The following in some aspects proposes techniques for providing results from photon maps and mechanisms for interfacing with systems implementing such techniques.

The following primarily relates using photon mapping for lighting effects in 3 D scene rendering as well as to more generalized servicing of queries made of an n dimensional dataset. In some cases aspects can be used in conjunction with ray tracing as a mechanism to render 2 D representations of 3 D scenes. In some cases elements of a system architecture can be shared for use in both ray tracing and photon mapping. For example in some aspects a common form of acceleration structure can be provided for both ray tracing and photon map queries and hardware portions of a system tuned for accelerating ray tracing also can be used in accelerating the photon map queries and n dimensional data set queries as provided for in some examples .

One aspect of this disclosure relates to provision of an API that is intended for use with systems implementing photon mapping for determining lighting during rendering of 3 D scenes. In further aspects this disclosure relates to provisional of a capability for serving queries about data points in a generalized n dimensional space apart from a specific application in scene rendering.

As such although the principal examples used herein are in 3 dimensional space these disclosures are application in a space of any dimension n dimensional space . In discussing such application to higher order dimensions it can be helpful to generalize the terminology. Two principal kinds of data operated on in these disclosures are the data points themselves which in one application are photons deposited in a scene. Such photons can be used during diffuse lighting operations or calculations. For an n dimensional space these data points typically would be defined by a real number provided for each of the dimensions. In some applications these numbers can be represented as floating point numbers.

In some applications queries that ask what points are nearby a given point can be answered. To efficiently answer these queries an acceleration structure is provided that comprises a plurality of elements where each element can be considered a surface defined in the n dimensional space. The elements of the acceleration structure can be defined to bound different selections of the data points and are associated with each other such that a search of the acceleration structure can be made. In some examples the acceleration structure can be a hierarchy where each element has one or more child elements and its child elements each bound some subset of the data points bounded by its parent. In some common examples the acceleration structure elements can be considered manifolds of n 1 dimension for an n dimensional space. For example a ball s surface is a 2 D manifold and can be used to bound datapoints that are defined in 3 dimensions.

Photon queries can be accepted through an application programming interface . Those queries can be traced in collections. The collections can be formed based on determining overlap between an extent of elements of the acceleration structure and the extent defined by the photon query or queries . Photons meeting each of the queries can be returned .

Regarding the acceleration structure for example the acceleration structure may be comprised of spheres located in the scene again relying on the 3 D example and the photon queries each can establish a locus e.g. an origin and a distance from that point in which photons are to be identified for spherical queries . Spherical queries are an example and other query definitions and approaches can be implemented. In some aspects herein it can be helpful to visualize queries in terms of their shapes and other queries shapes that can be implemented include partial hypersheres hyper ellipsoids hyper boxes beams and cones. More generally such shapes can be viewed as defining a hypervolume. One approach to query definition allows definition of a manifold of an n dimensional data space where the definition of the manifold serves as the definition of the query to be served. Other examples of query definitions can include discontinguous hyperspaces or surfaces. Queries also can be defined using Boolean operators on multiple simpler queries. Here also the term manifold is helpful for understanding the concept as Euclidean spaces generally are more easily understood. However datasets and queries according to a variety of aspects herein are not strictly limited to or confined by principles of Euclidean geometry.

Queries also can be defined with fuzzy boundaries as well as boundaries that are data dependent. Examples of such queries include a query to find closest k photons to a locus and k closest photons that meet a criteria.

Each element of the acceleration structure is related to one or more other elements of the acceleration structure. Potentially elements of the acceleration structure serve as parent nodes for a number of children elements. When a parent node is ready for test its children are fetched and tested against all the photon queries that previously were determined to overlap an extent of the parent node of the acceleration structure the extent of overlap partial in that parts of the acceleration structure and of the photon queries may not overlap also . As such a search can continually narrow and focus further on more granular collections of photons until finally a small enough batch of photons can be returned for each query. Elements of an acceleration structure each can abstract a substructure a sub graph of a number of nodes and traversal of the sub graph with a query or collection of queries can depend on whether the node of the acceleration structure abstracting that sub graph has been intersected.

In some cases each photon query can have a unique identifier or at least unique among the photon queries then outstanding although the identifier may repeat. In some cases hardware resources can be provided for query resolution and hardware identifiers can be maintained for use in identifying queries being actively tested in hardware resources as well as software identifiers that have a wider range and which can be used to identify queries that are stored in memory but not currently being tested in hardware resources. Translation between the two can be provided or a mapping maintained.

Controller can maintain a ready collection list which includes collections of queries that have been determined ready for test. For example a collection of queries is ready for test when there is at least a determined number of queries associated with a given element of the acceleration structure. When the query test resource can test the queries of a collection against a set of acceleration elements identified based on their relationship with the element associated with the collection selected for test query test resource can cause definition data for those queries to be fetched from a comparatively slow memory and tested against the queries of the collection. Query test resource can comprise a plurality of test cells which each can operate synchronously or asynchronously or within a window of available testing with the other test cells. O where population control for photon queries can be implemented. Population control can occur by determining whether there is spatial locality for photon queries and preferentially holding back some queries. For example queries entering the hierarchical structure may split many more ways while queries farther down in the structure may split less given that a query can exist in a number of collections simultaneously . Therefore preference can be given to queries closer to completion. also illustrates attribute sharing for photon queries such as in outstanding query list . Outputs from query test resource can comprise a list of queries identifiers associated with one or more identifiers for photons or more generally data elements determined to satisfy the query . The outputs can be grouped according to query or according to photon or both. A matter between a given photon and a section of code such as a shader can be provided which can provide an input to a decision whether the output should be shaded other inputs can come from controller . If the decision is to defer then the photon can be returned to list . If the decision is to shade then a query identifier can be used to map to a bundle of queries such as to identify parameters for the query or for the photons. A count management process can be conducted which can manage a number of queries in flight and operate to provide a feedback to either dampen or increase secondary production of queries according to system through and resource availability.

As disclosed above each of the queries can be collected against elements of the acceleration structure and further traversal of each query can be deferred in favor of further traversal of other query collections. In some examples collections can be selected for further processing based on a number of queries collected. In other cases considerations such as query population control can be considered. In some exemplary implementations datasets used will be updated comparatively infrequently e.g. on the order of 10 milliseconds such as may be appropriate in a system operating to produce final outputs 60 times a second or on the order of 5 milliseconds for final output frequency of 120 times a second for example . Generally also it is contemplated that a large number of queries will be required where each is relatively insensitive to latency or time of completion. A maximum latency for resolving a single query can be specified such that the query resolution resources can be allocated to satisfying queries that have aged a given amount. In situations where closure of a query can cause additional queries to be spawned control of a population of defined queries that require resolution can be controlled by selecting different types of queries to be resolved.

In some exemplary aspects systems are organized to be used as query engines by distributing data defining the queries among local storage associated with testers e.g. among caches associated with cores . The query definition data can remain there until the query completes. Testing can be activated by passing identifiers for the queries among the testers. The identifiers passed can be determined by control circuitry that maintains collections of query identifiers against elements of the acceleration structure. When an acceleration structure element is selected for test a DMA can be provided to fetch the children elements of that element and those elements can be provided to the test cells. The results can be collected at the test cells or returned responsive to completion of testing in those test cells. Queues can be provided that allow out of order testing at the test cells. Multiple test cells can share a queue. Multiple test cells can share a cache. Packets can be passed among the test cells to collect results as well as to pass query identifiers.

Thus in these examples a query can specify a locus in n dimensions and the acceleration structure can be provided as an arrangement of manifolds in n 1 dimensions such that for the 3 D example the manifolds would be 2 D surfaces bounding selections of points as described above . As such the query engine can return points that are deemed similar to each other based on the critieria presented in the query.

A further call that can be provided in an API according to this disclosure is a call allowing emission of a bundle of photon queries all sharing at least one characteristic or similarity. For convenience such a call can be named EmitphotonBundle and can accept data defining or from which can be derived an origin and extent for each photon query data defining attributes shared among the queries of the bundle data defining attributes unique to each query as well as shared or unique parameters for each query.

The additional data can be user defined and can be application specific. For example an attenuation vector or number can be implemented as such additional data e.g. an origin and a radius are central to defining a spherical query but data that may be used for implementing different photon constructs can be made to vary herein among different applications .

As was disclosed above an API call can be provided to allow a shader to directly contribute to a buffer e.g. buffer . Such contribution although prototypically additive can also implement different functions in such contribution including setting. Also a buffer to which a contribute call may write can be an intermediate buffer used for any purpose and not only a buffer storing color information directly relevant to a pixel color. Thus an accumulation buffer or to otherwise accumulate encompasses capturing effects of write operations from usage of the contribute call available in the API.

In some cases it may be preferable to store queries currently being tested for intersection in cache while fetching primitives acceleration elements or a combination thereof for testing from RAM when required. Shaders can be stored in RAM along with texture data. Each core may be assigned to perform intersection testing or shading or in some cases may perform a combination of intersection and shading operations.

Programming semantic can be stored in storage or non volatile memory and loaded into RAM or a combination of RAM and cache with a rendering application such as a video game a computer aided design or animation package and so on. Programming semantic also accesses code and or hardware appropriate to the particular system implementation to implement the query emission and light contribution calls described above.

In any case textures can also be called texels and shader code can be provided to a frame shader . Frame shader can be run for each pixel of a 2 D representation to be rendered from a given 3 D scene. Frame shader can use inputs including textures and shader code which a programmer can use to supply data generally through textures and code through code that can be executed for use in performing such tasks as determining what queries to issue for a given pixel or more broadly an element of data set to be completed. Analogously filtering operations can be performed on these pixels or data elements. Thus frame shader can use both emit and contribute calls respectively identified as Emit Query and Contribute . Because flow is programmer centric intersection testing occurring between Emit Query and query shader is abstracted i.e. intersection testing determines what photons or more generally data elements meet a given query and hence what shader will be run . In sum a function of a camera in traditional ray tracing can be provided using a more generalized concept of a fully featured frame shader for general data querying or photon query systems giving increased flexibility to a programmer as to how queries should be issued into a scene for testing while also providing a useful abstraction of the rendering implementation.

Another aspect of flow is that a vertex shader can run to perform functions generally attributed to vertex shader as presently described in the literature. Ray shader also receives texture information and shader code and similar to frame shader use that information in determining how to use an Emit Query call and a Contribute call i.e. calling the same respective functions as calls and . Generally shader represents an instance of shader code executed in response to an identified ray primitive intersection on associated texture data and other data as available such other data including additional data passed through a ray data structure provided by a potential prior shader such as Frame Shader .

Still further aspects in accordance with these disclosures can include analysis of shader code written for use with a recursive ray tracing methodology renderer and automatically converting that recursive shader code into shader code for non recursive ray tracing. This automatic conversion can be useful in converting shader code written for use in recursive code implementations for non recursive implementation.

In sum any of the functions features and other logic described herein can be implemented with a variety of computing resources. A computing resource can be a thread a core a processor a fixed function processing element and the like. Also other functions which are not primarily the focus of this description can be provided or implemented as a process thread or task that can be localized to one computing resource or distributed among a plurality of computing resources e.g. a plurality of threads distributed among a plurality of physical compute resources .

Likewise computing resources being used for intersection test can also host other processes such as shading processes that are used to shade intersections detected. By further example if a core can support multiple threads then a thread can be dedicated to shading while another thread can be dedicated to intersection processing.

Thus scene builder accepts shaders that may be called to run during intersection testing of a scene being rendered. The shaders can pass data to each other through the EmitQuery call which can accept elements of additional data as arguments or a query data structure with such elements.

These query bundle calls can be provided by an API semantic such that when shaders use these calls a compiler or other software that is preparing to render a scene can appropriately interpret these calls based on that semantic. API as implemented on a given system and during shader execution i.e. during rendering of a scene as shaders are identified based on identified intersections code representing these ray bundle calls will be executed . Such execution interoperates with a memory storing a master copy of query data defining queries that have been emitted for intersection testing but generally which have not yet completed intersection testing. Some of these queries generally are being actively intersection tested in an intersection testing resource while others of these queries await intersection testing.

A controller manages master query data copy and determines which queries are to begin intersection testing and update master copy as intersection testing results become available and as shaders continue to emit new queries.

Also in this particular example a queue of query identifiers is populated under control of controller . Queue is read by intersection testing resource when it can accept new queries for intersection testing. In an example data defining the queries identified by query identifiers in the queue are separately provided in a queue for storage in a localized memory in the intersection testing resource not illustrated here . In some cases queue need not be provided and query definition data can be DMA ed to one or more local memories accessed by intersection testing resource .

Intersection testing resource outputs intersection testing results to a results queue and typically includes an identifier for a primitive intersected and the query identifier. For example results queue includes as one entry query ID A and Primitive ID Q. Controller or another functional block can determine that primitive Q maps to Shader B i.e. that shader B determines how primitive Q behaves . Subsequently a decision whether Shader B is to be executed for primitive Q is made . That decision can be made based in part on control inputs . Such control inputs can include indications of current resource usage such as current usage or occupancy of a total available memory space for query data master copy . The decision to shade or not also can use information about shader B which could have been derived at compilation time or is otherwise inferred based on contents of shader B. Decision also can be made based on a weight associated with the query or another suitable indication of relative importance of the query to the scene.

If the decision to shade a given query intersection is affirmative then there can be mapping between the query ID for that query and its associated bundle if there is such a bundle there need not be as queries can be emitted singly or even if emitted using a bundle call then can all be stored with completely distinct and independent information . Then a count of remaining queries of that bundle can be updated . The shader for the query can be executed in shader computation resources .

Control inputs can comprise a variety of other information about system usage. For example control inputs can comprise an upper bound above which higher weight queries are to be deferred for shading and a lower resource bound at which higher weight queries are to be preferred for shading. Further information can include an average weight for the queries that are currently stored in query data master copy trend information about such query weight and the like.

Systems methods and computer readable media embodying aspects of the above description related to accepting shaders and determining a query data structure for additional data elements inclusive in the query data structure can be provided. In these cases additional data elements also can be embodied by references such as memory references logical or physical rather than directly representing a given data value. The references can be used to retrieve corresponding data from one or more memories. The additional data elements can be associated with a data type when originally defined in shader source code e.g. integer float double string and so on . These data types can be used by scene builder in determining a query data structure and for correlating elements among shaders. Scene builder can be embodied in systems and code that also provide the API aspects related to contributing color and emitting queries as described above. For example an API can include calls for submitting shader code geometry textures and so on in addition to calls used by shaders during runtime. After an application has submitted such information through the API the application can indicate that the scene is ready to be rendered.

The above disclosures provide examples of methods and systems for resolution of queries in a given parameter space where the parameter space is occupied by spatially located data elements which in some implementations can be represented by points located in the parameter space. Queries can define a shape or shapes within the parameter space that define a hypersurface and allowing a determination whether the spatially located data elements are within or without the parameter space defined by a given query. Queries can be submitted singly or in bundles. Queries can be defined by reference to one or more other queries. Queries can be associated with arbitrary data such as a pointer to code or code that will be executed in a computation resource. Such code can in turn cause additional queries to be defined. These queries can reference or otherwise inherit such additional data. Examples of system control include controlling a number of queries that are emitted by selecting queries to be closed such as by executing associated code. Implementations can be used in the context of ray tracing to implement functions such as diffuse lighting calculations and in such implementations the API calls described can be used by shader code associated with one or more rays that have been found to intersect a surface associated with that shader code. Queries can be traced in collections such that a given collection or set of queries is tested against a group of acceleration elements that may be bound data elements that satisfy one or more of the queries.

Implementations can use one or more general purpose processors or processor cores each operable to execute one or more threads. Portions of the capability of each processor can be allocated to execution of traversal routines for queries while other portions of such capability can be allocated to running code associated with queries that have been satisfied. Other implementations can use special purpose testers to implement portions of a traversal algorithm. For example testers can be provided that are optimized to execute a particular intersection algorithm. In some implementations relatively fast memory is allocated to storage of queries in flight where they are repeatedly tested against different portions of an acceleration structure while slower and larger memory is allocated or used to store portions of the acceleration structure.

Examples of applications of additional data include attenuation vector s associating weights or masses or other physical attributes with queries mathematical operations such as filtering or blending specifications flags indicating or influencing shader behavior executable code e.g. code for procedural geometry that can modify or influence the scene or objects in the scene and so on.

Code for any method can be stored in computer readable media such as solid state drives hard drives CD ROMs and other optical storage means transiently in nonvolatile memories as well as embodied in communication signals. When such code is embodied in a communication signal and that signal is read and processed by a computer the computer uses that signal and its physical medium as a computer readable medium.

Computer executable instructions comprise for example instructions and data which cause or otherwise configure a general purpose computer special purpose computer or special purpose processing device to perform a certain function or group of functions. The computer executable instructions may be for example binaries intermediate format instructions such as assembly language or source code. Some aspects of the API described herein can be implemented as procedures functions or calls to such procedures and functions. This description implies no limitation as to a programming methodology that can be used to implement or provide the functionality described as being available through these procedures or functions so long as software hardware or a mixture thereof provides a programmer with an ability to access such functionality through an interface provided therefore. Various names were provided for particular coding concepts in both recursive and non recursive query tracing e.g. Trace Query Emit Query and EmitQueryBundle . These names imply no requirement as to what code performing these functions need to called in an implementation.

The various examples described above are provided by way of illustration only and should not be construed as limiting. For example only a limited example of query tracing behavior was presented and it would be understood that practical implementations involve many more queries and often more concurrent processing thereof. The disclosures herein can be adapted and understood from that perspective. In addition separate boxes or illustrated separation of functional elements of illustrated systems implies no required physical separation of such functions as communications between such elements can occur by way of messaging function calls shared memory space and so on without any such physical separation. More generally a person of ordinary skill would be able to adapt the disclosures relating to the programming semantic to a variety of other query tracing query shading implementations and no implied limitation as to its application exists from the systems methods and other disclosure used to explain examples thereof.

