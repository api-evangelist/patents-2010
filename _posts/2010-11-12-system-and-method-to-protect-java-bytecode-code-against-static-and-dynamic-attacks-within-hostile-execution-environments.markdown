---

title: System and method to protect Java bytecode code against static and dynamic attacks within hostile execution environments
abstract: A method and system that provides secure modules that can address Java platform weaknesses and protect Java bytecode during execution time. The secure modules are implemented in C/C++ as an example. Because implementation of the security modules is made in C/C++, this enables use of security technology that secures C/C++ software code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09213826&OS=09213826&RS=09213826
owner: Irdeto B.V.
number: 09213826
owner_city: Hoofddorp
owner_country: NL
publication_date: 20101112
---
This application is the National Stage of International Application No. PCT CA2010 01761 filed Nov. 12 2010.

The present invention relates generally to computer software and more specifically to a method and system of making computer software resistant to static and dynamic attacks within a hostile execution environment.

Within the computer programming industry the Java programming language is used in every major industry segment and has a presence in a wide range of devices computers and networks. Java applications are written in the Java programming language and compiled into machine independent bytecodes that are executed on a Java Virtual Machine JVM which is deployed on a host Operating System OS and the host Computer Processing Unit CPU Instruction Set Architecture ISA . Java technology s versatility efficiency platform portability and security make it the ideal technology for network computing. The Java programming language is found everywhere from laptops to datacenters game consoles to scientific supercomputers and cell phones to the Internet. Indeed portability extensibility generality and reliability are key Java strengths. However such ubiquity also provides ample opportunity for hackers and related computer attacks.

To prevent attacks and unauthorized access to the Java environment from un trusted applications Java technology includes the Java sand box security model for protecting the execution environment of the host machine or device where compromised software such as viruses or malware may be downloaded or installed illegally. Preventing such hostile attacks is essential in designing critical applications that normally run on highly protected environments and systems such as telecommunication systems transportation systems defense systems industrial automation systems and power management systems. Each year more and more such critical systems are designed and implemented using the Java programming language.

Likewise the consumer electronics industry is entering a new age where advanced technologies and products rapid demand on media digitalization and the continuously falling prices of consumer electronics taken together with increasing disposable income from emerging markets have spurred growth in the consumer electronics market at a speed and scope without precedent. Many such consumer electronics products rely on software applications to function. Certain Java programming language strengths such as portability extensibility generality reliability and simplicity reduces overall development and deployment cost of consumer electronics products thereby ensuring more and more Java based platforms and applications are deployed to new consumer products.

Almost all consumer electronics devices require functioning in an un trusted environment. In un trusted environments software within consumer electronics devices can be directly accessed for different purposes ranging from a beneficial reason e.g. to get needed services to undesirable reasons e.g. to hack the devices . As a result more and more computer applications execute in a relatively hostile environment than ever before. For example hand held devices such as portable media players or smart phones home networking such as set top boxes media players or personal computers and web based environments are areas where attackers often spend large amounts of time and resources. Therefore the protection of legitimate software against attacking software is becoming an escalating arms race. Moreover high performance hardware and sophisticated attack tools provide the intruders with many new advantages.

Software distributors must be sure that their software is robust and resistant to attack. However the given platform and software are often well known to an attacker who has time resources tools and all the experts on the web at the disposal of the attacker. This hostile attack landscape is often termed a white box environment where all the content is in plain sight and therefore subject to direct access and tampering. This is the opposite of a black box environment which is in the other words a trusted and protected environment where content is hidden or otherwise protected from attack. In the prevailing hostile landscape of a white box environment preventing or stopping direct and automated attacks to software systems is becoming one of the most demanding security challenges. Moreover strong defenses for white box attacks must be achieved to ensure proper and secure device function. The Java programming language is not adequately designed to tackle such security problems and challenges. In this respect certain Java strengths actually cause security weaknesses when compared to programming in C or C .

Unlike C C compilers that compile C C code to a low level instruction set which operates on raw binary data and is specific to the target hardware such as x86 or PowerPC a Java compiler compiles Java source code to a higher level portable bytecode that operates on classes and primitive types that the JVM can interpret during execution. Platform dependency is encapsulated within JVM and decoupled from the Java application.

As well the standard Java compiler does not perform compile time optimizations that are commonly and usually found in C C compilers. Instead Java relies on Just In Time JIT compilation to perform all optimizations at run time while taking the execution profile into account for performance improvement. Major C C code optimizations are performed at compile time. For example inline substitution results in copies of the given member function being scattered around the binary image use of the preprocessor combined with compile time evaluation of expressions may leave no trace of the constants defined in the source code and so on. In general sophisticatedly optimized code is more difficult to reverse engineer.

Still further Java program dependencies are resolved at run time when classes are loaded. So the name of the class and names of its methods and fields must be present in a class file as well as names of all imported classes called methods and accessed fields. On the other hand C C programs are statically linked. Therefore the names of classes members and variables need not be present in the compiled and linked program except for names exported from dynamic libraries.

Finally a Java application is delivered as a set of Java Archive JAR files. The JAR format enables multiple files to be bundled into a single archive file which are essentially non encrypted archives and from which it is relatively easy to extract individual classes. By comparison a C C application is delivered as a monolithic executable that may link with a few dynamic libraries so it is not as easy to identify program information and individual code.

Accordingly the decompilation of Java bytecode to Java source is much simpler and easier than dissembling C C and can therefore be fully automated. Program information such as class hierarchy statements names of classes methods and fields can all be retrieved from the bytecode. Although there are many freeware and commercial Java obfuscation tools available none provide protection to prevent a direct attack to execution of the bytecode. As a result Java reverse engineering is now a common practice.

Moreover a JVM provides an open run time environment for Java applications. There is very little built in security to protect the JVM and make the JVM itself robust. Attaching to a JVM itself or using a JVM to launch attacks is relatively trivial. Therefore regardless of the strength of protections applied to Java application code hackers may always use the JVM as the weakest link in order to implement white box attacks because of the JVM s vulnerability. Although a more trusted and robust JVM would likely protect Java applications and prevent white box attacks this approach would require significant changes to the current Java security model and related significant industry support and adaptation. It would therefore be desirable to have a trusted and robust component within industrial standard JVM that protects applications within a white box environment.

It is an object of the present invention to obviate or mitigate a major disadvantage of previous Java platform configurations.

This disclosure presents an invention that provides secure modules that can address Java platform weaknesses and protect Java bytecode during execution time. The secure modules are implemented in C C as an example. Because implementation of the inventive security modules is made in C C this enables use of security technology that secures C C software code. For purposes of the present invention suitable security technology is that provided by Cloakware Inc. of Ottawa Ontario Canada. Such suitably intended security technology is described fully within prior commonly owned United States Patents including U.S. Pat. No. 7 506 177 issued on 17 Mar. 2009 to Chow et al. and titled TAMPER RESISTANT SOFTWARE ENCODING AND ANALYSIS U.S. Pat. No. 7 464 269 issued on 9 Dec. 2008 to Johnson et al. and titled SECURE METHOD AND SYSTEM FOR HANDLING AND DISTRIBUTING DIGITAL MEDIA U.S. Pat. No. 7 397 916 issued on 8 Jul. 2008 to Johnson et al. and titled SYSTEM AND METHOD FOR PROTECTING COMPUTER SOFTWARE FROM A WHITE BOX ATTACK U.S. Pat. No. 7 395 433 issued on 1 Jul. 2008 to Chow et al. and titled METHOD AND SYSTEM FOR SUSTAINABLE DIGITAL WATERMARKING U.S. Pat. No. 7 350 085 issued on 25 Mar. 2008 to Johnson et al. and titled TAMPER RESISTANT SOFTWARE MASS DATA ENCODING U.S. Pat. No. 7 325 141 issued on 29 Jan. 2008 to Chow et al. and titled METHOD AND SYSTEM FOR SECURE ACCESS U.S. Pat. No. 6 842 862 issued on 11 Jan. 2005 to Chow et al. and titled TAMPER RESISTANT SOFTWARE ENCODING U.S. Pat. No. 6 779 114 issued on 17 Aug. 2004 to Chow et al. and titled TAMPER RESISTANT SOFTWARE CONTROL FLOW ENCODING and U.S. Pat. No. 6 594 761 issued on 15 Jul. 2003 to Chow et al. and titled TAMPER RESISTANT SOFTWARE ENCODING each of which patents are herein incorporated in their entirety by such reference made here.

The existing software security technology disclosed in the above referenced patents and related products from Cloakware Inc. are used to protect legitimate applications along with the functionality and intellectual property of the applications which run on hostile un trusted execution environments in order to prevent white box attacks to these applications. Such existing software security technology contains practical source code and binary protection tools that protect applications in C C along with native compiled code and make software and security inseparable by enhancing traditional application building processes.

In a first embodiment the present invention provides an apparatus for increasing tamper resistance of Java bytecode including a protection tool for applying security to Java bytecode during build time a security module accepting secured Java bytecode from the protection tool and launching the secured Java bytecode during run time and one or more protection mechanisms integrated with the protection tool and the security module wherein one or more protection mechanisms operate to counter static and dynamic attacks to the Java bytecode.

In a further embodiment of the present invention the apparatus also includes a secured Java bytecode including a protected Java application bytecode stub a protected application payload and an encrypted class bytecode frame each of which being formed by said protection tool during build time.

In another embodiment of the present invention the security module is distributed independently as a functional extension to a Java virtual machine environment to provide a root of trustiness of protected Java applications and the secured Java bytecode is distributed separately as per user needs.

In a further embodiment of the present invention the protection tool has a mechanism to dictate that the protected application payload is launched via said protected Java application bytecode stub.

In a further embodiment of the present invention the security module includes a protected bytecode class loader and the protection tool includes a mechanism to dictate that said protected application payload is launched via said encrypted class bytecode frame using the protected bytecode class loader.

In a further embodiment the apparatus is formed of programming engines implemented in a programming language including one or more of C C and Java.

In a further embodiment the apparatus is formed of programming engines implemented in a programming language capable of interfacing with a Java virtual machine.

In a further embodiment one or more of the protection mechanisms are selectable according to configuration options. These protection mechanisms may also include static security handlers formed within the protection tool and dynamic security handlers formed with the security module.

In a further embodiment the static security handlers may include a whitebox WB static security handler for accepting cryptographic information including cryptographic keys from a user so as to generate WB encryption key data used by one or more of other the static security handlers and WB decryption key data and a WB security module utility each used by one or more the dynamic security handlers during dynamic run time protection of the security module.

In a further embodiment the static security handlers may include a bytecode integrity verification BIV static security handler for applying hash code protection to the secured Java bytecode in response to protection marking information and the dynamic security handlers includes a BIV dynamic security handler for verifying the hash code protection at run time wherein the security module invokes tampering countermeasures upon verification failure.

In a further embodiment the apparatus further includes static security handlers which may include a secure loading bytecode SLB static security handler for forming during build time a protected Java application bytecode stub a protected application payload and an encrypted class bytecode frame and the dynamic security handlers includes an SLB dynamic security handler for loading into a memory buffer said encrypted class bytecode frame corresponding to the secured Java application bytecode decrypting each of encrypted class contained within the encrypted class bytecode frame via said WB decryption key data corresponding to the encrypted class loading each decrypted class bytecode into an application work space via a security module class loader so as to execute the Java application bytecode within the application work space.

Other aspects and features of the present invention will become apparent to those ordinarily skilled in the art upon review of the following description of specific embodiments of the invention in conjunction with the accompanying figures.

As seen by way of the Java platform additionally includes a Java Native Interface JNI that provides a facility to bridge two way interoperations and interactions between the Java world which includes a JVM Java applications and libraries in bytecode loaded within the JVM and the native code world which applications or shared libraries are written in other languages such as C C assembler and compiled into the host CPU ISA . By using a JNI Application Programming Interface API in Java programming language and C C assembler code C C assembler native binary code can be callable from Java and also can invoke Java bytecodes. There are two kinds of interactions down calls when a Java application code calls a native method and up calls when a native method accesses data or invokes methods of the given Java application via a JNI environment.

At the run time the security modules of the present invention can co execute within the JVM via the JNI so that the given Java application can invoke secure operations within the inventive security module where such secure operations can access the Java application and other Java library code loaded within the JVM and perform protections.

The approach of the present invention is effectively a security add on to an existing JVM by introducing a security module that is fully protected and trusted within the JVM via the JNI mechanism. At run time the security module acts as the root of the trust and as a protection trampoline and engine within the JVM to launch and perform the various protections to Java bytecode. In this way the present invention does not require any global changes to the existing Java platform. Rather both existing and newly deployed systems and devices can benefit from this solution immediately. In the other words the present invention may be treated as a security extension to existing Java infrastructure to address security problems faced by current Java applications. Thus the present invention provides a Java bytecode protection security module that leverages the ability of the JNI to access bytecode during run time and perform a set of protection methods to Java bytecode in response to static and dynamic attacks to the Java application.

The present invention provides a highly trusted protection tool and security module within a Java bytecode protection system. The present invention does not rely upon Java application protection based only on the JVM and Java security. Rather the present invention introduces a Java bytecode protection security module SM being a trusted zone that can work with the JVM via the JNI to launch perform and manage Java bytecode protection during run time. The trustworthiness of the security module is guaranteed by applying known effective security protection to C C code in which programming language the protection tool and security module are written. With such a trusted SM trustworthiness is expanded from the SM to the Java applications and the JVM by certain protections provided by the SM discussed further herein.

With regard to typical static and dynamic attacks to java bytecode are illustrated. In general any given Java application is developed in Java source form and then compiled into Java bytecode by a Java compiler which is stored on an archive file i.e. JAR file by using an archiver utility prior to distribution. Such distribution may take many forms including media such as a Compact Disc CD or downloadable files.

A static attacker normally uses reverse engineering tools e.g. a Java decompiler to extract valuable intellectual property information i.e. proprietary data or software algorithms from the code from the distribution media. In doing so the attacker may then make illegal changes to the code or otherwise compromise the underlying code . In order to prevent such static attacks to Java bytecode during the distribution of the given Java application the present invention applies a level of protection to application bytecode. This protection is provided before distribution to ensure that static attacks become extremely difficult tasks. After applying effective protection by way of the present invention the intellectual property embedded within the application bytecode is not easily reverse engineered and any tampering of the protected bytecode becomes an impractical exercise. Moreover the static protection of the present invention is advantageous because any tampered bytecode cannot be loaded and run by a legitimate JVM.

In comparison to static attacks to an application bytecode a dynamic attacker can implement attacks to Java bytecode by using dynamic attack tools while a JVM is loading and running the Java application. By using dynamic attack tools and methods an attacker can access the JVM and application bytecode observe and modify the bytecode directly to understand or and change original designated behavior and important values for their attack purpose. Moreover the attacker can ascertain valuable intellectual property and secrets from the bytecode including lifting original bytecode . In order to prevent such dynamic attacks to Java code during run time the present invention forms and implants protection to the application bytecode before distribution. Moreover the present invention implements those protections during run time to ensure any dynamic attacks are impractical. The present invention serves to not only prevent dynamic attacks but also adds the ability to the protected application to detect dynamic attacks and be able to mitigate dynamic attacks as well as making such attacks very expensive efforts in terms of time and resources for any prospective attacker.

The Java bytecode protection tool is used to apply security i.e. cloak the Java bytecode prior to deployment. This Java bytecode protection tool allows the security settings and protection mechanisms to be specified during build time. This tool takes as input the original Java application bytecode security specifications and the WB cryptographic keys and generates cloaked Java bytecode that is run in conjunction with the Java bytecode protection security module . The Java bytecode protection tool includes options for specifying how bytecode is launched e.g. via a Protected Application Bytecode Stub or a Protected Byetcode Class Loader as well as options for specifying security techniques for the deployed secured Java bytecode. The cloaked bytecode of the Java application is distributed in two parts 1 protected Java application bytecode stub which is loaded into the target JVM environment and 2 protected data files and white box security module WB SM utility which will be loaded and accessed by the SM during run time separately. The inventive Java bytecode protection security module can be distributed with these two parts or independently up to application provisioning approaches. In general the security module is generic in the sense that it can be installed once and applied to the cloaked bytecode of any Java application.

A variety of methods for the inventive bytecode protection are enabled for use in conjunction with the instant Java bytecode protection system . Each such bytecode protection method address static and dynamic attacks to Java application in bytecode form.

One method of bytecode protection includes White box cryptographic or WB cryptographic which is a unique cryptographic technology that protects cryptographic algorithms so that their operations can execute within a hostile environment without leaking a cryptographic key and other cryptographic values. In other words the WB cryptographic method can be executed against direct attacks. The present invention incorporates two kinds of WB cryptographic technology including the external WB cryptographic library and the internal WB cryptographic facility.

The external WB cryptographic library is implemented in C and protected with tampering resistance property by a hidden cryptographic key and other cryptographic information so that WB cryptographic operation can be used by protected Java applications and performed without releasing any valuable information including the key. The inventive internal WB cryptographic facility is a functional component of the build time protection tool that accepts cryptographic information and keys and generates WB key data and utilities for the inventive protection tool and security module to use to encrypt and decrypt different forms of java application bytecodes and relevant information.

Another inventive method of bytecode protection includes Bytecode Integrity Verification BIV . Protection via BIV can detect and mitigate static and dynamic tampering attacks to Java class or method code while loading a class or running Java methods. At build time the inventive method calculates static hash values of JAR files class and method bytecodes from the original application archive file. During loading and run time the inventive method calculates dynamic hash values by addressing class and method bytecode loaded with the JVM and makes the integrity verification by checking the dynamic hash values against the static ones.

Another inventive method of bytecode protection includes Anti Debug AD which is shown and described later in regard to . AD is one of the dynamic security handlers as shown in . AD protection can prevent and detect dynamic attacks by using debuggers during run time. AD consists of techniques that detect attacks by monitoring the internal and external state of the system environment at startup and during runtime. Appropriate countermeasures are invoked once the anti debug attacks are detected.

Another inventive method of bytecode protection is Secure Loading Bytecode SLB . This SLB protection method prevents and detects static reverse engineering and tampering attacks to archive file and Java class code before loading into the JVM . At build time the SLB protection method encrypts JAR files and selected class bytecodes from the original application archive file and introduces an application stub class. When a JVM loads the protected application the JVM first loads the application stub class and then triggers loading of the protected application. An SLB dynamic security handler described further herein below is a functional component of the inventive Java bytecode protection security module that is connected with the JVM via JNI during run time execution. The SLB dynamic security handler manages and controls loading a protected Java application bytecode into the work space in the JVM .

Another inventive method of bytecode protection is Dynamic Bytecode Decryption DBD . The DBD protection method prevents and mitigates dynamic attacks to Java class or method code during run time.

Another set of inventive methods of bytecode protection includes both transfer execution and partial execution. Both of these protection methods move part of original execution into the security module and make sure that only part of execution can be exposed within the JVM so as to prevent and mitigate dynamic code lifting attacks during run time. For example certain Java bytecode can be converted into C code J2C that can be protected and executed within the security module .

Another inventive method of bytecode protection includes bytecode transformation. This kind of protection can be achieved by techniques including data flow transformations and control flow transformations. Bytecode transformation can transform original bytecode into different code structure while still preserving the original functionality. The transformed bytecode becomes much harder to be reverse engineered and tamper resistant.

Referring to the Java bytecode protection tool applies different protection techniques to original application bytecode. The Java bytecode protection tool thus generates protected bytecode and relevant data and utilities that work with the Java bytecode security module during run time to implement those designated protection techniques to Java bytecode. The Java bytecode protection tool accepts the three inputs of cryptographic info and keys original JAR files and configuration options via the user interface and performs the three kinds of operations.

The first basic operation includes generation of WB key data and utilities. Using cryptographic info and keys the WB static handler generates WB encryption key data that are used by different static security handlers each described in more detail herein below and the tool itself. Also the build time process of the protection tool generates WB decryption key data that is stored as part of run time data in a data protection folder . A WB Security Module SM utility is provided to perform WB decryption operations invoked by the dynamic security handlers during run time by using the WB decryption key data.

The second basic operation includes application of protection techniques. According to configuration options the Java bytecode protection tool applies different static security handlers to modify application bytecode from the original form to protected forms. In doing so this operation generates protected Java application bytecode stub and relevant protection data files that contain protected application bytecode in various protection forms and important run time data.

The third basic operation includes packaging a deployable form of the protected Java bytecode. At the end of the process the Java bytecode protection tool will structure and pack all output files properly so that the Java application bytecode stub can be loaded by the JVM . This Java application bytecode stub is an entry point to launching the cloaked Java application and may take various forms including a class file that can be launched by an external program a class file that is launched by another Java class or a Java class loader. The Java bytecode protection tool will also structure and pack all output files properly so that the WB SM utility can be invoked by functional components of the Java bytecode security module. Still further the Java bytecode protection tool will also structure and pack all output files properly so that all protection data files can be accessed by certain functional components of the Java bytecode security module .

The Java bytecode protection tool includes a user interface for interfacing with a user in order to accept user commands and major inputs. The commands and inputs may include cryptographic info and keys including cryptographic algorithm selection and original key materials original application bytecode archive file which includes unprotected bytecode to be protected and configuration options which include user options to conduct the Java bytecode protection tool on what and how to protect the application bytecode e.g. a user can specify particular Java classes and methods whether to be protected or not.

The Java bytecode protection tool also includes a protection manager . The protection manager is provided to interpret configuration options and coordinate different protection techniques in a dependent order so as to interlock them such that the resulting overall protection is much stronger than each individual protection. Also the manager contains utilities commonly used by other functional components of the Java bytecode protection tool .

The Java bytecode protection tool also includes static security handlers . Each individual static handler is invoked by the protection manager to perform a respective predetermined protection technique. In the illustrated embodiment a WB static handler a BIV static handler an AD static handler a SLB static handler a DBD static handler a transfer execution static handler a partial execution static handler and a code transformation tool are shown. Each such static security handler is described in detail in later sections herein below. The protection manager and static security handlers are designed such that they work together to provide a plug in mechanism to add and extend security capability and new protection by easily integrating further new security handlers with the protection tool.

The Java bytecode protection tool also includes WB encryption key data generated by the WB static security handler . The WB encryption key data is used by the manager and static security handlers to encrypt certain forms of bytecode and protection data.

The Java bytecode protection tool also includes a WB SM utility generated by the WB static security handler . The WB SM utility is used by dynamic security handlers described further herein below within the security module .

The Java bytecode protection tool also includes a protected Java application bytecode stub . The stub only contains a boot strap of the protected Java application for the JVM to load first and then trigger a secure bytecode loader function to load real protected bytecode from protection data files.

The Java bytecode protection tool also includes a protected J2C library generated by the tool. The protected J2C library contains various protected code in C that have been converted from Java bytecode. This library is dynamically linked and invoked by the Java bytecode security module.

The Java bytecode protection tool also includes protected bytecode data . This protected bytecode data is one kind of protection data file generated by the tool and contains various protected bytecode.

The Java bytecode protection tool also includes run time data . This run time data contains various kinds of security related information such as but not limited to WB decryption key data integrity verification static hash values protected class and method information and tables.

It should also be understood that the Java bytecode protection tool exhibits downloadability. As such all outputs including the protected java application bytecode stub protected J2C library protected bytecode data and run time data from this protection tool are downloadable during run time.

In there is illustrated an overview of the run time process to protect Java application bytecodes in accordance with the present invention in terms of the Java bytecode protection security module shown in . As previously mentioned the Java bytecode protection security module is developed in the C programming language and itself protected by tamper resistance techniques such as those provided by Cloakware Inc. of Ottawa Ontario Canada so as to be robust and tamper resistant. It should be understood that the programming engines underlying the Java bytecode protection tool and security module may be engines developed in other programming languages. In fact the security module underlying this invention can be developed in other programming languages so long as such languages are capable of interfacing with the Java Virtual Machine.

Upon initiating run time the JVM loads the protected Java application bytecode stub as it would in loading any normal Java application. This triggers the Java application bytecode stub to bootstrap trusted and protected Java application bytecode by interacting with the security module via the JNI . During the run time the security module serves to manage and control data flow so as to secure and protect the Java application bytecode and the execution thereby preventing dynamic attacks to the bytecode and the execution.

With further regard to the major functional components and data files will now be described. Data and flow control to and from the security module is via the Java application bytecode work space . The work space is a virtual work space for the Java application within the JVM . At different states of run time which include loading and executing the application the actual application bytecode residing in the JVM is managed differently. Each state of the work space contains legitimate and fully functional application bytecodes but not complete application bytecodes. Optionally certain portions of these bytecodes may always be kept in their protected forms depending on build time configuration settings e.g. enabling transfer execution with Java and C execution options. When the portion of bytecodes is required to be executed the security module will load and restore them within the work space into the JVM just in time and then remove them after the execution. Also certain original method bytecodes have been translated into C functions which are not directly visible from the JVM and can only be invoked by the security module . In this approach an attacker is only able to see pieces of the original application bytecodes at any given moment during run time which makes is extremely difficult to reverse engineer an entire application bytecode.

The security module SM also includes a bridge mechanism referred to in as the JNI SM bridge . The JNI SM bridge is an interaction component that makes connection and co function possible via the JNI between the JVM and the security module . Sub components of the JNI SM bridge include the JNI to provide the sole mechanism of interactions between the JVM and native code. Also included in the sub components is a down call stub and up call stub . These stubs provide the application programming interface to redirect down calls from the Java application bytecode work space of the JVM to the dynamic security handlers via the security module in native programming code and redirect up calls from the security module to the JVM . The third sub component shown is the SM manager . The SM manager is a controller and coordinator for the security module . It not only manages and maintains various designated protections to the Java application bytecode but also to the security module itself. It also contains utilities commonly used by other functional components of the security module .

The security module also includes a plurality of dynamic security handlers . Each individual dynamic security handler is invoked to perform a unique protection technique. As shown the dynamic security handlers according to certain embodiments can include a WB dynamic security handler a Bytecode Integrity Verification dynamic security handler an anti debugging dynamic security handler an SLB dynamic security handler a DBD dynamic security handler a transfer execution dynamic security handler a partial execution dynamic security handler and a code transformation . The details of the dynamic security handlers are described later herein below.

Coordinating with the build time Java bytecode protection tool the SM manager and dynamic security handlers are also designed such that they work together to provide a plug in mechanism to add and extend security capability and new protection by easily integrating additional new dynamic security handler with the security module.

In one embodiment of the inventive method for external anti debug monitoring is illustrated. Here Java Platform Debug Architecture JPDA facilitates the capability of debugging the Java application. The inventive method focuses on detecting debug enabling and its subsequent debugging activities based on the JPDA. A multilayer defense strategy is used to maximize the chance of capturing the debugging activities both statically and dynamically within a running JVM process as shown. The three agents illustrated in the AD method shown in can be configurable to allow normal or legal debugging activity to be performed. The three agents include a Kernel Monitor Agent KMA a Debugger Attachment Monitor Agent DAMA and a Debugging Procedure Monitor Agent DPMA .

In regard to the KMA accessing kernel space it is required that the JVM process load a debugging library into its memory space before any debugging function can be performed. The KMA is spawned when the Java application starts. The KMA periodically checks its own process map from the Kernel to determine if libraries related to JDPA are loaded into its memory space. The appropriate related action is taken should these libraries be found.

In regard to the DAMA this agent serves the second line of defense. DAMA is facilitated with Java Virtual Machine Tool Interface JVMTI capabilities and is loaded when JVM starts . A call back function is provided to constantly monitor thread start screens for every thread created during the runtime. Activities of any attached JDPA debugger in the Java application can be captured whenever the JVM loads certain threads deemed to be essential to perform debugging. In this regard AMA enables the thread start listener detects a new thread start and detects a JDPA related thread .

In regard to the DPMA this agent is provided as a third line of defense. The DPMA also operates under the JVMTI environment. A call back function monitoring the debugging procedure e.g. hitting a break point line will be triggered whenever such action is taken. Detailed messages such as the thread and its location of the breaking point can be collected. In this regard the DMPA enables a line break listener detects debugging activities and report any thread and method information . Each of the KMA DAMA and DPMA can trigger an action and disable JVM .

The aforementioned static and dynamic security handlers will now be described in further detail. The WB security handler includes an external WB cryptographic library as shown in and an internal WB cryptographic facility as shown in .

The external WB cryptographic library in provided by the WB dynamic security handler provides a library that is used by the Java application for WB encryption and decryption functions via the JNI security module interface . The WB static handler accepts cryptographic information and original keys from a user and generates WB key data that can be distributed and rolled as needed which the cryptographic library can then use for secure cryptographic operations.

The internal WB cryptographic facility contains a WB static handler and a number of static and dynamic components are illustrated in . The WB static handler accepts cryptographic information and original keys from a user and generates WB encryption key data which other static security handlers then use for encryption operations to different forms of application bytecodes as part of different protection techniques. The WB static handler also generates WB decryption key data and provides a WB security module utility that are each used by dynamic security handlers to perform decryption operations while the security module performs dynamic protections.

The Java bytecode protection tool also includes a pre processing method as shown in . This pre process tool accepts the original Java application bytecode archive files and translates them into an Internal Representation IR of the original application bytecode. Particular classes and methods are then marked for protection and their manner of protection according to user options . Protection mark information is thereby generated. Both the original application bytecode in IR form and protection mark information are used by each static security handlers for desired protections.

Within each static security handler of the Java protection tool there is provided Bytecode Integrity Verification BIV . illustrates the work flow of the BIV static security handler . As well illustrates the work flow of the BIV dynamic security handler . Here BIV provides unique tamper resistance protection by introducing a dynamic integrity verification capability to Java bytecodes during run time. In general at build time a tool is used to sign classes and methods that require BIV protection where the BIV data is generated and then protected and BIV actions build into the Java bytecode. At run time BIV actions are triggered via the Java bytecode protection security module for BIV protected classes and methods where dynamic secure hash values are just in time calculated for their respective bytecode. Both static and dynamic secure hash values are represented in a secure form and feed into the Tamper Resistance Gate Keeper TRGK with success and or failure call back functions. The TRGK determines whether a BIV check is successful or failed without explicitly comparing the static and dynamic secure hash values. This can be accomplished via an appropriate algorithm in the form of a specifically designed mathematic computation. If the static and dynamic secure hash values are the same this generally indicates that the BIV check passes and a success call back function can be invoked. Otherwise if the static and dynamic secure hash values are not the same this indicates that tampering of a particular class or method is detected and the BIV check is failed. Thus a failure call back function can be invoked. Those call back functions are user defined countermeasures to detected tampering attacks.

In the present invention the process of computing dynamic secure hash values of Java bytecode differs from typical processing of computations on normal native binary code in which the computation merely needs to pick native code directly from the memory allocated for the executable. Normally application code cannot get a code segment directly from the memory at Java run time. Instead application code obtains a class or method bytecode through the JVM mechanism. In this invention the security module leverages this ability and the JNI interface by using an up call to the JVM to retrieve bytecodes and then computing the secure dynamic hash values and performing an integrity verification check of the retrieved bytecode against the pre registered hash value.

With regard to the bytecode integrity verification static security handler is seen to include bytecode signing. One of the major functions of the BIV static security handler is to walk through application bytecodes and check each of the classes and methods using protection mark information to determine which class or method needs the BIV protection. If a class or method requires the BIV protection a specific hash value is computed by applying a secure hash calculation to the particular class or method bytecode . In general a secure hash calculation algorithm as known in the computing art is commonly used. These resultant hash values are stored as BIV data in an organized and structured way so that they can be used effectively during run time.

The BIV data of the bytecode integrity verification static security handler is a data container that contains data of class and method static hash values and other information such as WB BIV decryption key data. Such data is used at run time by the dynamic BIV security handler. In order to be used more effectively BIV data is structured with corresponding information on each of the classes and methods to be protected and their static hash values.

The bytecode integrity verification static security handler also serves to transform and encrypt BIV data . The integrity of the BIV data is very important to maintain. BIV data can be transferred or download via networks. Accordingly the present invention applies transformation and encryption to them as part of packing them for use. Without such protection any tampering of the BIV data can be a step to break BIV protection. During packaging time the BIV static security handler performs double protections to the BIV data so as to prevent static attacks to sensitive BIV data. First the BIV static security handler performs the data transformation to the static hash values so that these values can be operated in transformed form at run time by the dynamic BIV security handler . This serves to ensure that the real plain values are never exposed. Secondly the BIV static security handler then performs encryption of these transformed values so as to prevent any tampering occurring to these transformed values before being dynamically used.

It should be understood that the BIV data is one kind of run time data that are used at run time by the dynamic security handlers . Run time data can be organized and stored into a single file or multiple files according to user options. There are some advantages to the form of multiple run time data files such as that the data information can be updated and downloaded in a more fine grain. For example BIV data can be structured for each of the Java classes to be protected. In this manner BIV protection can be performed more feasibly on each class base.

The bytecode integrity verification static security handler also provides unique BIV triggering. Two approaches to trigger BIV at run time are provided via an external BIV API and an internal BIV trigger. As a first approach that is part of the designated system under this invention a set of external BIV APIs are provided for users to use them in proper places within their Java code where a user has a clear idea to perform a BIV check. The user can indicate which Java class or method needs a BIV check. The user will have full control of mitigating actions by using call back functions. The other approach is an alternative to triggering by a user invoking external APIs. Instead BIV triggers can be pre built within certain functions of the Java bytecode protection security module. Each time the Java application invokes those functions the internal BIV actions can be triggered in a pre arranged fashion. Certain mitigating actions are pre defined and taken by the security module internally. However a user will still have partial control on the mitigating actions. This is enabled by providing a pre setting API for a user to pre set mitigating actions taken by the security module so that it will act accordingly to the setting. In general users have full control on whether and where to use the external BIV API and have indirect control on whether to use the internal BIV triggers at build time. Users do not have any control where to trigger the internal BIV as that is hidden and controlled by the security module.

With regard to the bytecode integrity verification dynamic security handler is seen to include BIV initialization. BIV initialization is provided to load secure static BIV data and decrypt them using the WB BIV decryption key data and thereafter load them into the memory in secure form. BIV initialization can be implemented in two ways as part of security module initialization or on demand during dynamic BIV. In regard to the first way this can be done once as part of SM initialization when loading the protected Java application. In regard to the second way this can be accomplished by loading what is needed on demand during dynamic BIV. This can be done when the BIV is required for a class. BIV data files can be organized at the class level. For a particular class BIV data is loaded and decrypted for this class only. This second approach can provide more flexibility to users to leverage small changes required to BIV data if the class bytecode changes.

The bytecode integrity verification dynamic security handler also performs dynamic BIV . As discussed above the dynamic BIV of a class or method can be launched by either external BIV API calls or other functional calls from the protected Java application to the security module that contains a pre arranged internal BIV trigger. Performing dynamic BIV includes at least the following key actions getting the latest bytecode computing the dynamic secure hash value and providing a tamper resistance gate keeper TRGK .

Getting the latest Bytecode occurs via an up call. In order to calculate the secure dynamic hash value securely for a class or method within the security module the latest bytecode of a class or method has to be obtained via an up call to the JVM via the JNI. The same bytecode itself should be interpreted or compiled into binary while executing this class or method loaded to the JVM . If there are not any tampering attacks to the bytecode the bytecode should be the same bytecode to which the static secure hash value has been calculated.

The action of dynamic secure hash value computation involves classic known hashing computation but the resultant value is in protected form and will be used in protected form.

Providing the TRGK involves two inputs. The TRGK uses both static and dynamic secure hash values SSHV DSHV for a particular class or method to verify whether the integrity of the bytecode of the class or method is compromised. If any tampering happens to the bytecode its DSHV cannot be the same as its SSHV . The TRGK can detect any tampering to the bytecode. If the BIV verification passes TRGK will trigger a success call back function or to return to the original BIV trigger otherwise the TRGK will trigger a failure call back function as the user s mitigating action.

The bytecode integrity verification dynamic security handler also includes a termination step in the form of the BIV close. The BIV close as part of the security module performs cleaning up of the memory space and the other information used by BIV dynamic secure handler.

With regard to the Secure Loading Bytecode SLB static security handler is shown. The SLB static security handler receives the internal representation of the original Java application bytecode along with the WB encryption and decryption key data and the protection marking information .

An important output of the SLB static security handler is the application stub . The application stub contains a bootstrapping class to launch a loading process via the security module during run time. The application stub is loaded by the JVM. The application stub contains each external public API necessary to enable the application to be launched independently or via another Java application. The application stub contains methods that invoke down call functions to the security module which in turn will decrypt and load the Java application into the JVM for execution.

To prepare the application stub the SLB static security handler includes an application bytecode work frame and an encrypted application bytecode work frame . The application bytecode work frame is different from the original application bytecode . In general a class within the application bytecode work frame does not require protecting so it will be the same as the original one. If a class needs to load securely a class stub replaces the original class bytecode and thus the class bytecode is the original bytecode. The encrypted frame is obtained by encrypting the application bytecode work frame using the application WB encryption key data via the static security handler during build time and is decrypted using application WB decryption key data via the dynamic security handler during run time.

In addition to the application stub the application payload is generated. The application payload contains the encrypted application work frame and the application WB decryption key data . The application WB decryption key data in the protected application payload is the key data generated by the WB static security handler and passed to the SLB static security handler as part of the WB decryption key data . At run time it is used to decrypt the encrypted application bytecode work frame .

As shown in the underlying code may be formed as class bytecode class stubs or encrypted class bytecode . Class bytecode is original bytecode. The class stub contains a bootstrapping method to launch a trusted class loading process via the security module during run time to load the encrypted class bytecode when necessary. During the packaging time the class bytecode is analyzed. Marked methods are replaced by methods that invoke down call methods to the security module where the security module invokes the original bytecode functionality via a security handler method designated at packaging time. The encrypted class bytecode is obtained by encrypting class bytecode using the class WB encryption key data via the static security handler during build time and is decrypted using the class WB decryption key data via the dynamic security handler during run time.

An encrypted class bytecode frame is also generated by the SLB static security handler . It contains encrypted class bytecode and class WB decryption keys for one or more classes. Users have the option to control how many classes a frame can contain within their encrypted class bytecode . The user has the option to load them together or separately during run time. Class WB decryption key data is generated by the WB static security handler and passes to the SLB static security handler as part of the WB decryption key data . At run time the class WB decryption key data is used to decrypt the encrypted class bytecode . The user has the option whether generate one or multiple class WB encryption and decryption keys.

In regard to the work flow of an SLB dynamic security handler is shown. The SLB dynamic security handler is a functional component of the security module that is connected with the JVM via JNI during bytecode execution. The SLB dynamic security handler manages and controls loading of a protected Java application bytecode into the work space in the JVM . Advantageously this capability can ensure that an original Java application bytecode is protected and likewise distributed in a protected form so as to prevent any static attacks to the application bytecode occurring before loading the application bytecode to the JVM . The SLB D handler contains two main functional components including secure application loading and secure class loading.

Secure application loading involves the protected application stub which is located in the class path and loaded normally by a JVM . A main bootstrapping method is executed after the loading and then an application bootstrapping method is invoked through a down call API via the JNI SM bridge . This triggers the following application loading actions of the SLB dynamic security handler . First the protected application payload is loaded from the protection data folder. This includes loading the encrypted application bytecode work frame from the payload into memory buffer and then decrypting the encrypted application bytecode work frame just in memory by using the application WB decryption key data . Next the decrypted application bytecode work frame is walked through to load each class bytecode and class stubs from the work frame into the application work space by using a special SM class loader . The SM class loader utilizes the security module to load encrypted bytecode and decrypt and load the bytecode into the JVM . Additional security checks may be incorporated to add BIV protection to the SM class loader and also checks on class loader hierarchy and integrity during load and run time. Finally execution is passed to the main method of the main application class within the work space.

Secure class loading involves the triggering of a class bootstrapping method as illustrated in . In general an encrypted class bytecode frame can be pre installed or downloaded on the device before executing the protected application or downloaded on the device during its execution. This depends on the functional nature of the application. When classes with class stubs are required during the execution of the protected application a class bootstrapping method is triggered and the following steps are executed via the JNI SM bridge to load the required class from the encrypted class bytecode frame. First the corresponding encrypted class bytecode frame is loaded into the memory buffer. Next each of the encrypted classes contained in the frame just in memory is decrypted by using each of the specific class WB decryption key data. The decrypted class bytecode is then loaded into the application work space by using the SM class loader. Thereafter execution of the application continues the within the work space

It should be noted that unlike running a native application where all code must be loaded first the JVM allows for loading a new class on the fly. This extends applications dynamically by loading classes only when they are needed. Moreover this characteristic of Java provides a good opportunity to use the SLB secure class loading against code lifting attacks. Further after a protected class is SLB securely loaded and executed the present invention can provide options to maintain the class in a protection state by restoring back to its class stub. In such a way only at just execution time is the original bytecode of the class available within the JVM image while it remains within protected form for other times.

In general Dynamic Bytecode Decryption DBD involves decryption of protected method bytecodes only when the encrypted method is invoked by a running Java program. This ensures that all of an application s unencrypted bytecode is never resident in memory at one time.

In regard to the build time workflow of a DBD static security handler is shown. During build time each unprotected class bytecode file is loaded into an internal buffer and a new class bytecode work frame is constructed for a class to be protected by DBD using the protection marking information where marked methods are replaced with a method stub that will invoke down call methods to trigger the invocation of DBD dynamic security handler at run time. For each Java method to be protected its bytecode is encrypted by using method WB encryption keys and storing the encrypted method into the encrypted method bytecode frame that is packaged along with the WB decryption key data for distribution as part of protected bytecode data. The original bytecode class is replaced by the protected class bytecode work frame for distribution.

In if needed once the original bytecode is restored to the JVM the DBD dynamic security handler may copy the class state to the real bytecode instance this option is determined at build time. The DBD dynamic security handler then invokes the unencrypted method in the JVM . Once the method invocation is complete the security handler then restores the real state from the unencrypted class instance to the encrypted instance and the control is returned to the originating down call method. shows the sample method invocation and state copy operations prior to calling the unencrypted method. Once the unencrypted method has completed execution the state is copied back to the class instance with the protected method stubs by the DBD dynamic security handler . The control is returned to the protected method whilst the security handler removes the unencrypted class and instance from the JVM .

The above described embodiments of the present invention are intended to be examples only. Alterations modifications and variations may be effected to the particular embodiments by those of skill in the art without departing from the scope of the invention which is defined solely by the claims appended hereto.

