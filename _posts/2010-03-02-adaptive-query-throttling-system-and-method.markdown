---

title: Adaptive query throttling system and method
abstract: An adaptive query throttling system and method are provided herein.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08321447&OS=08321447&RS=08321447
owner: Winshuttle, LLC
number: 08321447
owner_city: Bothell
owner_country: US
publication_date: 20100302
---
This application claims the benefit of priority to U.S. Provisional Application No. 61 156 639 filed Mar. 2 2009 titled ADAPTIVE QUERY THROTTLING naming inventors Vikram Chalana Vishal Chalana and Gurpreet Singh Sidhu. The above cited application is incorporated herein by reference in its entirety for all purposes.

The present invention relates to databases and more particularly for a method of adaptively throttling database queries.

Enterprise resource planning ERP systems are designed to coordinate some or all of the resources information and activities needed to complete business processes. An ERP system may support business functions including some or all of manufacturing supply chain management financials projects human resources customer relationship management and the like. In addition an ERP system may facilitate and or record data relating to live transactions so in many cases a business may require that its ERP system continuously perform well enough that live transactions can be processed in a timely fashion.

Many ERP systems incorporate a centralized database or other ERP data store and many ERP vendors provide one or more reporting tools that can be used to access the ERP data store. However it can be difficult and expensive to use vendor provided reporting tools. Consequently many businesses must maintain an expensive information technology IT to facilitate custom report creation. In many cases creating a custom report may cost thousands of dollars to an enterprise running an ERP system.

In addition generating reports directly from an ERP data store can compromise performance and security of the ERP data store. For example generating a report may involve running a complex inefficient and or badly formed query against the ERP data store which could at least temporarily hinder the ERP data store s ability to facilitate live transactions. In part to prevent report generation from hindering transaction performance many businesses generate reports using data from a data warehouse which may be updated from the ERP data store periodically e.g. once a day often overnight or during other times when the ERP data store is relatively not busy . However data in such a data warehouse may not always reflect the most recent transactions. Moreover maintaining a discrete data warehouse may be expensive.

The detailed description that follows is represented largely in terms of processes and symbolic representations of operations by conventional computer components including a processor memory storage devices for the processor connected display devices and input devices. Furthermore these processes and operations may utilize conventional computer components in a heterogeneous distributed computing environment including remote file Servers computer Servers and memory storage devices. Each of these conventional distributed computing components is accessible by the processor via a communication network.

Reference is now made in detail to the description of the embodiments as illustrated in the drawings. While embodiments are described in connection with the drawings and related descriptions there is no intent to limit the scope to the embodiments disclosed herein. On the contrary the intent is to cover all alternatives modifications and equivalents. In alternate embodiments additional devices or combinations of illustrated devices may be added to or combined without limiting the scope to the embodiments disclosed herein.

Database users may wish to build reports that query data from a live ERP data store and or other live database without the query impairing performance and or security of the live ERP data store and or other live database.

In various embodiments Throttling Server s may provide a front end user interface and or data query routines by which a client may obtain data from DB Server s . In some embodiments client may also access data from DB Server s directly. In other embodiments some or all of client Throttling Server s and DB Server s may all be incorporated into a single device.

In various embodiments network may include the Internet a local area network LAN a wide area network WAN and or other data network. In some embodiments Throttling Server s and DB Server s may be the same device. In other embodiments Throttling Server s and DB Server s may communicate with one another via a channel other than network . For example Throttling Server s and DB Server s may be connected via a storage area network SAN a high speed serial bus and or via other suitable communication technology. In many embodiments there may be multiple client devices .

The Throttling Server s also includes a processing unit a memory and an optional display all interconnected along with the network interface via a bus . The memory generally comprises a random access memory RAM a read only memory ROM and a permanent mass storage device such as a disk drive. The memory stores program code for adaptive query subroutine . In addition the memory also stores an operating system . These software components may be loaded from a computer readable storage medium into memory of the Throttling Server s using a drive mechanism not shown associated with a computer readable storage medium such as a floppy disc tape DVD CD ROM drive memory card or the like. In some embodiments software components may also be loaded via the network interface rather than via a computer readable storage medium .

Throttling Server s also communicates via bus with a database component such as DB Server s . Throttling Server s may communicate with the database component via the network interface a storage area network SAN a high speed serial bus and or via other suitable communication technology.

Although an exemplary Throttling Server s has been described that generally conforms to conventional general purpose computing devices an Throttling Server s may be any of a great number of devices capable of communicating with the network and or DB Server s for example a personal computer a game console a set top box a handheld computer a cell phone or any other device that is capable of accessing a database and or other data store.

Adaptive query routine obtains a compound database query in block . In many embodiments the query may be written in a query language such as Structured Query Language SQL and or an SQL variant or extension. In other embodiments query may comprise a statement in an alternate query language such as Common Query Language Datalog Entity Relationship Role Oriented Language ERROL XQuery XPath XSQL and the like.

In various embodiments the query may comprise a SELECT query. As used herein the term SELECT query refers to a query language statement that specifies a result set of records from one or more tables. In many query languages including SQL a SELECT query may be written using the statement SELECT. Other query languages may use other commands or keywords to describe a SELECT query i.e. a statement that specifies a result set of records from one or more tables . In various query languages a SELECT statement may include various clauses to specify which rows to retrieve e.g. a WHERE clause how to group rows how to order results how to join records from multiple tables e.g. a JOIN clause and other similar clauses.

For the sake of clarity and simplicity in the remainder of this document query language concepts will be discussed using SQL like syntax and keywords. However the disclosures are equally applicable to any query language and various embodiments may use alternate syntaxes and or query languages as appropriate.

In some embodiments Throttling Server s may provide a user interface to facilitate creation of the query. In other embodiments a user may write a query and submit it to Throttling Server s . In still other embodiments the query may be obtained by any other suitable method. In various embodiments individual users of an ERP system or other database system may create queries to generate custom reports that may incorporate up to date live transactional data without significantly impeding the database s performance for other users and other operations. In some embodiments such functionality may reduce the need for a business to maintain an IT infrastructure dedicated to creating custom reports.

In many embodiments Throttling Server s may provide additional functionality. For example in one embodiment Throttling Server s may also enforce user access controls permissions granular subschemas and or other data security measures including in some embodiments authenticating and or authorizing a user via password or other credential. For example in one embodiment a database may contain a comprehensive set of employee data but Throttling Server s may enforce access controls such that one group of users may be authorized to view only one subset of data e.g. payroll data while others are allowed access to only a second subset of data e.g. work history and or medical data .

Adaptive query routine submits the query to query throttling subroutine as illustrated in and discussed below. Once a set of results has been obtained from query throttling subroutine adaptive query routine determines in block whether to communicate the result set to client in chunks. In some embodiments if the size of the result set exceeds a threshold and or if the time to communicate the result set to client exceeds a threshold adaptive query routine may in block chunk the result set into a number of partial result sets. From beginning block to ending block adaptive query routine may iteratively communicate each partial result set to client in block .

If in decision block adaptive query routine determines not to communicate the result set in chunks then in block adaptive query routine communicates the result set to client . Adaptive query routine ends at block .

In block the compound query is sequenced into one or more component SELECT queries. This sequencing is related to but distinct from a process commonly referred to as query optimization. Many query languages including SQL are non procedural meaning that the compound query specifies a result set but does not specify how to calculate it. In many database systems a query optimizer translates a non procedural query into a query plan or a specific set of steps used to access or modify information in a database. In various embodiments query throttling subroutine may borrow various query optimization methods and or techniques the borrowed methods and or techniques being utilized to sequence the compound query into one or more component SELECT queries. 

As used herein the term component SELECT queries refers to a plurality of SELECT queries that when performed in at least one determined order obtain a plurality of interim result sets from which the result set specified in the compound query the compound query result set can be assembled.

In many embodiments component SELECT queries whether atomic or otherwise are determined and sequenced according to various factors including tables existing inside and outside of WHERE clauses tables paired with JOINS output display fields fields used in JOINS and the like. discussed below illustrates an exemplary chain of component SELECT query prioritization rules that may in some embodiments be used at least in part to determine an order for component SELECT queries.

In some embodiments a component SELECT query may be an atomic query. As used herein the term atomic query refers to a SELECT statement having a result set consisting of a single field from a single table selected according to a single criterion. In other embodiments a component SELECT query may be more complex than an atomic query but in most embodiments a component SELECT query describes a result set including rows from only a single table. In many embodiments a component SELECT query may be simple enough that its execution causes only minimal performance degradation even on a live transactional database.

In most embodiments sequencing a compound query into a plurality of component SELECT queries does not replace the query optimization process that ordinarily takes place when a non procedural query is executed. Similarly the sequenced ordered plurality of component SELECT queries does not constitute a query plan as that term is ordinarily understood by those skilled in the art. On the contrary the process of sequencing a compound query into a plurality of component SELECT queries may often be viewed as a pre processing operation prior to query optimization. Indeed in many embodiments the database may further optimize and or form a query plan for each individual component SELECT query before performing the component SELECT query.

In accordance with various embodiments once a sequence of component SELECT queries is determined the compound query result set may not be obtained all at once. Such an approach is likely to excessively load the database as the sequence of component SELECT queries if executed as a group may still be so resource intensive that its execution is likely to hinder other time sensitive operations the database may need to perform during that time.

To obtain the results described in the compound query without excessively degrading the transactional performance of the database query throttling subroutine periodically polls DB Server s to monitor one or more database load metrics and then serially performs each individual component SELECT query one at a time generally at full speed but only when the database has sufficient resources available. Put another way in accordance with various embodiments the result set specified by the compound query is obtained in components which trickle in as resources become available at the database. Thus obtaining the compound query result set is adaptively throttled such that reporting queries may often be performed on a live dataset without compromising the database s time sensitive transactional operations if any .

In various embodiments this adaptive throttling takes place between beginning loop block and ending loop block . In this loop query throttling subroutine iterates over each component SELECT query. In block query throttling subroutine polls DB Server s to determine a current database load metric. In decision block query throttling subroutine determines whether the current database load metric satisfies a predetermined availability condition. If the availability condition is not satisfied query throttling subroutine dynamically determines an adaptive wait period in block and waits for the determined period in block before again polling DB Server s in block .

In an exemplary embodiment the database load metric polled in block may relate to a count of processes that are currently utilized or available at the database. In other embodiments the database load metric may alternatively or additionally correspond to one or more other factors including processor and or memory utilization at the database a time of day and the like.

As illustrated in in one embodiment the database load metric may correspond to a percentage or other degree of availability or utilization at DB Server s . When availability exceeds about 50 or equivalently utilization is below about 50 the availability condition may be satisfied . When availability is between about 40 50 or utilization is between about 50 60 the adaptive wait period may be very brief less than 1 second . When availability is between about 30 40 or utilization is between about 60 70 the adaptive wait period may be about 1 second . When availability is between about 0 30 or utilization is between about 70 100 the adaptive wait period may be about 2 seconds . In other embodiments longer and or shorter wait periods may correspond to similar or different availability utilization ranges. In still other embodiments static non adaptive wait periods may be used e.g. wait N seconds whenever the availability condition is not satisfied .

In embodiments including enterprise resource planning ERP systems from SAP AG of Walldorf Germany the database load metric may correspond to the number of DIALOG processes utilized or available at DB Server s . For example in one embodiment the maximum number of DIALOG processes that can be utilized may be 100 or another number and the minimum number of DIALOG processes that can be utilized may be 0 or another number and adaptive wait periods may be determined according to a percentage of available utilized DIALOG processes as disclosed in .

Referring again to when the current database load metric is determined in block to satisfy the availability condition in block query throttling subroutine communicates the component SELECT query to the database to be executed. In many embodiments before executing the component SELECT query the database will further optimize the component SELECT query and or form a query plan according to the component SELECT query.

In various embodiments query throttling subroutine may communicate the component SELECT query to the database in various ways. For example in some embodiments query throttling subroutine may communicate with the database via a standard software application programming interface API such as Open Database Connectivity ODBC a language specific API such as Java Database Connectivity JDBC a DBMS specific API such as TransactSQL a vendor provided API and the like. In some embodiments a timeout parameter may be set so that the component SELECT query will terminate if its execution time exceeds the timeout parameter.

In block query throttling subroutine obtains the interim result set described by the component SELECT query. In block query throttling subroutine stores the interim result set in an interim memory. In block query throttling subroutine iterates back to block to wait if necessary and process the next component SELECT query. Once query throttling subroutine has iterated over all component SELECT queries in block query throttling subroutine assembles the interim result sets that were stored in iterations of block into the result set specified by the compound query. The assembled result set is returned at block .

According to prioritization rule queries having WHERE criteria have priority over queries that lack WHERE criteria. When queries cannot be prioritized according to rule then according to prioritization rule component SELECT queries are prioritized in descending order according to what percentage of their WHERE fields are indexed in the database. For example in database foo having indexed fields bar and baz and non indexed field bat query A SELECT from foo WHERE bar 1 has 100 indexed WHERE fields and query B SELECT from foo WHERE baz 2 AND bat 3 has 50 indexed WHERE fields therefore according to rule query A has higher priority than query B.

When queries cannot be prioritized according to rule then according to prioritization rule component SELECT queries are prioritized in descending order according to the number of JOIN fields included in the query. When queries cannot be prioritized according to rule then according to prioritization rule component SELECT queries are prioritized in ascending order according to what percentage of their JOIN fields are indexed in the database. When queries cannot be prioritized according to rule then according to prioritization rule component SELECT queries are prioritized in ascending order according to approximations of their tables sizes. When queries cannot be prioritized according to rule then according to prioritization rule component SELECT queries are prioritized in ascending order according to their table response times. When queries cannot be prioritized according to rule the queries have equivalent priorities. In other embodiments more fewer and or different prioritization rules may be used in the illustrated order or in a different order.

Although specific embodiments have been illustrated and described herein it will be appreciated by those of ordinary skill in the art that a whole variety of alternate and or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the embodiments discussed herein.

