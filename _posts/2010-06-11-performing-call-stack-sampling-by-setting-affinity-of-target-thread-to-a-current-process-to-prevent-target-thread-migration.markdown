---

title: Performing call stack sampling by setting affinity of target thread to a current process to prevent target thread migration
abstract: A sample is generated based on an event. Further, an interrupt handler captures information for an interrupted thread on a current processor. In addition, an affinity of the interrupted thread is set such that the interrupted thread runs only on the current processor without being able to migrate to a different processor. A sampler thread that runs on the current processor retrieves a call stack associated with the interrupted thread after the affinity of the interrupted thread has been set to the current processor. The affinity of the interrupted thread is restored after the call stack has been retrieved.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08843684&OS=08843684&RS=08843684
owner: International Business Machines Corporation
number: 08843684
owner_city: Armonk
owner_country: US
publication_date: 20100611
---
This disclosure generally relates to a computing environment. More particularly the disclosure relates to sampling technology.

Either time based or hardware event based sampling technology is typically utilized in application profiling tools to determine the specific usage of resources. A current approach is to sample by periodically generating interrupts. At each interrupt the current process thread the instruction being executed and optionally the data address being accessed may be identified and recorded. At a later time the collected data is aggregated and reports are generated showing sample distribution by address symbol process etc. A variety of tools are based on this technology. The full execution context of the sample is not typically recorded and not available in reports.

Attempts have been made to improve this technology by getting call stacks at the time of the sample. The existing set of tools may either attempt to walk the call stack directly or invoke functions on a separate sampler thread to obtain the interrupted thread s call stack.

In one aspect of the disclosure a computer program product is provided. The computer program product includes a computer useable medium having a computer readable program. The computer readable program when executed on a computer causes the computer to generate an interrupt based on an event. Further the computer readable program when executed on the computer causes the computer to capture information with an interrupt handler for an interrupted thread on a current processor. In addition the computer readable program when executed on the computer causes the computer to set an affinity of the interrupted thread such that the interrupted thread runs only on the current processor without being able to migrate to a different processor. The computer readable program when executed on the computer causes the computer to retrieve with a sampler thread that runs on the current processor a call stack associated with the interrupted thread after the processor affinity of the interrupted thread has been set to the current processor. Further the computer readable program when executed on the computer causes the computer to restore the affinity of the interrupted thread after the call stack has been retrieved.

In another aspect of the disclosure a process is provided. The process generates an interrupt based on an event. Further the process captures information with an interrupt handler for an interrupted thread on a current processor. In addition the process sets an affinity of the interrupted thread such that the interrupted thread runs only on the current processor without being able to migrate to a different processor. The process also retrieves with a sampler thread that runs on the current processor a call stack associated with the interrupted thread after the affinity of the interrupted thread has been set to the current processor. Further the process restores the affinity of the interrupted thread after the call stack has been retrieved.

In yet another aspect of the disclosure a system is provided. The system includes a current processor that generates an interrupt based on an event. Further the system includes an operating system that i captures information with an interrupt handler for an interrupted thread on a current processor and ii sets an affinity of the interrupted thread such that the interrupted thread runs only on the current processor without being able to migrate to a different processor. In addition the system includes a profiler that retrieves with a sampler thread that runs on the current processor a call stack associated with the interrupted thread after the affinity of the interrupted thread has been set to the current processor.

In another aspect of the disclosure a computer program product is provided. The computer program product includes a computer useable medium having a computer readable program. The computer readable program when executed on a computer causes the computer to generate with a current processor an interrupt based on an event. Further the computer readable program when executed on the computer causes the computer to capture information with an interrupt handler for an interrupted thread on a current processor. In addition the computer readable program when executed on the computer causes the computer to set an affinity of the interrupted thread such that the interrupted thread runs only on the current processor without being able to migrate to a different processor. The computer readable program when executed on the computer causes the computer to retrieve with a sampler thread that runs on the current processor a call stack associated with the interrupted thread after the affinity of the interrupted thread has been set to the current processor. Further the computer readable program when executed on the computer causes the computer to restore the affinity of the interrupted thread after the call stack has been retrieved.

The existing set of tools may either attempt to walk the call stack directly or invoke functions on a separate sampler thread to obtain the interrupted thread s call stack. Attempting to walk the call stack at the interrupt level is not ideal because applications may have stacks that have been paged out. As a result a user mode sampling thread may be employed to walk the call stacks when requested. On multiprocessor systems requesting that a separate thread gather the interrupted thread s call stack may allow the interrupted thread to migrate to a different processor and make forward progress i.e. continue execution while the call stack is being gathered. The gathered call stack will not reflect the state of the thread at the time it was interrupted.

According to an embodiment of the present invention a sampling configuration is provided that determines why a processor is being utilized in a particular manner. In one embodiment a call stack is gathered at each sample. As a result a determination may be made as to how functions were called in contrast with a profiler that is typically utilized to provide sample distribution reports of recorded addresses of instructions being executed during samples and is unable to make such a determination. Further a determination may be made as to what was the call stack that was utilized to invoke a particular function. Such a determination may help an analyst determine if a problem exists with how a particular function is being invoked what calling sequence is being utilized the most frequently and whether the calling sequence is necessary. In one embodiment a report may be generated to show the different ways in which a function was called.

In gathering calls stacks for interrupted threads there is a migration issue. That is while the call stacks are gathered the thread may have migrated to a different processor. It is possible to prevent thread migration by keeping all processors busy other than the one on which the call stack will be gathered. This could be accomplished by having sampler threads spin on those processors until the call stack is obtained for the thread of interest. However this severely affects overall application performance. Instead the thread of interest may be prevented from migrating to a different processor by setting its affinity to restrict it to only running on one processor. In this way the other processors do not have to be spun so that the other processors are free to continue running the application. Thus there is minimal application performance degradation. To reiterate thread migration is prevented by setting the processor affinity of the interrupted target thread to allow it to run only on the current processor.

After the call stack is retrieved the interrupted target thread s original affinity is restored. Setting a thread s affinity sometimes also known as binding causes the thread to run only on the specified processor s . Because the sampler thread runs at high priority and on the same processor on which the interrupted thread is intended to run the interrupted thread may not migrate to a different processor.

As samples are processed the kernel mode component handling the interrupt may be able to set the interrupted thread s affinity immediately within the interrupt handler. In one embodiment setting the affinity may occur outside the interrupt handler when interrupts are enabled. For example a second level interrupt handler SLIH or an interrupt back end may perform this action. While handling the samples e.g. interrupts the interrupted thread may not make forward progress until the SLIH or the interrupt back end has completed its processing which would include scheduling the sampling thread s for the interrupted process.

In an alternative embodiment all user mode sampler threads one for each processor may spin until the interrupted threads affinity is set. This method could be used if the operating system s support for binding or setting a thread s affinity is only supported from user mode. In another embodiment the target thread is suspended either in the interrupt handler or in an interrupt back end. Once the sampler thread gets control it will set the target thread s affinity and resume i.e. un suspend it. In yet another embodiment the profiler installs a global signal handler for the application being profiled. At interrupt time the interrupt handler signals the target thread using a predefined signal which causes the signal handler to run in the context of the target thread. The signal handler then sets the processor affinity of the target thread in which context it is executing to the current processor. Subsequently the signal handler signals the sampler thread on the current processor. The sampler runs after the signal handler signals the sampler thread.

Sampler threads are listening for commands to cause them to retrieve the call stack or a thread of interest which is performed by the profiler . A sampler thread is a profiler thread. Many sampler threads may be utilized as a plurality of processors may be utilized. Each sampler thread has an affinity to a single processor. Sampler threads may be very high priority threads so that they run immediately when signaled to do work such as retrieving a target thread s call stack. The target thread is the thread that has the call stack of interest to be obtained. Further a target processor is the processor on which the target thread was running and on which affinity is set so that the target thread remains on that processor for a duration.

Once a determination is made as a result of sampling a target thread s call stack is to be obtained. The target thread is prevented from making any forward progress during that time. In other words the target thread is kept where it is until the call stack is gathered. Afterward the target thread may resume.

In a multi processor environment an issue arises in gathering calls stacks. That is since call stacks are gathered by profiler sampler threads the target thread could potentially be running on another available processor i.e. a different processor than the target processor. By the time the sampler thread gathers the call stack the target thread may no longer be at the point where it was sampled and the call stack would not accurately reflect where the target thread was at the time of the sample. It would be possible to address this issue by boxing out all of the processors other than the target processor i.e. giving all the other processors busy work that is not useful to make them spin so that they do not have the sampler thread. However this tends to significantly hinder application performance. So instead the set of processors on which the target thread may run is restricted to the target processor according to an embodiment of the present invention. In this way the remaining processors may continue to do real work. Only the target processor is affected while the target thread s call stack is being retrieved. The affinity is set so that the target thread may run only on the one processor to which it has affinity. Once the target s call stack is obtained the target thread s affinity is restored and the target thread may run on any available processor again.

The sampling system may have a plurality of processors. For example the sampling system may have a first processor a second processor . . . and an nth processor . Only one thread may run on each processor at a given time. However that thread may potentially run on a different processor at a different time. In the sampling system at least one processor generates an interrupt. In one embodiment a sample may be driven by an interrupt. In one embodiment the sample is based on an event. For example the event may be time based so that the sample is generated at a constant rate for predetermined time intervals. Accordingly each of the processors may generate an interrupt at a constant rate irrespective of the status of each of the processors e.g. being idle or not being idle. The interrupt for each processor is generated by hardware and handled by an interrupt handler which determines if the interrupted thread is one for which a call stack should be obtained. The interrupt handler initiates the gathering of call stacks. Further the interrupt handler may notify or signal a profiler sampler thread. To avoid thread migration during sampling the affinity of a thread to a particular processor may be established.

In another embodiment a component such as an interrupt back end worker offlevel processing worker interrupt backend worker or the like may be utilized as only some things may be done at the interrupt level and the rest of the work is deferred until a subsequent time.

The profiler may retrieve the call stack i.e. the execution context. Further the profiler may restore the affinity.

In one embodiment the call stack sampling tool contains a kernel mode component and a user mode component that work together. In one configuration the underlying operating system provides application program interfaces APIs that allow setting a thread s affinity from kernel mode. The user mode component creates a high priority sampling thread for each processor and sets its affinity to only that processor. Each sampler thread is responsible for gathering call stacks for one or more interrupted threads that were running in that processor. Each sampler thread waits for notification from the kernel mode component. The kernel mode component enables the sampling e.g. interrupt mechanism. Interrupts will occur on each processor at a predetermined rate. The interrupt handler handles the sampling interrupts. For example the interrupt handler may perform the following 1 collect the interrupted thread s information e.g. thread id process id user mode and kernel mode instruction and stack pointers etc. 2 set the interrupted thread s affinity to only the processor on which it is running e.g. the interrupted processor 3 notify the user mode sampler thread to collect the call stack and 4 indicate that no more samples will be handled on this processor until the user mode sampler thread completes. Further the user mode sampler thread wakes up and performs the following 1 utilizes a virtual machine tools interface to obtain the interrupted thread s call stack or walks the interrupted thread s call stack directly 2 restores the original interrupted thread s affinity to allow for the operating system as seen in to schedule the interrupted thread on any available processor 3 save call stack and thread information 4 notify kernel mode component that processing had completed and 5 wait for the next kernel mode notification. In addition the kernel mode component resets the sampling mechanism and waits for the next interrupt to continue with the kernel mode component handling the sampling interrupts. As a result setting a thread s affinity is a very fast and lightweight operation and the need to spin threads on other processors for the length of time it takes to collect the interrupted thread s call stack is eliminated. Accordingly those other processors are free to perform useful work.

In another configuration the underlying operating system as seen in is assumed not to provide APIs that allow setting a thread s affinity from kernel mode. The user mode component creates a high priority sampling thread for each processor and sets its affinity to only that processor. Each sampler thread is responsible for gathering call stacks for one or more interrupted threads that were running in that processor. Each sampler thread waits for notification from the kernel mode component. Further the kernel mode component sets the sampling e.g. interrupt mechanism. Interrupts will occur on each processor at a predetermined rate. In addition the kernel mode component handles the sampling interrupts. The kernel mode component collects the interrupted thread s information e.g. thread id process id user mode and kernel mode instruction and stack pointers etc. Further the kernel mode component notifies all user mode sampler threads to wake up but assigns the responsibility for collecting the call stack to only those samplers running on processors on which an interrupted thread has been identified to have its call stack retrieved. The kernel mode component indicates that no more samples will be handled on this processor until the user mode sampler thread completes. All user mode sampler threads wake up and the ones which were not responsible for collecting a call stack go into a spin loop to wait for the samplers tasked with collecting a call stack to set their interrupted threads affinity whereas the samplers with work to do i.e. tasked with collecting call stacks set the interrupted thread s affinity to only the processor on which it was running e.g. the interrupted processor and join the spin until all interrupted threads have had their affinity changed. Once all interrupted threads have had their affinity changed samplers which were not tasked with collecting a call stack stop spinning and go back to waiting for kernel mode notification. Further samplers tasked with collecting a call stack continue processing. In addition samplers either request the interrupted thread s call stack utilizing virtual machine tools interface application programming interfaces APIs or retrieve the interrupted thread s call stack directly. The original interrupted thread s affinity is restored which allows the operating system to schedule the interrupted thread on any available processor. Further the call stack and thread information is saved. The kernel mode component is notified that processing has completed. Samplers go back to waiting for the next kernel mode notification. The kernel mode component resets the sampling mechanism and waits for the next interrupt to continue with the kernel mode component handling the sampling interrupts. As a result setting a thread s affinity is a very fast and lightweight operation and the length of time during which sampler threads on other processors need to spin is significantly reduced. The time is reduced from the length of time it takes to collect the interrupted thread s call stack to the length of time needed to set affinity of the interrupted threads. Once affinity is set the spinning processors are free to perform useful work.

Variations of the configurations provided herein may be utilized to allow for collecting the call stacks asynchronously. Instead of making a synchronous call to a virtual machine tools interface to collect the call stack a sampler would request that the call stack be collected for the interrupted thread asynchronously e.g. by setting a notification flag at the next convenient time and then wait for a notification from the virtual machine when the request is completed. At that time the sampler would restore the interrupted thread s affinity. Because collecting a call stack may be a lengthy operation once the request is made to the virtual machine to collect the call stack the sampler would yield the processor. The interrupted thread will not migrate away from that processor. In order to get the call stack from the interrupted thread as soon as possible after setting the notification flag the sampler thread could increase the priority of the interrupted thread and block. When the notification occurs the profiler would retrieve and process the call stack and before restore the thread s original priority.

In one embodiment the signal handler is installed when the processing is registered for call stack sampling and its sampler threads are allocated. After the hardware is set up to generate one or more interrupts for the requested events the interrupt is signaled and the interrupt handler handles the interrupt. The interrupt handler then signals the interrupted thread which may be effectuated by an SLIH or an interrupt back end as long as they occur on the same processor as the interrupting processor. The signal handler is then executed before the interrupted thread is allowed to resume normal execution. The signal handler may then perform various actions to cause the interrupted thread to be bound to the processor and allow the sampler thread to retrieve the call stack. In one embodiment the signal handler binds i.e. sets the affinity of the interrupted thread to the processor on which it was interrupted and then signals the sampler thread for that processor to get the interrupted thread s call stack . Because the signal handler may run on any processor care must be taken to make sure the interrupted thread is bound to the correct processor not necessarily the one on which the signal handler is running. In one embodiment the interrupt handler maintains a per processor entry containing the interrupted thread identifier. The signal handler searches the processor entry for its thread id and binds the thread to that processor. Other variations may be utilized.

When the sampler thread has determined that the interrupted thread is bound to the interrupted process the sampler thread then requests or gets the call stack. In one embodiment the sampler thread may set the affinity or know that the affinity was set by the signal handler.

With respect to native call stacks one approach is to have the monitored application link with a library that supports the registration of monitoring and the installation of a signal handler. Alternatively support may be added dynamically for an interrupted process using a mechanism similar to the process debuggers use to attach to an already running program. Although this may not be possible on the first interrupt a daemon process may be scheduled to initiate the attachment in an expedited manner for subsequent interrupts against that process to be handled via this disclosed method.

When the call stack is retrieved various actions may take place. In one embodiment the retrieved call stack is walked into a tree and the leaf node of the tree has its base count incremented which allows for utilization of the technology to produce reports or to view the collected information.

In yet another embodiment profiling static and dynamic code may be utilized. illustrates a process that may be utilized to profile static and dynamic code according to an embodiment of the present invention. At a process block the process utilizes the profiler to register events that identify load addresses and lengths for generated code. As an example a virtual machine tool interface event may identify a load address and length of the generated code. Further at a process block the process registers the event to support call stack sampling. In addition at a process block the process associates upon receipt of the event by the profiler data received with the generated code identified in the event. At a process block the profiler processes the data by recording the most recent data with the generated code identified in the event. In an alternative embodiment the profiler may associate the data utilizing a Last In First Out LIFO queue to give priority to the most recently generated code.

In another embodiment the data recorded by the profiler is handed to a component handling Address to Name A2N resolution. The component may have specialized support for code that is generated dynamically and may be overlaid.

After retrieving a call stack the sampler thread determines if the instruction pointer received from the interrupt handler falls within the address for the function being executed at the leaf node of a tree. If the instruction pointer falls within the leaf node the sampler thread indicates that the target thread did not drift I.e. execute instructions since the time the target thread was interrupted. If the instruction pointer does not fall within the leaf function the target thread drifted since the time the target thread was interrupted. The target thread was interrupted at the address given by the instruction pointer. However that address is not within the function being executed as indicated by the retrieved call stack. In other words the target thread is not where it was interrupted and has drifted. The sampler inspects other functions near the leaf node. In other words the functions that appear in the tree as immediate callers of the leaf functions i.e. functions that directly call the leaf function or functions directly called by the leaf function. The functions that directly call the leaf function are callers and the functions that are directly called by the leaf function are callees. If the instruction pointer is resolved to either a caller or a callee then the exact location of the drifted target thread may be determined. Accordingly corrections may be made in the tree by incrementing the occurrence counts in the actual caller or callee node which is where the target thread was actually interrupted. If the instruction pointer is not resolved to either a caller or a callee then the occurrence count on the leaf node is incremented because that is the location of the target thread regardless of where the target thread was interrupted.

Subsequently a report regarding the address range match is generated. While generating the report the address ranges are converted to symbols. The conversion is performed by identifying functions in the address range and utilizing the A2N component to retrieve start addresses and lengths. When the report is generated the A2N information is utilized to identify function names. In addition names that are added to the reports are also determined along with identifying which leaves bases should be incremented to reflect an accurate picture of the call stack samples.

Accordingly static and dynamic code is profiled utilizing the data collected by a device driver and data gathered for generated code. The profiling determines if an instruction address range collected by the device driver falls within the range of the generated code as specified by a virtual machine. This data may be utilized to determine the name of a routine that was executing at the time of an interrupt.

Further in one embodiment the address change is resolved in real time. Therefore dynamic code may also be accounted for during post processing. Similarly static code may be profiled utilizing a real time analysis

The processes described herein may be implemented in one or more general multi purpose or single purpose processor. Such a processor or processors will execute instructions either at the assembly compiled or machine level to perform the processes. Those instructions may be written by one of ordinary skill in the art following the description of the figures corresponding to the processes and stored or transmitted on a computer readable medium. The instructions may also be created using source code or any other known computer aided design tool.

The processor is coupled either directly or indirectly to the memory through a system bus. The memory may include local memory employed during actual execution of the program code bulk storage and or cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

The input output devices may be coupled directly to the system or through intervening input output controllers. Further the input output devices may include a keyboard a keypad a mouse a microphone for capturing speech commands a pointing device and other user input devices that will be recognized by one of ordinary skill in the art. Further the input output devices may include a receiver transmitter speaker display image capture sensor biometric sensor etc. In addition the input output devices may include storage devices such as a tape drive floppy drive hard disk drive compact disk CD drive digital video disk DVD drive etc.

Network adapters may also be coupled to the system to enable the system to become coupled to other systems remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the currently available types of network adapters.

For any of the configurations described herein various actions may take place when the call stack is retrieved. In one embodiment the retrieved call stack is walked into a tree and the leaf node of the tree has its base count incremented which allows for utilization of technology to produce reports or to view the collected information.

Any of the configurations described herein may be utilized with a virtual machine. A virtual machine may be configured to keep track of calling state and return that state referring to a virtual machine supported interface to return call stacks. For instance information about execution of threads may be obtained through trace data. This information may include call stack information obtained from call stacks associated with threads of interest. A virtual machine may be utilized to obtain the call stack information. Various approaches may be utilized by the virtual machine to obtain the call stack information. For example entry exit events an application timer tick or instrumenting codes that sample the instrumented values may be utilized. A selected sampling thread may send a call to the virtual machine to obtain the call stack information. The selected sampling thread may make the call to the virtual machine through a virtual machine interface. The virtual machine interfaces may return call stack information to the sampling thread or may store the call stack information in some work area. The obtained information may be placed into a tree for later analysis.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that may contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that may communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams may be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The processor of a general purpose computer special purpose computer or other programmable data processing apparatus may be referred to herein as a microprocessor. However the term microprocessor should not be interpreted as being limited to a single chip central processing unit or any other particular type of programmable data processing apparatus unless explicitly so stated.

These computer program instructions may also be stored in a computer readable medium that may direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks. The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration may be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

Reference throughout this Specification to one embodiment an embodiment or similar language means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus appearances of the phrase in one embodiment in an embodiment and similar language throughout this Specification may but do not necessarily all refer to the same embodiment. Furthermore the described features structures or characteristics of the invention may be combined in any suitable manner in one or more embodiments. Correspondingly even if features are initially claimed as acting in certain combinations one or more features from a claimed combination may in some cases be excised from the combination and the claimed combination may be directed to a subcombination or variation of a subcombination.

While the apparatus and method have been described in terms of what are presently considered to be the most practical and preferred embodiments it is to be understood that the disclosure need not be limited to the disclosed embodiments. The disclosure is intended to cover various modifications and similar arrangements included within the spirit and scope of the claims the scope of which should be accorded the broadest interpretation so as to encompass all such modifications and similar structures. The present disclosure includes any and all embodiments of the following claims.

