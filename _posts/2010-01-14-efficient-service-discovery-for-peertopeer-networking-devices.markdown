---

title: Efficient service discovery for peer-to-peer networking devices
abstract: Techniques for discovering and/or advertising services are described herein. A first bitmask is received from a remote device over a wireless network, the first bitmask having one or more bits that have a predetermined logical value. Each bit represents a particular service provided by the remote device. A logical operation is performed between the first bitmask and a second bitmask locally generated within a local device, where the second bitmask represents a service being searched by the local device. It is determined whether the remote device is potentially capable of providing the service being searched by the local device based on a result of the logical operation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08285860&OS=08285860&RS=08285860
owner: Apple Inc.
number: 08285860
owner_city: Cupertino
owner_country: US
publication_date: 20100114
---
This application claims the benefit of U.S. Provisional Patent Application No. 61 240 509 filed Sep. 8 2009 and U.S. Provisional Patent Application No. 61 249 582 filed Oct. 7 2009. This application is also a continuation in part CIP of co pending U.S. patent application Ser. No. 12 405 130 entitled Service Discovery Functionality Utilizing Personal Area Network Protocols filed Mar. 16 2009.

This application is also related to co pending U.S. patent application Ser. No. 12 479 745 filed Jun. 5 2009 and U.S. patent application Ser. No. 12 479 586 filed Jun. 5 2009. The disclosures of the above identified applications are incorporated by reference in its entirety.

The present invention relates generally to peer to peer networking. More particularly this invention relates to efficient service discovery for peer to peer networking devices.

Bluetooth BT wireless technology provides a manner in which many wireless devices may communicate with one another without connectors wires or cables. Current common uses for Bluetooth technology include those for headsets cellular car kits and adapters. Moreover Bluetooth technology is currently used for connecting a printer keyboard or mouse to a personal computer without cables. Also since Bluetooth technology can facilitate delivery of large amounts of data computers may use Bluetooth for connection to the Internet. Mobile communication devices such as cellular telephones may transfer photos video or ring tones between them. Additional functionality is expected to continue to expand.

Before two Bluetooth enabled devices may communicate the devices must be paired. Bluetooth pairing occurs when the two Bluetooth enabled devices become a trusted pair. To become a trusted pair two Bluetooth devices must first complete a specific discovery and authentication process. When a first Bluetooth device recognizes a second Bluetooth device and they complete a specific discovery and authentication process each device can automatically accept communication between them.

Device discovery is the procedure a Bluetooth wireless device uses to locate nearby Bluetooth wireless devices with which it wishes to communicate. Exchanging the Bluetooth addresses of the discoverable devices their friendly names and other relevant information via establishing a short term connection with each device in the vicinity can be a time consuming procedure. The procedure can involve having one Bluetooth wireless device transmitting an inquiry request to other Bluetooth wireless devices scanning for inquiry requests. A device that transmits the inquiry request a potential master is said to be discovering devices while the device that is scanning for inquiry requests is said to be discoverable.

Service discovery is another procedure in which one Bluetooth device searches for a service or application that may be provided by one or more remote Bluetooth devices. Similar to the device discovery procedure the originated Bluetooth device in this situation a client device has to send an inquiry to other Bluetooth devices in this situation a server device to determine whether those Bluetooth devices have the service or application being searched available. This procedure usually takes relatively long time and it may consume more power. Devices with other communication systems such as radios operating under a WiFi standard e.g. IEEE 802.11n or other IEEE 802.11 standards or under other wireless communication systems can also take a relatively long time to discover each other and their respective services. There has been a lack of an efficient way to perform a service discovery procedure.

Techniques for discovering and or advertising services are described herein. According to one aspect of the invention a first bitmask is received from a remote device over a wireless network the first bitmask having one or more bits that have a predetermined logical value. Each bit represents a particular service provided by the remote device. A logical operation is performed between the first bitmask and a second bitmask locally generated within a local device where the second bitmask represents a service being searched by the local device. It is determined whether the remote device is potentially capable of providing the service being searched by the local device based on a result of the logical operation.

According to another aspect of the invention a key value pair is generated based on an identifier of a service to be advertised by a local device. A hash operation is performed on a key of the key value pair to generate a bitmask the bitmask including a bit having a predetermined logical value. In response to an inquiry message from a remote device over a wireless network for searching for a service the bitmask is transmitted to the remote device over the wireless network to allow the remote device to determine whether the local device is potentially capable of providing a service being searched based on the bitmask.

According to another aspect of the invention one or more domain name system DNS resource records are received identifying a service available for access in a network. In response a DNS packet is created based on the DNS resource records. This DNS packet includes domain names having pointers referenced to other domain name s that previously appear in the DNS packet without reciting the entire referenced domain name s . A key value pair is generated from each resource record where each key value pair is used to represent a service to be available for access in the network.

One or more embodiments described herein can use any one of a variety of wireless communications systems such as for example Bluetooth compliant communication systems WiFi compliant communication systems e.g. radios operating under any one of the IEEE 802.11 standards such as the 802.11g standard or the IEEE 802.11n standard WiMax compliant communication systems radios operating under a cellular telephony standard radios operating under a personal area network PAN standard etc.

A service as described herein may be any one of a variety of applications or other facilities such as multi player games e.g. a card game on each of several devices etc. or collaborative applications e.g. music creation applications one on each of a plurality of devices or document creation or authoring applications one on each of a plurality of devices etc. or social networking applications e.g. a Facebook application on each of a plurality of devices or a LinkedIn application on each of a plurality of devices or a MySpace application on each of a plurality of devices etc. or voice chat applications or text chat applications or instant messaging applications etc. Examples of services and devices used in networking are also described in U.S. patent application Ser. No. 12 479 745 filed Jun. 5 2009 and in U.S. patent application Ser. No. 12 479 586 filed Jun. 5 2009 and both of these applications are incorporated herein by reference.

Data processing systems machine readable storage media and methods which include or use one or more embodiments of the invention are also described. Other features of the present invention will be apparent from the accompanying drawings and from the detailed description which follows.

Various embodiments and aspects of the inventions will be described with reference to details discussed below and the accompanying drawings will illustrate the various embodiments. The following description and drawings are illustrative of the invention and are not to be construed as limiting the invention. Numerous specific details are described to provide a thorough understanding of various embodiments of the present invention. However in certain instances well known or conventional details are not described in order to provide a concise discussion of embodiments of the present inventions.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in conjunction with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment. The processes depicted in the figures that follow are performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. software or a combination of both. Although the processes are described below in terms of some sequential operations it should be appreciated that some of the operations described may be performed in a different order. Moreover some operations may be performed in parallel rather than sequentially.

According to some embodiments a key value pair is used to represent a particular service advertised by a wireless computing device such as a Bluetooth device or other type of wireless device. When a wireless device has one or more services to be advertised in a wireless network for each service to be advertised one or more key value pairs are generated. A key value pair may be generated based on DNS information associated with the respective service. The key is used to indicate whether the wireless device is potentially capable of providing a particular service e.g. a game and the value includes further detailed information regarding the service to be provided. All the key value pairs are hashed using a hash function e.g. SHA 1 or MD5 to generate a bitmask. Each bit of the bitmask having a predetermined logical value e.g. logical value of TRUE indicates that the corresponding service is supported by the wireless device. In this situation a wireless device that advertises one or more services acts as a server that provides the advertised services to one or more other wireless devices which are referred to as client devices. Note that a wireless device could be both a server device and a client device dependent upon certain circumstances.

When another wireless device as a client device searches for a particular service in the network a key is generated based on an identifier of the service being searched such as for example domain name system DNS information associated with the service. In addition a bitmask is generated from the key for example by hashing the key. An inquiry message e.g. an extended inquiry or EI message is then broadcast in the network by the client device. The inquiry message is received by all other wireless devices in a communications range.

In response to the inquiry each server device that has a capability of providing services to others can respond to the inquiry by returning a bitmask representing services that are supported by the respective device as set forth above. When the client device receives the bitmasks from the server devices for each bitmask received the client device performs a predetermined operation e.g. a logical AND operation on the locally generated bitmask representing the service being searched and the bitmask received from a remote server device. The result of the operation is used to indicate that whether a particular server device potentially supports the service being searched.

If the result indicates that a server device may potentially provide the service being searched the client device can then establish a connection e.g. SDP connection with the associated server device and send a request for more detailed information about the service. In return the key value pair corresponding to the service is received from the server device. As a result the above protocol can quickly identify which of the server devices responding to the inquiry support the service being searched before establishing a connection to obtain the detailed information of the service e.g. key value pair from the server devices which may take a relatively long time.

According to one embodiment a key value pair is generated based on DNS information associated with the service being searched and or advertised. For example a name field and type field of a resource record RR in a DNS packet e.g. DNS query packet may be used to generate the key of a key value pair while a data field e.g. RData field of the DNS packet may be used to generate the value of the key value pair. A DNS packet may include multiple RRs. In one embodiment a name field of an RR may include a compression pointer CP pointing to a character string previously appeared in another RR or Question of the DNS packet without duplicating the entire character string in the name field. Similarly the data field e.g. RData field may also include a compression pointer pointing to a string that appears in another RR or Question or alternatively in the name field of the current RR without duplicating the entire string. Thus the value of a key value pair may include a pointer pointing to the key of the key value pair while the key of the key value pair includes a pointer pointing to another RR or Question of the DNS packet. As a result a size of a key value pair can be further reduced for the purpose of service discovery.

Devices may be any kinds of wireless communications or computing devices. Devices may be mobile phone devices messaging devices personal digital assistants PDAs notebook or laptop computers mobile data terminals gaming devices having a wireless communication interface media players e.g. audio and or video players etc. For example devices may be an iPhone or iPod device available from Apple Inc. of Cupertino Calif. or other consumer electronic device.

In one embodiment device includes a processing protocol stack having multiple processing layers including but is not limited to a service discovery layer or unit a wireless layer or unit . For example service discovery layer may be Bonjour compatible processing or protocol layer and the wireless layer may be a Bluetooth compatible processing or protocol layer. While the description has by way of example referred to radios operating under a Bluetooth compliant or compatible communication system it will be understood that other wireless communication systems can be used such as for example WiFi complaint or compatible communication systems e.g. radios operating compatibly with one of the IEEE 802.11 standards such as the IEEE 802.11n standard WiMax compliant or compatible communication systems radios operating according to a cellular telephony standard etc. In addition device includes storage for storing data and a wireless communications interface for communicating with another device such as device . The storage may be a non volatile memory such as a disk a volatile memory such as a random access memory RAM or a combination thereof.

In one embodiment service discovery layer includes but is not limited to a service advertisement unit a service mask generator and a key value pair generator . Service advertisement unit is used to advertise one or more services such as applications or services that device can provide where device acts as a server device e.g. service provider . When one or more services are advertised key value pair generator is invoked to generate a key and a value where the key value pair is used to represent a particular service. The key is used to indicate whether the wireless device potentially supports a particular service e.g. a game and the value includes further detailed information regarding the service to be provided which may be used to determine whether the device actually supports the particular service. The key value pairs are then stored in storage as key value pairs .

In addition all the key value pairs that represent all services advertised by device are used to generate a bitmask by service mask generator . In one embodiment the key value pairs are hashed using a hash function e.g. SHA 1 or MD5 etc. to generate a bitmask which is stored in storage as service mask . Each bit of the bitmask having a predetermined logical value e.g. logical value of TRUE or ONE indicates that the corresponding service is supported by device . In this situation device that advertises one or more services acts as a server device serving the advertised services to one or more other wireless devices e.g. device which are referred to as client devices. Note that a wireless device could be both a server device and a client device dependent upon certain circumstances.

Similarly according to one embodiment device includes a processing protocol stack including but is not limited to a service discovery layer or unit and a wireless layer or unit . Service discovery layer may be a Bonjour compatible processing or protocol layer and wireless layer may be a Bluetooth compatible processing or protocol layer. While the description has by way of example referred to radios operating under a Bluetooth compliant or compatible communication system it will be understood that other wireless communication systems can be used such as for example WiFi complaint or compatible communication systems e.g. radios operating compatibly with one of the IEEE 802.11 standards such as the IEEE 802.11n standard WiMax compliant or compatible communication systems radios operating according to a cellular telephony standard etc. In one embodiment service discovery layer includes a DNS processing unit and a key generator .

When application such as a browser application searches for a particular service in the network a DNS packet e.g. DNS query packet is generated by DNS processing unit . In addition key generator generates a key based on the DNS packet. The wireless layer generates a bitmask based on the key for example by performing a hash operation on the key using a variety of hash functions e.g. SHA 1 or MD5 etc. and stores the key and the bitmask in a local memory not shown of device . Wireless layer then broadcasts an inquiry message e.g. an extended inquiry or EI message in the network via wireless interface logic or circuit . The inquiry message is received by all other wireless device in a communications range including device .

In response to the inquiry each server device that is potentially capable of providing services to others can respond to the inquiry by returning a bitmask representing services that are supported by the respective device. In this example the inquiry message is received by device . In response to the inquiry message wireless layer is configured to retrieve a service bitmask from storage and returns data representing service bitmask to device via wireless interface logic or circuit .

When device receives the bitmask from device wireless layer compares the bitmask received from device with the one stored in the local memory to determine whether there is any corresponding bits in both bitmasks having an identical logical value which indicates that an associated service is supported by device . For example wireless layer may perform a logical AND operation between two bitmasks.

If the result indicates that the service being searched by application is potentially supported by device wireless layer may then establish a session connection e.g. session description protocol or SDP connection with device and send a request for more detailed information about the service. In one embodiment device may request for all key value pairs supported by the bitmask from device including the key value pair corresponding to the service being searched. The wireless processing unit may walk through all the key value pairs received from device . For example for each key value pair the wireless processing unit may compare or match a key of each key value pair with the one stored locally corresponding to the service being searched to identify the key value pair corresponding to the service being searched.

Once the key value pair corresponding to the service being searched is received and identified wireless layer passes such a key value pair to service discovery layer . Service discovery layer evaluates the key value pair and informs application whether the service being searched is actually supported by device . As a result the above protocol can quickly identify which of the server devices responding to the inquiry potentially support the service being searched before establishing a connection to obtain the detailed information of the service from the server devices to determine whether the server devices actually support the service being searched which may take a relatively long time.

Note that as described above the architectures of devices may be similar or identical. Dependent upon a specific circumstance devices may operate as a client device and or a server device. Thus certain functional units may perform some operations that are similar or identical when a device is operating as a client device a server device or both a client and server devices. For example service discovery layer may be implemented similar to the service discovery layer while wireless layer may be implemented similar to wireless layer . Although not shown service discovery layer may include other functional units similar to service advertisement unit service mask generator and or key value pair generator etc. Likewise service discovery layer may include other functional units similar to DNS processing unit and or key generator etc. For example the key generated by service discovery unit may be similar or identical to the key generated by service discovery unit for the same service. Note that some or all of the components of devices of may be implemented in software hardware or a combination of both.

If it is determined that the service being searched is supported by device at transaction device sends a request to establish a session connection e.g. SDP connection and at transaction device acknowledges the request to complete the establishment of the session connection.

Once the connection has been established during transaction device requests for one or more key value pairs from device and receives such key value pairs from device during transaction . Note that device may have multiple services that corresponding to the same bit of the bitmask. Based on the bitmask device can only determine that device may be or potentially capable of providing the service being searched. The techniques described throughout this application allow a device to quickly determine whether a peer device may be or potentially capable of providing a particular service without having to establish a connection with the peer device which may take a relatively long time. Only when it is determined that the peer device may potentially provide the particular service a session connection is then established to obtain further detailed information of the services provided by the peer device to determine whether the peer device actually can provide such a service. As a result by using a bitmask and key value pair certain peer devices that are not capable of providing a particular service can be quickly eliminated.

At block the key value is stored in a local storage and a bitmask is generated based on the key for example via a hash operation. The bitmask includes a single bit at a certain bit location corresponding to the key to indicate that the service is supported by the local computing device. Such a bitmask is also referred to as a service bitmask. If multiple services are supported by the device there may be multiple bits in the bitmask that have a predetermined logical value e.g. logical value of TRUE each indicating a particular service supported by the device. Subsequently at block an inquiry e.g. EI inquiry is received from a remote device inquiring one or more services. In response at block the service bitmask is returned to the remote device which is used by the remote device to determine whether a particular service is supported by the local device.

At block an inquiry e.g. EI message is broadcast in a network searching for the service that may be available from one or more peer devices in the network. At block each peer device in the network that receives the inquiry may respond with a service bitmask representing what service or services that each peer device can provide. At block for each bitmask received a logical operation e.g. logical AND operation is performed between the bitmask received from a remote peer device and the bitmask generated locally. The result of the logical operation is used to determine whether the service being searched is available from a particular peer device.

For example if the locally generated bitmask is 0x04 e.g. bit has a logical value of TRUE while the bitmask received from a remote peer device is 0x07 e.g. bits have logical value of TRUE a logical AND operation between two bitmasks yields a result of 0x04. Here a non zero value at bit of the result indicates that the service being searched may be supported by the remote peer device. Note that a peer device may have multiple services that corresponding to the same bit of the bitmask. At this moment the client device can only determine based on the bitmask that the remote device may be capable of providing the service being searched. In order to determine for sure that the remote device can provide the service being searched the local device has to establish a connection with the remote device to obtain apropos key value pairs and to examine them in order to determine whether the peer device actually supports the service being searched which may take a longer time. However by using a bitmask a local device can quickly eliminate those peer devices that cannot provide the service being searched and focus on those devices that can. As a result the efficiency for searching a service can be greatly improved.

According to one embodiment a key value pair is generated based on DNS information associated with the service being searched and or advertised. For example a name field and type field of a resource record RR in a DNS packet may be used to generate the key of a key value pair while a data field e.g. RData field of the RR may be used to generate the value of the key value pair. In one embodiment a name field of an RR may include a pointer such as a compression pointer CP pointing to a character string previously appeared in another RR or Question of the DNS packet without duplicating the entire character string in the name field. Similarly the data field e.g. RData field may also include a compression pointer pointing to a string that appears in another RR or Question or alternatively in the name field of the current RR without duplicating the entire string. Thus the value of a key value pair includes a pointer pointing to the key of the key value pair while the key of the key value pair includes a pointer pointing to another RR. As a result a size of a key value pair can be further reduced for the purpose of service discovery.

In order to reduce the size of a DNS packet a compression pointer CP is used to replace a subsequent appeared string by referencing a previous appearance of the string without reciting the entire string in the field as shown in . Referring to instead of reciting the entire strings of  tcp and local in name field of RR compression pointer is used to reference to the same strings previously appeared in name field of Question . For example the pointer represents an offset from the beginning of the DNS packet to the bytes that encode the domain name 4  tcp 5 local 0 . As a result instead of using 21 bytes to encode 8  example 4  tcp 5 local 0 only 11 bytes are used herein.

Similarly RData field may also use a pointer to reference to a string previously appeared in the DNS packet without having to repeat the entire string. For example it is assumed that RData field terminates in a string 8  example 4  tcp 5 local 0 . Such a string can be replaced with a pointer pointing to the name field that includes pointer referenced to name field .

According to one embodiment a key is comprised of a name field and type field generated from a question or resource record of the DNS packet in this example resource record . The name field includes a pointer referenced to a string previously appeared in the DNS packet without reciting the entire string as shown in . Note that it is assumed that the DNS class used in the DNS packet is IN referring to the Internet class the only DNS class in widespread use . The 2 byte DNS class in the DNS packet is replaced in Key by a version identifier identifying how the compression is performed on the domain name in name field . For example the version identifier indicates which in memory DNS packet also referred to as a compression dictionary was used to create this key such that the receiver of the key can decompress the key back into a full DNS name. Note that key is described for the purpose of illustration only other formats may also be applied. Further the value of a key value pair is generated from a record data field in this example RData field of the record having a pointer pointing to the name field of the resource record. That is the value of a key value pair includes a pointer referenced to the key of the key value pair and the key itself includes a pointer pointing to another domain name e.g. name field that is before the information used for the key in the DNS packet. This makes the size of a key value pair even smaller.

As shown in the computer system which is a form of a data processing system includes a bus or interconnect which is coupled to one or more microprocessors and a ROM a volatile RAM and a non volatile memory . The microprocessor is coupled to cache memory . The bus interconnects these various components together and also interconnects these components and to a display controller and display device as well as to input output I O devices which may be mice keyboards modems network interfaces printers and other devices which are well known in the art.

Typically the input output devices are coupled to the system through input output controllers . The volatile RAM is typically implemented as dynamic RAM DRAM which requires power continuously in order to refresh or maintain the data in the memory. The non volatile memory is typically a magnetic hard drive a magnetic optical drive an optical drive or a DVD RAM or other type of memory system which maintains data even after power is removed from the system. Typically the non volatile memory will also be a random access memory although this is not required.

While shows that the non volatile memory is a local device coupled directly to the rest of the components in the data processing system the present invention may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as is well known in the art. In one embodiment the I O controller includes a USB Universal Serial Bus adapter for controlling USB peripherals. Alternatively I O controller may include a wireless adapter such as a Bluetooth adapter or a WiFi interface or an IEEE 1394 adapter also known as FireWire adapter for controlling FireWire devices.

Some portions of the preceding detailed descriptions have been presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the ways used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of operations leading to a desired result. The operations are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments of the present invention also relate to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable medium. A machine readable medium includes any mechanism for storing information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. etc.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method operations. The required structure for a variety of these systems will appear from the description above. In addition embodiments of the present invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of embodiments of the invention as described herein.

In the foregoing specification embodiments of the invention have been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

