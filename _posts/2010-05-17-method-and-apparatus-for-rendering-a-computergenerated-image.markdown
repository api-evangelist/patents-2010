---

title: Method and apparatus for rendering a computer-generated image
abstract: A method and apparatus for rendering a computer generated image using a stencil buffer is described. The method divides an arbitrary closed polygonal contour into first and higher level primitives, where first level primitives correspond to contiguous vertices in the arbitrary closed polygonal contour and higher level primitives correspond to the end vertices of consecutive primitives of the immediately preceding primitive level. The method reduces the level of overdraw when rendering the arbitrary polygonal contour using a stencil buffer compared to other image space methods. A method of producing the primitives in an interleaved order, with second and higher level primitives being produced before the final first level primitives of the contour, is described which improves cache hit rate by reusing more vertices between primitives as they are produced.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08654146&OS=08654146&RS=08654146
owner: Imagination Technologies, Ltd.
number: 08654146
owner_city: Kings Langley, Hertfordshire
owner_country: GB
publication_date: 20100517
---
The invention relates to a method and apparatus for rendering computer generated images in which the images include at least one closed polygonal contour. Particularly the invention relates to rendering of images using image space calculations and standard graphics hardware and in which the polygons in the images include arbitrary shaped polygons where arbitrary permits the existence concavities self intersections and even multiple contours .

In a computer generated image there are typically a large number of individual polygons. Graphics rendering hardware in particular 3D graphics hardware often only has capability for the rendering of triangle primitives or occasionally other convex polygons that is to say polygons in which all the internal angles of the polygon are less than 180 . Such polygons are relatively straightforward to render. Such specifications include fill rules which determine which parts of an arbitrary polygon are to be deemed interior and which are exterior. SVG defines two such rules even odd and non zero . For brevity in this document we will usually assume use of the even odd rule but it will be clear to one skilled in the art that the techniques presented apply to other well defined fill rules.

The ability to render such arbitrary polygons whilst also supporting convex polygons is useful for a number of reasons for example to support vector graphics standards such as SVG Scalable Vector Graphics and OpenVG Open Vector Graphics . SVG is a language for describing two dimensional graphics and graphical applications in XML Extensible Markup Language . OpenVG is a royalty free application programming interface API designed for hardware accelerated 2 dimensional vector graphics. Naturally any method able to render the arbitrary polygons must also be able to handle convex polygons.

There are two families of methods with the capability of rendering arbitrary polygons on such hardware. The first family performs calculations in model space and are generally referred to as triangulation algorithms. These take a polygon outline and produce a set of non overlapping triangles that exactly cover the filled area of the original polygon. To avoid confusion with other uses of triangulation in this document we will refer to such algorithms as true triangulation . An example of the possible results of such a process as applied to the polygon of is shown in . The original shape can thus be constructed from the triangles v v v v v v v v v v v v v v v . Assuming a simple polygon with N sides and that no extra vertices are added note some algorithms do introduce additional vertices we will obtain N 2 triangles. Once these triangles are generated they can easily be rendered on any commodity graphics hardware.

Numerous algorithms for the true triangulation process have been published. Lamot and Zalik provide a survey of methods in Information Visualization 1999 pp 153 158 . These documented methods are nearly always restricted to simple polygons such as and i.e. they may contain neither self intersections including repeated vertices nor multiple contours. Nevertheless Meister s ear cutting or ear clipping algorithm and Seidel s method are of interest to this discussion.

Meister s method removes one vertex at a time from a simple polygon in such a way that the reduced polygon remains simple. It repeatedly clips an ear formed by a triple of consecutive vertices from the polygon. This algorithm runs in O n time and although it has been subsequently improved to be O n it is not particularly attractive except for polygons with relatively few vertices.

Seidel s method on the other hand runs in O n log n time for simple polygons where log n is defined as . . .

We can thus consider O n log n to be practically O n for any reasonable values of n. As stated above very few true triangulation algorithms have been published that handle arbitrary polygons. Held s method FIST Fast Industrial Strength Triangulation of Polygons Algorithmica 30 4 563 596 is one of the few exceptions. Although based on ear clipping additional structures are used to achieve a much better time complexity for simple polygons but it is not clear to the inventor how it behaves in the presence of self intersections etc.

The application s inventor has implemented a version of Seidel s algorithm that has been enhanced to support completely arbitrary polygons. This still achieves virtually linear performance assuming the implicit vertices created by self intersections are included in n . However on a 2 GHz CPU the process still takes an average of 1 2 s per polygon vertex. For polygons that will be drawn multiple times over numerous frames the triangulation results can be cached and so the pre processing cost is amortised by the rendering process. For situations however where a polygon is only drawn a few times or is being dynamically altered on a frame by frame basis which forces re triangulation the true triangulation process can be a very significant penalty. Note that applying linear transformations to the model does not require re triangulation. 

The second family of methods with the capability of rendering arbitrary polygons uses image space calculations. Here the rendering sampling process itself is adapted to determine which pixels fall inside the arbitrary polygon and which are outside. Although this can be done with scan line rendering algorithms we are primarily interested in those that break the arbitrary polygon into smaller polygons usually triangles for which the hardware has direct rendering support render those smaller polygons and make use of the hardware stencil buffer to determine which of the rendered pixels are inside the original arbitrary polygon. It is well known in the art 1.4 Shreiner et al ISBN 0321173481 that arbitrary polygons can drawn by using the stencil buffer. For example one may implement the odd even rule by applying XOR operations to the stencil. Similarly provided triangle winding orders are taken into account increments and decrements of the stencil can be used to implement the non zero rule.

With either fill rule one must first produce a set of triangles from the source polygon. The obvious approach is described in the section of chapter 13 of Shreiner et al available at either http fly.cc.fer.hr unreal theredbook chapter13.html or http www.scribd.com doc 7605395 Redbook . Here a triangle fan refer Chapter 2 of Shreiner et al or http en.wikipedia.org wiki Triangle fan is created by simply submitting the vertices in order i.e. v v v . . . v which implicitly creates the set of N 2 triangles with vertices v v v v v v v v v . . . v v v .

Borrowing the example from Shreiner et al part of this process is shown in . The seven sided figure is rendered as a fan of five triangles. Assuming the odd even fill rule the pixels of the screen which are covered by an odd number of triangles will be deemed interior while those covered by an even number will be exterior. For example the area bounded by v v and location is covered by triangles v v v and v v v . Assuming that the stencil buffer is initialised to zero and an XOR operation employed drawing triangle v v v will first set all the pixels stencil values for region v v but these will subsequently be cleared again by triangle v v v . The region will thus be correctly deemed exterior to the polygon. The simplicity of this process is extremely appealing and since it uses a triangle fan it only requires the transmission of N vertices to the graphics hardware.

Once the stencil has been set to indicate which pixels are inside the polygon it must be filled with the appropriate colours or textures. Methods to do this include computing the 2D bounding rectangle of all the vertices of the polygon and then drawing just a single rectangle with stencil test or to simply resend the generated triangles. The former as applied to and illustrated in has the advantage of sending a near minimal amount of geometric data to the hardware but requires pre computation of min and max bounds. It also can be expensive in terms of wasted pixel processing if the rectangle does not tightly bound the polygon to be filled as shown by the region .

Another method as shown in in this example using a set of triangles generated using the invention s method refer FIG. sends more geometry than the bounding box method but generally results in less redundant pixel filling. In this example much of the shape is filled with a single layer pass of pixels but there are regions where pixels are filled multiple times . This typically becomes worse with polygons with greater numbers of regions of or total area of concavity.

The method also works unaltered for self intersecting and multiple contour polygons Shreiner et al also provide an example of the latter. In effect they just concatenate all the vertices of all the contours and treat the result as larger triangle fan.

Despite the pleasing simplicity of this fan method as described in the art the inventor has appreciated that it has two fundamental problems. The first is related to the shape of the generated triangles. Producing a fan of triangles from the original polygon tends to lead to the production of long thin triangles. Such a triangle is generally slower to render with graphics hardware than another that has an equal screen area but is more equilateral in shape. One publication Silhouette clipping Sander et al SIGGRAPH 2000 pages 327 334 discusses this problem and gives a partial solution. Sander et al also need to fill sets of contour edges. These are in effect polygons and are likely to have concavities. They state 

This typically does improve the shape of the triangles but unfortunately introduces an extra point which thus requires the data to be read twice. It also creates an additional triangle in the fan. An example of the results of their process as applied to is shown in . Please note that the centroid location Vcentroid is only an approximation in this illustration .

This is unfortunately quite vague. Firstly they don t say how we pick two vertices . Secondly in the context of the paper proceed as before on the smaller loops would appear to imply the process of computing the centroid of each loop and turning each into a fan. That does not seem correct as it would only produce two child loops.

A more likely interpretation is that they have a target M for the number of vertices per child loop and divide the source polygon into sufficient equal pieces to meet that target number. An N vertex source polygon would thus require P child polygons where P N M 1 . With their scheme if the source polygon is thus divided into P sections then P additional vertices each located at the centroid of its respective loop are introduced. It should be noted that since each child loop is drawn with a fan there are practical reasons described in the following paragraph for not choosing too small a value for M.

Also of relevance to the invention are the methods by which contemporary rendering hardware reduces the triangle data and bus bandwidth when models are supplied to the rendering hardware. The simplest method is to supply each triangle as three V byte vertices so that for a model with T triangles 3 T V bytes of data would be transmitted to the hardware but more efficient options exist. We have already seen that 3D hardware typically supports the concept of triangle fans whereby a T triangle fan only needs to supply T 2 V bytes of data. For 3D models a related concept called triangle strips again see Shreiner or http en.wikipedia.org wiki Triangle strip is typically more useful. Like triangle fans these also require only T 2 V bytes of data for a strip of T triangles. In both cases the ratio of triangles to vertices climbs asymptotically towards 1 1 as the length of the strip or fan increases. Longer strips and fans are thus more efficient.

Over the past decade an indexed triangle format has been seeing increased popularity as a means of further decreasing the bandwidth and storage costs. Here each triangle is defined as three integer indices each say of 16 or 32 bits which select vertices from a vertex array. With 3D models this format offers the opportunity to exceed the 1 1 barrier of strips and fans though this is unlikely for 2D shapes. To efficiently support such a format graphics hardware now frequently employs a vertex caching technique such as that described by Hoppe SIGGRAPH 99 Proceedings pp 269 276 . In brief the hardware maintains a cache of the last K vertices used in past triangles. A FIFO replacement policy is generally employed rather than say a Least Recently Used LRU scheme as the former is not only simpler but more importantly generally results in a higher cache hit rate for 3D models.

We now return to the second and probably far more significant problem with the prior art fan algorithm which is that it can require a disproportionate amount of pixel filling . For example one can see from that there is a relatively large area which is covered by multiple triangles compared to the ideal situation of as generated by a real triangulation method. We will refer to the areas covered by multiple triangles as overdraw . This overdraw is an undesirable burden in the rendering phase and it is advantageous to reduce it if possible.

On average simply using the less obvious triangle strip order i.e. outputting the vertices in the order v v v v v v. . . and thus producing the triangles v v v v v v v v v . . . often results in both better shaped triangles and lower overdraw compared to fan order although ironically not in the particular case but the improvement is unfortunately not that great. From Sander et al s method would also appear to reduce overdraw at the expense of introducing an additional vertex and triangle but it certainly does not work in all cases. Applying their method to where the centroid would be located in the centre of the U would result in significant regions of overdraw as shown in .

The inventor has appreciated that there is a need for a method of producing a set of simpler polygons usually but not always triangles from an arbitrary polygon for rendering with a stencil buffer method which 

It is an object of the present invention to provide a method and system that goes some way towards achieving the above goals.

In addition for any method and system the following features though not necessarily essential are desired 

The invention is defined in the appended claims to which reference should now be made. Advantageous features are defined in the dependent claims.

In order to address the issues identified with known methods the inventor has appreciated the following 

In the ear clipping algorithms e.g. Meister or Held for true triangulation a safe vertex is identified and then removed to reduce an N sided shape to an N 1 shape. The clipped vertex then forms a triangle with its two original neighbours. Unfortunately the identification of a safe vertex i.e. where the produced triangle is entirely inside the original polygon is expensive.

We have appreciated that if one is using an image space method and rendering using a stencil buffer then it not absolutely critical if the vertex selected is safe . Taking the example from one can consider that the fan method in effect progressively clips the ears formed by vertices V V . . . Vuntil the polygon is reduced to the triangle V V V.

For triangle primitives the inventor has appreciated that if a simple ear clipping algorithm is applied to every second vertex of an original single contour of an N sided polygon the N 2 triangles thus formed will typically be more equilateral in shape than those produced by the fan or strip method. Furthermore these triangles are less likely to have large regions that either lie outside of the final filled shape or overlap other triangles than those typically generated by the fan or strip methods. After this process one will be left with a residual polygon with N 2 i.e. ceiling N 2 vertices. The same process may then be reapplied to produce another set of triangles and another residual polygon with even fewer vertices. This process is thus repeated until the residual polygon is empty i.e. when the residual polygon is a primitive of the size desired for output or the residual polygon has trivially zero area. The results of such a process as applied to are shown in . In this example the desired result of lower overdraw has been achieved.

The preceding paragraph assumes that the rendering system supports triangle primitives. Some rendering systems also support the rendering of quads either convex or arbitrary or even M sided arbitrary polygons with say M 16. Although the preferred embodiments detailed below demonstrate the invention for triangle primitives the invention is not restricted to the output of triangle primitives and may output M sided primitive units or output primitive units of more than one type eg triangles and quads if used with more flexible rendering systems. In the presently preferred embodiments one type of primitive e.g. triangles will be outputted to cover the majority of the contour.

It is also highly desirable to make the colour or texture filling process that occurs once the stencil has been set up be as efficient as reasonably possible. To this end the inventor has also appreciated that a single contour arbitrary polygon without self intersections will have an overall winding order and furthermore it is usually advantageous for this winding order to be consistent for all objects drawn by an application. This is due to the triangle fill or tie breaking rules of graphics hardware as say summarised by the OpenGL DirectX or OpenVG standards to avoid artefacts such as gaps appearing between abutting objects . For practical systems a multiple contour arbitrary polygon will thus also use a consistent overall winding order for the other pieces. By consistent it should be noted that contours representing holes will have the opposite winding order and that each contour will not in itself be self intersecting. 

The inventor has noted that once the stencil buffer has been set up for such an arbitrary polygon that has an overall winding order W only those triangles that were used to create the stencil that also have winding order W will be needed when filling the object. This can be demonstrated by considering the behaviour of the non zero fill rule as the pixels drawn are a superset of those produced by the odd even rule.

Assuming the overall winding order W corresponds to an increment of a pixel s stencil value we thus will only need to fill those pixels whose stencil has a positive value. Triangles with the opposite winding order only subtract from the stencil s value and since we are assuming a consistent winding order can be eliminated. Since rendering pipelines typically provide free support for eliminating polygons with a user selectable winding order the original triangulation can be re used. Note that polygons such as a self intersecting bow tie . i.e. 0 0 1 0 0 1 1 1 do not have an overall winding order and so cannot use this additional optimisation .

This process as applied to the triangulation of as illustrated in is shown in and can be compared with the results shown in . One can see that the triangle can be eliminated from the fill process leaving in this case just regions with a single layer of fill . There is still some redundant filling but this is greatly reduced compared to .

A first preferred embodiment is essentially that described earlier which is represented by the steps 

The conversion of a contour C v v v . . . v where N 3 to a set of primitives consists of dividing the closed polygonal contour into smaller polygonal units of maximum size P P 3 vertices by repeatedly removing up to a first set of P 2 vertices from the contour to produce a polygon with P vertices v v v and a reduced source contour with N P 2 vertices removing if possible a second set of up to P 2 vertices starting with the last vertex of previous set and continuing thus until the end of the source contour. More precisely this produces an initial set of smaller polygons 

This process is repeated with each subsequently reduced contour C until it has either P or fewer vertices or been reduced to a line segment and thus trivially zero area . The generated primitives are then rendered using a stencil buffer to produce a computer generated image.

For example the process of step 2 applied to a single contour to generate triangles i.e. for P 3 in accordance with a first embodiment of the invention will now be described. It is assumed that the contour has N sides with vertices numbered from Base to Base N 1 

It should be appreciated that this simple algorithm can be realised in hardware by one skilled in the art using a language such as VHDL or Verilog and would require only a small number of components including adders registers and comparators.

Of more importance is the amount of overdraw produced by the invention. A shows the pixels that are covered by more than one triangle. For simplicity this figure does not distinguish between areas covered by two triangles and those covered by three or more triangles even though the latter clearly is increasingly costly. Nevertheless if we just count the number of pixels touched by the overdraw region relative to the pixels of the final intended result we find that overdraw has an area that is approximately 15 of the area of the intended final result.

By contrast B shows the overdraw area using the modified fan algorithm. In this situation the overdrawn pixels represent a region that surprisingly has an area that is approximately 39 of the final result. Note that the unmodified Shreiner fan algorithm would be significantly worse.

This first embodiment of the invention described above does on average address the two most important issues i.e. that of improved triangle shape and reduced overdraw. Though of less importance the first embodiment does not achieve the triangle data efficiency of fans and strips whereby an N sided contour requiring N 2 triangles can be transmitted with just N vertices. Another potential drawback of the method of the first embodiment is that with the possible exception of the final larger values of StepSize generated triangles that are chronologically local are often only spatially local in the vicinity of a single shared vertex.

If one examines the order of vertices created by the previously described embodiment and assuming the vertices start from 1 one can see that the triangles are created in the order v v v v v v v v v . . . v v v v v v . . . . If we assume this data is provided in an indexed format to hardware with a K vertex cache where K is typically much smaller than N it will only achieve a cache hit rate of around 33 since only one vertex is usually reused between adjacent triangles. A fan or strip on the other hand achieves nearly 66 as two vertices are shared.

A second preferred embodiment will now be presented that addresses these additional issues. This second embodiment incorporates the additional feature of a very small stack. Assuming the maximum number of vertices in a contour that will ever be encountered is N then this stack needs at most log N 1 ie ceiling log N 1 entries. For example if in a given system a contour could have at most 2vertices then the stack would have no more than 17 entries.

This embodiment provides interleaving of primitive levels to maximise vertex temporal locality and produces at least one second level primitive before all the first level primitives are produced. Primitive polygon level is reflected in the separation of the vertices of the primitive polygon relative to the vertices of the original arbitrary closed polygonal contour. A first level primitive has vertices which are contiguous vertices in the original closed polygonal contour. Higher level primitives have vertices which are offset from each other in the original closed polygonal contour. The amount of offset is related to the primitive level and the number of vertices in the primitive. An i 1 level i 1 primitive is formed of end points of consecutive ilevel primitives. Considering the set of ilevel primitives and associated vertices each vertex will belong to exactly one member of the set except for the special case of end points an end point being shared with at most one other ilevel primitive.

When a contour is divided into a single size of primitive over all primitive levels for primitive level i and polygon primitive size Q the vertices in the ilevel primitive correspond to vertices offset from each other by Q 1 i 1 in the original arbitrary closed polygonal contour. For example when dividing a contour using only triangle primitives assuming first level primitives have vertices v v v v v v . . . the second level primitives will have vertices v v v v v v . . . with an offset of 3 1 2 1 2 relative to the vertices of the original closed polygonal contour and the third level primitives will have vertices v v v v v v . . . with an offset of 4 relative to the vertices of the original closed polygonal contour etc.

The second embodiment uses the same steps 1 and 3 as the first variant but replaces step 2 i.e. the triangulation of a single contour with the following method as expressed in pseudo code. We will assume as before that the contour starts at vertex number base and has N vertices.

In this embodiment the triangles are produced in an order which is far more vertex cache friendly . Specifically the triangles produced are . . .

In essence triangles corresponding to various values of StepSize of the first embodiment are interleaved. Assuming N is sufficiently large triangles are produced corresponding to the following levels at least initially with the pattern . . .

With the ordering produced by the second embodiment and assuming the existence of a 16 entry vertex cache with a FIFO replacement policy the hit rate for say a 120 vertex contour is a respectable 62 which is nearly double that of the first embodiment and on par with a fan or strip.

An example of an apparatus implementing the invention is shown in . The parameters for a contour are supplied to an input buffer . These are read by a state machine which implements the steps described in the pseudo code above.

The state machine has access to a vertex stack. The vertex stack is preferably split into two portions a first portion containing P stack entries and a second portion . The state machine has direct access to the top P entries in the case of triangulation P 3 of the first portion of the vertex stack . Because it is desirable to have parallel read and write access to these three entries these would preferably be implemented as independent registers. The second portion of the vertex stack holds the remaining stack entries and would only require a single read write port and so could be implemented with a cheaper register file with an index to the element that is 4highest on the stack.

There is a read write path between the first portion of the vertex stack containing in this case the top three entries and the remainder of the stack space second portion to allow for pushing and popping of stack data.

Unit also supports the ability to remove or overwrite central elements when P 3 the second from top stack element corresponding to the elements which will be culled or clipped as the contour is processed as described in the pseudo code above. The stack operations are done under the guidance of the state machine. The primitive output unit here a triangle output unit can be instructed by the state machine to select the top three stack elements and output the corresponding triangle.

Using a rendering simulator the cycle counts for filling of the stencil for the arbitrary polygons of using a number of the described triangle generation techniques are compared against each other. Also as a target benchmark the rendering cycles not including pre processing costs of the results of a true triangulation algorithm are supplied. For ease of interpretation the scores are normalised so that the modified fan algorithm scores 1.0. Smaller figures are better. The Sander algorithm is the inventor s interpretation of Sander et al s document.

The second preferred embodiment can further be adapted so that it is unnecessary to know in advance how many vertices are in a particular contour before starting to generate the triangle indices. Such an embodiment would be useful in an application which streams vertices that are generated on the fly . Additionally it can be modified to not require support for indexed triangles in the rendering hardware by also storing vertex coordinates in a wider stack.

Some rendering systems also support the rendering of quads either convex or arbitrary or even M sided arbitrary polygons with say M 16. Either of the presented preferred embodiments can be easily adapted without departing from the scope of the invention to output primitive units other than triangles to suit these more flexible rendering systems.

The invention thus presented on average reduces overdraw improves the triangle shape and or reduces the data required relative to the prior art but one can encounter pathological situations. A very simple case is shown in A . Here the first three vertices v v v form a concavity in the shape as do all the other StepSize 1 triangles as shown in grey in B . After their processing the method effectively still has to fill the large pentagonal region . As can be seen from the figure all these triangles would form a considerable area of overdraw.

The location of the first vertex in was unfortunate . If the embodiments instead received the geometrically equivalent figure shown in A the alternative Stepsize 1 triangles in B would instead be produced. This would leave just the region to be covered by the remaining stepsize triangles and lead to no overdraw at all.

Another embodiment thus attempts to reduce the frequency of these pathological cases. Taking inspiration from Seidel s true triangulation method the alternative embodiment uses a randomisation technique. For each contour a random or pseudo random offset value can be supplied to or computed by the embodiment. This offset is then added modulo N to all the vertex indices in the contour to reduce the likelihood of recurring worst cases.

In some polygon data the vertices themselves may be supplied as an array of arbitrary indices into a vertex array. It should be obvious one skilled in the art that the embodiments presented here can be extended to support such indirection.

In the Adobe flash format the edges of arbitrary polygons are apparently supplied in a random disconnected order. One skilled in the art will realise that a hashing system can be used to reorder these into connected chains before applying the invention described here.

Once the stencil has been set up by drawing the triangulation by the methods above they can be filled shaded textured by any of the known methods known in the art such as those described above i.e. using the bounding box or re use of the triangulation. Furthermore if the winding order of the parent polygon is consistent the additional enhancement presented in this invention may be used whereby the triangulation is resent to the rendering system but instructed to cull triangles with the opposite winding order.

