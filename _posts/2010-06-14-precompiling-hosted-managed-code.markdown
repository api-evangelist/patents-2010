---

title: Pre-compiling hosted managed code
abstract: A hosted pre-compilation system is described herein that provides a way to enable ahead-of-time compilation for managed code running inside a host. The host triggers ahead-of-time compilation at application runtime, after any configuration settings are available. The host can choose which modules to compile, when to compile them, and where to persist the generated images. Upon detecting a module load, the host can trigger pre-compilation, provide the loader an existing pre-compiled image of the module, or do nothing. The runtime/platform validates the integrity of any host-supplied pre-compiled image and provides application programming interfaces (APIs) to inform the host when an image becomes invalid and fails to load. The platform also provides APIs to let the host trigger compilation of binaries at any time relevant to the host, and to generate the images either synchronously or in a background process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08924922&OS=08924922&RS=08924922
owner: Microsoft Corporation
number: 08924922
owner_city: Redmond
owner_country: US
publication_date: 20100614
---
Many applications and libraries are distributed in an intermediate format such as MICROSOFT Intermediate Language MSIL . These intermediate language binaries also known as managed assemblies in the case of MICROSOFT .NET are typically compiled dynamically at runtime in a virtual machine environment using a Just in Time JIT compiler. An alternative to dynamic compilation is pre compilation via Native Generation NGen . NGen generates machine code and runtime data structures from the intermediate language and persists them in files on disk. The images produced by NGen are called Native or NGen images. Unlike JIT compiled code code and data structures in NGen images can be shared across processes. For libraries and frameworks that are typically shared across multiple processes NGen is extremely useful since it minimizes the working set of each managed process. NGen therefore reduces the overall memory utilization of the system. NGen is also very useful for minimizing start up time of client side applications.

Several managed platforms applications are using NGen. Unfortunately however it is quite difficult to use NGen in these current platforms. Since NGen images are created on the end user machine NGen commands are typically chained through the framework application s installer. Typically that involves writing a custom action such as a MICROSOFT WINDOWS Installer action that invokes a command line tool ngen.exe in the case of MICROSOFT .NET . Custom actions are not trivial to write. Moreover NGen images may become invalidated for a variety of reasons such as when the corresponding libraries assemblies are serviced updated and need to be regenerated each time that happens by issuing explicit commands through the command line tool.

Contemporary browsers and other applications allow plug ins which in general comprise hosted software code that interacts with the hosting browser application to provide additional functionality. One reason for using plug ins is to increase security the hosting browser limits the actions that the hosted code which is generally untrusted can perform. The Internet has become very dangerous with malicious websites often attempting to cause a user to download and run harmful code that may damage the user s computer system or destroy the user s data. Thus web browsers often include restrictions on the code that can run and the plug ins that can perform actions on the user s computer system. Plug ins increase the size of the sandbox provided by the browser because they allow more functionality on the web while decreasing the number of untrusted applications installed. One such plug in is MICROSOFT SILVERLIGHT which provides a platform that allows application developers to create rich web applications hosted in the browser that typically include animation vector graphics and or media e.g. audio video content playback. Another example plug in is ADOBE FLASH .

Virtual execution environments typically make it possible for a host application the host itself may be written in native or managed code to customize various aspects of the environment in which the hosted managed code runs. For example the host can specify settings related to security to set up a sandbox and loading dynamically linked libraries DLLs e.g. to indicate where to load DLLs from . Ahead of time compilers like NGen typically do not have access to these settings since they are generated as part of running the host application. For example these settings are not typically known at install time. Current solutions expect a developer to run the host application record the settings and then make that information available to the compiler. Often times there is no supported way to provide this information and even when there is the process is manual and tedious. As a result hosted managed code is typically not pre compiled causing performance and resource usage to suffer.

A hosted pre compilation system is described herein that provides a way to enable ahead of time compilation for managed code running inside a host. The host triggers ahead of time compilation at application runtime after any configuration settings are available. The host can choose which modules to compile when to compile them and where to persist the generated images. This frees the runtime from having to infer application settings schedule the initial compilation work and track when images become invalid and need to be regenerated. Images are generated and regenerated on demand in the context of the application that is going to use them. The hosted pre compilation system identifies whether an application is running inside another host application and lets the host intercept module loads. Upon detecting a module load the host can trigger pre compilation provide the loader an existing pre compiled image of the module or do nothing. The runtime platform validates the integrity of any host supplied pre compiled image and provides application programming interfaces APIs to inform the host when an image becomes invalid and fails to load. The platform also provides APIs to let the host trigger compilation of binaries at any time relevant to the host and to generate the images either synchronously or in a background process. Thus the hosted pre compilation system makes pre compilation possible for hosted applications.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

A hosted pre compilation system is described herein that provides a way to enable ahead of time compilation for managed code running inside a host. The host triggers ahead of time compilation at application runtime after any configuration settings are available. The host can choose which modules e.g. DLLs to compile when to compile them and where to persist the generated images. This frees the runtime from having to infer application settings schedule the initial compilation work and track when images become invalid and need to be regenerated. Images are generated and regenerated on demand in the context of the application that is going to use them. The hosted pre compilation system identifies whether an application is running inside another host application and lets the host intercept module loads. Upon detecting a module load the host can trigger pre compilation provide the loader an existing pre compiled image of the module or do nothing. The runtime platform validates the integrity of any host supplied pre compiled image and provides application programming interfaces APIs to inform the host when an image becomes invalid and fails to load. The platform also provides APIs to let the host trigger compilation of binaries at any time relevant to the host and to generate the images either synchronously or in a background process.

The system can automatically pre compile managed binaries e.g. MSIL Java byte code to machine code when running inside another application host. The system provides the host application complete control over the binaries to pre compile the compilation policy to use and the location where the generated images are stored. The system communicates with the host when given pre compiled binaries are determined to be invalid e.g. because the corresponding DLLs changed their dependencies have changed or the version of the platform they were built against changed . The system triggers pre compilation in the context of the running application and thus the generated images will work correctly in the context of that application. Thus the hosted pre compilation system makes pre compilation possible for hosted applications and allows such environments to have performance on par with non hosted environments by producing native images.

When managed code MSIL or Java byte code for example is running inside another host application a managed runtime e.g. the MICROSOFT .NET Common Language Runtime CLR executes a different code path to load dependent modules e.g. DLLs . As part of its logic to determine whether a given module has a valid pre compiled form the runtime loader lets the host application select a location from which to load a pre compiled binary. The runtime validates the host supplied binary and either loads the binary and executes code as usual or determines the binary is invalid and provides a callback notification to the host. The host can listen to that callback and use a runtime provided API to trigger generation of a new valid pre compiled binary. The host can trigger compilation of binaries with or without such a callback at any time and for any set of binaries.

The generated images are completely under the host s control. The runtime is responsible for reconciling multiple versions or copies of pre compiled binaries existing on a machine e.g. one in the host cache one in a machine wide cache and for ensuring that the loaded image is valid and up to date. The host is responsible for determining when to compile the managed binaries e.g. at application install time application update install time when a specific image is determined to be invalid at load time and so on how to compile them synchronously or asynchronously and managing the generated pre compiled images the size of the store how to quickly retrieve images from the store when to delete or retire images from the store and so forth .

The host detection component determines when application code is running in a hosted environment. Applications may run by themselves e.g. standalone or may be executed by a hosted environment e.g. within an application sandbox . The system can be implemented within a runtime such as the MICROSOFT .NET runtime that is used for both types of applications. The host detection component can detect which application type is running and execute the logic described further herein for hosted environments. Hosted environments present different circumstances because the purpose of the host is often to control security settings accessible resources or impose other application restrictions. The runtime performs logic to respect the host s settings and the host detection component allows the runtime to determine the presence of such a host. In some embodiments the host may directly inform the runtime that the host has provided a hosted environment. In other cases the runtime may automatically detect the hosted environment based on modified security or other settings.

The host interface component provides an interface through which the hosted environment can invoke the system such as to compile images from modules storing intermediate language code. For example the host interface may include an API that allows the host to specify a path to a specific file or directory of files to be compiled from an intermediate language to native binary images for the particular machine on which the binaries are to be run. The host can use the host interface at any time such as upon the occurrence of events that may invalidate previously compiled binary images. For example after the host application receives a software update the application may recompile any previously compiled binaries or after initial installation and execution the host may compile modules into native binary images for the first time. Those of ordinary skill in the art will recognize that the host interface component may present an interface using a variety of programming common techniques and in a variety of programming languages e.g. Component Object Model COM interfaces MICROSOFT .NET classes a web service and so forth .

The host notification component notifies a host upon occurrence of events related to dependent modules used by the host environment. For example the host notification component may notify the host when an image binder loader determines that previously compiled binary images are no longer valid. Images may become invalid for a variety of reasons such as a change in security settings an update received for the module from which the image was compiled an update to one or more platform binary images an update to the host application and so forth. The component also notifies the host when loading modules so that the host can provide a path to a host controlled image cache that stores compiled binary images. The runtime may use the cache to look for previously compiled images and in which to store freshly compiled images used by the host.

The image receiving component receives from the host a path to a location that contains one or more previously compiled binary images. Allowing the host to control where images are stored allows a computer system to include multiple separate hosts operating independently on the same computer system. The host cache also isolates the host from any machine wide cache provided by the platform runtime. Host applications often expect a higher level of isolation than normal application environments and thus may expect a higher level of control over modules used with the host. The image receiving component receives the location where a particular host stores its binary images and looks in the location to determine whether a binary image for a module to be loaded exists. If a binary image exists then the image receiving component invokes the image validation component to determine whether the binary image is valid.

The image validation component determines whether a received binary image is a valid compiled version of a dependent module related to the hosted environment. A binary image is valid when it reflects the output that would be produced by a current compilation of the dependent module using the current settings. If compilation would produce a different binary image then the binary image is no longer valid and will be recompiled. The image validation component may determine whether an image is valid in a variety of ways such as by inventorying all of the input that goes into compiling the image and comparing timestamps that indicate whether any input parameters have changes subsequent to the last compilation of the dependent module. Input may include other modules security or other settings host components and so forth. If any of these have changed then the image validation component may signal that the binary image is no longer a valid compiled version of the dependent module and invoke the compilation component to produce a new binary image.

The compilation component compiles software code written into a particular language into machine executable binary instructions. Compilation is used generally herein and may include multiple steps such as parsing lexical analysis dependency analysis compiling linking and other typical build steps of a software program. The compilation component starts with input in a form that is not natively executable e.g. a programming language or intermediate code and produces output that is natively executable by a physical or virtual machine. The compilation component may store output in a file or format in the image data store e.g. with a filename related to the original dependent module file name or other cache e.g. the global assembly cache GAC or a host controlled cache .

The image storage component stores compiled binary images under control of the hosted environment. For example the compilation component may notify a host through the host notification component upon producing a new binary image so that the host can direct the image storage component to a location to store the binary image. The image storage component communicates with the host to determine where to store compiled images. The host may also provide a storage location on startup or at another time by calling the host interface component .

The image data store is a storage facility provided by the hosted environment for caching compiled binary images related to the hosted environment. The image data store may include one or more files file systems databases cloud based storage services or any other facility for persisting data. The image data store is controlled by the host and allows the host to isolate images used with the hosted environment from other binary images that may be installed on a computer system.

The execution engine provides the context in which applications and dependent modules execute. Depending on the programming language and higher level constructs provided by the programming language the execution engine may be as simple as the operating system s execution of a stream of processor instructions or as complex as a virtual machine environment that decodes and executes instructions in a sandbox. The execution engine executes the compiled binary images provided by the system .

The computing device on which the hosted pre compilation system is implemented may include a central processing unit memory input devices e.g. keyboard and pointing devices output devices e.g. display devices and storage devices e.g. disk drives or other non volatile storage media . The memory and storage devices are computer readable storage media that may be encoded with computer executable instructions e.g. software that implement or enable the system. In addition the data structures and message structures may be stored or transmitted via a data transmission medium such as a signal on a communication link. Various communication links may be used such as the Internet a local area network a wide area network a point to point dial up connection a cell phone network and so on.

Embodiments of the system may be implemented in various operating environments that include personal computers server computers handheld or laptop devices multiprocessor systems microprocessor based systems programmable consumer electronics digital cameras network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and so on. The computer systems may be cell phones personal digital assistants smart phones personal computers programmable consumer electronics digital cameras and so on.

The system may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures and so on that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

Continuing in decision block if the system is operating within a hosted environment then the system continues at block else the system continues at block . Continuing in block the system performs a hosted module load as described further with reference to . The hosted load typically involves searching a host provided module cache and compiling the module under the direction of the hosted environment. Continuing in block the system performs a traditional non hosted module load. The traditional load may include searching a global assembly cache or other machine wide location for storing compiled binary images. After block these steps conclude.

Continuing in block the system validates the stored binary image accessed at the received location. Validation may include determining the settings under which the binary image was compiled and comparing the settings to current settings determining version information about dependencies modules the specified image depends upon or host modules and so forth. The validation determines whether the stored binary image is suitable for execution. If the binary image is not suitable for execution then the system will recompile the module to produce a new binary image. Because compilation can be a time consuming process particularly where many modules are to be loaded the system strategically avoids recompilation using various heuristics.

Continuing in decision block if the system determines that the stored binary image is valid then the system jumps to block and prepares the stored image for execution else the system continues at block to begin the process of producing a new updated binary image. Upon the first run of an application the host may not find any image at all i.e. no previous compile has occurred . This situation is similar to finding an invalid image and is not separately illustrated. Continuing in block the system notifies the hosted environment that the stored binary image is invalid. The host may respond to the notification in various ways. For example the host may ignore the notification altogether store the information that the binary image is invalid for a later scheduled compilation run or immediately direct the system to recompile the module to produce a new binary image. The hosted environment receives the notification through the host interface described herein.

Continuing in block the system receives a host request to generate a new binary image version of the loading module. The system may receive the request to generate the image during the notification of the invalid image or much later. For example the host may periodically recompile any invalid images at a time determined by the host to be appropriate. The system provides the host with control of the decision to compile. Hosted environments perform a variety of tasks for a variety of purposes and may want to avoid recompiling at particular times or under particular conditions. Thus the hosted environment may specify a later time for recompilation that is more appropriate for the host. Upon receiving the request from the host to finally generate a new binary image the system invokes a compiler to produce the image from the particular module.

Continuing in block the system stores the new binary image at a host provided location. The location may include a host cache or other storage facility managed by the host. The host may manage the storage location using its own policies. For example the host may invalidate all of the images stored at the location on a periodic schedule to force regeneration of the images. It is up to the host to determine why and when to produce new images.

Continuing in block the system prepares the image for execution. If the stored image was valid then the stored image is prepared for execution. If the image was newly generated by compiling then the new image is prepared for execution. Preparation for execution varies by programming environment language operating system and or machine architecture but may include steps such as mapping the image into memory fixing up any branch locations allocating memory space and so forth. After preparation for execution the binary image is ready to run or to be invoked by other binary images. After block these steps conclude.

Continuing in block the system receives a binary image generation request from the host. The request may include one or more compilation settings security configuration parameters optimization settings and other information for generating the binary image from the input module. Continuing in block the system determines one or more host environment settings that affect output code associated with the compiled binary image. Some environments such as MICROSOFT .NET provide a trust model that can lead to different binary output depending on a trust level associated with a module. For example the environment may perform additional security checks for APIs called by an untrusted module than for a trusted module. Continuing in block the system locates any module dependencies that affect output code associated with the compiled binary image. For example the module may include import instructions that specify related code stored in dependent modules. The system may use this information during compilation of the subject input module.

Continuing in block the system builds a binary image from the received input module using the determined host environment settings and other information. Building may include converting intermediate code to associated machine native instructions. Intermediate code may run on a virtual machine whereas native instructions run on a physical processor e.g. a central processing unit CPU . Building may produce optimized code based on a detected processor or other environment settings. Continuing in block the system stores the built binary image at the host provided output location for subsequent execution. The host may maintain a cache of built binary images for use in response to module load or execution requests. The system informs the host when a particular binary image is needed and the host can provide any previously built image from the output location.

Continuing in block the system notifies the host that the binary image generation completed. If the build process encountered an error then the system may provide the error in the notification and inform the host that no binary image was produced. For successful builds the host may use the notification to trigger other actions such as executing an application in the hosted environment. After block these steps conclude.

In some embodiments the hosted pre compilation system only precompiles some modules. The decision of whether to precompile a particular image is a performance decision left to the host. The host may have knowledge that affects the decision such as particular modules being updated frequently leading to a decision not to precompile and instead to compile at each use. For other modules such as those that infrequently change the host may opt to precompile so that a binary image is available and does not unduly delay execution of a program that uses the module.

In some embodiments the hosted pre compilation system allows the host to choose synchronous or asynchronous compilation. For some modules the host may decide to wait for compilation to complete such as situations where the host has an immediate use for executing the module. In other cases the host may allow the compilation component to complete at its own schedule and notify the host when compilation is complete e.g. asynchronously .

In some embodiments the hosted pre compilation system receives an indication from the host to discard compiled images when an application changes. The host controls the image data store and may specify points in time to invalidate the cache and purge the compiled binaries. In some embodiments the host may lazily discard images by waiting until the next request for the image determining if it is time to discard the image and if so discarding the image.

In some embodiments the hosted pre compilation system determines where to look for compiled binary images based on a privilege level of an application. For example the system may use a host provided or application provided location for modules that are less privileged but allow more trusted applications to place compiled images in a global assembly cache GAC or native image cache NIC . Placing more compiled images in the GAC allows more applications to share the same compiled binary images thus saving disk space and memory usage if the image can be commonly mapped in memory . However placing images in the GAC can introduce security risks if an application places an image there that does not perform as expected. Thus the system may prefer the GAC for trusted applications but use application supplied caches for less trusted applications.

In some embodiments the hosted pre compilation system provides extra information to the host application. For example the system may allow the host to perform name resolution and request particular versions of modules. A host that wants to use a particular version of a module can then ask for that module. The system tracks full dependency versions and may have multiple versions of the same native image stored on a system at the same time to satisfy host requests.

In some embodiments the hosted pre compilation system allows the host application to disable or further control validation. Validating images can be a time consuming process and some hosts e.g. MICROSOFT SILVERLIGHT OR MICROSOFT ASP.NET may want to skip all or part of validation for certain well defined situations. Accordingly the host may configure the system to skip validation or to notify the host to determine whether to perform validation in a particular case e.g. during load of a particular module .

From the foregoing it will be appreciated that specific embodiments of the hosted pre compilation system have been described herein for purposes of illustration but that various modifications may be made without deviating from the spirit and scope of the invention. Accordingly the invention is not limited except as by the appended claims.

