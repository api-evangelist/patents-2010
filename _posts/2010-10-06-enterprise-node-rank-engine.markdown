---

title: Enterprise node rank engine
abstract: Various methods and systems for calculating ranks of importance of nodes of an enterprise are described. A plurality of relations may be accessed, wherein each relation of the plurality of relations comprises an indication of two nodes of a plurality of nodes, and an indication of a relationship between the two nodes. A matrix may be created using the plurality of relations. The matrix may be processed using the Perron-Frobenius theorem. The plurality of nodes of the enterprise may be ranked according to importance, wherein each node is either a user or an item.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09251157&OS=09251157&RS=09251157
owner: ORACLE INTERNATIONAL CORPORATION
number: 09251157
owner_city: Redwood Shores
owner_country: US
publication_date: 20101006
---
This application is a non provisional of U.S. Provisional Patent Application No. 61 250 846 filed Oct. 12 2009 entitled Rank Engine A System For Calculating Static Ranks By Perron Frobenius Analysis Of Enterprise Activity Graph the entire disclosures of which are incorporated by reference for all purposes. Further this application is related to U.S. patent application Ser. No. 12 899 395 filed Oct. 6 2010 entitled Methods and Systems for Collecting and Analyzing Enterprise Activities and U.S. patent application Ser. No. 12 899 406 filed Oct. 6 2010 entitled Collaborative Filtering Engine the entire disclosures of which are incorporated by reference for all purposes.

When a person uses a search engine she may be looking for specific topics files or persons to name only a few examples. Whether she is searching the Internet a hard drive or an enterprise s network many results may be provided to the person. While these results may be in some way related to the search terms provided by the person the results may contain at least some obscure recommendations that are unlikely to be desired by the person. One possible way of providing more relevant results is by organizing or filtering the results according to a calculated level of importance of each result. Therefore a result determined to have a higher importance level may be presented to the person ahead of a result that has a lower importance level.

In some embodiments a method of calculating ranks of importance of nodes of an enterprise is present. The method may include accessing by a computer system a plurality of relations wherein each relation of the plurality of relations comprises an indication of two nodes of a plurality of nodes and an indication of a relationship between the two nodes and each node is either a user or an item. The method may include creating a matrix using the plurality of relations. The method may include processing the matrix using the Perron Frobenius theorem. The method may include ranking based on the processing of the matrix the plurality of nodes according to importance.

The method may include creating a table of a plurality of identifiers of the nodes and ranks. The method may include pushing the ranking of the plurality of nodes according to importance to one or more search engines. The method may include ordering by the computer system a set of search results at least partially based on the ranks of the nodes of the enterprise. In some embodiments ordering the set of search results at least partially based on the ranks of the nodes of the enterprise further comprises ordering the set of search results at least partially based on a similarity score computed for the nodes. The method may include creating the plurality of relations based on a plurality of events wherein each event of the plurality of events comprises an indication of a source node an indication of a target node and an indication of an action performed by the source node on the target node. In some embodiments the method may include gathering by the computer system the plurality of events from multiple applications of the enterprise.

In some embodiments a computer program product stored on a computer readable storage medium for calculating ranks of importance of nodes of an enterprise is present. The computer program product may comprise instructions for accessing a plurality of relations wherein each relation of the plurality of relations comprises an indication of two nodes of a plurality of nodes and an indication of a relationship between the two nodes. The computer program product may include instructions for creating a matrix using the plurality of relations. The computer program product may include instructions for processing the matrix of the relations. The computer program product may include instructions for ranking based on the processing of the matrix the plurality of nodes according to importance wherein each node of the plurality of nodes is either a user or an item.

In some embodiments a method of calculating ranks of importance of nodes of an enterprise may be present. The method may include creating a plurality of relations based on a plurality of events wherein each event of the plurality of events comprises an indication of a source node an indication of a target node and an indication of an action performed by the source node on the target node. The method may include accessing the plurality of relations wherein each relation of the plurality of relations comprises an indication of two nodes and an indication of a relationship between the two nodes. The method may include processing the plurality of the relations using the Perron Frobenius theorem. The method may include ranking based on the processing of the relations the plurality of nodes according to importance wherein each node is either a user or an item. The method may include creating a table of the nodes and ranks.

When providing a user of a computer system with search results or some other form of recommendation of objects that the user may wish to interact with some of the results provided may be irrelevant to the user. While these results may conform to the search terms provided by the user the results may be less relevant to the user than some other results. For example while two files may contain the same string of text searched for one of the files may represent a company s quarterly report while the other file is a secretary s timesheet. The former file may be determined to be more important and therefore likely to be useful to the user. Therefore it may be more likely that the user conducting the search is likely to be interested in the company s quarterly report rather than the timesheet.

A rank engine may be used to determine the relative importance of objects a object may refer to a user or an item such as a document wikipage spreadsheet etc. as compared with other objects. These rankings may be used to order and or filter search results that are to be provided to the user. The rankings may also be used to order and or filter recommendations of objects that may be provided to a user at a time other than when a search is performed. For example if a user is interacting with a particular document the user may automatically be provided with a listing of one or more other documents that are similar and ranked by importance.

In some situations it may be possible to determine the relative importance of objects by evaluating various links such as hyperlinks that exist between objects. This may work well in the context of the Internet. On the Internet websites and web pages are typically linked to other websites and web pages via hyperlinks. However in the context of an enterprise e.g. a business organization objects residing on the enterprise s computer system may be linked to few if any other objects on the enterprise s computer system. For example it may be rare that one document is linked to any other document on the enterprise s computer system.

However in the context of an enterprise it may be possible to track various events that occur involving objects. An object such as a user may interact with another object such as a document of the enterprise via the enterprise s computer system. For example a user the first object may open a document the second object . Some or all of such events may be logged and stored. An event may contain an action a source object an object that conducts the action and a target object the object that is the recipient of the action . Besides opening many other forms of actions may exist such as closing printing saving editing forwarding adding a contact deleting etc. Events involving such actions may be gathered from one or more different software applications operated by the enterprise. Each event may be associated with two objects and an action. These objects and actions may be used to create a mathematical graph that represents various relations between objects. In such a mathematical graph the objects may be represented by nodes. Therefore a node within such a mathematical graph may correspond to an object which may be an item or a user. The edges of the graph which may be represented as lines connecting various nodes may represent relationships between the nodes. Therefore in the context of a mathematical graph the objects are referred to as nodes with the relationships referred to as edges. For simplicity throughout the remainder of the application objects outside the context of a mathematical graph will also be referred to as nodes.

These events may be processed to identify relations. While an event refers to a specific event that occurred at a finite point in time such as user123 opening file456 at 3 24 PM a relation defines a relationship that may change between nodes. For example a relation may be that user123 has opened file456 twenty seven times. If the user opens file456 again the relation may be modified to state that user123 has opened file456 twenty eight times. Such relations may be present for some or all of the nodes present on an enterprise s computer system. To be clear a node may be either a user or an item which is any type of node besides a user such as a document a file a presentation a wikipage an email a picture etc. As those with skill in the art will recognize many other forms of nodes may be possible. Because links such as hyperlinks may not be available between some or all nodes within an enterprise the measure of importance of nodes may be determined by evaluating relations rather than links.

Such measurements of importance may be performed by a rank engine implemented using either software hardware or firmware. The rank engine may evaluate various relations that have been created based on events that occurred involving pairs of nodes. These relations may be shaped into a form appropriate to be evaluated by the rank engine. This may involve some or all of the relations being used to create a square matrix. The matrix may then have the Perron Frobenius theorem applied to it to find a fixed point representing the ranks of nodes associated with the relations in the matrix. The resulting measure of ranking may be used to order and or filter a list of search results provided to a user or order and or filter a list of recommended nodes provided to the user.

System of may list some or all of the nodes including the users within an enterprise and some or all of the actions and events involving such nodes of the system. Therefore an enterprise s social network representing some or all of the users within an enterprise may be a subset of all of the nodes within system .

Users may represent all of the users that have an account with a computer system of an enterprise. System illustrates three users for simplicity only it should be understood that more or fewer users may be part of system . Each user in system user user and user may be associated with one or more items and or other users with which he has interacted. For example user is linked to items and . Merely by way of example item may represent a document such as a text document or a spreadsheet item may represent a wild or an article within a wild item may represent a webpage and item may represent an email. As those with skill in the art will recognize various other items are possible and the examples of web pages emails documents and wilds are only examples.

For each item that user is associated with the user may also be associated with an action that involved user and the associated item. Referring to item user may be associated with three actions that user performed or was otherwise involved in regarding item . In this example user is associated with three actions an open action a print action and an edit action . These actions and nodes may also be looked at in terms of events. As discussed an event involves two nodes and an action. For example an event may include user item and action . User item and action may represent another event.

User may have the same or different actions associated with other items. For example referring to item the user is associated with an upload action . Actions and may be associated with user and object . Further item may be associated with user and actions . As another example user is also associated item . In the illustrated embodiment user is associated with user .

Referring to user besides being associated with item which is illustrated twice for simplicity once associated with user and once associated with user user may be associated with user . Because both objects and users are nodes whether an action involves a user and an item two users or two items substantially the same relationship may be stored as an event a source the node performing the action an action and a target the node the action is being performed on . Therefore in one event user may be associated with user and action which may involve user being added as a contact or some other action.

It should be understood that only a small portion of the actions involving nodes may be illustrated in system . Besides actions such as open print edit upload copy tag add contact many other actions may be possible such as delete move view save undelete attach delete contact send email to a user receive email from a user like rate etc.

To maintain system the events involving users items and actions may need to be logged and stored. Further these events involving users items and actions may be used to determine the similarity between pairs of users pairs of items and or users and items. These functions may be performed by a system that utilizes computer systems and storage devices such as system of . illustrates a system that may store and analyze various associations between users items and actions.

System may include an event store . Event store may store actions that have occurred involving nodes in the form of events using a computer readable medium such as memory or one or more hard drives. For example if a user views a document at some time event store may store an identifier of the user e.g. his user name the time of the action an identifier of a target item and the type of action. Therefore event store may store a chronology or otherwise organized such as by source node target node or action type of some or all of the actions performed using the computer system of an enterprise.

Event collector may serve to collect or gather events as they occur or in a batch processing arrangement that is performed periodically from various enterprise applications such as Open Usage API . Open Usage API may serve to send or gather events for the event store. Event collector may then store these events using event store . Event collector and or Open Usage API may be configured to interact with a variety of different enterprise applications. For example different steps may need to be performed and or different files accessed in order to determine what emails a user has interacted with as opposed to what wikis a user has edited an article through.

Event store may be accessed by engines . Engines may include a rank engine a Collaborative Filtering Engine CFE a gathering engine and an event activity mapper . The gathering engine and event activity mapper may access and process events stored in event store and store the result of the processed events in relation store . Therefore while event store may contain unorganized or loosely organized events that have involved various nodes gathering engine and event activity mapper may serve to organize those events and determine the similarity of nodes based on those events. Relation store may store various aggregations of events using a computer readable storage medium such as memory or one or more hard drives. For example if there are ten actions in event store indicating a user has opened a document these may be combined and stored as a single relation between the document and the user that indicates the user has accessed the document ten times in relation store . Therefore the relation store may store data from the event store organized into a format that uses multiple events to determine some or all of the relations.

The CFE may represent an engine that determines the similarity between various objects and users. The results output by the CFE such as the similarity scores determined between various nodes may be stored in relation store or in some other location to be used to recommend to a user some node that is similar to a node the user has interacted with. For example the CFE may recommend a similar document to a user based on actions that users have performed involving that document. The CFE may also recommend some other user that has performed actions involving the same or similar nodes as the user. Various CFEs are described in detail in U.S. patent application Ser. No. 12 899 395 filed Oct. 6 2010 entitled Collaborative Filtering Engine.

Nodes may be processed to determine a rank indicating the importance of each node compared to each other nodes. Such a ranking may be performed using software firmware and or hardware. The ranking may be performed by rank engine of or by some other embodiment of a rank engine and may use relations stored in a relation store such as relation store . These ranks may be stored in a search index and may be used to help determine an order in which to return search results. For example the ranks may be used to list nodes that have been determined to be important higher in a listing of search results than nodes that are deemed to be less important.

Search engines may be used to interact with engines including rank engine and CFE . Therefore similarity values computed by CFE may be accessed and used by search engines .

Query Service may comprise one or more software modules. Query API Application Programming Interface receives queries for relation data from other applications. A user may submit a search or some other request through Query API . The Query API queries the gathered relation data possibly stored in relation store and provides relation data to the requesting applications. This may also involve the use of rank engine and CFE . REST API Representational State Transfer Application Programming Interface may be used in conjunction with Query API to interact with and receive information content from a website. The REST API may establish a relationship with various gateways using authentication techniques. REST API may also ensure that JAVASCRIPT hijacking does not occur by ensuring that REST responses are not valid JAVASCRIPT. String parsing may be used to convert text into valid JAVASCRIPT. Event Store QRPP Query Result Post Processor may perform security filtering and metadata provisioning at query time. Therefore after a preliminary list of results has been determined the Event Store QRPP may remove nodes from the list of the results that a user is not permitted to see. Also the Event Store QRPP may add information to the list of results that will be presented to the user such as a name URL description icon IRL etc. for each node on the list of results that will be presented to the user. Multiple different QRPPs may be present.

Additional detail regarding system and various embodiments of methods utilizing a system such as system may be found in U.S. patent application Ser. No. 12 899 395 filed Oct. 6 2010 entitled Methods and Systems for Collecting and Analyzing Enterprise Activities .

System may be used to rank nodes of an enterprise based on relations involving the nodes. illustrates a simplified embodiment of a method for ranking nodes of an enterprise. Such a method may be conducted by a rank engine such as rank engine of . In some embodiments a rank engine or some other software hardware and or firmware other than rank engine of may be used to conduct method .

At block relations may be accessed by the rank engine. These relations may have been created and stored by some other engine. For example a product such as ORACLE s ACTIVITY GRAPH may gather and or collect events from one or more different applications. Applications may send an indication of events that have occurred to an event collector such as event collector of . Some applications may instead store events to a computer readable storage device. If this occurs an engine may periodically retrieve a listing of the events that have occurred involving that application. Whether the events are sent by the applications or gathered from the applications the events may be stored using an event store and processed by some other engine such as a gathering engine to create relations. These relations may be stored in a relation store such as relation store of . These relations may be updated periodically such as once per hour or once per day. These relations may be used to determine a rank of importance of some or all of the nodes represented in the relations. The relations stored on the relation store may be accessed by the rank engine to determine the rank of some such as a particular class such as items or users or all the nodes associated with the stored relations. In some embodiments the relation store may be in the form of a database table linked to the event store. Such a database table may be dynamically updated as events are added to the event store.

At block these relations may be processed to determine the relative rank between nodes. This processing may make use of some algorithm or theorem to determine the relative importance of the nodes based on the relations. One possible theorem that may be used is the Perron Frobenius theorem.

At block based upon the output from the algorithm or theorem used the nodes may be ranked. This rank may be used to identify the relative importance between nodes.

At block events may be used to create and or modify relations. If relations have yet to be created or a full rebuild of the relations is required all relations may be created based on the events present in the event store. If the relations are to be modified the relations may be updated based on events that have been added to the event store since the last time the relations were modified. The creation and modification of the relations may be handled by another piece of software hardware or firmware such as ORACLE s ACTIVITY GRAPH product.

At block a rank engine implemented using software hardware and or firmware may access the relations which are possibly stored on a relation store.

For the relations to be processed the relations may need to be in a particular format. One possible format that may be required is a matrix such as a square matrix. At block the relations accessed at block may be reshaped meaning arranged in a particular format to create a matrix. The matrix that is created may be a square matrix meaning it has the same number of rows as columns.

At block the matrix may be processed according to the Perron Frobenius theorem. The Perron Frobenius theorem may be used to assist in determining the relative importance of nodes by multiplying the matrix repeatedly by an arbitrary starting vector to calculate a measure of rank. A value may be output for each node.

At block the node of the enterprise may be ranked according to the results of the matrix processed in accordance with the Perron Frobenius theorem. At block a table may be created that indicates a measure of rank of each node. This table may include two columns one indicating an identifier of a node and one indicating an associated measure of rank of the nodes. This table may be accessed to determine the importance of nodes as compared with each other.

At block events may be gathered from applications of an enterprise. This may involve receiving events transmitted by one or more applications and or retrieving events from one or more applications. As events occur an application may send events to an event collector such as event collector of . Such an application may be programmed to communicate with an event collector via an API such as Open Usage API . After an event occurs an application may transmit an indication of the event to an event collector via Open Usage or some other API. Upon receiving the event the event collector may store the event in an event store such as event store .

If events are to be retrieved from one or more applications an engine may periodically access a store where an application stores events that have occurred. The engine may retrieve all events that have occurred since the last retrieval of events. These events may also be stored in the event store. At block relations may be created and or modified based on the events. An engine such as gathering engine and or event activity mapper of or some other gathering engine and or event activity mapper may be used to create relations from the events stored in the event store. Such relations may be stored in a relation store such as relation store . More detail is provided regarding system the gathering of events and the creation and modification of relations in related U.S. patent application Ser. No. 12 899 395 filed Oct. 6 2010 entitled Methods and Systems for Collecting and Analyzing Enterprise Activities .

At block some or all of the relations stored possibly on a relation store may be accessed by a rank engine such as rank engine of . The decision of what relations to access may be determined based on what class or classes of nodes are to be ranked. For example a user may specify that only users or only items are to be ranked. Further separate ranking may be produced for the class of users and the class of items. Further it may be possible to rank various subclasses such as specific types of items e.g. only wikipages or only presentations or specific groups of users e.g. only employees in a particular city or only software developers .

Whether some or all of the stored relations are to be used to rank nodes at block a matrix may be created using the relations related to the nodes to be ranked. This may be referred to as reshaping. This may not involve editing the relations but rather rearranging them to form a matrix possibly a square matrix. The form of the matrix may be determined based on the algorithm used to determine the importance of the nodes.

At block the matrix may be processed. This processing may involve applying the Perron Frobenius theorem. According to the Perron Frobenius theorem a solution to a matrix of equations may be found by multiplying the matrix repeatedly by an arbitrary starting vector as long as the matrix s entries are positive and the entries in each column add to one. The output of the application of the Perron Frobenius theorem may result in some value being associated with each node. These values may be used at block to measure the importance of the nodes in according to these values output by the Perron Frobenius theorem. This may involve linking an identifier such as an integer or some other number with each node that indicates a measure of importance of the node. At block a table may be created or updated if the table already exists . This table may be similar to table of .

At block the information contained in the table may be pushed to a search engine such that the information may be used to determine how to present search results to a user.

At block a search request may be received from a user by the search engine. The user may generate a search request using some other application available through the computer system of the enterprise. At block the rankings may be used to filter and or order the search results based on the ranking of the nodes. The ordering of the search results may be partially based on a query dependent score that identifies how much the search query received by the search engine matches the nodes in the search results and partially based on a query independent score such as the rankings of the nodes. The weight provided to the query independent and query dependent scores may be varied. The search results may be determined by some other engine besides the rank engine such as a CFE such as CFE of . Various embodiments of CFEs are described in detail in related U.S. patent application Ser. No. 12 899 395 filed Oct. 6 2010 entitled Collaborative Filtering Engine . Filtering of search results may involve removing one or more results from the search results based on the rank of the node of the search result being below some threshold. In some embodiments the results may be reordered based on the ranks of the nodes of the search results. At block the ordered search results may be provided to the user by the search engine.

It should be understood that besides ordering search results the rankings may be used to order recommendations that are presented to a user. For example if a user is working with a particular node be it another user or an item other similar nodes may be recommended to the user. These recommended nodes may also be filtered and or ordered at least partly based on the rankings determined by the rank engine.

To perform the previously described methods a computer system may be used. Such a computer system may be part of system of . Alternatively a different system involving a computer system may be used to perform the methods and processes described herein. provides a schematic illustration of one embodiment of a computer system . It should be noted that is meant only to provide a generalized illustration of various components any or all of which may be utilized as appropriate. therefore broadly illustrates how individual system elements may be implemented in a relatively separated or relatively more integrated manner.

The computer system is shown comprising hardware elements that can be electrically coupled via a bus or may otherwise be in communication as appropriate . The hardware elements may include one or more processors including without limitation one or more general purpose processors and or one or more special purpose processors such as digital signal processing chips graphics acceleration processors and or the like one or more input devices which can include without limitation a mouse a keyboard and or the like and one or more output devices which can include without limitation a display device a printer and or the like.

The computer system may further include and or be in communication with one or more storage devices which can comprise without limitation local and or network accessible storage and or can include without limitation a disk drive a drive array an optical storage device solid state storage device such as a random access memory RAM and or a read only memory ROM which can be programmable flash updateable and or the like. Such storage devices may be configured to implement any appropriate data stores including without limitation various file systems database structures and or the like.

The computer system might also include a communications subsystem which can include without limitation a modem a network card wireless or wired an infrared communication device a wireless communication device and or chipset such as a Bluetooth device an 802.11 device a WiFi device a WiMax device cellular communication facilities etc. and or the like. The communications subsystem may permit data to be exchanged with a network such as the network described below to name one example other computer systems and or any other devices described herein. In many embodiments the computer system will further comprise a working memory which can include a RAM or ROM device as described above.

The computer system also can comprise software elements shown as being currently located within the working memory including an operating system device drivers executable libraries and or other code such as one or more application programs which may comprise computer programs provided by various embodiments and or may be designed to implement methods and or configure systems provided by other embodiments as described herein. Merely by way of example one or more procedures described with respect to the method s discussed above might be implemented as code and or instructions executable by a computer and or a processor within a computer in an aspect then such code and or instructions can be used to configure and or adapt a general purpose computer or other device to perform one or more operations in accordance with the described methods.

A set of these instructions and or code might be stored on a computer readable storage medium such as the storage device s described above. In some cases the storage medium might be incorporated within a computer system such as the system . In other embodiments the storage medium might be separate from a computer system e.g. a removable medium such as a compact disc and or provided in an installation package such that the storage medium can be used to program configure and or adapt a general purpose computer with the instructions code stored thereon. These instructions might take the form of executable code which is executable by the computer system and or might take the form of source and or installable code which upon compilation and or installation on the computer system e.g. using any of a variety of generally available compilers installation programs compression decompression utilities etc. then takes the form of executable code.

It will be apparent to those skilled in the art that substantial variations may be made in accordance with specific requirements. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets etc. or both. Further connection to other computing devices such as network input output devices may be employed.

As mentioned above in one aspect some embodiments may employ a computer system such as the computer system to perform methods in accordance with various embodiments of the invention. According to a set of embodiments some or all of the procedures of such methods are performed by the computer system in response to processor executing one or more sequences of one or more instructions which might be incorporated into the operating system and or other code such as an application program contained in the working memory . Such instructions may be read into the working memory from another computer readable medium such as one or more of the storage device s . Merely by way of example execution of the sequences of instructions contained in the working memory might cause the processor s to perform one or more procedures of the methods described herein.

The terms machine readable medium and computer readable medium as used herein refer to any medium that participates in providing data that causes a machine to operate in a specific fashion. In an embodiment implemented using the computer system various computer readable media might be involved in providing instructions code to processor s for execution and or might be used to store and or carry such instructions code e.g. as signals . In many implementations a computer readable medium is a physical and or tangible storage medium. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. Non volatile media include for example optical and or magnetic disks such as the storage device s . Volatile media include without limitation dynamic memory such as the working memory . Transmission media include without limitation coaxial cables copper wire and fiber optics including the wires that comprise the bus as well as the various components of the communication subsystem and or the media by which the communications subsystem provides communication with other devices . Hence transmission media can also take the form of waves including without limitation radio acoustic and or light waves such as those generated during radio wave and infrared data communications .

Common forms of physical and or tangible computer readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium punchcards papertape any other physical medium with patterns of holes a RAM a PROM EPROM a FLASH EPROM any other memory chip or cartridge a carrier wave as described hereinafter or any other medium from which a computer can read instructions and or code.

Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to the processor s for execution. Merely by way of example the instructions may initially be carried on a magnetic disk and or optical disc of a remote computer. A remote computer might load the instructions into its dynamic memory and send the instructions as signals over a transmission medium to be received and or executed by the computer system . These signals which might be in the form of electromagnetic signals acoustic signals optical signals and or the like are all examples of carrier waves on which instructions can be encoded in accordance with various embodiments of the invention.

The communications subsystem and or components thereof generally will receive the signals and the bus then might carry the signals and or the data instructions etc. carried by the signals to the working memory from which the processor s retrieves and executes the instructions. The instructions received by the working memory may optionally be stored on a storage device either before or after execution by the processor s .

It should be noted that the methods systems and devices discussed above are intended merely to be examples. It must be stressed that various embodiments may omit substitute or add various procedures or components as appropriate. For instance it should be appreciated that in alternative embodiments the methods may be performed in an order different from that described and that various steps may be added omitted or combined. Also features described with respect to certain embodiments may be combined in various other embodiments. Different aspects and elements of the embodiments may be combined in a similar manner. Also it should be emphasized that technology evolves and thus many of the elements are examples and should not be interpreted to limit the scope of the invention.

Specific details are given in the description to provide a thorough understanding of the embodiments. However it will be understood by one of ordinary skill in the art that the embodiments may be practiced without these specific details. For example well known circuits processes algorithms structures and techniques have been shown without unnecessary detail in order to avoid obscuring the embodiments. This description provides example embodiments only and is not intended to limit the scope applicability or configuration of the invention. Rather the preceding description of the embodiments will provide those skilled in the art with an enabling description for implementing embodiments of the invention. Various changes may be made in the function and arrangement of elements without departing from the spirit and scope of the invention.

Further while the above description is in the context of recommending nodes within the context of an enterprise it should be understood that similar arrangements may utilize actions to make recommendations outside of a single enterprise or business organization.

Also it is noted that the embodiments may be described as a process which is depicted as a flow diagram or block diagram. Although each may describe the operations as a sequential process many of the operations can be performed in parallel or concurrently. In addition the order of the operations may be rearranged. A process may have additional steps not included in the figure. Furthermore embodiments of the methods may be implemented by hardware software firmware middleware microcode hardware description languages or any combination thereof. When implemented in software firmware middleware or microcode the program code or code segments to perform the necessary tasks may be stored in a computer readable medium such as a storage medium. Processors may perform the necessary tasks.

Having described several embodiments it will be recognized by those of skill in the art that various modifications alternative constructions and equivalents may be used without departing from the spirit of the invention. For example the above elements may merely be a component of a larger system wherein other rules may take precedence over or otherwise modify the application of the invention. Also a number of steps may be undertaken before during or after the above elements are considered. Accordingly the above description should not be taken as limiting the scope of the invention.

