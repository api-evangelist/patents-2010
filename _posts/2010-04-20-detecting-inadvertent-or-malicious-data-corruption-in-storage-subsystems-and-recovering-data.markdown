---

title: Detecting inadvertent or malicious data corruption in storage subsystems and recovering data
abstract: Embodiments of the invention detect inadvertent or malicious data corruption and for recovering data including receiving a query specifying corrupted application data; analyzing transaction logs to find update operations related to the data; determining where the data are stored, by mapping the table data to locations within the file system and mapping the file system locations to volume logical blocks; and analyzing snapshot volume bitmaps to determine if the bitmaps show changes to the table data stored in the volume logical blocks. Changes which are reflected in the bitmaps for the data, but which do not have corresponding entries in the transaction logs are flagged as unauthorized changes. Snapshots of the data, from a time prior to the time at which a flagged snapshot was taken, are identified for use in restoring data to its status prior to the unauthorized change.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08315991&OS=08315991&RS=08315991
owner: International Business Machines Corporation
number: 08315991
owner_city: Armonk
owner_country: US
publication_date: 20100420
---
The invention relates generally to data recovery in enterprise computer systems and more particularly to determining when a database object has changed determining if the change was authorized or inadvertent and identifying a non corrupt point in time copy of data to recover.

Data corruption is an important problem for customers of enterprise computer systems. Causes for data corruption may include one or more of application software bugs human configuration errors and physical media errors caused by disks caching controller firmware bugs and or multi path drivers. Another category of errors are inadvertent writes to a device which may be the result of Storage Area Network SAN configuration errors unintentional writes by a privileged user silent disk errors or damage caused by virus attacks and malicious worms. This category of errors will be referred to as inadvertent writes hereinafter.

Errors caused by software bugs human configuration errors and physical media errors collectively referred to as logical errors can be detected and corrected by referring to the logs available at the application tier the middleware tier and the storage tier. However the inadvertent writes cannot be detected and corrected in the same way using available logs. Storage subsystem hardware and storage management software have long provided the ability to make Point In Time copies of data managed by the systems. In order to recover from the logical errors at a production server using Point in Time copy techniques stored volume copies must be accessed and the data as it existed before the error occurred must be used to restore the production system to a state as before the error.

The primary methods of creating a Point in Time copy are the Split Mirror method and the Copy on Write COW method. In the Split Mirror method a traditional RAID 1 mirror is removed from the configuration of the production system and used for some other purpose. In the Copy on Write COW method at the time the Point in Time copy is initiated a bitmap is created to manage regions of the storage sectors tracks or blocks for example . If a region of the original volume is to be modified the original contents of the region are first copied to the storage region allocated to the Point in Time copy. There are also variations of the Copy on Write technique that modify the original volume in order to reduce the number of I O operations required to preserve the integrity of the Point in Time copy such that only changed blocks are copied.

A primary purpose of the various Point In Time copy technologies is to provide a means to quickly recover from logical errors caused by software bugs or human error. One of the most common uses of Point in Time copies is to make backups of enterprise databases. The controller periodically takes a snapshot of the available volumes. At the time of data corruption the database administrator needs to decide on the optimal stored snapshot to use for data recovery. Determining which snapshot is optimal is typically a trade off between data loss a Recovery Point Objective or RPO and the amount of time it takes to get the production system back on line after a failure a Recovery Time Objective or RTO .

As noted above errors caused by software bugs human configuration errors and physical media errors can be detected and corrected by referring to the logs available at the application middleware and storage tiers using any of the existing Point in Time copy techniques.

The present invention provides a method and computer program product for automatically detecting at least one inadvertent write to data to restore comprising steps of receiving a query specifying a corrupt application data set said set comprising data information about at least one corrupt data object and time information temporally locating said corrupt data object locating one or more bitmaps for snapshots for said at least one data object said bitmaps having at least one bitmap entry locating a transaction log for said data objects based on said time information said transaction log having at least one transaction log entry comparing at least one transaction log entry to said at least one bitmap entry for said one or more bitmaps and detecting an inadvertent write when a change to a bitmap entry does not have a corresponding transaction log entry.

Under the present invention transaction log analysis database DB catalog mapping FS LBA mapping and anomaly pattern detection are used to identify unauthorized changes to data and to locate a data snapshot from prior to the changes to be restored. More specifically in response to input of a query specifying application data objects in terms of tables tablespaces indexes data files etc. that have been corrupted the inventive system and method analyze available transaction logs to find all update operations related to the data objects. In addition the system and method determine where the data are stored by mapping the table data to locations within the file system and then mapping the file system locations to volume logical blocks. Snapshots of the logical volume blocks in the form of snapshot volume bitmaps are analyzed to determine if the bitmaps show changes to the table data stored in the volume logical blocks. Changes which are reflected in the bitmaps for the data but which do not have corresponding entries in the transaction logs are flagged as likely to be unauthorized changes. Snapshots of the data from a time prior to the time at which a flagged snapshot was taken can then be identified for use in restoring data to its status prior to the unauthorized change.

At Step the RPS locates the transaction logs for the table. At Step the bitmaps are compared to the transaction logs. If a bitmap indicates a change to a table that is not reflected in the transaction log for that table then the change to the table is presumed to be an unauthorized change i.e. corruption of data caused by the class of errors known as inadvertent writes. At Step a determination is made as to whether an anomaly pattern has been detected the anomaly pattern being an inconsistency between changes noted in the bitmap for the table and transaction log entries for the table. If no anomaly pattern is detected at step the process continues to evaluate other bitmaps i.e. previous or successive bitmaps for the table and the corresponding transaction log information until an anomaly is detected. Once an anomaly is detected a yes determination at decision box the RPS selects at step a snapshot from a point in time prior to the change reflected in the anomalous bitmap for use in restoring the object. The database object is restored at step . As an alternative to the RPS selecting a snapshot the RPS may notify the system administrator of detection of the anomaly and identify and display the best candidate snapshot to recover from the error to the system administrator. The system administrator may then provide input for restoring the object.

The mapping and use of bitmaps is hereinafter described in greater detail with reference to . Applications including Relational Database Management Systems RDBMs store data in extents pages or blocks on disk wherein each disk contains multiple physical disk blocks. A particular database object will be stored at a specific offset on a storage device or file. The Database Management System DBMS maintains a list of pages used by each object so that it may retrieve and update the object data. The page mapping information can be used to determine which storage regions are used by a particular object table.

In most environments the sizes of application pages and storage regions do not necessarily match. For example the default block size for DB2 for Linux UNIX and Windows is 32K while the monitored storage region for XIV Nextra Storage Subsystem is 1 MB. For Oracle RDBMs the default page size is 8K while a monitored storage region for IBM FlashCopy is 32K. This may lead to some uncertainty regarding which block within a storage region was modified at a specific time. However if a region occupied by a specific database object was not modified i.e. the bitmap for this region indicates no change then the snapshot is a candidate for recovering the object before modification.

Correlating database tables to files is a task made possible by various existing Database Application Programming Interfaces DB APIs . Mapping a file to its corresponding logical blocks involves multiple steps due to multiple levels of mapping indirection that exist in the stack. shows a simplified overview of an example file table1.db being mapped to corresponding logical blocks of Volume Logical Blocks from which a Snapshot Volume Bitmap is made. Entries and are mapped to blocks from 8 24 bytes of the 512 bytes of the Volume Logical Blocks . Similarly table entries and map to k through k 8 and k 8 through k 16 respectively and entry 990 maps to the block n to n 8. Steps involved in this mapping process include mapping a file to corresponding File System FS blocks and mapping FS blocks to corresponding Volume Logical Block Addresses LBAs . The Volume Logical Blocks are mapped to the partitions or slices at the storage location.

Different File System specific tools are typically used in the recovery domain to provide mechanisms for retrieving FS mapping information. Debugfs is one such commonly used utility on Linux systems. When executed on an ext3 file system the command debugfs c R stat absolutePathName dev devName outputs the file system blocks for the specified file where absolutePathName is the name of the file for which the mapping information is required and devName is the device name of a block disk device e.g. dev sda dev sdb etc. .

As noted above the mapping of file system blocks to volume logical blocks may or may not be a one to one mapping. For instance a typical file system block size is 4K whereas logical unit LUN block size as configured in disk arrays is typically anywhere between 512B and 512 KB. Storage controller level caching and other information lifecycle management ILM schemes are optimized for the LUN block size and hence the need for a level of indirection. In XIV Nextra storage system the Volume LUNs exported by XIV have a logical block size of 512B. In such systems if FS block size is 4K then FS block on the file system would correspond to logical block addresses LBAs . . . .

As detailed above snapshot volume bitmaps of volume logical blocks are periodically made and can be used to track changes to the underlying stored data. Reference numeral of illustrates a snapshot volume bitmap stored for the volume logical blocks shown at . A snapshot volume bitmap is typically a bit array with each bit representing some sort of status information about its corresponding logical block. As shown in a set bit i.e. a bit having a 1 value in a location in the bit array indicates that the corresponding LBA has changed since the time of taking the snapshot. At creation of the source volume the bitmap contains all 0s in its bitmap sections A through D as shown at . When a change is made to the source volume a new snapshot is taken for storage at and a new bitmap is generated and stored. Bitmap taken at time T shows a bit change from 0 to 1 in the bitmap section B which corresponds to the modified region of the source volume. At time T bitmap shows that additional changes have been made to another region D of the source volume. Finally at time Tn three 1s in bitmap indicate changes to three of the four regions represented by the bitmap sections A B and D.

Once the file to file system block mapping has been completed and the subsequent mapping of the FS block to the volume LBA has been done the association between a file and a subset of bits in the snapshot volume bitmap can be inferred. Snapshot volume bitmaps for the table query input for the relevant time frame such as bitmaps and for times T to Tn can be compared with the corresponding transaction logs for the table for the relevant time period to detect any anomaly patterns.

Most relational databases provide a mechanism for reading transaction log entries. For DB2 an Application Programming Interface API called db2ReadLog provides this function. It requires a starting and ending Log Sequence Number LSN which is a unique log record identifier representing the relative byte address of the log record within the database log. The db2ReadLog API returns a Log Manager Header shown in Table 1 below and data for entry at the data manager transaction manager utility manager and log data manager entries. For transaction manager log entries each transaction is identified by a unique Transaction Identifier TID . The log entry for a transaction also includes the time at which the transaction was committed. Corresponding Data Manipulation Language DML actions for this transaction will be chained together using the TID in the Log Manager header of each Data Manager Log record in the transaction. The Data Manager Log record contains both the table ID and the tablespace ID of the table affected by the DML action.

One operation that may not be logged is the bulk load of a table from a text file. There are parameters in the Load command that will cause the table load data to be logged. However even though the actual data may not be logged in the Transaction Manager Log a Utility Manager Log record entry shown in Table 3 will be created to indicate the start of a table load. Although there is no date time in the Utility Manager Log record for a table load certainly some bounds on the start time can be established by examining the date time of the transaction immediately preceding and following the table load log record to verify an authorized change.

The foregoing technique can be used to identify the point at which the storage region corresponding to a database table was modified without a corresponding transaction log entry. This would indicate an inadvertent write to the device or file by a privileged user. In each of these cases the transgression can be detected and a snapshot suitable for recovery can be identified.

The methodologies of embodiments of the invention may be particularly well suited for use in an electronic device or alternative system. Accordingly the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer usable or computer readable medium s may be utilized. The computer usable or computer readable medium may be a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic or semiconductor system apparatus device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

Program code stored on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wire line optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

The present invention is described above with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions.

These computer program instructions may be stored in a computer readable medium that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instruction means which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

For example is a block diagram depicting an exemplary processing system formed in accordance with an aspect of the invention. System may include a processing device memory coupled to the processor e.g. via a bus or alternative connection means as well as input output I O circuitry operative to interface with the processor. The processor may be configured to perform at least a portion of the methodologies of the present invention illustrative embodiments of which are shown in the above figures and described herein.

It is to be appreciated that the term processor as used herein is intended to include any processing device such as for example one that includes a central processing unit CPU and or other processing circuitry e.g. digital signal processor DSP microprocessor etc. . Additionally it is to be understood that the term processor may refer to more than one processing device and that various elements associated with a processing device may be shared by other processing devices. The term memory as used herein is intended to include memory and other computer readable media associated with a processor or CPU such as for example random access memory RAM read only memory ROM fixed storage media e.g. a hard drive removable storage media e.g. a diskette flash memory etc. Furthermore the term I O circuitry as used herein is intended to include for example one or more input devices e.g. keyboard mouse etc. for entering data to the processor and or one or more output devices e.g. printer monitor etc. for presenting the results associated with the processor.

The flowchart and block diagrams in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings it is to be understood that the invention is not limited to those precise embodiments and that various other changes and modifications may be made therein by one skilled in the art without departing from the scope of the appended claims.

