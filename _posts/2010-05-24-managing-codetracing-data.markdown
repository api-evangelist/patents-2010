---

title: Managing code-tracing data
abstract: A method of managing code-tracing data is described. The method comprises the steps of: receiving code-tracing data from an executing software component; adding the received code-tracing data to a log stored in temporary storage; detecting a property of the received code-tracing data; copying the log to non-volatile storage when the property matches a defined trigger property; and deleting contents of the log according to a caching policy when the property does not match a defined trigger property.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08499200&OS=08499200&RS=08499200
owner: NCR Corporation
number: 08499200
owner_city: Duluth
owner_country: US
publication_date: 20100524
---
To improve fault detection in software software engineers typically add instrumentation code to software components application software drivers and the like so that code tracing data is generated automatically by the instrumentation code as the software components execute. The instrumentation code typically generates code tracing data when certain functions are performed status changes occur and the like. A trace manager is used to store the code tracing data generated by the instrumentation code in a log file.

If a fault occurs then the log file can be analyzed to identify the cause of the fault. For example the code tracing data may indicate if any unexpected events occurred or if any expected events did not occur prior to the fault occurring.

Although generating and storing code tracing data has clear advantages there are also problems associated with managing code tracing data.

One problem is that instrumentation code can produce a large amount of code tracing data every second which consumes valuable storage space and may slow down the operation of the software as the log file is written to disk. Furthermore the large quantity of code tracing data produced makes it difficult to identify the code tracing data that is relevant to an error. Other errors may be detected that are irrelevant to and may obscure the error being targeted.

It would be advantageous to overcome or mitigate some of these disadvantages or other disadvantages associated with managing code tracing data.

Accordingly the invention generally provides methods systems apparatus and software for managing code tracing data.

In addition to the Summary of Invention provided above and the subject matter disclosed below in the Detailed Description the following paragraphs of this section are intended to provide further basis for alternative claim language for possible use during prosecution of this application if required. If this application is granted some aspects may relate to claims added during prosecution of this application other aspects may relate to claims deleted during prosecution other aspects may relate to subject matter never claimed. Furthermore the various aspects detailed hereinafter are independent of each other except where stated otherwise. Any claim corresponding to one aspect should not be construed as incorporating any element or feature of the other aspects unless explicitly stated in that claim.

According to a first aspect there is provided a method of managing code tracing data the method comprises the steps of 

deleting contents of the log according to a caching policy when the property does not match a defined trigger property.

The defined reference may identify the software containing the instrumentation code that generated the defined category.

The defined reference may be associated with a component such as a service provider or a driver an object within a component such as a framework device controls or the like or code within an object such as a function or routine . The defined reference may be selected at the desired level of granularity.

The defined category may be selected from an error category a function entry point category a function exit point category a general category an information category a warning category an event category and the like. In some embodiments it may be desirable to use an error category as the defined category. In some embodiments it may be desirable for the defined trigger property to consist of an error category so that copying the log to non volatile storage will be triggered whenever an error category is created by any instrumentation code.

The caching policy may be based on a fixed number of bytes stored in the log so that the earliest code tracing data is deleted whenever the log reaches the fixed number of bytes.

The caching policy may be based on time so that code tracing data is deleted whenever it is older than a fixed time period for example two hours.

The caching policy may be based on the number of entries stored so that the earliest code tracing data is deleted whenever the log reaches the fixed number of entries.

The step of deleting contents of the log according to a caching policy when the property does not match a defined trigger property may involve not deleting any contents of the log if the caching policy does not require any contents to be deleted.

The step of detecting a property of the received code tracing data and the step of copying the log to non volatile storage when the property matches a defined trigger property may be implemented prior to during or subsequent to the step of adding the received code tracing data to the log stored in temporary storage.

The method may be implemented when at least one client or session does not request code tracing data. Alternatively the method may be implemented even if all clients all sessions request code tracing data.

The method may further comprise permanently storing code tracing data in a file for any client such as a thread in the software component requesting such storage. This file is separate from the log and is not subject to the caching policy.

The step of deleting contents of the log according to a caching policy when the property does not match a defined trigger property may be implemented prior to during or subsequent to the step of detecting a property of the received code tracing data.

According to a second aspect there is provided a system for managing code tracing data the system comprising 

a trace manager arranged to i receive code tracing data from an executing software component ii add the received code tracing data to a log iii detect a property of the received code tracing data iv copy the log to non volatile storage if the property matches a defined trigger property and v delete contents of the log according to a caching policy.

The trace manager may be implemented by a CEN XFS compliant software component. Alternatively the trace manager may be implemented by a proprietary code tracing data storage component.

The executing software component that transmits code tracing data may comprise an XFS service provider.

According to a third aspect there is provided a computer program comprising program instructions for executing the steps of the first aspect.

The computer program may be stored on a computer readable medium such as a computer memory an input output data storage device such as a magnetic or optical disk or a Flash storage drive or the like.

According to a fourth aspect there is provided a computer data signal embodied on a carrier wave encoding instructions that when executed on a processor implement the method of the first aspect.

According to a fifth aspect there is provided a self service terminal comprising a plurality of modules for providing transaction related functions to a customer of the self service terminal and a controller coupled to the modules and executing a runtime platform including a trace manager the trace manager being arranged to a receive code tracing data from an executing software component b add the received code tracing data to a log stored in volatile storage c detect a property of the received code tracing data d copy the log to non volatile storage if the property matches a defined trigger property and e delete contents of the log according to a caching policy.

According to a sixth aspect there is provided a method of managing code tracing data the method comprises the steps of 

copying the trace log to non volatile storage when the received code tracing data relates to an error category and

For clarity and simplicity of description not all combinations of elements provided in the aspects recited above have been set forth expressly. Notwithstanding this the skilled person will directly and unambiguously recognize that unless it is not technically possible or it is explicitly stated to the contrary the consistory clauses referring to one aspect are intended to apply mutatis mutandis as optional features of every other aspect to which those consistory clauses could possibly relate.

These and other aspects will be apparent from the following specific description given by way of example with reference to the accompanying drawings.

Reference will now be made to which is a simplified schematic diagram showing an SST memory executing software components. In this embodiment the SST is an ATM. The software components comprise a control application and a runtime platform .

As is known in the art the control application presents a sequence of screens on an ATM display to a customer at the ATM collates information from the customer for example customer account information from a customer s ATM card transaction request and the like obtains authorization for a transaction request from a remote authorization host not shown and instructs modules within the ATM as needed to fulfill an authorized transaction.

As is also known in the art the control application also comprises a conventional CEN XFS interface for communicating with a trace manager in the form of an XFS manager described as box below in the runtime platform . CEN is the European Committee for Standardisation and XFS is the eXtensions for Financial Services standard. The current version of this CEN XFS standard is v.3.10.

It should be appreciated that the XFS manager provides many more functions than merely managing traces. For example the XFS manager provides services to clients applications or threads of applications .

The control application is capable of creating and maintaining multiple sessions as illustrated by ellipses

The runtime platform comprises proprietary device drivers only three of which are illustrated an operating system an XFS manager and XFS service providers

In this embodiment the operating system is a Windows XP trade mark operating system available from Microsoft Corporation trade mark . The operating system includes a plurality of standard device drivers for interfacing with standard computing devices such as a magnetic disk drive a display USB ports serial ports a parallel port and such like. As is well known in the art the operating system is responsible for memory process task and disk management and includes routines for implementing these functions.

The proprietary device drivers are a set of APTRA trade mark XFS components available from NCR Corporation 3097 Satellite Blvd. Duluth Ga. 30096 U.S.A. The device drivers provide a range of programming facilities specific to self service terminal devices and services.

One function of the device drivers is to enhance the operating system so that the operating system and device drivers together provide high level access to all of the devices and modules including both standard home computing devices via the operating system and XFS computing devices via the run time components . Thus the combination of the device drivers and the operating system can be viewed as providing a complete ATM operating system.

The device drivers interface with self service specific devices and include support files not shown to allow each device or module to be operated tested maintained and configured. Although only a few device drivers are shown there are many device drivers one for each self service specific module such as a card reader not shown a receipt printer not shown an encrypting keypad not shown and FDKs not shown and a cash dispenser not shown . Furthermore there are many more devices and modules in an ATM than those described herein for example there are more standard computing devices such as USB ports and a parallel port there may also be more self service devices and modules such as a statement printer a cash accept module and the like. These devices and modules are not discussed herein because they are not essential to an understanding of the invention.

The XFS manager includes an XFS application programming interface API a service provider interface SPI configuration data and a cache .

The service providers communicate with the XFS manager and also with the self service device drivers and the standard device drivers associated with the modules. Suitable service providers are available from NCR Corporation Satellite Blvd. Duluth Ga. 30096 U.S.A.

The service providers provide a high level of abstraction to allow the control application to issue standard XFS commands to request functions and services. The service providers translate these XFS commands for the particular device drivers used in the runtime platform . Each service provider is typically associated with one module such as a cash dispenser module .

Each of the multiple sessions is capable of initiating and maintaining independent communication with the same service provider .

Reference will now be made to which is a block diagram illustrating one of the service providers in more detail. In this embodiment service provider is associated with a cash dispenser.

The cash dispenser service provider comprises a framework portion which is identical for all of the service providers a software development kit SDK portion which is also identical for all service providers and a device control portion . The cash dispenser service provider is a component according to the terminology used herein and the framework portion SDK portion and device control portion are all objects according to the terminology used herein . As is known in the art when each of these objects registers with the XFS manager each object provides the XFS manager with a reference. This reference identifies the object to the XFS manager .

The SDK portion provides a set of application programming interfaces APIs between the framework portion and the device control portion . The SDK portion ensures that the device control portion is implemented to a specific contract so that the device control portion operates in unison with the framework portion .

The device control portion is unique for each service provider and includes device driver functionality for the device associated with that service provider . The device control portion also includes function implementing code

The function implementing code is illustrated as a plurality of individual boxes. This is merely to illustrate that there is code within the service provider providing discrete functions implemented by the cash dispenser.

The framework portion the SDK portion and the device control portion all include instrumentation code which is illustrated in as an ellipse.

In this embodiment function implementing code implements a banknote dispense function and function implementing code implements a banknote retract function.

The instrumentation code provides checkpoints trace lines and other diagnosis tools. Whenever one of the functions for example the banknote dispense function is called then a trace line in the instrumentation code for that function creates data to indicate i the client thread that called the function ii when the function was called iii the name of the function called and iv the names and values of the parameters input to the function and output from the function.

The service provider creates a code tracing object populated with i the created data ii the reference identifying the object for example the device control portion incorporating the trace line in the instrumentation code that created the code tracing object and iii a category for the created data.

The reference is included so that the code tracing object identifies the software that caused the code tracing object to be created or more accurately the software containing the instrumentation code that created the code tracing object .

The category indicates what type of data is included in the code tracing object. For example the category may be one of the following entry point exit point general data information warning or error. The category is created automatically based on the type of instrumentation code that created the data.

The category is a property of the code tracing object. The reference is also a property of the code tracing object.

The service provider pushes this created code tracing object which contains code tracing data to the XFS manager using a conventional XFS command WFMOutputTraceData .

Each session can request the XFS manager to store the code tracing data which is data extracted from the code tracing object in a log file using either the WFSSetTraceLevel XFS API call or when a session is opened with the service provider . This log file is typically stored on permanent I O storage within the ATM not shown such as a disk drive. The configuration information stores the name and path of this log file which by default is xfstrace.log . However due to the adverse impact in performance caused by saving the code tracing data in a log file the sessions may not request the XFS manager to save the code tracing data.

In this embodiment even if the sessions do not request the XFS manager to save the code tracing data as a log file the XFS manager saves the code tracing data to a cache within the ATM memory . The code tracing data that is stored in the cache is referred to herein as buffered data . Since the code tracing data is being saved to main memory rather than I O storage any adverse effect on performance is minimal.

When the XFS manager stores the code tracing data to the memory it detects from the code tracing object the properties of the code tracing data including the reference and the category to which the code tracing data belongs.

If one or more of the properties matches a defined trigger property then the XFS manager transfers the buffered data from memory to I O storage for subsequent retrieval and analysis. In this embodiment the defined trigger property is that the category is an error category regardless of the value of the reference property.

To prevent the buffered data from getting too large the XFS manager implements a caching policy. In this embodiment the caching policy is based on the number of bytes stored in the memory . The XFS manager does not allow the buffered data to exceed the predefined data size limit. In this embodiment the predefined data size limit is one megabyte. If the buffered data approaches this limit then the XFS manager deletes the earliest entries to ensure that this limit is not exceeded.

The buffered data is separate from and independent of any log file such as xfstrace.log stored in response to a session requesting permanent storage of code tracing data.

The service providers are typically able to maintain multiple independent sessions so that if one session requests storage of code tracing data but another session requests that code tracing data should not be stored the XFS manager maintains the buffered data in the cache for code tracing data relevant to the session that does not want permanent storage and maintains a disk file such as xfstrace.log stored on I O storage for code tracing data relevant to the session that does want permanent storage. Since the two sessions may be performing different functions different instrumentation code may be executed for each so the buffered data may be different to the code tracing data in the xfstrace.log file.

If an error occurs then the buffered data is written to disk as a file referred to as the buffer file and a person can analyze both the xfstrace.log file for session and the buffered file for session . This is useful because prior art systems would not store the code tracing data associated with session even though the error may have been caused by that session rather than the session that requested storage of the code tracing data.

It will now be appreciated that the above embodiment has the advantage that code tracing data that would otherwise be discarded is retained but kept to a manageable size based on deleting the oldest code tracing data. This ensures minimal impact on performance. Furthermore if an error occurs the code tracing data prior to that error occurring is copied to permanent storage for subsequent analysis so that the most important data is not lost.

This embodiment ensures that trace information code tracing data leading up to an error in a real time software component can always be obtained even if storage of code tracing data has not been requested.

Various modifications may be made to the above described embodiment within the scope of the invention for example in other embodiments the SST may not implement the CEN XFS standard. In such embodiments a proprietary trace manager may be provided.

In other embodiments the self service terminal may be an information kiosk a financial services centre a bill payment kiosk a lottery kiosk a postal services machine a check in and or check out terminal such as those used in the retail hotel car rental gaming healthcare and airline industries or the like.

In other embodiments different caching policies may be used based on how long the code tracing data has been stored the number of entries stored a combination of these or any other convenient policy. Even if the total storage size caching policy is used the predefined log file size limit may be different to larger or smaller than one megabyte.

In other embodiments different categories may be used than those described above. A higher or lower number of categories may be used.

A defined trigger property may comprise a sequence of multiple properties each property linked by a Boolean relationship such as AND OR NOT and the like to the other properties in the sequence.

In other embodiments a property other than or properties in addition to an error category may be used as a trigger property. For example in other embodiments a defined trigger property may comprise i a specific reference for example corresponding to the device control portion and ii an error category so that storage of the log is only triggered by an error category for object data created by instrumentation code within the device control portion . In other embodiments there may be a Boolean OR relationship between different properties so that a trigger occurs if either property is present.

In the above embodiment the software components including instrumentation code comprise service providers. In other embodiments the software components including instrumentation code may comprise applications executing in the environment of an operating system and or a runtime platform.

The steps of the methods described herein may be carried out in any suitable order or simultaneously where appropriate. The methods described herein may be performed by software in machine readable form on a tangible storage medium or as a propagating signal.

The terms comprising including incorporating and having are used herein to recite an open ended list of one or more elements or steps not a closed list. When such terms are used those elements or steps recited in the list are not exclusive of other elements or steps that may be added to the list.

Unless otherwise indicated by the context the terms a and an are used herein to denote at least one of the elements integers steps features operations or components mentioned thereafter but do not exclude additional elements integers steps features operations or components.

