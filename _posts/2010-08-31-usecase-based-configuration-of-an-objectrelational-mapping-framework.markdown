---

title: Use-case based configuration of an object-relational mapping framework
abstract: Systems, methods, and computer program products are disclosed for configuring an object-relational mapping framework. The object-relational mapping framework may monitor, in the context of a use case of an application, fetching of data from a relational database and accessing of the fetched data by the application. The object-relational mapping framework may be configured based on the monitored activity.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08489647&OS=08489647&RS=08489647
owner: International Business Machines Corporation
number: 08489647
owner_city: Armonk
owner_country: US
publication_date: 20100831
---
Embodiments of the invention relate generally to techniques for object relational mapping and more specifically to configuring an object relational mapping framework.

Databases are computerized information storage and retrieval systems. The most prevalent type of database is the relational database a tabular database in which data is defined so that it can be reorganized and accessed in a number of different ways.

Regardless of the particular architecture in a database management system DBMS a requesting entity e.g. an application or the operating system demands access to a specified database by issuing a database access request. Such requests may include for instance simple catalog lookup requests or transactions and combinations of transactions that operate to read change and add specified records in the database. These requests are made using high level query languages such as the Structured Query Language SQL . Illustratively SQL is used to make interactive queries for getting information from and updating a database such as International Business Machines IBM DB2 Microsoft s SQL Server and database products from Oracle Sybase and Computer Associates. The term query denominates a set of commands for retrieving data from a stored database. Queries take the form of a command language that lets programmers and programs select insert update find out the location of data and so forth.

Embodiments of the invention provide a computer implemented method computer program product and system for performing an operation during execution of an application that accesses a relational database using an object relational mapping ORM framework. The operation also includes monitoring activity comprising i fetching of data from the relational database by the ORM framework for a use case of the application and ii accessing of the fetched data by the use case of the application wherein the use case represents a unit of work performed by the application. The operation also includes configuring a manner in which the ORM framework fetches data from the relational database based on the monitored activity during execution of the application and without having to restart the application.

Embodiments of the present invention generally provide techniques for bridging an object relational impedance mismatch between a relational model and an object oriented model. The object relational impedance mismatch arises from differences in how data is represented under the relational model and under the object oriented model. Under the relational model data is exposed in the form of tables having rows and columns and according to a relational schema that specifies the structure of the tables and relationships between the tables. Under the object oriented model data is exposed in the form of a collection of interacting objects that exhibit object oriented characteristics such as inheritance and polymorphism. As is known inheritance refers to a process in which a class inherits state and behavior of another class thereby giving rise to a hierarchy of classes. Polymorphism refers an ability of objects belonging to different types to respond to function calls of the same name while providing distinct type specific behavior. Polymorphism also provides that the exact type of the object need not be known in advance instead the behavior of the object may be determined at run time.

To bridge the impedance mismatch between the relational model and the object oriented model an object relational mapping ORM framework is provided and used by an application to access data stored in a relational database. The ORM framework automates data conversions from the relational model to the object oriented model and vice versa. Accordingly by using the ORM framework the developer of the application need not write any source code for performing the data conversions. As a result the productivity in developing the application may be improved.

In one embodiment during execution of the application the ORM framework may configure how the ORM framework fetches data from the relational database. In doing so performance of the application and or of the relational database may be improved. The configuration of the ORM framework occurs without requiring any restart of the application. Further the configuration of the ORM framework may vary dynamically over time to suit a corresponding use case of the application where the use case also varies dynamically over time. Each use case of the application represents a distinct logical unit of work that is being performed by the application. Each use case may be defined by a developer of the application and uniquely identified by the ORM framework during execution of the application. Further each use case of the application may be correlated with a distinct pattern of fetching and or accessing data. Accordingly dynamically configuring of the ORM framework based on each occurring use case may result in improved performance of the application and or the relational database. In particular the performance may be improved relative to applying a single configuration of the ORM framework to all use cases of the application. Further the developer of the application need not attempt to determine a suitable configuration of the ORM framework for each use case of the application from sifting through voluminous amounts of stack trace information which can be tedious and error prone in some cases.

In the following reference is made to embodiments of the invention. However it should be understood that the invention is not limited to specific described embodiments. Instead any combination of the following features and elements whether related to different embodiments or not is contemplated to implement and practice the invention. Furthermore although embodiments of the invention may achieve advantages over other possible solutions and or over the prior art whether or not a particular advantage is achieved by a given embodiment is not limiting of the invention. Thus the following aspects features embodiments and advantages are merely illustrative and are not considered elements or limitations of the appended claims except where explicitly recited in a claim s . Likewise reference to the invention shall not be construed as a generalization of any inventive subject matter disclosed herein and shall not be considered to be an element or limitation of the appended claims except where explicitly recited in a claim s .

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The computer generally includes a processor connected via a bus to a memory a network interface device a storage an input device and an output device . The computer is generally under the control of an operating system . Examples of operating systems include UNIX versions of the Microsoft Windows operating system and distributions of the Linux operating system. More generally any operating system supporting the functions disclosed herein may be used. The processor is included to be representative of a single CPU multiple CPUs a single CPU having multiple processing cores and the like. Similarly the memory may be a random access memory. While the memory is shown as a single identity it should be understood that the memory may comprise a plurality of modules and that the memory may exist at multiple levels from high speed registers and caches to lower speed but larger DRAM chips. The network interface device may be any type of network communications device allowing the computer to communicate with other computers via the network .

The storage may be a persistent storage device. Although the storage is shown as a single unit the storage may be a combination of fixed and or removable storage devices such as fixed disc drives floppy disc drives tape drives removable memory cards or optical storage. The memory and the storage may be part of one virtual address space spanning multiple primary and secondary storage devices.

The input device may be any device for providing input to the computer . For example a keyboard keypad light pen touch screen track ball or speech recognition unit audio video player and the like may be used. The output device may be any device for providing output to a user of the computer . For example the output device may be any conventional display screen or set of speakers along with their respective interface cards i.e. video cards and sound cards not shown . Although shown separately from the input device the output device and input device may be combined. For example a display screen with an integrated touch screen a display with an integrated keyboard or a speech recognition unit combined with a text speech converter may be used.

As shown the memory of the computer includes an application an ORM framework and a DBMS . The storage of the computer includes a relational database . The DBMS manages the relational database . The ORM framework communicates with the DBMS to retrieve data from the relational database . The ORM framework also converts data between the relational model and the object oriented model. The application may be any object oriented application that accesses data stored in the relational database . By using the ORM framework to access the data stored in the relational database the application need not include code for converting data between the object oriented model and the relational model instead such conversions are provided by the ORM framework . Depending on the embodiment some or all of the functionality of the ORM framework may be integrated into the DBMS .

As shown the application includes an object hierarchy and use cases . The object hierarchy defines the types of objects used by the application and defines relationships between the objects. Depending on the embodiment the object hierarchy may include only one root object or multiple root objects. Each type of object or class of object is represented as a node in the object hierarchy and each relationship is represented as an edge in the object hierarchy . Depending on the embodiment on or more objects rather than types may also be represented in the object hierarchy . The object hierarchy may also be referred to as a domain model for the application and may correspond to a Unified Modeling Language UML class diagram or object diagram. As described above the use cases each represent a distinct logical unit of work performed by the application and each of the use cases may be defined by a developer of the application and identified by the ORM framework . In one embodiment each use case causes at least one query to be issued against the relational database . However a use case may often cause multiple queries to be issued.

In one embodiment relationships between objects in the object hierarchy may include different types of relationships used in domain modeling. Types of relationships used in domain modeling may include without limitation association composition aggregation generalization realization dependency and multiplicity. In domain modeling an association represents a relationship between two associated classes e.g. classes that interact with one another . For example to model academic departments offering academic courses the object hierarchy may include an Offers relationship between a Department class and a Course class. Aggregation represents a relationship in which a first object is part of a second object where the life cycle of the first object is not dependent on the life cycle of the second object. Composition represents a relationship in which in which a first object is part of a second object where the life cycle of the first object depends on the life cycle of the second object. Generalization represents a relationship in which a first class is considered to be a generalized form of a second class. Depending on the embodiment generalization represents inheritance between classes. For example a Mammal class may be considered a generalized form of a Human class. Realization represents a relationship between an interface class and a component class in which functionality defined in the interface is realized by the component. Dependency represents a relationship between a first class and a second class where the first class uses the second class during execution of the application . For example the second class may be a parameter variable or local variable of a method of first class. Further one or more of the relationships described above may include an indicator of multiplicity which specifies whether the relationship is one to one one to many or many to many relationship etc.

As shown the ORM framework includes monitored activity . The monitored activity represents i fetching of data from the relational database by the ORM framework and or ii accessing of the fetched data by the application as monitored by the ORM framework . In some embodiments the ORM framework may monitor activity for a predefined period of time. The period of time may be specified by a user such that the amount of the monitored activity is deemed by the user to be sufficient for use in configuring the ORM framework . Based on the monitored activity the ORM framework configures itself to fetch data from the relational database in a manner that improves performance of the application and or the relational database . In an alternative embodiment an application separate from the ORM framework configures the ORM framework based on the monitored activity .

In one embodiment an ORM framework may fetch data from the relational database in different ways in terms of when the data is fetched. For example the ORM framework may fetch data either eagerly or lazily . Fetching data eagerly refers to fetching the data from the relational database prior to receiving any request from the application for the data i.e. proactively . On the other hand fetching data lazily refers to fetching the data from the relational database only upon receiving a request from the application for the data i.e. responsively . Stated another way fetching data lazily refers to refraining from fetching data from the relational database until the data is explicitly requested by the application . The data being fetched and or requested may correspond to one or more nodes of the object hierarchy . Depending on the embodiment whether to fetch data eagerly or lazily may be a global setting for all nodes of the object hierarchy for a given use case or a local setting specific only to one or more nodes of the object hierarchy for the given use case. In the latter embodiment each distinct use case may specify a lazy eager fetch setting for each individual node of the object hierarchy . By tailoring behavior of the ORM framework at a use case level and object level performance of the application and or the relational database may be improved.

In one embodiment an ORM framework may fetch data from the relational database in different ways in terms of how the data is fetched. For example the ORM framework may fetch data either by using individual selects or joins in queries issued against the relational database . Using individual selects to fetch data refers to issuing a separate query for each row in each table in the relational database . On the other hand using joins to fetch data refers to issuing a single query to retrieve data from all of the desired tables where the single query joins the desired tables together. Further each node of the object hierarchy may have a respective setting that specifies to fetch data using either individual selects or joins for the respective node. Further still the developer of the application may specify a relationship between the how and the when to fetch data from the relational database . For example the developer may specify that for a given level of the object hierarchy the ORM framework can use joins only if the ORM framework is fetching eagerly.

As described above in one embodiment the manner in which the ORM framework fetches data from the relational database affects performance of the application and or the relational database . Performance of the relational database is improved when the count of queries issued against the relational database is minimized. Further performance of the application and or the relational database is improved when the amount of data retrieved from the relational database is minimized. Some undesirable configurations of the ORM framework however may significantly impair performance. For example the undesirable configurations of the ORM framework may result in an N 1 selects problem or a Cartesian product problem .

To facilitate understanding of the N 1 selects problem suppose the application desires to retrieve a listing of all orders associated with all customer accounts. Suppose that accounts and orders are stored in respective tables in the relational database and that there are N customer accounts in total. The N 1 selects problem occurs when the ORM framework issues a single query to retrieve all customer accounts followed by an additional query to retrieve orders for each customer account for a total of N additional queries which results in a total of N 1 queries altogether . Issuing such a large number of queries to the relational database may impair performance relative to issuing a single query that specifies to join desired tables together e.g. the accounts table and the orders table in this particular example . Because the application does not issue queries directly but instead uses the ORM framework to retrieve desired data it may be difficult for the developer to determine whether a given object oriented source code for the application will result in the N 1 selects problem occurring between the ORM framework and the relational database . The likelihood of the N 1 selects problem occurring may be reduced by configuring the ORM framework using techniques described in more detail below.

To illustrate the Cartesian product problem suppose that the ORM framework issues a single query that joins the orders table and accounts table together without any join constraint. Suppose further that there are M orders in total. The Cartesian product problem occurs when the ORM framework issues a single query to retrieve all orders associated with all customer accounts without any join constraint relating the orders to the accounts. As a result the ORM framework may cause a total of N M records to be returned from the relational database where the returned records contain mostly redundant information. Fetching such a large amount of mostly redundant data from the relational database may impair performance. Further because the application does not issue queries directly but instead uses the ORM framework to retrieve desired data it may be difficult for the developer to determine whether a given object oriented source code for the application will result in the Cartesian product problem occurring between the ORM framework and the relational database . The likelihood of the Cartesian product problem occurring may be reduced by configuring the ORM framework using techniques described in more detail below. Further the above problems i.e. the N 1 selects problem and the Cartesian product problem are merely illustrative of two problems that may be addressed by embodiments of the invention. Other problems may also or alternatively be addressed.

As described above in one embodiment each use case of the application causes at least one query to be issued against the relational database . The application may include multiple use cases that each access the same portion of one or more nodes of the object hierarchy . Even among the multiple use cases there may be a node in the portion that is used in a first use case but not used in a second use case. If the second use case does not access the node in the portion then the ORM framework should be configured to fetch data lazily for the node thereby improving performance for the second use case. However if the first use case accesses the node in the portion along with all children of the node then the ORM framework should be configured to fetch data eagerly and using join for the node thereby improving performance for the first use case. Accordingly the ORM framework may dynamically configure itself based on the use case determined to be occurring. In so doing performance may be improved relative to setting a configuration for the node that applies across all use cases and without requiring the developer of the application to attempt to determine a suitable configuration of the ORM framework for each use case of the application .

Next the ORM framework determines which associations of Order are fetched eagerly. Further the ORM framework extracts rows for the Account object creates an account and determines which associations of Account are fetched eagerly. The ORM framework then extract rows for the Order object and create additional Order objects. The ORM framework then determines which associations of Order are fetched eagerly. The application may then access the fetched and converted data. However not all of the data fetched by the ORM framework is necessarily used by the application . To the extent that fetched data is not used by the application performance of the application and or the relational database may be impaired. To improve performance the ORM framework may apply a configuration that is specific to a use case of the application .

Next the ORM framework determines which associations of Order are fetched eagerly. Further the ORM framework extracts rows for the Account object creates an account and determines which associations of Account are fetched eagerly. The application may then access the fetched and converted data. By dynamically applying a configuration that is specific to the current use case of the application performance of the application and or the relational database may be improved.

As described above in one embodiment the ORM framework monitors activity of the ORM framework and or the application on a use case specific basis where the activity includes i fetching of data from the relational database by the ORM framework and or ii accessing of the fetched data by the application . By monitoring the activity on a use case specific basis the ORM framework identifies relationships between multiple queries issued in a single use case of the application . The ORM framework uses the identified relationships to determine a configuration better suited to the use case. For example the ORM framework may detect the duplicate fetch of objects across queries within a single use case. In response the ORM framework may reconfigure itself to fetch the objects only once. Accordingly the second fetch of the objects is eliminated thereby improving performance of the application and or the relational database .

In one embodiment the ORM framework may also monitor the context in which a particular data item is fetched. For example the ORM framework may monitor that node A is fetched in a context of node B where node B is the parent of node A in the object hierarchy . By monitoring the context in which data items are fetched the ORM framework may determine configurations suited for object hierarchies having objects with bidirectional relationships. For example two objects have bidirectional relationships when each of the objects provides an operation for retrieving the other object. Further monitoring the context in which data items are fetched allows the ORM framework to determine configurations suited for a shared object type. For example an object type such as an Address object may be shared between an Employee object and a Customer object. In other words both the Employee object and the Customer object include a method to retrieve an Address object. Monitoring the context of a load of the Address object in a use case of the application allows the ORM framework to determine a configuration that is better suited to the use case of the application .

In one embodiment the ORM framework may also monitor a primary key of a fetched object that is accessed by the application as stored in the relational database . By monitoring the primary key of a fetched object the ORM framework may detect an application accessing the same object repeatedly. For example suppose the ORM framework loads eight hundred objects for the application but the application only uses one of the objects eight hundred times. Such behavior of the application may suggest that the application is not tuned correctly and or contains an error. A developer of the application may be provided the monitored information to aid the developer in tuning and or correcting any error in the application .

In one embodiment using the monitored activity the ORM framework may configure the manner in which the ORM framework fetches data from the relational database . For example the ORM framework may determine for a given use case which nodes of data are fetched by the ORM framework but are not used by the application . The ORM framework may then configure the ORM framework to fetch data lazily for the determined nodes thereby avoiding fetching more data than the application actually uses. As another example the ORM framework may determine for a given use case which nodes of data are accessed by the application and are fetched lazily using individual selects by the ORM framework . The ORM framework may then configure the ORM framework to fetch data eagerly and with joins for the determined nodes thereby avoiding problems such as the N 1 selects problem.

In one embodiment upon determining a configuration change to the ORM framework for a given use case the ORM framework identifies and applies the configuration change upon detecting a subsequent execution of the given use case without requiring a restart of the application . To this end the ORM framework may identify that the subsequent execution of the given use case matches a previous execution of the given use case. The ORM framework may also apply the configuration change for the subsequent execution of the given use case. For example the ORM framework may modify the manner in which data is retrieved for certain nodes in the object hierarchy deemed to be accessed or otherwise in the given use case.

In one embodiment the particular configuration change may also depend on a maximum fetch depth of the object hierarchy. For example the ORM framework may monitor an actual depth to which the object hierarchy is accessed by the application . The ORM framework may then set the value of the maximum fetch depth to be the actual depth upon detecting subsequent executions of the use case. The maximum fetch depth may be used to control the amount of data retrieved from the relational database and may refer to a number of levels in the object hierarchy that a single query is allowed to retrieve data for.

In one embodiment the configuration of the ORM framework may include other parameters that are use case specific. For example the ORM framework may set a maximum batch size for a given use case. The maximum batch size specifies a maximum count of queries for being issued and or processed as a single batch against the relational database .

As described above in one embodiment the ORM framework monitors fetching of data by the ORM framework along with the respective context. To this end the ORM framework includes a data access layer and a controller layer. The data access layer executes queries against the relational database while the controller layer that directs the fetching of data from the relational model to the requested object hierarchy. An exemplary object hierarchy is shown in Table I.

As described above in one embodiment the ORM framework monitors accessing of fetched data by the application along with the respective context. The ORM framework determines that fetched data is accessed by the application upon detecting that a method of a particular class in the object hierarchy is invoked. For example if the method Order.getAccount is invoked then the ORM framework determines that the application has used the account data in the context of the order. Accordingly the ORM framework logs indications of monitored activity regarding method invocations in the object hierarchy. To monitor and log actual usage of data by the application within a specific use case the developer may apply bytecode enhancement to the object model classes. This produces object model classes augmented with custom code. The custom code includes an additional member variable as a session to each domain model class. The controller layer instantiates the member variable with a value immediately upon the object is instantiated with a row of data from the relational database . Accordingly the ORM framework may monitor and log usage of data by the application .

In one embodiment the ORM framework analyzes the monitored activity to determine for each use case a fetch count comprising how many objects of a given type are fetched and what is the parent object of the fetched objects. For example the ORM framework determines a count of accounts fetched in the context of an order. The ORM framework also determines how a usage count comprising how many method invocations occur for the respective use case. For example the ORM framework determines a count of invocations of the method order.getAccount. The difference between the fetch count and the usage count indicates an extent to which fetched data in the ORM framework went unused by the application .

In one embodiment the ORM framework re configures itself based on the difference between the fetch count and the usage count. If the difference amounts to less than a first predefined percentage of the fetch count and if the ORM framework is configured to lazily fetch account data from the order context the ORM framework may reconfigure itself to eagerly fetch the account data with joins and or subselects e.g. for one to many relationships . Subselects refer to nesting a select query inside another select query. On the other hand if the difference between the fetch count and the usage count exceeds a second predefined percentage of the fetch count and if the ORM framework is configured to eagerly fetch account data from the order context the ORM framework may reconfigure itself to lazily fetch the account data. The first and second predefined percentages may be user configurable.

In one embodiment the ORM framework organizes distinct configurations by the corresponding use case of the application based on stack trace information associated with the respective use case. If the ORM framework determines that a particular use case yields differing configuration values across different executions of the use case the ORM framework may receive user input specifying desired configuration values e.g. from a developer . Once the distinct configurations are organized by corresponding use case upon detecting a subsequent execution of a use case the ORM framework matches the subsequent execution of the use case to a corresponding distinct configuration for the use case based on stack trace information for the subsequent execution. The ORM framework then applies the matched configuration for the use case.

Depending on the embodiment the ORM framework may determine configurations for all distinct use cases prior to applying any of the determined configurations. To this end operation of the ORM framework may involve three phases monitoring activity for a predefined period of time analyzing the monitored activity to determine configurations and runtime tuning i.e. monitoring subsequent activity to apply the configurations . In analyzing the monitored activity the ORM framework may first identify all distinct use cases of the application . The ORM framework may then determine a corresponding configuration suited to each identified use case of the application . Subsequently during runtime tuning upon detecting that the application is executing a particular use case the ORM framework may reconfigure itself with the configuration corresponding to the detected use case. In an alternative embodiment the ORM framework may determine and apply configurations dynamically i.e. as the application is executing and without having to first determine configurations for all distinct use cases of the application . In this alternative embodiment two or more of the three phases monitoring activity analyzing the monitored activity and runtime tuning may be combined.

In one embodiment applying the configuration for the use case may be implemented in various ways. For example the ORM framework may use a public application programming interface API provided by the ORM framework to define multiple configurations and to select one of the configurations for a use case by activating the configuration at a session level of the ORM framework . Alternatively the ORM framework may use an internal API provided by the ORM framework to manipulate a runtime instance of a data structure that contains all configuration settings for the ORM framework . The internal API may be used to create multiple copies of the data structure each copy being modified to suit the corresponding use case identified by the ORM framework . The ORM framework may then replace the first default instance of the data structure with one of the copies storing the configuration settings that the ORM framework desires to apply.

Advantageously embodiments of the invention provide techniques for configuring an ORM framework. One embodiment of the invention provides the ORM framework between an application and a relational database. During execution of the application the ORM framework monitors fetching of data for a use case of the application and accessing of the fetched data by the use case of the application. The ORM framework may be configured based on the monitored activity of the use case without having to restart the application whereby performance of the application and or the relational database may be improved.

While the foregoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof and the scope thereof is determined by the claims that follow.

