---

title: Methods and systems for preparing extensible markup language (XML) documents and for responding to XML requests
abstract: Methods and systems for generating and sending an XML document are described. In a specific implementation, methods and systems for responding to an XML client request utilize an XML response generator. The XML response generator responds to a client request without having to first build and save the entire response. An emitter object is provided that receives data that is gathered. The calls are made in a particular order and ensure that the hierarchical nature of the response that is being built is preserved. The emitter object translates the data that it receives into response portions that are in proper XML syntactic form.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09552336&OS=09552336&RS=09552336
owner: Microsoft Technology Licensing, LLC
number: 09552336
owner_city: Redmond
owner_country: US
publication_date: 20100712
---
This application is a continuation of and claims priority to U.S. patent application Ser. No. 11 175 231 which is a continuation of and claims priority to U.S. patent application Ser. No. 09 361 782 the disclosure of each is incorporated by reference herein.

This invention relates to methods and systems for preparing Extensible Markup Language XML documents and in particular to methods and systems for responding to XML requests.

Extensible Markup Language XML is a meta markup language that provides a format for describing structured data. XML is a subset of Standard Generalized Markup Language SGML that provides a uniform method for describing and exchanging structured data in an open text based format and delivers this data by use of standard HTTP protocol. XML utilizes the concepts of elements and namespaces. XML is similar to HTML but facilitates more precise declarations of content and more meaningful search results across multiple platforms.

XML elements are structural constructs that consist of a start tag an end or close tag and the information or content that is contained between the tags. A start tag is formatted as and an end tag is formatted as . In an XML document start and end tags can be nested within other start and end tags. All elements that occur within a particular element must have their start and end tags occur before the end tag of that particular element. This defines a strict tree like structure that can be used to generate an XML document or by an XML parser to organize and parse the XML document. Each element forms a node in this tree and potentially has child or branch nodes. The child nodes represent any XML elements that occur within the start and end tags of the parent node.

XML accommodates an infinite number of database schemas. Within each schema data is represented by element names. Each schema is able to define its own dictionary of element names referred to as a namespace. Namespace identifiers are used within an XML document to qualify element names thereby allowing the same names to be used within different schemas.

Namespace inheritance within an XML document allows non qualified names to use default namespaces. The default namespace for any particular XML element is whatever default namespace is applicable to the parent of the particular element. A namespace specification within an XML document is said to have a scope which includes all child nodes beneath the namespace specification.

Typically XML documents are exchanged between different entities such as client and server computers in the form of requests and responses. A client might generate a request for information or a request for a certain server action and a server might generate a response to the client that contains the information or confirms whether the certain action has been performed. In many cases it is convenient to represent these XML documents in memory as a hierarchical tree structure. Once the hierarchical tree structure is built the actual XML document in proper syntactic form can then be assembled. Consider the following exemplary XML code 

This code includes two XML namespace declarations that are each designated with xmlns . The declarations include a prefix e.g. person and dsig respectively and the expanded namespace to which each prefix refers e.g. http www.schemas.org people and http dsig.org respectively. This code tells any reader that if an element name begins with dsig its meaning is defined by whoever owns the http www.dsig.org namespace. Similarly elements beginning with the person prefix have meanings defined by the http www.schemas.org people namespace.

Namespaces ensure that element names do not conflict and clarify who defined which term. They do not give instructions on how to process the elements. Readers still need to know what the elements mean and decide how to process them. Namespaces simply keep the names straight.

It has been typical in the past to build the entire tree structure such as the one shown in before building an XML document itself. For large XML documents this can consume a great deal of memory and processor time. Thus it would be desirable to avoid this process if at all possible.

Accordingly this invention arose out of concerns associated with providing improved methods and systems for generating XML documents that do not require or need a hierarchical tree structure to be built and stored in memory in order for the XML document to be generated.

Methods and systems for generating and sending XML documents and in particular generating and sending an XML response to an XML client request are described. In the described embodiment an XML document is prepared and sent to a client only a portion at a time. XML document portions are generated and sent until an entire XML document is sent to the client. In a specific implementation an XML response generator is provided and responds to a client request without having to first build and save a hierarchical tree structure in memory that represents the response. The response generator includes one or more request method objects. There is one request method object for each particular type of client request that might be received. Each request method object knows and gathers the data that is needed to respond to its particular associated client request. In addition the request method object knows the order in which the information must be provided.

The request method object calls an emitter object with the data that is gathered by the request method object. The calls are made in a particular order and ensure that the hierarchical nature of the response that is being built is preserved. The emitter object translates the data that it receives into response portions that are in proper XML syntactic form.

A body object is provided to manage a buffer. The emitter object calls the body object with the properly formatted XML response portions. The response portions are placed in the buffer. When a defined buffer threshold is reached the buffered response portions are sent to the client.

Before describing the various inventive methods and structures that are used in implementing the various functions described below reference is made to which shows but one example of an architecture that is suitable for use in connection with the invention. It is to be understood that the architecture that is described constitutes but one example and is not intended to limit the invention in any way.

A client is shown generally at and includes a software application a transport object a TCP IP module and a parser . Although these components are shown as being grouped within the client they can be separately organized outside of the client application . An exemplary client or application is one that generates requests for XML data and receives responses to its requests in the form of XML data streams that must be parsed. One specific example of an application is Microsoft s Outlook Express.

Transport object can be any transport object that is used in connection with sending and receiving requests. In one specific example that transport object can be a Distributed Authoring and Versioning WebDAV transport object that is designed to work in connection with WebDAV requests and responses. Specific examples of these are given later in the document.

In operation an application typically generates a request that is sent through the transport object and the TCP IP module to a server . The server receives the request processes it and sends an XML response to the client.

An exemplary server is Microsoft s Internet Information Service IIS . The XML data is received into the TCP IP module and the transport object . The transport object then begins pushing the data into the parser . The parser then begins to operate on the XML data stream by parsing it and providing it to the application . In this example parser is a so called push model parser because XML data is pushed into it by the transport object . Aspects that are described below are associated with the processing that takes place to build the XML response that is sent by the server to the client or application in response to a client request.

Methods and systems are provided in which an XML document is prepared and sent to a client only a portion at a time. XML document portions are generated and sent until an entire XML document is sent to the client. In a specific implementation various methods and systems respond to an XML client request without the need to build and save in memory a hierarchical tree structure that represents the entire XML response. In the described embodiment an XML response generator functions to enable a response to be prepared and sent to a client in a piecewise fashion.

At step a server such as server receives an XML client request. The server prepares only a portion of a response Step to the client s request. The server then sends the response portion step to the client. The server then determines whether the response preparation is complete step . If it is not then step loops back to step and the server prepares another portion of the response. Accordingly the server repeats steps and until a complete response is sent to the client at which time the processing for that response ends step .

This constitutes a highly desirable and timely improvement over past methods which required that the entire XML response be built and saved in memory before it was sent to the client. One of the advantages of the present response processing becomes apparent in the context of very large responses that must be prepared for certain client requests. An example of such a response is called a multistatus response which is discussed in more detail below. By sending a response to a client in a piecewise manner the client can begin processing the response portions e.g. parsing the response portions and providing the data to the client application sooner that it could if the server had to build the entire response save it in memory and send it out. This in turn translates to improved processing speeds and reductions in the overhead processing that is necessary to prepare and send the responses.

In this example the request method object does not have to know anything about the syntax of the response that is going to be built by the emitter object . It only needs to know the information that is necessary for the response e.g. the XML nodes their organization and order within the XML response any text values that are to be included in the response and the like. Since there is a request method object for each type of client request that can be received these objects only have to know the information or data that is associated with their particular type of client request. In this example the emitter object is primarily a mechanism by which the information or data is placed into the correct syntactic format. Thus the emitter object does not have to do any data gathering because the data and all other information it needs is provided to it by the request method object .

When the emitter object formats the response portions it provides the response portions to the body object . In this example the body object is a response sending mechanism that manages the sending function in which the response portions are sent to the client. The body object can also perform other functions such as setting up so called boiler plate portions of the response e.g. an XML prologue that is to be sent. The body object can also accumulate response portions and send them to the client at an appropriate time.

Thus the XML response generator is able to generate and send response portion to a client in a piecewise fashion. This avoids having to build and save an entire hierarchical tree structure that represents the response document.

Computer includes one or more processors or processing units a system memory and a bus that couples various system components including the system memory to processors . The bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is stored in ROM .

Computer further includes a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from and writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM or other optical media. The hard disk drive magnetic disk drive and optical disk drive are connected to the bus by an SCSI interface or some other appropriate interface. The drives and their associated computer readable media provide nonvolatile storage of computer readable instructions data structures program modules and other data for computer . Although the exemplary environment described herein employs a hard disk a removable magnetic disk and a removable optical disk it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks random access memories RAMs read only memories ROMs and the like may also be used in the exemplary operating environment.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into computer through input devices such as a keyboard and a pointing device . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are connected to the processing unit through an interface that is coupled to the bus . A monitor or other type of display device is also connected to the bus via an interface such as a video adapter . In addition to the monitor personal computers typically include other peripheral output devices not shown such as speakers and printers.

Computer commonly operates in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment computer is connected to the local network through a network interface or adapter . When used in a WAN networking environment computer typically includes a modem or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the bus via a serial port interface . In a networked environment program modules depicted relative to the personal computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Generally the data processors of computer are programmed by means of instructions stored at different times in the various computer readable storage media of the computer. Programs and operating systems are typically distributed for example on floppy disks or CD ROMs. From there they are installed or loaded into the secondary memory of a computer. At execution they are loaded at least partially into the computer s primary electronic memory. The invention described herein includes these and other various types of computer readable storage media when such media contain instructions or programs for implementing the steps described below in conjunction with a microprocessor or other data processor. The invention also includes the computer itself when programmed according to the methods and techniques described below.

For purposes of illustration programs and other executable program components such as the operating system are illustrated herein as discrete blocks although it is recognized that such programs and components reside at various times in different storage components of the computer and are executed by the data processor s of the computer.

One of the areas of application for the described embodiment is in the context of preparing and sending responses to client Web Distributed Authoring and Versioning WebDAV requests. WebDAV is an extension to the HTTP 1.1 protocol that allows clients to perform remote web content authoring operations. This extension provides a coherent set of methods headers request entity body formats and response entity body formats that provide operations for properties collections locking and namespace operations. With respect to properties WebDAV provides the ability to create remove and query information about Web pages such as their authors creation dates etc. With respect to collections WebDAV provides the ability to create sets of documents and to retrieve a hierarchical membership listing like a directory listing in a file system . With respect to locking WebDAV provides the ability to keep more than one person from working on a document at the same time. This prevents the lost update problem in which modifications are lost as first one author then another writes changes without merging the other author s changes. With respect to namespace operations WebDAV provides the ability to instruct the server to copy and move Web resources.

In HTTP 1.1 method parameter information is exclusively encoded in HTTP headers. Unlike HTTP 1.1 WebDAV encodes method parameter information either in an Extensible Markup Language XML request entity body or in an HTTP header. The use of XML to encode method parameters is motivated by the ability to add extra XML elements to existing structures provide extensibility and by XML s ability to encode information in ISO 10646 character sets providing internationalization support. In addition to encoding method parameters XML is used in WebDAV to encode the responses from methods providing the extensibility and internationalization advantages of XML for method output as well as input.

The following WebDAV HTTP methods use XML as a request and response format. The reader is assumed to have some familiarity with WebDAV HTTP methods or verbs. A brief description however of some pertinent WebDAV HTTP methods or verbs appears in the table immediately below 

In one example a client request is received and a multistatus response is prepared and sent to the client. A multistatus response is a special response body that is a text xml or application xml HTTP entity that contains a single XML element called multistatus that contains a set of XML elements called response elements. The table provided below summarizes element definitions of elements that appear in an exemplary multistatus response 

An exemplary multistatus response in XML format is shown below. A portion of a corresponding tree structure for the exemplary multistatus response is shown in . Because client responses can be quite large e.g. multistatus responses having to build the entire tree structure in memory for the response prior to generating and sending a client s response can undesirably increase client and server response times and necessarily increase the complexity of the processing overhead.

To reduce processing overhead complexities and increase client response efficiencies an XML response generator is provided that builds and sends portions of a client response to a client one piece at a time. This enables the client to begin processing the response so that the data contained therein can be put to use in a more timely fashion. Accordingly the piecewise processing and sending of the client response portions renders it unnecessary for an entire hierarchical tree structure to be built and stored in memory prior to generating the XML response.

Each request type or request method object is aware of the information that is necessary for its particular type of response to be generated. In addition each request type object knows the specific or defined order for the calls that it must make to the emitter object . That is because the client response is being generated in a piecewise fashion without building the entire hierarchical tree structure for the response each request type object needs to make sure that the order of the hierarchy is preserved in the individual response portions that are generated. For example see each response node can include only one href node. The href node must come before any propstat nodes. Each propstat node includes one status node and one prop node. In the past where an entire hierarchical tree structure was built in memory nodes or elements could be added at any time and at any place in the tree because the response had not yet been formulated and sent to the client. Here however individual portions of the response are being generated and sent to the client so that a node or element cannot later be added to a response portion that has already been sent to the client. The way that the order of the hierarchy is preserved is by generating and sending calls to the emitter object in a defined order that ensures that the hierarchical nature of the overall response is preserved. So using the tree structure of as an example the request type object would want to make calls in an order that results in generating the multistatus element then the first response element then the href element for the first response element then the first propstat element for the first response element then the status element for the first propstat element then the prop element for the first propstat element and then the sub elements under the prop element and so on. Since the response portions are being generated and sent in a serial piecewise fashion it is important to preserve the hierarchical nature of the client s complete response. So each request type object knows the information or data that it needs and the order of the calls it needs to make to the emitter object.

Once the request type object has been created and gathers the information that is necessary for building a portion of the response the request type object calls the emitter object step and provides the information to the emitter object. The emitter object then takes the information provided to it and generates syntactically appropriate XML response portions. In doing so the emitter object builds the XML response in a piecewise node by node fashion. When the emitter object has built an XML response portion it emits that response portion to the body object step . In this example the body object manages a buffer . The buffer has a set threshold that defines how much XML data it can hold. This enables the body object to accumulate or collect XML data step . Step determines whether the buffer threshold has been reached. If the threshold has not been reached or satisfied step loops back to step which emits additional response portions to the body object. If on the other hand the buffer threshold has been reached then step sends the buffered XML response portions to the client. In this example the body object calls the ISAPI extension which then returns the XML data to IIS. Step checks to see whether the client response is complete. If it is not then step loops back to step which emits XML data from the emitter object to the body object . If the response is complete however then the processing for that response is over step .

An advantage of the described embodiment is that processing of a client s XML request does not require building an entire hierarchical tree structure in memory prior to preparing the XML response and sending it to the client. Rather client responses are generated in a piecewise serial fashion. Individual response portions are prepared and sent to the client as the portions are generated. This can assist the client in beginning its processing of a response that might in some instances be quite lengthy. In addition response processing advantages are achieved by separating functionalities into data gathering functions that are directed to gathering data that is specific to a particular client request that is received and data formatting functions that format the data into syntactically correct XML response portions.

Although the invention has been described in language specific to structural features and or methodological steps it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or steps described. Rather the specific features and steps are disclosed as preferred forms of implementing the claimed invention.

