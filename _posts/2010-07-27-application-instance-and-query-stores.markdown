---

title: Application instance and query stores
abstract: An instance persistence command for an update to a state of an instance of an application can be issued. In response to the persistence command, a transaction with an instance store can be initiated. As part of the transaction, a first representation of the update can be stored in the instance store and a second representation of the update can be stored in a queue. The transaction can be committed after storing the first and second representations. After the transaction is committed, the second representation can be processed to store a third representation of the update in a query store. Application instance state information in the query store can be updated and queried without locking the instance store so that such operations in the query store can be performed asynchronously with operations in the instance store.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08903782&OS=08903782&RS=08903782
owner: Microsoft Corporation
number: 08903782
owner_city: Redmond
owner_country: US
publication_date: 20100727
---
Long running application instances such as for example instances of workflow applications often benefit from periodically persisting their work to allow for the application instance to recover after errors crashes or machine failures. Persisting work can also permit applications to temporarily go idle and have their resources reassigned. To persist work an application host can coordinate the persisted state of an application instance with runtime state of the instance to ensure that a consistent checkpoint is created. For example the persisted state for an instance may need to coordinate with application transactions message notifications locks local state caches etc. An authoritative version of the persisted state of one or more instances can be stored in a store which will be referred to herein as an instance store.

Subsequent to persisting the application instance state aspects of the persisted instance state can be queried in the instance store for example to support application tools for system administration diagnostics health monitoring business process tracking reporting visualization or analysis. As used herein querying and similar terms refer broadly to reading stored data. Application tools are often conceived of and implemented independently of the primary application that is executing the instance.

The tools and techniques described herein can enhance the use of persisted state representations in an instance store by also storing corresponding representations in one or more query stores. This can provide benefits such as allowing application tools to query the application state in a query store without locking the instance store.

In one embodiment the tools and techniques can include issuing an instance persistence command for an update to a state of an instance of an application. In response to the persistence command a transaction with an instance store can be initiated. As part of the transaction a first representation of the update can be stored in the instance store and a second representation of the update can be stored in a queue. The transaction can be committed after storing the first and second representations. After the transaction is committed the second representation can be processed to store a third representation of the update in a query store.

As used herein the term queue refers to storage for data that is waiting to be processed. For example it can refer to storage for data that is waiting to be published. A queue may be in any of various forms such as a database or portion of a database. Additionally a queue may use any of various queue processing techniques such as a first in first out technique or some other technique.

In another embodiment of the tools and techniques a subscription request for results of application instance state updates can be received from a query service. The subscription request can include a filter. A set of results of application instance state updates can be received from a results queue. Additionally a filter can be applied to the set of results from the results queue. Results of the set that meet a set of requirements of the filter can be published to the query service. Additionally representations of application instance state updates corresponding to the results published to the query service can be stored in a query store.

As used herein the term results and similar terms refer to representation s of updates to state s of application instance s . For example a result may indicate that an instance was created or deleted that a variable was assigned a particular value etc. Results may be the same as representations stored in an instance store or they may be in some other form. For example a result may indicate a current state e.g. by indicating a current value of a variable and or a change that was made e.g. by indicating a value that a variable was changed from and a value that a variable was changed to . Similarly representations of state updates can refer to representations of current state and or representations of changes that have been made to the state. For convenience the term results is generally used to refer to representations that are being transmitted while the term representations is generally used to refer to representations that are being stored.

In yet another embodiment of the tools and techniques an application host can be configured to run one or more application instances. An instance store can be connected to the application host and a results queue can be connected to the application host possibly via the instance store. The application host the instance store and the results queue can be configured to participate in transactions in response to instance persistence commands for updates to states of instances of an application running on the application host. Each such transaction can include initiating the transaction in response to an instance persistence command for an update to a state of an application instance storing a first representation of the update in the instance store storing a second representation of the update in the results queue and committing the transaction. A publisher can be connected to the queue and query services can be connected to the publisher. The publisher can be configured to process update representations in the results queue and to publish results from the queue to the one or more query services. The processing and publishing can be done without locking the instance store. Query stores can be connected to the query services and each of the query services can be configured to respond to received results by storing in a query store representations of updates corresponding to the received results.

This Summary is provided to introduce a selection of concepts in a simplified form. The concepts are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter. Similarly the invention is not limited to implementations that address the particular techniques tools environments disadvantages or advantages discussed in the Background the Detailed Description or the attached drawings.

Embodiments described herein are directed to techniques and tools for improved storing and or querying of application instance state information. Such improvements may result from the use of various techniques and tools separately or in combination.

Such techniques and tools may include initiating a transaction with an instance store in response to an instance persistence command for an update to a state of an application instance. The transaction can include storing a first representation of the update in the instance store storing a second representation of the update in a queue and then committing the transaction. This may include transmitting results of the command to the queue and possibly supplementing those results with application data that is not present in the first representation. After the transaction is committed the second representation of the update can be processed to store a third representation of the update in a query store. This processing can be done without locking the instance store and queries on information in the query store can also be done without locking the instance store. Accordingly the updating and querying of the query store can be done without slowing the performance of the instance store. This can in turn improve performance of applications being persisted because such applications can spend less time waiting for operations to be performed at the instance store.

The representations in the queue may be processed using a publish subscribe technique. For example query services that are each connected to a different query store can subscribe to a publisher which is connected to the queue. The query services may provide filters with their subscription information. The publisher can publish representations from the queue as results to query services according to the subscription information. In response to these publications the query services can update corresponding query stores with representations of the updates to the application instance state. Techniques may also be used to synchronize query stores with the instance store if the query stores are out of sync e.g. because a store has crashed has only recently subscribed or has had a change in its subscription .

The subject matter defined in the appended claims is not necessarily limited to the benefits described herein. A particular implementation of the invention may provide all some or none of the benefits described herein. Although operations for the various techniques are described herein in a particular sequential order for the sake of presentation it should be understood that this manner of description encompasses rearrangements in the order of operations unless a particular ordering is required. For example operations described sequentially may in some cases be rearranged or performed concurrently. Techniques described herein with reference to flowcharts may be used with one or more of the systems described herein and or with one or more other systems. For example the various procedures described herein may be implemented with hardware or software or a combination of both. Moreover for the sake of simplicity flowcharts may not show the various ways in which particular techniques can be used in conjunction with other techniques.

The computing environment is not intended to suggest any limitation as to scope of use or functionality of the invention as the present invention may be implemented in diverse general purpose or special purpose computing environments.

With reference to the computing environment includes at least one processing unit and memory . In this most basic configuration is included within a dashed line. The processing unit executes computer executable instructions and may be a real or a virtual processor. In a multi processing system multiple processing units execute computer executable instructions to increase processing power. The memory may be volatile memory e.g. registers cache RAM non volatile memory e.g. ROM EEPROM flash memory or some combination of the two. The memory stores software implementing application instance and query stores.

Although the various blocks of are shown with lines for the sake of clarity in reality delineating various components is not so clear and metaphorically the lines of and the other figures discussed below would more accurately be grey and blurred. For example one may consider a presentation component such as a display device to be an I O component. Also processors have memory. The inventors hereof recognize that such is the nature of the art and reiterate that the diagram of is merely illustrative of an exemplary computing device that can be used in connection with one or more embodiments of the present invention. Distinction is not made between such categories as workstation server laptop handheld device etc. as all are contemplated within the scope of and reference to computer computing environment or computing device. 

A computing environment may have additional features. In the computing environment includes storage one or more input devices one or more output devices and one or more communication connections . An interconnection mechanism not shown such as a bus controller or network interconnects the components of the computing environment . Typically operating system software not shown provides an operating environment for other software executing in the computing environment and coordinates activities of the components of the computing environment .

The storage may be removable or non removable and may include non transitory computer readable storage media such as magnetic disks magnetic tapes or cassettes CD ROMs CD RWs DVDs or any other medium which can be used to store information and which can be accessed within the computing environment . The storage stores instructions for the software .

The input device s may be a touch input device such as a keyboard mouse pen or trackball a voice input device a scanning device a network adapter a CD DVD reader or another device that provides input to the computing environment . The output device s may be a display printer speaker CD DVD writer network adapter or another device that provides output from the computing environment .

The communication connection s enable communication over a communication medium to another computing entity. Thus the computing environment may operate in a networked environment using logical connections to one or more remote computing devices such as a personal computer a server a router a network PC a peer device or another common network node. The communication medium conveys information such as data or computer executable instructions or requests in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired or wireless techniques implemented with an electrical optical RF infrared acoustic or other carrier.

The tools and techniques can be described in the general context of computer readable media. Computer readable media are any available media that can be accessed within a computing environment. By way of example and not limitation with the computing environment computer readable media include memory storage and combinations of the above.

The tools and techniques can be described in the general context of computer executable instructions such as those included in program modules being executed in a computing environment on a target real or virtual processor. Generally program modules include routines programs libraries objects classes components data structures etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer executable instructions for program modules may be executed within a local or distributed computing environment. In a distributed computing environment program modules may be located in both local and remote computer storage media.

For the sake of presentation the detailed description uses terms like determine choose adjust and operate to describe computer operations in a computing environment. These and other similar terms are high level abstractions for operations performed by a computer and should not be confused with acts performed by a human being unless performance of an act by a human being such as a user is explicitly noted. The actual computer operations corresponding to these terms vary depending on the implementation.

The application host is a module such as an executing workflow program that can execute application instances and can manipulate the instance state stored in an instance store to reflect the instance execution results. The instance store can be a form of persistent storage such as a persistent database. The application host can submit instance persistence commands to the instance store through a persistence provider . The persistence provider can be connected to the instance store and to the application host indeed the persistence provider may be part of the application host to pass the commands to the instance store and can track the application state results that are returned by the instance store in response to the issued commands .

There can be disadvantages to having the application host and application tools operate against the same instance store . For example the coordinated access of data between two processes may introduce locking of tables pages rows values or other types of regions of the instance store . Such locking could have computational overhead which could slow the rate at which instances were executed by causing execution of the application host to block temporarily while a query was being performed by one of the application tools . The simultaneous execution of application instances and queries on the same instance store could similarly introduce application level locking costs by serializing or delaying instance persistence commands while query commands are being performed.

Moreover the storage organization of data in the instance store may be made advantageous for instance execution while a different storage organization may be advantageous for queries. As applications tools may be developed independently from or even subsequent to the application host it may be difficult to accommodate these different preferences with a single storage solution.

Instead the system of can replicate updates of the instance store so that instance execution and queries can be isolated from one another. Although this asynchronous replication can delay the propagation of instance state changes to the query processor many types of application tools are insensitive to this delay. For example interactive applications are already limited by the rate at which information can be displayed and the user can enter commands. Reporting applications may run in the background at a low priority and reflect results that are hours old before the report is viewed. Historical records may be insensitive to ongoing changes in instance state. These types of delays may dwarf the asynchronous delay of propagating updates of the instance store for use in querying.

The system of can include a result queue which can be connected to the application host such as through the instance store and or the persistence provider . The result queue may be a form of persistent storage such as a persistent database. The result queue can asynchronously decouple the front end system such as the persistence provider and instance store that is interacting with an application instance run by the application host from a back end system that provides representations of state updates to be queried by the application tools . Because of this decoupling the introduction of the back end system which may include one or more additional queues for propagating representations of updates to the state of the application instance for use in servicing queries may have little or no impact on the perceived delay of updates.

Referring still to the application host can be configured to execute an instance persistence command to update representations of instance state in the instance store . The application host may also have application data that is interesting to the application tools but is not part of the instance state to be stored in the instance store .

The persistence provider can be configured to provide the appropriate instance persistence command to the instance store . Responsive to the instance persistence command the instance store can store representation s of the update s represented by the instance persistence command and can provide the persistence provider with results of the instance persistence command .

The persistence provider can create a results responsive to the results of the instance persistence command . The results may be similar to the results but supplemented with the application data from the application host that was not present in the results . Additionally the results may exclude ephemeral portions of the results of the instance persistence command .

Referring back to the persistence provider can enqueue the results in the result queue . The instance persistence command can be performed under a transaction where changes to the application state changes to the instance state and the enqueuing of the results as state update representations in the result queue can be done atomically as part of the transaction. The application host the instance store and the result queue can be configured to participate in such transactions in response to instance persistence commands for updates to state s of instance s of application s running on the application host . Each such transaction can include initiating the transaction in response to an instance persistence command for an update to a state of an application instance storing a first representation of the update as part of the representations in the instance store storing a second representation of the update as part of the representations in the result queue and committing the transaction.

Referring still to one or more query services and can be connected to a result update publisher which can in turn be connected to the result queue . A query service can register an interest in receiving instance persistence command results by sending subscription information to the result update publisher that is connected to the result queue . The subscription information can include a filter which may include in the subscription for example all of the instance persistence command results or alternatively only a portion of the instance persistence command results. For example the filter may only include in the subscription the instance persistence command results for an instance 123 only the instance persistence command results for commands that ran after 5 00 PM or only the instance persistence command results that set the value of a particular variable. In addition to a subscription filter the subscription information may also include contact information for the subscribing query service .

The result update publisher can process the queued update representations by dequeuing instance persistence command results from the result queue . The boundaries between sets of dequeued instance persistence command results may differ from the boundaries when the corresponding results were enqueued. For example the persistence provider may enqueue a batch of instance persistence command results for all of the changes done under a single transaction while the result update publisher may receive each change individually in the dequeued results .

The results update publisher can apply the subscription information to publish instance persistence command results to each of the subscribers whose subscription filter matches the dequeued set of instance persistence command results . The instance persistence command results may be published in any of various ways. For example the publisher may push the results to the subscriber query service by sending the published results as a message or event or may create a result cursor that the subscriber can read the published results from later. The result cursors may share amongst themselves a single copy of the published instance persistence command results rather than replicating the results for each subscriber query service and .

The processing and publishing of the results and can be done without locking the instance store . Accordingly this publishing may be done asynchronously with respect to operations in the instance store .

Each query service and may be connected to a query store and configured to use the received instance persistence command results to perform updates on the query store so that the query store can include representations of updates to the state of application instance s hosted by the application host in the instance store that correspond to published results received at the query service . The query store may be any of various types of storage such as a type of persistent or non persistent storage. For simplicity in a query store is illustrated for one query service but not for the other query service . However it is to be understood that the other query service could also update its own query store. Moreover the system could include just a single query service or it could include many more query services than are illustrated in . Likewise the system could include more or less of other illustrated modules such as more application hosts etc.

Referring still to the query store may mirror the instance store or may represent only a portion of the instance store depending on how the subscription filter is configured. Additionally the query store may include additional application information that is not present in the instance store .

The instance persistence command results may be transformed by various modules in the system . For example the query service may perform transformations on the published instance persistence command results prior to using them to update the query store . Also the organization of the query store may differ significantly from the organization of the instance store . For example the query store may be a distributed cache while the instance store may be a relational database. A schema for the query store may contain tables and columns specialized to the application tools that interact with that query store such as for example predefined columns for application data provided by the application host that is not a part of the instance store .

The set of application tool s can query information in the corresponding query store . The execution of the queries can be independent of the storage organization and runtime artifacts for the instance store so that the query store can be updated and queries can be run on the query store without locking the instance store . Thus operations on the instance store can be run asynchronously with operations on the query store .

From time to time it may be beneficial to initially synchronize or to resynchronize the contents of the instance store and the query store . The synchronization of the contents of these stores is a type of transmission between the two resources but there can be different strategies for performing this transmission operation.

For example the query store may not be durable or there may not have been subscribers capturing the events requested by an application tool in the set . To synchronize such a query store with the instance store a query service can send to the publisher a request not shown to synchronize with the instance store. The publisher can respond by sending a synchronization request to the instance store for synchronization information such as a retransmission of previous instance persistence command results. The instance store can respond by sending the requested synchronization information such as in the form of instance persistence command results by enqueuing them in the result queue in the normal manner. The publisher can publish these instance persistence command results from the queue to one or more of the query services and or in the normal manner.

The retransmitted instance persistence command results may differ from those originally transmitted. An example of this difference will be discussed with reference to . As illustrated in a series of commands to the instance store resulted in the following result sequence being returned to the persistence provider not shown in Create Instance 5 Instance 5 Cheese Swiss Create Instance 6 Instance 6 Cheese Provolone Instance 6 Cheese Gruyere Delete Instance 5.

Thus instance 5 has been deleted and the value of Instance 6 Cheese was Provolone but has been overwritten with Gruyere . The update representations of the instance state in the instance store may only reflect the current state. If so that current state may only indicate that the Instance 6 state includes Cheese Gruyere with no indication that Instance 5 was present and no indication that Instance 6 Cheese had previously been set to the value of Provolone . Accordingly the synchronization result may indicate results that would lead to the current state in the update representations but not the history of the entire result sequence . Accordingly after overwriting or deleting portions of the instance state the retransmitted instance persistence command results may reflect the cumulative results of several instance persistence commands rather than the intermediate results of each of the commands . Alternatively the instance store may retain some or all of the history of the commands and or the result sequence so that the synchronization results may represent all or a portion of that history.

Referring back to the instance persistence command results and the update representations may have associated timestamps and or sequence numbers. The result update publisher and the instance store may use these identifiers to resynchronize only a portion of the instance store . For example the result update publisher may indicate that it only wants synchronization information for instance state updates that may be relevant to the month of August 2009. As another example the result update publisher may indicate that it only wants the retransmission of instance persistence command results that had been sent previously with synchronization numbers 1401 1420.

Similarly the result update publisher may limit the synchronization request to only a portion of the instance store such as a particular instance or the values of particular variables. The result update publisher may use the subscription filters provided by subscribing query services and or to construct this bounded request by excluding from the synchronization request a portion of the instance store whose instance persistence command results would not pass requirements of any of the subscription filters.

Upon receiving synchronization information in the form of published results a query service can use the synchronization information to synchronize at least a portion of a query store with at least a portion of the instance store such as by using the published results to update the query store in the normal manner.

The connections between the modules of for transmitting data such as application data and data for commands results subscription information updates and queries between the modules can be implemented in various ways. For example the connection between the application host and the persistence provider could be made by way of function calls or application programming interface calls. The instance store the result queue and the query store can all be databases and connections between those databases and other modules can utilize database connections. Alternatively some or all of the connections to the instance store result queue and or query store could be made with storage application programming interfaces. The publisher and the query services could be connected via network messaging connections. Other types of connections between modules may be used instead of and or in addition to these types of connections.

Several application instance and query store techniques will now be discussed. Each of these techniques can be performed in a computing environment. For example each technique may be performed in a computer system that includes at least one processor and a memory including instructions stored thereon that when executed by the at least one processor cause the at least one processor to perform the technique a memory stores instructions e.g. object code and when the processor s execute s those instructions the processor s perform s the technique . Similarly one or more computer readable storage media may have computer executable instructions embodied thereon that when executed by at least one processor cause the at least one processor to perform the technique.

Referring to an instance and query store technique will be discussed. The technique can include issuing an instance persistence command for an update to a state of an instance of an application. A transaction can be initiated with an instance store in response to the persistence command. As part of the transaction a first representation of the update can be stored in the instance store and a second representation of the update can be stored in a queue. The transaction can be committed after storing the first and second representations. After committing the transaction the second representation of the update can be processed to store a third representation of the update in a query store. The storage of the first second and third representations may each be performed in standard ways such as with standard database storage techniques. The transaction can include locking at least a portion of the instance store but processing the second representation of the update can be done without locking the instance store. The technique can further include querying the third representation in the query store without locking the instance store.

The first second and third representations of the update may be the same as each other but they may be different from each other. For example the technique may include supplementing the second representation of the update with application data that is not present in the first representation. Also the instance store can include information that is not in the query store such as information about the state of the application instance. Processing the second representation of the update to store a third representation of the update in a query store can include applying a filter to the second representation.

Referring now to another instance and query store technique will be discussed. The technique can include receiving from a query service a subscription request for results of application instance state updates. The subscription request can include a filter and may also include other information such as contact information for the subscribing query service that sent the subscription request. The technique can also include receiving a set of results of one or more application instance state updates from a results queue. The filter from the query service can be applied to the set of results so that one or more results from the set that meet a set of requirement s of the filter can be published to the query service. One or more representations of one or more application instance state updates corresponding to the results published to the query service can be stored in a query store.

The technique of can also include storing in an instance store representations of application instance state updates corresponding to the set of results. Publishing to the query service and storing in the query store can be done without locking the instance store. Additionally the technique can include receiving from the query service a request to synchronize with the instance store. In response to the request to synchronize synchronization information can be requested from the instance store. The requested synchronization information can be received from the instance store and at least a portion of the synchronization information can be forwarded to the query service. At least a portion of the synchronization information can be used to synchronize at least a portion of a query store with at least a portion of the instance store.

The technique of may include issuing an instance persistence command for an update to a state of an application instance of an application. A transaction between the application and an instance store can be initiated in response to the persistence command. As part of the transaction a first representation of the update can be stored in the instance store and a second representation of the update can be stored in the results queue. After the transaction is committed the second representation can be processed to store a third representation of the update in the query store.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

