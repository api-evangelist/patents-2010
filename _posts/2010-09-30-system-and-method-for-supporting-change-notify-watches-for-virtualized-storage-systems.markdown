---

title: System and method for supporting change notify watches for virtualized storage systems
abstract: A technique supports Change Notify watches in virtualized storage systems. In particular, techniques of the present invention advantageously emulate Change Notify features (e.g., as documented by the CIFS protocol) on virtualized storage systems by leveraging virtualization mapping information (e.g., an inode-to-path or “I2P” mapping) to walk a file system tree backwards from the data blocks to their ancestors to determine whether there are applicable watches on ancestor directories, and to obtain a pathname (e.g., relative) of the watched (changed) data. In particular, changes to data received from different protocols (e.g., CIFS, NFS, HTTP, etc.) can trigger watches to clients on the virtualized storage system. Also, performance may be enhanced using various caching techniques, and watch state may be retained while moving watched data across volumes of the virtualized storage system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07958169&OS=07958169&RS=07958169
owner: NetApp, Inc.
number: 07958169
owner_city: Sunnyvale
owner_country: US
publication_date: 20100930
---
The present application is a continuation of commonly assigned copending U.S. patent application Ser. No. 11 948 608 which was filed on Nov. 30 2007 now U.S. Pat. No. 7 809 776 by Wesley R. Witte for a SYSTEM AND METHOD FOR SUPPORTING CHANGE NOTIFY WATCHES FOR VIRTUALIZED STORAGE SYSTEMS and is hereby incorporated by reference.

The present invention relates to storage systems and in particular to supporting Change Notify watches in virtualized storage systems.

A storage system typically comprises one or more storage devices into which information may be entered and from which information may be obtained as desired. The storage system includes a storage operating system that functionally organizes the system by inter alia invoking storage operations in support of a storage service implemented by the system. The storage system may be implemented in accordance with a variety of storage architectures including but not limited to a network attached storage NAS environment a storage area network SAN and a disk assembly directly attached to a client or host computer. The storage devices are typically disk drives organized as a disk array wherein the term disk commonly describes a self contained rotating magnetic media storage device. The term disk in this context is synonymous with hard disk drive HDD or direct access storage device DASD .

The storage operating system of the storage system may implement a high level module such as a file system to logically organize the information stored on volumes as a hierarchical structure of data containers such as files and logical units. For example each on disk file may be implemented as set of data structures i.e. disk blocks configured to store information such as the actual data for the file. These data blocks are organized within a volume block number vbn space that is maintained by the file system. The file system may also assign each data block in the file a corresponding file offset or file block number fbn . The file system typically assigns sequences of fbns on a per file basis whereas vbns are assigned over a larger volume address space. The file system organizes the data blocks within the vbn space as a logical volume each logical volume may be although is not necessarily associated with its own file system.

A known type of file system is a write anywhere file system that does not over write data on disks. If a data block is retrieved read from disk into a memory of the storage system and dirtied i.e. updated or modified with new data the data block is thereafter stored written to a new location on disk to optimize write performance. A write anywhere file system may initially assume an optimal layout such that the data is substantially contiguously arranged on disks. The optimal disk layout results in efficient access operations particularly for sequential read operations directed to the disks. An example of a write anywhere file system that is configured to operate on a storage system is the Write Anywhere File Layout WAFL file system available from Network Appliance Inc. Sunnyvale Calif.

The storage system may be further configured to operate according to a client server model of information delivery to thereby allow many clients to access data containers stored on the system. In this model the client may comprise an application such as a database application executing on a computer that connects to the storage system over a computer network such as a point to point link shared local area network LAN wide area network WAN or virtual private network VPN implemented over a public network such as the Internet. Each client may request the services of the storage system by issuing file based and block based protocol messages in the form of packets to the system over the network. By supporting a plurality of file system protocols such as the conventional Common Internet File System CIFS and the Network File System NFS protocols the utility of the storage system is enhanced.

Often it is desirable for a client or administrator to be aware of changes to the data containers served by the storage system. Typically changes to data containers are maintained through the client s operating system which locally manages storage and is thus aware of file and directory locations in that local storage. Two problems arise however with virtualized network storage systems such as the logical volumes served by the storage system described above. First the client s local operating system is generally unaware of the actual physical storage locations of the files and directories on the logical volumes of the storage system and as such is generally unable to monitor for changes particularly those made by clients sharing the logical volumes. Second the logical volumes generally are minimally aware of the files and directories at the data block level. In other words the portions of the logical volumes that control the underlying physical storage e.g. in a clustered storage system as described herein are only aware that data has changed not to which particular files or directories that data belongs e.g. handled by another portion of a clustered storage system .

The present invention overcomes the disadvantages of the prior art by providing a system and method for supporting Change Notify watches in virtualized storage systems. In particular techniques of the present invention advantageously emulate Change Notify features e.g. as documented by the CIFS protocol on virtualized storage systems by leveraging virtualization mapping information e.g. an inode to path or I2P mapping to walk a file system tree backwards from the data blocks to their higher level file and directory inodes ancestors to determine whether there are applicable watches on ancestor directories and to obtain a pathname e.g. relative of the watched changed data. In particular changes to data received from different protocols e.g. CIFS NFS HTTP etc. can trigger watches to clients on the virtualized storage system. Also performance may be enhanced using various caching techniques and watch state may be retained while moving watched data across volumes of the virtualized storage system.

According to one or more embodiments of the present invention data is stored on data containers of a storage system that may be arranged as one or more logical volumes e.g. a clustered storage system and a mapping is maintained from the data containers to corresponding parent directories of a file system of the storage system e.g. I2P mapping . Watches may be set e.g. by clients on one or more of the directories to request that changes made to data stored within the directories be reported in accordance with Change Notify features. In the event a change is detected to data stored within a directory upon which a watch is set the mapping is traversed to determine a relative pathname of the changed data based on the corresponding parent directories and the pathname is reported e.g. to the client . If the watches define an action to be taken in response to changes then the system also takes that action such as performing a delete pending procedure etc.

Also according to an aspect of the present invention triggered watch events may be cached. Such caching may increase performance and reduce storage requirements. For instance caching may be used to prevent duplicate reports and to prevent traversal of the mapping based on previously stored pathnames.

Further according to another aspect of the present invention the logical volumes may be moved from a first storage device to a second storage device e.g. of a clustered storage system . As such the present invention defines techniques that may be used to retain the watches during the move to the second storage device.

As noted it is often desirable for a client or administrator to be aware of changes to the data containers served by the storage system. Change Notify is a facility in CIFS network file systems that notifies clients of any changes made to directories or files of the storage system e.g. at a single directory level or an entire subtree level. The client identifies the directories and actions it wants reported by setting watches on these directories. When changes are made to a file or directory having an associated watch as requested by the client the watch is triggered and a response is sent to notify the client of the change. For example these changes may be conveyed to the client through an NT TRANSACT NOTIFY CHANGE command of a conventional Server Message Block SMB NT Trans Request as may be appreciated by those skilled in the art. For the reasons described above however it has been difficult to support Change Notify watches on virtualized storage systems

Accordingly the present invention provides a system and method for supporting Change Notify watches in virtualized storage systems. In particular techniques of the present invention advantageously emulate Change Notify features e.g. as documented by the CIFS protocol Common Internet File System CIFS Version CIFS Spec 0.9 Storage Networking Industry Association SNIA Draft SNIA CIFS Documentation Work Group Work in Progress Revision Date Mar. 26 2001 on virtualized storage systems by leveraging virtualization mapping information e.g. an inode to path or I2P mapping to walk a file system tree backwards from the data blocks to their ancestors to determine whether there are applicable watches on ancestor directories and to obtain a pathname of the watched changed data. In particular changes to data received from different protocols e.g. CIFS NFS HTTP etc. can trigger watches to clients on the virtualized storage system. Also performance may be enhanced using various caching techniques and watch state may be retained while moving watched data across volumes of the virtualized storage system.

The clients may be general purpose computers configured to interact with the node in accordance with a client server model of information delivery. That is each client may request the services of the node and the node may return the results of the services requested by the client by exchanging packets over the network . The client may issue packets including file based access protocols such as the Common Internet File System CIFS protocol or Network File System NFS protocol over the Transmission Control Protocol Internet Protocol TCP IP when accessing information in the form of files and directories. Alternatively the client may issue packets including block based access protocols such as the Small Computer Systems Interface SCSI protocol encapsulated over TCP iSCSI and SCSI encapsulated over Fibre Channel FCP when accessing information in the form of blocks. Notably the clients may request that one or more watches be set on data stored by the storage system such as in accordance with a Change Notify feature as described herein.

Each node is illustratively embodied as a dual processor storage system executing a storage operating system that preferably implements a high level module such as a file system to logically organize the information as a hierarchical structure of named data containers such as directories files and special types of files called virtual disks hereinafter generally blocks on the disks. However it will be apparent to those of ordinary skill in the art that the node may alternatively comprise a single or more than two processor system. Illustratively one processor executes the functions of the N module on the node while the other processor executes the functions of the D module .

The memory illustratively comprises storage locations that are addressable by the processors and adapters for storing software program code and data structures associated with the present invention. The processor and adapters may in turn comprise processing elements and or logic circuitry configured to execute the software code and manipulate the data structures. The storage operating system portions of which is typically resident in memory and executed by the processing elements functionally organizes the node by inter alia invoking storage operations in support of the storage service implemented by the node. It will be apparent to those skilled in the art that other processing and memory means including various computer readable media may be used for storing and executing program instructions pertaining to the invention described herein.

The network adapter comprises a plurality of ports adapted to couple the node to one or more clients over point to point links wide area networks virtual private networks implemented over a public network Internet or a shared local area network. The network adapter thus may comprise the mechanical electrical and signaling circuitry needed to connect the node to the network. Illustratively the computer network may be embodied as an Ethernet network or a Fibre Channel FC network. Each client may communicate with the node over network by exchanging discrete frames or packets of data according to pre defined protocols such as TCP IP.

The storage adapter cooperates with the storage operating system executing on the node to access information requested by the clients. The information may be stored on any type of attached array of writable storage device media such as video tape optical DVD magnetic tape bubble memory electronic random access memory micro electro mechanical and any other similar media adapted to store information including data and parity information. However as illustratively described herein the information is preferably stored on the disks of array . The storage adapter comprises a plurality of ports having input output I O interface circuitry that couples to the disks over an I O interconnect arrangement such as a conventional high performance FC link topology.

Storage of information on each array is preferably implemented as one or more storage volumes that comprise a collection of physical storage disks cooperating to define an overall logical arrangement of volume block number vbn space on the volume s . Each logical volume is generally although not necessarily associated with its own file system. The disks within a logical volume file system are typically organized as one or more groups wherein each group may be operated as a Redundant Array of Independent or Inexpensive Disks RAID . Most RAID implementations such as a RAID 4 level implementation enhance the reliability integrity of data storage through the redundant writing of data stripes across a given number of physical disks in the RAID group and the appropriate storing of parity information with respect to the striped data. An illustrative example of a RAID implementation is a RAID 4 level implementation although it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein.

To facilitate access to the disks the storage operating system illustratively implements a write anywhere file system that cooperates with one or more virtualization modules to virtualize the storage space provided by disks . The file system logically organizes the information as a hierarchical structure of named directories and files on the disks. Each on disk file may be implemented as set of disk blocks configured to store information such as data whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization module s allow the file system to further logically organize information as a hierarchical structure of blocks on the disks that are exported as named logical unit numbers luns .

In the illustrative embodiment the storage operating system is preferably the NetApp Data ONTAP operating system available from Network Appliance Inc. Sunnyvale Calif. that implements a Write Anywhere File Layout WAFL file system. However it is expressly contemplated that any appropriate storage operating system may be enhanced for use in accordance with the inventive principles described herein. As such where the term ONTAP is employed it should be taken broadly to refer to any storage operating system that is otherwise adaptable to the teachings of this invention.

In addition the storage operating system includes a series of software layers organized to form a storage server that provides data paths for accessing information stored on the disks of the node . To that end the storage server includes a file system module in cooperating relation with a RAID system module and a disk driver system module . The RAID system manages the storage and retrieval of information to and from the volumes disks in accordance with I O operations while the disk driver system implements a disk access protocol such as e.g. the SCSI protocol. In particular the VSM implements a Locate function to compute the location of data container content among the volumes served by the cluster to thereby ensure consistency of such content.

The file system implements a virtualization system of the storage operating system through the interaction with one or more virtualization modules illustratively embodied as e.g. a virtual disk vdisk module not shown and a SCSI target module . The vdisk module enables access by administrative interfaces such as a user interface of a management framework see in response to a user system administrator issuing commands to the node . The SCSI target module is generally disposed between the FC and iSCSI drivers and the file system to provide a translation layer of the virtualization system between the block lun space and the file system space where luns are represented as blocks.

The file system is illustratively a message based system that provides logical volume management capabilities for use in access to the information stored on the storage devices such as disks. That is in addition to providing file system semantics the file system provides functions normally associated with a volume manager. These functions include i aggregation of the disks ii aggregation of storage bandwidth of the disks and iii reliability guarantees such as minoring and or parity RAID . The file system illustratively implements the WAFL file system hereinafter generally the write anywhere file system having an on disk format representation that is block based using e.g. 4 kilobyte KB blocks and using index nodes inodes to identify files and file attributes such as creation time access permissions size and block location . The file system uses files to store meta data describing the layout of its file system these meta data files include among others an inode file. A file handle i.e. an identifier that includes an inode number is used to retrieve an inode from disk.

Broadly stated all inodes of the write anywhere file system are organized into the inode file. A file system fs info block specifies the layout of information in the file system and includes an inode of a file that includes all other inodes of the file system. Each logical volume file system has an fsinfo block that is preferably stored at a fixed location within e.g. a RAID group. The inode of the inode file may directly reference point to data blocks of the inode file or may reference indirect blocks of the inode file that in turn reference data blocks of the inode file. Within each data block of the inode file are embedded inodes each of which may reference indirect blocks that in turn reference data blocks of a file.

Operationally a request from the client is forwarded as a packet over the computer network and onto the node where it is received at the network adapter . A network driver of layer or layer processes the packet and if appropriate passes it on to a network protocol and file access layer for additional processing prior to forwarding to the write anywhere file system . Here the file system generates operations to load retrieve the requested data from disk if it is not resident in core i.e. in memory . If the information is not in memory the file system indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical vbn. The file system then passes a message structure including the logical vbn to the RAID system the logical vbn is mapped to a disk identifier and disk block number disk dbn and sent to an appropriate driver e.g. SCSI of the disk driver system . The disk driver accesses the dbn from the specified disk and loads the requested data block s in memory for processing by the node. Upon completion of the request the node and operating system returns a reply to the client over the network .

Included in the storage operating system is a set of inode to pathname I2P functions . The I2P functions in conjunction with the file system illustratively implement I2P mapping functionality in accordance with the present invention. One exemplary technique for I2P mappings is described in the commonly owned copending U.S. Patent Application Publication No. US 2006 0288026 entitled SYSTEM AND METHOD FOR GENERATING AND MAINTAINING INODE TO PATHNAME MAPPING INFORMATION by Ed Zayas et al. published on Dec. 21 2006 the contents of which are hereby incorporated by reference in their entirety. The I2P functions may include various scanners described further below that operate to install remove I2P mappings in accordance with embodiments of the present invention. Additionally the I2P functions may include an application program interface API that is exposed to enable other processes executing within the storage operating system to perform I2P mappings. The API may also be accessible via remote procedure calls RPCs to enable programs executing on other computers in network environment to perform I2P mapping functions. Also included within the file system is a lock manager and a watch process which implements the novel Change Notify support procedures of the present invention e.g. in conjunction with watch process of N module .

It should be noted that the software path through the storage operating system layers described above needed to perform data storage access for the client request received at the node may alternatively be implemented in hardware. That is in an alternate embodiment of the invention a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array FPGA or an application specific integrated circuit ASIC . This type of hardware implementation increases the performance of the storage service provided by node in response to a request issued by client . Moreover in another alternate embodiment of the invention the processing elements of adapters may be configured to offload some or all of the packet processing and storage access operations respectively from processor to thereby increase the performance of the storage service provided by the node. It is expressly contemplated that the various processes architectures and procedures described herein can be implemented in hardware firmware or software.

As used herein the term storage operating system generally refers to the computer executable code operable on a computer to perform a storage function that manages data access and may in the case of a node implement data access semantics of a general purpose operating system. The storage operating system can also be implemented as a microkernel an application program operating over a general purpose operating system such as UNIX or Windows XP or as a general purpose operating system with configurable functionality which is configured for storage applications as described herein.

In addition it will be understood to those skilled in the art that the invention described herein may apply to any type of special purpose e.g. file server filer or storage serving appliance or general purpose computer including a standalone computer or portion thereof embodied as or including a storage system. Moreover the teachings of this invention can be adapted to a variety of storage system architectures including but not limited to a network attached storage environment a storage area network and disk assembly directly attached to a client or host computer. The term storage system should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems. It should be noted that while this description is written in terms of a write any where file system the teachings of the present invention may be utilized with any suitable file system including a write in place file system.

In the illustrative embodiment the storage server is embodied as D module of the storage operating system to service one or more volumes of array . In addition the multi protocol engine is embodied as N module to i perform protocol termination with respect to a client issuing incoming data access request packets over the network as well as ii redirect those data access requests to any storage server of the cluster . Moreover the N module and D module cooperate to provide a highly scalable distributed storage system architecture of the cluster . To that end each module includes a cluster fabric CF interface module adapted to implement intra cluster communication among the modules including D module to D module communication.

The protocol layers e.g. the NFS CIFS layers and the iSCSI FC layers of the N module function as protocol servers that translate file based and block based data access requests from clients into CF protocol messages used for communication with the D module . That is the N module servers convert the incoming data access requests into file system primitive operations commands that are embedded within CF messages by the CF interface module for transmission to the D modules of the cluster . Notably the CF interface modules cooperate to provide a single file system image across all D modules in the cluster . Thus any network port of an N module that receives a client request can access any data container within the single file system image located on any D module of the cluster.

Further to the illustrative embodiment the N module and D module are implemented as separately scheduled processes of storage operating system however in an alternate embodiment the modules may be implemented as pieces of code within a single operating system process. Communication between an N module and D module is thus illustratively effected through the use of message passing between the modules although in the case of remote communication between an N module and D module of different nodes such message passing occurs over the cluster switching fabric . A known message passing mechanism provided by the storage operating system to transfer information between modules processes is the Inter Process Communication IPC mechanism. The protocol used with the IPC mechanism is illustratively a generic file and or block based agnostic CF protocol that comprises a collection of methods functions constituting a CF application programming interface API . Examples of such an agnostic protocol are the SpinFS and SpinNP protocols available from Network Appliance Inc. The SpinFS protocol is described in the above referenced U.S. Patent Application Publication No. US 2002 0116593.

The CF interface module implements the CF protocol for communicating file system commands among the modules of cluster . Communication is illustratively effected by the D module exposing the CF API to which an N module or another D module issues calls. To that end the CF interface module is organized as a CF encoder and CF decoder. The CF encoder of e.g. CF interface on N module encapsulates a CF message as i a local procedure call LPC when communicating a file system command to a D module residing on the same node or ii a remote procedure call RPC when communicating the command to a D module residing on a remote node of the cluster . In either case the CF decoder of CF interface on D module de encapsulates the CF message and processes the file system command.

A data container e.g. a file is accessed in the file system using a data container handle. is a schematic block diagram illustrating the format of a data container handle including a volume ID field an inode number field and a unique ifier field . The volume ID field contains a global identifier within the cluster of the volume within which the data container resides. The inode number field contains an inode number of an inode within an inode file pertaining to the data container. The unique ifier field contains a monotonically increasing number that uniquely identifies the data container handle . The unique ifier is particularly useful in the case where an inode number has been deleted reused and reassigned to a new data container. The unique ifier distinguishes that reused inode number in a particular data container from a potentially previous use of those fields.

In the illustrative embodiment a data container is represented in the write anywhere file system as an inode data structure adapted for storage on the disks . is a schematic block diagram of an inode which illustratively includes a meta data section and a data section . The information stored in the meta data section of each inode describes the data container e.g. a file and as such includes the type e.g. regular directory vdisk of file its size time stamps e.g. access and or modification time an ownership i.e. user identifier UID and group ID GID of the file a link count field and a primary name data structure . The meta data section also includes a generation number and a meta data invalidation flag field . The meta data invalidation flag field is used to indicate whether meta data in the inode is usable. The link count field tracks the number of names and implicitly the number of hard links associated with the inode. For example a link count of one signifies that there are no hard links to the data container and that the only name associated with the inode is the primary name.

The primary name pathname data structure illustratively includes a parent directory inode field a parent directory cookie field and in alternative embodiments additional fields . The parent directory inode field contains an inode value that is associated with the parent directory of the data container. Thus if the data container is a file bar located in the foo directory i.e. foo bar then the parent directory inode field contains the inode number of the foo directory. The parent directory cookie field illustratively contains a multi bit value that identifies a directory block and entry within the directory block of the directory identified by the parent directory inode field .

The contents of the data section of each inode may be interpreted differently depending upon the type of file inode defined within the type field . For example the data section of a directory inode contains meta data controlled by the file system whereas the data section of a regular inode contains file system data. In this latter case the data section includes a representation of the data associated with the file.

Specifically the data section of a regular on disk inode may include file system data or pointers the latter referencing 4 KB data blocks on disk used to store the file system data. Each pointer is preferably a logical vbn to facilitate efficiency among the file system and the RAID system when accessing the data on disks. Given the restricted size e.g. 128 bytes of the inode file system data having a size that is less than or equal to 64 bytes is represented in its entirety within the data section of that inode. However if the length of the contents of the data container exceeds 64 bytes but less than or equal to 64 KB then the data section of the inode e.g. a first level inode comprises up to 16 pointers each of which references a 4 KB block of data on the disk.

Moreover if the size of the data is greater than 64 KB but less than or equal to 64 megabytes MB then each pointer in the data section of the inode e.g. a second level inode references an indirect block e.g. a first level L1 block that contains 1024 pointers each of which references a 4 KB data block on disk. For file system data having a size greater than 64 MB each pointer in the data section of the inode e.g. a third level L3 inode references a double indirect block e.g. a second level L2 block that contains 1024 pointers each referencing an indirect e.g. a first level L1 block. The indirect block in turn contains 1024 pointers each of which references a 4 KB data block on disk. When accessing a file each block of the file may be loaded from disk into the memory .

When an on disk inode or block is loaded from disk into memory its corresponding in core structure embeds the on disk structure. For example the dotted line surrounding the inode indicates the in core representation of the on disk inode structure. The in core structure is a block of memory that stores the on disk structure plus additional information needed to manage data in the memory but not on disk . The additional information may include e.g. a dirty bit . After data in the inode or block is updated modified as instructed by e.g. a write operation the modified data is marked dirty using the dirty bit so that the inode block can be subsequently flushed stored to disk. The in core and on disk format structures of the WAFL file system including the inodes and inode file are disclosed and described in commonly owned U.S. Pat. No. 5 819 292 titled METHOD FOR MAINTAINING CONSISTENT STATES OF A FILE SYSTEM AND FOR CREATING USER ACCESSIBLE READ ONLY COPIES OF A FILE SYSTEM by David Hitz et al. issued on Oct. 6 1998 the contents of which are hereby incorporated by reference in its entirety.

Also in accordance with an embodiment of the present invention each data block comprises one or more directory entries A N. Illustratively the parent directory cookie value uniquely identifies a particular directory entry within the directory identified by the parent directory inode field . That is the inode identified by the parent directory inode field identifies a directory inode . The parent directory cookie value identifies a particular level 0 data block of the directory and a particular directory entry within that level 0 data block .

A file system layout is provided that apportions an underlying physical volume into one or more virtual volumes or flexible volume of a storage system such as node . An example of such a file system layout is described in U.S. Patent Application Publication No. US 2005 0246401 titled EXTENSION OF WRITE ANYWHERE FILE SYSTEM LAYOUT by John K. Edwards et al. published Nov. 3 2005 and assigned to Network Appliance Inc. The underlying physical volume is an aggregate comprising one or more groups of disks such as RAID groups of the node. The aggregate has its own physical volume block number pvbn space and maintains meta data such as block allocation structures within that pvbn space. Each flexible volume has its own virtual volume block number vvbn space and maintains meta data such as block allocation structures within that vvbn space. Each flexible volume is a file system that is associated with a container file the container file is a file in the aggregate that contains all blocks used by the flexible volume. Moreover each flexible volume comprises data blocks and indirect blocks that contain block pointers that point at either other indirect blocks or data blocks.

In one embodiment pvbns are used as block pointers within buffer trees of types of files such as directory stored in a flexible volume. This hybrid flexible volume embodiment involves the insertion of only the pvbn in the parent indirect block e.g. Mode or indirect block . On a read path of a logical volume a logical volume vol info block has one or more pointers that reference one or more fsinfo blocks each of which in turn points to an Mode file and its corresponding Mode buffer tree. The read path on a flexible volume is generally the same following pvbns instead of vvbns to find appropriate locations of blocks in this context the read path and corresponding read performance of a flexible volume is substantially similar to that of a physical volume. Translation from pvbn to disk dbn occurs at the file system RAID system boundary of the storage operating system .

In an illustrative dual vbn hybrid flexible volume embodiment both a pvbn and its corresponding vvbn are inserted in the parent indirect blocks in the buffer tree of a type of file e.g. a directory . That is the pvbn and vvbn are stored as a pair for each block pointer in most buffer tree structures that have pointers to other blocks e.g. level 1 L1 indirect blocks inode file level 0 L0 blocks. is a schematic block diagram of an illustrative embodiment of a buffer tree of a directory that may be advantageously used with the present invention. A root top level inode such as an embedded inode references indirect e.g. level 1 blocks . Note that there may be additional levels of indirect blocks e.g. level 2 level 3 depending upon the size of the directory. The indirect blocks and inode contain pvbn vvbn pointer pair structures that ultimately reference data blocks used to store the actual data of the directory. As noted above in data blocks of directory contain directory entries A N.

The pvbns reference locations on disks of the aggregate whereas the vvbns reference locations within files of the flexible volume. The use of pvbns as block pointers in the indirect blocks provides efficiencies in the read paths while the use of vvbn block pointers provides efficient access to required meta data. That is when freeing a block of a file the parent indirect block in the file contains readily available vvbn block pointers which avoids the latency associated with accessing an owner map to perform pvbn to vvbn translations yet on the read path the pvbn is available.

Whereas the aggregate is analogous to a physical volume of a conventional storage system a flexible volume is analogous to a file within that physical volume. That is the aggregate may include one or more files wherein each file contains a flexible volume and wherein the sum of the storage space consumed by the flexible volumes is physically smaller than or equal to the size of the overall physical volume. The aggregate utilizes a physical pvbn space that defines a storage space of blocks provided by the disks of the physical volume while each embedded flexible volume within a file utilizes a logical vvbn space to organize those blocks e.g. as files. Each vvbn space is an independent set of numbers that corresponds to locations within the file which locations are then translated to dbns on disks. Since the flexible volume is also a logical volume it has its own block allocation structures e.g. active space and summary maps in its vvbn space.

A container file is a file in the aggregate that contains all blocks used by a flexible volume. The container file is an internal to the aggregate feature that supports a flexible volume illustratively there is one container file per flexible volume. Similar to a pure logical volume in a file approach the container file is a hidden file not accessible to a user in the aggregate that holds every block in use by the flexible volume. The aggregate includes an illustrative hidden meta data root directory that contains subdirectories of flexible volumes 

Specifically a physical file system WAFL directory includes a subdirectory for each flexible volume in the aggregate with the name of subdirectory being a file system identifier fsid of the flexible volume. Each fsid subdirectory flexible volume contains at least two files a file system file and a storage label file. The storage label file is illustratively a 4 KB file that contains meta data similar to that stored in a conventional raid label. In other words the storage label file is the analog of a raid label and as such contains information about the state of the flexible volume such as e.g. the name of the flexible volume a universal unique identifier uuid and fsid of the flexible volume whether it is online being created or being destroyed etc.

Each fsinfo block also includes a block pointer to an inode file that contains inodes of a plurality of files including an owner map an active map a summary map and a space map as well as other special meta data files. The inode file further includes a root directory and a hidden meta data root directory the latter of which includes a namespace having files related to a flexible volume in which users cannot see the files. The hidden meta data root directory includes the WAFL fsid directory structure that contains file system file and storage label file . Note that root directory in the aggregate is empty all files related to the aggregate are organized within the hidden meta data root directory .

In addition to being embodied as a container file having level 1 blocks organized as a container map the file system file includes block pointers that reference various file systems embodied as flexible volumes . The aggregate maintains these flexible volumes at special reserved inode numbers. Each flexible volume also has special reserved inode numbers within its flexible volume space that are used for among other things the block allocation bitmap structures. As noted the block allocation bitmap structures e.g. active map summary map and space map are located in each flexible volume.

Specifically each flexible volume has the same inode file structure content as the aggregate with the exception that there is no owner map and no WAFL fsid filesystem file storage label file directory structure in a hidden meta data root directory . To that end each flexible volume has a volinfo block that points to one or more fsinfo blocks each of which may represent a snapshot along with the active file system of the flexible volume. Each fsinfo block in turn points to an inode file that as noted has the same inode structure content as the aggregate with the exceptions noted above. Each flexible volume has its own inode file and distinct inode space with corresponding inode numbers as well as its own root fsid directory and subdirectories of files that can be exported separately from other flexible volumes.

The storage label file contained within the hidden meta data root directory of the aggregate is a small file that functions as an analog to a conventional raid label. A raid label includes physical information about the storage system such as the volume name that information is loaded into the storage label file . Illustratively the storage label file includes the name of the associated flexible volume the online offline status of the flexible volume and other identity and state information of the associated flexible volume whether it is in the process of being created or destroyed . Illustratively an alternate name file is located in the hidden meta data directory . The alternate name file is utilized to store I2P mapping information associated with alternate names of an inode and is illustratively implemented as a balanced e.g. B tree structure to enable fast searches. Further lock file and watch file may also be included within the hidden meta data directory as described herein.

The VLDB is a database process that tracks the locations of various storage components e.g. flexible volumes aggregates etc. within the cluster to thereby facilitate routing of requests throughout the cluster. In the illustrative embodiment the N module of each node accesses a configuration table that maps the volume ID of a data container handle to a D module that owns services the data container within the cluster. The VLDB includes a plurality of entries which in turn provide the contents of entries in the configuration table among other things these VLDB entries keep track of the locations of the flexible volumes hereinafter generally volumes and aggregates within the cluster.

Most file level protocols include locking functionality that enables a client to transmit an operation to a software module that acts in conjunction with a file system to implement a lock on either an entire file or a defined subset of a file. A lock is a mechanism that represents the right of an owner such as a client or system administrator to access a shared resource. An entity later attempting to access this shared resource will be notified of the lock which may in the case of an exclusive lock prevent others from accessing the resource. The types of locks can vary for example in some instances there may be a write lock placed on a resource by the owner yet other entities may be able to obtain read access to the resource. The type of lock and or the absence of a lock over a particular data container such as a file or portion thereof are referred to herein as a lock state. In particular once the lock e.g. a write lock is granted only the client owning the lock may perform certain operations e.g. write operations directed to the file or subset thereof. Other clients attempting such operations will have these operations denied by the file system. Typically the file system maintains the current lock state in the memory of the storage system i.e. in core. That is if a client acquires a lock information concerning the lock is typically retained in an in memory data construct that may be quickly accessed by the file system when determining whether to permit deny subsequently later requested operations.

Commonly owned co pending U.S. Pat. No. 7 587 558 entitled SYSTEM AND METHOD FOR MANAGING HARD LOCK STATE INFORMATION IN A DISTRIBUTED STORAGE SYSTEM ENVIRONMENT filed on Nov. 1 2005 by Toby Smith et al. describes providing a technique for managing lock state information in a distributed storage system architecture comprising two or more volumes distributed across a plurality of nodes interconnected as a cluster. In particular as described therein a lock manager is configured to efficiently manage the lock state information lock file including granting revoking and releasing of various types of locks on data containers or ranges of data containers stored on the storage system.

Briefly is a schematic block diagram of an exemplary lock file in accordance with an embodiment of the present invention. The lock file illustratively comprises a plurality of entries . Each entry contains an owner field and one or more lock fields i.e. each entry is associated with a single owner of one or more locks in the file system. Each lock field illustratively comprises a data container handle field a lock state field and in alternate embodiments additional fields . The data container handle field contains a data container e.g. a file handle identifying the file with which the lock is associated. The lock state field identifies the current state of the lock including e.g. type range etc. Also in accordance with one or more embodiments of the present invention each entry may also contain a watch pointer field to point to associated watches corresponding to the data container identified in file handle field .

Certain events occurring within the storage system and or a storage operating system executing thereon may result in a message being displayed to an administrator. For example the storage system may detect that one or more data containers have become corrupted. A pathname provides a way for the administrator to refer to a data container served by the storage system. To that end each pathname typically represents one data container within the hierarchical structure of the file system. However the storage system typically reports the identity of the data container to the administrator by using its associated inode number. The inode number is used internally within the file system to identify the inode associated with the data container and unfortunately is not easily understood by humans. It is therefore desirous for the administrator to know the pathname of the data container to which the message relates so that appropriate action may be taken. One technique for generating inode to pathname information I2P is described in the above incorporated U.S. Patent Application Publication No. US 2006 0288026 entitled SYSTEM AND METHOD FOR GENERATING AND MAINTAINING INODE TO PATHNAME MAPPING INFORMATION by Ed Zayas et al. published on Dec. 21 2006. In such an environment a primary name data structure is included within each inode. The primary name data structure contains information identifying a specific directory entry associated with a primary name of the data container. Illustratively additional names for a data container e.g. hard links may be stored in an alternate name file in a metadata directory within the file system.

As described in the above incorporated U.S. patent application Ser. No. 11 156 679 filed on Jun. 20 2005 by Edward R. Zayas et al. the I2P functions of the storage operating system operate in conjunction with the file system to permit processes to read and or write I2P information from either a primary name data structure within an inode or from an alternate name file . Such reading writing operations described further below may be utilized by the various watch processes of the present invention. In accordance with the illustrative embodiment of the present invention any reading writing techniques for obtaining setting the I2P information may be utilized. As such these procedures should be taken as exemplary only.

The procedure begins in step and continues to step where the file system and I2P functions retrieve read the primary name data structure from the inode. In step the file system and I2P functions determine whether the primary name data structure contains a zero value. Illustratively a zero value within the primary name data structure signifies that the file system has not yet identified the appropriate I2P mapping information for this inode. This may be because an initial scan described further below has not yet reached this particular inode or may be due to corruption of the information which has resulted in the file system clearing the I2P information to prevent incorrect results being returned. If the primary name data structure within the inode contains a zero value the procedure branches to step signifying that the I2P mapping information is not set before completing in step . Illustratively a caller or program invoking procedure will return information signifying that the I2P mapping information is not available. In alternate embodiments if the primary name data structure is zero then the file system invokes the scanner described further below to generate the appropriate information. In such alternative embodiments the scanner which is illustratively part of the I2P functions generates the appropriate primary name data structure contents before re initiating procedure .

If in step the value is not zero then the procedure continues to step where a determination is made whether the option e.g. a has been selected to display return alternate names. If the alternate names option has not been set the procedure branches to step and returns the primary name before completing in step .

However if in step it is determined that the alternate names are desired the procedure continues to step where a determination is made as to whether the alternate name file contains entries associated with this inode. If the alternate names file does not contain any associated entries then the data container only has a primary name which is returned in step before the procedure completes in step . The primary name is determined by examining the directory entry in the appropriate directory that is identified by the cookie value within the primary name data structure . However if in step there are alternate names identified then the file system returns the primary name and the alternate name s in step before completing in step . The alternate name s are identified in a similar manner to the primary name i.e. the directory is identified by the parent directory inode and a specific entry within the directory is identified by the cookie value.

Once the directory entry has been removed and the link count updated the procedure proceeds to step where a determination is made as to whether the link count is greater than zero for the inode. If the link count is not greater than zero then the procedure branches to step and completes. An inode will have a link count of zero when the one and only name associated with it is removed thereby indicating that the data container associated with the inode may be removed from the file system.

In step an alternate name of the data container is promoted to the primary name. Illustratively the first alternate name stored in the alternate name file is selected and stored within the primary name data structure of the inode as the new primary name. Once the newly promoted primary name has been stored the file system and I2P functions remove the promoted alternate name from the alternate name file in step before the procedure completes in step . However if in step it is determined that the name to be deleted is not the primary name the procedure branches to step where the name is removed from the alternate name file. This may be accomplished using conventional B tree removal operations. In alternate embodiments where the alternate name file is not implemented as a B tree appropriate conventional entry removal operations are utilized. In step the appropriate directory entry is removed and the link count of the inode is updated before the procedure completes in step .

The present invention overcomes the disadvantages of the prior art by providing a system and method for supporting Change Notify watches in virtualized storage systems. In particular techniques of the present invention advantageously emulate Change Notify features e.g. as documented by the CIFS protocol on virtualized storage systems by leveraging virtualization mapping information e.g. an inode to path or I2P mapping to walk a file system tree backwards from the data blocks to their higher level file and directory inodes ancestors to determine whether there are applicable watches on ancestor directories and to obtain a pathname of the watched changed data. In particular changes to data received from different protocols e.g. CIFS NFS HTTP etc. can trigger watches to clients on the virtualized storage system. Also performance may be enhanced using various caching techniques and watch state may be retained while moving watched data across volumes of the virtualized storage system.

As noted above it is often desirable for a client system or administrator to be aware of changes to data on a storage system. Change Notify is a facility in CIFS network filesystems that notifies clients of any changes made to data containers such as directories and or files of the storage system e.g. at a single directory level or an entire subtree level. The client identifies the directories and actions it wants reported by setting watches on these directories. When changes are made to a file or directory having an associated watch as requested by the client the watch is triggered and a response is sent to notify the client of the change. To be understood by those skilled in the art changes may be conveyed to the client through NT TRANSACT NOTIFY CHANGE commands of a conventional Server Message Block SMB NT Trans Request. Notably while one or more embodiments described herein reference the CIFS protocol and associated Change Notify features changes made by other protocols such as NFS HTTP FTP etc. as will be understood by those skilled in the art may also be watched and reported in accordance with one or more techniques described herein. In particular by nature of a virtualized storage system illustratively a networked virtualized storage system arbitrary protocols may be allowed access to the stored data and any resultant changes should be detected and reported accordingly.

As a simple example of watches and Change Notify features assume that two user interface windows are open displaying a same directory. If a change is made within a first window e.g. adding a file text.txt it may be desirable to have the change be reflected in a second window e.g. showing the added file text.txt . Conventional CIFS Change Notify features without underlying virtualized storage systems may have placed a watch on the directory such that detecting the change within the open directory results in a change notification that updates the second window to include the added file. Also inheritable watches may be set on directories so that events within a subtree hierarchically below the watched directory may result in notifications e.g. directories within the watched directories . Thus a client may set inherited watches on data hierarchically below a directory upon which an inheritable watch is set e.g. other directories and or files beneath the watched directory .

This simplified example however demonstrates conventional Change Notify features that are made available through the client s operating system which locally manages storage and is thus aware of file and directory locations in storage. With virtualized network storage systems however such as the logical volumes served by the storage system described herein problems may arise with supporting Change Notify watches. In particular the client s local operating system is generally unaware of the actual physical storage locations of the files and directories on the logical volumes of the storage system and as such is generally unable to monitor for changes particularly those made by clients sharing the logical volumes. Also in a clustered storage system described herein D modules that control the underlying physical storage are only aware that data has changed not to which particular files or directories that data belongs e.g. handled by N modules of the clustered storage system . This problem is particularly prevalent where an N module of one node is communicating with a client that desires a directory be watched while the directory is under the control of a D module of another separate node . As such prior to the inventive techniques described herein it has been difficult to support Change Notify watches on virtualized storage systems.

Operationally according to one or more embodiments of the present invention data is stored on data containers of a storage system that may be arranged as one or more logical volumes e.g. a clustered storage system and a mapping is maintained from the data containers to corresponding parent directories of a file system of the storage system e.g. I2P mapping . Watches may be set e.g. by clients on one or more of the directories to request that changes made to data stored within the directories be reported in accordance with Change Notify features. Illustratively in the event a change is detected to data the mapping may be traversed to determine whether there are applicable watches on ancestor directories i.e. whether the changed data is part of hierarchically below a watched directory . In the event a change is detected to data stored within a directory upon which a watch is set the mapping is also traversed to determine a pathname e.g. a relative pathname of the changed data based on the corresponding parent directories and the pathname is reported e.g. to the client . Notably in accordance with expected SMB change notification mechanisms the relative pathname from the watch to the object that was changed is what is illustratively reported.

If the watches define an action or a plurality of actions to be taken in response to changes then the system also takes that action or those actions such as performing a delete pending procedure etc. Also if multiple watches are set on a single directory then the system may take the action defined by each of the plurality of watches in response to changes made to the data. In this manner the novel techniques described herein conform to the standard CIFS protocol such that all notification events and expected Change Notify features are supported on the virtualized storage system accordingly.

Also according to an aspect of the present invention triggered watch events may be cached. Such caching may increase performance and reduce storage requirements. For instance caching may be used to prevent duplicate reports and to prevent traversal of the mapping based on previously stored pathnames. In particular generation numbers may be used to keep track of changes in directories being watched inheritance of watches the inode events for watches the post trigger or client notification of watches etc. Specifically with generation numbers the novel techniques can cache the paths and event information until further changes are made to the events or directories to be notified as described herein.

Notably as used herein the term mode is used as a filter that a client specifies in a watch to limit what types of file system actions are watched e.g. create modify delete etc. . Also the term post is the act of returning a watch notification from the D module to the N module via a notification callback mechanism. Further post action represents the type of post that is occurring. In addition as described herein watch state may be associated with inode based lock structures locks that are assigned to the data and watch volume states may be maintained by the lock manager .

Illustratively there are four main classes of in core data structures that may be used to implement watches in accordance with one or more embodiments of the present invention. Namely those data structures comprise Watch State data structures Watch Cache data structures Watch Trigger data structures and Global data structures each as described in detail below.

In particular Watch Directory Structure comprises one or more fields used to carry store associated information. Mode summary field contains a superset of modes on all the watches. Inherit mode summary field contains a mode summary for only inherited watches. Watch open count field contains a total number of watches for this directory. Watch open list field contains a list of all watches on the directory. Volume pointer field contains a pointer to the volume containing this directory. Finally Lmgr pointer field contains a pointer to a lock manager file object lock file of this directory.

In particular Watch Open Structure comprises one or more fields used to capture watch information that is static for the life of the watch. Flags may indicate various states of the watch such as e.g. a too many flag that is set when there is a need to indicate that there have been too many changes to keep track of or a posted flag that is true when the open is on the associated post list of Global Data Structure . Lock ID field identifies a lock granted to the client on file open create. Directory backpointer field contains a backpointer to the associated directory. Watch mode field contains a mode that is set the first time the watch is created. Number posts field contains a number of posts illustratively having a buffered limit set to a maximum number of concurrent posts e.g. 8 . Posts field contains an array of posts that is pending on this open that is a small set of posts that are pending for Notification callback processing described below . Total post bytes field contains a total number of bytes to post e.g. used to detect a too many condition . Notify time field contains a timing value used to indicate when to trigger the next callback e.g. set on the first post and reset after a callback . Next watch field links all watches Watch Opens for the same directory file. Buffered post watches field contains a list of all watches which have some posts buffered and are linked to the post list of the volume. This field may be scanned by a notify callback message described below to fire generate send the callbacks. Lastly Instance pointer field contains a list of zero or more instances of this watch that have been created by the client i.e. pointers to Watch Instance Structures .

In particular Watch Instance Structure comprises one or more fields used to carry store associated information. Next instance field contains a pointer to the next instance in a linked list of instances associated with an open Watch Open e.g. as in . Watch cookie field contains an opaque cookie passed when the Watch Instance Structure is created and is used as described herein. Request preallocation placeholder field contains a placeholder for request preallocation that may be used when deleting a directory being watched. In particular in that case all instances have to notify clients of the pending delete before freeing the instances described below . Also Watch max buffer size field may be passed in the watch request and contains the maximum number of bytes that can be sent back to the client for this watch e.g. which if exceeded may return a too many condition .

As noted another type of data structure that may be used with the present invention is a Watch Cache Data Structure. is an illustrative block diagram of an example Watch Cache Data Structure in accordance with the present invention. Watch Cache Data Structure may be used to cache watch information for individual file system objects to minimize processing when watches are checked or watch notifications are posted as described herein. In particular the Watch Cache Data Structure may have sub structures comprising a Watch Volume Structure and a Watch Inode Cache Structure .

In particular Watch Volume Structure comprises one or more fields used to carry store associated information. Directory generation field contains a directory generation number which tracks additions of non inherited watches to a volume generation numbers are described in more detail below . Inherited generation field contains an inherited generation number which tracks additions of inheritable watches to a volume. Mode generation field contains a mode generation number which tracks additions to the modes being watched for individual watches. Mode mask field contains a lists supported modes of the volume. Number directory watches field contains a count of the number of inheritable and non inheritable watches on the volume. Number inherited watches field contains a count of the number of inheritable watches and directories on the volume. Statistics field contains a set of per volume statistics. Watch list field contains a list of all the Watch Directory Structures associated with the volume. Lastly Prune list field optional contains a list of stale opens watches that is for use with recycling Watch Opens which have no Watch Instances for a configured length of time e.g. such as when a client doesn t renew a watch .

If the Watch Inode Cache Structure is present it can be used to determine if the cache is valid if a post is necessary and if an I2P parent walk is necessary to locate possible watches. The Structure generally contains a watch mode summary that is the superset of all watches that is filtering for this object a path to the most ancestral watch for the object present only when a post has occurred for the object and a matching set of generation numbers for those in the Watch Volume Structure each of which is compared to determine the validity of various aspects of the Watch Inode Cache Structure information. Also an additional post generation number is compared with a global post generation number kept in the Watch Global structure to allow for the efficient suppression of rapid duplicate posts.

In particular Watch Inode Cache Structure comprises one or more fields used to carry store associated information. Directory generation field corresponds to Directory generation field of Watch Volume Structure . Inherited generation field corresponds to Inherited generation field of Watch Volume Structure . Mode generation field corresponds to Mode generation field of Watch Volume Structure . Post generation field corresponds to Post generation field of Watch Global Structure below and contains a post generation number which is changed after every notification callback set is sent. Post action mask field contains a mask of all of the actions that have triggered for this inode during the current Post generation period. Notably Post action mask may be used in conjunction with Post generation field to suppress rapid duplicate triggers. Mode summary field contains a summary of all of the applicable modes accumulated through the parent chain of this inode. Lastly Path pointer field contains a pointer to a path that is the complete path from this inode to the top most watch in the associated I2P chain which may be empty .

Generation numbers as mentioned above and as used to fill certain various fields described above are a type of timing count number that may be updated changed e.g. increased incremented upon certain defined actions. Generally generation numbers may change in response to creating watches handling watches and handling notification callback messages. The four types of generation numbers mentioned above and used in accordance with one or more embodiments of the present invention are directory generation inherit generation mode generation and post generation.

Directory generation fields contain values generation numbers that are incremented bumped whenever a new Watch Directory is added to the volume. These signify that a new directory is being watched for the first time. The generation number is not incremented when a new watch Watch Open is added to a directory that already has watches present or when a Watch Directory Structure is removed. A change to this value informs the file operation watch handling code that its summary mode may be incorrect and should be recomputed. If only Directory generation has changed and Inherit generation has not existing caches with modes that were not inherited only need to check for parent node changes that is a complete I2P parent walk is not necessary.

Inherit generation fields contain values that are incremented whenever a directory is watched and the watch is inheritable or when the first inheritable watch is added to an existing watched directory. The value is also incremented when a directory is renamed since an associated inheritance has changed. The value is not incremented when a non directory file is renamed nor when an inheritable watch is removed. If inode caches have Inherit generation mismatches then the inheritance structure has changed and cached paths must be released and I2P walks are necessary to find interested watchers.

Mode generation fields contain values that are incremented whenever a new watch is added to an existing watched directory and the new watch adds new trigger mode bits to the mode summary for the directory. This signifies that the inheritance structure has not changed but that summary trigger mode values are no longer valid and should be recomputed. When an inode indicates that it has no watchers mode generation changes can be safely ignored.

Post generation fields contain values that are incremented during notify callback processing. Along with the watch action value stored in the inode cache Post action mask this value allows rapid duplicate posts to be avoided since each inode only needs to post the first instance of an action during a single notify callback cycle.

Still another type of data structure that may be used with the present invention is a Watch Trigger Data Structure. is an illustrative block diagram of an example Watch Trigger Data Structure in accordance with the present invention. Watch Trigger Data Structure may be created and populated when watch events are triggered i.e. changes are made to watched data thus triggering post operations as described herein. In particular the Watch Trigger Data Structure may have substructures comprising a Watch Post Item Structure and a Watch Post Set Structure .

Illustratively as described herein notification callbacks aka posts may be computed during the LOAD phase and committed during the MODIFY phase of appropriate file operation handlers. The watch process mechanism uses one or more Watch Post Item structures each of which represents a post and a Watch Post Set structure which is a container for all of the posts generated for a single file operation. For example the Watch Trigger Data Structure illustratively contains a list of actions to post in Item Structures each post containing a watch relative pathname and an action to be performed and a summary mask for all of the post actions contained in the post set in Set Structure . During the MODIFY phase of file operations described herein Watch Post Set is walked and paths are committed allocated and transferred from the Watch Post Item structures to slots in the appropriate Watch Open Structures .

In particular Watch Post Item Structure comprises one or more fields used to carry store associated information noted above. For instance Next pointer field contains a pointer to a next post item in a chain e.g. empty if no further items exist . Open pointer field contains a pointer to the Watch Open Structure with which this post is associated. Watch action field contains the action associated for this post item. Primary name field contains information that corresponds to path pointer below and may be used along with Watch action to uniquely identify post sources so that multiple posts may be collapsed removed etc. Path pointer field contains a relative path from the watched directory that the open Watch Open is associated with to the object that posted the watch e.g. which if null signifies an error .

Also is an illustrative block diagram of an example Watch Post Set Structure in accordance with the present invention. Illustratively each Watch Post Set Structure is used to contain all of the Watch Post Item Structures that are processed by a file operation during its modify phase. In addition Structure contains a roll up of the post actions being signaled by the enclosed Post Items which is used to update the Post generation field of the associated Watch Inode Cache Structure during the modify phase. According to an illustrative embodiment the Watch Post Set Structure may be allocated on a file operations stack as may be appreciated by those skilled in the art.

Watch Post Set Structure comprises one or more fields used to carry store associated information noted above. For instance Action mask field contains a rollup of all of the individual actions contained in the individual post items . Post count field contains a number of elements in Item pointer field which contains a list of Watch Post Item Structures e.g. terminated by null . Further Watch volume pointer field contains a pointer to the volume to which this post set relates which may be null and that may be used for the case when renaming a directory and the Inheritance generation needs to be incremented during the MODIFY phase.

The last noted type of in core data structure that may be used with the present invention is a Watch Global Data Structure. is an illustrative block diagram of an example Watch Global Data Structure in accordance with the present invention. Generally there is one Watch Global Data Structure per D module . In particular Watch Global Data Structure comprises one or more fields used to carry store associated information noted above. For instance Structure may contain a global list of triggered watches in Post list field which carries a list of Watch Open Structures that have pending posts notification callbacks that remain in this list until processed. That is Post list contains a list of watches which have posts after their last callback. It is this post list that is scanned in order to send notifies callbacks . Further as noted above Post generation field may contain values that are incremented after each notification callback processing cycle used to eliminate rapidly repeated duplicate posts. Lastly various freelists and other related data may be used for memory management and summary statistics field may contain other global variables statistics for the node D module for watch operation processing e.g. ASUP data as described below .

In accordance with one or more embodiments of the present invention the file system e.g. watch process may check for watch triggers during particular file operations. For instance there are three situations when triggers are checked when an object is created or linked when an object is modified and when an object is deleted or unlinked. For example the following file operations have the associated watch processing 

Each of the forms of watch checking create modify delete may follow the same basic algorithm although each may have its own customization. For example while checking watches for deletes actions need not be kept in an inode cache since the object is being removed or its link count is being reduced. Illustratively watches are triggered during a LOAD phase of file operations which is where the operating system reserves necessary resources for the operation to ensure success of the operation. Specifically if a watch triggers the appropriate post s are computed in the LOAD phase. These posts may then be committed in a MODIFY phase of the file operations which is where those reserved resources from the LOAD phase are committed. In this manner the posts are not committed unless the entire file operation is successful.

It step a determination is made as to whether the Watch Inode Cache shows that no watches are interested in this action. If there are no interested watches an early out causes the procedure to end in step . If however there is at least one interested watch in step the system may then determine in step whether this action has been posted for this object during this post generation cycle as described herein. If so an early out condition causes the procedure to end in step but if not the action needs to be posted. As such if there is no cached path in Watch Inode Cache in step then the path may be computed to the farthest ancestor watch in step e.g. using I2P walk with directory loads. Once the path is cached Watch Post Set is computed for the object e.g. through an I2P walk and the procedure for the LOAD phase of a file operation ends in step .

Note again that I2P ancestor walking traversing I2P mappings as described in detail above may be used by watch process to obtain the relative pathname of a file or directory by walking e.g. bottom up through the file s or directory s ancestor chain. In other words with the information stored in the inodes walking backwards up the file system tree from the filename to its ancestors is allowed thus enable watch lookup and notification callback pathname construction as described herein. In particular the I2P walking is necessary to create or update an object s Watch Inode Cache Structure compute an object s path pathname for posting and compute the Watch Post Set for an object as described herein.

As an example assume that a path exists from a root of the file system to an object x and the full path pathname is a b c x as will be appreciated by those skilled in the art. In the event that an inherited watch is set on directory b when object x is modified changed an I2P walk is performed from x to a to discover that there is a watch at b that is interested in the change. Once the interested watch is located another I2P walk may be performed to construct a relative pathname from b to x e.g. after an intermediate I2P walk to determine the distance from the changed object to the watched directory accordingly thus resulting in relative pathname c x that may be sent to the clients accordingly. These multiple I2P walks are necessary due to the fact that there may be multiple watches set up and down the path so the watches and distances can be determined prior to constructing the pathname. As such the caching techniques described herein may be advantageously utilized to reduce the number of I2P walks necessary during watch trigger processing. In accordance with one or more embodiments described herein a notification callback e.g. NOTIFY CB operation may be sent to inform N modules of watch posts e.g. the pathnames generated at D modules e.g. within a CF Message . The N module i.e. the device setting the watch watch process in turn may send notifications of these events e.g. the pathnames to the proper CIFS e.g. Windows client identified by the Watch cookie of Watch Instance given to the client as part of the callback. Illustratively a file system backdoor message or other dedicated thread and or timeout mechanism may be used to trigger periodic generation of notification callback messages such as at a timeout interval e.g. one second. Clients may respond to the callback messages with requests to renew or cancel the associated watch where renewing a watch maintains a current Watch Open intact not adding another Watch Instance .

Notably watches for volumes that are offlined or unmounted may illustratively maintain their state as with the locks such that upon returning onlined or remounted the watches remain active. In this manner watches may only be closed in response to a specific request from the client or if the corresponding file or illustratively the corresponding lock is deleted. Further in the event of a sendhome as will be appreciated by those skilled in the art locks and watches may be destroyed on the source node. When a watch is destroyed any pending notification callbacks are consequently aborted ceased. Further if a directory being watched by one client is deleted by another client all existing watches on that directory are posted by D module with a watch action DELETE PENDING which indicates that the directory or file within the directory is about to be deleted by another client. This indication prompts the corresponding N module to respond to the appropriate CIFS Windows clients with DELETE PENDING as expected by the CIFS Change Notify features as will be understood by those skilled in the art. Notably as an added optimization if a directory is marked as deleted by the system but is still waiting on the last client to close the directory e.g. DELETE ON CLOSE semantics of the CIFS protocol for DELETE PENDING any attempt made by clients to set watches on this deleted directory may be replied to with a DELETE PENDING notification without setting the watch on the deleted directory.

In addition in accordance with one or more embodiments of the present invention various support or auto support ASUP measurements e.g. on per volume and per node basis may be kept with regard to the watch support. For instance the following statistics inter alia may be kept e.g. in global statistics field and or volume statistics field the number of times an inode watch cache was valid and reused cache hits the number of times an inode watch cache was updated but not allocated cache updates the number of times an inode watch cache was created cache creates the number of times watch I2P walks to the root of the volume were performed I2P root walks the number of times single level watch I2P walks were performed not to root of volume I2P single level walks the number of I2P walks to compute watch paths that cause the directories to be loaded I2P path walks the number of times cached paths were good I2P path cache hits the average path lengths of watch paths e.g. in elements not bytes I2P path length average the number of times watch post processing was averted because of cache hits post cache hits the number of I2P walks to compute watch posts post walks the number of watch posts watch posts the number of directories that are being watched watched directories etc.

Volumes are often moved between nodes of a cluster and the expectation is that the move is completely transparent to clients i.e. no outage to file access or loss of state. Because watches represent a Change Notify state the watches and associated information also need to be moved. As such according to another aspect of the present invention if the logical volumes are moved from a first storage device e.g. serviced by a first D module of a clustered storage system to a second storage device e.g. serviced by a second D module the watches are retained during the move to the second storage device.

In particular as noted herein watches are closely paired with locks. As such a new operation may be defined in accordance with the present invention to identify the presence of watch information along with the lock information to reproduce watch state on the destination of volume move. For example a new flag may be set within a lock transfer command to indicate that the lock has associated watches. Note that this may allow for backward compatibility with systems not supporting watches. 

Note that for local volume moves i.e. volume moves within control of a same D module watches need not be recreated. Instead the watches may remain attached to their Watch Directory and associated locks and the volume pointer in the Watch Directory is reassigned and watch counters generation numbers from the old volume are copied to the new volume. Since there are no outstanding posts at this point i.e. have been flushed the Global Post list is empty on the source volume. The new volume watch information including the generation numbers and counters are reinitialized so that all inode caches are invalidated and will trigger a slow path approach during posting that is does not have the benefits of the caching as described above .

In summary the present invention advantageously overcomes the disadvantages of the prior art by providing a system and method for supporting Change Notify watches in virtualized storage systems. In particular techniques of the present invention emulate Change Notify features e.g. as documented by the CIFS protocol on virtualized storage systems by leveraging virtualization mapping information e.g. an inode to path or I2P mapping to walk a file system tree backwards from the data blocks to their ancestors to obtain a pathname of the watched data. Also performance may be enhanced using various caching techniques and watch state may be retained while moving watched data across volumes of the virtualized storage system.

If the watch defines an action that action may be taken in step . Also if there are a plurality of set watches on the changed data in step then each action defined by each of the plurality of watches may be taken in step e.g. as described above multiple posts callbacks . In step however triggered watch events may be cached to prevent duplicate reports and to prevent traversal of the mapping based on previously stored pathnames. The procedure ends in step .

While there have been shown and described illustrative embodiments that supporting Change Notify watches in virtualized storage systems it is to be understood that various other adaptations and modifications may be made within the spirit and scope of the present invention. For example the embodiments have been shown and described herein in conformance with CIFS and associated Change Notify features functionality. However the embodiments of the invention in its broader sense are not so limited and may in fact be used with the Network File System NFS protocol. Further while volumes are illustratively organized using inodes the techniques described herein may be equally applicable to any type of volume organization and the volume need not comprise an inode tree structure.

In addition certain storage system vendors have implemented various forms of I2P mapping functionality. For example the Novell NetWare system stores character strings of all of the names associated with an inode within the inode itself. However inodes are typically fixed sized data structures and if a sufficient number of names are associated with an inode additional spill over inodes must be allocated for the data container. Such a solution increases the complexity of managing data and utilizes extra and valuable inode numbers which may be limited within the file system. Alternately the Solaris operating system available from Sun Microsystems Inc. stores a pathname in the in memory vnode data structure. However modifications to the names of any directories in the pathname are not updated in the cached path within the vnode. Should a directory be renamed the cached pathname data within the vnode data structure is not updated which can result in incorrect pathnames being presented to an administrator. Another noted disadvantage is that no pathname information is stored persistently. Accordingly while the inode tree structure and I2P mapping techniques described above are merely one representative example of mapping that may be used with the present invention it may be appreciated by those skilled in the art that other albeit possibly less efficient mapping techniques may also be used in conjunction with the present invention.

The foregoing description has been directed to particular embodiments of this invention. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. Specifically it should be noted that the principles of the present invention may be implemented in non distributed file systems. Furthermore while this description has been written in terms of N and D modules the teachings of the present invention are equally suitable to systems where the functionality of the N and D modules are implemented in a single system. Alternately the functions of the N and D modules may be distributed among any number of separate systems wherein each system performs one or more of the functions. Additionally the procedures processes and or modules described herein may be implemented in hardware software embodied as a computer readable medium having program instructions firmware or a combination thereof. Therefore it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.

