---

title: Font file with graphic images
abstract: At least certain embodiments of the present disclosure include a font file having graphic image files. In one embodiment, the font includes a set of glyphs and the font file includes a set of predetermined information of each glyph and graphic image data of each glyph. The graphic image data contains a graphic image of the corresponding glyph, which may be a multi-color glyph.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08687004&OS=08687004&RS=08687004
owner: Apple Inc.
number: 08687004
owner_city: Cupertino
owner_country: US
publication_date: 20101101
---
As many word processing applications and digital publishing applications become more widely used many new fonts have been developed to provide users with more options and flexibility in creating or authoring documents e.g. books slides flyers product literature webpages menus etc. . Conventionally a font includes a set of glyphs that define the appearance of characters in the font. Furthermore parameters that define various characteristics of the glyphs can be provided in one or more font tables of the font. These characteristics may include dimensions of the glyphs spacing and color. In order to properly define these characteristics a font may include a huge number of parameters organized in a complicated manner. For example one conventional true type font may have a font file having thirty or more tables containing various parameters to define the glyphs of the true type font. Because of the complexity in organizing and using these parameters glyphs of conventional color true type fonts are limited to monochrome. In other words each glyph of conventional color true type fonts is in a single color only.

Some embodiments include one or more application programming interfaces APIs in an environment with calling program code interacting with other program code being called through the one or more interfaces. Various function calls messages or other types of invocations which further may include various kinds of parameters can be transferred via the APIs between the calling program and the code being called. In addition an API may provide the calling program code the ability to use data types or classes defined in the API and implemented in the called program code.

At least certain embodiments include an environment with a calling software component interacting with a called software component through an API. A method for operating through an API in this environment includes transferring one or more function calls messages other types of invocations or parameters via the API.

Some embodiments of the present disclosure include a method for supporting fonts with multi color glyphs. In some embodiments a font file is created for a font including one or more multi color glyphs. The font file includes a set of characteristics of each multi color glyph such as size and outline of a respective glyph. The font file further includes graphic image data for each glyph. The graphic image data can be in any graphic format such as for example Portable Network Graphic PNG Graphic Interchange Format GIF Tagged Image File Format TIFF Joint Photographic Expert Group format JPEG etc. Thus the font file may also be referred to as a graphic image based font file. Because the graphic image data may contain a colored image of the respective glyph which can be reproduced e.g. rendered or printed as a graphic image and hence there is no need to include complicated coding or parameters to specify the color s of the glyph in the font file. In some embodiments the font file further includes a reference e.g. a pointer for each glyph to refer to a location of the corresponding graphic image file. The font file can be stored on a computer readable storage medium accessible by a layout engine and a font parser. The layout engine and font parser can access the font file to retrieve information of one or more glyphs of the font in order to render and or print the glyphs.

Some embodiments of the present disclosure include a method for printing multi color glyphs. In one embodiment a layout engine sends an instruction to a graphic engine to draw a glyph of a font. In response the graphic engine sends a request to a font parser to request information on some predetermined characteristics commonly referred to as glyph metrics of the glyph. The font parser accesses the font which may be stored in a stand alone font file or embedded in other files to retrieve such information and returns the information to the graphic engine. In some embodiments the glyph metrics includes the origin of the glyph i.e. location relative to the drawing position the advance i.e. distance to move to after drawing the glyph and the bounding box i.e. the rectangular region occupied by the glyph . Based on the glyph metrics the graphic engine sets aside a region on a printing medium leaving the region blank. The layout engine further requests a color bitmap of the glyph from the font parser. In response the font parser retrieves the color bitmap requested from the font and sends it to the layout engine. Using a reference in the color bitmap the layout engine retrieves some graphic image data of the glyph from the font. Then the layout engine instructs the graphic engine to draw the image of the glyph according to the graphic image data in the blank region thus effectively printing the glyph at the location of the blank region.

Various devices which perform one or more of the foregoing methods and machine readable media which when executed by a processing system cause the processing system to perform these methods are also described.

Various embodiments and aspects of the disclosure will be described with reference to details discussed below and the accompanying drawings will illustrate the various embodiments. The following description and drawings are illustrative of the disclosure and are not to be construed as limiting the disclosure. Numerous specific details are described to provide a through understanding of various embodiments of the present disclosure. However in certain instances well known or conventional details are not described in order to provide a concise discussion of embodiments of the present disclosure.

Some portions of the detailed descriptions which follow are presented in terms of algorithms which include operations on data stored within a computer memory. An algorithm is generally a self consistent sequence of operations leading to a desired result. The operations typically require or involve physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like can refer to the action and processes of a data processing system or similar electronic device that manipulates and transforms data represented as physical electronic quantities within the system s registers and memories into other data similarly represented as physical quantities within the system s memories or registers or other such information storage transmission or display devices.

The present disclosure can relate to an apparatus for performing one or more of the operations described herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a machine e.g. computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs erasable programmable ROMs EPROMs electrically erasable programmable ROMs EEPROMs flash memory magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a bus.

A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example machines store and communicate internally and with other devices over a network code and data using machine readable media such as machine readable storage media e.g. magnetic disks optical disks random access memory read only memory flash memory devices phase change memory and machine readable communication media.

At least certain embodiments of the present disclosure include one or application programming interfaces in an environment with search software interacting with a software application. Various function calls or messages are transferred via the application programming interfaces between the search software and software applications. Transferring the function calls or messages may include issuing initiating invoking or receiving the function calls or messages. Example application programming interfaces transfer function calls to implement various operations e.g. search networking service discovery etc. for a device having a display region. An API may also implement functions having parameters variables or pointers. An API may receive parameters as disclosed or other combinations of parameters. In addition to the APIs disclosed other APIs individually or in combination can perform similar functionality as the disclosed APIs.

The display region may be in a form of a window. A window is a display region which may or may not have a border and may be the entire display region or area of a display. In some embodiments a display region may have at least one window and or at least one view e.g. web text or image content . The methods systems and apparatuses disclosed can be implemented with display regions windows and or views.

In some embodiments a platform provides various editing and networking operations. The platform includes hardware components and an operating system. The hardware components may include a processing unit coupled to an input panel and a memory coupled to the processor. The operating system includes one or more programs that are stored in the memory and configured to be executed by the processing unit. One or more programs include various instructions for transferring function calls or messages through an Application Programming Interface API in order to perform various editing and networking operations.

One or more APIs may be used in some embodiments. An API is an interface implemented by a program code component or hardware component hereinafter API implementing component that allows a different program code component or hardware component hereinafter API calling component to access and use one or more functions methods procedures data structures classes and or other services provided by the API implementing component. An API can define one or more parameters that are passed between the API calling component and the API implementing component.

An API allows a developer of an API calling component which may be a third party developer to leverage specified features provided by an API implementing component. There may be one API calling component or there may be more than one such component. An API can be a source code interface that a computer system or program library provides in order to support requests for services from an application. An operating system OS can have multiple APIs to allow applications running on the OS to call one or more of those APIs and a service such as a program library can have multiple APIs to allow an application that uses the service to call one or more of those APIs. An API can be specified in terms of a programming language that can be interpreted or compiled when an application is built.

In some embodiments the API implementing component may provide more than one API each providing a different view of or with different aspects that access different aspects of the functionality implemented by the API implementing component. For example one API of an API implementing component can provide a first set of functions and can be exposed to third party developers and another API of the API implementing component can be hidden not exposed and provide a subset of the first set of functions and also provide another set of functions such as testing or debugging functions which are not in the first set of functions. In other embodiments the API implementing component may itself call one or more other components via an underlying API and thus be both an API calling component and an API implementing component.

An API defines the language and parameters that API calling components use when accessing and using specified features of the API implementing component. For example an API calling component accesses the specified features of the API implementing component through one or more API calls or invocations embodied for example by function or method calls exposed by the API and pass data and control information using parameters via the API calls or invocations. The API implementing component may return a value through the API in response to an API call from an API calling component. While the API defines the syntax and result of an API call e.g. how to invoke the API call and what the API call does the API may not reveal how the API call accomplishes the function specified by the API call. Various API calls are transferred via the one or more application programming interfaces between the calling API calling component and an API implementing component. Transferring the API calls may include issuing initiating invoking calling receiving returning or responding to the function calls or messages in other words transferring can describe actions by either of the API calling component or the API implementing component. The function calls or other invocations of the API may send or receive one or more parameters through a parameter list or other structure. A parameter can be a constant key data structure object object class variable data type pointer array list or a pointer to a function or method or another way to reference a data or other item to be passed via the API.

Furthermore data types or classes may be provided by the API and implemented by the API implementing component. Thus the API calling component may declare variables use pointers to use or instantiate constant values of such types or classes by using definitions provided in the API.

Generally an API can be used to access a service or data provided by the API implementing component or to initiate performance of an operation or computation provided by the API implementing component. By way of example the API implementing component and the API calling component may each be any one of an operating system a library a device driver an API an application program or other module it should be understood that the API implementing component and the API calling component may be the same or different type of module from each other . API implementing components may in some cases be embodied at least in part in firmware microcode or other hardware logic. In some embodiments an API may allow a client program to use the services provided by a Software Development Kit SDK library. In other embodiments an application or other client program may use an API provided by an Application Framework. In these embodiments the application or client program may incorporate calls to functions or methods provided by the SDK and provided by the API or use data types or objects defined in the SDK and provided by the API. An Application Framework may in these embodiments provide a main event loop for a program that responds to various events defined by the Framework. The API allows the application to specify the events and the responses to the events using the Application Framework. In some implementations an API call can report to an application the capabilities or state of a hardware device including those related to aspects such as input capabilities and state output capabilities and state processing capability power state storage capacity and state communications capability etc. and the API may be implemented in part by firmware microcode or other low level logic that executes in part on the hardware component.

The API calling component may be a local component i.e. on the same data processing system as the API implementing component or a remote component i.e. on a different data processing system from the API implementing component that communicates with the API implementing component through the API over a network. It should be understood that an API implementing component may also act as an API calling component i.e. it may make API calls to an API exposed by a different API implementing component and an API calling component may also act as an API implementing component by implementing an API that is exposed to a different API calling component.

The API may allow multiple API calling components written in different programming languages to communicate with the API implementing component thus the API may include features for translating calls and returns between the API implementing component and the API calling component however the API may be implemented in terms of a specific programming language. An API calling component can in one embedment call APIs from different providers such as a set of APIs from an OS provider and another set of APIs from a plug in provider and another set of APIs from another provider e.g. the provider of a software library or creator of the another set of APIs.

It will be appreciated that the API implementing component may include additional functions methods classes data structures and or other features that are not specified through the API and are not available to the API calling component . It should be understood that the API calling component may be on the same system as the API implementing component or may be located remotely and accesses the API implementing component using the API over a network. While illustrates a single API calling component interacting with the API it should be understood that other API calling components which may be written in different languages or the same language than the API calling component may use the API .

The API implementing component the API and the API calling component may be stored in a machine readable medium which includes any mechanism for storing information in a form readable by a machine e.g. a computer or other data processing system . For example a machine readable medium includes magnetic disks optical disks random access memory read only memory flash memory devices etc.

In Software Stack an exemplary embodiment applications can make calls to Services or using several Service APIs and to Operating System OS using several OS APIs. Services A and B can make calls to OS using several OS APIs.

Note that the Service has two APIs one of which Service API receives calls from and returns values to Application and the other Service API receives calls from and returns values to Application . Service which can be for example a software library makes calls to and receives returned values from OS API and Service which can be for example a software library makes calls to and receives returned values from both OS API and OS API . Application makes calls to and receives returned values from OS API .

Referring to the layout engine starts with sending an instruction to the graphic engine to draw a glyph of a font at a predetermined location on a printing medium which may include physical printing medium e.g. paper slide textile etc. or digital printing medium e.g. a Portable Document Format PDF file rendered on a display device e.g. a computer monitor a touch screen etc. . Broadly speaking a glyph of a font is an element of writing in the font. In some embodiments the glyph is a multi color glyph. In other words the glyph has more than one color. Further each glyph of the font may have the same or different color or combination of colors. Colored images of the glyphs are captured in graphic image data e.g. PNG data JPEG data etc. which are stored in a font file of the font. Alternatively the font file may store references e.g. pointers to the graphic image data of the glyphs. In another embodiment the font file may store both the graphic image data of glyphs and references to the graphic image data. The font file in general includes a set of data defining the font. Note that the font file may be a stand alone file or a set of data embedded in one or more files which may be local or remote.

In some embodiments the font file includes a set of characteristics of each glyph of the font such as size and outline of a respective glyph. In some embodiments the font file includes glyph metrics which includes the origin of the glyph i.e. location relative to the drawing position the advance i.e. distance to move to after drawing the glyph and the bounding box i.e. the rectangular region occupied by the glyph . The font file further includes graphic image data containing an image of each glyph. The graphic image may be a colored image. The graphic image data can be in any graphic format such as for example PNG GIF TIFF JPEG etc. The font file can be stored on a computer readable storage medium accessible by the layout engine and the font parser .

In response to the instruction from the layout engine the graphic engine sends a request for a set of glyph metrics of the glyph to the font parser which retrieves the glyph metrics of the glyph from the font file . In some embodiments the font file returns an empty vector list corresponding to a blank region to the font parser . The font parser forwards the empty vector list to the graphic engine which causes a printer e.g. an ink jet printer a laser printer etc. communicably coupled to the graphic engine to set aside a blank region according to the empty vector list at the predetermined location on the printing medium .

Referring to the layout engine further sends a request for a color bitmap file of the glyph to the graphic engine which in turns requests the color bitmap file from the font parser . The font parser retrieves the color bitmap file requested from the font file . The font file sends the color bitmap file to the font parser and then the font parser forwards it to the graphic engine which forwards it to the layout engine .

In some embodiments the color bitmap file contains a reference to some graphic image data of the glyph. The reference may be a pointer and the graphic image data may be stored at a location in the font file referenced by the pointer. The graphic image data can contain a colored image of the glyph. Further the graphic image data can be in any graphic format such as PNG GIF TIFF JPEG etc. usable by the layout engine and the graphic engine .

Referring to the layout engine uses the reference to the graphic image data of the glyph to retrieve the graphic image data from the font file . In response to the request the font file returns the graphic image data of the glyph to the layout engine .

Referring to the layout engine sends another instruction to graphic engine to draw the image of the glyph as contained in the graphic image data. In response the graphic engine causes the printer to draw the image of the glyph in the blank region previously drawn on the printing medium . Thus the printer effectively prints the image of the glyph in the blank region.

Because the glyph of the font is stored as a graphic image in the font file both the graphic engine and the printer can treat it as a graphic image instead of a glyph and hence the printer can print the glyph exactly as it appears in the graphic image data. In other words there is no need to include complicated coding in the font file in order to define the color s and opacity of the glyph while the layout engine the graphic engine the font parser and the printer do not have to incorporate significant code changes in order to interpret any complex definition of the glyph its color s and opacity in the font file . Thus the layout engine graphic engine and font parser can readily render and or print the glyph which can be multi color as a graphic image in order to support the font without having any significant modification to the underlying font processing code. Note that the above techniques are compatible with many conventional techniques of glyph rendering. As such the layout engine the graphic engine the font parser and the printer can draw a combination of conventional glyphs and multi color glyphs defined by graphic image data as discussed above.

Initially the layout engine instructs a graphic engine to draw a glyph of a font at a predetermined location on a printing medium processing block . In response the graphic engine may obtain a set of glyph metrics of the glyph from a font file of the font and set aside a blank region according to the glyph metrics. In some embodiments the glyph metrics includes the origin of the glyph i.e. location relative to the drawing position the advance i.e. distance to move to after drawing the glyph and the bounding box i.e. the rectangular region occupied by the glyph . The layout engine further requests a color bitmap table of the glyph from the font parser processing block . In response the font parser obtains a color bitmap table of the glyph from the font file and sends the color bitmap table to the layout engine. The layout engine receives the color bitmap table from the font parser processing block .

In some embodiments the layout engine uses a reference in the color bitmap table to retrieve graphic image data of the glyph from the font file processing block . Finally the layout engine instructs the graphic engine to draw an image of the glyph according to the graphic image data retrieved in the blank region previously set aside processing block .

In some alternate embodiments the method described above can be performed exclusively by a graphics engine such as graphics engine in instead of the layout engine. One advantage of using the graphics engine to perform the above method is that the graphics engine is typically the lowest level of many operating systems to publicly draw glyphs and hence the graphics engine can easily handle color bitmaps.

In some embodiments a layout engine a graphic engine and a font parser run on the operating system . In general the layout engine a graphic engine and a font parser operate with each other to process render and print text in different fonts. The layout engine may measure the size of a glyph determine a location of the glyph and instruct the graphic engine to draw the glyph. The graphic engine may be operable to draw text in different fonts as well as graphic images. The font parser may determine various characteristics of glyphs to be drawn such as outlines bitmaps and sizes of the glyphs by accessing a font file .

In some embodiments the font file is stored in a computer readable storage medium such as a hard drive a flash memory device etc. Alternatively a font file residing remotely may be accessed over a network by the network interface . In some embodiments a font file is provided for each font supported by the apparatus . Furthermore the font file may be a stand alone file or embedded in one or more files. The font file includes information on various characteristics of each glyph of the font and graphic image data containing an image of at least one of the glyphs. Details of one embodiment of a font file are illustrated in .

Using the information from the font file the graphic engine can set aside a blank region or a blank space according to an outline of a glyph. Then the layout engine may retrieve the graphic image data of the glyph from the font file and instruct the graphic engine to draw the image of the glyph according to the graphic image data in the blank region.

In some embodiments the graphic engine is communicably coupled to the printer via the input output interface . The graphic engine may send instructions to the printer to cause the printer to set aside a blank region at a predetermined location on a printing medium e.g. paper and then to draw an image of the glyph in the same color as in the graphic image data in the blank region. In other words the graphic engine and the printer can simply treat the glyph as an ordinary graphic image. As such the apparatus can readily support fonts having multi color glyphs without requiring significant changes to the code of the graphic engine and or the printer .

In one example the font associated with the font file includes a glyph G. Various information of G is stored in the font file such as outline of G size of G etc. In addition the font file includes a reference e.g. a pointer to graphic image data of G which is also stored in the font file in the current example.

In some embodiments the graphic image data contains a color image of the glyph G. The glyph may be of multiple colors. Further part of the image of the glyph may be opaque. The format of the graphic image data may be PNG GIF TIFF JPEG etc. Note that the formats of all the graphic image data in the font file may be the same or different in some embodiments.

Using the information of the glyph a graphic engine can set aside a blank region e.g. a blank box on a printing medium which may include physical printing medium e.g. paper slide etc. and or digital printing medium e.g. a PDF file rendered on a display device such as a computer monitor or a touch screen . Then the graphic engine may further draw an image of the glyph according to the graphic image data in the blank box . Details of some embodiments of a method to use such a font file have been discussed above.

In some embodiments the font file can be updated by replacing one or more of the existing graphic image data of glyphs with new graphic image data of glyphs. For example when the colors of some of the glyphs are changed new graphic image data of the glyphs may be generated to replace the existing graphic image data of the glyphs referenced in the font file . To replace some existing graphic image data of a glyph in the font file the reference to the existing graphic image file may simply be changed to refer to a location of the new graphic image data of the glyph.

In some embodiments the font file reside as an individual file in a computer readable storage medium such as a memory in a personal computer a compact disc CD a flash drive etc. Alternatively the font file may be embedded in one or more applications and or other files e.g. a PDF file . In some embodiments the font file may reside remotely over a network e.g. Local Area Network LAN Internet etc. .

This device may also optionally include a display controller and display device which is coupled to the other components through the bus . One or more input output controllers are also coupled to the bus to provide an interface for input output devices and to provide an interface for one or more sensors which are for sensing user activity. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as are well known in the art. The input output devices may include a keypad or keyboard or a cursor control device such as a touch input panel. Furthermore the input output devices may include a network interface which is either for a wired network or a wireless network e.g. an RF transceiver . The sensors may be anyone of the sensors described herein including for example a proximity sensor or an ambient light sensor. In at least certain implementations of the device the microprocessor may receive data from one or more sensors and may perform the analysis of that data in the manner described herein.

In certain embodiments of the present disclosure the device can be used to implement at least some of the methods discussed in the present disclosure.

In the foregoing specification the disclosure has been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the disclosure as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

