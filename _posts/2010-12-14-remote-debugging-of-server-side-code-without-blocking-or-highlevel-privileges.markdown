---

title: Remote debugging of server side code without blocking or high-level privileges
abstract: A server exposes debugger services to a plurality of debugger clients. One or more debugger clients can select a debug operation and establish a debug session in a thread of a server process for debugging user code. A two-way debug communication pipeline can be established between a debugger client and the server using standard encoding protocols and standard network transport protocols. A two-way debug communication pipeline can be established using HTTP where the server can initiate a communication with the debugger client using a long polling technique. When one of the threads of the server process is suspended, the other threads in the server process continue to execute.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09064049&OS=09064049&RS=09064049
owner: Microsoft Technology Licensing, LLC
number: 09064049
owner_city: Redmond
owner_country: US
publication_date: 20101214
---
A debugger is a tool which enables a programmer to monitor the execution of a program. A debugger can stop execution of a program being debugged re start it set breakpoints in the program and or access or change values in memory. A debugger can enable a program to be run step by step called stepping to stop at a particular line of code when a breakpoint is encountered breaking and can enable the value of variables to be inspected when the program is at a breakpoint or while the program is running inspection . Some debuggers can also modify program state while the program is running in addition to observing and reporting on program state. Some debuggers can display and navigate the callstack enabling the user to skip over parts of code while stepping or to restart the execution from a potentially arbitrary line of code. Other functions of debuggers include listing and debugging multiple threads at the same time enabling hit counting.

Hence debuggers are typically very powerful. Moreover the same functionality that makes a debugger useful for finding bugs also makes it useful as a software cracking tool to retrieve sensitive information evade copy protection circumvent digital rights management and so on. Hence a user who does not have high level privileges typically cannot run a debugger process.

When software running in a process is being debugged other threads running in the process can be affected. For example if a server process is being debugged clients accessing the server may experience a slow down in server response time or the application being debugged and all the clients accessing the application being debugged may even freeze.

A cooperative non blocking non invasive debugger can execute on a server in a network environment to debug client user code. The execution environment that runs the user code on the server can cooperate with and enable the debugger. A remote debugging channel that supports a two way communication pipeline between a debugger client and the debugger on the server can use a standard protocol such as but not limited to HTTP Hypertext Transfer Protocol and or TCP Transmission Control Protocol or a custom network protocol. Long polling can be used to implement the two way communications debugging channel. Debugger messages can be serialized and or encoded using standard protocols including but not limited to XML Extensible Mark up Language SOAP Simple Object Access Protocol and or JSON JavaScript Object Notation .

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Traditionally the only people who were interested in debugging code that executes on a server were the developers of server applications. Debugging server code was typically performed on a server that was removed from production so that the debugging activities did not interfere with clients accessing the server. With the advent of cloud computing however more and more users are developing code that has to be tested and debugged on a production server. Moreover multiple users may want to do remote debugging at the same time. Because the cloud is a multi tenancy environment it is increasingly valuable and necessary to enable multiple users to debug their server side code instances simultaneously within the same server process even when the users are in distant parts of the world do not know each other do not know of each other and or do not control what runs in the server process. Users need to be able to debug their code instances without having any impact on each other or on anyone else being served by the process in any way.

Today the technologies that enable the debugging of user code typically block the debuggee process within which the user code being debugged is running and make that process unavailable for other tasks. Blocking a server process in a production environment can be particularly disruptive because a given server machine has a limited number of processes but potentially many user sessions can be handled by a single process. Once a server debugger is attached to user code and a breakpoint is hit all the threads in the process are frozen preventing the server from serving any of the other users of that process. Therefore debugging just one user s code can block a server process and significantly limit that server s ongoing ability to serve other clients.

In computing privileges control what a user can and cannot do. Examples of privileges are the privilege to create a file in a directory the privilege to read a file the privilege to delete a file the privilege to access a device the privilege to read or write to a socket for communicating over the Internet and so on. Many modern processor architectures have CPU modes that allow the operating system to run at different privilege levels. Processes resources and instructions which access resources are tagged with a privilege level. When a process tries to use a resource or attempts to execute a privileged instruction the processor determines whether or not it has permission to do so and either permits or denies the operation. This prevents user processes from damaging the operating system or from damaging other processes running on the machine. Some processors support two levels of privilege such as user low privilege and supervisor high privilege . Other processors have four levels with level 0 having the most privileges high privilege and level 3 having the fewest privileges level 2 and level 3 may be considered low privilege .

In general elevated privilege is needed to debug a debuggee process. When debugging locally e.g. a user is debugging a program on his own computer it typically does not matter which of the two debugger or debuggee is more privileged because all the information on the computer typically belongs to the same user. Remote debugging is more problematic. Because of the potentially significant impact of debugging user code server side debugging typically requires high level privileges. This can make debugging server side user code practically unavailable for low privileged users.

Traditional debugging approaches can have undesirable and invasive side effects. For example typically only a single executing instance of a debugger can be attached to a debuggee process. It is not typically permitted for two or more executing instances of the same debugger or two or more executing instances of different debuggers to be attached to a single debuggee process. Traditional solutions that allow a client to debug on a server can compromise security. For example because the debugger interrogates the target the program being debugged and has extensive control over the process the debugger and thus a client running the debugger can ask for any desired information can extract any information it wants and can control what runs and what does not run. If a breakpoint is encountered in the code being debugged the entire process is stopped to allow the inspection of process values at the breakpoint. This means that any other user of the process is frozen unless and until the debugging client resumes processing. Alternative solutions prohibit the client from debugging at all on the server.

In accordance with aspects of the subject matter disclosed herein non invasive non blocking debugging of server side user code can be achieved through cooperation between the server execution environment and a cooperative debugger executing on the server. Debugging services on the debugger server are available to users who lack high level privileges. A cooperative debugger in this context refers to a remote debugger executing on a server which cooperates with the execution environment of the server to provide debugging services to debugger clients. The executing thread of a cooperative debugger executing on a server can call into the debugger client at sequence point code locations that are possible locations for breakpoints. The debug state of the server debugger can be passed to the debugger client. Cooperative debugging can be provided by a service which the execution environment of the server supports to avoid invasiveness the need for high level privileges blocking the single debugger constraint issue and so on. Cooperative debugging can be implemented through traceback instrumentation interpretation or by other mechanisms.

The execution environment and the cooperative non invasive non blocking debugger can expose debugging services to debugger clients. A debugger client can inspect and drive the state of the executing user code by communicating with the server debugger through the debugger services. Communication between the debugger client and the server debugger can be serialized and transmitted across network remoting boundaries. Remoting boundaries can exist in an intranet the Internet a LAN local area network a WAN wide area network and so on and can also exist between processes executing on the same computer. The communication between the debugger client and the debugger executing on the server can be generalized into a duplex message passing system in which messages are encoded using SOAP XML JSON or any other standard or custom protocol. The delivery or transport of each message between the debugger on the server and the debugger client can be performed through a network transport protocol suited to the application being debugged. Some examples of network protocols include but are not limited to TCP UDP User Datagram Protocol HTTP SOAP REST Simple Object Access Protocol Representational State Transfer web services and so on.

System may include one or more of the following one or more server computers such as server computer etc. and or one or more client computers such as client client . . . client n etc. A server computer such as server computer may include one or more processors such as processor a memory and one or more modules that implement a cooperative non invasive non blocking debugger such as debugger . Server computer can also include one or more modules such as module that establishes a two way debug communication pipeline between a client computer and the server computer. It will be appreciated that the above described modules can be loaded into memory to cause one or more processors such as processor to perform the actions attributed to the module s .

One or more server processes can execute on the server computer . A server process such as server process executing on the server computer can include one or more executing threads or sessions such as user session user session . . . user session n in which an instance of the cooperative non invasive non blocking debugger e.g. debugger instance is executing. Each user session can include an execution environment such as execution environment that supports or cooperates with the cooperative non invasive non blocking debugger and an instance of the cooperative non invasive non blocking debugger . It will be appreciated that the execution environment and the non blocking debugger stacks need not be the same for different user sessions. For example a configuration in which a first user executes debugs VB.NET code while a second user executes debugs JavaScript code is feasible.

Clients such as client client . . . client n etc. may include modules including a debugger client a message serializer and a network transport. As described herein each client and corresponding user session can be associated with a remote debugging channel that supports a two way communication pipeline between a debugger client and the server side debugger represented in by debugging channel for communication between user session and client debugging channel for communication between user session and client . . . debugging channel for communication between user session n and client n .

A cooperative non invasive non blocking debugger can be achieved in various ways such as for example by using an interpreter that interprets script code line by line. For example for each line the interpreter can insert a breakpoint so that if the debugger stops at a breakpoint the executing thread that is interpreting the script stops. In this way only the executing thread is stopped at the breakpoint and all the other threads within the process can continue to execute. Another way of implementing a cooperative non invasive non blocking debugger is by instrumenting code using tracebacks or callbacks. Before each breakpoint is encountered a callback function can be called. Other methods of implementing a cooperative non invasive non blocking debugger are also contemplated.

In accordance with aspects of the subject matter disclosed herein however the cooperative non invasive non blocking debugger is implemented the execution environment on the server computer hosting the cooperative non invasive non blocking debugger supports cooperative non invasive non blocking debugging. The execution environment supports the debugger by providing debugging services needed by the debugger. These services may include calling into the debugger to indicate when sequence points are reached regardless of whether the execution environment is interpreted or instrumented with tracebacks etc. . Other services may include inspection and manipulation of local variables expression evaluation transferring control to a different execution location and so on. The cooperative non invasive non blocking debugger on the server computer can expose a set of operations to which a client can connect. Upon establishment of the connection and the debugging channel the client can inspect the state of the debugger.

Traditional debuggers do not attach to threads they attach to a process. Consequently when the process is stopped to examine its execution state all the threads in the process are stopped. In contrast in accordance with aspects of the subject matter disclosed herein a cooperative non invasive non blocking debugger attaches to a single thread in a process. Consequently when a breakpoint is encountered in a thread or when another event causing suspension of execution is encountered in the thread only that single thread is stopped. During execution the thread periodically calls a function that determines whether or not the thread needs to stop execution so that a debugger may examine that and no other thread s execution state. If the function determines that the thread needs to stop that thread is put to sleep by placing the thread in a wait state. The thread does not wake up or resume until it receives a wakeup or resume event. When the wakeup or resume event is raised the thread wakes up and resumes execution. Because only the affected thread is put to sleep all the other threads in the process continue to execute code normally. It will be appreciated that this represents one possible way that non blocking remote debugging can be realized. There are other possibilities that do not necessarily require the thread to be put to sleep. However implemented the resultant effect is the same no other actively executing thread is affected by the debugging state of a given thread.

Client client . . . client n can be clients separated from the server computer and from the cloud by a remoting boundary comprising a network such as an intranet the Internet a LAN a WAN or by any network boundary. Alternatively the cooperative non invasive non blocking debugger and the debugger client can execute on the same computer and the boundary can be a process boundary not shown . Client client . . . client n can exist behind a firewall. The server computer can be separated from the client by a remoting boundary comprising an intranet the Internet a LAN a WAN or by any network boundary. The server computer can exist behind a firewall. A remoting boundary can exist between the cloud and the client and or between the cloud and the server computer. Client client . . . client n may access the server computer by a public connection point that accesses a load balancer. The load balancer can delegate the work to one of a plurality of servers which may be protected by a firewall. Considerations of issues of security firewalls network address translators NATs network topologies and network latency can affect how the communication mechanism between client and server is implemented.

A message serializer on the server computer can serialize a communication from a user session executing in the server process . The communication can be addressed to a client user such as client client to client n . Similarly the message serializer on a client computer can serialize a communication from a client such as client client . . . client n to a server computer . It will be appreciated that different serializers can be accommodated on the server computer for different processes. The communication between the debugger client and the debugger executing on the server computer can be generalized into a duplex message passing system in which messages are encoded using SOAP XML JSON or any other standard or custom protocol. It will be appreciated that different transport protocols can be accommodated on the server computer for different processes.

Messages that can be exchanged between client and the server computer can include messages sent from the client to the server including but not limited to a message that gets one or more threads e.g. GetThreads a message that looks up a source file e.g. LookupSourceFile a message that requests an asynchronous break e.g. RequestAsyncBreak a message that sets a breakpoint e.g. SetBreakpoint a message that begins a stepping operation e.g. BeginStep a message that cancels a stepping operation e.g. CancelStep a message that sets a value for a next statement e.g. SetNextStatement a message that gets one or more local variable values e.g. GetLocals a message that changes the value of one or more local variables ChangeLocals a message that gets one or more arguments e.g. GetArgs a message that requests evaluation of an expression e.g. EvaluateExpression a message that issues a run command e.g. Run and or a message that closes a debug session e.g. CloseSession . Each message can include one or more parameters. Messages that can be exchanged between a client and the server computer can include messages sent from the server to the client including but not limited to a message that notifies the client of a debug event e.g. NotifyDebugEvent . Parameters can specify the nature of the event that occurred that caused the server to contact the client.

A logical representation of a particular message such as a SetBreakpoint message that is sent by the client to the server can include information such as the file name or file identifier of the code file where the breakpoint is being set and the source span of the breakpoint i.e. the location of the code fragment in the file such as for example the start and end line and start and end column . It will be appreciated that other messages will include other appropriate information.

A message serialized and or encoded by the message serializer can be transported via a custom or standard network transport protocol on the server to the debugger client and via a custom or standard network transport protocol from the debugger client to the server over the debugging channel. Standard network transport protocols include but are not limited to TCP UDP HTTP SOAP REST web services and so on.

A remote debugging channel that supports a two way communication pipeline between client and server or between the server and client using a one way transport protocol can be established. The remote debugging channel can use a standard protocol such as but not limited to HTTP TCP UDP and or SOAP REST web services or can use a custom network protocol. Either the server or the client can initiate communication using the two way channel of the client server server client communication pipeline. It will be appreciated that because communication systems can have different requirements there can be different ways of establishing the remote debugging communication pipeline between client and server or between server and client. One way to establish a two way communication using a one way transport protocol is by using a long polling or server push technique.

Long polling also called server push is a variation of the traditional polling technique that emulates an information push from a server to a client. In long polling the client requests information from the server in a similar way to a normal poll but if the server does not have any information available for the client instead of sending an empty response the server holds the request and waits for some information to be available. Once the information becomes available or after a suitable timeout a complete response is sent to the client. Typically the client then immediately requests information again from the server so that the server will usually have an available waiting request that it can use to deliver data in response to an event. In accordance with aspects of the subject matter disclosed herein the long polling technique is used over HTTP. HTTP is a one way protocol initiated by a client such that in response to the client request a server comes back with a response. An HTTP request is a pull request a client issues a request to a server and the server sends a response to the client request. A server cannot make a push response using HTTP. That is a server cannot send an unsolicited message to a client. To satisfy the need for the server debugger to initiate a communication to the debugger client a server push notification using HTTP as described above can be implemented.

After the communication channel is established between the client and the server debugging communications can ensue. Debugging communications can include but are not limited to the debugger client setting a breakpoint at a certain line in the user code the server sending a notification to the debugger client that a particular breakpoint has been hit a debugger client requesting the value of a local variable or requesting evaluation of an expression a debugger client requesting inspection of the call stack the debugger client requesting inspection of threads a debugger client requesting to step over to the next statement causing execution to continue and then immediately break on the next statement of the current function and or the debugger client requesting to step into a function causing the execution to continue and then immediately break on the first statement of the function being called and so on. When a breakpoint in one of the threads of the server process is encountered only the execution of that thread is suspended. The other threads in the server process remain active and continue execution.

It will be appreciated that a suspension of a thread can occur for reasons other than encountering a breakpoint. For example while at a breakpoint the debug client may request a step operation causing the execution to continue and then immediately break again when the next statement is executed. This sequence of events causes suspension of the thread in a fashion that is similar to hitting a breakpoint. Additionally when the user code is executing the debug client may issue an asynchronous break request. This instructs the debugger to break the execution as soon as possible also causing suspension of the thread.

It will be appreciated that the subject matter disclosed herein can be applied to activities having purposes that are not limited to debugging. For example a client side tool that performs runtime code analysis of code running on the server may use the methodology described herein. Code analysis can be performed for purposes including but not limited to code optimization data mining performance analysis and so on. Similarly instead of a developer interacting with an IDE or source code development application on the client side an automated process may put breakpoints in various places in program code. When a breakpoint is encountered the software may perform code flow analysis or information logging for purposes including but not limited to performance testing code usage statistics gathering and so on . In this way potentially slow and long running client server processes can occur without impacting other code running on the server.

In accordance with aspects of the subject matter disclosed herein an executing thread can actively cooperate with a server side debugger component. On a server process executing a plurality of executing threads only a subset of those executing threads may actually be cooperating with the debugger. Of the threads cooperating with the debugger only a thread which has reached a point in execution that is determined to be a breakpoint will be suspended and only as a consequence of being in that cooperative state. No other thread is subject to stopping since it is the server side debugger component which suspends the thread by causing the thread to enter a wait state. When the appropriate event is raised that will cause the wait state to end the broken thread resumes execution. Because each cooperating thread has its own execution state and therefore its own breakpoint conditions each cooperating thread will be suspended independently from any other solely based on its own execution state and breakpoint conditions so indicate.

In accordance with aspects of the subject matter disclosed herein debugging of user code on the server can be performed in a modified way so the debug operations do not block or control the server and can be performed by a user who lacks high level privileges. At a server computer can expose a set of operations to which a client can connect. The exposed set of operations can enable the connected client to inspect the state of a cooperative non invasive non blocking debugger executing user code on the server. At a debugger client can select one of the operations to perform and the server computer can receive the client s selection. At a communication protocol can be established between the client and the server. The server and the client can for example agree on a serialization and encoding format such as but not limited to an XML SOAP JSON or custom format. The server and the client can also agree on a transport protocol such as but not limited to a custom or standard network transport protocol including but not limited to TCP UDP HTTP SOAP REST web services and so on. A two way debug communication pipeline can be established between the server and the client.

At a remote user debug session can be initiated on the server. The remote debug session can be initiated from within an IDE or from outside of an IDE on the client machine. The remote debug session can execute a cooperative non invasive non blocking debugger such as the server debugger described with respect to . A local user debug session can be initiated on the client machine. At debugging activities inside or outside of the IDE can be performed on a client machine. For example suppose a debugging activity is setting a breakpoint at a particular location in a particular function. Debugging activities can also occur at the server machine. At in response to the debugging activities on either the client or the server a debug message can be created and a communication can be initiated by either the client or the server.

Suppose for example that a user has an IDE open on the client machine and the IDE is displaying some user code. The user may set a breakpoint on a line of code displayed in the IDE on the client machine. A message can be created by the debugger client at . The message can be a non invasive call to the server debugger. The message can be created encoded into the format specified in the communication protocol e.g. XML JSON SOAP etc. and can be transmitted to the server using the debug pipeline at . On the server at the message can be received by the network transport protocol decoded by the message serializer deserializer and given to the cooperative non invasive non blocking debugger.

At more debugging activities can occur. For example the cooperative non invasive non blocking debugger on the server can modify its internal state so that the cooperative non invasive non blocking debugger is aware that there is now a breakpoint at a particular point on a particular line. Before the cooperative non invasive non blocking debugger executes a line it can check its internal state to see if there is a breakpoint on the line that will execute next. When the cooperative non invasive non blocking debugger encounters a line on which a breakpoint occurs the cooperative non invasive non blocking debugger can go into break mode. The cooperative non invasive non blocking debugger can suspend execution of the thread on which the user code is running and can create one or more messages at . The message or messages can include the name of the file on which the debugger is operating the line number of the line being executed and so on.

The message can be serialized and encoded according to the communication protocol established at and can be transmitted over the two way debug communication pipeline established at to the client at . Similarly at the client the message can be received decoded deserialized at . The debugger client can act upon the information provided in the message. For example if the debugger client is executing within an IDE the IDE can display the state of the remote debugger e.g. in break mode to the user by for example highlighting the line identified in the message received from the server in the source code file.

Suppose now that the user while in break mode wants to perform the debug activity at of inspecting a value for a local variable. In response to performing the gestures that select an option to inspect the value for the local variable one or more messages can be created at . The message or messages can ask the debugger on the server to display the current state of the debugger executing on the server. The current state of the debugger can provide the value of the local variable. The message or messages can be serialized encoded and sent to the server at over the two way debug communication pipeline. At the server can decode deserialize the message or messages. At the server debugger can perform the debug activities of reading the message or messages retrieving the state of the local variable. At the server debugger can create another message serialize and encode the message and transport the message to the client at and so on. This process can continue until the debug sessions at the client and the server end and the communication pipeline is closed. It will be appreciated that although method depicts debugging activities message generation encoding and transmission for one debugger client the sequence of actions depicted from through can occur concurrently for multiple debugger clients as described above.

It will be appreciated that the actions described above can be repeated for multiple clients so that multiple user debug sessions can be established within a single server process. For example a first user debug session for a first debugger client of a plurality of debugger clients can execute in a first thread of a server process executing on the server computer. A first instance of the server debugger can be instantiated for the first user debug session. A two way debug communication pipeline between the server and the first debugger client can be established such that the server computer can initiate a communication with the first debugger client using a one way network communication protocol such as HTTP as described above. A second user debug session for a second debugger client of the plurality of debugger clients can execute in a second thread of the server process executing on the server computer the second user debug session instantiating and executing a second instance of the server debugger. A two way debug communication pipeline between the server and the second debugger client can be established such that the server computer can initiate a communication with the second debugger client even when a one way network communication protocol such as HTTP is used as described above. Messages can be sent from client to server or from server to client using the debugging channel.

When the first thread enters a wait state and stops execution the second thread continues to execute and vice versa. Moreover it will be appreciated that the server process is not restricted to two threads. One two or more threads can execute in the server process during the same time period. Moreover threads executing in the server process are not restricted to executing an instance of the cooperative non blocking debugger but regardless of what the threads are doing debugging activities in one thread do not affect execution of the other threads.

In order to provide context for various aspects of the subject matter disclosed herein and the following discussion are intended to provide a brief general description of a suitable computing environment in which various embodiments may be implemented. While the subject matter disclosed herein is described in the general context of computer executable instructions such as program modules executed by one or more computers or other computing devices those skilled in the art will recognize that portions of the subject matter disclosed herein can also be implemented in combination with other program modules and or a combination of hardware and software. Generally program modules include routines programs objects physical artifacts data structures etc. that perform particular tasks or implement particular data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. The computing environment is only one example of a suitable operating environment and is not intended to limit the scope of use or functionality of the subject matter disclosed herein.

With reference to a computing device for low privilege debugging in the form of a computer is described. Computer may include a processing unit a system memory and a system bus . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit . The system memory may include volatile memory and nonvolatile memory . Nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM or flash memory. Volatile memory may include random access memory RAM which may act as external cache memory. The system bus couples system physical artifacts including the system memory to the processing unit . The system bus can be any of several types including a memory bus memory controller peripheral bus external bus or local bus and may use any variety of available bus architectures.

Computer typically includes a variety of computer readable media such as volatile and nonvolatile media removable and non removable media. Computer storage media may be implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other transitory or non transitory medium which can be used to store the desired information and which can be accessed by computer .

It will be appreciated that describes software that can act as an intermediary between users and computer resources. This software may include an operating system which can be stored on disk storage and which can control and allocate resources of the computer system . Disk storage may be a hard disk drive connected to the system bus through a non removable memory interface such as interface . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It will be appreciated that computers can be implemented with various operating systems or combinations of operating systems.

A user can enter commands or information into the computer through an input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone and the like. These and other input devices connect to the processing unit through the system bus via interface port s . An interface port s may represent a serial port parallel port universal serial bus USB and the like. Output devices s may use the same type of ports as do the input devices. Output adapter is provided to illustrate that there are some output devices like monitors speakers and printers that require particular adapters. Output adapters include but are not limited to video and sound cards that provide a connection between the output device and the system bus . Other devices and or systems or devices such as remote computer s may provide both input and output capabilities.

Computer can operate in a networked environment using logical connections to one or more remote computers such as a remote computer s . The remote computer can be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . Remote computer s can be logically connected via communication connection . Network interface encompasses communication networks such as local area networks LANs and wide area networks WANs but may also include other networks. Communication connection s refers to the hardware software employed to connect the network interface to the bus . Connection may be internal to or external to computer and include internal and external technologies such as modems telephone cable DSL and wireless and ISDN adapters Ethernet cards and so on.

It will be appreciated that the network connections shown are examples only and other means of establishing a communications link between the computers may be used. One of ordinary skill in the art can appreciate that a computer or other client device can be deployed as part of a computer network. In this regard the subject matter disclosed herein man pertain to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. Aspects of the subject matter disclosed herein may apply to an environment with server computers and client computers deployed in a network environment having remote or local storage. Aspects of the subject matter disclosed herein may also apply to a standalone computing device having programming language functionality interpretation and execution capabilities.

A user can create and or edit the source code component according to known software programming techniques and the specific logical and syntactical rules associated with a particular source language via a user interface and a source code editor in the IDE . Thereafter the source code component can be compiled via a source compiler whereby an intermediate language representation of the program may be created such as assembly . The assembly may comprise the intermediate language component and metadata . Application designs may be able to be validated before deployment.

The various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus described herein or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing aspects of the subject matter disclosed herein. In the case of program code execution on programmable computers the computing device will generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may utilize the creation and or implementation of domain specific programming models aspects e.g. through the use of a data processing API or the like may be implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

While the subject matter disclosed herein has been described in connection with the figures it is to be understood that modifications may be made to perform the same functions in different ways.

