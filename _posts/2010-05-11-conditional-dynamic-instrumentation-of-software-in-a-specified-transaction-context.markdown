---

title: Conditional dynamic instrumentation of software in a specified transaction context
abstract: Techniques for analyzing software in which un-instrumented components can be discovered and conditionally instrumented during a runtime of the software. Initially, software such as an application can be configured with a baseline set of instrumented components such as methods. As the application runs, performance data gathered from the instrumentation may indicate that the performance of some methods is below expectations. To analyze this, any methods which are callable from a method at issue are discovered, such as by inspecting the byte code of loaded classes in a JAVA Virtual Machine (JVM). To limit and focus the diagnosis, the instrumentation which is added to the discovered components can be conditional, so that the instrumentation is executed only in a specified context. The context can involve, e.g., a specified sequence of components in which a discovered component is called, and/or transaction data in which a discovered component is called.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08473925&OS=08473925&RS=08473925
owner: CA, Inc.
number: 08473925
owner_city: Islandia
owner_country: US
publication_date: 20100511
---
The growing presence of the Internet as well as other computer networks such as intranets and extranets has brought many new applications in e commerce education and other areas. Organizations increasingly rely on such applications to carry out their business or other objectives and devote considerable resources to ensuring that they perform as expected. To this end various application management techniques have been developed.

One approach involves monitoring the infrastructure of the application by collecting application runtime data regarding the individual software components that are invoked in the application. This approach can use agents that essentially live in the system being monitored. For example using instrumentation of the software a thread or process can be traced to identify each component that is invoked as well as to obtain runtime data such as the execution time of each component. Tracing refers to obtaining a detailed record or trace of the steps a computer program executes. One type of trace is a stack trace. Traces can be used as an aid in debugging. However deciding which components to instrument can be problematic. An over inclusive approach can result in excessive overhead costs and possibly impair the operation of the application while an under inclusive approach can result in the omission of important performance data. As a result analysis and diagnosis of software can be problematic.

The present invention provides a technique for monitoring software which addresses the above and other issues.

In one embodiment a computer implemented method for instrumenting an application includes a number of computer implemented steps. The steps include obtaining performance data from instrumented methods in the application. For instance this can include start and stop times of each method. The method further includes based on the performance data selecting at least one method of the instrumented methods to analyze in further detail and based on the selecting determining at least one callable method which can be called by the at least one selected method and which is un instrumented. The method further includes in response to the determining providing conditional instrumentation for the at least one callable method wherein the conditional instrumentation specifies a context in which the at least one callable method can be called.

In another embodiment a computer implemented method for instrumenting an application includes receiving information from instrumentation of at least one selected method of the application indicating that the at least one selected method starts executing and based on the receiving storing an indication in a memory resource that the at least one selected method is executing. For instance the memory resource can be a thread local cache. The method further includes receiving a request from conditional instrumentation of at least one called method of the application when the at least one called method is called by the at least one selected method. The request accesses from the memory resource the indication that the at least one selected method is executing. Moreover the conditional instrumentation executes to report regarding an execution of the at least one called method based at least partly on the accessed indication.

Another embodiment provides a tangible computer readable storage having computer readable software embodied thereon for programming at least one processor to perform a method for instrumenting an application. The method performed includes obtaining performance data from instrumented methods in an application identifying at least one method of the instrumented methods to analyze in further detail identifying at least one callable method which can be called by the at least one selected method and which is un instrumented and providing conditional instrumentation for the at least one callable method which determines whether a condition is met when the at least one callable method is subsequently called. The conditional instrumentation executes to provide performance data regarding execution of the at least one callable method based on determining that the condition is met and the conditional instrumentation does not execute to provide performance data regarding execution of the at least one callable method based on determining that the condition is not met.

Corresponding methods systems and computer or processor readable storage devices which include a storage media encoded with instructions which when executed perform the methods provided herein may be provided.

The present invention provides a technique for analyzing software in which un instrumented components can be discovered and conditionally instrumented during a runtime of the software. Initially software such as an application can be configured with a baseline set of instrumented components such as methods. As the application runs performance data can be gathered from the instrumentation and it may be learned that the performance of some methods is below expectations or is otherwise an issue. To analyze the problem a technique can be used to discover any methods which are callable from the method at issue. In a particular implementation the callable methods are discovered by inspecting the byte code of loaded classes in a JAVA Virtual Machine JVM . A decision can then be made to instrument and or report the discovered methods. By selectively adding instrumentation additional performance data can be obtained from the discovered components to allow a deep diagnosis of a performance problem without initially requiring over inclusive instrumentation. Furthermore the instrumentation which is added to the discovered components can be conditional so that the instrumentation is executed only in a specified context. The context can involve e.g. a specified sequence of components in which a discovered component is called and or data of a transaction in which a discovered component is called. Thus the goals of efficient and lightweight instrumentation can be achieved along with the capability for a deep diagnosis when needed.

For example a corporation running an enterprise application such as a web based e commerce application may employ a number of application servers at one location for load balancing. Requests from users such as from an example web browser of a user are received via the network cloud such as the Internet and can be routed to any of the application servers and . The web browser typically accesses the network cloud via an Internet Service Provider not shown. Agent software running on the application servers and denoted by Agent A and Agent A respectively gather information from an application middleware or other software running on the respective application servers and in one possible approach. For example such information may be obtained using instrumentation one example of which is byte code instrumentation. However the gathered data may be obtained in other ways as well. The agents essentially live in the computer system being monitored and provide a data acquisition point. The agents organize and optimize the data communicated to the manager .

Various approaches are known for instrumenting software to monitor its execution. For example as mentioned at the outset tracing may be used to track the execution of software. One example of tracing is discussed in U.S. Patent Application Publication No. 2004 0078691 titled Transaction Tracer published Apr. 22 2004 incorporated herein by reference. In one approach discussed therein object code or byte code of an application to be monitored is instrumented e.g. modified with probes. The probes measure specific pieces of information about the application without changing the application s business or other logic. Once the probes have been installed in the byte code of an application it is referred to as a managed application. The agent software receives information such as performance data from the probes and may communicate the information to another process such as at the manager or process the information locally such as to determine whether the information indicates an abnormal condition. For example the information from the probes may indicate performance data such as start and stop times of a transaction or other execution flow or of individual components within a transaction execution flow. This information can be compared to pre established criteria to determine if it within bounds. If the information is not within bounds the agent can report this fact to the manager so that appropriate troubleshooting can be performed. The agents and are typically aware of the software executing on the local application servers and respectively with which they are associated.

The manager can be provided on a separate computer system such as a workstation which communicates with a user interface such as a monitor to display information based on data received from the agents. See example displays in and B D. The manager can also access a database to store the data received from the agents. In the example provided the application servers can communicate with the manager without accessing the network cloud . For example the communication may occur via a local area network. In other designs the manager can receive data from the agents of a number of application servers via the network cloud . For instance some large organizations employ a central network operations center where one or more managers obtain data from a number of distributed agents at different geographic locations. To illustrate a web based e commerce enterprise might obtain agent data from servers at different geographic locations that receive customer orders from servers that process payments from servers at warehouses for tracking inventory and conveying orders and so forth. The manager and user interface display might be provided at a corporate headquarters location. Other applications which are not necessarily web based or involve retail or other sales can similarly employ agents and managers for managing their systems. For example a bank may use an application for processing checks and credit accounts. Moreover in addition to the multi computer system arrangements mentioned a single computer system can be monitored as well with one or more agents.

Further the functionality described herein may be implemented using hardware software or a combination of both hardware and software. For software one or more tangible processor readable storage devices having processor readable code embodied thereon for programming one or more processors may be used. The tangible processor readable storage devices can include computer readable media such as volatile and nonvolatile media removable and non removable media. For example tangible computer readable media may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Examples of tangible computer readable media include RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer. In alternative embodiments some or all of the software can be replaced by dedicated hardware including custom integrated circuits gate arrays FPGAs PLDs and special purpose processors. In one embodiment software stored on a storage device implementing one or more embodiments is used to program one or more processors. The one or more processors can be in communication with one or more tangible computer readable medial storage devices peripherals and or communication interfaces.

Component oriented programming models are useful in allowing the programmer to assemble an application or other program from building blocks referred to as components. Each component can perform a specific function which fits in with an overall functionality of the software. Furthermore a component can call other components as well as calling itself in a recursive call so that a sequence of components is invoked in a program. The components are examples of resources in a computer system that are consumed or work that is done when a program executes. One example of a component oriented programming model is J2EE which can employ components such as a Java Server Page an Enterprise Java Bean a servlet and a Java Database Connectivity component. However other component oriented programming models may also be used such as those using Microsoft .NET components. Moreover the programming model need not be object oriented. In one approach the components are methods.

In the specific example shown component C and C can call a component C . The arrows indicate method calls at a start of execution and method returns at the end of execution. Components C and C can call a component C . Thus the possible calling sequences include C C C C C C and C C. Each of the components depicted is assumed to be instrumented so that performance data including execution times can be obtained from them. However there may be additional components which are called which are not currently instrumented. To avoid slowing down the application excessively not all components can be instrumented. Moreover even if the additional components could be instrumented temporarily to diagnose a performance problem with the application the amount of data provided by the instrumentation could still be over inclusive. For optimal efficiency conditional instrumentation can be provided which is conditional to a context in which a components executes. The context can be set so that it corresponds to a context in which a performance problem occurs or generally to a specific context which is desired to be analyzed.

For example assume that C is identified as having a performance problem such as an excessive execution time. In this case a process can be implemented to discover un instrumented methods which could be called by C e.g. callable methods of C. An un instrumented method could have instrumentation code which is inactivated or no instrumentation code present. In the example of the discovered components are C and C .

Regarding context the instrumentation of C and C may be conditioned upon one component or a specified sequence of multiple components being called. For instance it may be determined that C has performance problems when it is called in the sequence C C C but C does not have performance problems when it is called in another sequence such as C C C or C C. Thus the instrumentation of C and C may be conditioned upon C or C being called by the sequence C C C. If C or C are called by this sequence so that the specified context is met the conditional instrumentation of C or C executes to report the execution or calling of C or C such as to an agent. Likewise if C or C are called by another sequence so that the specified context is not met the instrumentation of C or C does not execute to report the execution or calling of C or C.

Note that more than one context can be implemented as well for a given callable component. For example C may be instrumented based on the contexts of C C C and C C C.

Once a callable component is discovered the process can be repeated to discover and instrument additional levels of callable components which are further down in a hierarchy of components. For example depicts an example of discovered components which are callable by one of the discovered components of . Specifically components C C and C are callable from C. These discovered components can be instrumented to obtain performance data which can help analyze the performance problem with C. Note that this example proceeded with discovery and instrumentation one level of components at a time where the level refers to a level of the components in a hierarchy. For instance in the hierarchy of the first level includes C and C the second level includes C and C the third level includes C the fourth level includes C and C and the fifth level includes C C and C. There may or may not be additional lower levels in the hierarchy. Another approach is to perform discovery and instrumentation with more than one level of components at a time. For instance C and C could be discovered after which C C and C are discovered in addition to discovering callable components of C not depicted. The components C C and the callable components of C can then be instrumented together.

Regarding context the instrumentation of C C and C may be conditioned upon a specified sequence of components being called. For instance it may be determined that C has a performance problem when it is called in the sequence C C C C but not when it is called in another sequence. Thus the instrumentation of C C and C may be conditioned upon C C or C being called by the sequence C C C C. If C C or C are called by this sequence so that the specified context is met the instrumentation of C C or CIO executes to report the execution calling of C C or C. Likewise if C C or C are called by another sequence so that the specified context is not met the instrumentation of C C or C does not execute to report the execution calling of C C or C.

In Data and Data represents possible types of transaction data. For example assume Data represents a problematic payment type and Data represents a non problematic payment type. Generally different aspects of a transaction can be represented by respective data fields. When C calls C it includes Data such as in a header of a message so that C can access this data if desired. In this sequence Data is passed from C to C and from C to C or C. On the other hand in a sequence in which C calls C Data different than Data is passed from C to C from C to C and from C to C or C. In this example the conditional instrumentation of C or C executes to report performance data only if Data is passed to C.

In this example CA or CB call a component C which adjusts an inventory by decrementing the quantity of the item which is purchased. However C initially does not include instrumentation and is discovered as a callable method of CA or CB. For instance if performance data indicates that CA takes too long to execute while the performance of CB is acceptable C may be discovered as a callable method of CA and conditional instrumentation applied to C. This allows performance data of C to be obtained in an attempt to diagnose CA. C could also be discovered based on both CA and CB having a performance problem.

Once C and any components which are called under C not depicted complete executing the execution flow returns to C so that execution of CA or CB is completed after which execution of CA or CB is completed. C then calls an order completion component C to confirm the purchase to the user such as by providing an order confirmation number and a tracking number e.g. in a confirmation e mail or web page.

Note that a component can continue executing after calling another component which begins executing in an asynchronous multi thread or multi process mode or can temporarily pause until the called component has finished executing in a synchronous single thread or single process mode. For example CA or CB can pause while the components CA or CB and C execute. Moreover a given component may be invoked more than once during a transaction.

The representation a transaction trace is an example of the type of execution path information provided by one or more hosts. It can be a graphical representation which is provided as a report on a user interface for instance and represents performance data in the form of execution times of components such as methods. The execution path information can identify which methods of an application are invoked and the time in which they are invoked. The horizontal direction represents time while the vertical direction indicates call stack depth or position. A call stack identifies methods which have been called or invoked during the execution of one or more programs or threads. An execution path will typically extend for a fraction of a second to a few seconds.

An example execution path depicts components and respective graph regions and execution times as follows C t t C t t CA t t CA t t C t t and C t t . This example includes the option of reserving the item for one s self CA and making a cash payment CA . A host receives a request from a client and notes when C begins executing at t. Each transition in the sequence is noted by the agent based on instrumentation. C calls C at t and C completes executing at t. C calls CA at t. CA calls CA at t. CA calls C at t. C completes executing at t. CA completes executing at t. CA completes executing at t. C calls C at t and C completes executing at t. The host provides a response to the client at which time C completes executing at t. The host periodically reports time and transaction data to the central manager.

The region for C is shown in dashed lines to indicate that C is conditionally instrumented. Further in this example the context or condition which is required to activate the instrumentation is that C is called by CA. That is the context can be based on a set of one or more specific called methods within a stack. As depicted the start and end of the method in the context are at t and t respectively. Since CA is executing when C is called the context is met and the conditional instrumentation of C executes.

Initially assume that C is not conditionally instrumented so that the graph of does not include the region C. The graph may indicate to the user or the corresponding data behind the graph can be automatically processed to determine that the response time of CA is too long and exceeds a threshold level. However at this time no information is known from the user interface regarding any methods which might be called by CA. In this example the techniques described herein are used to discover that C is callable from CA. A callable component may be but is not necessarily called by another component. A particular method which is called directly by another method which is one level higher in the graph may be considered to be a child method of the another method. Similarly the next higher method in the graph may be a grandparent method of the particular method and so forth. Once a callable method is identified it can be instrumented to obtain performance data from it when it is subsequently called. In this case C is instrumented after it is discovered and the application continues to execute so that new performance data is gathered and the region can be displayed in the graph.

The transaction data can include various items including type of product ordered identity of product vendor class of user making a purchase such as a premium user who holds a membership which entitles the user to special privileges vs. a regular user who does not have such privileges whether the e commerce application is accessed via a specified portal geographic location of the user payment mode product shipping mode and so forth. In these cases instrumentation can be conditioned upon a context in which transaction data indicates e.g. that a problematic product type and or vendor is involved. Instrumentation can thus be conditioned upon a context which involves one or more aspects of a transaction in which a user participates or generally any type of transaction. Moreover the concepts herein are not limited to web based e commerce applications but can include other web based applications and non web based applications.

This example is the same as except for the addition of transaction data passed from CA to C matching a context. As a result the two aspects of the context are met where the first aspect is that CA is executing when C is called e.g. C is called by CA and the second aspect is that specified data is passed to C by CA. The data is a data object of a transaction in which CA and C are called. Since the context is met the conditional instrumentation of C executes.

C calls C at t and C completes executing at t. C calls CA at t. CA calls CA at t. CA calls C at t. C calls CA at t. CA calls CA CA or CA at t and CA CA or CA completes executing at t. CA completes executing at t. C completes executing at t. CA completes executing at t. CA completes executing at t. C calls C at t and C completes executing at t. The host provides a response to the client at which time C completes executing at t.

The context for the conditional instrumentation of CA CA or CA requires the sequence of CA C CA precede CA CA or CA being called. The context may also require that the components with conditional instrumentation i.e. CA CA or CA are called by the last component in the sequence i.e. CA. In this example the condition is met so that the conditional instrumentation is executed. Specifically CA the first method in the context starts executing at t. C the second method in the context starts executing at t. CA the third method in the context starts executing at t. Thus each of the components in the sequence is executing when CA CA or CA is called. Subsequently the third second and first methods of the context stop executing at t t and t respectively.

When conditional instrumentation is applied to a component the checkbox can subsequently be unchecked by the user to remove the instrumentation. A portion of the region allows the user to set a sequence length in a context for conditional instrumentation using a drop down widget. This can represent e.g. a number of successive components which are called before the discovered component. In one approach the last component of the sequence calls the discovered component. In this example the length is three for each discovered component corresponding to the sequence CA C CA. It is possible to provide a different sequence length for different components. The sequence length can be preset to a default level as well. Generally the amount of performance data which is provided can be reduced by increasing the sequence length.

A portion of the display region informs the user that the user can select one or more components in a display region to display data e.g. a trace for that component based on its instrumentation in a display region and that component names in italics in region indicate that no data is available.

The display region can be automatically populated with each of the components in the application using a hierarchical structure such as a tree which shows which components are under or called by another component. In this example CA is called by CA since the context of the conditional instrumentation of CA is met. As a result the performance data for CA is available when the name CA is clicked on using a mouse or other pointing device in tree in the region . In contrast the other two discovered components of CA namely CA and CA are not called by CA. The names CA and CA are displayed in italics in the tree to indicate that no performance data is currently available. Thus CA and CA cannot be selected by the user such as by clicking with a mouse to view corresponding performance data in the region .

The display region depicts performance data such as transaction traces of the instrumented components based on the instrumentation for selected ones of the components in the region . For example components C CA and CA are currently selected by a user as indicated by the underlining of the component names in the region and corresponding performance data such as transaction traces is provided by curves and in region . The region can be populated with performance data provided from the agent to the central manager.

When applicable a portion of the region allows the user to filter the performance data by transaction data such as by checking or unchecking boxes to include or not include respectively certain transaction data. For instance Transaction data is currently checked so the curves and are provided only for invocations of C CA and CA respectively which occur under Transaction data . As an example the transaction data may be associated with different user classes. Transaction data may indicate a transaction involving a premium user Transaction data may indicate a transaction involving a mid level user between premium and regular and Transaction data may represent a regular user.

The registers includes a program counter pc which keeps track of where in the memory it should be executing instructions. The program counter identifies the next byte code to be executed. The frame register contains a pointer to the execution environment of the current method in the operand stack. The operand top optop register contains a pointer to the top of the operand stack and is used to evaluate arithmetic expressions. The variable vars register contains a pointer to local variables.

The operand stack supplies parameters to methods and operations and receives results back from them. All byte code instructions take operands from the stack operate on them and return results to the stack. The operand stack includes a stack frame of an executing method. The stack frame holds the state e.g. local variables and intermediate results of calculations for a particular invocation of a method. Specifically each JVM thread has a private JVM stack created at the same time as the thread. A JVM stack stores frames holds local variables and partial results and plays a part in method invocation and return. A frame is thus used to store data and partial results as well as to perform dynamic linking return values for methods and dispatch exceptions. A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes whether that completion is normal or abrupt it throws an uncaught exception . Frames are allocated from the JVM stack of the thread creating the frame. Each frame has its own array of local variables its own operand stack and a reference to the runtime constant pool of the class of the current method.

The heap or memory allocation pool is garbage collected. The heap is the runtime data area from which memory for all class instances and arrays is allocated. The heap is created on virtual machine start up and heap storage for objects is reclaimed by an automatic storage management system known as a garbage collector. Specifically each program running in the Java runtime environment has a garbage collected heap assigned to it. Moreover each class in the heap has a constant pool associated with it. Because constants do not change they are usually created at compile time. Items in the constant pool encode all the names used by any method in a particular class. The class contains a count of how many constants exist and an offset that specifies where a particular listing of constants begins within the class description.

The method area stores byte code instructions that are associated with methods in the compiled code and a symbol table which the execution environment needs for dynamic linking. Any debugging or additional information that might need to be associated with a method is stored in this area as well. The program counter always points to e.g. contains the address of some byte in the method area. The program counter is used to keep track of the thread of execution. After a byte code instruction has been executed the program counter will contain the address of the next instruction to execute.

The method area is shared among all JVM threads and stores per class structures such as the runtime constant pool field and method data and the code for methods and constructors including the special methods used in class and instance initialization and interface type initialization. The method area is created on virtual machine start up. A runtime constant pool is a per class or per interface runtime representation of the constant pool table in a class file. It contains several kinds of constants ranging from numeric literals known at compile time to method and field references that must be resolved at run time. Each runtime constant pool is allocated from the JVM s method area. The runtime constant pool for a class or interface is constructed when the class or interface is created by the JVM.

If the application byte code matches rules directives at a decision block the transformer adds probes in the form of tracer byte code. If the application byte code does not matches the rules at the decision block the transformer does not add instrumentation to the byte code. The transformer and the decision block may be considered to be part of a probe builder .

In this implementation the rules are a set of typically static rules that identify portions of the managed application which are to be instrumented. The rules are usually implemented when a class is defined in a virtual machine for the first time. A class can be loaded multiple times while being defined only once. For example there can be multiple class loaders loading the same class. Further components such as classes may be instrumented based on whether they are named a certain way whether they implement a certain interface whether they extend a certain subclass or super class and so forth. Such components are selected to be instrumented because it is believed they might provide performance data which is useful or otherwise interesting.

For instance a rule may indicate that all servlets should be instrumented since it is believed that at least some of the servlets may provide interesting data. In this case the rules may indicate that all components that are subclasses of the JAVA class HttpServlet should be instrumented. HttpServlet is an abstract class from which all servlets depend. However not all components can be instrumented and there is a tension in that over inclusive instrumentation results in excessive overhead costs and possibly impairing the operation of the application while under inclusive instrumentation results in the omission of important performance data.

Moreover the CLR is an implementation of a Common Language Infrastructure CLI which provides a language neutral platform for application development and execution including functions for exception handling garbage collection security and interoperability. The CLI includes the core class libraries Common Type System and the Common Intermediate Language CIL . As with JAVA byte code CIL is another example of intermediate byte code. JAVA and .NET provide example implementations only as other implementations are possible.

Here the process may be implemented by an agent in one possible approach. In one possible scenario some process in the .NET framework references a class by name and the CLR finds the class shows it to a transformer if any and uses the resultant CIL. In particular if the class matches rules at a decision block instrumentation is added. If the class does not match the rules at the decision block instrumentation is not added. The transformer and the decision block may be considered to be part of a probe builder .

Generally tracing allows users to conduct deep diagnosis of code issues by following a specific user transaction through its execution and reporting the sequence duration and order of the method executed. Current approaches however do not distinguish between execution of methods within the transaction scope and outside of it leading to overhead and noisy information. Moreover without context the relative weight of reported performance metrics for different transactions cannot be determined. Typically the user starts a transaction trace and detects that some specific kind of transaction starting with the invocation of a traced method is having a performance issue. To obtain more information about the issue the user can apply conditional tracing to the traced method.

Step includes obtaining performance data from instrumented methods during a runtime of an application. This can include methods which are already instrumented such as based on static rules which determine which methods are to be instrumented when they are loaded into the application as discussed in connection with . In another approach the methods may be instrumented after they are loaded into the application. Further details are provided in .

Step includes identifying at least one selected method in the application to analyze based on the performance data. For instance in the example of the method to analyze is CA or CB. In the example of the method to analyze is CA. Further details are provided in .

Step includes identifying one or more callable methods of the at least one method to analyze. Further details are provided in .

Step includes identifying a context of the one or more callable methods. Further details are provided in .

Step includes re instrumenting the at least one method to analyze and or a sequence of components which includes the at least one method least to analyze. Further details are provided in .

Step includes instrumenting the one or more callable methods with conditional instrumentation based on the context. Further details are provided in .

Step includes obtaining performance data from the one or more callable methods when the one or more callable methods are subsequently called during a runtime of the application and the context is met. The performance data is obtained by executing the conditional instrumentation. Further details are provided in .

Step determines a class of the at least one method to analyze through reflection. In one possible implementation this includes using the JAVA application programming interface API java.lang.instrument step . The at least one method to analyze may be considered to be an invoking method since it can invoke or call one or more callable methods. Step can include fetching a JAVA class from among all loaded classes in memory e.g. in the JVM.

Step includes loading a byte code representation of the class such as from an original resource location from which the byte code was obtained. In an example implementation the JAVA class ClassLoader is used if available step . Note that a safety precaution can be enforced to limit the amount of code which is loaded in memory so that very large automatically generated classes will not overwhelm the memory.

Step includes parsing a byte code representation of each class obtained to identify one or more instances of an invoke byte code. In a particular implementation this includes identifying specific opcodes operation codes in the byte code representation of a class step . For instance four opcodes in the JAVA language identify a byte code which can invoke another method. Specifically the opcode for invokevirtual is decimal value 182 or hexadecimal value 0xb6 or b6 the opcode for invokespecial is decimal value 183 or hexadecimal value 0xb7 or b7 the opcode for invokestatic is decimal value 184 or hexadecimal value 0xb8 or b8 and the opcode for invokeinterface is decimal value 185 or hexadecimal value 0xb9 or b9 . The presence of any of these opcodes identifies callable methods.

It is also possible to limit step to detecting one or more specified opcodes but fewer than all possible opcodes. For instance it may be determined that an interface method is not of interest in which case only the opcodes for invokevirtual invokespecial and invokestatic but not invokeinterface are detected.

Step identifies one or more callable methods based on the one or more instances of an invoke byte code. In an example implementation the one or more callable methods are extracted from a constant pool of the class determined at step . Specifically step identifies indexes to entries in a constant pool table based on the opcodes and step identifies one or more referenced methods based on the indexes. Step stores the one or more callable methods which are the one or more referenced methods as a string in cache e.g. the called methods for doSomething . Note that the process of can be performed separately for each of a number of different methods at the same time or at different times.

In an example process step reports the one or more callable methods to a manager from a first agent associated with a first instance of an application. At step the manager pushes an identification of the one or more callable methods to one or more other agents associated with one or more other instances of the application. At step the one or more other agents instrument the one or more other instances of the one or more callable methods in the one or more other instances of the application.

At step the conditional instrumentation of the one or more callable methods which are called in step checks with the thread local cache to determine if the context is met. See also .

If the context is not met such as when step is invoked at decision step the conditional instrumentation of the one or more callable methods does not execute step . If the context is met at decision step the conditional instrumentation of the one or more callable methods does execute at step and provides performance data to an agent. Thus the conditional instrumentation executes to report regarding an execution of the at least one callable method when the conditional instrumentation determines that the at least one callable method is called in the context. Similarly the conditional instrumentation does not execute to report regarding the execution of the at least one callable method when the conditional instrumentation determines that the at least one callable method is not called in the context.

At step a conditional anchor at the end of the last method in the context executes and informs the thread local cache that the method has stopped executing. At decision step if there is another method in the context step is performed in which a conditional anchor at the end of the next method in the context executes and informs the thread local cache that the method has stopped executing. If there is no next method in the context at decision step then execution of the application outside of the context continues at step . This can include for instance the agent providing performance data to the manager or the user interface display being updated at step although these activities can occur during execution within the context as well.

At t when CA is called by CA the conditional instrumentation of CA sends a request to the thread local cache to retrieve the execution status for one or more specified methods. This is a request to access from the memory resource one or more indications that one or more methods are executing. This request is represented by the pseudocode Retrieve ExecutionStatus for MethodName CA. C and CA. The conditional instrumentation of CA accesses this information and uses it to determine if the context is met. Note that as discussed transaction data can also be used by the conditional instrumentation of CA to determine if the context is met additionally or alternatively. In one possible implementation the transaction data is passed to the conditional instrumentation of CA by CA so that the conditional instrumentation of CA does not access the transaction data from the thread local cache. However it is also possible for the transaction data to be provided by the methods in the context and accessed by the conditional instrumentation to determine whether the context is met. When the conditional instrumentation of CA determines that the context is met the conditional instrumentation of CA executes to report regarding an execution of the at least one callable method. This execution is based at least partly on the accessed one or more indications from CA C and CA.

Subsequently the methods in the context stop executing in succession. At t CA stops executing and the second conditional anchor code of the instrumentation of CA sends a message to the thread local cache which includes an identifier name of the method e.g. MethodName CA and a request to remove erase the execution status e.g. Remove ExecutionStatus. Or a request could be sent to set the execution status to ExecutionStatus NotExecuting. At t C stops executing and the second conditional anchor code of the instrumentation of C sends a message to the thread local cache which includes an identifier name of the method e.g. MethodName C and the request Remove ExecutionStatus. At t CA stops executing and the second conditional anchor code of the instrumentation of CA sends a message to the thread local cache which includes an identifier name of the method e.g. MethodName CA and the request Remove ExecutionStatus.

The condition anchor is a tracer that is added to the byte code of the traced method in a context at the start and end of the method. The tracer perform two operations namely it stores in the thread local cache in a data structure such as a map the fact that it has been called when the method is called and starts executing and removes this information at the end of the method. The overhead incurred by the use of conditional anchors is minimal. In one possible approach the conditional anchor tracers update a map structure with constant access time. The map is in the thread local cache so there is no contention. Similarly the overhead incurred by the use of conditional instrumentation is minimal.

As an alternative to the thread local cache the conditional instrumentation of a method could analyze the call stack at the time of invocation of the method to determine if the context is met. As mentioned a call stack identifies methods which have been called or invoked during the execution of one or more programs or threads. In this approach the method determines if the call stack indicates that the context is met. The use of a thread local cache may be more performing since there is no need to look through the stack which may result in a significant access time depending on the depth of the stack.

The dynamic instrumentation cache may store the callable methods which have been identified for a method which is being analyzed. The callable method can then be quickly identified from the cache if a subsequent analysis of the same method is performed thereby reducing the consumption of computing resources. The resource can be a memory location which is used for storing byte code of different classes of the application which is loaded into memory when the application is instrumented and begins executing. In one possible implementation the dynamic instrumentation cache and the resource are provided in the memory of in an application server.

The java.lang.instrument API is used to access all loaded classes to determine a particular class of the at least one method being analyzed in correspondence with steps and of . In one approach all loaded classes are provided in an array. Based on the class a class loader is used to access the resource to load class byte code for the class in correspondence with steps and of . The class byte code is parsed to identify one or more instance of opcodes and in correspondence with steps and of . Each opcode can have respective index bytes which are used to fetch a string of a method call from a constants pool in correspondence with steps and of .

A discovered component can include a dynamically updatable list of classes which should be instrumented. This list can change from time to time so that particular methods are instrumented for limited periods of time in which diagnosis is performed. The user interface may specify the time period or a default time period may be used. Thus a component can be redefined so that it transitions e.g. from not having instrumentation at one point in time to having instrumentation at another point in time. It is also possible to provide different types or levels of instrumentation e.g. a high level of instrumentation in which many aspects of the performance of a component are tracked and a low level of instrumentation in which only a few aspects of the performance of a component are tracked. Redefining a component can thus involve a transition to a different type of instrumentation.

Instrumentation can yield many types of performance metrics data including an average execution or response time of a component an invocation rate per second or per interval a count of invocations a concurrency metric indicating a number of invocations that have started but not finished per interval and a stalled metric indicating a number of invocations that have started whose method invocation times have exceeded a specific threshold per interval. Further the data can identify a garbage collection heap size a bandwidth metric indicating file and socket activity a number of threads system logs exceptions memory leaks and component interactions. The data can also identify which components are called by the instrumented component or which call the instrumented component. For instance in a controller architecture control flows in through a controller component which has control over which components are executed next and knows how often they are executing and how they are performing. The controller component can report via instrumentation on which un instrumented components are being frequently invoked and therefore are perhaps of interest and should be redefined to add instrumentation.

As mentioned it is possible to redefine a component to change its type of instrumentation. For example more instrumentation may be added when the existing instrumentation detects a problem e.g. due to one or more parameters being out of bounds. Also the additional instrumentation may be subsequently removed when the instrumentation establishes that a normal condition has returned. The removal could be performed based on a user command or automatically without user intervention.

Note that the discovered components user interface static list of components and performance monitor can be provided at the same location or at different locations. For example the user interface can be provided at the user interface host the discovered components and the static list of component can be provided at the application server or and the performance monitor may be associated with the manager which receives performance data from the agents and at the application servers and respectively.

The performance monitor provides an idea of what components are involved in a problem transaction and can determine whether these components could be causing or are causing issues and identify this information on the user interface .

The user interface allows a user to manually pick and choose which components including the discovered components are to be instrumented or not instrumented for instance. The type of instrumentation when different types are available could also be specified via the user interface.

The static list of components may include classes or other components which are to be instrumented when the application begins running. This may be a baseline list of components which are expected to yield important data. In one approach a list of the discovered components can be persisted so that the next time the system starts up the same components are instrumented. This allows the user to have constant data reporting and performance data from a component and provides a good way to allow the user to set up the environment.

A component can be redefined in different ways according to whether the component has already been incorporated into the application at runtime. If a component is not already incorporated into the application it can be incorporated normally by being loaded by the class loader such as in a JVM in one possible implementation. In other implementations such as those which use the .NET framework a class loader is not used.

When a component is loaded the transformer probe builder instruments the component if instructed e.g. in response to the user interface discovered components static list of component and performance monitor . A component which is already incorporated into the application but is not instrumented can be reincorporated into the application with instrumentation. For example the component can be removed from the application and reloaded during the runtime without restarting the virtual machine. To achieve this the JAVA redefineClass command is provided to the class loader with the component. The JAVA DEVELOPMENT KIT JDK version 1.5 or higher has a redefinition capability which uses this command. This command redefines a supplied set of classes using supplied class files. It operates on a set in order to allow interlocked changes to more than one class at the same time. Moreover if a redefined method has active stack frames those active frames continue to run the byte codes of the original method and the redefined method will be used on new invokes.

Redefining a component such as a class is analogous to restarting the virtual machine but only for that class. When a class is redefined if the class is already in existing method stacks it stays there. But for every new method invocation the new class is used. That is once it is redefined the new version is picked up.

When the transformer probe builder receives the redefined component it instruments the component if instructed to do so. The transformer probe builder could also add a specified type of instrumentation to the component.

After a discovered component has been instrumented and reincorporated into the application and the instrumentation is no longer need for diagnosis the component can be reincorporated into the application again but without instrumentation. This removal of instrumentation can be based on a user command a time out after a specified diagnosis period or other some other event. For instance the performance monitor may determine that performance data of the discovered component has been acceptable for a certain period of time or for number of invocations of the component. That is the performance monitor may determine that performance data of at least one method of the instrumented methods no longer fails to meet a threshold performance level. In response the performance monitor can issue a command such as redefineClass to remove the instrumentation.

The adding and removal of instrumentation can be done dynamically at runtime so that the virtual machine in which the byte code is executing does not have to be brought down and data from the instrumented components can be accessed immediately in the case of adding instrumentation .

The foregoing detailed description of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. The described embodiments were chosen in order to best explain the principles of the invention and its practical application to thereby enable others skilled in the art to best utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims appended hereto.

