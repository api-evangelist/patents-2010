---

title: Wireless file transmission
abstract: A computer system which includes one or more wireless interface devices that are adapted to communicate with a remote host over a radio link. Each of the wireless interface devices is a pen-based device which includes an ink field in which pen events are translated into pen data packets and transmitted to the remote host over the radio link. Local inking is provided at the wireless interface device in order to maintain the pen paradigm in essentially real time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08456453&OS=08456453&RS=08456453
owner: Warren & Lewis Investment Corporation
number: 08456453
owner_city: Falls Church
owner_country: US
publication_date: 20101216
---
This application is a continuation of U.S. patent application Ser. No. 11 975 312 filed on Oct. 18 2007 now U.S. Pat. No. 7 889 181 which is a continuation of U.S. patent application Ser. No. 10 199 475 filed Jul. 19 2002 now U.S. Pat. No. 7 423 637 which is a continuation of U.S. patent application Ser. No. 08 784 688 filed on Jan. 15 1997 now U.S. Pat. No. 6 724 372 which is a continuation in part of the following application Ser. No. 08 543 786 filed on Oct. 16 1995 abandoned.

This case is also related to the following applications all filed on Oct. 16 1995 REMOTE CONTROL INTERFACE by B. R. Banerjee S. C. Gladwin A. Maskatia and A. Soucy Ser. No. 08 543 700 now U.S. Pat. No. 6 760 017 RADIO FLASH UPDATE by D. Bi H. Hsiung and J. Wilson Ser. No. 08 543 463 now U.S. Pat. No. 6 126 327 MOUSE EMULATION WITH PASSIVE PEN by D. Bi G. Cohen M. Cortopassi J. George S. C. Gladwin H. Hsiung P. Lim J. Parham A. Soucy D. Voegeli and J. Wilson Ser. No. 08 543 786 abandoned RESUME ON PEN CONTACT by M. Cortopassi S. C. Gladwin and D. Voegeli Ser. No. 08 543 510 now U.S. Pat. No. 5 974 558 SCREEN SAVER DISABLER by D. Bi S. C. Gladwin and J. Wilson Ser. No. 08 543 698 now U.S. Pat. No. 6 683 605 IPX DRIVER FOR MULTIPLE LAN ADAPTERS by D. Bi Ser. No. 08 553 808 now U.S. Pat. No. 6 148 344 DISASTER RECOVERY JUMPER by M. Cortopassi J. George J. Parham and D. Voegeli Ser. No. 08 543 423 now U.S. Pat. No. 6 018 806 SYSTEM AND METHOD FOR DELAYING A WAKEUP SIGNAL by M. Cortopassi Ser. No. 08 543 697 now U.S. Pat. No. 5 996 082 DOUBLE PEN UP EVENT by D. Bi and J. George Ser. No. 08 543 787 now U.S. Pat. No. 5 990 875 REMOTE OCCLUSION REGION by J. Wilson Ser. No. 08 543 701 now U.S. Pat. No. 6 005 533 BROADCAST SEARCH FOR AVAILABLE HOST by D. Bi S. C. Gladwin and J. Wilson Ser. No. 08 543 599 now U.S. Pat. No. 6 141 688 HOST REMOTE CONTROL MODE by M. Cortopassi J. George S. C. Gladwin H. Hsiung P. Lim J. Parham D. Voegeli and J. Wilson Ser. No. 08 551 936 now U.S. Pat. No. 6 137 473 PASSWORD SWITCH TO OVERRIDE REMOTE CONTROL by D. Bi S. C. Gladwin and J. Wilson Ser. No. 08 543 785 now U.S. Pat. No. 5 867 106 AUTOMATIC RECONNECT ON REQUIRED SIGNAL by S. C. Gladwin and J. Wilson Ser. No. 08 543 425 now U.S. Pat. No. 6 092 117 and PORTABLE TABLET by G. Cohen S. C. Gladwin P. Lim J. Smith A. Soucy K. Swen G. Wong K. Wood and G. Wu Ser. No. 29 045 319 now U.S. Pat. No. D385 857 REMOTE KEYBOARD MACROS ACTIVATED BY HOT ICONS by S. C. Gladwin J. Wilson Ser. No. 08 543 788 now U.S. Pat. No. 6 209 034.

This case is also related to the following cases all filed on Jan. 15 1997 A COMPUTER SYSTEM FOR ENABLING A WIRELESS INTERFACE DEVICE TO SELECTIVELY ESTABLISH A COMMUNICATION LINK WITH A USER SELECTABLE REMOTE COMPUTER by S. C. Gladwin A. Soucy and J. Wilson Ser. No. 08 783 708 now U.S. Pat. No. 7 512 671 WIRELESS ENUMERATION OF AVAILABLE SERVERS by S. C. Gladwin D. Bi A. Gopalan and J. Wilson Ser. No. 08 784 275 now U.S. Pat. No. 6 353 599 DYNAMIC SERVER ALLOCATION FOR LOAD BALANCING WIRELESS INTERFACE PROCESSING by D. Bi Ser. No. 08 784 276 now U.S. Pat. No. 6 330 231 SYSTEM HAVING WIRELESS INTERFACE DEVICE FOR STORING COMPRESSED PREDETERMINED PROGRAM FILES RECEIVED FROM A REMOTE HOST AND COMMUNICATING WITH THE REMOTE HOST VIA WIRELESS LINK by D. Boals and J. Wilson Ser. No. 08 784 211 now U.S. Pat. No. 6 108 727 MULTI USER RADIO FLASH ROM UPDATE by D. Bi and J. Wilson Ser. No. 08 783 080 now U.S. Pat. No. 6 279 153 AUDIO COMPRESSION IN A WIRELESS INTERFACE TABLET by S. C. Gladwin D. Bi and D. Voegeli Ser. No. 08 784 141 now U.S. Pat. No. 6 963 783 MULTI USER ON SCREEN KEYBOARD by D. Bi Ser. No. 08 784 243 now U.S. Pat. No. 6 664 982 LOCAL HANDWRITING RECOGNITION IN A WIRELESS INTERFACE TABLET DEVICE by S. C. Gladwin D. Bi D. Boats and J. Wilson Ser. No. 08 784 034 now U.S. Pat. No. 7 113 173 INK TRAILS ON A WIRELESS REMOTE INTERFACE TABLET AND WIRELESS REMOTE INK FIELD OBJECT by S. C. Gladwin D. Bi D. Boals J. George S. Merkle and J. Wilson Ser. No. 08 784 688 now U.S. Pat. No. 6 724 372 and MODE SWITCHING FOR PEN BASED COMPUTER SYSTEMS by D. Bi Ser. No. 08 784 212 now U.S. Pat. No. 6 924 790.

The present invention relates to a computer system and more particularly to a computer system which includes a wireless interface device that is adapted to communicate with a remote host by way of a radio link. The remote host processes pen data transmitted by the wireless interface device. Local inking of the pen events is provided at the wireless interface device in order to maintain the pen paradigm in essentially real time.

Pen based portable personal computer systems are generally known in the art. Such systems typically include a digitizer panel and utilize a stylus as an input device. Both active and passive stylus devices are known. In such pen based personal computer systems the path of the stylus is tracked relative to the digitizer panel to maintain the pen paradigm and to provide visual feedback to the user. Such pen based portable personal computer systems are known to use Microsoft Windows for Pen Computing Systems Pen Windows . With such a system utilizing the Pen Windows operating system the pen driver can typically deliver stylus tip locations every five to ten milliseconds to achieve a resolution of about 200 dots per inch and to connect the dots in a timely manner. As such the Pen Windows operating system can provide a real time response to maintain the pen paradigm.

The object of the pen based portable personal computer system is to provide the user with a tool as familiar as pencil and paper. Unfortunately the popularity of such pen based computer systems is a lot less than expected by the industry. As such application programs for such pen based systems are limited.

It is yet another object of the present invention to provide a computer system which includes a remote wireless interface device which can operate in a pen based mode.

The present invention relates to a computer system and more particularly to a computer system which includes a wireless interface device that is adapted to communicate with a remote host by way of a radio link. The remote host processes pen data transmitted by the wireless interface device and provides for inking of the pen events on the wireless interface device.

Briefly the present invention relates to a computer system which includes one or more wireless interface devices that are adapted to communicate with a remote host over a radio link. Each of the wireless interface devices is a pen based device which includes an ink field in which pen events are translated into pen data packets and transmitted to the remote host over the radio link. Local inking is provided at the wireless interface device in order to maintain the pen paradigm in essentially real time.

The present invention relates to a system which allows wireless access and control of a remote host computer which may be either a desktop tower or portable computer to enable remote access of the various files and programs on the host computer. The system not only allows access to remote host computers that are configured as stand alone units but also provides access to both wired and wireless local area networks LAN .

The system includes a wireless interface device which includes a graphical user interface GUI which allows various types of input. In particular input to the wireless interface device is primarily by way of a passive stylus which can be used in a pen mode or a mouse mode. In a pen mode a trail of ink tracking the path of the stylus pen paradigm provides visual feedback to the user by way of a pen digitizer. In a mouse mode however a cursor may be generated which follows the tip of the pen but the path of cursor motion is not inked.

A virtual keyboard is also provided as part of the GUI. Activation of the keys on the virtual keyboard is by way of the stylus or by finger input. In addition the system also supports a full size external keyboard.

As mentioned above the wireless interface device can also be used with a wireless LAN in a peer to peer network or a wired LAN. illustrates the communication between the wireless interface device and a wired LAN which includes a server in a for example Novell Netware or Microsoft LAN Manager environment. In this mode the transceiver in the wireless interface device communicates with an access point by way of a transceiver not shown which interfaces the wireless interface device with a wired LAN which includes a server . Alternatively the wireless interface device can be used in a wireless network in a Windows for Workgroups or Personal Netware environment for example.

The configuration of the radio communication subsystem between the wireless interface device and the remote host computer or access point conforms to the Open System Interconnection OSI reference model for data communications and implements the lower two layers of the seven layer OSI model. In particular with reference to the physical layer WIRELESS PHY may be a 2.4 GHz spread spectrum frequency hopping radio which replaces the LAN cable normally connected between workstations. The radio operates within the 2.4000 2.4835 GHz band the unlicensed Industrial Scientific and Medial ISM band and is divided into eighty two 1 MHz channels. In a spread spectrum frequency hopping radio data is broadcast on one particular channel for a predetermined time i.e. 400 msec and then the system hops to another channel in a predetermined pattern to avoid interference.

The wireless media access control WIRELESS MAC is used to interface to higher level software i.e. NOS SHELL NOVELL MICROSOFT through network drivers i.e. LINK LEVEL INTERFACE ODI NDIS . The MAC conforms to the industry standard protocol is in accordance with IEEE 802.11.

As shown in the wireless interface device includes a central processing unit CPU a local memory system a pen based input subsystem STYLUS a display subsystem and a transceiver . As will be discussed in more detail below the wireless interface device includes a Viewer Manager software which performs three 3 basic functions i collecting and transmitting input positional information from a stylus input subsystem to the host computer ii receiving from the host computer video image to be displayed on the display subsystem and iii managing the communications link between the wireless interface device and the host computer .

The wireless interface device is thus able to control and access various programs such as Windows and Windows application programs and files residing at the host computer and display the results in its display .

The CPU interfaces over local bus with a system controller . The system controller manages i system operation including the local and ISA buses and ii memory and iii power to the system. The system controller may be for example a Model No. 86C368 integrated circuit available from. PicoPower Technology Inc. San Jose Calif.

The present implementation takes advantage of the several levels of power management supported by the system controller . Power management in the present implementation is described in further detail below.

The system controller provides a dynamic random access memory DRAM controller and a non volatile random access memory NVRAM controller to control the DRAM A and a non volatile RAM NVRAM B which form a portion of the memory subsystem in the wireless interface device . As shown in the DRAM A in the wireless interface device may be provided by four 16 bit by 256K DRAM memory chips to provide a total of 2 megabytes of memory while the NVRAM B used to store configuration data and passwords for example may be implemented using E2PROM technology to provide permanent storage.

All devices on the ISA bus are managed by an integrated peripheral controller IPC . The IPC provides various functions including direct memory access DMA control interrupt control a timer a real time clock RTC controller and a memory mapper for mapping peripheral devices to the system memory space as illustrated in Table 4 below. The IPC may be implemented by a Model No. PT82C206 integrated circuit also available from the aforementioned PicoPower Technology Inc.

The stylus input subsystem is implemented by a stylus a pen controller A and a digitizer panel B. The pen controller A controls the digitizer panel B and provides positional information of pen or stylus contact. The pen controller A can be implemented for example by a Model No. MC68HC705J2 microcontroller available from Motorola Inc. In this implementation the digitizer panel B can be for example an analog resistive touch screen so that the stylus is sensed by mechanical pressure. Using a digitizer panel which senses mechanical pressure allows a dumb stylus or even the human finger to be used as an input device. When using a dumb stylus switching between mouse and pen modes is accomplished by selecting an icon as discussed below. Alternately other styli such as a light pen or an electronic stylus with various operating modes can also be used. In some electronic stylus switching between pen and mouse modes can be achieved by pushing a barrel button i.e. a switch located on the barrel of the stylus .

As mentioned above the wireless interface device includes a display subsystem which in turn includes a liquid crystal display LCD C. The LCD C is controlled by a video controller A and supported by video memory B. The video controller A can be implemented by a Model No. CL GD6205 video controller available from Cirrus Logic Corporation Milpitas Calif. The LCD C can be for example a monochrome display such as the Epson EG9015D NZ from Epson Corporation or an active matrix color display. The video memory B may be implemented as DRAMs organized as 0.256K by 16 bits.

The video controller A communicates with video memory B over a separate 16 bit video bus D. In this implementation the video controller A provides backlighting support through a backlight control pin BACKLITEON that is de asserted to conserve power under certain power management conditions as discussed below.

As discussed above the communication subsystem allows communication with a remote host computer in either a stand alone configuration or connected to either a wired or wireless LAN. The communication system includes the transceiver an antenna A and an RF controller A for interfacing with the local ISA bus .

The wireless interface device also includes a keyboard controller which performs in addition to controlling an optional keyboard by way of a connector various other functions including battery monitoring and LCD status control. The keyboard controller can be implemented by a Model No. M38802M2 integrated circuit from Mitsubishi Corporation Tokyo Japan. Battery power to the wireless interface device may be provided by an intelligent battery pack IBP for example as described in U.S. patent application Ser. No. 07 975 879 filed on Nov. 13 1992 hereby incorporated by reference connected to a system power supply module by way of a battery connector . The IBP maintains and provides information about the remaining useful battery life of IBP monitored by keyboard controller . Upon the occurrence of a significant event relative to the IBP e.g. battery remaining life falling below a preset value the keyboard controller generates an interrupt signal.

A serial port is provided and implemented by way of a universal asynchronous receiver transmitter UART which can be accessed externally via a serial port connector . As will be discussed in more detail below the serial port connector allows for disaster recovery for the flash memory which may be used to store the basic input output BIOS for the CPU .

In order to conserve battery power the wireless interface device incorporates power management. While a user of the wireless interface device would normally only be aware of four power management states off active suspend and sleep modes internally six power management states are implemented as shown in . More particularly with reference to before the wireless interface device is powered up the wireless interface device is in an off state indicated by the reference numeral . In an off state no power is supplied to the system. A state the active state is entered when the power switch to the wireless interface device is turned to the on position. In the active state all components of wireless interface device are active. From active state the wireless interface device enters a local standby state . The local standby state is transparent to the user of the wireless interface device . From the user s point of view in the local standby state the wireless interface device is in active mode. In this state specific inactive devices are each put into a static state after a predetermined time out period of inactivity for that device. In a static state each device consumes minimal power. In the local standby state devices that can be put into static states include the CPU the video controller A the pen controller A the UART and the transceiver . Backlighting of the LCD video display is also disabled in local standby state . If not input activities are detected by the keyboard controller or pen controller A. After the later of their respective present time out periods these devices are placed in a static state. These devices emerge from the static state once an activity relevant to its operation is detected e.g. a pen event is detected.

The user of the wireless interface device can place the wireless interface device in a sleep mode by selecting an icon labelled sleep from the GUI as will be discussed below. Alternatively the sleep mode may be entered from the active state after a preset period of inactivity. In a sleep mode corresponding to either sleep state or active sleep state the display subsystem is switched off and most devices are placed in static states. When a keyboard or pen event is detected the sleep state and active sleep state are exited and the wireless interface device enters the active state . From the sleep state an active sleep state is entered when a communication packet is received from the host computer . Although the display subsystem is turned off the received communication packet can result in an update to an image stored in the video memory B. The CPU handles the communication packet from the host computer and activates the video controller A to update such an image. The active sleep state is transparent to the user of the wireless interface device since the updated image is not displayed on the LCD screen C. When the communication packet is handled the wireless interface returns to a sleep state . The device activities in wireless interface device in sleep mode are illustrated in Table 1 below.

Upon expiration of a timer the wireless interface device enters into an internal state suspend mode . In a suspend mode the wireless interface device is essentially turned off and communication packets from the host computer are not handled. The wireless interface device emerges from suspend state into active state when a pen event is detected.

As mentioned above the video controller A supports various power management modes internal to the display subsystem . Power is conserved in display subsystem by entering standby and suspend modes. In the video controller A s standby mode which can be entered by i expiration of a timer internal to the video controller A ii firmware in the video controller A or iii a signal received from system controller on the video controller A s STANDBY pin. In the video controller A s standby mode the LCD C is powered down and the video clock is suspended. The video controller A exits the standby mode either under firmware control or upon system controller s de asserting video controller A s STANDBY pin. Upon exiting standby mode the LCD C is powered and the video clock becomes active. In this implementation the LCD C includes multiple power planes panels . For reliability reasons in a powering up or powering down operation these panels in the LCD display are preferably powered in a predetermined sequence specified by the manufacturer.

Maximum power is conserved in the display subsystem when video controller A enters the suspend mode. The suspend mode can be entered either by asserting a signal from the system controller on the SUSPEND pin of video controller A or under firmware control. In this implementation if the suspend mode is entered from the SUSPEND pin the CPU is prevented from accessing the video RAM B and video bus D. In that state the contents of configuration registers in the video controller A are saved to be restored when suspend mode is exited. In the suspend mode the video RAM B is refreshed using the lowest possible refresh clock rate.

In normal operation state the wireless interface device controls the program running in the host computer in accordance with the input data received from stylus input subsystem . The positions of the stylus in stylus input subsystem are delivered to the host computer which generates display commands to the wireless interface device . The CPU executes the display commands received which may result in an update of the LCD C. In this embodiment either a direct user command or inactivity over a predetermined time period causes the wireless interface device to enter a HOT STANDBY minimum power state sleep mode represented in by block . In the minimum power state to preserve battery power the various operations of the wireless interface device s functional units are placed on standby status. If the status is put in contact with the digitizer panel the wireless interface device is reactivated and control of the host computer is resumed by re entering state . Thereupon wireless interface device enters into a state in which an auto disconnect procedure is executed which releases control of the host computer and powers down the wireless interface device .

The user may also relinquish control of the host computer from state by selecting a manual disconnect function. When the manual disconnect function is selected the wireless interface device enters manual disconnect state in which the connection to the host computer is terminated. The wireless interface device is then returned to state to accept the next user validation.

In the software environment B i.e. in host computer pen events are queued in pen event buffer which may then be provided to the Pen Windows module . The Pen Windows module processes the pen events and creates video events in a video event buffer which is then transmitted to the wireless interface device over wireless communication system .

The RC Manager examines each pen event in the RC buffer and according to the context of the pen event in its possession the RC Manager determines whether the stylus is in the pen mode or in the mouse mode. In this embodiment as will be discussed in more detail below an icon allows the user to use the stylus as a mouse device. The icon called mouse button toggle allows the user to switch between a left button and a right button as used in an industry standard mouse device. The selected button is deemed depressed when the stylus makes contact with the pressure sensitive digitizer panel. A rapid succession of two contacts with the display is read by the RC Manager as a double click and dragging the stylus along the surface of the display is read by the RC Manager as the familiar operation of dragging the mouse device with the selected button depressed.

If the stylus is in the pen mode the RC Manager provides the pen event to a recognizer to interpret the gesture . Alternatively if the pen event is a mouse event the RC Manager provides the pen event as a mouse event for further processing in a module . The interpreted gestures or mouse events are further processed as input data to the Windows operating system or the application program .

The output data from an application program such as Windows or application program is provided to the video event buffer . These video events are transmitted to the host communications output manager for transmission to the wireless interface device .

At the core of the wireless interface device s user interface is the stylus s behavior under Pen Windows. Of significance in wireless interface device s design is the emulation of the natural pen and shaper interaction with the user. That is in a pen mode the stylus must leave ink as it moves across the surface of the screen in the same way that a pen leaves ink on paper. However using Pen Windows software the RC Manager residing in the host computer determines for each pen event whether the mouse or the pen mode is used.

If the wireless interface device simplistically accesses the host computer as a local device access the wireless link between the host computer and the wireless interface device would be required to carry a minimum of 200 inking messages per second 100 stylus tip locations plus 100 line drawing commands . To maintain the pen and paper emulation the wireless interface device is further required to have a total processing delay hence response time including the overhead of the communication protocols which is near or below the human perception level. In addition noise in the transmission medium often leads to momentarily interruption of data transmission or results in data corruption that requires re transmission thereby further reducing the throughput of the wireless link. To provide an acceptable level of performance i.e. a high message per second communication rate and an acceptable propagation delay a technique referred to as local inking is developed and applied to the wireless interface device s design in accordance with the present invention. Without local inking a high bandwidth communication link is required to meet the propagation delay requirement. Such a high bandwidth communication link is impractical both in terms of cost and its impact on the portability of the resulting wireless access device.

With local inking the Viewer Manager software provides inking on the LCD C locally before the corresponding inking video events are received from the host computer . In this manner visual feedback is provided virtually immediately without requiring either highly complex networking equipment or very high performance and costly components in both the wireless interface device and the host computer . Local inking provides both a real time response and an orderly handling of the stylus s data stream. Since local inking reduces the need for processing at the peak pen event rate of the stylus s data stream the host computer can thus apply normal buffering techniques thereby reducing the bandwidth requirement on the communication network.

In one proposed industry standard for a stylus or pen based system namely the Microsoft Windows for Pen Computing system Pen Windows the pen mode requires i a pen driver that can deliver stylus tip locations every five to ten milliseconds 100 to 200 times per second so as to achieve a resolution of two hundred dots per inch 200 dpi and ii a display driver than can connect these dots in a timely manner. By these requirements Pen Windows attempts to provide a real time response to maintain the pen paradigm. The Windows for Pen Computing system is promoted by Microsoft Corporation Redmond Wash. Details of the Pen Windows system are also provided in Windows version 3.1 Software Developer Kit obtainable from Microsoft Corporation. Under one implementation of the Pen Windows a maximum of four stylus locations can be stored in a buffer of a module called PENWIN.DLL for Pen Window Dynamically Linked Library . Consequently in that implementation the maximum latency allowed is twenty to forty milliseconds before any queue 15 tip location is written. Each time the system fails to process a pen event within twenty to forty milliseconds of queuing a stylus tip location is lost and there is a corresponding impact on the accuracy of the line being traced.

As mentioned above the stylus is used in both pen mode and mouse mode. Since the RC Manager running on the host computer rather than a software module on the wireless interface device determines whether a given pen event is a mouse mode event or a pen mode event the Viewer Manager software must anticipate which of these modes is applicable for that pen event. Further should the anticipated mode prove to be incorrect the Viewer Manager software is required to correct the incorrectly inked image in video display subsystem .

Alternatively while in state if a mode message is received indicating the stylus is in the pen mode the control program enters state in which the accumulated pen events are drawn locally onto the LCD screen of the video display subsystem in accordance with the line style and color specified in the mode message. After all accumulated pen events in the pen event buffer are drawn the control program enters a state in which control program continues to ink the trajectory of the tip of the stylus for as long as contact with the pen digitizer is maintained. Once the tip of the stylus breaks contact with the pen digitizer the control program enters state .

In state the control program assumes that the stylus will continue to be in the pen mode. Thus local ink will follow the trajectory of the stylus while the top of the stylus remains in contact with the pen digitizer or until a mode message is received from the host computer whichever arrives earlier. Since the initial policy decision is a guess the local inking is drawn using a single pixel wide style and an XOR exclusive OR operation in which the pixels along the trajectory of the stylus are inverted. While in state the pen events associated with the trajectory of the stylus are accumulated in the pen event buffer .

If the mode message received in state indicates that the stylus is in mouse mode i.e. the policy decision was wrong the control program then enters a state in which the accumulated pen events in pen event buffer are used to erase the stylus stroke. Since the initial draw is accomplished by a bit XOR exclusive OR operation at the appropriate positions of the frame buffer erasure is simply provided by the same XOR operation at the same positions of the frame buffer. The control program then enters state . However if the mode message received in state confirms that the stylus is in pen mode the accumulated pen events of pen event buffer are used to redraw on the LCD C using the line style and color specified on the mode message.

Under a convention of the Pen Windows software starting a stroke of the stylus with the barrel button depressed for active stylus systems indicates an erase ink operation in pen mode. The control program recognizes this convention and refrains from inking during this stroke without waiting for confirmation from the host computer . In addition the control program does not change modes across an erasing stroke i.e. if the stylus is in the pen mode prior to the erase stroke the stylus remains in the pen mode after the erase stroke conversely if the stylus is in the mouse mode prior to the erase stroke the stylus remains in the mouse mode after the erase stroke.

Since all the pen events used in local inking on the wireless interface device are also processed in the host computer the trajectory of local inking must coincide identically with the line drawn at the host computer . Because of local inking processing by the host computer within the human perceptual response time is rendered unnecessary. Thus in the host computer the pen events can be queued at pen event buffer to be retrieved one at a time by pen event injector . Hence when pen event buffer is suitably sized data loss due to overflow by RC buffer is prevented.

Alternatively the control program can also be implemented to follow a retractable ball point pen paradigm. Under this paradigm the user controls a local stylus mode of the stylus such that inking occurs when the stylus is set to be in the local pen mode and no inking occurs when the stylus is in the local mouse mode. If the local stylus mode conforms with the mode expected by Pen Windows the image seen on the LCD display of the video display subsystem is the same as described above with respect to state of the control program . If the local stylus mode is the mouse mode and Pen Windows software expects stylus to be in the pen mode the 20 subsequent video events from host computer would provide the required inking. Finally if the local stylus mode is the pen mode and Pen Windows software expects the stylus to be in the mouse mode inking would be left on the screen of video display subsystem . Under this paradigm the user would eliminate the erroneous inking by issuing a redraw command to Pen Windows.

One embodiment of the invention is illustrated in the schematic drawings . Referring to the system may include a CPU such as an AMD Model No. AM386DXLV microprocessor. The CPU includes a 32 bit data bus D 0 . . . 31 as well as a 32 bit address bus A 2 . . . 31 . Both the data bus D 0 . . . 31 as well as the address bus A 2 . . . 31 are connected to the processor bus for example an AT bus. As will be discussed in more detail below the system controller performs various functions including management of the processor bus . In order to conserve power a 3 volt microprocessor may be used for the CPU . As such a 3 volt supply 3V CPU is applied to the power supply VCC pins on the CPU . The 3 volt supply 3V CPU is available from a DC to DC converter by way of a ferrite bead inductor . In particular the DC to DC converter includes a 3 volt output 3V CORE. This output 3V CORE is applied to the ferrite bead inductor and in turn to the power supply pins VCC of the CPU . In order to prevent noise and fluctuations in the power supply voltage from affecting the operation of the CPU the power supply voltage 3V CPU is filtered by a plurality of bypass capacitors through .

The 3 volt supply 3V CPU is also used to disable unused inputs as well as to pull various control pins high for proper operation. For example the 3 volt power supply 3V CPU is applied to the active low N A and BS pins of the CPU by way of a pull up resistor . In addition the signals BE 0 . . . 3 W R D C M IO and ADS are pulled up by a plurality of pull up resistors through .

The CPU is adapted to operate at 25 megahertz MHz at 3.0 volts. A 25 MHz clock signal identified as CPU CLK available from a clock generator is applied to a clock input CLK on the CPU by way of a resistor and a pair of capacitors and . The AMD Model No. AMD386DXLV microprocessor supports a static state which enables the clock to be halted and restarted at any time.

The wireless interface device includes a speaker . The speaker is under the control of the system controller . In particular a speaker control signal SPKR from the system controller is applied to a source terminal of a field effect transistor FET for direct control of the speaker . The drain terminal is connected to the speaker by way of a current limiting resistor and a bypass capacitor . Normally the speaker is active all the time. In particular the gate terminal of the FET is connected to the system ground by way of a resistor . The gate terminal of the FET is also under the control of a speaker disable signal SPKRDISABLE available from the keyboard controller . The speaker disable signal SPKRDISABLE is active high. Thus when the speaker disable signal SPKRDISABLE signal is low the FET is turned on to enable the speaker signal SPKR from the system controller to control the speaker . When the speaker disable signal SPKRDISABLE is high the FET is turned off to disable the speaker .

Referring to the system controller is connected between the local processor or AT bus and the system ISA bus . The system controller performs a variety of functions including that of system controller DRAM controller power management battery management and management of the local AT bus . The system controller preferably a PicoPower Pine Evergreen 3 Model No. 86C368 system controller is a 208 pin device that operates at 33 MHz with a full 5 volt input or a hybrid 5 volt 3.3 volt input. At 3.3 volts the system controller is adapted to reliably operate at 20 Mhz and perhaps up to 25 Mhz.

The system controller includes several system features including support of several clock speeds from 16 to 33 MHz. In addition the system controller includes two programmable non cacheable regions and two programmable chip selects used for universal asynchronous receiver transmitter UART interface and the radio interface B as discussed below.

The system controller supports both fast GATE A and a fast reset control of the CPU . In particular the system controller includes a 32 bit address bus A 0 . . . 31 that is connected to the local AT bus . The address line A 20 is used to develop a signal CPUA20 which is applied to the A pin on the CPU and also applied to an AND gate to support a port H for a fast GATE A signal. A fast reset signal RSTCPU is also generated by the system controller . The fast reset signal RSTCPU is applied to the reset pin RESET of the CPU for fast reset control.

The system controller also provides various other system level functions. For example the system controller includes a register at address H. By setting bit of this register a ROM chip select signal ROMCS is generated which enables writes to the flash memory system which will be discussed below. A keyboard controller chip select signal KBDCS for the keyboard controller as well as general purpose chip select signals GPCS and GPCS for selecting between the RF controller A the UART or the pen controller A are generated by the system controller .

The system controller is connected to the system ISA bus by way of a 16 bit system data bus SD 0 . . . 15 and a 24 bit system address bus SA 0 . . . 23 of which only 8 bits SA 0 . . . 7 are used. The system controller is also connected to the 32 bit local processor data bus D 0 . . . 31 as well as the local processor address bus A 0 . . . 31 .

All of the ground pins GND on the system controller are tied to the system ground. Both 3 volt and 5 volt power supplies are applied to the system controller . In particular a 5 volt supply 5V EG is applied to the power supply pins VDD of the system controller . The 5 volt supply 5V EG is available from DC to DC converter by way of a ferrite bead inductor . More particularly a 5 volt supply signal 5V CORE from the DC to DC converter is applied to the ferrite bead inductor which in turn is used to generate the 5 volt supply signal 5V EG. In order to stabilize the 5 volt supply signal 5V EG a plurality of bypass capacitors are connected between the 5 volt supply 5V EG and system ground.

A 3 volt power supply 3V EG is also applied to the system controller and in particular to the power supply pins VDD 3V. This 3 volt supply 3V EG is also obtained from the DC to DC converter by way of a ferrite bead inductor . More particularly 3 volt supply 3V CORE available at the DC to DC converter is applied to the ferrite bead inductor which in turn is used to generate the 3 volt power supply signal 3V EG. A plurality of bypass capacitors and are connected between the 3 volt supply 3V EG and system ground for stabilizing.

The system controller is reset by a reset signal RCRST on power up. The reset signal RCRST is developed by the 3 volt power supply 3V EG available from the DC to DC converter and circuitry which includes a resistor a capacitor and a diode . Initially on power up the capacitor begins charging up from the 3 volt supply 3V EG through the resistor . During this state the diode is non conducting. As the capacitor charges the level of the reset signal RCRST rises to reset the system controller . Should the system be turned off or the 3 volt supply 3V EG be lost the diode provides a discharge path for the capacitor .

In order to assure proper operation of the system controller a number of signals are pulled up to either five volts or three volts or pulled down by way of various pull down resistors. More specifically the signals IOCS MASTER MEMCS REFRESH ZWS IOCHCK GPI MDDIR and GPIO MDEN are pulled up to the 5 volt supply 5V EG by way of a plurality of pull up resistors respectively. Similarly the signals BUSY FERR LOCAL SMIADS and RDY are pulled up by a plurality of pull up resistors through . In addition the general purpose chip select signals GPCS and GPCS are pulled up to the 5 volt power supply signal 5V EG by way of a pair of pull up resistors and . Certain signals are pulled low by way of pull down resistors in order to assure their operating state. In particular the signals KBC PO LB EXTACT RING EXTACT VLCLK and HRQ are pulled down by the pull down resistors to . The signal BLAST is tied directly to the system ground.

As mentioned above the system controller is capable of running at different clock frequencies depending upon the voltage applied while supplying a clock signal to the CPU . Even though the system controller can supply either a 1 or a 2 clock signal to the CPU the system controller requires a 2 clock for proper operation. Thus a 2 clock signal CLKIN available from a clock generator circuit is applied to the clock 2 pin CLKIN of the system controller . In addition 32 kilohertz KHz and 14 megahertz MHz clock signals are also applied to the system controller available from the clock generator circuit for proper operation. The system controller in turn provides a CPU clock signal CPUCLK to the CPU and in particular to its clock 2 pin CLK by way of a resistor and the capacitors and .

The system controller is adapted to be configured during an RC RESET mode. In particular the DRAM memory address lines MA 0 . . . 10 normally used for addressing the DRAM A are pulled high or low in order to configure the system controller . More particularly the DRAM memory address lines MA 0 . . . 10 are applied to either pull up or pull down resistors for configuration as illustrated in . Table 2 below illustrates the configuration shown.

As shown the DRAM memory address lines MA 0 . . . 10 are shown with bits MA MAS and MA pulled high to the 3 volt power supply voltage 3V EG by way of a plurality of pull up resistors and . The remaining DRAM address line bits MA MA MA MA MA MA MA and MA are pulled low by a plurality of pull down resistors through respectively. The DRAM memory address lines MA 0 . . . 8 are also coupled to a plurality of coupling resistors to form a 9 bit DRAM address bus BMA 0 . . . 8 .

The system controller functions as a DRAM controller and is capable of supporting up to 64 megabytes of memory divided among one of four banks and can support 256K 512K 1M 2M and 4M of memory in any width. The system controller includes a pair of registers associated with each bank of DRAM. The first register stores the total amount of DRAM connected to the system while the second identifies the starting address for each bank. Referring to two 1 Mbyte banks are connected to the DRAM memory address bus BMA 0 . . . 8 and to the processor data bus D 0 . . . 31 .

In order to conserve power 3 volt DRAM A is used. The 3 volt power supply 3V RAM is applied to the VCC terminals of each of the DRAMS A. The 3 volt power supply 3V RAM is available from the DC to DC converter by way of a ferrite bead inductor . In particular a 3 volt supply 3V CORE available at the DC to DC converter is applied to the ferrite bead inductor to generate the 3 volt DRAM supply 3V RAM. A plurality of bypass capacitors are connected between the DRAM supply voltage 3V RAM and system ground.

The system controller generates the appropriate row address strobes RAS and column address strobes for the DRAM A. In particular the column address strobe lines CAS 0 . . . 3 are applied to the upper and lower column address strobe pins UCAS and LCAS on the DRAM A by way of a plurality of coupling resistors to . Similarly the row address signals RASO and RAS are applied to the row address strobe pins on the DRAM A by way of a plurality of coupling resistors and . Writing to the DRAMS A is under the control of a DRAM write enable signal BRAMW applied to the write enable pin WE on the DRAM A. The DRAM write enable signal BRAMW is generated by the system controller by way of a coupling resistor .

An EEPROM or NVRAM B may be used to maintain system configuration parameters when the system is powered off. All user changeable parameters are stored in the EEPROM B. For example pen calibration data and passwords used during boot up may be used in the EEPROM . The contents of the EEPROM B may be shadowed into a CMOS memory when the system is active. Communication with the EEPROM B is under the control of the system controller and in particular a pair of programmable input output pins GPIO and GPIO. The GPIO provides a clock signal to the EEPROM B while the pin GPIO is used for data transfer.

As discussed above the wireless interface device also includes the flash memory which is used for storing the BIOS. The system controller allows for direct shadowing of the BIOS by enabling the appropriate address space to read the FLASH DRAM write mode which allows all reads to come from the flash device with writes to the DRAM A memory devices.

In addition to system control features and DRAM control the system controller provides various other functions. The power management function and NVRAM n controller have been discussed above. The system controller also controls all operations on the local AT bus . The AT bus clock is derived from the clock CLKIN pin that is divided to achieve an 8 MHz bus rate.

The system controller also includes a number of programmable pins which enhance its flexibility. For example four general purpose input output pins GPIO 0 . . . 3 are provided each of which may be independently set for input or output. The GPIO and GPIO pins are used for the EEPROM B as discussed above. The GPIO pin and GPI pin may be used for various purposes. In addition to the programmable input output pins the system controller includes two general purpose chip select pins GPCS and GPCS as well as a plurality of programmable output pins PC 0 . . . 9 . The programmable chip selects GPCS and GPCS are used for the pen controller A UART and the radio interface B.

Peripheral devices connected to the system ISA bus are controlled by an integrated peripheral controller as discussed above. The integrated peripheral controller may be a PicoPower Model No. PT82C206F which can be operated at either 3.3 or 5 volts. As will be discussed in more detail below the integrated peripheral controller includes several subsystems such as DMA Control Interrupt Control Timer Counter RTC Controller CMOS RAM and Memory Mapper.

The IPC includes two type 8259A compatible interrupt controllers which provide 16 channels of interrupt levels one of which is used for cascading. The interrupt controller processes all incoming interrupts in order as set forth in Table 5.

The integrated peripheral controller IPC is connected to the system data bus SD 0 . . . 15 . Addressing of the IPC is accomplished by two bits SA and SA from the system address bus SA 0 . . . 23 and eight 5 bits A 2 . . . 9 from the local address bus A 0 . . . 31 . The address bits from the local address bus A 2 . . . 8 are converted to 5 volts by way of a 3 to 5 volt signal converter to develop the 5 volt address signals KA 2 . . . 8 . A 32 kilohertz clock signal 32 KHz from the clock generator is applied to the clock input OSC of the IPC .

Referring to in order to prevent spurious operation of the IPC before the system power supply is stabilized a power good signal PWRGOOD is applied to a power good pin PWRGD. The power good signal PWRGOOD is a delayed signal which assures that the 5 volt power supply has stabilized before the IPC is activated. In particular a 5 volt power supply 5V CORE is applied to a delay circuit which includes a resistor a diode and a capacitor . Initially the 5 volt power supply signal 5V CORE is dropped across the resistor . While the capacitor is charging the diode is in a non conducting state. As the capacitor begins to charge the voltage at the anode of the diode increases as a function of the RC time constant. When the capacitor is fully charged it approaches the value of the power supply voltage 5V CORE. When the capacitor becomes fully charged the power good signal PWRGOOD is applied to a power good pin PWRGD at the IPC for enabling the IPC after the power supply has stabilized. The diode provides a discharge path for the capacitor when the power supply is shut off. The power good signal PWRGOOD is also used to reset the keyboard controller .

A 5 volt power supply 5V CORE from the DC to DC converter is applied to a ferrite bead inductor to develop a 5 volt power supply 5V  which in turn is applied to the power supply pins VCC of the IPC . In order to delay application of the 5 volt power supply 5V  as discussed below a charging circuit which includes a serially coupled resistor and a capacitor are connected between the power supply voltage 5V  and the system ground. A power supply reset signal PSRSTB an active low signal is applied to the junction between the resistor and the capacitor to discharge the capacitor when the power supply is reset. Moreover in order to stabilize the voltage of the power supply 5V  a plurality of bypass capacitors and are connected between the power supply 5V  and system ground.

In order to assure proper operation of the 15 circuit various pins of the IPC are pulled low while various other pins are pulled high. In particular the input output read and write signals IOR and IOW are pulled up to the power supply voltage 5V  by a pair of pull up resistors and . In addition the interrupt request pin IRQ is pulled up to the power supply voltage 5V CORE by a pull up resistor . The signals OUT REFREQ AEN and AEN are pulled low by pull down resistors while the signal TEST MODE is pulled up to the supply voltage 5V CORE by a pull up resistor .

Even though the IPC includes a direct memory access DMA controller this function is not required by the system. As such the direct memory access request pins DREQ 0 . . . 7 are pulled low by a pull down resistor to system ground. In addition as set forth in Table 5 above 30 various interrupt levels are unused. For example as shown in Table 5 interrupt levels IRQ IRQ IRQ IRQ IRQ IRQ IRQ and IRQ are not used. Thus these interrupt levels are pulled low by a pull down resistor .

As illustrated in Table 5 interrupt levels IRQ and IRQ are used for the COM and pen controller interrupt levels IRQ and IRQ. To assure that these levels are proper the IRQ and IRQ which are active high are pulled low by pull down resistors and .

Interrupts by the system controller and IPC INTR EG and INTR are applied to the CPU by way of a diode and pull up resistor . In particular the interrupt signals INTR EG and INTR from the system controller and IPC respectively are applied to the cathode of the diode while the anode is pulled up to the power supply voltage 3V CORE by the pull up resistor . The logic level of the anode is set by the interrupt signal INTR which is applied to the CPU . When the interrupt signals INTR and INTR EG are high the diode does not conduct and the CPU interrupt signal INTR will be high. When either of the interrupt signals INTR EG or INTR are low the diode conducts forcing the CPU interrupt signal INTR low.

The IPC also includes a type 8254 compatible counter timer which in turn contains three 16 bit counters that can be programmed to count in either binary or binary coded decimal. The zero counter output is tied internally to the highest interrupt request level IRQO so that the CPU is interrupted at regular intervals. The outputs of the timers and are available for external connection. In particular internal timer generates one signal OUT which is used to generate a DRAM refresh request signal REFREQ to the CPU . The internal timer generates an output signal OUT that is used to generate speaker timing. All three internal timers are clocked from a timer clock input TMRCLK at 1.2 megahertz from the system controller .

As mentioned above the IPC includes a real time clock RTC controller which maintains the real time. The real operational time is maintained in a CMOS RAM that can be accessed through registers H and H. The memory map for the CMOS memory is provided in Table 6 as shown below 

The area designated as User RAM is used by the system BIOS to save the status of the system configuration registers. The alarm bytes may be used to set and generate an interrupt at a specific time. When periodic interrupt is required the two most significant bits in the alarm register can be set high.

The various clock signals used for the system are provided by the clock generator circuit . The clock circuit includes a clock generator for example an Integrated Circuit Designs Model No. ICD2028. A 14.318 MHz crystal and a 32.768 KHz crystal are applied to the clock generator . In particular the crystal is applied to a pair of X1 and X2 input pins along with a plurality of capacitors and an input resistor . Similarly the crystal is applied to input pins XSYSB and XSYSB. A pair of capacitors and are connected across the crystal .

The clock generator IC provides three clock outputs CLKA CLKB and CLKD. The clock A output CLKA is used to develop an 8 MHz clock signal for the keyboard controller by way of a resistor and capacitors and . The clock B output CLKB is used to develop a clock 2 output signal CLKIN for the system controller by way the resistors and and a pair of capacitors and . The clock D output signal CLKD is used to generate a 1.84 MHz signal for use by the Universal Asynchronous Receiver Transmitter UART by way of a resistor and capacitors and . As mentioned above the system controller also requires a 14 MHz clock signal. This clock signal is developed by way of a system bus output pin SYSBUS a resistor and a pair of capacitors and .

Selection of the various clock output signals is available by way of the select pins S S and S. These pins S S and S are pulled up to the 3 volt power supply 3V CORE by way of pull up resistors and . The 3 volt power supply signal 3V CORE is available from the DC DC converter .

The clock generator utilizes a 3 volt power supply CLOCK VCC . The 3 volt power supply CLOCK VCC is available from the DC to DC converter by way of an in line ferrite bead inductor . In particular the 3 volt power supply 3V CORE is applied to the ferrite bead inductor to generate the power supply for the CLOCK VCC for the clock generator . This power supply CLOCK VCC is applied to the power supply pin VDD. The power supply signal CLOCK VCC is also used as analog supply AVDD to the clock generator IC and is applied to the analog supply AVDD by way of the resistor and a pair of capacitors and . The power supply signal CLOCK VCC is also applied to the battery pin VBATT of the clock generator IC by way of a diode to prevent any back feeding.

A number of the circuits in the system operate at either 3.3 volts or 5 volts. Thus a plurality of bi directional signal level translators and are provided as well as the translator previously discussed. The signal level translators and may be as supplied by Integrated Circuit Technology Model No. FCT164245T. Each of the signal level translators and includes a 3 volt supply 3V CORE and a 5 volt supply 5V CORE available from the DC to DC converter . In order to stabilize the voltage of the 3 and 5 volt power supplies 3V CORE and 5V CORE a plurality of bypass capacitors are utilized. In particular the bypass capacitors through are connected between the 3 volt supply 3V CORE and system ground. Similarly the bypass capacitors through are connected between the 5 volt supply 5V CORE and system ground. The ground terminals of each of the signal level translators and are also tied to system ground.

Each of the signal level translators and includes two 8 bit programmable input output pins. More particularly the first 8 bit group A B 1 . . . 8 is under the control of an operate enable pin OE which is active low while the second bank A B 1 . . . 8 is under the control of an output enable pin OE also active low. The direction of the input pins and output pins i.e. A relative to B is under the control of direction pins DIR and DIR. The direction pin DIR controls the direction of the pins A B 1 . . . 8 while the pin DIR controls the direction of the pins A B 1 . . . 8 .

The signal level translator is used to convert the local data bus bits D 16 . . . 31 and the system data bus bits SD 0 . . . 15 . Both the local data bus D 16 . . . 31 as well as the system data bus SD 0 . . . 15 are bi directional. In this application the processor bus data bits D 31 16 are being mapped to the system data bus bits SD 15 0 .

The direction of the signal level translator is under the control of a signal direction signal SDIR available at the system controller . The signal direction signal SDIR is applied to both the direction control pins DIR and DIR of the signal level translator . The operate enable inputs OE and OE are under the control of system data enable inputs signals SDEN and SDEN respectively also under the control of the system controller .

The signal level translator is used to map the signal levels of the local address bus bits A 23 . . . 8 to the system address bus bits SA 23 . . . 8 . More particularly the local address bits A 23 . . . 16 are applied to pins A 1 . . . 8 while the local address bits A 15 . . . 8 are applied to the pins A 1 . . . 8 . Similarly the system address bits SA 23 . . . 16 are connected to the pins B 1 . . . while the system address bits SA 15 . . . 8 are applied to the pins B 1 . . . 8 . In this case the operate enable pins OE and OE both active low are connected to system ground in order to permanently enable the signal level translator . The direction control pins DIR and DIR are permanently set such that the data always flows from A to B. In particular the directional pins DIR and DIR are connected to the 3 volt power supply 3V CORE by way of a pull up resistor .

The signal level translator is used to convert the signal levels of the 3 volt clock output signals 14 Mhz 1.84 Mhz 32 Khz and 8 Mhz to 5 volt levels as well as to convert the 3 volt local address bits A 2 . . . 8 to 5 volt address bits XA 2 . . . 8 for use by the IPC as discussed above. More particularly the system address bits A 2 . . . 8 are applied to the pins A 1 . . . 8 . The clock signals 14 MHz 1.84 MHz 32 KHz and 8 MHz are applied to the pins A A A and A respectively to produce corresponding 5 volt level signals 14 MHz5V 1.84 MHz5V 32 KHz5V and 8 MHz5V signals at pins B B B and B respectively. The unused pins A and B are pulled low by way of pull down resistors and respectively. The operate enable pins E and E are tied to system ground to permanently enable the signal level translator . The directional pins DIR and DIR are pulled up to the 3 volt power supply voltage 3V CORE by way of a pull up resistor to permanently force the 15 direction from A to B.

Referring to the system includes a keyboard controller which performs several functions including battery monitoring LCD status control brightness and contrast control as well as keyboard control. In addition the system also maintains the status of the remaining battery life and also provides information to the system controller when the battery voltage is low or other critical battery condition has occurred. In operation the keyboard controller will maintain the current status of the battery level until data is requested. When a critical battery condition event occurs the keyboard controller generates an SMI interrupt. As discussed above the intelligent battery pack IBP provides an indication of the percentage of remaining battery capacity. Communication between the IBP and the keyboard controller is by way of a bi directional serial data bus which includes a clock line BATCLK and a data line BATDATA. The data line BATDATA is a bi directional line which allows for bi directional communication with the IBP . The clock line BATCLK is driven by the IBP but may be pulled low by the keyboard controller .

The bi directional serial data bus is connected to the port pins P. and P. on the keyboard controller . In particular the port pin P. is used for the serial battery data BATTDATA. An NPN transistor is connected to the port pin P. to disconnect the keyboard controller from the IBP during power down. In particular the collector terminal of the NPN transistor is connected to the port pin P. while the emitter terminal forms a battery data signal BATTDATA. The base of the NPN transistor is biased on by way of a biasing resistor that is connected to a 5 volt power supply 5VKBD. The collector is pulled high by way of a pull up resistor connected to the 5 volt power supply 5V KBD.

Similarly the battery clock signal BATTCLK is connected to the port . on the keyboard controller by way of an NPN transistor . The collector terminal of the NPN transistor is connected to the port . as well as to a pull up resistor and the 5 volt power supply 5V KBD. The NPN transistor is turned on anytime the power supply to the keyboard 5V KBD is powered up by way of a biasing resistor . The emitter of the NPN transistor forms the battery clock signal BATTCLK.

In addition to battery management the keyboard controller also supports an external PS 2 type keyboard as well as a PS 2 type bar code reader connected to a keyboard connector . Communication between the keyboard or bar code reader not shown is by way of a standard type PS 2 two wire bus connected to serial ports P. and P.. In particular the keyboard data KDATA is pulled up to the 5 volt voltage supply 5V CORE by way of a pull up resistor while the keyboard clock signal KCLK is pulled up the 5 volt supply 5V CORE by way of a pull up resistor .

Referring to the keyboard connector may be a 6 pin MINI DIN connector or a DB 8 connector as shown. Pins are connected to system ground. Pin of the connector is pulled up to the power supply voltage 5V CORE by way of a fuse and is filtered by a capacitor and an inductor . The data signal KDATA is applied to pin by way of a current limiting resistor while the clock signal KCLK is applied to pin by way of a current limiting resistor and a pair of capacitors and . These clock and data signals KCLK and KDATA are connected to the ports P. and P. respectively for serial communication with an external keyboard or bar code reader.

Additionally the keyboard controller may be used to control the brightness level as well as the contrast level of the LCD display. More particularly referring to a contrast signal CONTRAST available at port pin of the keyboard controller is used to adjust the contrast level of the LCD display. The contrast signal CONTRAST is applied to an adjustment terminal ADJ of a negative 24 volt DC voltage supply which can be incrementally adjusted in steps by a 24 volt DC supply for example a Maxim Model No. 749 which provides for 64 step adjustment. Thus each high pulse will increment the contrast of the LCD display by one step. With a 64 step device sixty three pulses rolls the counter over and decreases the contrast by 1. The 24 volt DC supply is under the control of an enable signal ENAVEE available from the video controller A .

In order to assure proper operation the 24 volt supply is connected in a circuit as shown in which includes a plurality of capacitors a plurality of resistors an inductor a PNP transistor and a zener diode . The output of the circuitry is a nominal negative 24 volt signal LCDVEE which is adjustable in 64 increments by way of the CONTRAST signal as discussed above to vary the contrast level of the LCD display.

The keyboard controller also controls the brightness of the LCD display. In particular brightness adjustment signals BRIGHTNESS UP BRIGHTNESS DOWN are available at port pins and . These signals BRIGHTNESS UP and BRIGHTNESS DOWN are normally pulled up to the 5 volt supply 5V KBD by way of a pair of pull up resistors and . These signals BRIGHTNESS UP and BRIGHTNESS DOWN are applied to a digital output potentiometer for example a Dallas Semiconductor Model No. DS1669 50. The digital output potentiometer is powered by a 5 volt power supply 5V CORE which is also used to pull up an unused output terminal RH.

The brightness control signals BRIGHTNESS UP and BRIGHTNESS DOWN are applied to the increment and decrement terminals UC and DC of the digital output potentiometer . The output of the digital output potentiometer is a variable resistance signal which forms the brightness control signal BRIGHTNESS. This brightness control signal BRIGHTNESS is pulled down by a pull down resistor .

The brightness control signal BRIGHTNESS from the digital output potentiometer as well as a backlight control signal BACKLITEON and a backlight power signal BACKLITEPOWER are connected to the system by way of a 6 pin connector . The backlight control signal BACKLITEON is connected to pin of the connector and pulled low by way of a pull down resistor . The power control signal BACKLITEPOWER is applied to pins and while the backlight brightness control signal BRIGHTNESS is applied to pin . The backlight control signal BACKLITEON is available from the video controller A and is used to power the backlight on the LCD. The backlight power signal BACKLITEPOWER available from an FET is under the control of the backlight power control signal BACKLITEON available from the video controller A .

The FET is used to control power to both the LCD as well as the backlight. In particular referring to the backlight power control BACKLITEON is used to control an NPN transistor by way of a current limiting resistor . The NPN transistor in turn is used to control the FET to generate the backlight power signal BACKLITEPOWER at the drain terminal D. The main power signal POWER is connected to the collector of the NPN transistor by way of a resistor . The main power signal POWER is also applied to a source terminal of the FET . A gate terminal G of the FET is connected between the resistor and the collector of the NPN transistor . The backlight power control signal BACKLITEON is used to conserve power under certain power management conditions discussed above. This signal BACKLITEON controls the NPN transistor . In particular in a normal state the backlight power control signal BACKLITEON is high which turns ON the NPN transistor . When the NPN transistor is ON the gate terminal G of the FET is connected to system ground which turns the FET ON thereby connecting the main power signal POWER to the drain terminal D of the FET to provide a power signal BACKLITEIN which is filtered by a ferrite bead inductor to provide the backlight power signal BACKLITEPOWER that is applied to the LCD by way of the connector . When the backlight power control signal is low for example during a power management mode the NPN transistor turns OFF thereby connecting the gate G of the FET to the main power signal POWER by way of the resistor thereby turning the FET OFF disconnecting power to the LCD.

The FET may be supplied as a dual element with two FETs in a single package. As shown in the gate G source S and drain D terminals of the FET are used to control power to the LCD under the control of an LCD enable signal ENAVDD available from the video controller A . In particular the LCD enable signal ENAVDD is normally high and is de asserted to disable the LCD power supply LCD POWER. This LCD enable signal ENAVDD is pulled low by a pull down resistor and applied to an inverter whose output is connected to the gate terminal G of the FET . The LCD power supply signal LCD VCC is applied to the source terminal S of the FET while the drain terminal D represents the LCD power signal LCD POWER filtered by an inductor and a capacitor . The LCD power signal LCD POWER is connected to the LCD by way of the connectors or . In operation the LCD power enable signal ENAVDD is high which turns on the FET to enable the LCD power supply LCD POWER. When the LCD power enable signal ENAVDD is de asserted the FET is turned OFF.

The keyboard controller is connected to the system data bus SD 0 . . . 7 . The system address bit SA is used for addressing the keyboard controller . In particular the address terminal of the keyboard controller is connected to bit SA of the system address bus SA 0 . . . 23 .

Power to the keyboard controller is provided by way of a 5 volt supply 5V KBD supplied to the power supply terminal VCC. The 5 volt supply 5V KBD provided by the DC to DC converter by way of an in line ferrite bead inductor . In addition to supplying power to the keyboard controller the 5 volt supply 5V KBD is used to pull up various pins by way of pull up resistors and . In order to stabilize the 5 volt power supply 5V KBD a plurality of bypass capacitors and are connected between the power supply 5V KBD and system ground.

As mentioned above the keyboard controller has various functions. One of those functions is to monitor when AC power is plugged into the machine from an AC adapter plug connected to the external power supply signal AC DCIN by way of a pair of EM filters and and a connector . In particular an AC power signal ACPWR available from an FET is applied to port pin by way of an inverter . The external power supply signal AC DCIN available from the AC plug is used to control the gate terminal of the FET normally pulled down a pull down resistor . A 5 volt supply 5V CORE is connected to the drain terminal while the source terminal is used for the AC power signal ACPWR pulled down by a pull down resistor . When an external power source is not connected to the FET the signal ACPWR will be low. Once external power is connected to the connector the signal AC DCIN from the IBP goes low which in turn turns on the FET to cause the signal ACPWR to go high.

The keyboard controller also monitors the status of the radio. As such an output from the radio TX RX LED pin is applied to pin of port of the keyboard controller by way of an inverter . When pin of port is high the keyboard controller interprets that the radio is in a transmit mode. Another signal from the radio CD LED is used to provide an indication to the keyboard controller that that radio is in a receive mode. This signal CD LED is applied to pin of port .

An 8 MHz clock signal 8 MHz5V is used to drive the keyboard controller . The clock signal 8 MHz5V is developed by the clock generator and converted to a 5 volt level by way of the translator signal level translator .

The video controller A controls the video functions. The video controller A for example a model number CL GD 6205 from Cirrus Logic can support various video modes including a mono STN and a color TFT panel with up to 640 480 with 64 shades of gray. In addition the video controller A will support 1024 by 768 resolution with 16 colors on a CRT through the aid of its on board digital to analog converter.

The video controller IA utilizes two clock sources for timing generated by an internal clock generator to produce the required frequencies for the display and memory timing. Two separate analog power supply sources AVCCMCLK and AVCCVCLK are provided to the analog power supply inputs AVCCVCLK and AVCCMCOK on the video controller A. These analog power supply sources AVCCMCLK and AVCCVCLK are derived from the 3 volt power supply 3V CORE available at the DC to DC converter . In particular the 3 volt power supply 3V CORE is used to develop a 3 volt power supply VGA VCC by way of an in line ferrite bead inductor . The power supply VGA VCC in turn is filtered by a plurality of bypass capacitors connected between the power supply VGA VCC and system ground. The 3 volt power supply VGA VCC is used to develop the analog power supplies AVCCMCLK and AVCCVCLK by way of a plurality of resistors and as well as a plurality of by pass capacitors to connected to an analog ground AGND. The analog ground AGND is tied to the digital ground GND by way of a ferrite bead conductor .

The keyboard controller also provides various miscellaneous system functions by way of its I O ports and . Five port bits P. P. of port are used for system control. Bit is used to generate a signal KBC P an active high signal which disables the general purpose chip select signals GPCS and GPCS available at the system controller during boot up until the signals GPCS and GPCS are properly configured. As discussed above the general purpose chip select signals GPCS and GPCS are used for selecting the pen controller A the radio interface B and the UART . Bit P. is used to generate a contrast signal CONTRAST normally pulled low down by a pull down resistor for contrast control of the LCD as discussed above. Briefly the contrast signal CONTRAST is used to step the 24 volt supply . Bit P. is used to generate a keyboard shutdown signal KBSHUTDOWN. This signal KBSHUTDOWN discussed below is active low and in conjunction a pen shutdown signal PEN SHUTDOWN available at the pen controller A is used to generate a shutdown signal SHUTDOWN to shutdown the AC to DC converter during low power conditions. More particularly the keyboard shutdown signal KBSHUTDOWN pulled up by a pull up resistor and the pen shutdown signal PEN SHUTDOWN pulled low by a pull down resistor are diode ORed by a pair of diodes and . The cathodes of the diodes and are joined to form the active low shutdown signal SHUTDOWN. If the keyboard shutdown signal KBSHUTDOWN is asserted the shutdown signal SHUTDOWN will be forced low which in turn is used to disable the DC to DC converter . Bit P. is used to generate a signal FLASHVPP to enable the flash memory devices to be programmed. In particular when the signal FLASHVPP is low the flash memory devices can be programmed. Bit P. is used to generate a signal KBC PO. The signal KBC PO is an active high signal and is used to indicate to the system controller that a low battery condition has occurred. Bit P. is used for speaker control as discussed above. The pen P. is used to generate the speaker disable signal SPKRDISABLE an active high signal.

Port bits P. P. P. and P. of the keyboard controller are used for system functions. Bit P. is configured as an input and is used to indicate to the keyboard controller that the system is in a test mode. As discussed above the test mode signal TEST MODE is used to enable the flash memory device to be programmed. In particular as discussed above the test mode signal TEST MODE is used to generate a decode signal FLIP SA for decoding of the flash memory device . Port bits P. P. and P. are used for LCD control. In particular the pen P. may be used for LCD status control. the pens P. and P. are used for brightness control of the LCD as discussed above.

Port bits P. P. P. P. P. and P. are configured as inputs. As discussed above a signal ACPWR available from the source of the FET is applied to the pin P.. This signal ACPWR notifies the keyboard controller that an external power source is connected to the system. The signal CD LED is applied to the pin P.. This signal CD LED available from the radio interface indicates that the radio is receiving a signal. A signal TX RX LED also available from the radio interface is applied to the pin P.. This signal TX RX LED indicates that the radio is in a transmit mode. A signal DOCKACK may be applied to the pin P.. This signal may be used to indicate to the keyboard controller that a device is docked to the UART . The development of the signal DOCKACK does not form a part of the present invention. A second test mode signal TEST MODE2 may be applied to the pin P. for added functions. A signal PC P is applied to the pen P.. This signal PC P is available from the system controller and indicates that the system is in a sleep state as discussed above.

The video controller A is connected to the system database SD 0 . . . 15 as well as the system address bus SA 0 . . . 23 and is adapted to support the video memory B of either 256K by 16 bit or 256K by 4 bit video memory chips or . These video memory chips and for example 256K by 16 dram memory chips as manufactured by Toshiba Model No. NE4244170 70 are connected to a 16 bit video memory databus VMDATA 0 . . . 15 and the 9 bit video memory address bus VMADR 0 . . . 8 . The video memory chips and are accessed in the range from A000H BFFFFH and are switched to allow access to a full 512 kilobyte range. The video memory chips and are provided with dual column address strobe CAS pins to allow byte selection. The video memory column address strobes LCAS and UCAS are under the control of the high and low video memory column address strobe low and high signals VMCASL and VMCASH which are applied to the LCAS and UCAS pins by way of a pair of current limiting resistors and to generate the buffered CAS the lower and high CAS signals VMCISLBUF and VMCASHBUF. The row address strobe signal VMRAS from the video controller A as well as the write enable signal VMWE are also applied to the video memory and by way of current limiting resistors and respectively. The output enable pin on the video memory chips and is under the control of a video memory operate enable signal VMOE. This video memory operate enable signal VMOE is generated by the video controller and is applied directly to the video memory chip and .

Various power supply signals VGA VCC LCD VCC VGABUS VCC and VMEM VCC are applied to the video controller A. The power supply VMEM VCC is applied to the VMEM VCC pins on the video controller A and is also used as the power supply for the video memory chips and . The video memory power supply VMEM VCC may be supplied as either a 3 volt or 5 volt power supply. More particularly both a 3 volt and 5 volt power supply 3V CORE and 5V CORE. Depending on whether 3 volt or 5 volt operation is selected only one of the component positions illustrated as ferrite bead inductors or will be populated to produce the power supply VMEM VCC.

As will be discussed in more detail below the system also includes an LCD controller to control the LCD screen C. The power supply for the LCD controller LCD VCC can likewise be supplied as either three volt or five volt by way of the 3 and 5 volt power supply voltages 3V CORE and 5V CORE available at the DC to DC converter . Depending on the voltage selected only one of the component locations and will be populated to provide the LCD power supply voltage LCD VCC. In addition a power supply voltage VGABUS VCC is used for the VGA bus. This power supply voltage VGABUS VCC is generated by the DC to DC converter by way of a ferrite bead inductor .

In order to filter noise out of the power supply signals various bypass capacitors are connected between the power supply signals and system ground. For example a plurality bypass capacitors are coupled between the power supply signal VMEM VCC and the system ground. Similarly a pair of bypass capacitors and are connected between the power supply signal LCD VCC and the system ground. Lastly a plurality of bypass capacitors to is connected between the power supply signal VGABUS VCC and the system ground.

Additional filtering is provided for the analog subsystem. In particular a filter consisting of a pair of capacitors and and a resistor is connected to a filter terminal VFILTER and analog ground AGND. Similarly another pair of capacitors and and a resistor are connected between a signal MFILTER and analog ground AGND.

The video controller A requires two separate clock signals 14 MHz and 32 KHz. The 14 MHz clock signal is used for most timing including the LCD panel memory and the bus cycle while the 32 KHz clock signal is used for video memory refreshing when the system is suspended. These clock signals are supplied by the clock generator by way of the signal level translator . More particularly 32 KHz and 14 MHz clock signals 32 KHz and 14 MHz from the clock generator respectively are applied to the signal level translator to transform these respective signals into 5 volt signals 32 KHz5V an 14 MHz5V to provide a suitable clock signal voltage for the video controller A.

RGB data from the video controller A is supplied to the LCD screen C by way of a data bus PDATA 0 . . . 17 . This data bus PDATA 0 . . . 17 is applied to a plurality of current limiting resistors respectively to generate the buffer signals PDBUF 0 . . . 17 . These buffer signals PDBUF 0 . . . 17 are connected to the LCD panel along with various control signals by way of a pair of connectors and .

The BIOS as well as other data is stored in flash memory for example 512K by 8 bit memory devices . These flash memory devices are connected to the local ISA bus by way of the system address bus SA 0 . . . 23 and the system data bus SD 0 . . . 15 . The chip enable pins CE of the flash memory devices are selected by a decoder circuit as will be discussed in more detail below. The output enable pins OE on the flash memory devices are under the control of a memory read signal MEMR. The memory read signal MEMR is under the control of the system controller . The write enable pins WE which are active low are under the control of a memory right gate signal MEMWGATE. This signal MEMWGATE is only enabled when the flash memory devices are being programmed. As discussed above programming of the flash memory devices is under the control of a flash program signal FLASHVPP available at port . of the keyboard controller . This programming signal FLASHVPP normally pulled high by a pull up resistor is ORed with a memory write signal MEMW by way of an OR gate to generate a signal MEMGATE an active low signal.

The power supply for the flash memory devices is developed by a 5 volt power supply signal 5V ROM. The 5 volt power supply signal 5V ROM is available from the DC converter by way of a ferrite bead inductor . This power supply signal 5V ROM is also connected to a plurality of by pass capacitors for stabilization.

Decoding of the flash memory devices is provided by the circuitry that includes the buffers the inverters and and OR and a 3 to 8 bit multiplexer Model No. 74HCT138 for example as manufactured by Motorola and a pair of resistors and . In particular the system address bits SA 19 . . . 21 are applied to a 3 to 8 bit multiplexer . The system address bit SA is applied to the inverter to develop a FLIP SA signal that is pulled down by the pull down resistor . During a normal boot up the FLIP SA signal will be same as the system address bit SA. However during a test mode boot up the FLIP SA signal will be low until a control signal available at the control signal GPIOO available at the system controller goes low in order to enable the system to boot from the BIOS in the flash memory device as will be discussed in more detail below. Once the GPIOO signal goes low the FLIP SA signal will be the same as the system address bit SA.

The multiplexer is under the control of a flash memory rewrite signal MRW. This signal MRW and the system address bit SA 23 . The flash memory read write signal MRW is under the control of an OR gate . The OR gate in turn is under the control of memory read and write signals MEMW and MER which are applied to a pair of inverters and respectively and in turn to the OR gate . The memory read MEMR and memory write MEMW signals are available from the system controller .

The output of the multiplexer is used to generate the chip select signals CS CS and CS. In order to provide the ability of the flash memory device to be addressed during a test mode the chip select signal CS is under the control of an OR gate and a plurality of inverters . During a normal mode of operation the chip select signal CS will be under the control of the multiplexer . During a normal boot up the chip select signal CS for the flash memory device will be under the control of a ROM chip select signal ROMCS available at the system controller in order to enable the system BIOS to be shadowed into the DRAM A.

In order to provide the ability of the system to update the BIOS in the flash memory device and to recover from a corruption of the BIOS data in the flash memory device a uniform asynchronous receiver transmitter UART is provided. The UART is connected to the system data bus SD 0 . . . 15 and the system address bus bits SA 0 . . . 2 . The UART is powered by the 5 volt power signal 5V CORE available at the DC to DC converter . A 1.84 MHz clock signal 1.84 MHz5V available at the signal level translator is used to drive the UART .

A serial interface consisting of a standard DB 9 connector enables external serial data to be received by the UART . The UART signals are filtered by way of a plurality of resistors and bypass capacitors and applied to an optional disaster recovery adapter an RS 232 interface connected to the rear of the DB 9 connector and permits the flash memory devices to be updated by an external source in the event of a flash disaster. The flash recovery adapter may be implemented as a DB 9 connector and is connected to the 5 volt power supply 5V CORE which in turn is connected to a plurality of bypass capacitors and . An additional four capacitors are connected to the module as shown.

The power supply for the system includes the DC to DC converter which has the ability to provide both 3 volt and 5 volt power supplies signals to the various subsystems as discussed. The DC to DC converter includes a switching power supply for example a Maxim type 786. One source of power to the DC to DC converter is the IBP for example 7.2 volts nominal as well as from an external source of AC power connected to the plug .

Input power to the DC to DC converter may be from an AC DC converter not shown connected to the plug which has a DC output voltage between 5.5 15 volts DC applied to a power supply terminal AC DCIN as well as internal batteries for example the IBP connected to the system by way of a connector . The battery supply voltage from the IBP is connected to the battery positive terminal BATT . The two supplies BATT and AC DCIN are alternatively used to develop a main power signal POWER that is applied to a switching power supply for example a Maxim type 786 by way of a pair of FETS and IL. under the control of a main power switch . The main power signal POWER is applied to a drain input D on each of the FETS and . A bypass capacitor is connected to the drain terminal D of the FET and system ground. The source terminals S of each of the FETS and is connected to the switching power supply to provide 5 and 3 volt references by way of the zener diodes and respectively. The gate terminals G and G of the FETS and are under the control of the switching power supply .

The switching power supply provides both a 3 volt and 5 volt output voltages 3V CORE and 5V CORE by way of filters which include a plurality of resistors and a plurality of inductors and and a plurality of capacitors as well as a capacitor . For proper operation the D and D terminals on the switching power supply are connected to the system ground along with the ground pins PGND and GND. The SS and SS pins are connected to system ground by way of a pair of capacitors and .

The frequency of the switching power supply is under the control of a pair resistors and and a capacitor connected to the SYNC and reference terminals on the switching power supply . A HOOK VCC signal is applied to the VH and VL pins of the switching power supply . This signal HOOK VCC is available from the module discussed above. The signal HOOK VCC signal is connected to the switching power supply by way of a resistor a plurality of capacitors and and an FET .

As mentioned above both the pen controller A and keyboard controller are used to develop a shutdown signal SHUTDOWN. The shutdown signal SHUTDOWN is pulled low by a pull down resistor and applied to an active low shutdown pen SHDN on the switching power supply . The shutdown signal SHUTDOWN is indicative of a shutdown by the keyboard controller .

As mentioned above one source of power for the system is the IBP which accounts for temperature and discharge rates and sends it to the keyboard controller . Two predefined levels are set in the IBP to indicate low battery and critical battery. The IBP will inform the keyboard controller of a low battery when there is approximately five minutes left. When the battery charge is between 5 minutes to 2 minutes the IBP will report a battery critical condition. Within the final thirty seconds the IBP will force an immediate shutdown. The IBP will report the battery status approximately once every 2.5 seconds. If the system is changing to a power savings mode a command will be sent to the IBP to put the IBP into a power saving state. The IBP will tri state its communication lines and discontinue reporting battery status to the system.

A charge control signal CHGCTRL from the IBP is used to control charging. Referring to the charge control signal CHGCTRL is applied to a zener diode for example a 5.1V zener diode. The zener diode controls whether the IBP is fast charged or trickle charged as a function of the magnitude of the charge control signal CHGCTRL.

In particular if the magnitude of the charge control signal CHGCRL is less than the zener breakdown voltage i.e. less than 5.1 volts the IBP is trickle charged by way of series pass transistor a pair of resistors and from the external power signal POWER by way of a diode a fuse and a filter consisting of an inductor and a capacitor .

Should the charge control signal CHGCTRL be greater than the zener breakdown voltage of the zener diode the IBP will be fast charged by way of an FET whose source terminal is connected to the AC DC converter by way of the diode and drain terminal connected to the battery positive terminal BATT by way of the fuse and the inductor .

The series pass transistor that controls trickle charging is under the control of an FET . The drain terminal of the FET is connected to the system ground while the source terminal is connected to the base terminal of the PNP series pass transistor . Normally the series pass transistor is turned off with its base terminal being high by way of its connection to a pair of biasing resistors and which in turn are connected to the main power signal POWER by way of the diode . When the charge control signal CHGCTRL is less than the breakdown voltage of the zener diode the charge control signal CHGCTRL turns on the FET by way of the biasing resistors and a coupling capacitor connected to its gate terminal. Once the FET is turned on it turns on the series pass transistor to provide a charging path between the main power signal POWER and the battery positive terminal BATT.

As mentioned above fast charging of the battery is under the control of the FET . The FET in turn is under the control of a PNP transistor . The PNP transistor which includes a pair of biasing resistors and is connected to the collector terminal of an NPN transistor . The base of the NPN transistor is connected to a pair of biasing resistors and and in turn to a collector terminal of another NPN transistor and the main power signal POWER. The NPN transistor is biased by way of a pair of biasing resistors and and in turn to the anode of the zener diode .

In operation when the charge control signal CHGCTRL exceeds the breakdown voltage of the zener diode the zener diode conducts thereby biasing the NPN transistors and turning them ON. Once the NPN transistor is turned ON the base terminal of the PNP transistor is connected to ground thereby turning the PNP transistor ON. The PNP transistor in turn connects the main power signals POWER to the gate terminal of the FET by way of the diode thereby turning the FET ON to enable the battery positive terminal BATT to be fast charged from the AC to DC converter.

As mentioned above the wireless interface device includes a radio system which allows for wireless interfacing with a host computer and also wireless interfacing to both a wired local area network LAN and a wireless LAN. The radio subsystem has been discussed above. It is implemented by way of an interface implemented by way of a 25 2 header which connects the radio subsystem to the balance of the circuitry in the wireless interface device . In particular the system data bus SD 0 . . . 15 as well as the system address bus bits SA 0 . . . 2 are connected to the interface . The radio interface is under the control of the system controller such as I O write IOW I O read IOR and an address enable signal AEN .

Output signals from the radio interface include the signals CD LED TX RX LED IRQ and IOCS. As discussed above the signal CD LED indicates a connection has been made with a host computer . The signal TX RX LED indicates that a signal is either being sent or received through the radio interface . As mentioned above the peripheral controller is responsible for interrupt control. Thus the radio subsystem interrupt IRQ is applied to the peripheral controller . Power supply for the radio interface is by way of a 5 volt power supply signal 5V CORE available at the DC to DC converter which is filtered by a pair of bypass capacitors and .

The interrupts for both the radio interface IRQ as well as the UART IRQ are formed into a common signal IRQ and applied to the system controller by way of a resistor . In particular the radio interface interrupt signal IRQ is applied to an inverter whose output is ORed by way of the OR gate with the UART interrupt signal IRQ. The output of the OR gate forms the combined interrupt signal IRQ .

The radio interface as well as the UART are selected by the chip select signals RADIOCS and URTCS. These signals are available at the output of a pair of the OR gates and respectively. The system address bit SA is inverted by way of an inverter and ORed with a general purpose chip select gate signal GPCSGATE by way of the OR gate to generate the UART chip select signal UARTCS. The system address bit SA is applied directly to the OR gate and ORed with the general purpose chip select gate signal GPCSGATE to generate the radio chip select signal RADIOCS. The general purpose chip select signal gate signal GPCSGATE is available at the output of an OR gate . In particular a general purpose chip select signal GPCS available from the system controller is ORed with an output from pin of port of the keyboard controller to cause the radio interface to be addressed at addressed 3E0 3E7 and the UART to be addressed at address 3EA 3EF. The signal KBC P is normally pulled up to the 5 volt power supply voltage 5V CORE by way of a pull up resistor .

The pen controller A is illustrated in and is adapted to cooperate with an analog resistive type digitizer . The pen controller A includes a controller for example a Motorola type MC68HC705J2 microcontroller with the firmware being programmed within the part. The controller communicates with the system by way of the system data bus SD 0 . . . 15 . In particular serial data from a port PB on the controller is applied to a shift register which in turn is connected to an 8 bit parallel buffer which in turn is connected to the serial data bus SD 0 . . . 15 . The controller is adapted to be used with an analog resistive touch screen digitizer for example a drawing No. 8313 34 Rev. C4 as manufactured by Dynapro. XY information from the digitizer is received by the controller by way of a connector . The X and Y information from the digitizer is connected to a 12 bit analog to digital A D converter and also applied to port PAS of the microcontroller . In particular the X data from the digitizer is applied to the Al terminal of the A D converter by way of a pull up resistor and an FET . The FET is under the control of a charge pump for example a Linear Technology Model No. LTC1157C58. The Y data from the digitizer is applied to the terminal Al of the A D converter by way of a current limiting resistor . A pair of bypass capacitors and are tied between the terminals AO and Al of the A D converter and an analog ground PEN AGND. The X Y X Y inputs from the digitizer are also applied to the controller ports PA 0 . . . 4 by way of a plurality of transistors and a plurality of resistors and an inductor and a plurality of capacitors and . The transistor as well as the transistors and are used to prevent leakage in a suspend state.

Power from both analog and digital power supply and grounds are supplied to the system. In particular a 5 volt digital power supply PEN VCC developed from the 5 volt supply 5V CORE is available from the DC to DC converter by way of an in line ferrite bead inductor . An analog power supply PEN AVCC is developed from the digital supply PEN VCC by way of an in line ferrite bead inductor . The digital power supply PEN VCC is applied to the microcontroller and filtered by a bypass capacitor . The analog supply PEN AVC is utilized by the 12 bit analog to digital converter and filtered by way of a bypass capacitor .

A separate clock supply is used for the microcontroller . This clock supply includes a 4.0 MHz crystal a resistor and a pair of parallel coupled capacitors and . The clock supply is applied to the oscillator terminals OSC and OSC of the microcontroller .

A 5 volt signal PENACT5V available at the port P5V pin of the microcontroller is converted to a 3 volt signal PENACT3V by way of a pair of voltage dividing resistors and . This signal PENACT3V is applied to a 3 volt terminal of the system controller . As discussed above the power supply for the FETs and is provided by the charge pump . The power supply for the charge pump is a 5 volt power supply signal 5V CORE available at the DC to DC converter . A ground terminal of the charge pump is connected to system ground by way of a pull down resistor . The 5 volt power supply PEN VCC is also utilized by the shift register and the data buffer and buffered by way of a pair of bypass capacitors and .

The chip select signal PENCS for the data buffer is generated by an OR gate . The general purpose chip select signal GPCS is available from the system controller as well as a signal KBC P available from the keyboard controller are applied to the inputs of the OR gate .

A pen shut down signal PEN SHUTDOWN is used to develop a shut down signal SHUTDOWN as discussed above for turning on the switching power supply . The pen shutdown signal PEN SHUTDOWN is developed by the circuit that includes the transistors and a plurality of resistors and and a capacitor . In particular a 5 volt power supply signal 5V CORE is applied to a pair of voltage dividing resistors and which in turn is used to bias the transistor on. The base emitter voltage is held fairly constant by the capacitor . Once the transistor is turned on it is used to control the FET . A main power supply signal POWER is applied to the gate of the FET by way of the resistor . Wake up of the system by way of the pen subsystem is discussed below.

As mentioned above the wireless interface device includes the flash memory devices . As will be discussed in more detail below the flash memory devices enable user software upgrades by way of the radio interface . Should power be lost during the programming the data within the flash memory devices will be corrupted which could result in the system failing to boot.

In order to enable recovery from such a condition recovery BIOS is stored in a protected sector of the flash memory device which will be unaffected during reprogramming. In addition a serial port interface is provided to enable the flash memory devices to be programmed in such a condition by an alternative wired source following a normal boot up. Unfortunately the configuration of the flash memory device may result in the system failing to boot. More particularly disaster recovery BIOS is not stored at the uppermost address of the flash memory device . Each flash memory device are 512K 8 bit devices. With reference to Table 5 above the flash memory device is mapped to the address range 0C0000 0FFFFF. The recovery BIOS is contained in the lower half of that range i.e. 0E0000 0FFFF .

On a normal boot up the system begins executing code at the top of the address range i.e. 000000 ODFFFF flash memory device by way of the system address bit SA. More particularly on a normal boot up a test mode signal TEST MODE available at port . of the keyboard controller is pulled high by the keyboard controller during boot up which enables the buffer which in turn enables another buffer to enable the system address bit SA during boot up. When the system address bit SA is enabled the system begins executing code at the top of the address range 000000 of the flash memory device . However during a condition when the data in the top half of the address range 0C00000 0DFFFFF becomes corrupt as a result of a problem occurring during reprogramming the system may not boot during such a condition.

In order to solve this problem the system address bit SA is forced low. By forcing the system address bit SA low the system will begin executing code from the protected area of the flash device in the address range 0E0000 0FFFF during such a condition where the disaster recovery BIOS resides in a protected sector. In particular the system address bit SA is applied to the buffer which is under the control of the test mode signal TEST MODE by way of the buffer . The output of the buffer is a signal FLIP SA which is applied to the address pin A on the flash memory device .

During a normal boot up the test mode signal TEST MODE will enable the buffer and in turn the buffer to cause the system address bit SA to drive the signal FLIP SA. During a condition when the code in the flash memory device becomes corrupt the test mode signal TEST MODE is forced low which in turn forces the signal FLIP SA low resulting in the system executing code from the protected area i.e. 0E0000 OFFFF of the flash memory device during such a condition to enable the flash memory device to be reprogrammed by way of the serial interface .

There are various ways in which to force the test mode signal TEST MODE low during reprogramming of the flash memory device by way of the serial interface . One way is to externally ground the test mode signal TEST MODE during such a condition. In particular the test mode signal TEST MODE may be connected to one pin of a two pin header . The other pin of the header is connected to system ground. During reprogramming of the flash memory device an external jumper not shown is inserted into the header to shunt the test mode signal TEST MODE to system ground to enable the system to execute code from the protected or boot block area of the flash memory device in order to enable the system to be booted. Once the system is booted the flash memory device is reprogrammed by way of the serial interface . Once reprogramming is complete the shunt is removed from the header and the adapter plug is removed restoring the system to normal operation.

In order to conserve battery power the wireless interface device goes into a suspend mode when the system is not in use. As discussed above a shut down signal SHUTDOWN is used to shut down the power supply during such a condition which essentially disables the power to all but the circuitry required to detect a pen down event by way of the main power signal POWER .

Three sources control the shut down signal SHUTDOWN the keyboard controller the pen controller A and a signal HOOK VCC connected to the switching power supply by way of the FET . These sources are diode ORed to the shut down signal SHUTDOWN by way of the diodes and and a diode . During a normal state the shut down signal SHUTDOWN is high which enables the power supply . When the shut down signal SHUTDOWN goes low the power supply goes into an inactive state. During the inactive state minimum power is supplied to the pen detection circuitry as discussed above.

As will be discussed in more detail below once the system is turned on by the main power switch the shut down signal SHUTDOWN will be under the control of the pen shutdown signal PEN SHUTDOWN available from the pen controller A and the keyboard controller shut down signal KBSHUTDOWN .

The keyboard controller can place the system in a suspend state by way of a command which in turn causes the keyboard controller shut down signal KBSHUTDOWN available at port P. to go low. More particularly during normal operation only the keyboard shutdown signal KBSHUTDOWN is high placing control of the suspend state solely in the keyboard controller . The keyboard controller can then force the system into a suspend state by forcing port P. low which in turn places the power supply in an inactive state.

The pen shut down control signal PEN SHUTDOWN is used to wake the system from a suspend state. More particularly as mentioned above during a suspend state power from the main power supply POWER is applied to the collector of the transistor and to the drain of the FET . Since the 5 volt power supply 5V CORE is unavailable during a suspend state the transistor will be OFF allowing power to appear at the gate of the FET thus turning the FET N. Once the FET is turned ON the main power signal POWER is applied to the XPLUS terminal of the digitizer panel. Thus a pen or finger down event will result in the YPLUS terminal being connected to the XPLUS terminal by way of a finite resistance i.e. 500 1500 Ohms to apply power to the YPLUS terminal which in turn is connected to the drain of the P channel FET while its source is used as the pen shutdown signal PEN SHUTDOWN. The FET is under the control of a leakage signal LEAKAGE available at the output of the charge pump . Since the leakage signal LEAKAGE will be low during a suspend state the FET will turn on in response to the pen down event thereby connecting the YPLUS terminal to the pen shut down signal PEN SHUTDOWN. As mentioned above the YPLUS terminal will be high in response to a pen down event following a suspend state. As such the pen shut down signal PEN SHUTDOWN will go high. Since the pen shut down signal PEN SHUTDOWN is diode ORed with the shut down signal SHUTDOWN the shut down signal SHUTDOWN will thus be forced high in response to a pen down event following a suspend state which in turn will wake up the power supply . Once the system is wakened the keyboard controller shutdown line KB SHUTDOWN goes high latching the system ON. The resistors and the capacitor are used to delay turning ON the transistor and the turning OFF of the FET before the keyboard shutdown signal KB SHUTDOWN is pulled high which would cause the pen shut down signal PEN SHUTDOWN to go low before the keyboard shutdown signal KB SHUTDOWN goes high.

The FETs and are used to prevent current leakage in a suspend state. In particular these FETs and are under the control of the leakage control signal LEAKAGE available at the charge pump which turns the FETs and N in normal operate and OFF in a suspend state.

The sensing of suspend state is done by the charge pump which monitors the 5 volt power supply signal 5V CORE. When the 5 volt power supply signal 5V CORE goes low indicating a suspend state the leakage control signal LEAKAGE goes high turning off the FETs and blocking leakage into the pen circuitry from the XPLUS terminal.

The system ON OFF switch enables the system to be completely shut off. When the switch is closed power from either the IBP or the external AC to DC converter supplies power to the system. In order to wake up the system from an OFF state a shutdown line SHUTDOWN must be held high until the keyboard controller pulls its shutdown pin KB SHUTDOWN high. As discussed above the keyboard shutdown signal KB SHUTDOWN is diode ORed relative to the shutdown signal SHUTDOWN which controls the power supply . Until the time when the keyboard shutdown signal KB SHUTDOWN is pulled high a signal HOOK VCC is used to force the shut down signal SHUTDOWN high. As mentioned above the HOOK VCC signal is also diode ORed relative to the shutdown signal SHUTDOWN by way of the diode . However for proper operation of the system the shutdown signal SHUTDOWN will be under the control of the keyboard controller after the system is turned on. Thus a 5 volt power supply signal HOOK VCC available at the power supply forces the shut down signal SHUTDOWN high until the keyboard controller has time to pull its keyboard shutdown signal KB SHUTDOWN high. The 5 volt power supply signal HOOK VCC is always high when the main power switch is turned on. On power up the 5 volt power supply signal HOOK VCC forces the shutdown signal SHUTDOWN high by way of an FET and the diode which in turn wakes up the power supply . Once the power supply is enabled a power supply signal MAX  VCC is used to turn off the FET to place the control of the shut down signal SHUTDOWN under the control of the keyboard controller as discussed above. In order to provide sufficient time for the keyboard controller to pull its keyboard shutdown signal KB SHUTDOWN high the turn OFF of the FET is delayed by way of a resistor and a capacitor . In particular once the main power switch is closed the power supply signal MAX VCC will be low thereby causing the FET to be turned ON which connects the power supply signal HOOK VCC to the shutdown signal SHUTDOWN by way of the diode . Once the power supply is enabled the signal MAX VCC applied to the gate of the FET turns off the FET placing the shutdown signal SHUTDOWN under the control of the keyboard controller shutdown signal KB SHUTDOWN as discussed above. The resistor and capacitor delay the turning off of the FET after the signal MAX VCC goes high for a sufficient time to allow the keyboard controller to pull its keyboard shut down signal KB SHUTDOWN high.

An inhibit circuit which includes a plurality of resistors a diode a transistor and an FET is used to prevent the system from being turned ON during low battery conditions when the system is being supplied solely by the IBP . During a normal condition i.e when the system is being supplied power by the AC DC converter or by the battery the signal MAX VCC is connected to the main power signal POWER by way of the FET . The FET is under the control of the transistor . During conditions when the AC DC converter is supplying power to the system a signal AC DCIN will be high thereby turning ON the transistor which in turn turns ON the FET connecting the main power signal POWER to the signal MAX VCC. The collector of the transistor in turn controls the FET which connects the power supply signal HOOK VCC to the enable terminals ON and ON on the power supply . When AC power is not available the AC DCIN goes low leaving the control of the transistor under the control of an inhibit signal INHIBIT available from the IBP by way of the connector . During a normal battery condition the inhibit signal is high keeping the transistor turned ON thereby enabling the power supply by way of the FET . Should a low battery condition occur the inhibit signal goes low turning OFF the transistors as well as the FET to prevent the system from being turned ON.

As mentioned above the wireless interface device includes a digitizer B and utilizes a passive pen as an input device. illustrate a method for emulating the functions of a mouse for example a two button mouse to provide standard mouse functions with the passive pen.

There are three aspects of the mouse emulation. One aspect relates to emulation of a double click of a mouse button required by some application programs. Another aspect relates to emulating both the left and right buttons of a two button mouse. The third aspect relates to emulating both the movement of the mouse MOVE MODE and the clicking of a mouse button TOUCH MODE with a passive pen as an input device.

Referring first to the mouse emulation system is event driven by the passive pen. Initially the system checks to see if the passive pen has touched anywhere on the LCD C which includes a display area and a hot icon area . If a pen down event has been detected the system checks in step if the wireless interface device has been placed in a calibration mode. If so a calibration handler is called in step . The calibration handler does not form part of the present invention. If the wireless interface device is not in the calibration mode the system then checks to determine if the pen has been lifted from the LCD C in step . If a pen up event occurs subsequent to a pen down event control is passed to a hot icon identification ID processor in step which as will be discussed below processes the pen position to determine which of the hot icons in the hot icon area of the LCD screen C was selected. If the pen was not lifted from the LCD C the system checks in step if the previous event in a previous cycle was a pen up event. If the previous pen event in the previous cycle was a pen down event the current pen event is processed by a mouse mode handler in step which as will be discussed in more detail below determines if the pen is being used in a mouse MOVE or mouse TOUCH MODE. In step the coordinates of the current pen down event are processed to determine if the current pen down event occurred in the hot icon area of the LCD C. If the pen down event occurred in the hot icon area a flag is turned on indicating the hot icon area was selected in step . If the system determines the current pen down event occurred in the display area of the LCD screen C an audio click is generated in step different from the hot icon audio click.

Steps are driven by each pen event in order to determine the location of the pen down event i.e. hot icon area or display area . Once the system determines where the pen event occurred the pen data is converted to mouse data in step and a cursor is displayed in the viewing area corresponding to the location of the pen touch in step . After the cursor is displayed the system determines in step whether the mouse data is to be used locally by the wireless interface device for local applications or the application running on the host computer . As mentioned above the wireless interface device through its graphical user interface provides a virtual or on screen keyboard OSK . Thus if the OSK has been activated and the pen event occurs in the OSK area the mouse data is used locally by the wireless interface device in step . If the wireless interface device is running a host application the mouse data is sent to the host computer application over the wireless interface as discussed above in step .

As mentioned above the system is able to emulate both left and right mouse buttons. This emulation is accomplished by way of left right mouse button hot icon . A left mouse button is configured to be the default setting. This hot icon is set up as a toggle. Thus when the system is first turned on the pen events from the mouse mode handler are translated to be left mouse button events. Anytime the left right mouse button hot icon is selected the system will toggle and translate subsequent pen events to be right mouse button events. A subsequent pen down event on the hot icon causes subsequent pen events from the mouse mode handler to be translated as left mouse button events and so on.

The hot icons in the hot icon area are triggered by a pen down event followed by a pen up event. As discussed above such a sequence of pen events is processed by hot icon ID processor illustrated in . The hot icon ID processor first determines if the pen event occurred in the viewing area of the LCD C by determining from the mouse mode handler whether the system is in the TOUCH in step since this mode only occurs for pen events in the viewing area of the LCD display C. If the system is not in a TOUCH mode the system checks in step whether the system is in the MOVE mode. If the pen event i.e. pen down followed by a pen up event did not occur in the viewing area of the LCD display C the system compares the coordinates of the pen down event with the locations of the various hot icons displayed in in step . In step the system determines if the left right mouse button hot icon was selected. If not the system proceeds directly to step to uplevel software for processing. If the system determines that the left right mouse hot icon was selected the system emulates a left or right mouse button in step depending on the last status of the left right mouse button emulation and utilizes the emulated left or right mouse button status in the uplevel software in step .

Pen events in the hot icon area of the LCD display C are handled by the hot icon ID processor while pen events in the viewing area are handled by the mouse mode handler . The mouse mode handler emulates two mouse actions moving without either button being depressed and released MOVE and button depression and release events TOUCH . As discussed above both left and right mouse button events can be emulated in the TOUCH.

As discussed above the current pen down event preceded by a pen down event activates the mouse mode handler . In step the system first determines if the hot icon flag is on. As discussed above the hot icon flag is turned on anytime a pen down event occurs in the hot icon area of the LCD display C. If the hot icon flag is not on the pen down event is translated to a mouse button down event by a mouse TOUCH handler in step . If the hot icon flag is on the system determines in step whether the coordinates of the current pen down event to determine if the current pen down event occurred in the hot icon area . If so the pen coordinate data is dropped in step since such data will be processed by the hot icon ID processor discussed above. If the current pen event occurred in the viewing area the pen coordinate data is translated to mouse move data.

A mouse button double click is emulated by two pen down events separated by a pen up event in the viewing area of the LCD C. In particular when the host computer is running a Windows application a pen driver translates the two pen down events separated by a pen up event and passes four mouse messages mouse button down mouse button release mouse button down and mouse button release to the host Windows application.

As will be discussed in more detail below the host manager Windows module modifies a Windows configuration file. WIN.INI and in particular the distance and time limitations for a mouse button double click. In particular the Windows system checks the Windows configuration file WIN.INI in order to compare the distance between the mouse locations for each of the clicks as well as the time between clicks. More particularly the Windows systems will only pass double click data to a Windows application program if the distance i.e. height and width between mouse locations for the two clicks is less than 16 for both height and width and the time between the clicks is less than 1.0 seconds.

With a pen based system two pen down events separated by a pen up event normally take longer and occur at greater distances between pen down events than allowed by the Windows system to generate a double click. Thus the host manager Windows module modifies the time and distance parameters to enable two pen down events separated by a pen up event to enable Windows to emulate a mouse double click that can be passed on to the Windows application program running in the host computer . In particular the host manager Windows module includes an initializer which loads the host manager Windows module and an initial icon displayer which displays that the host manager Windows module has been loaded. The host manager Windows module also includes a double click configuration modifier . The double click configuration modifier modifies the configuration of the Windows systems file WIN.INI by modifying the time or speed in step . The distance broken down into width and length between the successive pen down events is modified by a double click width modifier and a double click height modifier in steps and . The modified speed width and height parameters are set in the Windows system file WIN.INI running in the host computer in step to enable a mouse button double click to be emulated by two successive pen down events.

Normally the Window system file WIN.INI is in cache. The host manager Windows manager disables the in cache copy of the Windows system file WIN.INI which allows the Windows system to go to the modified configuration file with the modified parameters.

As mentioned above the wireless interface device connects to a host computer and displays whatever is being displayed on the host computer . In particular after a connection is made all of the screen images on the host computer are passed on to the LCD display C on the wireless interface device . Whenever the host computer is running a screen saver the host display will continually change passing on all of the images to the LCD C on the wireless interface which creates a lot of unnecessary traffic on the LAN. In order to reduce this unnecessary LAN traffic a host manager Windows module disables the screen saver on the host computer anytime a connection is made between the host computer and the wireless interface device . Anytime the connection between the host computer and the wireless interface device is broken the host manager Windows module re enables the screen saver on the host computer .

The connection status between the host computer and the wireless interface device is under the control of a host manager DOS module a terminate and stay resident program. The host manager DOS module is driven by a timer tick interrupt and checks the connection status at each timer tick interrupt. If the connection status has changed the host manager DOS module calls a host manager communicator which passes the new status to the host manager Windows module .

Referring to anytime the connection status between the host computer and the wireless interface device changes the host manager Windows module checks the new status in step . If the connection has been lost a screen saver disable module is called which in turn calls several Windows modules Windows Software Development kit functions SystemParametersInfo and WritePrivateProfileString to disable the screen saver. Should the current status indicate that the wireless interface device is connected to the host computer the system proceeds to step which calls the various Windows module.

Referring to anytime the host manager DOS module is loaded an initial connection status checker calls the host manager DOS module to obtain the current connection status between the wireless interface device and the host computer . Next the system checks in step whether a connection exists between the host computer and the wireless interface device . If not the system returns. If there is a connection a virtual key poster posts a virtual key V TAB into the Windows Systems queue to force the Windows program to disable the current active screen saver automatically which in essence simulates the press of a key on a keyboard. Once the current active screen saver is disabled the screen saver on off flag in a Windows configuration file is turned off in step to disable the screen saver until there is a change in the connection status.

Whenever a connection is made between wireless interface device and the host computer the user can optionally blank the screen on the host computer and disable the keyboard and mouse inputs connected to the host computer . These features prevent the host computer from being accessed while the host computer is under the control of the wireless interface device at a remote location. Once the connection between the host computer and the wireless interface device is lost the keyboard and mouse inputs on the host computer are re enabled under the control of the host manager program residing in the host computer .

There are certain situations where the screen to the host computer may not be enabled on disconnection for example when the disconnection occurs because the wireless interface device is either out of power or out of range. In order to enable the user to access the host computer in such a situation a host manager first checks whether the connection status has changed in step in the manner as discussed above. If the system is connected no action is required. However if the connection has been broken the system checks in step whether the screen is enabled. If not the user will have normal access to the host computer . If so the latest log in password by the user is stored in by the system in step . Since the host manager DOS module controls the screen the system checks in step to determine whether Windows is running in the host computer . If DOS is running the system compares the password entered on the keyboard with the latest log in password in steps and . If the password entered does not match the correct password the system returns to step and awaits another keyboard input. If the correct password is entered the screen is turned on in step .

Should the host computer be running Windows as determined in step the latest log in password is passed to a host manager Windows module in step . The system next checks in steps and whether the correct password was entered in a similar manner as discussed above. If so since DOS handles the enabling of the screen on the host computer the host manager DOS module is notified that the correct password was entered in step which in turn enables the screen in step .

The pen controller A normally generates a series of interrupts and in turn a series of pen packets whenever the pen touches the LCD C a pen down event and is lifted from the LCD C a pen up event and generates an interrupt. For each interrupt a single packet is generated. The format of the possible packets is illustrated in Table 7 below where x0 is bit of the x coordinate of the pen location and y0 is bit of the y coordinate of the pen location etc.

The packets are generated in the following sequence p1 p2 p3 p4 p1 p2 p3 p4 p1 p2 p3 p4 p5 . The packets p1 p2 p3 p4 relate to pen down events a pen point each group of packets p1 p3 p3 p4 relating to one x y coordinate of the pen. The packet p5 relates to a pen up event. Thus anytime the pen is lifted from the digitizer one packet p5 is generated. Thus when the pen first touches the digitizer panel and is moved across the digitizer a plurality of pen points p1 p2 p3 p4 are generated which correspond to the x y locations of the points touched by the pen. Normally pen points per second are generated by the pen controller A.

Whenever a 12 bit serial pen packet is generated by the pen controller A and read by a firmware module in step an interrupt is generated in step . A pen packet assembler assembles the packets into pen points p1 p2 p3 p4 . These pen points p1 p2 p3 p4 are processed and passed to the applications program. In order to process each pen point p1 p2 p3 p4 the interrupts must be disabled. During the time when the interrupts are disabled the pen point packets p1 p2 p3 p4 and the pen up packets p5 are generated by the pen controller A but not processed and thus are garbled or lost. Lost or garbled pen point packets p1 p2 p3 p4 do not affect mouse emulation. However since mouse emulation is based on both pen down and pen up events lost pen up packets p5 can result in the mouse emulation being hampered possibly resulting in the system being stuck in the state preceding the pen up event.

In order to solve this problem a firmware module generates two pen up packets p5. More particularly with reference to the firmware module reads in the 12 bit serial data from the pen controller A into packets in step . Next the system checks in step whether the packet was a pen up packet p5. If not the system proceeds to the pen driver in step . If the packet is a pen up packet p5 the system checks to determine if the pen up packet p5 is the first pen up packet in step . If not the system passes the packet to the pen driver in step as discussed above. If the system determines in step that the pen up packet p5 is the first pen up packet p5 the serial data for second pen up packet p5 is generated in step and assembled in step . In addition the first pen up packet p5 is passed to the pen driver.

The pen driver is responsive to an interrupt that is generated each time a packet is assembled. In response to an interrupt the pen driver reads the packet in step . In step the pen driver determines whether the packet is a pen up packet p5. If not the pen packet assembler processes the packet in step . If the system determines in step that the packet is a pen up packet it next checks in step whether the packet is the second pen up packet. If so indicating that the first pen up packet was processed the second pen up packet is dropped in step . If not the packet is determined to be a first pen packet which is processed by the pen packet assembler in step .

The wireless interface device may be connected to host computer by way of a wireless LAN. The wireless LAN protocol is Novell open data link interface IPXODI protocol. Since the IPXODI protocol is also used for wired LAN s it would be desirable to connect the wireless interface device to a wired LAN system and utilize the Novell IPXODI protocol. Unfortunately the IPXODI protocol can only communicate with a single LAN card at a time either a wired LAN card or a wireless LAN card at one time.

The standard Novell LAN stack configuration is illustrated in . The LAN card is identified with the reference numeral . Communication between the LAN card and the IPXODI protocol is by way of a driver . The driver communicates with the IPXODI protocol IPXODI.COM by way of a link support layer LSL.COM . The Novell IPXODI protocol passes data between the applications programs and the link support layer LSL.COM . Even though the link support layer LSL.COM can support multiple LAN cards the IPXODI protocol only supports a single LAN card.

In order to enable the Novell IPXODI protocol to support a configuration as illustrated in to enable the wireless interface device to connect to both a wired LAN card and a wireless LAN card an additional layer IPXMUX.COM is provided for multiplexing incoming and outgoing packets to and from the wired LAN card and the wireless LAN card . The multiplexer IPXMUX.COM manipulates the data packet source and destination addresses to simulate a single LAN card so as to be compatible with the IPXODI protocol. By providing the additional layer IPXMUX.COM the host computer as well as the wireless interface device will be able to access all of the LAN resources .

Referring to the additional layer IPXMUX.COM is stacked between the Novell IPXODI protocol IPXODI.COM and the link support layer LSL.COM . As mentioned above the link support layer LSL.COM can support two LAN cards. Thus a wireless LAN card and a corresponding wireless LAN card driver which communicates with the link support layer LSL.COM along with the wired LAN card and its corresponding driver can communicate with IPXODI.COM by way of the driver.

The multiplexer IPXMUX.COM multiplexes or interleaves the data from both the wireless LAN card driver and the wired LAN card driver to the IPXODI protocol by manipulating the source and destination addresses of incoming and outgoing packets so that as far as the Novell IPXODI protocol is concerned it is only communicating with a single LAN card. Similarly communication from the host computer as well as applications which may be running on the wireless interface device to both the wired LAN card and the wireless LAN card is formatted by the IPXODI.COM and multiplexed to either the wireless LAN card or wired LAN card by the multiplexer IPXMUX.COM by way of the link support layer. The multiplexer IPXMUX.COM is loaded after the wired LAN card driver and the wireless LAN card driver are loaded and before IPXODI.COM .

The Novell LAN software includes a configuration file which checks the particular LAN cards being run by the LAN card driver . The system is initialized by the routine illustrated in which is run each time the multiplexer IPXMUX.COM is loaded. Initially a command line parser is used to determine whether the user has issued commands to either load or unload IPXMUX.COM command in step . If the command is an unload command the system checks whether IPXMUX.COM has already been loaded in step . If so the system unloads IPXMUX.COM in step . If IPXMUX.COM has not been loaded the system exits the initialization routine.

If the command was to load IPXMUX the system checks in step to determine if the link support layer LSL.COM has been loaded. If not the system exits the initialization routine since IPXMUX.COM cannot be loaded until the link support layer LSL.COM has been loaded. If the link support layer LSL.COM was loaded control is passed to a LAN configuration browser in step to browse the LAN configuration for the number of LAN cards and the frame types of the cards and the number of frame types i.e. IEEE 802.2 802.3 etc. to find out which LAN card drivers are running. In addition the browser finds and saves all relevant application program interface entry points to the link support layer LSL.COM and sets to those supported by IPXMUX.COM. The browser also sets the LSL interrupt vector to the interrupt vector supported by IPXMUX.COM as well as finds and saves all logical board numbers.

In order to interleave the data from the wired LAN card and the wireless LAN card to IPXODI.COM to emulate a single LAN card 2F interrupt calls from the application program by way of IPXODI.COM are trapped and handled by a separate routine. In particular 2F interrupt calls are checked in step to determine if such calls are interrupt calls to LSL.COM. If not the system exits. If so the address of the LSL protocol support API handler supported by IPXMUX.COM is returned. Interrupt calls to LSL.COM from an application program are handled by a special interrupt handler. If the interrupt call is to LSL.COM a LSL initialization entry point supported by IPXMUX.COM is returned in step . The LSL initialization entry point represents an address of the protocol initialization routine into LSL.COM.

Once the address of the LSL initialization entry point is known by the IPXODI protocol the IPXODI protocol will call that address for service. Thus all LSL service calls are checked in step to determine if the call is a request for protocol support API entry point. If not the multiplexer IPXMUX.COM will direct that call into LSL.COM. If so an address of a special 2F interrupt handler LSL Protocol Support API Handler supported by IPXMUX.COM is returned to IPXODI.COM in step .

The special interrupt handler LSL Protocol Support API Handler which forms a part of IPXMUX.COM is illustrated in . Three services are handled by the LSL Protocol Support Handler which is supported by the multiplexer IPXMUX.COM to set up an address for communication with a host on the network. These services are register protocol stack bind stack and send a packet. The balance of the services are handled by LSL.COM.

The entry point of the LSL Protocol Support API Handler in IPMMUX.COM from the standpoint of IPXODI.COM is the protocol support API within the link support layer LSL. Since the link support layer LSL.COM supports various protocols such as IPXODI and TCPIP registration of the IPXODI.COM protocol is checked in step . If the call to the link support layer LSL is to register a protocol stack an IPXMUX register protocol stack application program interface API handler in step checks whether the protocol stack is IPXODI. If the protocol stack is IPXODI the protocol stack handler sets a packet receive handler supported by IPXMUX.COM and calls LSL.COM s protocol stack API to register the protocol. The protocol stack handler also saves the stack ID. Subsequently in step an IPXMUX Receive Routine Linker sets the protocol stack IPXODI s receive routine address to the packet receive address supported by IPXMUX.COM.

If the protocol API call is not to register the protocol stack the system then checks in step whether a special registration service a bind stack service is requested. A bind stack service normally done before registration is used to set up a protocol for communication i.e. packet length etc. If bind stack service is requested an IPXMUX Bind Stack API handler in step is called which forces IPXODI to bind to the wired LAN card to which IPXODI is bound before the wireless LAN card was installed in order to be compatible with the IPXODI protocol. The IPXMUX bind stack handler also saves the process ID of the binding for sending and receiving packets.

If the protocol API call is not a register protocol stack or a bind stack service the system checks in step whether send packet service is requested. If not the system exits and the service call is handled by LSL.COM. If so an IPXMUX send packet routine is called in step and which sets the address of the wireless LAN card as the source node address in step . The packet modifier also sets the node address of the wireless interface device as the packet s destination mode address in step . The send event service routine address is set to the address of the send event service routine in IPXMUX.COM before it returns.

Incoming packets are handled by an incoming packet handler illustrated in . In particular incoming packets are checked in step whether the source address of the packet is from the wireless LAN card . If not the system returns. If so the packet s source mode address is saved and set to the mode address of the wireless LAN card while the pocket destination address is set to the address of the wired LAN card to which IPDXDI is bound.

The wireless interface device includes a hot icon in the hot icon area of the LCD C for switching control of the host computer from the wireless interface device and the host computer . While the wireless interface device has control of the host computer the user has the option to dim the screen of the host computer as well as lock out the keyboard and mouse inputs. In particular with reference to a set up window hot icon may be selected. Activation of the set up window icon causes one of five selectable set up dialog boxes to be displayed in the viewing area of the LCD C on the wireless interface device . These dialog boxes are illustrated in which can be selected by a graphical button bar . When the host button is selected a list of host computer groups that are accessible by the wireless interface device as well as the specific host to which the wireless interface device is connected are displayed. When the wireless interface device has control of the host computer the host computer screen can be dimmed and the host keyboard and mouse can be locked out by placing the pen down in the box next to those functions in the dialog box illustrated in . relates to setting up remote keyboard macros. is a maintenance dialog box which enables various maintenance functions such as calibration of the pen rebooting of the host and the like. relates to power settings and in particular includes an inactivity timer for timing periods of inactivity in order to place the wireless interface device in a low power state. is selectable by the screen button and enables the brightness and contrast of the LCD C on the wireless interface device to be adjusted.

Initially in step the system determines if the hot icon area of the LCD C on the wireless interface device was pressed. As illustrated in the hot icon area includes several hot icons. Thus the system checks in step whether the host control mode hot icon was selected. If not the system loops back to step and waits for the hot icon area to be pressed. If the host control mode hot icon was selected the wireless interface device sends a private message i.e. pocket to the host computer in step requesting host control mode.

The system then checks in step whether the host computer returned an acknowledgement that the private message was received. If an acknowledgement of the private message is not received by the wireless interface device the attempt to enter the host control mode is aborted in step . If an acknowledgement is received the system checks in step if the mouse keyboard and mouse had been previously locked out by the wireless interface device as discussed above. If so the host keyboard and mouse are unlocked. Subsequently in step an internal flag is set indicating a request for termination of the connection with the host computer in step . The request for termination initiates a timer which when timed out disconnects the wireless interface device from the host computer . Thus the system checks to determine if the host computer is still connected to the wireless interface device in step . If so the system determines if the request for termination has timed out in step . If not the system waits for the timer to time out and disconnects the wireless interface device from the host computer . Once the wireless interface device is disconnected control of the host computer is returned to the host computer .

In order to obviate the need to reconfigure the wireless interface device the next time the wireless interface device is connected to the host computer the system checks in step whether any of the configuration data i.e. contrast brightness was changed. If not the wireless interface device is placed in a suspend mode in step . If the configuration data did change the new configuration data is saved in the EEPROM B in step .

The wireless interface device can determine the available hosts within range for wireless connection. The user can then select a host by way of a dialog box which will be discussed in more detail below. An important aspect of the wireless interface device is that it can be connected to virtually any available hosts without any physical connections and without knowing the host address or node address beforehand unlike known wireless and wired LAN systems where the node addresses of each of the personal computers in the network have a preassigned node address and are therefore known prior to any communications being established.

In order to initiate connection of the wireless interface device to an available host the set up hot icon is selected in step which causes a set up dialog box as illustrated in to be displayed in the viewing area of the LCD . Subsequently in step the wireless interface device broadcasts network packets to be received by all available hosts in range that are on the same channel and domain as the wireless interface device . After the network packets are broadcast the wireless interface device listens for a predetermined time period in steps and for return acknowledgement packets from the available hosts which contain among other things the node addresses of the available hosts . After the time out period the wireless interface device terminates listening for responses from the available hosts in step . After listening is terminated the system checks the number of responses received in step . If no responses are received the wireless interface device repeats the cycle i.e. returns to step for a predetermined number of retries as determined in step .

If a response is received the system identifies the unique node address from the responding hosts in step and saves the unique host node addresses in step . The list of available hosts is searched in step for duplicate serial numbers. Should duplicate serial numbers be found in step a warning is generated in step warning the user that a duplicate copy of software is running on one of the responding hosts . In step the currently connected host is forced to appear as unavailable on the dialog box illustrated in .

The responding hosts are sorted first by group name and then by host name in step . After the sorting an internal status list of the available hosts in designated as available in step . Subsequently the available hosts and groups are displayed in the dialog box illustrated in in step . Movement of the cursor by a pen down event to the desired host selects that host . A connect button on the dialog box is then selected to connect the wireless interface device to the selected host .

Referring to the wireless interface device includes two user defined hot icons and located in the hot icon area of the LCD C that can be used for the macros. These hot icons and are configurable in a set up mode which as discussed above is under the control of the set up hot icon . Once the set up hot icon is selected a hot key button on the dialog box illustrated in is selected. As noted in the dialog box includes two configurable macros. These macros are configured by way of the two edit fields and . In order to configure the macros the icon for the desired edit field or is selected. These edit fields and are configurable by way of a virtual on screen keyboard OSK selectable by way of a hot icon .

Referring to the system checks in step whether there has been a pen down event in the viewing area of the LCD C and in step whether the OSK hot icon was selected. If not the system loops back to step . If so the selected key on the OSK is translated into a keyboard scan code in step and a visual indication of the key selected in the edit field or in step . The process is repeated until the macro i.e. WIN DIR followed by a carriage return is complete and the macro is saved in the EEPROM B in step . A clear button is provided in the dialog box illustrated in for each edit field and . These clear buttons enable the edit fields to be cleared in the EEPROM B .

Activation of the remote keyboard macros is accomplished by pressing down on the user defined hot icons or located in the hot icon area of the LCD C. The system checks in steps and whether the user defined hot icons or are selected. If the user defined hot icons or are not selected the system returns to step . Once one of the user defined hot icons or is selected the keyboard scan code sequence stored in the EEPROM B is retrieved for the selected hot icon or in step which are then individually transmitted to the host in step . These scan codes are then written to the keyboard buffer on the host in step . Subsequently in step the host processes the scan codes as though they originated from the host keyboard.

As mentioned above the wireless interface device includes several flash memory devices . The flash memory device includes a protected area which contains the system BIOS and a sufficient amount of functionality to enable the wireless interface device to be rebooted to enable reprogramming of the flash memory devices by way of the serial port in the event of a flash disaster.

In order to upgrade the flash memory devices the upgrade disks are installed in an available host computer . In particular the flash upgrade software is written to a predetermined directory on the host s hard disk. After the flash upgrade disks are installed the wireless interface device is turned on in step by way of the main power switch . Subsequently in step a connection between the host computer and wireless interface device is initiated in step by first selecting the configuration hot icon .

Subsequently the maintenance button on the dialog box is selected to get to the dialog box illustrated in . An upgrade button on the dialog box illustrated in is selected in step . In order to prevent programming errors the radio quality is checked in step before proceeding. If the radio quality is poor the upgrade is aborted. If the radio quality is adequate power management is disabled in step to prevent the wireless interface device from going into a reduced power state as discussed above during programming of the flash memory devices . After the power management is disabled a portion of the DRAM memory A in the wireless interface device is set aside to receive a flash sector from the host computer in step . Subsequently the wireless interface device polls the host computer to determine the correct numbers of sectors in the flash update and whether the sectors are available on the hard disk of the host computer in steps and . If the flash update files are not on the host hard drive or an incorrect number of sectors are available on the host hard disk the update is aborted. Otherwise the system requests the path file data from the host computer in step . Subsequently each sector file in the flash update is read by the host computer and uploaded over the radio to the DRAM A in the wireless interface device in step . After the sectors are written to the DRAM A in the wireless interface device a BIOS call is made to write the sectors in the DRAM A to the flash memory devices in step .

In step the system checks for errors in writing to the flash memory devices . Should any errors be detected the update is aborted. If no errors are detected the system checks in step whether all of the sectors from the DRAM A have been written to the flash memory devices in the wireless interface device . If not the system loops back to step . Once all of the files have been transferred to the flash memory devices the wireless interface device is rebooted in step . Once the wireless interface device is rebooted the system will be able to utilize the updated software in the flash memory devices .

As mentioned above the wireless interface device can be connected to any of the available hosts that appear in the dialog box illustrated in in the manner described above. The system illustrated in B and C obviate the need for the user to select a host for connection each time the wireless interface device is powered up by automatically connecting the wireless interface device to the last host to which it was successfully connected. As will be discussed in more detail below when a host is selected from the dialog box illustrated in for connection to the wireless interface device and a connection is successfully achieved the node address of that host is stored in the EEPROM B . Subsequently once the wireless interface device is powered up in step the system reads the node address from the EEPROM B and reads it to a specific location in DRAM A in step . After the node address is written to the DRAM A the system checks the node address to determine whether it is valid in step . Invalid node addresses occur anytime the wireless interface device makes an attempt to connect to a host which fails during automatic reconnecting or is later disconnected by the end user. Thus if a successful connection is not made or if there is a manual disconnection the node address is cleared from the DRAM A in step and thus will be invalid. Subsequently if the automatic reconnect fails in order to facilitate connection of the wireless interface device to another available host the set up dialog box illustrated in is displayed on the display C of the wireless interface device in step . After the host selection set up dialog box is displayed on the wireless interface device the system checks in step whether the wireless interface device is connected to an available host . Normally if an invalid address is found in step and the host selection set up dialog box appears on the display C of the wireless interface device there will be no connection to an available host and the system will jump to step where it checks if the hot icon area has been depressed. Normally in this situation since the host selection dialog box is already being displayed on the screen of the wireless interface device the only hot icon that can affect the situation is a sleep face hot icon which places the wireless interface device in a low power sleep mode. In a normal situation when the wireless interface device is first powered up the sleep faced hot icon is not depressed and the system waits for the user to select an available host from the host set up dialog box illustrated in as discussed above in step . Once an available host is selected the system loops back to step and attempts to establish connection with the selected host .

In step the system checks whether or not the connection was successful. If not the system goes to step and clears the node address for the selected host from the DRAM A and displays the host selection set up dialog box in step . If the connection between the wireless interface device and the host is successful the node address of the host is saved in a specific DRAM location in step and in turn written to the EEPROM B in step . After the node address of the selected host is stored in EEPROM B the wireless interface device will display whatever is being displayed on the host in step .

After a connection is established between the host and the wireless interface device the system continuously checks for hot icons being selected in step . If no hot icons are selected the system will loop back and continue to check for the selection of a hot icon. If the system determines that a hot icon is selected the system checks in step whether the set up dialog hot icon was selected. If so the system loops back to step and displays the host selection set up dialog box illustrated in on the display C of the wireless interface device . If the set up dialog hot icon is not selected the system checks in step whether the sleep face hot icon is selected in step . If not the system checks in step whether other hot icons in the hot icon area were selected and the appropriate action is taken. The system then goes to step and in turn and continually checks for the selection of other hot icons in step .

If it is determined in step that the sleep face hot icon is selected the system checks in step whether a double pen down event occurred at the location of the sleep face hot icon . As mentioned above the sleep face hot icon causes the wireless interface device to go into a low power mode. However before placing the wireless interface device in a low power mode the node address of the host to which the wireless interface device is connected is saved in a specific location of the DRAM A and in turn written to the EEPROM B in step . After the node address is saved the wireless interface device is powered down in step .

The system discussed above is thus able to automatically connect the wireless interface device to the last host to which it was connected. After the automatic reconnect should the set up window hot icon be selected the host selection set up dialog box illustrated in will be displayed on the screen C of the wireless interface device . Subsequently the system will go to step and check whether the wireless interface device is connected to a host . In this case since the wireless interface device will still be connected to the available host the system then checks in step whether a disconnect button on the host selection dialog box illustrated in has been depressed. If not the system goes to step and continuously waits for a hot icon in the hot icon area of the LCD C to be depressed. If the disconnect button in the host selection set up dialog box illustrated in is depressed the node address for the host to which the wireless interface device is connected is erased from the specific location in the DRAM B in step . Subsequently the system goes to step and waits for a hot icon in the hot icon area to be depressed.

As mentioned above the wireless interface device includes a virtual on screen keyboard OSK as illustrated in . More particularly the OSK is configurable by the buttons and in a control box located at the top of the OSK. These buttons and enable the OSK to be configured. For example a button displays the OSK as illustrated in with a full keyboard and numeric keypad. The button is a toggle which displays the keyboard without the numeric keyboard as illustrated in . The button displays the numeric keypad with the NUM LOCK off as illustrated in or alternatively displays the OSK as a numeric keyboard NUM LOCK on as illustrated in . The button allows the size of the OSK to be varied. The X button closes the window displaying the OSK.

As mentioned above the display C on the wireless interface device displays whatever is being displayed on the host when a connection is made. Since the graphics for the OSK is generated locally at the wireless interface device a remote occlusion region is generated at the host to prevent the host from painting over the OSK on the display C of the wireless interface device . The remote occlusion region is analogous to a window in the display of the host in which the host is prevented from using.

Referring to the system monitors the hot icon area to determine if any of the hot icons have been pressed. As discussed above the system includes an OSK hot icon which displays the OSK on the LCD C of the wireless interface device when depressed. If the system determines in step that a hot icon has been depressed it checks in step whether the OSK hot icon was pressed. If not the system loops back to and continually checks for hot icons being pressed. If the OSK hot icon has been depressed the system determines the last configuration for the OSK in step i.e. . Once the configuration of the last OSK is determined in step the system then checks the operating system and video mode of the host in step . Depending on whether the host is in text or graphics mode will determine whether the OSK image on the wireless interface device is merely shadowed onto the display of the host by way of a private message as will be discussed in more detail below or whether the remote occlusion region at the host is established by drivers in the host software which create the remote occlusion region by way of ASCII characters. Thus in step if the system determines that the host is in the text mode an occlusion region on the display of the host is created using the host control drivers in step . In step the system checks whether the occlusion region was successfully established. If not the system then checks in step whether the OSK is currently visible on the display C of the wireless interface device . If not the display of the OSK is aborted in step . If it is determined in step that the OSK is currently visible on the LCD C of the wireless interface device any reconfiguration of the OSK is ignored and the configuration of the last OSK is continuously displayed in step . If it is determined in step that the remote occlusion region is successfully established the system goes to step which enables the OSK to be used.

If it is determined in step that the host is not in a text mode the system checks in step whether the host is in a graphics mode. If not the system goes to step and sets the video mode to VGA graphics in the wireless interface device and subsequently proceeds to step to establish the occlusion region in the host by host control drivers. If the host is in a graphics mode the system next checks in step whether the host is running a Windows application. If not the system returns to step and establishes the occlusion region on the display of the host using the host control drivers.

If it is determined in step that the host is running a Windows application the occlusion region on the host is established by way of a private message sent by the wireless interface device to the host in step . After the private message is sent the system checks in step to determine if it was successfully sent. If not the system proceeds to step and checks to determine if an OSK is currently visible. If the private message is successfully sent the system checks in step whether the private message was successfully received by the host . If so the system goes to step and checks whether the private message was acknowledged by the host . If so the system goes to step and draws the OSK at the user requested coordinates. If not the system goes to . If it is determined in step that the private message has not been received the system continually checks for receipt of the private message for a predetermined time out period in step . Should a time out occur before the private message is acknowledged by the host the system again will go to step .

The OSK includes a control bar . The control bar enables the location of the OSK on the LCD C of the wireless interface device to be changed by touching the control bar with the pen and dragging it to the desired location on the LCD C of the wireless interface device . Anytime the user changes the location of the OSK on the LCD C of the wireless interface device as acknowledged by the system in step the system then returns to step to determine the video mode of the host computer . As discussed above the video mode determines whether the remote occlusion region on the display of the host is created by shadowing the OSK on the display of the host by way of the private message or whether the occlusion region on the display of the host is created by local drivers using ASCII characters. The system then goes to step .

The alternate embodiments of the invention discussed heretofore all relate to a single wireless interface device interfaced to a single host implemented as a personal computer or to a local area network by way of an access point . The following embodiments illustrated in primarily relate to a system in which multiple wireless interface devices interface in real time with a multi device server which forms a portion of either a wired LAN or a wireless LAN or multiple servers connected together by routers as will be discussed in more detail below. The system for enabling multiple wireless interface devices to interface in real time with a multi device server or plurality of servers is generally identified with the reference numeral and illustrated in . In this system a plurality of wireless interface devices etc. communicate with one or more local area network LAN segments and by way of an access point discussed above . Each LAN segment includes a multi device server with an extended Windows NT operating system as discussed below. The LAN segments and are connected together by a router discussed in more detail below. Only four wireless interface devices identified in as and are shown for example. However more wireless interface devices can be connected to the System .

Various server platforms are suitable for use with the system . For example server platforms which include one to four microprocessors for example 32 bit x86 or Pentium Intel Microprocessors or RISC based systems of at least 100 MHz or faster are suitable. Examples of suitable servers include ZDS Z Server MX Server up to 4 Pentium microprocessors ZDS Z Server WG Server up to 2 Pentium microprocessors and Z Station GT Desktop Server single Pentium microprocessor and the ZDS P6OE Server all available from Zenith Data Systems Sacramento Calif. Each server should have at least 90 MB of free hard disk space and 16 32 MB of RAM preferably 16 MB plus 4 MB per user.

As mentioned above each server utilizes an extended Windows NT Operating System. The Windows NT operating system is described in detail in Windows NT Server Professional Reference by K. P. Siyan New Writers Publishing 1995 Programming Windows 95 by C. Pelzold and P. Yao Microsoft Press 1996 WINDOWS 95 WIN 32 Programming API Bible by R. Simon M. Gauher and B. Barnes Waite Group Press 1996 hereby incorporated by reference. In order to enable remote control access of the servers and by the wireless interface devices an additional layer of software for example WinFrame by Citrix Systems Inc. is used in both the servers as generally shown in . The Citrix WinFrame software is described in detail in Citrix WinFrame published by Citrix Systems Inc. copyright 1995 hereby incorporated by reference. The WinFrame software supports Windows 95 Windows NT Windows 3.X as well as MS DOS text applications.

The access point allows multiple wireless interface devices to be connected to one or more LAN segments . Various devices are suitable for use as the access point . For example a wireless LAN adapter such as the CruiseLAN wireless LAN adapter as manufactured by Zenith. Data Systems Sacramento Calif. is suitable as described in detail in CruiseLAN PCMCIA SPECIFICATIONS published by Zenith Data Systems copyright 1994 hereby incorporated by reference.

The CruiseLAN LAN adapter is adapted to be installed in a PCMCIA Type 2 interface or ISA interface available on various desktop and portable personal computers. The CruiseLAN wireless LAN adapter is based on a frequency hopping spread spectrum technology in the 2.4 2.4835 GHz band and can be used in both client server and pier to pier network architecture systems. The CruiseLAN wireless LAN adapter supports NetWare 2.x 3.x 4.x NetWare Lite Microsoft Windows for Work Groups as well as Microsoft LAN Manager.

Various other wireless LAN adapters are suitable for use as the access point as long as the data rate requirements of standard PC LAN applications are exceeded for example 1.6 Mbps and suitable at a reasonable operating distance. Moreover various configurations are intended to be within the broad scope of the invention. For example the router can be used to connect the LAN to a gateway not shown . Also the router can be used to connect the LAN to a LAN which includes its own access point not shown .

As mentioned above the system may include multiple LAN segments connected together by a router . Various commercially available devices are suitable for use as the router for example as manufactured by CISCO Systems Inc.

The hardware for the wireless interface device is described in detail above and illustrated in FIGS. with the exception of the audio input subsystem described below. The software for the wireless interface devices for use with the multi device servers as well as the software for the multi device servers and is described below and included in Appendix 2.

As mentioned above the servers may be provided with the service advertising protocol SAP a Windows NT service as described in a CD ROM entitled Microsoft Developer Network Development Library January 96 published by Microsoft Corporation copyright 1996 hereby incorporated by reference. The SAP enables the servers to provide a broadcast function for broadcasting its server name and node address to the network. The servers with the broadcast function may or may not be in the same LAN segment with the access point through which the wireless interface device communicates. If the server is not on the same LAN segment the enumeration will be across the network router .

The system for enabling wireless enumeration of the servers available for connection to a wireless interface device is illustrated in . is an overall flow chart for both the servers and wireless interface devices . The software for the wireless interface device is illustrated in while the server software is illustrated in . illustrates a set up dialog box available at the wireless interface device for initiating the wireless enumeration of the servers and connecting to one of the servers.

Turning to the servers which as mentioned above utilize a Windows NT operating system are provided with the Service Advertising Protocol SAP which allows the servers to advertise their server names and node addresses. As shown in step the SAP uses the IPX Protocol supported by Windows NT operating system to transmit a SAP packet every 60 seconds to inform the other servers as well as routers on the network of their availability. When a wireless interface device is seeking a server to connect to the wireless interface device sends a SAP query packet as indicated in step . The SAP query packet is received by those servers and routers which support SAP. The servers that support SAP return their server names and node address as indicated in step .

Referring to after the server name and node address information is received by the wireless interface device an IPX packet is directed to the server to request the domain name software version as indicated in step . Steps and may also include information whether a particular application is supported which is part of a load balancing function described below. The IPX packet is received by the server which in turn requests its domain name as illustrated in steps and . In a server running the Windows NT operating system all domain names must be authenticated to a primary domain controller. The server then sets up packets identifying its server domain name and software version in step . This information is returned to the wireless interface device and then put into a server list buffer in step and displayed in the dialog box . Control is then transferred to the client manager for the wireless interface device in step in the wireless interface device . The wireless interface device may be then connected to the selected server by depressing the connect button in the set up dialog box illustrated in .

The SAP query packet is initiated by way of the wireless interface device by way of the set up dialog box illustrated in . As discussed above the set up dialog box can be accessed by depressing the hot icon in the hot icon area of the wireless interface device . As illustrated in the set up dialog box includes a server button as well as dialog boxes and which identify the server domain names as well as server name for those servers which broadcast a SAP advertising packet. The set up dialog box also includes a disconnect button and update list dialog button as well as a connect button . In order for the wireless interface device to issue a SAP query packet as discussed above the update list button on the set up dialog box is depressed. As mentioned above the servers then return their server names and node addresses on the network. This information is communicated to the wireless interface devices wirelessly. The server name and domain name is displayed in the dialog boxes and . The dialog box displays the group or domain information all of the servers in a particular group while the dialog box displays the individual servers within each of the groups.

The software for the enumeration service for the wireless interface device is illustrated in . As discussed above and illustrated in the wireless interface devices may include application software for example Novell NetWare. Referring to initially the IPX protocol is initialized in step when the update list button is depressed in the set up dialog box illustrated in . The IPX protocol Internet Packet Exchange is part of Novell NetWare s Protocol Stack and is used in this application to transfer data between the servers on the network and the various wireless interface devices . Once the IPX protocol is initialized an IPX socket is opened for listening in step . Once the IPX socket is opened for listening event control blocks ECBs are set up for listening for the expected IPX packets by calling an application programming interface API known as an IPXListenForPacket. The event control blocks ECBs are used for controlling the communication between wireless interface device and the server . Once the ECBs are set up for listening additional ECBs are set up for sending the SAP query packet in step . Once the ECBs for the SAP query packet are set up the SAP query packet is directed to the wireless network. As mentioned above the servers running the SAP service broadcast a SAP advertising packet every 60 seconds. The wireless interface device continues to receive these packets during a predetermined time out period as indicated in step . Since the servers which can support multiple wireless interface devices as well as personal computers which can only support a single wireless interface device respond to the SAP query packets in step during a predetermined time out period the wireless interface device checks in step whether the responding servers can support multiple wireless interface devices. If not the system returns to step and continues to wait for a response from a server that can support multiple wireless interface devices during the time out period. Once a response is received during the time out period from a server which can support multiple wireless interface devices the server name and node address is written to a list buffer in step . Once the time out period has expired the listen ECBs are removed in step and the IPX socket is closed in step . In other words the servers on the network only have within the time out period to respond to a SAP query packet from a requesting wireless interface device . Whatever servers respond during the time out period are identified by server name and node address in the list buffer. After that the listen ECBs are removed and the IPX listening socket is closed in steps and .

The server list buffer at this point contains the names of the servers connected to the network. The wireless interface device then determines the domain names of the various servers as illustrated in . In particular in step an IPX packet is initialized for a domain query to determine the domain name and software version and may also be used to determine whether a particular application is supported. Once the IPX packet is initialized a socket is opened in step as well as an event control block ECB for setting up an IPX packet for the domain query in step in order for the IPX packet to be sent to the wireless network in step . The domain query packet is sent out to the wireless interface device in step . Then ECBs are set up for listening for the domain packets and for the expected packets by calling IPXListenForPacket service in step . The system waits for servers to respond and checks in step whether all of the servers have responded. For each of the responses the domain and software version number is written to the server list buffer in step by the wireless interface device . The complete list buffer is displayed in the dialog box as discussed above.

The software for the servers equipped with the enumeration service is illustrated in . relates to the enumeration service initialization while relate to the enumeration service.

Initially the particular server in which the enumeration service is to be installed is initialized by calling a Windows NT API known as an open service control manager in step used for installing services on the servers . In order to determine whether the enumeration service is being installed or removed a parameter of the installation program is checked in step to determine whether the enumeration service is being installed or removed. If the parameter indicates that the enumeration service is to be installed the enumeration service is installed on the server in step . If the particular parameter in the installation program indicates that the enumeration service is to be removed the enumeration service is removed in step .

The operation of the enumeration service at the server side is illustrated in . In particular illustrates the software that enables the server to respond to an IPX packet from the wireless interface device regarding the server domain name and software version. In order to enable a server to respond to an IPX packet from the wireless interface device as set forth above the global variables for an IPX socket at the server are initialized in step . Subsequently in step a WIN socket is initialized. After the WIN socket is initialized an IPX socket is created in step to enable the servers to communicate with the wireless interface device . The system then checks in step whether there are any errors in creating the IPX socket for enumeration. If so the enumeration service is stopped and removed as discussed above. If there are no errors the WIN socket API is called in step to retrieve a datagram RecvFrom API call which retrieves packets sent from the wireless interface device to server from the network indicating a request packet has been sent by client . Subsequently in step the network Application Program Interface API is called to get the primary domain name of the server. If this process fails the primary domain name is obtained from the NT registry under key WINLOGON.

As will be discussed below in connection with the load balancing function the system may obtain certain other information including the server software version the number of current log in users per processor whether the specified application is supported by the server in step . The server software version number of current log in users per processor and whether the specified application is supported by the server is combined with the domain name and used to build and send a reply message in step which as discussed above is returned to the wireless interface device and stored in a server list buffer.

In accordance with another important aspect of the invention the system can provide for dynamic server allocation for load balancing the wireless interface devices . In order to provide dynamic load balancing the system checks the number of users per processor on each server and passes this information to the wireless interface device directly. In one embodiment only the server with the smallest load is identified in the server list buffer made available and displayed in the dialog box on the wireless interface device as discussed above.

In this application the software is essentially the same as discussed above for the enumeration service with the exceptions noted below. Since only one server will be made available to the wireless interface device the wireless interface device initiates a request to launch a specific application by name in addition to requesting the server domain name and version in steps . The responding server indicates whether the specified application is supported in addition to providing its domain name and version in steps . Once the server with the smallest load is detected which supports the application specified by the wireless interface device the number of hops for each server and number of log in users per processor on each server is multiplied to obtain a product in step . Each hop is identified as the number of links LAN segments or routers between a source node to a destination node. For example in there is one hop between the source node i.e. a wireless interface device and the server while there are two hops between the source node and the server . The product of the number of hops and the number of log in users per processor provides an indication of the amount of load per server. In order to select the server with the smallest load the server with the smallest product result is selected in step . Thus for the selected server group as illustrated in the dialog box in the set up dialog box illustrated in the server with the smallest load is identified in the dialog box while passing control to the client manager in the wireless interface device in step . After the server with the smallest load is identified and control is passed to the client manager in the wireless interface device connection between the selected server and the wireless interface device can be initiated by depressing the connect button on the set up screen.

In order to minimize memory storage space local software for the wireless interface device is stored in a compressed format for example in a read only memory device ROM such as the flash memory devices then decompressed written and executed from the DRAM memory devices A . As will be discussed in more detail below both .EXE files and .COM files as well as various other types of files are compressed and decompressed. An .EXE file is any executable file with an extension .EXE i.e. FIND.EXE MSD.EXE. A .COM file is any executable file with an extension .COM i.e. EDIT.COM SYS.COM. Such files as known by those of ordinary skill in the art include a header portion as well as a data or code portion where either data or a software program is stored. An exemplary header for an .EXE file is illustrated in Table 8 below.

As shown in Table 8 an executable file header identifies the various attributes of an .EXE file including the size of the file the required memory storage space for the file as well as various attributes of the header file such as the number of bytes in the header. Utilizing the example of Table 8 the exemplary header file indicates that there are 160 or 352 paragraphs in the header. Since there are 16 bytes per paragraph the exemplary header file illustrated in Table 8 is a 5632 byte file.

With known data compression techniques the data or code portion of both .COM files as well as .EXE files are compressed by various techniques for example as disclosed in DATA COMPRESSION by James A. Storer Computer Science Press Copyright 1988 pps. 146 163 hereby incorporated by reference. However due to the complexity of the structure of the headers for an .EXE file for example as shown in Table 8 such header files have not heretofore been known to be compressed. Thus using the example illustrated in Table 8 the entire 5632 byte header for the .EXE file would be stored in a decompressed format while the code or data portion of the file is stored in a compressed format.

For applications to be run locally on the wireless interface device which include a number of .EXE files the header for such an .EXE file can occupy a relatively substantial portion of the available memory storage space provided by the flash memory devices . In order to reduce the required memory storage space in the flash memory devices in the wireless interface device the headers for the .EXE files are at least partially compressed in accordance with an important aspect of the invention. As will be discussed in more detail below the header for such .EXE file is transformed into a customized header which may include an uncompressed portion and a compressed portion . The data or code portion is totally compressed as discussed above.

The uncompressed portion of the header for example the first 100 bytes may be used for various attributes of the file which may be used either before or during the decompression process in order to speed it up. For example the uncompressed portion of the header may include an attribute of the original header such as the length of the original header. Various other types of information may also be included in the uncompressed portion of the customized header . For example the uncompressed portion of the customized header may include a signature field . The signature field can be used to indicate whether the file is a .COM file or an .EXE file as well as the version of the compression software. Such information can be used to speed up the decompression process.

The overall flow chart for the compression decompression process is illustrated in . The flow diagram for the compression process is illustrated in and while illustrates the flow diagram for the decompression process.

New software to be loaded into the wireless interface device may be loaded by way of the UART by way of the serial port or by way of the radio interface . In particular in order to load software into the wireless interface device wirelessly in a system in which multiple wireless interface devices are supported by a single server the software is first loaded into an available server . In such an application the wireless interface device is placed in a set up mode of operation. In particular the hot icon is initially selected from the hot icons illustrated in . The MAINTENANCE BUTTON is then depressed to provide the dialog box as illustrated in .

The overall flow chart for the compression decompression process is shown in . Initially files are compressed and transmitted to the wireless interface device . In particular the compressed files are written directly to the flash memory devices . In order to execute the file the compressed file from the flash memory device is written to a temporary file within the DRAM memory devices in the memory space 10000 to 1FFFFF. In such an application the flash memory devices act as input files while the temporary file in the DRAM memory devices serves as an output file. Alternatively new files to be written to the flash memory devices are initially uncompressed and stored in an external input file external from said wireless interface device . The input file is then compressed and stored in an output file . The compressed output file is then transferred to the flash memory devices within the wireless interface device over a radio link. Thus in step depending upon whether compressed data is being written to the flash memory devices or whether the compressed data within the flash memory device is being executed input and or output files are opened in step as generally discussed above. If the file is to be transferred to the flash memory devices in the wireless interface device the file is compressed and written to an output file and transferred to the flash memory devices as indicated by steps and . For files that are currently stored in the flash memory devices in a compressed format these files are decompressed and written to an output file for execution as indicated in steps and .

The software for compressing the various software to be stored in the wireless interface device is illustrated in and . Files to be compressed are read to determine whether the file is an .EXE file or a .COM file in step . The system then sets up a signature field . As discussed above the signature field is stored in the uncompressed portion of the customized header and may include information as to whether the file is an .EXE file or a .COM. Thus in step the input file is read to determine the type of file written to the input file . If the file is an .EXE file a signature flag for an .EXE file is set in the signature field as illustrated in step . On the other hand if the file is a .COM file the signature flag within the signature field is set to represent a .COM file in step . Once the signature flag is set other signature information may be added to the signature field in step . For example as discussed above the software version of the compression software may be included in the signature field in order to speed up the decompression process. Once the signature field is set up the signature field is written to the output file in step .

As mentioned above due to the complexity of the headers for the .EXE files for example as illustrated in Table 8 a customized header is set up for both an .EXE file and a .COM file. Once the signature field is written to the output file the system determines in step whether the file is an .EXE file or a .COM file. If the file is a .COM file a customized file header for a .COM file is set up in step . As such in step the entire header and the data or code portion for the .COM file is compressed after which the system goes to step . Since the headers for .COM files may rather easily be compressed the customized header for a .COM file may merely indicate the size of the header and store it in an uncompressed portion of the customized header . The customized header file is then written to the output file in step . After the customized file header is set up the system checks in step whether the file is an .EXE file or a .COM file.

If the file is a .COM file the entire file including the header is compressed. If it is determined in step that the file is an .EXE file the system reads the file block by block in order to determine the size for the customized file header . As indicated above the customized file header for .EXE files may include an uncompressed portion as well as a compressed portion . Once the signature field is set up the system can then begin processing the header for the .EXE file block by block in order to form the customized file header as discussed above. As shown in Table 8 .EXE files include various types of information. Thus in steps through the system reads portions of the header on a block by block basis for such .EXE files in order to form the customized header which includes the uncompressed portion as well as the compressed portion as generally illustrated in . As mentioned above by the time the system reaches step the signature field has already been set up. The system continually loops from step to step until all of the blocks of data in the file header for example as illustrated in Table 8 is transformed for example as indicated above into a customized file header which includes an uncompressed portion and a compressed portion . The system constantly checks in step whether the entire header i.e. all of the blocks for the .EXE file has been written to the output file .

As mentioned above the header for an .EXE file indicates the size of the header. For example as illustrated in Table 8 the exemplary header is 5632 bytes long. Once the uncompressed portion is formed the amount of space for the compressed portion can be determined in step . Once the size of the compressed portion of the customized file header is determined space for the size of the compressed block of the customized header is reserved in the output file in step . A first block of data from the header in the input file is read in step . The first block of data is then compressed in step and written to the output file in step . The total length of the compressed block of data is written to the output file in step . The system then loops back to step to determine of additional data from the original header written to the input file needs to be processed.

After the customized file header is formed and written to the output file the data or code portion for both .EXE and .COM files is read compressed and written to the output file in steps . In order to identify the beginning of the data or code portion the signature field may include a data image index which indicates the memory location of the data or code portion in the input file . Since the customized header may be at least partially compressed the address location in the output file of the beginning of the data or code portion is modified in the signature field in the output file in step . Subsequently space is reserved in the output file for the data or code portion of the file in step . The data or code portion is then read from the input file and compressed according to known compression techniques for example as discussed above and written to the output file in step . After the compressed data is written to the output file the size of the compressed data or code portion is written to the output file in step .

The flow chart for decompressing stored compressed files in the flash memory devices is illustrated in . Initially any file to be executed is in a compressed format as discussed above. Initially as indicated by step the signature field is read from the input file . After the signature field is read from the input file the customized file header is read in step . As mentioned above the signature field identifies whether the particular file is an .EXE file or a .COM file. Thus the system ascertains in step whether the file is an .EXE file or a .COM file. As indicated above the signature field may include data regarding the file as to whether it is an .EXE file or a .COM file as well as the software version of the compression software in order to speed up the decompression process. Before the file can be decompressed the size of the compressed data or code portion must be ascertained. As indicated above for .EXE files the size of the header may be ascertained directly from the customized file header . Since the header for a .COM file is compressed in the same manner as the code portion for the .COM file the header portion is treated the same as the code portion . Thus the entire .COM file header portion and code portion are written directly into the output file in step . In the case of .EXE files the customized file header is written to the output file . The system then reads the size of the block in step . In the case of a .COM file the size of the compressed data or code block may be read directly from the flash memory device . In the case of an .EXE file the file header is partially compressed as indicated above in data blocks. Thus in steps the system reads decompressed blocks of data from the input file and writes the decompressed data to the output file . Both the headers portions as well as the data or code portions are decompressed one data block at a time by the loop consisting of the steps . Once all of the data has been decompressed including the header the decompressed file may be executed directly from the output file which may be a part of the DRAM A.

As previously indicated the wireless interface devices may include one or more flash memory devices . However the present invention also applies to other electronically programmable memory storage devices such as electronically erasable programmable read only memory EEPROM . For a single user system as indicated above any software updates to the wireless interface device may be accomplished by loading the software onto an available host and then establishing a connection between a host computer and the wireless interface device . For a single user wireless interface device as discussed above the user simply goes to the set up dialog box as indicated in and depresses the upgrade button for automatic wireless loading of the software to the wireless interface device . In a multi user environment for example as illustrated in each of the wireless interface devices can individually initiate an upgrade from the available server . In such an application the server and in particular the network administrator notifies all of the various wireless interface devices users connected to the network that the local software within the wireless interface device needs to be updated. Each of the individual wireless interface devices can then be updated from the server wirelessly as illustrated in and discussed below.

More particularly initially each of the wireless interface devices are turned on in step and a connection is established with the system servers in step as discussed above. Once the connection with the server is established each of the individual wireless interface devices is notified by the network administrator regarding the need for a local software update. The software in each of the individual wireless interface devices can be initiated by a local user interface as indicated in step . In particular the flash upgrade is initiated by going to the set up dialog box on the wireless interface device and depressing the MAINTENANCE BUTTON to arrive at the dialog box as indicated in . The user depresses the upgrade button to initiate automatic wireless installation of the software into the flash memory devices in the wireless interface device. In order to prevent programming errors the radio quality is checked in step before proceeding. If the radio link quality is poor the upgrade is aborted as indicated by step . If the radio link quality is sufficient any power management functions in the wireless interface device is disabled in step to prevent the wireless interface device from going into a reduced power state as discussed above during programming of the flash memory devices . After the power management function is disabled a portion of the DRAM memory A in the wireless interface device is set aside to receive a flash sector from the server in step . Subsequently in step wireless interface device polls the servers to determine the total number of sectors in the flash update over the radio link in step . After the total number of sectors is obtained for the upgrade the system checks in step whether there have been any errors in the data transmission from the server . The errors may be checked for example by checking whether cyclic redundancy checking CRC code matches a specified CRC code for each file or whether there are any other server errors. Thus if the value resulting from the CRC at the wireless interface device does not match the value of the CRC of the server the flash upgrade is aborted in step . Otherwise the system proceeds to step and sets up a receiving buffer in the DRAM memory devices A and requests a sector of the upgrade from the server . Once a request for a sector is initiated the sector is transmitted from the servers over the radio link to the DRAM memory devices A. A BIOS routine is called in step to write the flash sector from the DRAM memory device A to the flash memory devices in step . In step the system checks for any errors in writing the flash sectors to the flash memory devices . Should any errors be detected the flash upgrade is aborted and the system returns to step . If no errors are detected the system checks in step whether additional sectors need to be requested from the server . If so the system loops back to step . If all of the sectors have been requested the system goes to step and reboots the wireless interface device .

As mentioned above updating of the software in the flash memory devices may be initiated depressing the upgrade button in the set up dialog box in the individual wireless interface devices . illustrates the method for installing the upgrade files onto the server to be wirelessly transferred to the wireless interface devices . In particular in order to prevent unauthorized updating of files in the server the system checks in step whether the current log in user of the servers has administrative privilege. If not the flash upgrade is aborted in step . If the log in user to the server has administrative privilege the flash upgrade binary files for example from a floppy disk may be loaded onto the server for example by way of a floppy disk and recorded in the server registry in step .

The thread for the wireless flash upgrade is illustrated in more detail in connection with . Once a wireless interface device is connected to a particular server a communication channel is set up between the server and the wireless interface device requesting an update. Initially in step the server continuously reads the communication driver channel for requests from the various wireless interface devices connected to the servers . In steps through the server ascertains the type of request from the wireless interface device. For example in step the system ascertains whether the wireless interface device is initiating an upgrade of the flash memory devices . If so the system ascertains in step whether the wireless interface device has initiated an upgrade by way of the set up dialog box illustrated in as discussed above. If so the server initiates a flash upgrade by processing the overhead associated with a flash update such as obtaining sector numbers and getting the CRC code for the number of sectors as well as the sectors themselves in step . If the request from the wireless interface device is not an initiate flash upgrade request the system checks in step whether the request is for a flash upgrade name. If so the system checks with the server registry for the latest flash upgrade name and passes it on to the wireless interface device in step . If not the system checks in step whether the request is a request for a packet of binary file data associated with the flash update. If so the server sends data packets to the wireless interface device for the various sectors of the flash upgrade in step as discussed above. In step after reading the communication driver channel the server checks to determine if the request from the wireless interface device is a request to cancel the flash upgrade or that the flash upgrade is complete. If so the flash upgrade clears or frees up all resources it utilized. In step the system checks whether there is any other type of request from the wireless interface device . If not the system loops back to step and continues to read the communication driver channel. If there is a request from the wireless interface device other than as enumerated in steps to the server posts a message to other threads associated with that request in step .

The wireless interface device is adapted to support multi media applications features running on the server wirelessly transmitted to the wireless interface device by way of the access point . In support of the multi media applications the wireless interface device may be provided with a speaker as well as a microphone . In order to receive audio input data as well as broadcast audio at to the wireless interface device to receive audio data an audio processing system is provided which includes a speaker and a microphone . The audio processing system processes input audio data from the microphone to simulate that the audio input is directly received by the server . As will be discussed in more detail below audio data received by the wireless interface device is compressed and wirelessly transmitted to the servers . The audio data is decompressed by a decompressor at the servers and formulated by a kernel mode driver forcing the server to assume that the audio data was input directly into the server .

As mentioned above the audio input processing system includes an output path which includes the speaker for supporting various multimedia applications. Referring to digital audio signals either from the ISA bus as discussed above or the digital signal processor are applied to a D A converter which are in turn filtered and amplified by a filter and amplifier and broadcast through the speaker .

Referring to input audio data is converted to a digital signal by the A D converter and applied to an audio driver such as the digital signal processor in step . The audio signals are then compressed in step . Control of the compressed audio data is then turned over to the client manager for the wireless interface device which reformulates the compressed audio data for data transmission over the radio link as indicated by step . On the server side the compressed audio signals from the wireless interface device are received over the radio link by the server as indicated by step . Control of the compressed audio signals at the server side is turned over to the server manager in step which formulates the data for decompression in step . In order to simulate that the original audio input was input directly into the server the uncompressed audio data is fed into a kernel mode driver in step running in the Windows NT kernel to simulate that the audio input is directly to the server . The algorithms for compressing and decompressing the audio data are discussed in detail in DATA COMPRESSION by James A. Storer Computer Science Press copyright 1988 hereby incorporated by reference.

An important aspect of the invention relates to the manner in which the audio data is compressed. Referring to audio data prior to being compressed is stored in a temporary buffer in the wireless interface device . Uncompressed data as illustrated in is sampled every predetermined time period or when the volume is below a predetermined level as illustrated and stored in a temporary buffer. As illustrated in the sample points on the horizontal axes marked with the X are exemplary data points stored in the temporary buffer. As shown the points and are at predetermined time intervals while the point between 2 and 3 seconds is a point where the amplitude or volume is below a predetermined level. Thus as indicated in step the system samples the audio data points at every predetermined time period or when the volume has reached a predetermined level and places the data in a temporary buffer in step . The system loops back to step and continues sampling data points until the buffer is full as ascertained in step . Once the temporary audio buffer is full the entire buffer is compressed at one time as indicated by step . The compressed audio data is then passed to the wireless interface device client manager in order to pass the data over the radio link to the server in step .

As mentioned above in a single user mode the wireless interface device is provided with an on screen keyboard OSK which can be actuated by pressing the hot icon in the hot icon area . In such an application once the OSK is selected a remote occlusion area on the host is created to prevent the host from painting over the OSK on the wireless interface device . The operation of the OSKs in a single user environment have been discussed above and illustrated in 

In a system where a plurality of wireless interface devices are connected to servers by way of a single access point for example as illustrated in each of the wireless interface devices in such a multi user environment can be provided with an OSK in much the same manner as discussed above. In fact the software for the OSK at the side of the wireless interface device is essentially the same with the exception that in this application rather than a single wireless interface device communicating with a single host a plurality of wireless interface devices communicate with servers . Thus the software for the multi user application for the wireless interface devices is essentially as illustrated in and . The server side software for the multi user OSK is illustrated in . The server software is used to prevent overwriting of the OSK on the display of the wireless interface device by the server.

Once the shared memory is created global data i.e. position and dimension of the OSK is initialized for a default position. In particular when the OSK hot icon is depressed the OSK will appear in a predetermined position on the display. Thus in step the initial position of the OSK is identified. As will be discussed in more detail below the OSK can be moved around the display.

If an occlusion window does not exist steps are used to create the occlusion window. The occlusion window is created in response to a private message sent by the wireless interface device . In particular a no paint occlusion window is created in step . A no paint window is a window in which the background is not painted during movement. In addition to the no paint window a holder window may be created in step . A holder window is simply a wire frame which prevents the original no paint window from being painted while the no paint is being moved. Both the no paint window as well as the holder window are registered in steps as set forth above. In step a system wide WH CALLWNDPROC hook is created by way of an API call. A system wide hook is called for any system wide messages in order to coordinate with pop up menus as well as keyboard and mouse messages. In particular the system wide hook is registered with the Window NT system such that during conditions when the OSK is running certain Windows messages such as a pop up menu will automatically disable the OSK. Once the window and the hook are created the X Y position of the OSK is updated in step and a success or failure rate is checked in step .

The procedure for closing the occlusion window is illustrated in . Initially an API call is made in step to uninstall the WH CALLWNDPROC hook in order to remove it from the system. After the Windows WN CALLWNDPROC hook is uninstalled the holder window and no paint window data are destroyed by removing these windows from the system in step . Subsequently in step the occlusion region global data is destroyed.

The process illustrated in is initiated any time the hot icon is toggled to disable the on screen keyboard. The software for creating the occlusion window as indicated in steps and is illustrated in .

Referring to in a Windows environment all windows have procedures for processing keyboard and mouse inputs for that window. Initially the system determines whether a window is being created in step by checking for a WM CREATE Windows message. The WM CREATE Windows message as well as other Windows messages are described in detail in Programming Windows 95 by C. Petzold Microsoft Press 1996. If a new OSK window is being created the no paint and holder windows are set up in step as discussed above. In particular the no paint and holder windows are set up by registering the windows with respect to the class and the shared memory. Once the no paint and holder windows are set up the system exits to step .

If a new OSK window is not being created the system determines in step whether there are any messages for painting in step by checking for WM PAINT messages. The WM PAINT message indicates that the window needs to repaint itself. If so a ValidateRect function is called to cause the client area of the no paint window to be repainted.

The system continually checks the Windows messages and checks in step whether the message is a window position change message WM WINDOWPOSCHANGING. If the message is a WM WINDOWPOSCHANGING message a holder window is shown and the no paint window is hidden in step while the position is changing. Afterwards in step a message is posted that the window position has changed. In response to a window position change message WM WINDOWPOSCHANGED as ascertained in step the no paint window is relocated and shown in step while the holder window is relocated and hidden in step . In step the system checks for any window destroy messages WM DESTROY. These messages are usually sent by the system when the windows are closed. In the case of the OSK the WM DESTROY message is sent anytime the OSK on the wireless interface device is disabled by the hot icon. In response to a window destroy message WM DESTROY the system closes the occlusion region and releases the shared memory in step . If there are no Windows messages as set forth in steps or then the default window processing function DEFWINDOWPROC is called in step .

The flow chart for installing a hook is illustrated in . A standard Windows function call is used to set up a WH CALLWNDPROC hook. This hook is used to avail the occlusion window to any window messages on the system. Thus in step in order to access various Windows messages on the system the pointer for the occlusion region global data shared memory is obtained in step . Subsequently in step the system ascertains whether the message is a window position changing message. If not the message is passed on to the next hook by calling a standard API called CALLNEXTHOOKEX in step . The CALLNEXTHOOKEX function is used to pass information to the next hook procedure in the chain. The system then exits in step . If the message is a window position changing message the system then checks the window to determine any overlap in step . Essentially if a pop up window or other window will conflict with the OSK the OSK as well as the occlusion window is closed in step . The global data for the occlusion window is updated in step . If the window being tracked does not conflict with the position of the OSK the system exits in step .

27. Ink Trails on a Wireless Remote Interface Tablet Wireless Remote Interface Ink Field Object and Distributed Pen Support of Ink Trails.

As discussed above on power up the wireless interface device comes up in a mouse mode with a left mouse button default. The hot icon allows the pen events to be converted to right mouse button events. In the mouse mode all pen events are translated as mouse messages back to the servers as either right mouse button or left mouse button data depending on the status of the hot icon . As mentioned above the wireless interface device is also adapted to operate in a pen mode. In a pen mode the pen events are translated into pen data and transmitted back to the servers . Ink trails are created on the wireless interface device to follow the pen wherever it is moved within the ink field .

There are various methods for transferring the mode of operation of the wireless interface device from a mouse mode to a pen mode. For example the pen mode may be entered by depressing a hot icon not shown as discussed above. Alternatively an active stylus can be used which to enable the wireless interface device to switch between a mouse mode and a pen mode by depressing a barrel switch on the stylus as discussed above. Alternatively as will be discussed below the pen mode can be initiated by way of an application program such as Microsoft VISUAL BASIC MICROSOFT ACCESS MICROSOFT VISUAL FOXPRO or BORLAND DELPHI. Such application programs are used to create custom forms or containers for embedding controls. The form is customized by way of the various controls placed on the container. An OLE 2.0 control object linking and embedding can be implemented as an ink field control to support the ink trails on the wireless interface device . In particular with reference to a sample container application with an ink field is illustrated. In such an application any time a pen event is detected in the ink field data is interpreted as pen data. The pen data is passed to the server over the wireless radio link which in turn transmits the information back to the wireless interface device for display. More particularly each point which the pen moves across in the ink field within the container application is formulated into a data packet and transmitted back to the server over the wireless radio link. The server then processes the data packets for all the pen points and causes lines to be drawn between successive pen points. This data is transmitted back to the wireless interface device for display within the ink field .

A data flow diagram for the system is illustrated in . The container application is under the control of the application program discussed above i.e. VISUAL BASIC etc. The ink field object provides the ink field control for one or more ink fields within the container application . As mentioned above an OLE 2.0 object linking and embedding object is implemented as the ink field object by registering the OLE 2.0 object in the registry in the Windows NT servers . After the OLE 2.0 object is registered in the registry the ink field control can be added to a tool box in the application program such as VISUAL BASIC to provide ink field control for the ink field . Ink field data is processed by the servers . In particular each point within the ink field over which the pen passes is converted to pen data packets in the wireless interface device by way of a virtual communication channel . The server in turn processes the pen packets and communicates back with the wireless interface device to draw lines between successive pen points within the ink field object in order to display the ink within the ink field in the container application .

The ink field within the container application is activated as illustrated in . As mentioned above the pen mode is initiated by a pen down event within the ink field within the container application as indicated by step . Following a pen down event within the ink field the system checks in step whether the ink field is already active. If so the system proceeds directly to step and provides for local inking for all pen down events within the ink field . If the ink field is not previously activated the system is assumed to be in a mouse mode as discussed above. In such a mode the left mouse button is the default button state in the mouse mode. Thus as indicated in step a mouse left button message WM LBUTTONDOWN is passed to the server from the wireless interface device . If the pen down events are within the ink field and the container application the ink field object enables the pen mode for the system. In particular a private message is sent by the servers to the wireless interface device to enable the pen mode in step . The pen driver processes the private message to enable local inking. Prior to the pen mode being enabled all pen down events within the ink field are stored as mouse data points. All points interpreted as mouse data points within the ink field are inked locally as indicated in step . Once the system is in a pen mode all points within the ink field are inked locally immediately.

The ink field is enabled as illustrated in . As mentioned above in step a mouse left button down message WM LBUTTONDOWN is sent from the wireless interface device to the servers anytime a pen down event occurs in the ink field . In response to the left button down message WM LBUTTONDOWN the window handle for the ink control window i.e. ink field is obtained in step by calling the member function GETHWND for the OLE 2.0 control in step . After the window handle of the ink field is obtained shared memory is set up by the server for sending private messages to the wireless interface device in step . In step the window position and size of the ink field window is obtained. After the window position and size is obtained a private message is sent by the servers to the wireless interface device to enable inking by posting the message on a message handler thread of the server manager in step . After the private message is sent to the wireless interface device a mouse button up event is simulated in step .

Referring to an active ink control disabler is responsive to standard Windows messages as well as certain ambient property changes such as changes in the UIDead and user mode status as discussed below. A WM SYSKEYDOWN message is transmitted to the active ink control disabler anytime the ALTERNATE key is depressed as indicated by step . A WM KEYDOWN message is sent to the active ink control disabler anytime any other keyboard key is depressed as indicated by step . A WM KILLFOCUS message indicates that the ink control field has lost its focus for example when a model dialog box pops up. Lastly the ambient property changes of the container application as indicated by the block cause the ink field to be disabled.

As mentioned above ambient property changes also disable the ink field. These events as indicated in step cause the system to switch to mouse mode as indicated in step . In particular with reference to any changes in the ambient property as indicated in step cause the ambient property handler to be called in step which in turn calls the active ink control disabler in step .

The ambient property handler is illustrated in while the Windows message handler is illustrated in . The ambient property handler illustrated in determines if there are any changes in the application program such as VISUAL BASIC to the inking control in step . In particular controls for the container are set up by the application program as is illustrated in . The ink control software checks in step whether the UIDead status is true i.e. ink control cannot receive input . If the UIDead status has changed to true the active ink control disabler is called to disable the ink control. The user mode relates to either a design mode for setting up the controls on the container application or a run mode for utilizing the container application . Otherwise the user mode is checked in step . If the user mode changes to false which means a switch to the design mode the ink control is disabled in step . Otherwise the default handler of the On Ambient PropertyChange processes the ambient property changes.

As mentioned above various Windows messages such as WM SYSKEYDOWN WM KILLFOCUS and WM KEYDOWN all cause disabling of the ink control. In response to any of the standard Windows messages the active ink control disabler is called in step . After the active ink control disabler is called the default handler for the corresponding message is called in step to process the particular message.

Inking within the ink field of the container application can be cleared by way of a right mouse button double click. In particular as discussed above certain ambient property changes disable the inking function and return the system to a mouse mode. Once the mouse button has been toggled to the right mouse button state a double click as discussed above is used to clear the ink in the ink field . In particular in response to the right mouse button double click event a Windows WM RBUTTONDBCLK message is sent by the Windows message handler which clears the ink data buffer as indicated in step . Once the ink data buffer is cleared a member function InvalidateControl is called to cause redrawing of the ink field which clears all inking in step .

The pen data processor and pen data buffer manager are illustrated in . The pen data processor is shown in . The pen data processor manages pen data sent by the wireless interface device to the servers . As discussed above once the system is determined to be in a pen mode pen data packets are formulated for each point in the ink field touched by the pen. These pen data packets are stored in a message buffer. Thus in step the system ascertains whether there are any pen data packets in the message buffer. If there are pen data packets in the message buffer one pen data packet is processed at a time. In particular in step one pen data packet is retrieved from the message buffer in step and converted to a VGA point in step . The VGA point is then stored in the message buffer in step by calling the pen data buffer manager. After each point is processed the system checks in step to determine whether the inking field has been disabled by way of the user interface in the application program and whether the mode of the application program is in a run mode as opposed to a design mode in step . If not one point or segment is inked in step . The system continues looping between step and step until all of the pen data packets in the message buffer have been processed.

The pen data buffer manager is illustrated in . Initially in step the system ascertains whether the pen data buffer is full. If so a larger buffer is allocated in step . Once a larger buffer is allocated the contents of the previous buffer are copied into the new buffer in step to enable the previous buffer to be freed in step .

The buffer manager in order to conserve space stores the offsets between the various points. Thus in step the offset from the previous point is calculated and stored in the pen data buffer.

The flow chart for the router is illustrated in . Initially in step the system determines whether the wireless interface device is in an ink mode as discussed above. If the wireless interface device is not in an ink mode the system assumes that the wireless interface device is in a mouse mode and proceeds to get the packet for the point from the data buffer in step . This point is pushed onto the router stack in step . The mouse manager is called in step to process the point as a mouse data point as discussed above. The system continuously processes the points in the buffer while the system is in a mouse mode until it is determined in step that the buffer is empty at which point the system exits the router in step .

If it is determined in step that the wireless interface device is in an ink mode the system checks in step whether the router stack is empty. Thus if it is determined in step that the stack is empty a pen data packet is obtained from the buffer in step . If the buffer is empty as determined in step the system exits. If the buffer is not empty the system proceeds to step to determine if the packet represents the first pen down event. If the pen data point is not the first pen down event the system checks in step whether the pen data point was in the ink field in step . If not the system ignores the point in step and returns to step for processing further packets. If it is determined in step that the data packet was within the ink field the data packet is placed into a transmit buffer in step for a wireless transmission to the servers . After the data packet is placed into the transmit buffer a local inker is called to ink the point on the screen of the wireless interface device in step . The system then returns to step for processing additional data packets.

If it is determined in step that the router stack is not empty one data packet is popped from the stack in step . After the data packet is popped from the router stack in step the system ascertains in step whether the data packet represents the first input ink point. If not the data packet is placed in the transmit buffer in step for a wireless transmission to the servers . Subsequently a video manipulation module included in Appendix 2 is called to draw the point in step . The system then proceeds to empty the router stack as indicated in step and subsequently returns to step for a further data packet processing.

If it is determined in step that the data packet represents the first pen down point the system then checks in step whether the data packet is a stack point. If not the system checks whether the point was within the ink field in step . If not the ink field is disabled in step and the mouse data packets are pushed into the router stack in step . After the mouse data packets are pushed into the router stack the mouse manager is called in step to process the data packet as a mouse data packet in step . Subsequently the system returns to step for processing.

If it is determined in step that the data packet is a stack point the system then checks in step whether the data packet was within the ink field in step . If not the point is ignored in step and the system returns to step for further data packet processing. If it is determined in step that the data packet in the stack was within the ink field the data packet is put into the transmit buffer in step for wireless transmission to the server . After the data packet is placed into the transmit buffer the point is inked on the display of the wireless interface device in step .

As mentioned above the wireless interface device is provided with an ink field . As mentioned above wireless interface device powers up in a left button down mouse mode. A pen down event within the ink field causes the wireless interface device to switch to a pen mode. As mentioned above all pen down events are formulated into pen data packets and stored in a buffer. Initially the system determines in step whether the wireless interface device is in a handwriting recognition mode which as will be discussed below may be controlled in a manner as discussed above by pen events in the ink control field running on the servers . If the system is not in a handwriting recognition mode the system calls the default pen point handler which processes pen data as discussed above. If the system is in a handwriting recognition mode the system calls the handwriting recognizer in step which takes the pen data and converts it to characters and passes it onto the client manager in step for transmission to the servers by way of the radio link. The character data is received by the servers in step and converted to a keyboard input in step .

As indicated above a pen events in an ink control field may be used to place the system in a handwriting recognition mode as indicated in step . This information is transmitted to the server manager in step for wireless transmission to the wireless interface device in step . The wireless interface device receives this data in step and passes it to the pen driver in step .

The handwriting recognizer is illustrated in . Initially pen data from the pen interrupt handler is analyzed in step to determine whether the pen data represents the first pen down event. If so as mentioned above a mouse left button down message is formulated in step . If not the pen data is converted into relative movement format in step . In step a pen data packet is built by adding pressure angle and move direction in the buffer. Default values may be used for the pressure and angle data. The system then checks in step whether there were any pen up events or a time out. If not the system returns in step . If so the system calls a handwriting recognition engine in step . Various handwriting recognition systems are suitable for use with the system. For example the handwriter recognition system by CIC Products and Services of Tokyo Japan is suitable. As mentioned above a handwriting recognition engine converts the pen data to characters for transmission to the servers .

Obviously many modifications and variations of the present invention are possible in light of the above teachings. Thus it is to be understood that within the scope of the appended claims the invention may be practiced otherwise than as specifically described above.

