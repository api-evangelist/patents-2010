---

title: Stateless animation, such as bounce easing
abstract: An animation system is described herein that uses a transfer function on the progress of an animation that realistically simulates a bounce behavior. The transfer function maps normalized time and allows a user to specify both a number of bounces and a bounciness factor. Given a normalized time input, the animation system maps the time input onto a unit space where a single unit is the duration of the first bounce. In this coordinate space, the system can find the corresponding bounce and compute the start unit and end unit of this bounce. The system projects the start and end units back onto a normalized time scale and fits these points to a quadratic curve. The quadratic curve can be directly evaluated at the normalized time input to produce a particular output.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09262855&OS=09262855&RS=09262855
owner: Microsoft Technology Licensing, LLC
number: 09262855
owner_city: Redmond
owner_country: US
publication_date: 20100318
---
Simulation is often used to approximate natural phenomena such as the laws of physics in software applications. For example games often simulate real world experiences such as racing flying and so forth. Simulation typically involves a complex software model designed to mimic behavior of a physical system. Software applies Inputs to the model similar to real world inputs. For example a gravity simulator may receive inputs about the mass of an object its aerodynamic properties one or more forces applied to the object and so forth.

Simulation can also be useful in user interface animation to increase the reality of interacting with objects experienced by users of the interface. For example folders that animate from one location to another are easier to understand than those that simply disappear and reappear at another location. One type of user interface animation is a bounce which refers to the desirability of an object having some amount of elasticity as it moves from one location to another. For example a software designer may want an object dragged from one location to another to bounce at the destination as it would if physically dropped. The bounce calls the user s attention to the object s new location and gives the object a more realistic feel making the interface more pleasing to use.

Unfortunately typical simulations are difficult to use for user interface animation and similar applications. It is often not feasible to setup and run a complex model that includes state information stored over time. The requirements of such models are resource intensive and do not allow for starting the simulation in the middle or even running the simulation in reverse. Rather such models often are designed to run from start to finish uninterrupted. Animation for a user interface is typically more declarative in that an application author knows a from and to value and wants an animation to occur for values in between. Such animations are more difficult than simple linear interpolation.

An animation system is described herein that uses a transfer function on the progress of an animation that realistically simulates a bounce behavior. The transfer function maps normalized time and allows a user to specify both a number of bounces and a bounciness factor. Given a normalized time input the animation system maps the time input onto a unit space where a single unit is the duration of the first bounce. In this coordinate space the system can find the corresponding bounce and compute the start unit and end unit of this bounce. The system projects the start and end units back onto a normalized time scale and fits these points to a quadratic curve. The quadratic curve can be directly evaluated at the normalized time input to produce a particular output. Thus the animation system provides a simulation for which 1 the user has customizable control over the number of bounces and the bounciness 2 the system can statelessly evaluate the output of the transfer function at any point without simulating prior states or output values and 3 the resulting transfer function accurately simulates the motion of an object falling under gravity and bouncing with elastic collisions.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

An animation system is described herein that uses a transfer function on the progress of an animation that realistically simulates a bounce behavior such as a bouncing ball . The transfer function maps normalized time and allows a user to specify both a number of bounces and a bounciness relative amplitude between the peaks of two consecutive bounces . Given a normalized time input the animation system maps the time input onto a unit space where a single unit is the duration of the first bounce. In this coordinate space the system can find the corresponding bounce and compute the start unit and end unit of this bounce. The system projects the start and end units back onto a normalized time scale calculates an amplitude of the bounce to define a midpoint and fits these points to a quadratic curve. The quadratic curve can be directly evaluated at the normalized time input to produce a particular output e.g. height of the bounce at the given time . Thus the animation system provides a simulation for which 1 the user has customizable control over the number of bounces and the bounciness 2 the system can evaluate the output of the transfer function at any point without simulating prior states or output values i.e. stateless and 3 the resulting transfer function accurately simulates the motion of an object falling under gravity and bouncing with friction e.g. each bounce is symmetric and a duration of each bounce is proportional to its peak amplitude .

Unlike an absolute value of a sine wave with dampened exponential decay the transfer function of the animation system provides for bounces that speed up properly at smaller bounces i.e. the bounces are closer together as they would occur naturally and whose amplitude is symmetric around peaks i.e. the amplitude is not smaller after the bounce as would occur naturally if air friction is ignored . Symmetric bouncing is visually more accurate because air friction on this scale is negligible so the only loss in energy is due to the collision with the ground between bounces. In addition a sine wave with dampened exponential decay may not pass through a destination point as expected. Thus although the animation system can be used with a variety of transfer functions including sine wave based simulations in its default implementation the system provides results that are more realistic.

The application interface component provides an interface between a software application and the system . An application may include many user interface objects or other visual objects for which the animation provided by the system produces a visually pleasing effect. Thus the application may invoke the system to calculate an object s position during an animation so that the application can display the object appropriately. For example an application may animate a bouncing ball or a window moving from one location to another with a bounce effect and use the system to determine the object s position at regular intervals over a period of the animation. The application interface component may include an object model classes functions and other common application interface techniques for an application to provide data to the system and receive one or more results.

The input component receives one or more parameters that affect a particular animation. For example the input component may receive a bounciness coefficient and a current time at which the software application wants to determine the position of an object having the specified bounciness. The input component may receive parameters based on initialization values of a declared class that inherits from a class provided by the system as well as function parameters or other method of passing data between software components. The input component may also receive an animation mode that it provides to the animation mode component to alter behavior of the animation produced by the system .

The animation mode component receives one or more animation modes from the software application and modifies behavior of the system based on a received mode. In some embodiments the animation system provides multiple modes. For example for a bounce animation the system may allow an object to ease in i.e. opposite of gravity smaller to larger bounces ease out i.e. like an object dropped under the influence of gravity or both ease in and out i.e. start small and bounce to a peak then trail off again . If an ease in is thought of as a function of time f t that provides amplitude on a unit scale then ease out is the reverse e.g. 1.0 f 1.0 t .

The stateless animation component determines a current animated value of an animated object based on a specified time. The stateless animation component uses a stateless transfer function to determine the current animated value without performing a long simulation from the beginning to the current time. The software application may invoke the system repeatedly at regular intervals e.g. in an animation loop to determine a present position at which to display the animated object. The stateless animation component may provide a variety of animation types or transfer functions through the animation mode component that an application can select to obtain different animation behavior.

The output component provides the current animated value of the animated object as a result to the software application. For example the software application may invoke a class method of the system and receive the result as a return parameter. The animated value may include a position or other animated properties such as color rotation angle and so forth. Although position is used herein as an example a position may include these other types of animated values. The output component may also communicate with a display component to display the animated object. As the software application invokes the system over time the output component provides the current position of the animated object at whatever time is specified by the software application.

The display component optionally displays the animated object. While the system may be used in some embodiments by software applications that provide their own display capabilities and use the system to receive position values and other animation characteristics the system may also be implemented in a manner in which the system provides the displayed animation through the display component . The system may provide a default display capability that applications can override for more complex object types or animations.

The computing device on which the system is implemented may include a central processing unit memory input devices e.g. keyboard and pointing devices output devices e.g. display devices and storage devices e.g. disk drives or other non volatile storage media . The memory and storage devices are computer readable storage media that may be encoded with computer executable instructions e.g. software that implement or enable the system. In addition the data structures and message structures may be stored or transmitted via a data transmission medium such as a signal on a communication link. Various communication links may be used such as the Internet a local area network a wide area network a point to point dial up connection a cell phone network and so on.

Embodiments of the system may be implemented in various operating environments that include personal computers server computers handheld or laptop devices multiprocessor systems microprocessor based systems programmable consumer electronics digital cameras network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and so on. The computer systems may be cell phones personal digital assistants smart phones personal computers programmable consumer electronics digital cameras and so on.

The system may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures and so on that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

Continuing in decision block if the received animation mode specifies an ease in animation behavior then the component continues at block else the component continues at block . Continuing in block the component invokes a stateless animation component to determine a current position of an animated object based on the received input parameters. In the example shown an ease in animation is handled by the transfer function of the stateless animation component by default so that the time is passed in directly although it may be normalized first to a unit scale to the stateless animation component to receive the appropriate resulting position back.

Continuing in decision block if the received animation mode specifies an ease out animation behavior then the component continues at block else the component continues at block . Continuing in block the component invokes a stateless animation component to determine a current position of an animated object based on the received input parameters. In the example shown an ease in animation is handled by the transfer function of the stateless animation component by default so that for an ease out behavior the time scale is reversed by passing 1.0 minus the input time. The result is also flipped by subtracting the result from 1.0 to receive the appropriate resulting position back.

Continuing in decision block corresponding to an ease in out animation mode if the received input time is less than 0.5 halfway complete then the component continues at block else the component continues at block . Continuing in block the component invokes a stateless animation component to determine a current position of an animated object based on the received input parameters. In the example shown the first half of the animation is an ease in and thus the input time is doubled and the result is cut in half. This fits an ease in animation to the first half of the unit time scale. If on the other hand execution continues to block where the second half of the animation is an ease out then the input time is reversed the result is flipped and the animation is scaled to fit the appropriate half of the unit time scale.

Continuing in block the component returns the result from the stateless animation component as a response to the caller. The result indicates a current position of the animated object in a particular coordinate system. After block these steps conclude. Note that although the stateless animation component is shown here as producing a default ease in animation and the input parameters and result are modified to produce other behaviors other transfer functions can be used with the system that may include a different default behavior and other modifications of the input parameters and result to produce different behaviors. Thus the implementation shown is provided as an example to demonstrate one function of the system without limiting other possible implementations.

Continuing in block the component projects a start and end time of the current bounce into time space. The component can determine the start and end times based on the current bounce and the bounciness coefficient. A proper bounce takes less and less time as the animation progresses for ease out . Many bounce techniques fail to properly simulate this aspect of bouncing animation unlike the animation system described herein. Continuing in block the component determines a duration and peak of the current bounce to which to fit a curve. For example the peak can be found at the mid point of the start and end time and the amplitude of the peak can be determined based on the bounciness coefficient.

Continuing in block the component determines a curve that fits the determined start time end time and peak of the current bounce. For example the system may fit a quadratic curve that passes through the start and end time points and peaks at an amplitude that matches the bounce peak. Continuing in block the component returns a resulting position based on the determined curve and the received input parameters. The time specified in the input parameters will determine which position on the fit curve to return. Note that no state is stored by the steps described herein between iterations. The system can efficiently determine the current position based on the received input parameters without executing a costly simulation from start to finish or from start to a current time . After block these steps conclude.

A bounce transfer function as described herein may be a function of three input parameters number of bounces bounciness and time t . The bounciness is a relative duration between two consecutive bounces. For example a bounciness of two means that the second bounce is twice as high as the first bounce. Time is normalized time between 0 and 1. In some embodiments given the input values above the bounce transfer function follows the steps below to compute the bounce height.

Computes which bounce the animation would be in based on the normalized time. This will give e.g. 2.3 which means t is 30 into the second bounce.

Truncate the previous value to the nearest integer less than bounceAtT. 2.3 will become 2 for start and 3 for end.

8. Given the start time and end time of the bounce in the normalized time scale the system computes the duration and the peak of the curve and then fits a quadratic curve given these set of points.

9. The final step in evaluating the bounce transfer function is to evaluate this quadratic equation at time t 

The graph shows a sample bounce function. The transfer function for a bounce has a domain in the 0 1 range and a range in the 0 1 range. The bounces are computed such that the peak of the last bounce is at 1.0. The number of bounces for a bounce function does not include the last half bounce bringing it back to the peak. Thus the graph shows a bounce function with two bounces. The graph shows the same bounce function with additional parameters defined by the animation system. The system defines a duration of the first bounce to be one unit. The duration of subsequent bounces depends on the bounciness factor. For inputs 2 and 2 then the total units will be five 1 for first bounce 2 for second bounce 4 2 for the last half bounce to get back to the peak of the bounce . In graph the current time t is part way into the second bounce so start will be 1 and end will be 2.

The following example C code shows one possible implementation of the steps described herein and illustrated further with reference to . The EaseInCore function provides a function that returns a current position for an ease in type of bounce animation based on input parameters that specify a current normalized time a number of bounces and a bounciness factor. The Ease function wraps the EaseInCore function to provide other animation modes such as ease out and ease in out as described further herein.

In some embodiments the animation system is implemented in an application programming interface API that developers can invoke to provide animations for their software applications. For example implementations of the animation system are currently provided in the SILVERLIGHT 3.0 and WINDOWS Presentation Foundation 4.0 APIs. The animation system can also be integrated into a single software application or packaged differently in other APIs or graphics libraries as appropriate for a particular application.

The stateless nature of the animation provided by the animation system allows common user interface paradigms to be implemented more easily. For example because the system can efficiently determine a position of the animation at any given time it is easy to reverse the animation or seek to a particular position in the animation simply by specifying the right time parameters. Thus recording of user interface UI behavior and later playback are provided inherently by the system. Previous simulation techniques become unwieldy in such situations.

In some embodiments the animation system caches parts of the bounce transfer function. For example for a given bounciness and bounce it is possible for the system to avoid determining a curve at every call and the system can instead cache the determined curve and use the cached curve to respond to later calls to the transfer function. Such techniques are optimizations that do not affect the results provided by the system but may improve the efficiency particularly for performance sensitive uses of the system e.g. a user interface function invoked at high frequency .

In some embodiments the animation system may be provided as a delegate or via inheritance rather than as an interface. An interface has the advantage integrating more easily with declarative systems such as an Extensible Application Markup Language XAML based declarative user interface definition. However it is also possible to provide the system to third party code using other programming techniques such as delegates was will be recognized by those of ordinary skill in the art. The system may also provide in some embodiments its own internal clock that progresses the animation forward and calls out to an external software application with the progress of the animation. These and other variations are not explicitly described herein but are within the skill of those skilled in the art.

From the foregoing it will be appreciated that specific embodiments of the animation system have been described herein for purposes of illustration but that various modifications may be made without deviating from the spirit and scope of the invention. Accordingly the invention is not limited except as by the appended claims.

