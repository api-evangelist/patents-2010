---

title: Optimizations for implementing multi-stack stack hosts
abstract: Architecture that includes optimizations for “Bump-in-the-API” (BIA) as employed for multi-stack hosts. These optimizations reduce the limitations imposed by the existing translation technologies by simplifying the implementation and addressing possible compatibility issues. More specifically, the architecture discloses optimizations that use a preconfigured NAT64 prefix for mapping of NAT64 IPv6 addresses in the prefix subnet to IPv4 addresses, without a mapping table (stateless), use configuration information for enabling API translation per application (resolves possible compatibility issues), and use a local IPv4 socket and a data pump to reduce the number of translated API calls.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08484666&OS=08484666&RS=08484666
owner: Microsoft Corporation
number: 08484666
owner_city: Redmond
owner_country: US
publication_date: 20100913
---
As technology continues to evolve there is a never ending need for transition mechanisms that bridge the gap between legacy and newer architectures. Dual stacks can function as a transition mechanism between these architectures. In one specific transition example for IP Internet protocol addresses a technique called Bump in the API BIA is employed for multi stack hosts to transition between IPv4 and IPv6 hosts. For example this enables hosts to communicate with other IPv6 hosts using existing IPv4 applications. However a translator is involved and requires one or more tables to be created and utilized to facilitate the transition processing.

The following presents a simplified summary in order to provide a basic understanding of some novel embodiments described herein. This summary is not an extensive overview and it is not intended to identify key critical elements or to delineate the scope thereof. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

The disclosed architecture includes optimizations for Bump in the API BIA as employed for multi stack hosts. These optimizations reduce the limitations imposed by the existing translation technologies by simplifying the implementation and addressing possible compatibility issues. This is accomplished by applying a well defined reversible stateless transformation for different transport address versions such as IPv4 and IPv6. In a specific implementation the architecture discloses optimizations that use a preconfigured NAT64 prefix for mapping of NAT64 IPv6 addresses in the prefix subnet to IPv4 addresses without a mapping table stateless use configuration information for enabling API translation per application resolves possible compatibility issues and use a local IPv4 socket and a data pump to reduce the number of translated API calls.

To the accomplishment of the foregoing and related ends certain illustrative aspects are described herein in connection with the following description and the annexed drawings. These aspects are indicative of the various ways in which the principles disclosed herein can be practiced and all aspects and equivalents thereof are intended to be within the scope of the claimed subject matter. Other advantages and novel features will become apparent from the following detailed description when considered in conjunction with the drawings.

The disclosed architecture introduces optimizations for Bump in the API BIA implementations of multi stack hosts and address possible compatibility issues between hosts of different IP infrastructures e.g. IPv4 and IPv6 . Specifically the optimizations include but are not limited to a well defined reversible stateless transformation that when implemented performs address mapping between disparate transport address versions e.g. IPv4 and IPv6 . In one specific reversible stateless transformation technique for NAT64 provides network address translation NAT from IPv6 to IPv4 networks IPv6 addresses use a preconfigured NAT64 prefix for mapping of NAT64 IPv6 addresses in the prefix subnet to IPv4 addresses without a mapping table stateless use application configuration information that for enables API translation per application and possible compatibility issues and optimize function mapping using a local IPv4 socket and data pump to reduce the number of translated API application programming interface calls.

Reference is now made to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding thereof. It may be evident however that the novel embodiments can be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate a description thereof. The intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

As described in greater detail hereinbelow the local host can further comprise a configuration component from which the API translation component accesses the configuration information associated with the application to determine if translation is needed for the application. The API translation component can further comprise an address mapper that performs the transport address version translation. The address mapper reconstructs a second transport address version e.g. IPv6 into a first transport address version e.g. IPv4 by stripping a prefix from the second transport address version and adding the prefix to the first transport address version. This translation operation is performed statelessly in that no address mapping table is utilized.

The API translation component can further comprise a connect mapper that intercepts a function call to connect to a transport address creates a local connect socket and establishes a connection with the remote host via the local connect socket. The connect mapper creates a listening socket that monitors communications between the remote host and the application via the local connect socket.

The API translation component includes other components such as a name resolver an address mapper a connect mapper and a data pump . When an IPv4 only client application e.g. application connects to an IPv6 server e.g. server host the server host may actually be an IPv4 only server behind a NAT64 device a device that provides network address translation from IPv6 to IPv4 networks .

Obtaining and knowing the NAT64 prefix the address mapper can create an IPv4 address by stripping this prefix from an IPv6 address and then reconstructing the IPv6 address by adding the prefix to the IPv4 address. This is a stateless no mapping table required process.

This stateless reversible transformation technique can be used for reducing usage of an IPv4 address pool and the size of any mapping table used for specific purposes. For example the address mapper can use this technique for IPv6 addresses which match the configured NAT64 prefix and use the pool for other addresses. Alternatively if the functionality is required only for NAT64 addresses which share the same prefix the pool and the mapping table components may be eliminated altogether.

Another conventional limitation is that mappings are created based on name resolution and therefore do not support IPv4 only applications that do not perform name resolution and attempt connection to a server using a pre configured IPv4 address. Assuming the IPv4 server host is accessible through the NAT64 device the address mapper can construct an IPv6 address by deconstructing the IPv6 address into an IPv4 address obtain the prefix and then add the configured NAT64 prefix to the IPv4 address for IPv4 compatibility.

In operation at the application initiates an IPv4 name resolution call. At the API translation component consults the configuration information for the application stored in the configuration component to determine whether to intercept the call for this application . At the API translation component performs IPv6 name resolution using the name resolver component . At the API translation component deduces the IPv4 address using the NAT64 prefix. At the application creates an IPv4 socket a socket being structured by an IP address and a port number and performs a connect API call via the connect mapper component .

At the API translation component reconstructs the IPv6 address using the NAT64 prefix. At the API translation component creates an IPv6 socket as part of a data pump and connects to the destination host behind a NAT64 device . At the API translation component creates a local IPv4 listening socket and allows the application to connect to the listening socket . At the application communicates with the local IPv4 listening socket created by the API translation component . At the API translation component pumps the data between the IPv4 listening socket and the IPv6 socket using the data pump . At the API translation component communicates with the destination host behind the NAT64 device .

In other words in the context of IPv4 and IPv6 transport addressing for example the optimization of address mapping for NAT64 IPv6 addresses includes the address mapper which is responsible for maintaining a table of pairs of an IPv4 address and an IPv6 address. The IPv4 addresses are assigned from an IPv4 address pool consisting of private addresses. When the number of IPv4 applications communicating with IPv6 hosts is large the available address spaces might be exhausted and smart techniques might be required for managing the pool. We propose a solution which may reduce the pool use or with the limitation discussed below eliminate the pool altogether.

In some cases interfering with the API stack may lead to undesirable results. For example supporting connections without prior name resolution by assuming the IPv4 address is NAT64 able may result in problems. In case this assumption is wrong e.g. the IPv4 address actually belongs to an IPv4 host in the same network and no API translation is actually required interfering with the API will break the application application configuration information created and maintained to enable or disable API translation on a per application basis. For example this can be accomplished by specifying an include or exclude list of executable files in the configuration component for which the API translation will apply.

The disclosed architecture also creates and utilizes the local listening socket for optimizing function mapping. When the application or application creates a socket and attempts to connect to an IPv4 address step in the connect function call is intercepted by the API translator component . At this point the connect mapper component obtains an IPv6 address from the address mapper component creates the IPv6 socket and then establishes a connection with the destination host step in .

The connect mapper component then creates the IPv4 listening socket to listen on the IPv4 loopback address on a dynamically allocated port X step in the diagram . The connect mapper component changes the IPv4 destination address in the connect call to 127.0.0.1 X and lets the default socket API implementation to continue handling the call. The socket API connects to 127.0.0.1 X and the connect mapper component accepts this connection. The control then is returned to the application .

From the perspective of the application connection is directly to the remote host when actually connected to the API connect mapper component and starts communication step in . In turn the API connect mapper component has sockets to both the local IPv4 application and the remote IPv6 host and can start a data pump step in . This results in the application exchanging data with the remote host step .

Using this technique only the connect function and some auxiliary functions like getpeername are modified. Functions that actually transfer data do not require modification. For UDP the operation is similar except that the API translator sockets creation is delayed till sendto or recvfrom call. Even then the actual data transfer is handled by the default API implementation.

Put another way a computer implemented system is provided that includes a multi stack local host having an application of a first transport address version API that seeks communication with a remote host of a second transport address version API a configuration component that stores application configuration information accessible for a given application seeking communications with the remote host and an API translation component that facilitates the communication between the application and the remote host. The API translation component is associated with or includes a name resolver component that performs name resolution based on the application configuration information an address mapper component that statelessly deduces and reconstructs an address of the first transport address version into an address of the second transport address version and a connect mapper component that creates sockets for the application and the remote host via which the application communicates with the remote host.

The connect mapper component creates a data pump with an application listening socket and remote host socket that enables communications between the application and the remote host. The address mapper component performs transport address version translation. The address mapper reconstructs a second transport address version into a first transport address version by stripping a prefix from the second transport address version and adding the prefix to the first transport address version. The first transport address version is IPv4 and the second transport address version can be IPv6 for example. The prefix is based on a network address translation device imposed between the remote host and the application. The application can be of the first transport address version that seeks to communicate with remote host which is of the first transport address version via a network address translation component. The stack can be based on the bump in the API technology.

Included herein is a set of flow charts representative of exemplary methodologies for performing novel aspects of the disclosed architecture. While for purposes of simplicity of explanation the one or more methodologies shown herein for example in the form of a flow chart or flow diagram are shown and described as a series of acts it is to be understood and appreciated that the methodologies are not limited by the order of acts as some acts may in accordance therewith occur in a different order and or concurrently with other acts from that shown and described herein. For example those skilled in the art will understand and appreciate that a methodology could alternatively be represented as a series of interrelated states or events such as in a state diagram. Moreover not all acts illustrated in a methodology may be required for a novel implementation.

As used in this application the terms component and system are intended to refer to a computer related entity either hardware a combination of software and tangible hardware software or software in execution. For example a component can be but is not limited to tangible components such as a processor chip memory mass storage devices e.g. optical drives solid state drives and or magnetic storage media drives and computers and software components such as a process running on a processor an object an executable a data structure stored in volatile or non volatile storage media a module a thread of execution and or a program. By way of illustration both an application running on a server and the server can be a component. One or more components can reside within a process and or thread of execution and a component can be localized on one computer and or distributed between two or more computers. The word exemplary may be used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs.

Referring now to there is illustrated a block diagram of a computing system that executes optimization for multi stack hosts in accordance with the disclosed architecture. In order to provide additional context for various aspects thereof and the following description are intended to provide a brief general description of the suitable computing system in which the various aspects can be implemented. While the description above is in the general context of computer executable instructions that can run on one or more computers those skilled in the art will recognize that a novel embodiment also can be implemented in combination with other program modules and or as a combination of hardware and software.

The computing system for implementing various aspects includes the computer having processing unit s a computer readable storage such as a system memory and a system bus . The processing unit s can be any of various commercially available processors such as single processor multi processor single core units and multi core units. Moreover those skilled in the art will appreciate that the novel methods can be practiced with other computer system configurations including minicomputers mainframe computers as well as personal computers e.g. desktop laptop etc. hand held computing devices microprocessor based or programmable consumer electronics and the like each of which can be operatively coupled to one or more associated devices.

The system memory can include computer readable storage physical storage media such as a volatile VOL memory e.g. random access memory RAM and non volatile memory NON VOL e.g. ROM EPROM EEPROM etc. . A basic input output system BIOS can be stored in the non volatile memory and includes the basic routines that facilitate the communication of data and signals between components within the computer such as during startup. The volatile memory can also include a high speed RAM such as static RAM for caching data.

The system bus provides an interface for system components including but not limited to the system memory to the processing unit s . The system bus can be any of several types of bus structure that can further interconnect to a memory bus with or without a memory controller and a peripheral bus e.g. PCI PCIe AGP LPC etc. using any of a variety of commercially available bus architectures.

The computer further includes machine readable storage subsystem s and storage interface s for interfacing the storage subsystem s to the system bus and other desired computer components. The storage subsystem s physical storage media can include one or more of a hard disk drive HDD a magnetic floppy disk drive FDD and or optical disk storage drive e.g. a CD ROM drive DVD drive for example. The storage interface s can include interface technologies such as EIDE ATA SATA and IEEE 1394 for example.

One or more programs and data can be stored in the memory subsystem a machine readable and removable memory subsystem e.g. flash drive form factor technology and or the storage subsystem s e.g. optical magnetic solid state including an operating system one or more application programs other program modules and program data .

The one or more application programs other program modules and program data can include the entities and components of the system of the entities and components of the system of and the methods represented by the flowcharts of for example.

Generally programs include routines methods data structures other software components etc. that perform particular tasks or implement particular abstract data types. All or portions of the operating system applications modules and or data can also be cached in memory such as the volatile memory for example. It is to be appreciated that the disclosed architecture can be implemented with various commercially available operating systems or combinations of operating systems e.g. as virtual machines .

The storage subsystem s and memory subsystems and serve as computer readable media for volatile and non volatile storage of data data structures computer executable instructions and so forth. Such instructions when executed by a computer or other machine can cause the computer or other machine to perform one or more acts of a method. The instructions to perform the acts can be stored on one medium or could be stored across multiple media so that the instructions appear collectively on the one or more computer readable storage media regardless of whether all of the instructions are on the same media.

Computer readable media can be any available media that can be accessed by the computer and includes volatile and non volatile internal and or external media that is removable or non removable. For the computer the media accommodate the storage of data in any suitable digital format. It should be appreciated by those skilled in the art that other types of computer readable media can be employed such as zip drives magnetic tape flash memory cards flash drives cartridges and the like for storing computer executable instructions for performing the novel methods of the disclosed architecture.

A user can interact with the computer programs and data using external user input devices such as a keyboard and a mouse. Other external user input devices can include a microphone an IR infrared remote control a joystick a game pad camera recognition systems a stylus pen touch screen gesture systems e.g. eye movement head movement etc. and or the like. The user can interact with the computer programs and data using onboard user input devices such a touchpad microphone keyboard etc. where the computer is a portable computer for example. These and other input devices are connected to the processing unit s through input output I O device interface s via the system bus but can be connected by other interfaces such as a parallel port IEEE 1394 serial port a game port a USB port an IR interface short range wireless e.g. Bluetooth and other personal area network PAN technologies etc. The I O device interface s also facilitate the use of output peripherals such as printers audio devices camera devices and so on such as a sound card and or onboard audio processing capability.

One or more graphics interface s also commonly referred to as a graphics processing unit GPU provide graphics and video signals between the computer and external display s e.g. LCD plasma and or onboard displays e.g. for portable computer . The graphics interface s can also be manufactured as part of the computer system board.

The computer can operate in a networked environment e.g. IP based using logical connections via a wired wireless communications subsystem to one or more networks and or other computers. The other computers can include workstations servers routers personal computers microprocessor based entertainment appliances peer devices or other common network nodes and typically include many or all of the elements described relative to the computer . The logical connections can include wired wireless connectivity to a local area network LAN a wide area network WAN hotspot and so on. LAN and WAN networking environments are commonplace in offices and companies and facilitate enterprise wide computer networks such as intranets all of which may connect to a global communications network such as the Internet.

When used in a networking environment the computer connects to the network via a wired wireless communication subsystem e.g. a network interface adapter onboard transceiver subsystem etc. to communicate with wired wireless networks wired wireless printers wired wireless input devices and so on. The computer can include a modem or other means for establishing communications over the network. In a networked environment programs and data relative to the computer can be stored in the remote memory storage device as is associated with a distributed system. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers can be used.

The computer is operable to communicate with wired wireless devices or entities using the radio technologies such as the IEEE 802.xx family of standards such as wireless devices operatively disposed in wireless communication e.g. IEEE 802.11 over the air modulation techniques with for example a printer scanner desktop and or portable computer personal digital assistant PDA communications satellite any piece of equipment or location associated with a wirelessly detectable tag e.g. a kiosk news stand restroom and telephone. This includes at least Wi Fi or Wireless Fidelity for hotspots WiMax and Bluetooth wireless technologies. Thus the communications can be a predefined structure as with a conventional network or simply an ad hoc communication between at least two devices. Wi Fi networks use radio technologies called IEEE 802.11x a b g etc. to provide secure reliable fast wireless connectivity. A Wi Fi network can be used to connect computers to each other to the Internet and to wire networks which use IEEE 802.3 related media and functions .

What has been described above includes examples of the disclosed architecture. It is of course not possible to describe every conceivable combination of components and or methodologies but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly the novel architecture is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

