---

title: Identifying test cases to be run after changes to modules of a software application
abstract: An aspect of the present invention facilitates identification of test cases to be run after changes to modules of a software application. In one embodiment, a reference data is generated by inspecting the instructions (static analysis) forming the modules of the software application, with the reference data specifying a corresponding set of modules in the application that are referenced by each of the modules in the application. The reference data is then examined to find a referencing set of modules which reference any of the changed modules either as immediate reference or multi-level reference through other modules. Test cases invoking any of the modules in the referencing set are identified as suitable test cases to be run.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08694966&OS=08694966&RS=08694966
owner: Oracle International Corporation
number: 08694966
owner_city: Redwood Shores
owner_country: US
publication_date: 20100304
---
The present disclosure relates to software testing and more specifically to identifying test cases to be run after changes to modules of a software application.

A software application is generally organized in the form of modules. Each module contains a corresponding set of instructions which are together compiled linked etc. as is well known in the relevant arts. Modules are maintained in the form of source files class files JAR files etc. as is also well known in the relevant arts.

There are often changes made to specific modules with a view to meeting specific objectives. For example during the development phase of the software application developers may modify modules to add modify functionality and during maintenance phase developers may modify modules to fix errors referred to as bugs also found after deployment of the software application.

It is often required to identify test cases to be run after such changes typically to check whether the changes meet the objectives as well as do not cause unintended consequences e.g. create new errors disrupting pre existing functionality etc. in the operation of the software application. Each test case is designed to contain the inputs and logic to make operative specific desired portions of the corresponding modules and to potentially check whether the output resulting from such operation satisfies a desired condition.

It is generally desirable that an optimum set of test cases be identified such that the desired checking is performed as well as unneeded test cases are not run. Various aspects of the present invention address one or more of such requirements as described below in further detail.

In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements. The drawing in which an element first appears is indicated by the leftmost digit s in the corresponding reference number.

An aspect of the present invention facilitates identification of test cases to be run after changes to modules of a software application. In one embodiment a reference data is generated by inspecting the instructions static analysis forming the modules of the software application with the reference data specifying a corresponding set of modules in the application that are referenced by each of the modules in the application. The reference data is then examined to find a referencing set of modules which reference any of the changed modules either as immediate reference or multi level reference through other modules. Test cases invoking any of the modules in the referencing set are identified as suitable test cases to be run.

In an embodiment the test cases are also treated as referencing modules of the specific modules invoked and the reference data accordingly reflects such a relationship. Accordingly the referencing set of modules includes the test cases as well as the modules tested. Modules of test case type in the referencing set of modules accordingly form the suitable test cases to be run.

It may be appreciated that the reference data is generated by static analysis that is inspection of the instructions forming the application in contrast to dynamic analysis approaches such as execution traces which require the modified application formed by the merging of the changes with the software application to be executed. Such static analysis is generally desirable in new development projects where code design requirements change frequently and accordingly the generation of execution traces for every change adds substantial overhead to the development process.

Several aspects of the present invention are described below with reference to examples for illustration. However one skilled in the relevant art will recognize that the invention can be practiced without one or more of the specific details or with other methods components materials and so forth. In other instances well known structures materials or operations are not shown in detail to avoid obscuring the features of the invention. Furthermore the features aspects described can be practiced in various combinations though only some of the combinations are described herein for conciseness.

Merely for illustration only representative number type of systems is shown in . Many environments often contain many more systems both in number and type depending on the purpose for which the environment is designed. Each system device of is described below in further detail.

Network provides connectivity between developer systems A C and server system . Network may be implemented using protocols such as Transmission Control Protocol TCP and or Internet Protocol IP well known in the relevant arts. In general in TCP IP environments a TCP IP packet is used as a basic unit of transport with the source address being set to the TCP IP address assigned to the source system from which the packet originates and the destination address set to the TCP IP address of the target system to which the packet is to be eventually delivered.

Each of developer systems A C represents a system such as a personal computer workstation mobile station etc. used by users developers to modify change some of the modules forming a software application for example to add modify a functionality of the application fix errors bugs uncovered in the application etc. Accordingly the developers may retrieve store the desired modules sought to be changed from code repository by sending appropriate requests and receiving corresponding responses to source control executing in server system . After incorporating the desired changes in the modules the developers may send requests for testing the changed modules to testing tool executing in server system . The requests may be generated using appropriate interfaces.

Server system represents a server system such as a web application server executing code management testing softwares such as testing tool and source control capable of performing tasks requested by developers using one of developer systems A C. The softwares may perform the requested tasks on data maintained internally or on external data stored in code repository and test case database and then send the result of performance of the tasks to the requesting developer system.

Source control represents a code management software controlling access to different developers of the source code of modules maintained in code repository . Source control also keeps track of the specific changes made to each of the modules by the different developers by maintaining multiple versions of the same module in code repository . Such tracking of changes may be required to ensure that the same module is not modified by different developers at the same time to version the software application for reverting back to earlier versions of the modules to undo certain changes etc. The process of storing a module in code repository along with associated information such as the developer identifier version number etc. is commonly referred to as checking in while the process of retrieving the module from code repository is referred to as checking out .

Typically source control enables multiple versions of a software application to be formed from code repository . There are generally several testing versions that can be formed with each testing version having specific versions e.g. by cutoff date by functionalities of the modules as specified by a developer. Many of the modules can be untested in the testing version. Developers may indicate the specific modules which have been successfully tested and are ready to be merged into a production version. Accordingly a production version formed by source control of the software application contains the latest successfully tested versions of the modules and is ready for deployment.

Each of code repository and test case database represents a non volatile storage facilitating storage and retrieval of a collection of data by one or more softwares such as testing tool and source control executing in server system . In particular code repository is used to maintain modules forming a software application in a source format that can be readily edited by developers. Code repository may maintain multiple versions of the same module to keep track of the changes modifications made to the same module.

It is assumed that code repository contains modules of a software application developed according to test driven design development TDD approach of development. As is well known in the relevant arts in this approach test cases may be created first according to a functional specification and the modules are then developed while ensuring that the test cases are satisfied. In such kind of development environment it may be important to make sure that any change to a module does not result in failure of test cases before merging of the modules. Therefore in such kind of development environment code merging is tightly coupled with execution of unit test cases and merge is allowed only after successful execution of test cases.

Test case database maintains the test cases used to test the functionalities of modules forming a software application. Each test case may specify a set of conditions to be checked during the execution of a corresponding module s with module determined to be working correctly pass against a test case if all of the corresponding set of conditions are determined to be satisfied true and to be not working properly failed otherwise. In general a large number of tests cases are required to be created and run to determine that a software application is functioning correctly. Furthermore test cases may be created to cover test the functionality of specific errors bugs uncovered during previous testing.

Testing tool represents a testing software framework designed to run test cases maintained in test case database while executing the software application and to determine the status pass or fail of each of the run test cases based on whether the corresponding set of conditions are satisfied or not. Accordingly at least for the TDD approach it may be necessary that testing tool successfully run the test cases in test case database before merging of the modules into the production version. It may be appreciated that the running of a large number of test cases before each merge may result in longer merge time. It may be accordingly desirable that an optimal set of test cases be identified and run.

In one approach the specific optimal set of test cases to be run is typically specified by a developer using one of developer systems A C. The developer may manually identify the optimal set by including the minimal number of test cases that covers testing of the changed software modules. As noted in the Background section the running of the optimal set of test cases ensures that all the changes meet the desired objectives as well as do not cause unintended consequences e.g. create new errors disrupting pre existing functionality etc. in the operation of the software application.

Testing tool provided according to several aspects of the present invention identifies the test cases to be run after changes to modules of a software application by static analysis of the application. The term static analysis implies that the identification of the test cases is performed by inspecting the instructions contained in the modules forming the software application. Such static analysis of the modules in the application is in contrast to using dynamic approaches such as execution traces where the modified application formed as the result of merging the changed modules with the other modules of the application maintained in code repository is required to be executed.

The manner in which the optimal set of test cases to be run is identified using static analysis is described below with examples.

In addition some of the steps may be performed in a different sequence than that depicted below as suited to the specific environment as will be apparent to one skilled in the relevant arts. Many of such implementations are contemplated to be covered by several aspects of the present invention. The flow chart begins in step in which control immediately passes to step .

In step testing tool generates by inspecting the instructions forming the software application a reference dependency data specifying the modules referenced by each module of the software application. A module hereafter referencing module is said to have a reference to another module hereafter referenced module if the referencing module uses at least one of the functionalities provided by the referenced module. Such functionalities include for example if the referencing module invokes a procedure in the referenced module if the referencing module contains instructions that use data specified in the referenced module etc. It may be appreciated that the referenced modules may be determined by parsing and inspecting the instructions forming the referencing module in the application.

However in some scenarios such determination may not be possible for example when a referencing module loads and uses a set of modules dynamically during run time and the specific module that is referenced is determined based on external data e.g. user input configuration files etc. . In such scenarios additional data may be received from a developer indicating the specific modules that are indirectly referenced by each module of the application and the reference data may be generated based on the additional data provided by the developer. In one embodiment described below the additional data is provided in the form of properties files.

It may be appreciated that the reference data may be required to be generated only once for corresponding version in code repository and that the reference data may not be dependent on the immediately changed modules received below if the reference data is made persistent. Accordingly in one embodiment testing tool generates and stores reference data in a secondary storage in server system in step .

However in alternative embodiments testing tool may generate reference data based on inspection of the instructions forming the modules in code repository as well as the changed set of modules before check in merge and accordingly step may be performed only after receiving the changed set of modules in step .

In step testing tool receives an indication that a set of modules in a software application is changed modified. The indication including identifiers of the changed modules may be received from a developer using one of developer systems A C for testing the changes made to a software application. Alternatively testing tool may be designed to operate with source control to identify the set of modules changed in the application for example by requesting a testing version in response to receiving a request to test the software application from the developer.

In step testing tool finds the first level of modules having references to the changed set of modules received in step by examining the reference data in one embodiment after retrieving from a secondary storage . In other words testing tool checks the reference data for the modules that have been indicated to have at least one of the changed set of modules as a referenced module. Thus testing tool determines the modules that have immediate reference to any one of the changed set of modules.

In step testing tool adds the found referencing modules to the changed set of modules. The finding and addition of referencing modules follows from an understanding that any changes made to a referenced module may cause unintended consequences e.g. create new errors disrupting pre existing functionality etc. in the immediately referencing modules and accordingly an optimal set of test cases should not only test the changed modules but also any of the modules having a reference to the changed modules. Accordingly in one embodiment testing tool determines the optimal specific set of test cases based on the changed set of modules and the modules immediately referencing any one of the changed set of modules.

However it may be appreciated that as per the above understanding a second level of modules that have a reference to at least one of the newly found first level of modules immediately referencing the changed modules should also be tested to ensure no unintended consequences have been caused in second level of modules as well. Similar logic may be extended for a third level of modules referencing at least one of the second level of modules a fourth level referencing at least one of third level etc. Accordingly steps described below and are performed iteratively as a loop until all levels of modules referencing the changed set of modules are identified and included in the changed set based on the reference data.

Thus in step testing tool finds the next level of modules having references to the previous level of found modules by examining the reference data and in step testing tool checks whether there at least one module is newly found in step . In other words the finding of at least a single module indicates that the reference data needs to be searched for modules referencing the single module and according requires the steps of and to be repeated while the finding of no modules in step indicates that all the levels of modules referencing the changed set of modules have been found.

Thus in step control passes to step for determining the next level of modules if at least one module if found and to step for determination of test cases otherwise. It should be appreciated that the loop of steps and operates to find the referencing modules that has a multi level reference through other modules to any of the changed set of modules of step .

In step testing tool determines the optimal specific set of test cases based on the final changed set of modules containing the original set of modules changed by the developers received in step as well as all the modules at different levels referencing at least one of the original set of changed modules. The determination of the test cases based on the final changed set of modules may be performed in a known way.

In one approach the test cases are determined based on a mapping data maintained by the developers of the modules test cases. The mapping data specifies for each test case specified for the application in test case database the corresponding set of modules in the application tested accessed by the test case. Testing tool then determines the specific set of test cases to be run by checking whether each of the modules in the final changed set is specified in the mapping data and including those test cases that are indicated to access test at least of the modules in the optimal set. Such an approach may be used when the modules in the software application correspond to code files containing instructions according to a programming language while each of the test cases is in the form of a test script containing instructions according to a scripting language different from the programming language.

In another approach the test cases used to test a software application are also included as modules of the application prior to generation of the reference data. As such it may be appreciated that the performance of step ensures that the mapping data described above is also generated as part of the reference data with the test cases indicated as referencing modules and the corresponding set of modules accessed tested indicated as referenced modules. Furthermore the performance of the steps of through ensures that the optimal set of test cases is also included in the final changed set of modules.

Accordingly testing tool determines the specific set of test cases to be run by checking the type of each of the modules in the final changed set and including the modules of type test case in the optimal set. Such an approach may be used when the modules as well as the test scripts are specified according to the same programming language. The flow chart ends in step .

Thus the set of test cases to be run after changes to modules of a software application are identified using static analysis of the application. The identified optimal set of test cases may then be run by testing tool to determine whether the changes can be merged if all test cases pass or not. The failing of a test case may indicate that the changes originally done by the developer has not met the desired objectives or has caused unintended consequences e.g. create new errors disrupting pre existing functionality etc. in at least some of the referencing modules. Thus the developer may be required to make more changes either to the original changed set of modules or the referencing modules to the software application before checking in the modules to the code repository.

The description is continued illustrating the manner in which the steps of are implemented in one embodiment.

Application is shown containing modules code files A.java AI.java B.java C.java D.java E.java and Rx.java as well as test cases ATest.java CTest.java RxTest.java and FuncTest.java . Other files modules such as JRE System Library bcel 5.2.jar etc. are also shown as being part of or being used by application .

The modules and test cases hereafter referred to by their name without the .java extension are shown to be organized in the form of a hierarchy as specified by a developer of application . Modules AI A B and C and are shown as belonging to one package com.intex.sample while modules D and E and are shown as belonging to another package com.intex.sample.lib . The content of the modules and some of the test cases is also shown in corresponding numbered boxes in .

Thus it may be observed that the content of module AI is shown as defining an interface named AI and the content of module A is shown as defining a class A as an implementation of the interface AI . Accordingly during the generation of the reference data testing tool identifies module A as a referencing module and module AI as a corresponding referred module. Similarly based on the content of module B in particular the instruction that class B extends class A testing tool identifies that module B has a reference to module A. With respect to module C based on the instruction for creation of an instance of class B and its assignment to a variable of class A testing tool identifies module C as a referencing module and both modules A and B as the corresponding referenced modules. It may be observed that module D from one package has a reference to module A belonging to another package .

Module Rx is a referencing module which dynamically loads and uses modules using reflection well known in the relevant arts specified in a configuration file named AppConfig.xml . Accordingly testing tool may require a developer to provide additional date indicating the specific modules that are indirectly referenced by the module Rx. Module reflectionclass.properties specifies the additional data for the modules that use reflection to indirectly invoke other modules of the application in the format referencing module comma separated list of referred modules . Thus the content of module indicates that module Rx invokes module A. It may be observed that the content of module Rx does not have any reference to module A indicating that the referencing is indirect in contrast to direct referencing shown in the content of modules A B C D and E.

Module ATest depicts the content of a test case used for testing application . It may be observed that the test case contains instructions according to Java programming language. Such test cases may be provided by testing frameworks such as JUnit well known in the relevant arts. It is noted that the ATest module is shown containing an assertTrue instruction that checks whether the class name of module A is equal to com.intex.sample.A with respect to module A. Thus on running test case ATest the condition is checked and the status of the test case is determined to be pass if the condition is satisfied true and to be fail otherwise. Though only a simple single condition is shown in the test case typical test cases have more number of as well as more complex type of assertions conditions that need to be checked during the execution of the application.

It is noted that module ATest represents a unit test case which is designed to test the functionality of a single module in application . Similarly the other unit test cases such as CTest and RxText may contain instructions to test other modules such as C and Rx in application by invoking the modules and thereby have a direct reference to the modules.

However module FuncTest represents a functional test case which tests the functionality of application generally via a user interface provided by application . The specific functional tests to be run for an application are specified in the configuration file functest.xml . Since functional tests do not directly invoke any of the modules of the application it may be necessary that a developer provide a mapping data specifying for each functional test case the corresponding set of modules tests accessed in application .

Module FuncTest.properties specifies the mapping data for the functional test case module FuncTest in the format test case name comma separated list of referred modules . Thus the content of module indicates that module FuncTest tests indirectly invokes module A. In one embodiment the mapping data for each functional test case is specified in a correspondingly named properties file similar to module . However in alternative embodiments the mapping data for multiple functional tests may be specified in a single file. Furthermore the mapping data may also specify similar to the format noted above the referenced modules for unit test cases such as modules ATest CTest RxTest etc. as well. Such a mapping data may be desirable when the test cases contain instructions according to a scripting language different from the Java programming language.

Thus application is shown containing different modules such as code files and test cases. Testing tool may then inspect the instructions forming application to generate the corresponding reference data as described below with examples.

Broadly testing tool generates the reference data by parsing the instructions in each of the modules forming the software application and searching for specific keywords patterns corresponding to references between the modules. For example testing tool may parse and search for the keywords patterns such as class X implements Y class X extends Y new Y Y variablename new Z Y.methodname variablename.methodname etc. where X Y and Z are module class names and class implements extends and new are keywords in the Java programming language. On finding a match for one of the patterns testing tool adds data specifying the referencing module for example X and the referenced modules for example Y and Z in the reference data.

Thus in module A testing tool may find a match for the pattern class X implements Y with X as A and Y as AI and accordingly add data to the reference data indicating that the module A has a reference to module AI. Similarly in module C testing tool may find a match for the pattern Y variable name new Z with Y as A and X as B and add data indicating module C as a referencing module having a reference to the referenced modules A and B.

In one embodiment the matching of the patterns is performed using a Byte Code Engineering Library BCEL which provides an application programming interface API for analyzing binary Java class files compiled format . Accordingly the .java code files modules are converted into the corresponding compiled class files and then inspected using the BCEL API to determine the reference among the modules. The BCEL API provides convenient methods for determining the interfaces classes implemented extended by a class etc. and also for tracing fields methods classes exceptions etc. Furthermore BCEL facilitates the inspections of the byte codes contained in the compiled class files for the generation of the reference data.

Thus testing tool generates the reference data specifying the modules referenced by each module of the application. As noted above testing tool may also inspect any additional data such as reflectionclass.properties file provided by the developers when generating the reference data. One specific format in which reference data may be generated and maintained in is described below with examples.

Table specifies the reference data generated by testing tool for application based on the static analysis of the content of the modules as shown in . Column Module Name specifies a unique name of a referencing module in the application column Module Type specifies the type of each module such as an interface class unit test case etc. and column Reference List specifies a list of referred modules for the corresponding referencing module.

Each of rows specifies the reference data for a corresponding referencing module in application . For example row specifies that the module AI is of type interface and does not have references to any other module in the application as indicated by the value while row specifies that the module C is of type class and has references to modules A and B. Similarly other rows specify the referenced modules for the corresponding referencing modules.

It may be appreciated that testing tool may insert row in table in response to identifying the pattern class X implements Y with X as A and Y as AI in the content of module A and row in response to identifying the pattern Y variable name new Z with Y as A and X as B in the content of module C . Furthermore testing tool may insert row based on the inspection of the additional data shown in file provided by a developer of application .

On receiving an indication that a set of modules in application is changed modified testing tool iteratively find all the levels of modules referencing at least one of the changed set of modules as described below with examples.

Testing tool then finds the first level of modules having immediate references to at least one of the changed set of modules based on the reference data and adds the newly found modules to the changed set steps and of . The modules added to the changed set are also removed from the search set for the convenience of finding the next level of modules. Testing tool also performs iteratively the steps of and of to identify the subsequent levels of modules again based on the same reference data and adding the modules to the changed set while removing the same modules from the search set until no more modules are newly found.

In the below disclosure the operation of the steps of is shown in a tabular format for convenience with column specifying the level of modules columns and respectively specifying the contents of the search set the changed set and the newly found modules after performing step at a corresponding level.

Table illustrates the manner in which the set of referencing modules in application is found for the changed set A. Testing tool may find the referencing modules based on the reference data shown in generated for application prior to receiving the changed set of modules.

Row indicates the contents of the sets at the start of iteration before performing step of . It may be observed that the search set is initialized to the set of all modules except module A contained in the changed set while the changed set contents is A and that are no newly found modules is indicated as blank. Row specifies the contents of the sets after the performance of step and with the modules in the newly found column identified based on rows and having the module A as a referenced module in column . The search set in row is shown updated with the newly found modules removed while the change set in row is shown updated with the newly found modules added to the previous state in row .

Row specifies the contents of the sets after the performance of a first iteration of steps and with the second level as indicated in column modules of newly found column identified based on rows and having respectively the modules D C and Rx as a referenced module in column . The search set and changed set in row are shown appropriately updated with the newly found modules respectively removed and added to the sets.

Row specifies the contents of the sets after a second iteration in general the iteration number is determined as one less than the level in column and indicates that no modules were newly found in step as indicated by the in column . Accordingly the iteration is stopped and the contents of the changed set in column of row represents the final changed set of modules A B C D E Rx ATest CTest RxTest containing the original changed set of modules A and all the modules referencing at different levels at least one of the original changed set.

Thus the referencing modules in application for a changed set of modules A is found based on the reference data of . Tables and respectively illustrate the manner in which the set of referencing modules in application is found for the corresponding changed sets B Rx and D with the corresponding final changed sets shown in rows and .

Testing tool after finding all the referencing modules and adding the referencing modules to the original changed set of modules to generate the final changed set of modules determines the impact of the original changes in the software application based on the final changed set of modules as described below with examples.

Testing tool may determine the optimal minimal set of test cases to be run covering the testing of the changed modules based on the final changed set of modules step of . As described above testing tool may determine the test cases based on a mapping data such as file provided by a developer specifying which of the modules of the application are accessed tested by each of the test cases. Testing tool may also determine the test cases based on the type of the modules as described below.

Thus for the changed set A of table the final changed set shown in row is inspected to identify the test cases ATest CTest and RxTest based on the type Unit Test of the modules as indicated by column . The identification of the modules of the test case type may be performed in any convenient manner. For example modules of test case type may be required to have the text Test appended to their names according to a coding convention and as such the test cases may be identified as the modules whose names end with the text Test . Thus for the final changes set shown in row assuming that the above coding convention is followed the test cases ATest CTest and RxTest may be identified as the test cases.

Furthermore testing tool also identifies the test case FuncTest based on the mapping data of file since the module A contained in the final changes set shown in row is indicated to be invoked by the content of . For the format described above testing tool checks whether a module such as A contained in the final changed set of modules appears on the right hand side of the sign and then includes only those test cases FuncTest specified in the left hand side of the sign if the module appears on the right hand side.

Thus the minimal set of test cases for the changed set A is identified to be ATest CTest RxTest FuncTest. Similarly for the changed set B Rx of table the set of minimal test cases is identified to be CTest RxTest based on the final changed set of modules shown in row .

It may be appreciated that in some scenarios testing tool may not be able to identify any test cases based on the final changed set of modules in other words the set of test cases is empty . According to an aspect of the present invention testing tool notifies a developer of the lack of test cases to cover testing of the original changed set of modules if the set of test cases is identified to be empty. Thus for the changed set D E of table it may be observed that the final changed set of modules in row does not have any modules of test types as well as the mapping data of does not indicate any test cases. Accordingly testing tool may notify a developer of the lack of test cases to cover the changed set D E.

In one embodiment the software application is a multi layered application with the modules belonging to a set of layers where the modules belonging to each layer maintained in a corresponding code repository. In such an embodiment if the changed set of modules belongs to a first layer testing tool checks whether the referencing set of modules includes a second module belonging to a second layer contained in the set of layers where the second layer is different from the first layer. Testing tool then notifies a developer of an interface mismatch between the first layer and the second layer if there a second module is present with the interface mismatch corresponding to changes made to a module contained in the final changed set of modules referenced by the second module. Such a notification enables the developer to fix the interface mismatch before integration of modules in the different layers from different code repositories.

It may be appreciated that testing tool may store the reference data in a secondary non volatile storage after generation and then retrieve the stored reference data for finding the referencing modules. Such storage and retrieval facilitates the checking for interface mismatch to be performed without requiring inspecting of the instructions forming the modules in multiple layers and maintained in different code repositories .

In another embodiment the modules forming the software application are divided into a set of packages such as com.intex.sample and com.intex.sample.lib noted above with each package related to a corresponding functionality provided by the software application. In such an embodiment if the changed set of modules is contained in a first package related to a first functionality provided by the application testing tool checks whether the referencing set of modules includes a third module belonging to a third package contained in the set of packages where the third package is different from the first package and is related to a third functionality different from the first functionality. Testing tool then notifies a code reviewer to review the impact of the first functionality on the third functionality if such a third module is present.

It should be appreciated that the features described above can be implemented in various embodiments as a desired combination of one or more of hardware executable modules and firmware. The description is continued with respect to an embodiment in which various features are operative when executable modules are executed.

Digital processing system may contain one or more processors such as a central processing unit CPU random access memory RAM secondary memory graphics controller display unit network interface and input interface . All the components except display unit may communicate with each other over communication path which may contain several buses as is well known in the relevant arts. The components of are described below in further detail.

CPU may execute instructions stored in RAM to provide several features of the present invention. CPU may contain multiple processing units with each processing unit potentially being designed for a specific task. Alternatively CPU may contain only a single general purpose processing unit.

RAM may receive instructions from secondary memory using communication path . RAM is shown currently containing software instructions constituting operating environment and or other user programs such as testing production versions of the software applications code management testing softwares etc. . In addition to operating environment RAM may contain other software programs such as device drivers virtual machines etc. which provide a common run time environment for execution of other user programs.

Graphics controller generates display signals e.g. in RGB format to display unit based on data instructions received from CPU . Display unit contains a display screen to display the images defined by the display signals. Input interface may correspond to a keyboard and a pointing device e.g. touch pad mouse and may be used to provide inputs. Network interface provides connectivity to a network e.g. using Internet Protocol and may be used to communicate with other systems connected to the network.

Secondary memory may contain hard drive flash memory and removable storage drive . Secondary memory may store the data for example portions of the reference data of portions of the additional data mapping data provided by developers etc. and software instructions which when operative perform the steps of and cause the states shown in which enable digital processing system to provide several features in accordance with the present invention.

Some or all of the data and instructions may be provided on removable storage unit and the data and instructions may be read and provided by removable storage drive to CPU . Floppy drive magnetic tape drive CD ROM drive DVD Drive Flash memory removable memory chip PCMCIA Card EPROM are examples of such removable storage drive .

Removable storage unit may be implemented using medium and storage format compatible with removable storage drive such that removable storage drive can read the data and instructions. Thus removable storage unit includes a computer readable storage medium having stored therein computer software and or data. However the computer or machine in general readable medium can be in other forms e.g. non removable random access etc. .

In this document the term computer program product is used to generally refer to removable storage unit or hard disk installed in hard drive . These computer program products are means for providing software to digital processing system . CPU may retrieve the software instructions and execute the instructions to provide various features of the present invention described above.

Reference throughout this specification to one embodiment an embodiment or similar language means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus appearances of the phrases in one embodiment in an embodiment and similar language throughout this specification may but do not necessarily all refer to the same embodiment.

Furthermore the described features structures or characteristics of the invention may be combined in any suitable manner in one or more embodiments. In the above description numerous specific details are provided such as examples of programming software modules user selections network transactions database queries database structures hardware modules hardware circuits hardware chips etc. to provide a thorough understanding of embodiments of the invention.

While various embodiments of the present invention have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

It should be understood that the figures and or screen shots illustrated in the attachments highlighting the functionality and advantages of the present invention are presented for example purposes only. The present invention is sufficiently flexible and configurable such that it may be utilized in ways other than that shown in the accompanying figures.

Further the purpose of the following Abstract is to enable the U.S. Patent and Trademark Office and the public generally and especially the scientists engineers and practitioners in the art who are not familiar with patent or legal terms or phraseology to determine quickly from a cursory inspection the nature and essence of the technical disclosure of the application. The Abstract is not intended to be limiting as to the scope of the present invention in any way.

