---

title: Method and system for software developer guidance based on analyzing project events
abstract: In systems and methods for providing assistance to software developers, a profile of a software developer is accessed. The profile contains a software development history of the software developer. Event data is developed comprising data related to at least one software code event associated with a software development project and with the software developer. Guidance is selected for use by the software developer in resolving a software development problem, based on an analysis of the event data, data related to the software development project, data related to an environment in which the at least one software code event occurred, and the profile. Feedback regarding progress of the software developer in the development project is also developed from the event data and the profile. The guidance and feedback are presented to the software developer via an interactive console unit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08595685&OS=08595685&RS=08595685
owner: Accenture Global Services Limited
number: 08595685
owner_city: Dublin
owner_country: IE
publication_date: 20100520
---
This application claims priority to Indian Patent Application 966 CHE 2010 entitled METHOD AND SYSTEM FOR SOFTWARE DEVELOPER GUIDANCE BASED ON ANALYZING PROJECT EVENTS and filed Apr. 7 2010.

As known in the art software code comprises instructions that may be used to control or instruct the operation of one or more processing devices such as microprocessors microcontrollers co processors etc. It is not uncommon for software development projects to require the services of numerous software code developers and their supervisors for periods of time stretching over many months or even years. A software development project involves several types of tasks such as coding writing tests for the code performing the tests analyzing the results and debugging.

Software developers often face problems in performing the tasks assigned to them in a software project. While the problem remains unresolved the developers projects may be stalled. A developer may not have the information necessary to solve the problem. If the information is available the developer may not know how to apply the information to solve the problem. In addition frequently problems may recur. In many cases developers themselves may not be able to detect a trend of problems they are repeatedly encountering. Even if they do detect a trend they typically have little clue how to alleviate the same.

Problems that software developers face have often arisen before in other software development projects under similar circumstances or in similar environments. A typical software development project emits out many events related to the activities performed by developers. Analyses of those events or even just information about those events could be useful to a developer to suggest the needed guidance to mitigate problematic situations. When a problem arises it would be helpful to a developer to obtain information about the problem as it has previously arisen such as the frequency with which it has arisen the environment in which it developed other problems or events with which it has been associated and successful and unsuccessful approaches that others may have used in attempts to resolve the problem.

However project tools today have a very limited ability to aid and assist a software developer when he she gets stuck or encounters problems repeatedly unless the developer explicitly asks for assistance. Further conventional software development systems typically do not provide developers with assistance in detecting trends in problems.

Not only does software development generate a considerable amount of project data pertaining to events and the operation of multiple servers repositories and workstations it generates considerable data pertaining to the behavior and productivity of individual software developers and development teams. Typically much of the generated data remains unused. Analysis of the data could provide a valuable in process feedback on the progress of a developer or a development team with the project.

It would be helpful to software development to leverage project data along with profiles of individual developers or development teams to assist developers and development teams in obtaining guidance and in process feedback.

Systems and methods for providing software developer guidance based on analyzing project events are herein described. In one embodiment providing assistance to software developers comprises accessing a profile of a software developer and developing event data with an events extractor. The profile comprises information about a software development history of the software developer and the event data relates to at least one software code event associated with the software developer. Guidance is selected with an events and environmental data processor for use by the software developer in resolving a software development problem. The guidance is selected based on an analysis of the event data data related to the software development project data related to an environment in which the at least one software code event occurred and the profile of the software developer. The guidance is presented to the software developer with a display device comprising an interactive console unit.

In one embodiment the profile includes information about previous software development experience by the software developer. In another embodiment the profile includes information about previous software coding problems faced by the software developer. In another embodiment the previous software coding problems comprise recurring software development problems faced by the software developer. In another embodiment the previous software coding problems comprise software development problems having a high likelihood of having been resolved. In one embodiment the profile includes information about previous system failures associated with the software developer.

In one embodiment the guidance is selected based on heuristic rules. In another embodiment an extent of difficulty of the software development problem is identified and is used with the other data to select the guidance. The guidance that has already been provided to the software developer may also be filtered out in guidance selection. In another embodiment the guidance alternatives are ordered according to past effectiveness in resolving one or more software development problems.

In one embodiment the guidance comprises a suggestion to refer to documentation related to a second software development project and identification of the documentation related to the second software development project. The guidance may also comprise a suggestion to refer to documentation related to the software development project and an identification of the documentation related to a second software development project. The guidance may also comprise a suggestion to collaborate with another person or entity and identification of the other person or entity.

In one embodiment the guidance may be developed in response to an automated identification of a need for the guidance. In one embodiment the need for the guidance is identified based on trends in software development problems faced by the software developer.

In one embodiment feedback may be developed relating to progress of the software developer in the development project. The feedback may be developed from the event data and the profile and presented to the software developer via a display device comprising an interactive console unit. Further embodiments comprise developing a value for at least one metric related to an extent of the developer progress in the development project and developing a value for at least one metric related to a quality of the software developer progress in the development project. Developing the feedback may further comprise identifying a trend in the software developer progress and presenting data corresponding to the trend and or developing a value related to the software developer progress relative to progress by other software developers.

It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory only and are not restrictive of the invention as claimed.

The accompanying drawings which are incorporated in and constitute a part of this specification illustrate embodiments of the invention and together with the description serve to explain the principles of the invention.

Reference will now be made in detail to the present embodiments exemplary embodiments of the invention examples of which are illustrated in the accompanying drawings. Wherever possible the same reference numbers will be used throughout the drawings to refer to the same or like parts.

As shown in system may comprise a local event monitor a global event monitor an events characteristics database an event extractor a developer profile repository a guidance repository an environmental data repository an events and environmental data processor a guidance feedback unit an interactive guidance console unit and a periodic reporting unit . One of skill in the art will appreciate that although only one of each of the components identified above are depicted in any number of these components may be provided. Furthermore one of ordinary skill in the art will recognize that functions provided by one or more components of system may be combined or incorporated into another component shown in . For example local event monitor and global event monitor may be combined into a unitary event monitor or they may be eliminated completely with the inputs of event monitors as shown in and described below input directly into event extractor .

One or more of the components depicted in may be implemented in software on one or more computing systems. For example they may comprise one or more applications which may comprise one or more computer units of computer readable instructions which when executed by a processor cause a computer to perform steps of a method. Computer readable instructions may be stored on a computer readable medium such as a memory or disk. Such media typically provide non transitory storage. Alternatively one or more of the components depicted in may be hardware components or combinations of hardware and software such as for example special purpose computers or general purpose computers. A computer or computer system may also comprise an internal or external database. The components of a computer or computer system may connect through a local bus interface.

In certain embodiments one or more of the components shown in may be a computer server with web services enabled. For example the events and environmental data processor could contain a processor web service for processing events and environmental data. The components depicted in may be operatively connected to one another via a network not shown such as the Internet an intranet or any type of wired or wireless communication system. Connections may be implemented through a direct communication link a local area network LAN a wide area network WAN and or other suitable connections.

Database and repositories and may be implemented as separate databases and repositories as shown in or as one or more internal databases stored for example on event extractor or on events and environmental data processor . Database and repositories and may be accessed by other components in system directly via an external connection or via a network not shown .

The local event monitor which in one embodiment may reside on a developer s workstation not shown is configured to monitor events related to the developer s activities at a workstation in creating code. Such activities may include but are not limited to writing debugging editing and saving code. As shown in monitor may monitor local tool events and Integrated Development Environment IDE events. Local tool events include events arising from the operation of development tools such as code quality or other evaluative testing tools used locally at the developer workstation. Examples of code quality tools include but are not limited to PMD Checkstyle Findbugs and Jdepend JavaNCSS and examples of testing tools include but are not limited to Junit harnesses Ncover Emma and Cobertura IDE events relate to the operation of IDEs such as the EMC IDE the Microsoft .NET framework the Microsoft Visual Studios IDE for writing and debugging code and the Eclipse IDE for incorporation of open source code.

The global event monitor which in one embodiment may comprise adaptors residing on the individual servers and repositories and a centralized monitor residing on a server on the network is configured to monitor events that are remote from the developer workstation. As shown in monitor may monitor build server events test server events code repository events global tool events and configuration management tool events.

Build server events include events arising from or at the build servers upon which the code is aggregated and compiled. Test server events include events arising from or at the test servers due to the operation of test suites. Examples of build server event data include but are not limited to identification of the test suite the run results of the test suite data about a failing of a test and data from a module that failed. Code repository events include events arising from or at the repositories due to checking code out of and in to repositories . The code repository events may include for example attributes such as time stamps for the beginning and end of the transaction the sections of the code that were affected and the identity of the person who checked out or checked in the code. Global tool events include events arising from the operation of development tools by other developers or other development teams. Configuration management tool events include events arising from the use of configuration tools such as for example particulars as to what was checked in or out who checked them in or out and when they were checked in or out.

The events extractor may be configured to extract events from the event characteristics database which may stores records identifying the attributes of previous events. As shown in one embodiment of a record of an event in the event characteristics database has an ID field for a unique identifier of the event. Record may also have a Code Involved field for storing an identifier of the code involved in the event a Tools In Use field for storing identifiers of the tools in use at the time of the event a Time Stamp field for storing time stamps for the event a Components field for storing identifiers of the components involved in the event a Cause s of the Event field for storing information as to who or what caused the event a Conditions field for storing information about the condition of the components and code at the time of the event and a Report Location field for storing the location of reports of the event or in one embodiment hyperlinks to the reports. The event characteristics database may also have an Event Log record storing the log itself of the events that have been reported.

The events extractor is configured to extract data from the developer profile repository which may store developer profiles. Developer profiles which contain a software development history of a software developer may be of any suitable kind. In one embodiment records for at least two types of developer profiles are stored in the repository for example static profiles and dynamic profiles.

Static profiles may contain relatively unchanging developer information. In one embodiment as shown in a record for the static profile may contain an ID field to contain an identifier of the developer such as a name or ID number and a Contact Information field for storing the contact information for the developer. The record may also have a Developer Employment Status field for storing data about the status of the developer e.g. consultant contractor employee a Company field for storing data identifying the name of the company division or unit employing the developer a Time in Service field for storing data identifying how long the developer has been a code developer at the company identified in field .

The record may also contain an Availability field for identifying information regarding the developer s availability. For example the field may contain data relating to the length of time that a developer is committed to working on a selected project future projects to which the developer is committed and any constraints as to availability such as upcoming vacations sabbaticals or agreements restricting the developer from working with selected groups or technologies or requiring the worker to work in a particular area. Record may also have an Area s of Specialization field for storing information related to a developer s areas of specialization expertise skills or proficiency. The field may have a primary sub field and secondary sub field to prioritize the areas of specialization.

Dynamic profiles may contain more current and more frequently changing information about the developer. In one embodiment as shown in a record for a dynamic profile may contain a Name field for identifying the subject developer. The record may be configured to store project specific information. For example it may have a Project s field to identify the projects on which the developer has worked recently in the last X years months or weeks . The record may have a Project Activity Categories field to store information about the category or categories of project activities to which the developer has been assigned recently. The categories of project activities may include for example writing code testing code reviewing code or debugging code.

The record may also have a Modules Field and an API field for identifying respectively the modules and the Application Programming Interfaces APIs with which or on which the developer has worked recently. The record may also have a Technical Specifications Library field for identifying the technical specification libraries that the developer has accessed recently. As will be described below in greater detail such project specific information may be useful to determine the pertinence of the developer s input about a problem or the pertinence of the project to a project for which guidance is being solicited.

The record may also have a Past Guidance Recommendations field to store information related to the past guidance recommendations that have been presented to the developer such as by an guidance feedback unit which is described in more detail below. The field may also have sub fields such as sub field to record each instance of guidance supplied to the developer. The sub field may have additional sub fields such as sub fields to identify the manner in which and the extent to which the developer followed the past guidance recommendations.

The record may also have fields to store metrics values related to the developer s efforts on his or her current projects. For example the record may have Progress Scores field for storing metrics values that measures the quality of the developer s performance as a code developer. One embodiment of such metrics is the Personal Quality Score PQS . In one embodiment an individual PQS is a composite score which is determined at selected intervals such as on a daily basis for each developer of a software development team. While PQS may be determined in any convenient manner two examples of PQS include a Personal Quality Score 1 PQS1 and a Personal Quality Score 2 PQS2 .

PQS1 may be a composite score based on the violations reported by code quality tools during an analysis interval such as a ratio of the weighted sum of the violations categorized into different severity levels e.g. High Medium and Low severity to the total number of non commenting source statements in those portions of the software code developed by the developer during the analysis interval. Weights may be assigned to each severity category based on the project manager s perception of the criticality of a category from a project perspective.

PQS2 may be a ratio of the weighted sum of the violations categorized into different severity levels e.g. High Medium and Low severity to the total number of modified non commenting source statements in those portions of the software code developed by the developer during the analysis interval. While PQS1 may give an indication of the impact on quality of the modified software code PQS2 may be a more developer centric and personal metric that indicates the quality of the last modification episode of a developer.

Another progress score may be a Failed to Successful Unit Tests FSUT ratio. While PQS1 and PQS2 may reflect the adherence of the developer to coding best practices FSUT may reflect functional quality of the code as determined by unit testing as known in the art. PQS1 PQS2 and FSUT ratios are normalized to allow appropriate comparison and benchmarking.

The quality metrics described above for an individual developer may be combined to provide a Developer Quality Score DQS for the developer. In one embodiment DQS is calculated by first calculating a weighted average of PQS1 and FSUT. The weights may be predetermined by a project manager to reflect the importance given by the project to adherence to coding standards vis vis functional testing. Based on the weighted average a lookup table may be used to map the weighted average to the DQS score. Alternatively DQS may be determined by associating project specific thresholds on PQS1 and FSUT to determine whether PQS1 and FSUT individually are good or violating norms. Based on the individually determined sufficiency of PQS1 and FSUT a table lookup mapping these two parameters to the DQS may provide a developer specific DQS. In either case it may be desirable to make the constituent PQS1 and FSUT data leading to the DQS and likewise the constituent violations leading to the PQS1 available for inspection to a user e.g. the developer in question thereby allowing the user to understand the rationale behind the DQS. In one embodiment the constituent violations and constituent PQS1 and FSUT data may be stored in record and presented to the developer on interactive feedback console unit .

In a similar vein aggregated quality metrics corresponding to portions of software attributable to more than a single developer e.g. from a small team of developers all the way up to the entire project s development team may be determined. Once again such aggregated quality metrics may be determined on a daily basis or according to any convenient interval. Generally this is accomplished by retrieving the quality metrics at the desired level of abstraction and determining scores according to that level of abstraction. Further scores at higher levels of abstraction e.g. broader abstraction levels may be determined by combining the initial aggregated scores. In one embodiment the aggregate scores at various levels of abstraction may be calculated and presented to the developer on interactive feedback console unit .

Embodiments of PQS FSUT and DQS are described in further detail in co pending Indian Patent Application 1986 MUMNP 2009 filed Sep. 1 2009 and entitled COLLECTION AND PROCESSING OF CODE DEVELOPMENT INFORMATION Applicant reference number 02079 PR IN . PQS and related values PQS1 and PQS2 described in the above identified patent application may be correlated to the quality of the source code produced by the developer. The Progress Scores field may have a PQS1 sub field and a PQS2 sub field to store the developer s current values of PQS1 and PQS2.

The dynamic profile may also identify the top recurring problems RP that the developer has faced. In one embodiment each developer s profile only stores her own information only while the developer profile repository may have profiles for each developer on the development team. For example in one embodiment RP n could be a set of type Quality issues and could constitute the set of problem issues that have been identified across the majority of the past n measurements or observations of problem issues. RP n having a large number of elements could indicate that the code under development is of high complexity. Alternatively or in addition a large RP n could indicate that the code under development has low tool coverage Tcov . Tcov may be used to identify which statements have been executed and how often. A low Tcov may demonstrate that the code has not been tested enough.

The record may have a Recurring Problem s field that stores the set of recurring problems in the developer s current projects. In one embodiment the set of recurring problems is the set of problems that have occurred in the majority of a series of observations of problems. One of ordinary skill in the art will understand that a problem may be characterized as recurring based on any suitable criteria. For example a problem may be characterized as recurring if it is observed in more than a quarter of a series of observations. Further the observations that define a problem as recurring need not be serial. The set of observations upon which a problem s characterization as recurring could be a random sample of observations. Other characterizations of a problem as recurring may be based on whether a problem has been observed a selected number of observations in a series.

The field may store numerous sets of recurring problems. shows one embodiment of a field for the embodiment in which a problem is characterized as recurring when it has been observed in a majority of a series of observations of problems. The field may have a plurality of sub fields for storing the observed sets of recurring problems identified across multiple observations of problems. For example sub fields may have sub fields for storing sets RP n RP n RP n which are the sets of problems that are characterized as recurring. In the embodiment in which a problem is characterized as recurring when it has been observed in a majority of a series of observations of problems RP n RP n and RP n are the sets of problems that are characterized as recurring in the past n n and n observations respectively. Sub fields may have sub fields for storing the values n n n respectively. Alternatively the field may have Problem sub fields for identifying the problems that the developer has faced with sub fields containing identifiers of the observations in which the problem was identified so that any desired set of recurring problems across a selected number of observations could be determined based on inspection of the Problem sub fields.

The dynamic profile may also identify the problems that recurred in the past but that no longer occur. If problems no longer occur the likelihood increases that they are solved. For example in one embodiment a set of problems that are likely to have been solved may be developed. The set may be known as Non Recurring Past NRP issues and is the set of recurring problems that are likely no longer recurring in the development project. One of ordinary skill in the art will understand that a problem may be characterized as no longer recurring based on any suitable criteria. In one embodiment a problem may be characterized as not recurring and therefore included in NRP based on not having been observed for a selected amount of time for a selected number of observations or in a selected number of observations in a series. Alternatively it may be characterized as not recurring if it has not been observed in a majority of observations in a set of observations. In one embodiment NRP may be developed from two sets of recurring problems for example from RP n and RP n x using the formula NRP n RP n RP n x .

Thus in the embodiment in which a problem is characterized as recurring when it has been observed in a majority of a series of observations of problems NRP n may be the set of problems that occurred across the majority of the past n observations of problem issues RP n excluding the problems that occurred across the majority of the past n x measurements of problem issues RP n x . So for example for an embodiment in which 50 observations were made of problems and a set of problems that recurred across in the last 50 observations and a set of problems that were identified across the last 20 observations RP 50 is the set of problems with recurrence across the last 50 measurements and RP 20 is the set of problems with recurrence across the past 20 measurements. NRP 50 is the set of problems that were contained in RP 50 but not in RP 20 . Therefore NRP 50 is the set of problems that had been observed to recur starting 50 observations ago but that ceased to recur 20 observations ago.

NRP may be defined in any suitable way depending on the objectives of the developers of system . System developers may be more interested for example in identifying trends in the number of non recurring problems than in actually identifying the problems that are no longer recurring. There may be some problems that are recurring across a number of problem observations but they are not appearing in a significant number such that they are counted as recurring. For example in the embodiment in which a problem is characterized as recurring when it has been observed in a majority of a series of observations of problems a problem X needs to recur 26 time in 50 observations to be considered non recurring. However if problem X appears five times in every ten observations during observations 1 40 and six times during observations 41 50 it will be characterized as a recurring problem in the most recent 50 observations 26 recurrences out of 50 but not in the most recent 40 observations 20 recurrences out of 40 the most recent 30 observations 15 recurrences out of 30 the most recent 20 observations 10 recurrences out of 20 and the most recent 10 observations 26 recurrences out of 50 . Therefore problem X would be included in NRP 50 30 because it was considered recurring in RP 50 but not in RP 30 . In another example if problem Y recurred frequently in observations 21 30 but was not observed starting 20 observations ago and if NRP is developed from the most 50 and 30 observations Problem Y might not be included in the set NRP. Nonetheless if the developers of system are more interested in using NRP to analyze the trends in recurring and non recurring problems than in using NRP to identify the actual problems that are recurring it may be acceptable for NRP to include in its membership problems that recur at relatively low rates or to exclude certain problems that recurred for a short period of time but stopped recurring.

Therefore depending on how RP and NRP are calculated while new issues may have arisen in the past x observations or old issues start recurring again membership in NRP n may represent a likelihood that a problem has stopped recurring and trends in RP and NRP may be analyzed to identify an extent of recurring or resolved problems. In other words depending how RP and NRP are defined there may be positive correlation between the number of member of the set NRP n and the number of software development issues that have been resolved.

The record may have a Non Recurring Problems field that stores the set of non recurring problems in the developer s current projects. The field may store numerous sets of non recurring problems. As shown in the field may have a plurality of sub fields for storing the observed sets of non recurring problems identified across multiple observations of problems. In the embodiment in which a problem is characterized as not recurring when it has been observed in a majority of a series of observations of problems but not in another where n n n there may be two sets on NRP n namely one based on n n and a second one based on n n . In addition there may be a set NRP n based on n n . Sub fields may have sub fields for storing sets the first NRP n the second NRP n and NRP n which are the sets of problems that are characterized as no longer recurring. Sub fields may have subfields for storing the values n n and n respectively. Finally Sub fields may have subfields for storing the measurement values n n and n respectively. Alternatively in the embodiment in which the field has Problem sub fields for identifying the problems that the developer has faced with sub fields to identify in which measurements of problem issues the problem was identified NRP n could be calculated based on inspection of the Problem sub fields.

Returning to the dynamic profile may also identify F n the number of times that the developer s modifications caused build failures in past units of observation. The unit of observation could be of any suitable type such as amount of time or number of builds. Generally the value of F will be greater than or equal to zero and less than or equal to the number of observations. For time units 0 F t t. Therefore a dynamic profile record stored in repository may contain a field for storing information related to F n . Further field may have sub field for storing the unit value of the failure s sub field for storing the value of F and or subfields for storing characteristics information about the failures themselves.

Returning to the system of the events and environmental data processor is configured to obtain data from the project environment repository and the guidance repository . In one embodiment the project environment repository contains a project configuration database and a project phase and complexity database . The project configuration database may contain records storing data describing the project identifying all components phases timelines and required elements for the project such as the identity of the developers assigned to the development project and the schedule for the project. The project phase and complexity database may contain data specific to the current phase of the project and data related to the complexity of the code development project

The events and environmental data processor accesses data from the project environment repository in order to identify the context of the project and to determine the nature of difficulty of the problem that the developer is facing.

The guidance repository may contain records storing data describing guidance that has been or may be provided to resolve problems in the project. The guidance repository which may be a knowledge base may contain data that is updated over time. In one embodiment the guidance is project specific relating to the methodology or APIs that are in use in the project. In other embodiments the available guidance is broader in scope. In one embodiment the guidance is a set of guidance instantiations that have been previously implemented in a code development project.

The guidance repository may store a record such as illustrated in for example. The exemplary record includes an ID field for identifying an instance of guidance a Type field for containing information about the type of guidance a Source field for storing data about the source of the provided guidance a Summary field for storing a summary of the guidance a Links field for identifying hyperlinks to the guidance an Environment field for storing data about the suggested system on which the guidance will be useful or on which the guidance was employed.

Additionally or alternatively record may have a Methodology field for identifying the suggested methodology to apply in taking the guidance or the methodology that was applied when the guidance was taken. Record may also have an API field for identifying the suggested API s to use in taking the guidance or the API s used when the guidance was taken. The record may also have a Time Stamp s field for storing timestamps related to when the guidance was implemented. Record may also have a Success field for storing a measure of the extent of success that developers have achieved in implementing the guidance.

The guidance repository may also store an heuristics decision table for use in selecting the guidance to suggest. In one embodiment the rows of the table will identify the categories of events that may demonstrate problems for example the table may have a local events row and a global events row . The table may also have a class column to identify the classes of problems that may be associated with a selected event. For example in the embodiment illustrated in local events may be associated with Compile Issues Code Quality Issues or Test Related issues problems while global events may be associated with Code Quality Issues Test Related Issues or Integration Failure problems.

The table may also have a scope column to identify the scope s of the classes of problem s that may be associated with a selected event. For example in the embodiment illustrated in a local event in the Compile Issues class may be associated with a problem scope of Public API problem or Private API Problem while a local event in the Code Quality Issues class may be associated with a problem scope of Public Standard or Private Standard. Further a local event in the Test Related class may be associated with only one problem scope for example Project Specific. 

The table may also have a guidance precedence order column to select the kinds of guidance may be associated with a selected event of a selected class and scope. The guidance precedence order column may have order sub columns for example primary sub column secondary sub column and tertiary sub column to identify the kinds of guidance that may be suggested for the a selected event of a selected class and scope and the order in which the guidance may be suggested.

For example in the embodiment illustrated in a developer facing a global event in the Code Quality Issues class and of the Public Standard scope may first receive a suggestion to check online knowledge bases available on the Internet . When that suggestion does not resolve the problem the developer may receive the suggestion to check the organization s knowledge base if that did not work she may receive the suggestion to collaborate with a team member. On the other hand if the global event was in the Code Quality Issues class but of the Project Standard scope the developer may first receive a suggestion to check internal project artifacts followed by a suggestion to collaborate with a team member followed by a suggestion to check the organization s knowledge base.

In one embodiment the processor has a guidance selector for which the processor obtains the data from the guidance repository . The guidance selector may be configured to select relevant guidance alternatives from the guidance data from the guidance repository in order to present alternatives to present to the developer. The guidance selector may be configured to filter out the guidance already considered and or to filter the guidance according to past effectiveness.

In one embodiment the processor has a developer progress score calculator which may be configured to calculate a metric representative of the quality of the progress made by the code developer. In one embodiment the developer progress score is a composite effectiveness score which is inversely proportional to the number of coding problems that the developer has faced but not yet resolved inversely proportional to the number of times that the developer s modifications caused build failures in past units of time or of builds and directly proportional to the number of coding problems that the developer has resolved.

One aim of calculating the DPS is to provide feedback to the developer regarding the quality of his or her work on the development project. The manner of feedback is described below.

The events and environmental data processor may also be configured to use the data presented to and created by the guidance selector and the developer progress score calculator to populate the Past Guidance Recommendations field the Progress Scores field the Recurring Problems field the Non Recurring Problems field and the Failures field in the exemplary dynamic profile record shown in .

The events and environmental data processor may be coupled to the interactive guidance console unit and the periodic reporting unit in order to provide the guidance alternatives and progress quality scores to the developer. In one embodiment each developer would have a console unit on his or her own workstation to operate as a user interface to the software guidance system . In one embodiment the console unit runs in the background of the developer s workstation and an icon may be installed on a system tray not shown to provide easy access to the console unit . Using the console unit the developer may request guidance with a selected problem monitor the project progress or view unsolicited assistance provided by the system due to a system perceived need for assistance with a problem.

The console unit may present to the developer a screen such as shown in . In one embodiment the screen has a My Project Health section to display metrics about the development project and the developer s contribution to the project. The My Project Health section may have a DPS display sub field to display in a section the developer progress score DPS across past measurements described above and a team DPS for the development team. The My DPS display sub field may also have a colored Orb display in section for showing a visual representation of the value of the developer s DPS metric relative to the value of the DPS metric for the development team. For example in one embodiment a green display may indicate that the developer s progress relative to her team is good an amber display may indicate that the developer s progress needs some improvement and a red display may indicate that the developer s progress relative to her team is poor.

The DPS display sub field may also have section to display the developer and team DPS trends across past measurements. Alternatively as shown in the DPS trend may be displayed in a separate field of the screen . In field DPS trends are shown as a bar graph but any suitable graphic display is contemplated. Percentile DPS may also be calculated using development team level information and displayed to provide information as to the developer s progress relative to others on the development team. In My DPS Percentile field a DPS percentile may be displayed to show the developer the percentage of team members having DPS lower than the developer s DPS.

In one embodiment the screen has a personal quality score field to provide information about the level of quality of the developer s coding work. In the embodiment shown in the My Project Health field has a PQS display section that displays one or more calculations of a developer s current PQS described above and other data based on PQS. For example the PQS display section may provide displays of PQS1 and or PQS2 disclosed above their trends across past measurements or a moving average of PQS1 or PQS2 with a window of past scores. Composite PQS may be developed and displayed and the individual scores may be weighted such that the most recently calculated score contributes highest to the composite score. Percentile PQS1 or PQS2 using development team level information may also be calculated and displayed to provide information as to the developer s quality relative to others on the development team. Such metrics could be displayed on the screen . Alternatively screen may have links or tabs to access displays of the metrics. In the embodiment shown in the PQS display sub field displays in a section a developer PQS1 and a team PQS1. The My PQS1 display sub field may also have a colored Orb display in section for showing a visual representation of the value of the developer s PQS1 metric relative to the value of the PQS1 metric for the development team. For example in one embodiment a green display may indicate that the developer s quality relative to her team is good an amber display may indicate that the developer s personal quality needs some improvement and a red display may indicate that the developer s quality relative to her team is poor. In the embodiment shown in the screen has a Quick View Issue field to display a count of the recurring issues facing the developer solved issues and pending guidance for the developer. In one embodiment the counts serve as drill downs providing links to other screens not shown displaying the recurring issues solved issues and or pending guidance.

In the embodiment shown in the screen has a Recurring Problems and Guidance field to display information about the recurring problems that the developer has faced. Field has a Build Failure API Usage Alert sub field to display an alert if the code shows signs of a build failure due to improper usage of an API a Complexity Alert sub field to display an alert if the code shows signs of being highly complex and a Performance Alert sub field to display an alert if the developer s code shows signs of having low quality. In one embodiment the Alert sub fields serve as drill downs providing links to other screens not shown displaying the additional information about the failures complexity and quality issues identified by system .

In one embodiment the console unit has a guidance recommendation section to display the guidance alternatives that were suggested to the developer. Referring to field has a Guidance sub field to display suggested guidance. Guidance sub field has sections and to display the suggested guidance and to provide drill downs such as links to the suggested guidance. In section is displaying a link to a guidance record found in a project knowledge base ProjKB section is displaying a link to a guidance record found in an internal knowledge base IntKB and section is displaying a suggestion to collaborate with a person Contact Ashok along with identified context . As discussed in more detail below the Guidance sub field could also display guidance in the form of links messages or another convenient mechanism.

In one embodiment the console unit has a feedback section to display data relating to whether the suggested input was taken or not taken by the developer and whether the suggested input was found to be helpful or not helpful to the developer. In the embodiment shown in the screen has a Guidance Feedback field to display information about the recurring problems that the developer has faced and allow the developer to provide feedback as to the usefulness of the guidance.

Section has a Past Recurring Problem sub field to display the recent problems that the developer has faced. In one embodiment the sub field is populated with data from the developer dynamic profile retrieved from the developer profile repository . In one embodiment the data from the Developer profile is read automatically into the sub field . Section also has a Mode of Guidance sub field to identify the type of guidance that was suggested to resolve the problem a Completion sub field to allow the developer indicate whether the developer has completed consideration of the suggested guidance and a Helpfulness sub field to indicate the extent of usefulness that the guidance provided. Each of the sub fields have fields to display multiple problems the associated suggested guidance and completion and usefulness indicators. Further the screen has a Submit button to allow the developer to submit his or her feedback about the completion and usefulness of the suggested guidance.

One of skill in the art will appreciate that the above described features may be displayed directly on the screen or alternatively links tabs pull down lists or other display mechanisms could be utilized to provide the above features. Also one of skill in the art will appreciate that the above described features could be organized as shown in or in any other convenient way. Further one of skill in the art will appreciate that any information about coding quality such as metrics may be conveniently displayed on screen or through a link from screen .

In one embodiment the displayed code quality indices may be directly based on coding violations reported through static analysis. A plurality of coding violation indications corresponding to software code are categorized according to a plurality of coding quality attributes. The coding violation indications may be reported via static analysis tools or via manual analysis of the software code. The categorized coding violations may serve as the basis for determining a plurality of code quality indices each corresponding to a respective one of the plurality of coding quality attributes. The coding quality indices may further be processed to determine an overall code quality index for the software code. One or more of the resulting code quality indices may be displayed. Embodiments of coding quality indices are described in further detail in co pending Indian Patent Application 1987 MUM 2009 filed Sep. 1 2009 and entitled ASSESSMENT OF SOFTWARE CODE QUALITY BASED ON CODING VIOLATION INDICATIONS Applicant reference number 02178 PR IN .

The interactive guidance console unit is connected to the guidance feedback unit to identify which of the guidance alternatives was considered or tried by the developer and the extent of success of the developer in resolving the problem that could be attributed to the suggested guidance. The guidance feedback unit may be connected to the developer profile repository to provide input to update the dynamic profile records of the developer.

The events and environmental data processor may be connected to a periodic reporting unit which in one embodiment may provide periodic reports to the developer the development team or other interested party. The reports may include reports of the progress metrics created by the progress metric calculator or the guidance alternatives suggested by the guidance selector . The reports may include an identifier of the guidance used by the developer and the extent of success based on the guidance. The reports may also include updates to the guidance repository developer profile repository event characteristics database and environmental data repository .

At stage the processor processes the events data project data and developer data received from the events extractor to identify recurrence patterns of events that may demonstrate the existence of a problem. In addition to the data that it receives from the events extractor the processor uses data about the system environment in which the problem arose which it obtains from the environmental data repository . The processor also uses further data from the static and dynamic profiles of the developer which it obtains from the developer profile repository and data related to previous instances of guidance which it obtains from the guidance repository . Based on the recurrence patterns and the type of certain events the processor marks a problem as a recurring problem RP . Similarly the processor identifies the RPs which are no longer recurring for example in the manners disclosed above and calculates a value for Non Recurring Problem NRP .

At stage the processor identifies an event that may constitute a problem that could benefit from guidance. the processor identifies the event s category class and scope from the data analyzed in stage . From the event s category class and scope the processor identifies the problem that could benefit from guidance. The processor may also make the identification based in part on the category severity of the identified problem and the number of occurrences and or frequency of occurrences of the problem. The processor also determines the extent of difficulty that the developer is facing.

At stage the processor selects relevant guidance alternatives from the guidance repository . In one embodiment the processor makes the selections based on heuristic rules that are stored in an heuristic decision table in the guidance repository shown in . As described above the table has rules for selecting the kinds of guidance that may be associated with a selected event of a selected class and scope. If an event recurs it becomes a problematic event. Based on the problematic event s category class and scope the processor recommends guidance of a selected type in the order stored in the table .

For example in the embodiment illustrated in a developer facing a global event in the Test Related class and of the Project Specific scope may first receive a suggestion to check internal project artifacts followed by a suggestion to collaborate with a team member. For each problematic event the specific guidance suggestions for different types of guidance are stored in the guidance repository. If a developer has been offered a guidance and the problem still recurs that factual situation is recorded in the dynamic profile. The guidance next in order may be suggested.

The order of guidance to be suggested as recorded in table may change over time depending on a particular guidance type being considered more helpful for a particular event by the developers in their feedback. This table typically will also differ for developers with different levels of experience skills and time in the project. Data about a developer s levels of experience skills and time in the project is stored in the static developer profile and is made available to the processor in selecting the guidance to provide.

The guidance alternatives may be configured differently for developers with different levels of experience skill and assignment. The exemplary table for guidance selection rules is just an instance to be used for a moderately experienced and skilled person. If for example the person is new and inexperienced the first priority might be given to internal project or org level knowledge bases to make them more current date with what is common knowledge to a more experienced person. Therefore one of ordinary skill in the art will appreciate that there may be several heuristic tables for different levels of experience skill and assignment.

At stage the processor uses the guidance alternatives and the developer profile data from the developer profile repository to filter out the guidance already provided and to rank guidance according to past effectiveness. At a stage the processor provides identifies suggested guidance to the interactive guidance console unit . That information may be displayed for example on the screen in the Guidance sub field in sections 

As shown in the suggested guidance may be in the form of on line artifacts project artifacts and or collaboration. On line artifacts may include internal training documents internal knowledgebase documents or external knowledge base documents. Project artifacts may include documentation from the project including but not limited to prior events project logs and logged discussions. Suggestions of collaboration with others may include a suggestion to connect to subject matter experts within the project or to experts outside of the project for example experts within the organization.

At stage the processor may also provide information about suggested guidance to the periodic reporting unit which creates reports as required for example for review by supervisors or for other administrative uses about or the guidance alternatives suggested by the guidance selector . The reports may identify the guidance used by the developer and the extent of success based on the guidance. The reports may also include updates to the guidance repository developer profile repository event characteristics database and environmental data repository . Alternatively as shown in the updates are provided by the guidance feedback unit .

At stage the processor may also provide warnings about high code complexity or build failures to the console unit so that the screen can display an alert if the code shows signs of being highly complex or if build failures are occurring. The alerts may be displayed for example in the Build Failure API Usage Alert sub field and Complexity Alert sub field of Guidance field .

At stage the processor obtains information about code development in the project. Such information may include data from the static and dynamic profiles of the developer and of the developer s team members from the developer profile repository . Data may also include data related to local or global events from the local and global events monitors data from the event characteristics database data related to previous instances of guidance and whether it was followed by the developer from the guidance repository and data about the system environment in which problems arose from the environmental data repository .

At stage the developer progress score calculator of processor calculates metrics values representative of the quality of the progress made by the code developer for example developer and team DPS across a series of measurements. The calculator creates the developer and team DPS values for example in section of the screen . The processor may further generate the charts of DPS trends for example for display on the DPS trend display field of screen . The calculator may also generate a DPS percentile value to provide information as to the developer s progress relative to others on the development team for example for display in the DPS Percentile field of the screen .

At stage the calculator also calculates the developer and team PQS1 values to provide information about quality of the software development work and for example to display in the PQS display section of screen . The calculator may also calculate any other desired progress or quality values such as PQS2 or a moving average of PQS1 or PQS2 with a window of past scores. It may also develop percentile PQS1 percentile PQS2 composite PQS values or composite weighted PQS values for display on screens of the screen that are not here shown. The processor may develop graphs related to PQS score also for display on screen .

At stage the processor provides values of progress and quality metrics to the console unit for display. The processor may further provide progress and quality metrics graphs to the interactive guidance console unit so that the information may be displayed for example on the screen in the sections . At stage the processor may also provide quality warnings to the console unit so that the screen can display an alert if there are signs of low code development quality. The alert may be displayed for example in the Alert sub field and Performance Alert sub field of Recurring Problems and Guidance field .

At stage or in the embodiment shown in at stage the databases knowledge bases and repositories are updated. The updating may be done by the processor or as shown in the console unit may forward the information to the guidance feedback unit so that the unit may perform the updating.

One of skill in the art will appreciate that the above described stages may be embodied in distinct software modules. Although the disclosed components have been described above as being separate units one of ordinary skill in the art will recognize that functionalities provided by one or more units may be combined. As one of ordinary skill in the art will appreciate one or more of units may be optional and may be omitted from implementations in certain embodiments.

The foregoing description has been presented for purposes of illustration. It is not exhaustive and does not limit the invention to the precise forms or embodiments disclosed. Modifications and adaptations of the invention will be apparent to those skilled in the art from consideration of the specification and practice of the disclosed embodiments. For example the described implementations may be implemented in software hardware or a combination of hardware and software. Examples of hardware include computing or processing systems such as personal computers servers laptops mainframes and micro processors. In addition one of ordinary skill in the art will appreciate that the records and fields shown in the figures may have additional or fewer fields and may arrange fields differently than the figures illustrate. It is intended that the specification and examples be considered as exemplary only with a true scope and spirit of the invention being indicated by the following claims.

