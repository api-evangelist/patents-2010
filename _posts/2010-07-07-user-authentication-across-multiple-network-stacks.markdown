---

title: User authentication across multiple network stacks
abstract: A computing device provides an application that uses multiple protocol stacks to communicate with a server. The server requires messages from each of the protocol stacks to include a credential for a user of the computing device. The credential is a set of information that includes identification and proof of identities that is used to gain access to a resource. However, the user is not prompted for the credential more than once. In some embodiments, this is accomplished by storing the credential at the computing device for retrieval by the protocol stacks when the application uses the protocol stacks to communicate with the server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08412836&OS=08412836&RS=08412836
owner: Microsoft Corporation
number: 08412836
owner_city: Redmond
owner_country: US
publication_date: 20100707
---
Client devices can communicate with servers for a variety of reasons. For example a client device can communicate with a server to retrieve a document stored on the server. In another example a client device can communicate with a server to upload a document to the server. In yet another example a client device can communicate with a server to stream audio or video from the server.

In some instances client devices can use multiple protocol stacks to communicate with the same server. A protocol stack is a set of communications protocols that work together to enable communication on a network. For example a client device can use a protocol stack associated with the Web DAV protocol and a protocol stack associated with the File Transfer Protocol FTP to communicate with the same server.

Furthermore in some instances where a client device uses multiple protocol stacks to communicate with the same server the server requires each message from each of the protocol stacks to include a credential for a user of the client device. A credential is a set of information that includes identification and proof of identities that is used to gain access to a resource. Example types of credentials include usernames and passwords certificates biometric data one time passwords and so on.

Each of the protocol stacks maintains a separate session state. When the protocol stacks detect that the server requires a credential the protocol stacks prompt the user for the credential and store the credential as part of their respective session states. The protocol stacks can reuse this credential in later messages to the server. Consequently the protocol stacks do not need to prompt the user for the credential each time the protocol stacks send messages to the server. However each of the protocol stacks still needs to separately prompt the user to provide the credential. In other words if the client device uses five protocol stacks to communicate with the server five separate session states are maintained and the user is prompted for the credential five separate times. Providing the credential multiple times can be annoying and or confusing to the user.

An application uses multiple protocol stacks to communicate with a server over a communications network. The server requires messages from each of the protocol stacks to include a credential for a user. Despite the fact that the server requires messages from each of the protocol stacks to include the credential the user is not prompted for the credential more than once. This may improve the user experience of the application. In some embodiments the credential is stored at the computing device for retrieval by the protocol stacks when the application uses the protocol stacks to communicate with the server. In this way once the credential is stored at the client device it may not be necessary to prompt the user for the credential again.

This summary is provided to introduce a selection of concepts. These concepts are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is this summary intended as an aid in determining the scope of the claimed subject matter.

The server is a computing system that stores documents. The server can store various types of documents. For example the server can store word processor documents spreadsheet documents note documents slide presentation documents web page documents desktop publishing documents project design documents diagram documents image documents and other types of documents. Some of the documents stored by the server might contain information that should be kept secret from the general public.

A user uses the client device to retrieve and work on documents stored by the server . Furthermore in some embodiments the user can use the client device to create new documents and to store the new documents at the server . To help the user retrieve generate and store documents the client device provides an application. For example the client device can provide a word processing application such as the MICROSOFT WORD word processing document to help the user retrieve generate and store word processor documents. In another example the client device can provide a spreadsheet application such as the MICROSOFT EXCEL spreadsheet application to help the user retrieve generate and store spreadsheet documents. In other examples the client device can provide other types of applications including note taking applications slide presentation applications web page design applications desktop publishing applications project design applications diagram drawings applications media editing applications and so on.

To retrieve documents stored by the server and to store documents to the server the client device communicates with the server via the network . In particular the application provided by the client device uses multiple protocol stacks to communicate with the server . A protocol stack is a set of communications protocols that work together to enable communication on a network. A communications protocol is a set of rules or standards designed to enable computers to connect with one another and to exchange information. Example types of communications protocols include the Hypertext Transfer Protocol HTTP the File Transfer Protocol FTP the SOAP protocol and so on.

To protect the documents stored by the server from being accessed by people who do not have the right to access the documents the server can require messages from each of the protocol stacks to include a credential for the user . A credential is a set of information that includes identification and proof of identities that is used to gain access to a resource. Example types of credentials include usernames and passwords certificates biometric data one time passwords and so on.

Although the server can require messages from each of the protocol stacks to include a credential for the user the client device does not prompt the user for a credential to use with the server more than once. That is the client device may prompt the user to provide a credential to use with the server once but the client device does not need to prompt the user for the same credential for each of the multiple protocol stacks used by the application to communicate with the server . The user could find it annoying to provide the same credential multiple times. Consequently not needing to prompt the user for the same credential multiple times could improve the experience of using the application.

As illustrated in the example of the client device includes a data storage system a processing system a network interface a video adapter and an input interface . It should be appreciated that the client device can contain many other devices modules systems interfaces and other components. Such other components are omitted from the example of for the sake of clarity.

The data storage system is a set of one or more computer storage media. A computer medium is a physical device or article of manufacture that is capable of storing computer readable information. The processing system is a system comprising one or more processing units. A processing unit is an integrated circuit or other type of device that executes computer readable instructions. The network interface is a component that enables the client device to communicate with other computing devices via a network. The video adapter is a component that enables the client device to generate a video signal sent to a device e.g. a monitor that displays video represented by the video signal. The input interface is a component that enables the user to provide input to the client device . For example the input interface can be a component that enables the user to provide keyboard and or pointer input to the client device .

As illustrated in the example of the data storage system stores computer readable instructions and or other data that when executed or otherwise used by the processing system cause the client device to provide an application a set of protocol stacks A through N a credential module a sync module and a local cache . The protocol stacks A through N are collectively referred to herein as the protocol stacks . It should be appreciated that the data storage system can store computer readable instructions that when executed by the processing system cause the client device to provide other functionality. Furthermore it should be appreciated that the data storage system can store data other than that illustrated in the example of .

In various embodiments the application can be various different types of applications. For example the application can be a word processing a spreadsheet application or another type of application.

Each of the protocol stacks provides a software infrastructure for a different protocol stack. As also discussed elsewhere in this specification a protocol stack is a set of communications protocols that work together to enable communication on a network. In various embodiments the protocol stacks provide the software infrastructure for protocol stacks that include various communications protocols. For example the protocol stack A can provide a software infrastructure for a protocol stack that includes the Internet Protocol version 4 IPv4 protocol the Transmission Control Protocol TCP and HTTP. In this example the protocol stack B not shown can provide a software infrastructure for a protocol stack that includes the Internet Protocol version 6 IPv6 TCP and HTTP. Furthermore in this example the protocol stack C not shown can provide a software infrastructure for a protocol stack that includes the Web DAV protocol and other protocols.

The protocol stacks receive requests from the application to send data. In response to such requests the protocol stacks use the network interface to send requests to the server . If the server requires a credential the server responds to the requests with messages that indicate that the server requires a credential. When the protocol stacks receive messages that indicate that the server requires a credential the protocol stacks send requests for credentials to the credential module . The credential module responds to such requests with the appropriate credentials for the server . Upon receiving the credentials from the credential module the protocol stacks use the credentials in subsequent requests to the server .

When the credential module receives a request for a credential from one of the protocol stacks the credential module determines whether the credential is stored locally. If the credential is stored locally the credential module provides the credential to the protocol stack without prompting the user to provide the credential. If the credential is not stored locally the credential module performs an operation to obtain the credential. After obtaining the credential the credential module stores the credential locally and copy the credential to the protocol stack.

When the application obtains a copy of a document from the server or generates a new document the application can store the document in the local cache . In some circumstances the client device can lose connectivity with the server after the application opens a document stored by the server . Furthermore in such circumstances the user can close the document and or the application . The document remains stored in the local cache . When the client device regains connectivity with the server the sync module attempts to use credentials stored by the credential module to synchronize a copy of the document stored in the local cache with a version of the document stored at the server .

Although not illustrated in the example of the client device can provide multiple applications. For example the client device can provide a word processing application and a spreadsheet application. When the client device provides multiple applications the protocol stacks can use the credential module in response to requests from each of these applications. Consequently if the credential module contains a credential associated with the server because of a communication between a first application and the server one of the protocol stacks can use this credential when communicating with the server in response to a request from another application. As a result if the user provided a credential associated with the server through one application provided by the client device the user might not need to provide the credential again through another application provided by the client device .

In response to receiving the input from the user to start the communication operation the application provides a request to one of the protocol stacks . For ease of explanation this specification assumes that the application provides a request to the protocol stack A in step . The request provided to the protocol stack A requests the protocol stack A to send some information to the server . For example the request provided to the protocol stack A can be a request to retrieve information about folders maintained by the server .

After providing the request to the protocol stack A the application receives a response from the protocol stack A . The response from the protocol stack A can include various types of data. For example the response from the protocol stack A can include information about folders maintained by the server . The application can then process the data in the response from the protocol stack A . The application can process the data in the response from the protocol stack A in various ways. Continuing the previous example the application can process the data in the response from the protocol stack A by displaying the information about the folders maintained by the server to the user .

The application also sends a request to another one of the protocol stacks . For ease of explanation this specification assumes that the application provides a request to the protocol stack B in step . The request provided to the protocol stack B requests the protocol stack B to send some information to the server . For example the request provided to the protocol stack B can be a request to retrieve data about documents stored in a particular folder maintained by the server .

After providing the request to the protocol stack B the application receives a response from the protocol stack B . The response from the protocol stack B can include various types of data. For example the response from the protocol stack B can include information about documents stored in a particular folder maintained by the server . The application can then process the data in the response from the protocol stack B . The application can process the data in the response from the protocol stack B in various ways. Continuing the previous example the application can process the data in the response from the protocol stack B by displaying the information about the documents in the particular folder to the user .

It should be appreciated that the operation is merely an example. In other embodiments the application can perform more complex operations involving multiple ones of the protocol stacks . For example the communication operation can be an operation to open a document stored by the server . In this example the application can use one of the protocol stacks to send one or more Web DAV protocol requests to the server . The Web DAV protocol requests retrieve information that describes a folder hierarchy maintained by the server . The application can then use another one of the protocol stacks to send one or more Web View protocol requests to the server . The Web View protocol requests retrieve data about documents in a particular one of the folders. The application can then use yet another one of the protocol stacks to send one or more FPRPC protocol requests to the server . The FPRPC protocol requests retrieve metadata regarding a particular one of the documents. Next the application can use yet another one of the protocol stacks to send one or more Web DAV protocol requests to the server . These Web DAV protocol requests retrieve a file from the server . In other embodiments the application uses a protocol stack to send one or more MS FSSHTTP protocol requests to the server to retrieve the document instead of the Web DAV protocol requests.

As illustrated in the example of the operation begins when the protocol stack A receives a request from the application to send data to the server . In various embodiments the application can receive the request from the application in various ways. For example in some embodiments the application can provide the request to the protocol stack A by invoking a method of an Application Programming Interface API provided by the protocol stack A an operating system of the client device or another component provided by the client device . In other embodiments the application can use a callback to provide the request to the protocol stack A.

After receiving the request from the application the protocol stack A sends a request to the server . In some cases the request sent to the server can include the data indicated by the application . In other cases the request sent to the server can be a request to set up a connection or session with the server and might not contain the data indicated by the application .

After the protocol stack A sends the request to the server the protocol stack A receives a response from the server . The response is responsive to the request sent by the protocol stack A to the server . When the protocol stack A receives the response from the server the protocol stack A determines whether the response indicates that the request was successful . If the protocol stack A determines that the response indicates that the request was successful YES of the protocol stack A can provide data in the response to the application and the operation is complete. In other embodiments when the response indicates that the request was successful the protocol stack A and the server can exchange one or more additional messages before the protocol stack A ultimately provides data to the application .

On the other hand if the request was not successful NO of the protocol stack A determines whether the request failed because a credential was needed . Requests can fail for a variety of reasons. For example a request can fail because the server did not respond to the request because a requested resource is not available on the server or for other reasons. If the request failed but not because a credential was needed NO of the protocol stack A sends an error message to the application . For example the protocol stack A can send an error message to the application indicating that a requested resource does not exist at the server .

If the request was not successful because the server requires a credential the protocol stack A has detected that the server requires the credential. Hence if the request was not successful because a credential was needed YES of the protocol stack A provides a request for the credential to the credential module . The request for the credential includes a server name of the server or the server is otherwise identified to the credential module when the protocol stack A provides the request for the credential to the credential module .

In various embodiments the protocol stack A provides the request for the credential to the credential module in various ways. For example in some cases the protocol stack A provides the request to the credential module by invoking one or more methods of an API provided by the credential module the operating system of the client device or another component provided by the client device . In other cases the credential module registers a callback with the protocol stack A when the credential module is initialized. In such embodiments the protocol stack A uses the callback to provide the request for the credential to the credential module . Furthermore in some embodiments different ones of the protocol stacks can provide the requests to the credential module in different ways. For example one of the protocol stacks associated with the HTTP protocol can use an API to provide requests to the credential module and one of the protocol stacks associated with the Web DAV protocol can use the callback technique to provide requests to the credential module .

Subsequently the protocol stack A receives a credential from the credential module . After receiving the credential from the credential module the protocol stack A sends a request with the credential to the server . This request can be the same type or a different type of request than the request initially sent in step . After sending the request with the credential the protocol stack A receives another response from the server and the protocol stack A can repeat the subsequent steps.

In response to receiving the request for a credential the credential module determines whether the credential module has stored a credential for the server . In various embodiments the credential module determines whether a credential has been stored for the server in various ways. For example the credential module can maintain a mapping data structure such as a hash table that maps the URIs of servers to credentials for the servers. If the credential module determines that the credential module has stored a credential for the server YES of the credential module provides the credential for the server to the protocol stack .

On the other hand if the credential module determines that the credential module has not stored a credential for the server NO of the credential module determines a credential type utilized by the server by communicating with the server . In various embodiments the credential module can determine the credential type utilized by the server in various ways. For instance illustrates one example operation to determine the credential type utilized by the server . is described in detail elsewhere in this specification. It should be appreciated that the credential module can use operations other than that illustrated in the example of to determine the credential type utilized by the server .

After determining the credential type utilized by the server the credential module prompts the user to provide a credential belonging to the credential type . After the credential module prompts the user to provide the credential the credential module receives a credential from the user . The credential module can prompt the user to provide a credential in various ways. For example if the credential utilized by the server is a username and password the credential module can use the video adapter to display a dialog box that has a field for a username and a field for a password. In another example if the credential utilized by the server is a certificate password combination the credential module can use the video adapter to display a dialog box for selecting a certificate from a file system and another dialog box that has a field for entering a password associated with the certificate. In yet another example if the credential utilized by the server is a fingerprint the credential module can use the video adapter to prompt the user to swipe his or her finger over a fingerprint reader.

After the credential module receives the credential from the user the credential module sends a request with the credential to the server . In various embodiments the credential module can send various requests with the credential to the server . For example in some embodiments the credential module can send HTTP HEAD or HTTP OPTIONS requests to the server . In this example the HTTP HEAD or HTTP OPTIONS requests include the credential in headers in these requests. In other embodiments other types of requests are used.

After sending the request with the credential to the server the credential module receives a response from the server . The credential module then uses the response to determine whether the request was successful . The request is successful if the server successfully validated the credential. If the request was not successful NO of the credential module prompts the user to provide a credential again . The credential module can continue prompting the user to provide credentials until the user provides a credential that the server successfully validates or until the user quits.

If the credential module determines that the request was successful YES of the credential module stores the credential . The credential module stores the credential such that the credential module can retrieve the credential when provided with information that identifies of the server . After storing the credential the credential module provides the credential to the protocol stack . The credential module can repeat the operation each time the credential module receives a request from one of the protocol stacks for a credential.

In some circumstances one or more proxy servers can exist on a network route between the client device and the server . A proxy server is a computer that acts as a barrier between a network and another network by presenting only a single network address to external sites. In some instances proxy servers require credentials from users in order to allow messages from the users to flow through the proxy servers. The credential module can automatically repeat the operation for each proxy server on a network route between the client device and the server . This can save the user the trouble of providing credentials to the proxy servers for each of the protocol stacks used by the application to communicate with the server .

After sending the OPTIONS request the credential module receives an OPTIONS response . The OPTIONS response is responsive to the OPTIONS request. After the credential module receives the OPTIONS response the credential module determines whether the OPTIONS response indicates that the OPTIONS request was successful .

If the OPTIONS request was successful the OPTIONS response includes information about the communications options available on the server . Some servers do not require any authentication in order to provide a successful response to an OPTIONS request but do require authentication for other types of requests. Consequently if the OPTIONS request was successful the OPTIONS response does not necessarily include information about a credential type requested by the server . If the OPTIONS request is not successful the OPTIONS response can include information indicating the credential type requested by the server . Hence if the OPTIONS request is not successful NO of the server determines the credential type requested by the server from the OPTIONS response .

On the other hand if the OPTIONS response is successful YES of the credential module sends an HTTP HEAD request to the server . The HEAD request specifies a resource hosted by the server . The IETF RFC 2616 defines the HEAD request. The HEAD request can be used for obtaining metadata about a resource indicated by the HEAD request without transferring the body of the resource to the client. After sending the HEAD request the credential module receives a HEAD response from the server . Typically if a server requests a credential to access a resource the server does generate a successful HEAD response without such a credential. Hence the HEAD response indicates that the HEAD response was not successful and includes information that indicates a credential type requested by the server . Thus when the credential module receives the HEAD response the credential module determines the credential type for the server from the HEAD response .

Subsequently the application determines whether the application has received a shutdown event . The shutdown event is an event that instructs the application to shut down. The application can receive the shutdown event in a variety of circumstances. For example the application can receive the shutdown event when the user provides input that instructs the application to shut down. In another example the application receives the shutdown event when the client device is preparing to shut down. If the application has not received input from the user to close the application NO of the application can perform one or more other tasks before eventually determining again whether the application has received input from the user to close the application .

If the application has received a shutdown event YES of the application determines whether the client device is able to communicate with the server . If the application determines that the client device is able to communicate with the server YES of the application communicates with the server to synchronize the local copy of the document with the corresponding server copy of the document . In various embodiments the application can synchronize the local copy of the document with the server copy of the document in various ways. For example the application can synchronize the copies of the document by sending the complete local copy of the document to the server . In another example the application can synchronize the copies of the document by sending to the server data that represents changes made to the local copy of the document. In this example the server applies these changes to the server copy of the document to update the server copy of the document.

After synchronizing the local copy of the document with the corresponding server copy of the document the application shuts down . In some embodiments the credential module also shuts down when the application shuts down. Furthermore in some embodiments the application removes the local copy of the document from the local cache after synchronizing the local copy of the document with the corresponding service copy of the document. In other embodiments the local copy of the document remains in the local cache after the application shuts down.

On the other hand if the application is not able to communicate with the server NO of the application instructs the credential module to send a credential for the server to the sync module . In this way the sync module receives the credential that the sync module can later use to synchronize the local copy of the document with the server copy of the document. In addition the application generates a document identifier map . The document identifier map is a data structure that maps an identifier of the local copy of the document to an identifier of the server copy of the document. For example the document identifier map can map a file system path name for the local copy of the document to a URL of the server copy of the document. The sync module uses such document identifier maps when synchronizing local copies of documents with server copies of the documents. At some time after generating the document reference map the application shuts down .

When the sync module starts the sync module identifies servers that are associated with documents in the local cache and for which the sync module has credentials . The sync module then starts retry timers for at least some of the identified servers . The retry timers generate events when particular time periods expire. For example a retry timer can generate an event when ten minutes expire. In another example a retry timer can generate an event when five minutes expire.

After starting the retry timers the sync module enters a processing loop in which the sync module responds to events. As illustrated in the example of the sync module first determines whether the sync module has received a credential for a server from the credential module . The credential module can provide the credential to the sync module when the application shuts down. If the sync module receives a credential for a server YES of the sync module stores the credential for the server . The sync module then starts a retry timer for the server .

Else if the sync module did not receive a credential NO of the sync module determines whether a retry timer for a server expired . If no retry timer for the server expired NO of the sync module can wait for another event and repeat the processing loop. On the other hand if a retry timer for a server expired YES of the sync module determines whether the client device is able to communicate with the server . In various embodiments the sync module determines whether the client device is able to communicate with the server in various ways. For example the sync module can determine whether the client device is able to communicate with the server by sending HTTP HEAD or OPTIONS requests to the server. If the sync module is not able to communicate with the server NO of the sync module restarts the retry timer for the server . After restarting the retry timer for the server the sync module can repeat the processing loop when the sync module receives another event. If the sync module is able to communicate with the server YES of the sync module uses the credential stored by the sync module to synchronize local copies of documents associated with the server with corresponding server copies of the documents . The sync module can use document identifier maps to identify server copies of documents that correspond to the local copies of documents.

A computing system is a system comprising one or more computing devices. A computing device is a physical device that is capable of processing information. Example types of computing devices include desktop computers laptop computers standalone server computers blade server computers mobile telephones personal media players video game consoles computers integrated into vehicles television set top boxes intermediate network devices and other types of physical devices that are capable of processing information.

In different embodiments computing devices are implemented in different ways. For instance in the example of the computing device comprises a memory a processing system a secondary storage device a network interface card a video interface a display device an external component interface an external storage device an input device and a communication medium . In other embodiments computing devices are implemented using more or fewer hardware components. For instance in another example embodiment a computing device does not include a video interface a display device an external storage device or an input device.

The term computer readable media as used herein may include computer storage media. Computer storage media may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. The memory includes one or more computer storage media capable of storing data and or instructions. As used in this document a computer storage medium is a device or article of manufacture that stores data and or software instructions readable by a computing device. In different embodiments the memory is implemented in different ways. For instance in various embodiments the memory is implemented using various types of computer storage media. Example types of computer storage media include but are not limited to dynamic random access memory DRAM double data rate synchronous dynamic random access memory DDR SDRAM reduced latency DRAM DDR2 SDRAM DDR3 SDRAM Rambus RAM solid state memory flash memory read only memory ROM electrically erasable programmable ROM and other types of devices and or articles of manufacture that store data.

The term computer readable media as used herein may also include communication media. Communication media may be embodied by computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may describe a signal that has one or more characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media may include wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media.

The processing system is a system comprising one or more processing units. Processing units include one or more physical integrated circuits that selectively execute software instructions. In various embodiments the processing system is implemented in various ways. For instance in one example embodiment the processing system is implemented as one or more processing cores. For instance in this example embodiment the processing system may be implemented as one or more Intel Core 2 microprocessors. In another example embodiment the processing system is implemented as one or more separate microprocessors. In yet another example embodiment the processing system is implemented as an ASIC that provides specific functionality. In yet another example embodiment the processing system provides specific functionality by using an ASIC and by executing software instructions.

In different embodiments the processing system executes software instructions in different instruction sets. For instance in various embodiments the processing system executes software instructions in instruction sets such as the x86 instruction set the POWER instruction set a RISC instruction set the SPARC instruction set the IA 64 instruction set the MIPS instruction set and or other instruction sets.

The secondary storage device includes one or more computer readable data storage media. The secondary storage device stores data and software instructions not directly accessible by the processing system . In other words the processing system performs an I O operation to retrieve data and or software instructions from the secondary storage device . In various embodiments the secondary storage device is implemented by various types of computer readable data storage media. For instance the secondary storage device may be implemented by one or more magnetic disks magnetic tape drives CD ROM discs DVD ROM discs Blu Ray discs solid state memory devices Bernoulli cartridges and or other types of computer readable data storage media.

The network interface card enables the computing device to send data to and receive data from a computer communication network. In different embodiments the network interface card is implemented in different ways. For example in various embodiments the network interface card is implemented as an Ethernet interface a token ring network interface a fiber optic network interface a wireless network interface e.g. WiFi WiMax etc. or another type of network interface.

The video interface enables the computing device to output video information to the display device . In different embodiments the video interface is implemented in different ways. For instance in one example embodiment the video interface is integrated into a motherboard of the computing device . In another example embodiment the video interface is a video expansion card. Example types of video expansion cards include Radeon graphics cards manufactured by ATI Technologies Inc. of Markham Ontario Geforce graphics cards manufactured by Nvidia Corporation of Santa Clara Calif. and other types of graphics cards.

In various embodiments the display device is implemented as various types of display devices. Example types of display devices include but are not limited to cathode ray tube displays LCD display panels plasma screen display panels touch sensitive display panels LED screens projectors and other types of display devices. In various embodiments the video interface communicates with the display device in various ways. For instance in various embodiments the video interface communicates with the display device via a Universal Serial Bus USB connector a VGA connector a digital visual interface DVI connector an S Video connector a High Definition Multimedia Interface HDMI interface a DisplayPort connector or other types of connectors.

The external component interface enables the computing device to communicate with external devices. In various embodiments the external component interface is implemented in different ways. For instance in one example embodiment the external component interface is a USB interface. In other example embodiments the computing device is a FireWire interface a serial port interface a parallel port interface a PS 2 interface and or another type of interface that enables the computing device to communicate with external components.

In different embodiments the external component interface enables the computing device to communicate with different external components. For instance in the example of the external component interface enables the computing device to communicate with the external storage device and the input device . In other embodiments the external component interface enables the computing device to communicate with more or fewer external components. Other example types of external components include but are not limited to speakers phone charging jacks modems media player docks other computing devices scanners digital cameras a fingerprint reader and other devices that can be connected to the computing device .

The external storage device is an external component comprising one or more computer readable data storage media. Different implementations of the computing device interface with different types of external storage devices. Example types of external storage devices include but are not limited to magnetic tape drives flash memory modules magnetic disk drives optical disc drives flash memory units zip disk drives optical jukeboxes and other types of devices comprising one or more computer readable data storage media. The input device is an external component that provides user input to the computing device . Different implementations of the computing device interface with different types of input devices. Example types of input devices include but are not limited to keyboards mice trackballs stylus input devices key pads microphones joysticks touch sensitive display screens and other types of devices that provide user input to the computing device .

The communications medium facilitates communication among the hardware components of the computing device . In different embodiments the communications medium facilitates communication among different components of the computing device . For instance in the example of the communications medium facilitates communication among the memory the processing system the secondary storage device the network interface card the video interface and the external component interface . In different implementations of the computing device the communications medium is implemented in different ways. For instance in different implementations of the computing device the communications medium may be implemented as a PCI bus a PCI Express bus an accelerated graphics port AGP bus an Infiniband interconnect a serial Advanced Technology Attachment ATA interconnect a parallel ATA interconnect a Fiber Channel interconnect a USB bus a Small Computing system Interface SCSI interface or another type of communications medium.

The memory stores various types of data and or software instructions. For instance in the example of the memory stores a Basic Input Output System BIOS an operating system application software and program data . The BIOS includes a set of software instructions that when executed by the processing system cause the computing device to boot up. The operating system includes a set of software instructions that when executed by the processing system cause the computing device to provide an operating system that coordinates the activities and sharing of resources of the computing device . Example types of operating systems include but are not limited to MICROSOFT WINDOWS Linux Unix Apple OS X Apple OS X iPhone Palm webOS Palm OS Google Chrome OS Google Android OS and so on. The application software includes a set of software instructions that when executed by the processing system cause the computing device to provide applications to a user of the computing device . The program data is data generated and or used by the application software .

The various embodiments described above are provided by way of illustration only and should not be construed as limiting. Those skilled in the art will readily recognize various modifications and changes that may be made without following the example embodiments and applications illustrated and described herein. For example the embodiments have been described with regard to a document. However other embodiments apply the techniques described in this specification to other types of hierarchical data structures. Furthermore the operations shown in the figures are merely examples. In various embodiments similar operations can include more or fewer steps than those shown in the figures. Furthermore in other embodiments similar operations can include the steps of the operations shown in the figures in different orders.

