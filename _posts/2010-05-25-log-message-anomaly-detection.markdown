---

title: Log message anomaly detection
abstract: One or more techniques and/or systems are disclosed for detecting anomalies in a message log. A log message is parsed from an unstructured text string to a structured form, comprising messages signature and parameter values. Structured log messages that contain a same parameter value of a same program variable are grouped together. One or more invariants for are identified from respective types of log message groups. Invariants are applied to log sequences of respective log types.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08495429&OS=08495429&RS=08495429
owner: Microsoft Corporation
number: 08495429
owner_city: Redmond
owner_country: US
publication_date: 20100525
---
A software system such as a program executed on a computer can generate a console log message that may be used to troubleshoot the program. For example console log messages are typically unstructured free form text strings which can record events or states of interest and capture a system developers intent. These logs can be read by a developer or user to detect the events states and other interesting occurrences for example. Usually when a program execution fails e.g. does not perform according to expectations system operators can examine recorded log files to gain insight about the failure and find out the potential root causes. These logs can be utilized for debugging distributed systems where checking the console logs to locate system problems which is usually most applicable as an instrumentation or dump based approach may make a system to behavior differently from its daily execution and introduce overhead.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Large scale data centers may consist of thousands of distributed components including servers network devices distributed computing software components and operating systems for example. Due to an increasing scale and complexity of distributed systems it may be very time consuming for a human operator to diagnose system problems by manually examining a great amount of log messages. Therefore in this example automated tools for problem diagnosis through log analysis are desirable for use in diagnosis of distributed systems.

Current and previous automatic detection systems and techniques check logs with a set of rules that describe normal system behaviors. These rules are typically manually predefined by experts according to their knowledge about system design and implementation. However it can be very expensive to manually define such rules because a great amount of system experts efforts are often used. Further modern systems often comprise multiple components developed by different groups or even different companies and a single expert may not have the complete knowledge of the system necessitating close cooperation of multiple experts. Additionally after a system upgrade the experts may need extra efforts to check or modify the predefined rules again.

Some current statistic learning based automatic tools have been developed that can analyze console logs profiles and measurements for system monitoring and trouble shooting. These approaches typically extract features from logs traces or profiles then use statistical techniques such as subspace analysis clustering and classification algorithms to automatically build models then identify failures or problems according to the learned models. However most of the learned models are black box models that cannot be easily understood by human operators. That is for example they may detect anomalies in a high dimensional feature space but do not provide intuitive and meaningful explanations for the detected anomalies.

Accordingly one or more techniques and or systems are disclosed that can be used to mine system invariants from console logs based on a statistical learning technique. For example program invariants have clear physical meanings that can be easily understood by a human operator. Therefore these techniques can detect system problems and give a meaningful interpretation for respective detected anomaly for example. In one embodiment an interpretation can associate the anomaly with program execution logic which can significantly help system operators to diagnose system problems.

In one embodiment for detecting anomalies in a message log a log message is parsed from an unstructured text string to a structured form such as by breaking it into a message signature and parameters. Structured log messages that contain a same value of a same program variable are grouped together and one or more invariants are identified from respective types of log message groups. In order to detect anomalies invariants are applied to log sequences of respective log types.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

A method may be devised that provides for mining system invariants from console logs such as from a program execution for example based on a statistical learning technique. Unlike current and previous approaches a program invariant can have a clear physical meaning that may be easily understood by a human operator for example. An exemplary method may detect system problems and provide a meaningful interpretation for detected anomalies. Such an interpretation for example can associate the anomaly with execution logic which can significantly help system operators to diagnose system problems.

At structured log messages that contain a same value of a same program variable are grouped. In one embodiment after parsing it may be determined whether a set of parameters correspond to a same program variable e.g. from an executed program from which the log messages are created . In this embodiment log messages that comprise a same value of a same program variable can be grouped together. For example log messages containing a same request ID value can be grouped together. Further by dividing log messages into some close inner related groups for example computational costs can largely be reduced.

At one or more invariants are identified for respective types of log message groups. In one embodiment after grouping log messages a compact sparse integer invariant set can be determined for example for respective types of the log message groups. In one embodiment message groups that are extracted according to the same program variable may be considered as the same type of group. For example the group of log messages with a request ID and the group of log messages with a request ID can be the same type of message groups. In one embodiment a brute force searching algorithm can be combined with a greedy searching algorithm to make the invariant searching process more tractable.

At invariants are applied to log sequences of respective log types to detect anomalies. In one embodiment after obtaining one or more sets of invariants the obtained sets can be applied to detect anomalies. For example a log sequence that violates an invariant can be labeled as an anomaly. In this example by detecting the anomalies in the message logs from an executed program problems in the execution may be identified automatically that is mitigating human involvement in manually searching through the logs to look for errors.

A simple example of program execution flow is illustrated in comprising stages of the program execution A B C D and E where an example condition may be present to direct the flow accordingly. In this embodiment a system executing the program can print a corresponding log message A E at the respective stages . Typically there can be multiple running instances that follow the execution flow shown in the exemplary embodiment . Further in some embodiments different instances may execute different branches and their produced logs may interleave together.

In one embodiment in the exemplary embodiment of a program execution flow the following equations are to be satisfied where c A c B c C c D c E denote a number of log messages A E in the logs respectively. The respective equations can correspond to a specific invariant of the program execution flow for example and validity of such invariants may not be affected by dynamics of the workloads e.g. varying workloads of the program executed multiple time a difference of system inputs e.g. into the program or an interleaving of multiple instances e.g. of the program execution .

In one embodiment these invariants may be identified as execution flow invariants. As an example a violation of these equations invariants may identify a program execution error. Because log sequences can record an underlying execution flow of system components in a program there may be many such linear equations e.g. invariants among the log sequences. In one embodiment automatically discovering respective invariants from collected historical log data for the program execution may facilitate error detection for example and further system management tasks.

Generally as an illustrative example log messages printed by a same log print statement in a source code are a same type of message as they may correspond to a same execution point and record a same kind of program event having a same semantic meaning. Alternatively for example different types of log messages can be used to record different program events having different semantic meanings and printed by different log printed statements. In one embodiment a free form text string in the log print statement can be used as a signature to represent the log message type. As an example a message signature can correspond to a constant content of respective log messages printed by the same log print statement. Further in this embodiment parameter values can be recorded variable values in the log print statement which may vary in different executions.

As an illustrative example illustrates an example log message . In this example the log message can be parsed into message signatures and parameter values . Parsing the log messages may be performed more easily if the corresponding source code is available for example but this is typically not the case. Therefore in one embodiment empirical rules can be applied to extract parameter values leaving raw message signatures e.g. message types to be extracted.

As an example empirical rules and a few general heuristics may be applied to extract some content that meets typical parameter patterns e.g. such as numbers uniform resource identifiers URIs Internet protocol IP addresses and globally unique identifiers GUIDs . Further in this example after extracting typical parameter values from the log messages by the empirical rules the remained parts of log messages may be categorized as a set of raw message signatures. Because all of the parameter values may not be extracted by the heuristics empirical rules approach raw message signatures may still contain some parameter values.

At of the exemplary embodiment of a clustering algorithm can be applied to the raw message signatures to obtain a set of clusters e.g. comprising similar elements . In one embodiment a weighted string edit distance e.g. a weighted Levenshtein distance may be used to evaluate similarity between two raw message signatures. After clustering a splitting procedure can be applied on the obtained clusters for example according to a diversity of content difference in the cluster. In this embodiment after the splitting processing final clusters can be obtained.

At for respective final clusters a common string in the cluster is may be considered as a message signature and remaining parts can be recognized as parameter values. In this way in this embodiment the signatures can be extracted and the remaining parameter values can be extracted.

As an example for a log message in we can denote an extracted message signature as K m a number of parameters as PN m and an iparameter s value as PV m i . In this example after message signature and parameter value extraction respective log messages in with a time stamp T m can be represented by a multi tuple 1 2 . . . which may be designated as a tuple form representation of the log messages e.g. A F .

Developers of programs often print out the same important program variable in multiple log print statements. In one embodiment multiple parameters may correspond to a same program variable which may be considered as cogenetic parameters e.g. created at a same time and or in a same place . For example a program variable e.g. request ID can appear as parameters in different log message types which may be related to execution flow of a request processing.

As another example as illustrated in the first three log messages A C and the fourth log message D the parameter at the position two B of the message signature Start TCP Job ID and the parameter at the position one A of the message signature Image file of job loaded in seconds size may be cogenetic parameters because they represent a same program variable e.g. JobID . In this exemplary embodiment for example these cogenetic parameters can be grouped.

At in the exemplary embodiment of a value range of a log parameter for a log message is enumerated. For example log messages can be collected several times as a target program runs under different workloads. In this example for respective times of collection the collected log messages can comprise a log bunch which may contain several log files from distributed machines. Further in one embodiment a value range for a particular parameter can be determined for the log bunch comprising the plurality of values from the respective times of collection for example. In this embodiment the value range for a particular parameter e.g. defined by its signature and index can comprise respective distinct values within respective log bunches. Therefore for example a value range for log parameters comprises values from a plurality of execution of a program resulting in a plurality of log messages.

At it can be determined whether a first log parameter and a second log parameter are cogenetic. In one embodiment this can comprise determining whether the value range of the first log parameter and the value range of the second log parameter are equivalent or whether the value range of the first log parameter is a sub set of the value range of the second log parameter at .

In one aspect determining whether two parameters are cogenetic. can be based on the following observations 

In this aspect for respective log parameters for two parameters if a size of an overlapped e.g. union value range is larger than a desired threshold and a desired minimal length of the parameter value is larger than a desired number of characters e.g. 3 characters using the text string form of the parameter values in the log messages for analysis the parameters may be cogenetic. At if the parameters are not cogenetic they are not grouped.

In this embodiment at those log messages having cogenetic log parameters are grouped. In one embodiment a set of parameter groups can be obtained in which parameters in respective groups are cogenetic where the parameter group corresponds to a program variable. Further log messages with the same program variable values can be grouped together.

Therefore in one embodiment an invariant can be represented by the vector . For example an invariant can be represented by the vector 0 0 1 1 1 0 . In this example the message type indexes of A to E are 1 to 5 respectively. Further given a group of log sequences L i 1 . . . n that are produced by a series of program executions for example the number of respective type of log messages can be counted in respective log sequences x j 1 . . . m. In this example xis the number of log messages of the jlog message type in the ilog sequence which can yield the following linear equation 01 . . . n

At in the example embodiment an invariant space of the count matrix is identified and one or more invariant candidates in the invariant space can be identified at . Further At of the exemplary embodiment invariants from the invariant candidates are validated using collected historical log data.

In this embodiment for example two sub spaces can be derived according to the matrix X a row space of matrix X which spans row vectors of X and null space of matrix X which is orthogonal complement space to the row space. The above equation yields an invariant which can be a vector in the null space of matrix X. In this embodiment the null space of matrix X can be the invariant space of the executed program for example. In this example respective vectors in the invariant space can represent an execution flow invariant where the vector in the invariant space is the invariant vector.

In one embodiment the invariant space can be estimated from the matrix X by singular value decomposition SVD operation. As an example a dimension of the invariant space can be equal to a number of zero singular values of the matrix X and the invariant space can be a span of corresponding singular vectors. However in this embodiment historical logs may contain some log messages caused by program failures which may influence the singular values which may result in no zero singular value of the matrix X for example. In one embodiment traditional sub space analysis algorithms can be used to determine the row space according to the energy spectrum.

In one embodiment the invariant searching algorithm can find a compact set of program sparse invariants for example based on the set of message counter vectors. Combinations of non zero coefficients can be used in different dimensions to construct a potential sparse invariant for example and it can be validated by determining if it fits with historical log data. For example an invariant may fit with the collected historical log data if it is satisfied by more than log message groups. In one embodiment can be a user defined threshold. Further in this embodiment the hypothesis of invariants can be constructed with k non zero coefficients and the validity of these hypotheses can be sequentially tested.

In one embodiment the mined invariants may reflect elementary execution flows in a program. For example these program invariants often provide intuitive and meaningful information to human operators and can help them to locate problems on fine granularity. Therefore in this embodiment the respective detected anomalies can be related with the invariants e.g. that it breaks to provide insight cues for problem diagnosis for example. In one example operators can check which invariants are broken by an anomaly and how many anomalies are raised by the violation of a specific invariant.

A system may be devised that provides for mining system invariants from console logs such as from a program execution. is a component diagram of an exemplary system for detecting anomalies in a message log. A memory component is used to store data such as log messages and a processor is used to process data. In one embodiment the memory component and processor may be comprised in a computing device together or alternately in separate computing devices operably coupled to perform anomaly detection for example.

A log message parsing component is operably coupled with the memory component and processor for parsing a log message from an unstructured text string to a structured form. For example the log message parsing component can convert a log message from an unstructured text string to a tuple form representation that comprises a timestamp a message signature e.g. a constant free form text string representing a log message type and a list of message parameter values.

A grouping component is also operably coupled with the memory component and processor and groups structured log messages that contain a same value of a same program variable. For example log messages that comprise a same value of a same program variable can be grouped together for the grouping component . Further in this example log messages that contain a same request ID value can be grouped together by the grouping component .

An invariant identification component is operably coupled with the memory component and processor and identifies one or more invariants for respective types of log message groups. For example message groups associated with a same program variable may be considered as the same type of group. In one embodiment the invariant identification component can use a brute force searching algorithm can be combined with a greedy searching algorithm to search for invariants and extract them.

An anomaly detection component is operably coupled with the memory component and processor and it applies invariants to log sequences to detect anomalies. For example an obtained set of invariants can be applied to detect anomalies and a log sequence that violates an invariant can be labeled as an anomaly. In this example by detecting the anomalies in the message logs from an executed program problems in the execution may be identified automatically.

The grouping component comprises a parameter value determination component that enumerates a value range of a log parameter for a log message such as from a log bunch e.g. from a plurality of program executions . Further the grouping component comprises a parameter comparison component compares log value ranges of parameters to determine if the parameters can be grouped based on value ranges such as by grouping log messages that contain the same value of the same program variable together.

The invariant identification component comprises a vector extraction component which extracts a set of message count vectors for respective log message groups that are related to a same target program variable where the count vectors form a count matrix. An invariant space determination component then identifies an invariant space of the count matrix. Further an invariant candidate identification component can identify one or more invariant candidates in the invariant space using combinations of non zero coefficients in different dimensions to construct the invariant candidate. Additionally an invariant validation component can validate invariants from the invariant candidates using collected historical log data. In this way for example the validated invariants can be applied to detect anomalies using the anomaly detection component .

Still another embodiment involves a computer readable medium comprising processor executable instructions configured to implement one or more of the techniques presented herein. An exemplary computer readable medium that may be devised in these ways is illustrated in wherein the implementation comprises a computer readable medium e.g. a CD R DVD R or a platter of a hard disk drive on which is encoded computer readable data . This computer readable data in turn comprises a set of computer instructions configured to operate according to one or more of the principles set forth herein. In one such embodiment the processor executable instructions may be configured to perform a method such as the exemplary method of for example. In another such embodiment the processor executable instructions may be configured to implement a system such as the exemplary system of for example. Many such computer readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 1394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Various operations of embodiments are provided herein. In one embodiment one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media which if executed by a computing device will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein.

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

