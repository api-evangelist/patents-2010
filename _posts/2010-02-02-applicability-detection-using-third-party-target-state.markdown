---

title: Applicability detection using third party target state
abstract: Aspects of the subject matter described herein relate to detecting needed updates. In aspects, an update agent receives a request to scan for updates for a target. The target may include a virtual or non-virtual device. The request may include one or more rules that indicate resources to check to determine attributes of the device. The update agent utilizes a resource accessor to access the resources indicated by the rules. The resource accessor maps resource names indicated by the update agent to corresponding resource names of the target. The update agent may provide results of evaluating the rules to an update source in a multi-pass protocol designed to eliminate irrelevant updates.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08316120&OS=08316120&RS=08316120
owner: Microsoft Corporation
number: 08316120
owner_city: Redmond
owner_country: US
publication_date: 20100202
---
As processing capability moves towards a model where functionality is managed through instances of virtual machines customers are managing their infrastructure through libraries of virtual machine images. In this model virtual machines are run when needed and suspended when not needed. Capacity is added by duplicating virtual machine images onto additional hardware.

As part of managing this library of images administrators need to ensure that the software inside the images is current with the latest software updates such as security fixes additional functionality and so forth . Traditionally this has been done by running a virtual machine and then executing an update agent in the virtual machine. While this allows virtual machines to be updated this mechanism is a significant maintenance activity that consumes compute resources and that may be time consuming and tedious for the administrators who manage the virtual machines.

The subject matter claimed herein is not limited to embodiments that solve any disadvantages or that operate only in environments such as those described above. Rather this background is only provided to illustrate one exemplary technology area where some embodiments described herein may be practiced.

Briefly aspects of the subject matter described herein relate to detecting needed updates. In aspects an update agent receives a request to scan for updates for a target. The target may include a virtual or non virtual device. The request may include one or more rules that indicate resources to check to determine attributes of the device. The update agent utilizes a resource accessor to access the resources indicated by the rules. The resource accessor maps resource names indicated by the update agent to corresponding resource names of the target. The update agent may provide results of evaluating the rules to an update source in a multi pass protocol designed to eliminate irrelevant updates.

This Summary is provided to briefly identify some aspects of the subject matter that is further described below in the Detailed Description. This Summary is not intended to identify key or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The phrase subject matter described herein refers to subject matter described in the Detailed Description unless the context clearly indicates otherwise. The term aspects is to be read as at least one aspect. Identifying aspects of the subject matter described in the Detailed Description is not intended to identify key or essential features of the claimed subject matter.

The aspects described above and other aspects of the subject matter described herein are illustrated by way of example and not limited in the accompanying figures in which like reference numerals indicate similar elements and in which 

As used herein the term includes and its variants are to be read as open ended terms that mean includes but is not limited to. The term or is to be read as and or unless the context clearly dictates otherwise. The term based on is to be read as based at least in part on. The terms one embodiment and an embodiment are to be read as at least one embodiment. The term another embodiment is to be read as at least one other embodiment. Other definitions explicit and implicit may be included below.

Aspects of the subject matter described herein are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments or configurations that may be suitable for use with aspects of the subject matter described herein comprise personal computers server computers hand held or laptop devices multiprocessor systems microcontroller based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers personal digital assistants PDAs gaming devices printers appliances including set top media center or other appliances automobile embedded or attached computing devices other mobile devices distributed computing environments that include any of the above systems or devices and the like.

Aspects of the subject matter described herein may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures and so forth which perform particular tasks or implement particular abstract data types. Aspects of the subject matter described herein may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing aspects of the subject matter described herein includes a general purpose computing device in the form of a computer . A computer may include any electronic device that is capable of executing an instruction. Components of the computer may include a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus Peripheral Component Interconnect PCI bus also known as Mezzanine bus Peripheral Component Interconnect Extended PCI X bus Advanced Graphics Port AGP and PCI express PCIe .

The computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media and removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media.

Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile discs DVDs or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the computer .

Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disc drive that reads from or writes to a removable nonvolatile optical disc such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include magnetic tape cassettes flash memory cards digital versatile discs other optical discs digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disc drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in FIG. provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers herein to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner a touch sensitive screen a writing tablet or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer may include a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

As mentioned previously with the shift to virtual machines updating software on the virtual machines can become a significant maintenance activity. A virtual environment is an environment that is simulated or emulated by a computer. The virtual environment may simulate or emulate a physical machine. This machine that is simulated or emulated is sometimes called a virtual machine. A virtual machine is a machine that to software executing on the virtual machine appears to be a physical machine. The software may save files in a virtual storage device such as virtual hard drive virtual floppy disk and the like may read files from a virtual CD may communicate via a virtual network adapter and so forth.

More than one virtual machine may be hosted on a single computer. That is two or more virtual machines may execute on a single physical computer. To software executing in each virtual machine the virtual machine appears to have its own hardware even though the virtual machines hosted on a single computer may physically share one or more physical devices with each other and with the hosting operating system.

Aspects of the subject matter described herein may also be applied to application virtualization. In application virtualization one or more resources such as a registry file system libraries and the like of an operating system are virtualized and presented to an application. This may be done for example via a virtualization layer that intercepts requests for the resources. When accessing virtualized resources the application believes that it is accessing normal resources of the operating system. Wherever the term virtual machine is used herein it is to be understood that in other embodiments the teachings herein may also be applied to application virtualization.

Although virtual machines are sometimes referred to herein aspects of the subject matter described herein may be applied to other devices. For example aspects of the subject matter described herein may be applied to non virtual devices such as printers routers refrigerators hand held or laptop devices multiprocessor systems microcontroller based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers personal digital assistants PDAs gaming devices printers appliances including set top media center or other appliances automobile embedded or attached computing devices other mobile devices distributed computing environments that include any of the above systems or devices and the like.

The entities illustrated in are exemplary and are not meant to be all inclusive of entities that may be needed or included. In other embodiments two or more of the entities and or functions described in conjunction with may be combined included in other entities not shown or divided into sub entities without departing from the spirit or scope of aspects of the subject matter described herein.

The entities may comprise components of a computer system. As used herein the term component is to be read to include all or a portion of a device a collection of one or more software modules or portions thereof some combination of one or more software modules or portions thereof and one or more devices or portions thereof and the like.

The entities may be located relatively close to each other or may be distributed across a wide area. In one embodiment groups of two or more of the entities may be hosted on the same physical or virtual machine. In other embodiments each of the entities may be hosted on a different physical or virtual machine.

Entities that are hosted on different machines may be able to communicate with each other via various networks including one or more local area networks one or more telephone networks one or more wide area networks direct connections virtual connections private networks virtual private networks some combination of the above and the like.

Entities that are hosted on the same machine may be able to communicate with each other via inter process intra process or other communication channels.

The update requestor may comprise a component that requests via the API that one or more of the targets be scanned for applicable updates. For example the update requestor may comprise a software module that receives and responds to input from a system administrator or the like. Upon instruction by the administrator the update requestor may request that a target be scanned for applicable updates.

As another example the update requestor may be associated with or part of a virtual machine library manager. Periodically upon receipt of notification of new updates or at other times the virtual machine library manager may instruct the update requestor to request that one or more virtual machines in the library be scanned.

The API provides a programming interface by which instructions may be sent to and responses may be provided by the update agent . The API may provide an interface that can be called by processes on remote devices.

The update agent may comprise a component that is in charge of detecting applicable updates for one or more targets. The update agent may do so by evaluating one or more rules against resources of the one or more targets. A rule may be associated with or embodied in one or more expressions. The one or more expressions may be evaluated to determine attributes of the target. These attributes may include information about software hardware configuration data application data state and the like of the device.

For example an attribute may include a version of a software application installed on the target. As another example an attribute may include a value in a registry or other database. As another example an attribute may be a language used on the target. As yet another example an attribute may be data in a database. As yet another example an attribute may include data about a hardware component installed on a device. Some other examples include a screen size and resolution of the target hard disk size total RAM cache processor type and speed.

The examples above are not intended to be all inclusive or exhaustive. Indeed in one embodiment an attribute of a device may include any data about the device that can be determined by a executing a fully privileged process on the target.

The rules may be conveyed with an update that includes code. The rules may indicate whether the update is applicable to a target. The code may include data that if applied modifies the state of the target. The term data is to be read broadly to include anything that may be represented by one or more computer storage elements. Logically data may be represented as a series of 1 s and 0 s in volatile or non volatile memory. In computers that have a non binary storage medium data may be represented according to the capabilities of the storage medium. Data may be organized into different types of data structures including simple data types such as numbers letters and the like hierarchical linked or other related data types data structures that include multiple other data structures or simple data types and the like. Some examples of data include program code program state program data other data and the like.

An update may include new software updates to existing software modifications to system settings or policy database updates interactive notifications to a user of the target and the like.

Some updates may not include code but may include only rules that may be used to detect the state of the target. Such updates are sometimes referred to herein as detectoids. A detectoid may be used to determine attributes of a particular target. For example the existence of certain registry keys folders files directories environment variables and or other data on a target may indicate that word processing software of a particular version is installed on the target. For example an expression may be evaluated that determines whether the file resource named c program files foo.exe exists and is greater than version 1.0.

An update may have one or more dependencies. For example whether to apply an update may depend on attributes of the target system such as whether other software and or updates have already been successfully applied on the target. For example an update that includes a version 3 of a software package may need to be applied after an update that includes version 2 of the software.

In evaluating a detectoid or an expression of another update the update agent may generate data that may then be passed back to the update source . The data may allow the update source to apply an efficient scan protocol described in more detail below by filtering out updates that do not apply because their dependencies are not satisfied. For example if a word processor is not installed there is no need for the update source to even send an update of the word processor to the client for evaluation.

The update source may comprise a component that based on data received from the update agent determines what updates may need to be installed on the target. In one embodiment the update source may comprise a service. A service may include one or more processes threads components libraries and the like that perform a designated task. A service may be implemented in hardware software or a combination of hardware and software. A service may be distributed over multiple devices or may be implemented on a single device.

In another embodiment the update source may comprise a file data structure or the like that includes update information for the update agent . For example the update source may comprise executable code that provides update information to the update agent . As another example the update source may comprise a CAB file MSI file or some other file.

The update source may execute a multi pass protocol to efficiently provide updates. In the multi pass protocol the update source may first send the update agent a set of updates including detectoids that have no dependencies. The update agent may evaluate the rules of these updates and inform the update source as to attributes of the target.

In evaluating the rules of a detectoid the state of one or more resources may be compared to one or more values. For example a rule may compare a particular registry key to the value of 5. The result of evaluating a rule may be provided by the update agent to the update source . Based on the result and possibly other results the update source may determine whether to send additional detectoids or updates to the update agent .

In a next iteration of the protocol the update source may send updates which depend on the software and or updates which were detected as installed in the previous iteration. The update agent may then evaluate the rules of these additional updates and send the results to the update source .

This process may continue until no more updates are available that depend on attributes of the target device. In one sense this process may be viewed as trimming away irrelevant branches of a tree or graph in each iteration based on results provided to the update source . The update source may start the process by sending updates including detectoids that do not depend on other updates and may send other updates depending on the results of the previous updates. This multi pass protocol may be used to efficiently prune out updates that do not apply to the target and thus reduce the cost of detecting the updates needed for a target.

The update agent may store data that indicates what is installed on a particular target. This data may be stored in a document that travels with the target. In one embodiment the document may be stored in a memory device e.g. a virtual disk image of the target. In another embodiment the document may be stored on a store e.g. the store outside of the target together with an identifier that associates the document with the target. In subsequent scans of the target this stored data may be used as a starting point for determining what updates are needed for the target.

The store may include any storage media capable of providing access to data including results regarding previous scans of targets. The store may include volatile memory e.g. a cache and non volatile memory e.g. a persistent storage . The store may comprise hard disk storage other non volatile storage volatile memory such as RAM other storage some combination of the above and the like and may be distributed across multiple devices. The store may be external internal or include components that are both internal and external to an apparatus hosting the update agent .

In one embodiment rules and other data provided by the update source to the update agent may be encoded in Extensible Markup Language XML . In other embodiments however the expressions may be encoded in other languages data structures or the like.

In one example the interaction between the update agent and the update source may include the following exemplary actions 

1. The update agent connects to the update source and requests that the update source provide all updates that have no dependencies.

2. In response the update source sends such updates to the update agent . Such updates may include many detectoids to detect the operating system application files and other state of the target.

3. The update agent evaluates the rules of the updates which may include evaluating one or more expressions. In evaluating the expressions the update agent may compute a set of results e.g. Boolean values that indicate updates and detectoids already installed on the target based on the evaluation of expressions against software and or hardware installed on the target or other target machine state.

5. The update source determines the updates that depend on what is already installed on the target. For example if a word processor of a certain version is installed on the machine the update source may determine whether there are any updates that depend on the version of the word processor. As another example if it is determined that the language of the target is German the update source may eliminate updates that pertain to other languages.

7. Steps 3 6 above are repeated until there are no new updates that depend on what is already installed on the target.

When the target is a virtual machine detecting the software installed in the virtual machine may be performed without running the virtual machine. A virtual machine may be stored as an image on a disk. This image may be accessed via the virtual machine or via another entity such as a resource accessor. When a target is an offline virtual machine the names of resources associated with the target may be different than when the resources are accessed by the virtual machine when executing. For example when accessed by the virtual machine names of resources on a disk of the virtual machine may start with a C . When the same disk is accessed outside of the virtual machine for example names of resources on the disk may start with a D .

The rules included in an update however may be created in anticipation of using with the original resource names. If the rules are evaluated directly against the resource names of an offline image the appropriate resources may not be found or accessed.

This same problem may occur when using other data that may evaluate into a resource name. For example system variables component identifiers folders including shell folders and other folders registry entries and other data that may be used in locating resources may be different when accessing the resources while the virtual machine is offline.

Resource accessors may be used to access the appropriate resources on the targets . Each resource accessor may include a mapping table or other data structure that associates resource names or portions thereof with mapped to resource names or portions thereof. For example the mapping table may include an entry that associates C with D . When a resource accessor receives a request to access a resource with a name that starts with C the resource accessor may use the mapping table to substitute a D at the start of the resource name to access the resource on the offline virtual machine.

Likewise some resource names may be prefixed by variables e.g. program files system and so forth . The mapping table may include entries for these variables that map the variables to prefixes on the target that correspond to the resource names.

There may be multiple levels of mapping that occur to access a resource. For example an expression may indicate that a resource name is found in a certain key of a registry. One mapping may be used to find the registry e.g. a mapping that replaces C with D . After the registry has been located and the value associated with the key obtained another mapping may be used to map the resource indicated by the value to a location it may be found on the loaded image. For example the registry value may refer to a resource on C . To correctly access this resource on the loaded image a mapping may be used to map from C to D .

Although only two levels of mapping have been described in the example of the paragraph above there is no intention to limit aspects of the subject matter to only two levels of mapping. Indeed in other embodiments there may be greater than two levels of mapping to access a resource. To determine a mapping in these cases may involve multiple operations. For example an environment variable may include a resource name that refers to a database entry. The database entry may include another resource name that refers to a file location. The file may include another resource name that refers to the desired resource. In this example to find the desired resource may involve multiple mapping operations.

Each resource accessor may have a mapping table appropriate for its associated target i.e. the targets respectively . This may allow the update agent to be used with many different types of targets and different instances of the same type from offline virtual machines of different versions and or from different vendors online virtual machines online or offline operating systems loaded on different partitions other devices mentioned previously and the like.

The update agent may not need to be aware of the target type or its capabilities. Instead the update agent may send rules to access certain resources to the expression evaluator which may access resources via the resource accessors . The resource accessors may then make the appropriate translations based on individualized mapping tables to access the appropriate resources.

It will be understood by those skilled in the art that the update mechanism described in conjunction with provides flexibility and extensibility. For example when a system administrator or the like desires to add a new target of a different type a mapping table may be created and provided to a resource accessor to allow access to the new target.

A mapping table may be created or populated automatically semi automatically or manually. For example in an automatic or semi automatic population when the update agent is instructed to update an offline virtual machine the update agent may mount e.g. as D an image of a disk associated with the virtual machine. The update agent may also access metadata associated with the virtual machine to determine a resource name e.g. C that the virtual machine associates with the disk. The update agent may then create a mapping entry from the name used by the virtual machine e.g. C to the name given to the mount e.g. D .

As another example environment variables or other resource location information e.g. paths or portions thereof may be defined in a registry of a virtual machine. For environment variables that are associated with resources one or more mapping entries may be automatically created that map the environment variables or other resource location information to the appropriate resource names for the mounted disk.

Certain mappings may be created manually. For example a temp directory of a brand of mobile devices may be hardcoded to a particular location. In this case a mapping entry for the temp directory may be hardcoded into the mapping table.

Although the system described above in conjunction with includes various entities and related communication paths it will be recognized that more fewer or a different combination of these entities and others may be employed without departing from the spirit or scope of aspects of the subject matter described herein. Furthermore the entities and communication paths included in the system may be configured in a variety of ways as will be understood by those skilled in the art without departing from the spirit or scope of aspects of the subject matter described herein.

At block a request to scan a target is received. The request is received at an entity other than the target. For example referring to the update agent receives a request from the update requestor via the API . In conjunction with receiving a request to scan a target the update agent may based on the target select a mapping data structure from a plurality of mapping data structures where each mapping data structure is applicable to a pre defined type of target or instance of a type of target.

A mapping data structure may include one or more mappings from resources indicated by updates to resources of the target. Furthermore a mapping data structure may indicate an algorithm by which a resource of the target is to be obtained. For example a mapping data structure may specify an algorithm that obtains the resource from a local or remote target using one or more operations that may involve one or more APIs. A mapping data structure is not limited to pairs of values in a table and may be encoded in code that includes for example if then else statements switch statements other statements or the like to obtain data of a resource from a corresponding resource of the target.

Furthermore the method of accessing the corresponding resource on the target may be different from accessing a similarly named resource from another source. For example in a Windows environment for an online machine a process may access a resource by calling a Win32 API e.g. querying the WMI store or calling GetSystemMetrics . For an offline image accessing that same resource might not be done via a call to the same API rather an accessor might have to directly access the underlying storage e.g. the registry of the offline image .

In addition in conjunction with receiving the request the update agent may receive an indication of a mapping from a resource name indicated by the rule to a corresponding resource name of the target. For example the update requestor may indicate that an image corresponding to a virtual machine has been loaded onto a network share of server share VMImage. This information may be used to create a mapping in the mapping data structure.

At block rules of an update are requested from an update source. The rules may be conveyed with updates as mentioned previously. The rules indicate resources to check to determine attributes of the target. For example referring to the update agent may request updates from the update source . Furthermore in requesting rules the update agent may obtain results of a previous scan from the target or the store and may pass these results to the update source in conjunction with requesting rules from the update source.

At block one of the rules is selected. One or more rules may be returned by the update source . For example referring to the update agent may determine or be informed as to an order in which to evaluate the rules and may select the first rule of the order.

At block resource names of the rule are identified. For example referring to the update agent may identify resource names indicated by the rule. As mentioned previously a rule may identify resources and values to which to compare the resources. A rule may be specified in XML or some other data structure that indicates resources comparison operators and values.

At block identified resource names are mapped to target resource names. This may involve determining one or more corresponding resource names of the target using a mapping data structure. For example referring to the resource accessor may map a resource name e.g. C Path File provided by the update agent to a resource name of the target e.g. D Path File .

At block at least some of the data from the mapped resources of the target is obtained. When a resource value includes a resource name obtaining the data may involve multiple mapping operations as described previously. For example referring to the resource accessor may obtain a value from an image of a virtual machine corresponding to the target .

At block one or more expressions of the rule are evaluated to compare the data to one or more criteria indicated by the rule. Evaluating the one or more expressions produces a result indicative of at least one of the software and or hardware installed on the target. For example referring to the expression evaluator may evaluate an expression of the rule to determine a result indicative of software and or hardware installed on the target .

At block a determination is made as to whether there is another rule in the update. If so the actions continue at block otherwise the actions continue at block .

At block the results are provided to the update source. For example referring to the update agent may provide results of evaluating rules to the update source .

At block a determination is made as to whether this is another update for the scan. If so the actions continue at block otherwise the actions continue at block .

At block other actions if any may be performed. Other actions may include for example storing the results produced by evaluating the expressions receiving another request to scan the target retrieving the results providing the results to the update source and receiving from the update source additional rules that depends at least in part on the results.

At block an indication may be received of an association that associates a resource name or portion thereof with another resource name or portion thereof. For example referring to the resource accessor may receive an indication that requests to C map to D VMs VM1 .

At block if an association is received it is stored in a mapping data structure. For example referring to the resource accessor may store the association in a mapping table associated with the target .

At block a request for at least some data of a resource of a target is received. The request may include a first resource name. For example referring to the update agent may request some data from a file and may indicate a resource name of C pathname file of the file.

At block the resource name is mapped to a target resource name. For example referring to the resource accessor may map the resource name of C pathname file to a target resource name of D VMs VM1 pathname file using a mapping table. This target resource name identifies the resource e.g. D VMs VM1 pathname file of the target that corresponds to the resource name e.g. C pathname file provided to the resource accessor .

At block the requested data is obtained from the target using the target resource name. For example referring to the resource accessor may use the resource name D VMs VM1 pathname file to obtain at least some data from a registry file associated with the target .

At block the data is provided to the requestor. For example referring to the resource accessor provides the requested data to the update agent .

At block other actions if any may be performed. For example referring to if the data in the resource refers to another resource more mapping may be performed to obtain the correct resource from the target .

As can be seen from the foregoing detailed description aspects have been described related to detecting needed updates. While aspects of the subject matter described herein are susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit aspects of the claimed subject matter to the specific forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of various aspects of the subject matter described herein.

