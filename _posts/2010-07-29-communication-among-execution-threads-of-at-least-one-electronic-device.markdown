---

title: Communication among execution threads of at least one electronic device
abstract: A method of communication in at least one electronic device is presented. In the method, a first execution thread and a second execution thread are created in the at least one electronic device. Also created is a message service for receiving messages for the first thread. A message to be transferred from the second thread to the message service of the first thread is generated. One of multiple data transfer mechanisms is selected for transferring the message from the second thread to the message service of the first thread based on a relationship between the first and second threads. This relationship may be one in which the first and second threads are executing within a single process, within different processes of the same device, or within different devices. The message is transferred to the message service of the first thread using the selected data transfer mechanism and processed in the first thread.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09027034&OS=09027034&RS=09027034
owner: Echostar Technologies, L.L.C.
number: 09027034
owner_city: Englewood
owner_country: US
publication_date: 20100729
---
This application claims the benefit of U.S. Provisional Application No. 61 229 595 entitled Communication among Execution Threads of at Least One Electronic Device filed Jul. 29 2009 which is hereby incorporated by reference herein in its entirety.

Firmware and software for both general purpose and embedded computing systems continue to become more efficient over time. Even with the increased availability of faster microprocessor technology and higher capacity memory components that software and firmware developers have enjoyed from year to year the developers continue to devise data structures processes and other computer programming innovations to yield a code set that employs the existing hardware resources in a highly efficient manner while providing the functionality desired of the system. Such a software or firmware development strategy is especially beneficial in embedded computing systems such as mobile communication devices data storage systems audio video entertainment components and many others in which several tasks must be performed often in real time and typically using hardware of some restricted capability or performance compared to many general computing systems such as personal computers.

To efficiently employ the computing system developers typically structure the associated firmware and software in an attempt to exploit the maximum amount of parallelism available in the device to keep the processor busy performing significant work. To this end the developer may configure the software to concurrently execute multiple processes each with its own state information to handle separate aspects of the system at the same time. Further each process may employ one or more execution threads which share the state of the associated process while further exploiting parallelism available in the system.

To aid the development of such software or firmware developers often employ an operating system such as a real time operating system to automate the creation of the processes and threads to facilitate communication therebetween and perform other required operations. Developers may write their own operating system or contract such a task to a third party thus being able to tailor the operating system for the target device but also bearing the responsibility of debugging and maintaining the operating system as well as adding significant cost to the development effort. On the other hand the developers may purchase a more general purpose off the shelf operating system that has been well tested over a period of time but provides functionality that is not specifically targeted to the task at hand.

The enclosed drawings and the following description depict specific embodiments of the invention to teach those skilled in the art how to make and use the best mode of the invention. For the purpose of teaching inventive principles some conventional aspects have been simplified or omitted. Those skilled in the art will appreciate variations of these embodiments that fall within the scope of the invention. Those skilled in the art will also appreciate that the features described below can be combined in various ways to form multiple embodiments of the invention. As a result the invention is not limited to the specific embodiments described below but only by the claims and their equivalents.

More specifically illustrates a first thread A with a message service A receiving a message A from a second thread A wherein both threads A A execute within a single process A executing within an electronic device A. Generally unlike a thread a process is a programming construct that contains its own separate state information including its own address space. Also a process such as the process A may include one or more executing threads such as the threads A A of . In contrast presents a first thread B with an associated message service B receiving a message B from a second thread B with the first thread B executing in a first process B while the second thread B executes within a second separate process B of the same electronic device B. Thus the logical coupling between the first thread B and the second thread B is attenuated compared to that associated with the threads A A of . This pattern continues in in which a message C is sent to a message service C of a first thread C of a first process C from a second thread C of a second process C wherein the processes C C operate in separate electronic devices C C. As a result the processes C C are executed on distinct hardware. In this case the message C is transmitted from the second electronic device C to the first electronic device C by some communication channel or link therebetween.

One of multiple data transfer mechanisms is then selected for transferring the message to the message service of the first thread based on a relationship between the first thread and the second thread operation . Such selection is not made under the control of either the first thread or the second thread . Possible types of relationships between the threads include those displayed in such as the two threads executing within a single process the two threads executing within different processes of the same electronic device and the two threads executing within different electronic devices . Other examples of different relationships or couplings between the threads may form the basis of determining which of several data transfer mechanisms may be employed to transfer the message in other embodiments. As will be described more fully below such mechanisms may include shared memory file transfers pipes network sockets and others.

After the data transfer mechanism is selected operation the message is transferred to the message service of the first thread by way of the selected data transfer mechanism operation . The first thread then processes the message in response to the message being transferred to the message service of the first thread operation .

While the operations of are depicted as being executed in a particular order other orders of execution including concurrent execution of two or more operations may be possible. In another embodiment a computer readable storage medium may have encoded thereon instructions for at least one processor or other control circuitry of one or both of the electronic devices of to implement the method .

As a result of at least some embodiments of the method the various execution threads executing in the firmware or software of one or more electronic devices may communicate by way of a standardized messaging interface without regard to how closely the threads are coupled or related. In other words from the viewpoint of the thread firmware or software messages are transferred to another thread in the same manner regardless of the location of the receiving thread such as whether the threads are in the same or another process of a single electronic device or are residing in separate devices. Instead firmware or software not residing in the threads sending or receiving the messages determines the appropriate data transfer mechanism for transferring the message based on the coupling or relationship of the threads involved. Other advantages may be recognized from the various implementations of the invention discussed in greater detail below.

As shown in the electronic device includes at least one processor and data storage . In some implementations the device may also include a communication interface for communicating with other devices . Other components including but not limited to a user interface signal transmitters and receivers and a power supply may also be included in the electronic device but such components are not explicitly shown in nor discussed below to simplify the following discussion.

The processor is configured control various aspects of the electronic device by way executing instructions residing in software or firmware of the device . These particular aspects as they relate to any specific electronic device are not discussed herein. Instead focused upon hereinafter are communications taking place within the electronic device and with other potential devices. The processor may include one or more processors such as microprocessors microcontrollers or digital signal processors DSPs configured to execute instructions residing in the device firmware or software.

Also potentially included in the electronic device is a communication interface for communication with another electronic device. Such an interface may be for example any wired or wireless communication interface including but not limited to an Internet or other wide area network WAN interface an Ethernet or other local area network LAN interface a Bluetooth Wi Fi or other short range wireless interface and a cellular or landline telephone interface.

The data storage of the electronic device is configured to store the software or firmware instructions to be executed by the processor . Examples of the data storage may include any single one of of combination of any digital data storage system or component capable of storing software or firmware instructions as well as any data employed by the software or firmware. Such systems or components may include volatile memory such as static random access memory SRAM and dynamic random access memory DRAM and or nonvolatile memory such as flash memory magnetic hard disk drives and optical disk drives.

As shown in the data storage is configured to store at least three basic portions of the firmware or software an operating system an abstraction layer and application code . Generally the operation system provides a basic software or firmware system which is utilized by other software or firmware to perform more specific functions associated with the electronic device . Typically the operating system may be employed in many types of different devices employing varying types of processors with the aid of firmware describing the specific hardware characteristics of the device . More specifically the operating system may provide access to various hardware aspects of the electronic device such as communication interfaces and other hardware circuits including timers logical or arithmetic processing units encoders decoders and so on possibly by way of basic input output system BIOS firmware residing in the electronic device . Further the operating system may provide utilities for generating manipulating and accessing various data structures provided by the system to facilitate control of the firmware or software operating within the device . Examples of possible operating systems include those operating systems normally identified with general purpose computing systems such as Windows Unix and Linux and those more closely associated with embedded computing systems such as VxWorks and other real time operating systems RTOSes .

The abstraction layer in the data storage generally is configured to provide interfacing software or firmware between the application code and the operating system . More specifically the abstraction layer may provide a more specialized set of utilities functions and various data structures and types useful to the specific tasks to be performed by the application code than what is available directly from the operating system . In one example the abstraction layer may provide an application framework which provides a standardized way of creating and destroying processes and threads communicating among those processes and threads setting and responding to system signals and performing other types of logistical tasks by way of one or more application programming interfaces APIs accessed by the application code . Further such an application framework may be designed according to a particular design pattern or description of the various data structures and associated functions that are useful for addressing a focused set of tasks or problems. Thus the abstraction layer typically provides a well understood simplified programming interface by which developers may generate the application code for particular tasks without becoming mired in or concerned with the details of the operating system . In many cases the abstraction layer may also provide for flow control of the various processes and or threads implemented in the application code by implementing the main loop of the overall firmware or software and by dispatching messages generated and transmitted by the threads of the application code . As a result development of the application code may be faster and less expensive than such code written to interface directly with the operating system . Examples of some functions associated with a particular abstraction layer are discussed in greater detail below.

As executed by the processor the application code employs the abstraction layer to address and handle specific tasks associated with the particular electronic device in which the application code resides. For example in the case of a satellite set top box serving as the electronic device the application code may perform a variety of functions associated with such a device such as processing of commands received from a remote control device storing and displaying an electronic program guide EPG containing information about upcoming audio video programs setting of recording timers for a DVR integrated within the set top box and presentation of a particular channel or program requested by the user for display on a connected television. In the implementations discussed below such tasks are implemented by way of multiple processes and or execution threads employed in the application code executing concurrently.

In the embodiment of of the threads three are designated normal threads while others are denoted worker threads or alternately sub threads . For example a first thread and a second thread may execute within the same process wherein the first thread is a sub thread of the second thread. In this particular implementation each of the normal threads provides a message service as noted above such as a message queue for receiving messages from other threads. The normal threads may also provide callback functions discussed more completely below called by the abstraction layer for each of its message services and for other events which are described below. Oppositely the worker threads do not provide a message service in at least one embodiment.

Additionally each of the normal threads may create one or more worker threads . In the example of only one normal thread creates a worker thread . In that case the creator normal thread may be termed a controller thread while the created worker thread may be called a controlled thread . Each of the normal threads as well as the non controlled worker thread may be created by the process itself.

In the worker thread creation API consists of a function thread worker create which may be called by a normal thread such as the controller thread of or directly by a process to create a worker thread such as the controlled thread of . In the arguments for thread worker create the controller thread or process code may specify or register one or more callback functions which provide the firmware or software to be executed during the lifetime of the created worker thread. For example the callback thread init cb provides a pointer to a function that performs any initialization work for the worker thread including but not limited to the creation of events and timers discussed in greater detail below upon which the worker thread may perform certain duties. To that end the thread worker create function may accept a pointer data to a set of data to be used as one or more input parameters to direct the initialization of the normal thread by the thread init cb callback. The size of the input data indicated by the data pointer is specified by an input parameter data size. The callback thread exit cb supplies a pointer to a function that may perform any clean up work such as deletion of events before the worker thread exits or terminates. The callback thread worker cb supplies the main worker thread execution code or loop that performs the primary tasks associated with that thread. Depending on the example this main code callback may sleep block on an event reawaken upon expiration of a timer or engage in other flow control measures. Either or both of the initialization callback function pointers may be set to null if the created worker thread does not require such a function.

Also provided in the arguments of thread worker create is a pointer to a set of attributes attr which may specify a number of characteristics of the worker thread being created such as a priority level for execution of the thread. Also specified in the attributes may be a start group for the worker thread which may designate a group of threads including the current worker thread that are intended to begin execution together. Other attributes associated with the worker thread being created may also be specified therein.

In response to being called the thread worker create function returns a pointer or handle thread handle for the created worker thread so that the thread may be referenced in further calls to the APIs provided by the abstraction layer . Also the thread worker create function provides a result status result e of the function thus possibly indicating whether the function was successful or whether an error condition or exception resulted during execution.

Similarly also provides an example of the interface for the normal thread creation function thread normal create which may be called directly by the process code. Similar to the initiation of the thread worker create function the calling process may provide a callback for an initialization function thread init cb to the thread normal create function for creating timers and events and for other initialization activities as well as a callback for a termination function thread init cb to be called prior to the created normal thread exiting or terminating. As with the worker threads either or both of these callback function pointers may be set to null. As with the thread worker create function a pointer to a set of attributes attr associated with the normal thread being created may also be provided as input to the thread normal create function.

Also included in the arguments to thread normal create is a pointer to a message handler callback function msg handler cb. The abstraction layer is responsible for calling this function once a message is received at a message service associated with the normal thread being created. More description regarding messages which are the primary means of communication among normal threads is set forth below. In addition the thread normal create function accepts a service identifier svc id identifying the particular message service associated with the normal thread being created as well as service permissions svc permissions specifying which other threads or thread types may be granted access to the message service i.e. which threads are allowed to send messages to the service . These permissions provide a means of security by restricting access to message services to only those threads requiring access as determined by the process creating the thread that receives the messages. As with worker thread creation the thread normal create function provides a thread handle thread handle for subsequent referencing of the created normal thread.

An example of a message employed for communication within the electronic device of is represented in . In this example the message includes a message header and an application payload . Generally the message header may include information employed by the application code and the abstraction layer to route the message to the appropriate message service to identify the type of message being sent to denote the sender of the message and possibly perform other tasks involving the message . In the specific implementation of the message header includes a message identifier a message sub identifier a priority value and a sender identifier . The message identifier and sub identifier may indicate to the receiving thread the type of message being sent and thus may facilitate a simple determination by the receiving thread or the abstraction layer as to which firmware or software within the receiving thread should process the message . The priority value may indicate a priority of the message compared to other messages being received by the receiving thread so that the thread or the abstraction layer may determine which messages are to be processed by the receiving thread first. The sender identifier allows the receiving thread to transfer a return message to the thread that sent the original message if such a message is warranted.

Also possibly included in the message header is the size or length of the application payload . The application payload may include any information intended to be transferred from the sending thread to the receiving thread as necessary for the desired operation of the electronic device .

The service owner accesses the service by way of a service pointer or handle svc. In one example the message handle svc refers to a queue or similar memory structure providing a capacity of one or more messages to be received and processed by the service owner. The service owner may also set one or more service permissions svc permissions to indicate which threads are allowed to send messages to the service owner by way of the registered message service. Thus the service permissions provide a measure of security against unauthorized or rogue threads attempting to send unauthorized messages to the service owner.

In the Service Client API a service client i.e. a thread accessing a message service of another thread to transfer messages uses a service query function to acquire the service handle svc by way of the service identifier svc id associated with the desired message service. In one implementation acquiring the service handle svc may allow the service client exclusive access to the service for a period of time. Once the service client has finished using the service the service client may release the service by way of a call to a service release function.

To employ the message service the service client employs the functions of the Message Sender API. For example to initially create the message the message client calls a msg create function of the abstraction layer . The client may specify several different characteristics for the message such as the message identifier and sub identifier message priority and the size of the application payload by way of a message information msg info input. In return the client receives the message handle msg. The client may then use the message handle msg to obtain the address of the application payload by way of a msg get payload function.

In one example the service client may alter the message identifier and sub identifier of a message msg by way of inputs msg id and msg sub id of a msg set id function.

Once the service client generates and writes the application payload of the message msg the service client may send the message msg by a call to a msg send function denoting the service handle svc that will be receiving the message msg. In the implementation of the msg send function sends the message msg to the service svc without a timeout. As a result the msg send function will not return control to the service client until the message msg is received and processed by the service svc. Other functions such as msg send timeout and msg send timeout ms allow the service client to set a timeout so that the function will return at least within a specified timeout indicated by the time span input in msg send timeout or by a number of milliseconds indicated in the timeout argument of msg send timeout ms to ensure that the service client does not stall in the event the message was not transferred to the service owner successfully.

In one implementation the service client may package multiple messages as a single message package for transmission to the service owner. For example multiple calls to msg create followed by a single call to msg send may be employed to create and send multiple messages at once thus reducing the amount of system overhead consumed. In this example the service owner would still view each message in the package as a separate message thus hiding any packaging of the messages by the service client from the service owner.

Once the service owner has received and processed the message the service client may use a msg destroy function to destroy the message . In one implementation destroying the message entails de allocating the memory employed for the message to allow that memory to be used for another purpose such as another message . In another example destroying the message may further involve clearing or resetting the memory contents of the message to prevent another process unintended or unauthorized access to the contents.

The service owner employs the Message Receiver API to access and process the message received at the message service of the owner. The service owner may be notified of the arrival of the message at the service by way of the callback function msg handler cb indicated during the creation of the owner thread in the thread normal create function discussed above in conjunction with . Within or as a result of the msg handler cb function the service owner may receive the message handle msg which the service owner may then use to access the message application payload by way of a call to a msg get payload function. To aid in processing the message the service owner may retrieve the size of the application payload by way of a msg get payload size function and use a msg get info function to retrieve the associated information that was previously set by the sending thread such as the message identifier message sub identifier and message priority of the message .

In some circumstances the service owner after processing the received message may generate and transfer a return message to the service client sending the original message . To that end the service owner may obtain a handle reply addr of the message service of the sender of the message by supplying the original message handle msg in a call to a msg get reply svc function. If the original message sender has not created such a service the msg get reply svc function may return a null value for the reply addr.

The message related APIs of supplied by the abstraction layer represent a standardized interface by which execution threads of the electronic device may transmit and receive messages therebetween regardless of the relationship or relative location of the threads. However the actual data transfer mechanism by which the messages are transferred from the service client to the service owner are likely to depend on the relationship or relative location of the message client and owner threads. B and C provide examples of differing inter thread relationships and the resulting mechanisms by which a message may be transmitted from one thread to another.

In two threads A A spawned by a single process A within an electronic device A may send and receive a message A by way of a shared memory area A. In one example the shared memory A exists as the result of the two threads A A sharing the same address space as a result of residing within the same process A. Thus the sending thread A may generate and store the message A within the shared memory A and the receiving thread A may receive and process the message A all without relocating the message A within the shared memory A or transferring the message A to another memory area.

In contrast depicts a sending thread B of one process B transmitting a message B to a receiving thread B located in a separate process B of the same device B. As the threads B B do not reside in the same process use of a shared memory data structure for transmitting the commands may be problematic due to the processes B B employing separate address spaces. Therefore the device B may utilize a different data transfer mechanism such as an inter process data transfer mechanism from that shown in . In the specific example of an inter process pipe B provides the data transfer mechanism by which the message B is transmitted from the sending thread B to the receiving thread B. In one example the pipe B provides a simplex or half duplex communication connection between the threads B B in a first in first out FIFO manner. In other examples other inter process communication mechanisms may be employed to similar end.

However in each of the cases outlined in the message related APIs provided by the abstraction layer software or firmware of the electronic devices remain constant thus providing a developer of the application code a simplified consistent interface for generating transmitting receiving and processing messages . The abstraction layer determines or selects which data transfer mechanism at its disposal should be used depending on the relative location or relationship of the threads involved thus simplifying the interface presented to the developers of the application code .

In some implementations other forms of inter thread communication maybe employed in addition the message services described above. For example semaphores may be employed as a simple flag indicator that does not warrant the overhead that might be associated with the messaging scheme disclosed herein. Similarly a shared memory construct may be used to facilitate lengthy communications between threads of the same process. In one embodiment each of the additional communication constructs may be associated with a unique identifier such as the UUID mentioned above to uniquely identify that construct. Other types of communication that may be implemented between two execution threads may be instituted alongside the above described messaging scheme in other examples.

The electronic device of may also incorporate an event notification system allowing one thread to alert the same thread or another of an event that has occurred within the device . In one example an event may be any occurrence of interest to the application code of the device including but not limited to a simple flag indicating some new status within the device a system signal indicating an important change in the device a user input the reception of a communication by way of a communication network socket and a request to access a data file in the device . In the example of the abstraction layer may provide an Events API to allow executing threads to set process and clear such events.

More specifically an execution thread may create an event by way of a call to an event create function of the Events API. As shown in the event create function returns an event handle event. Further the event create function creates the event in light of a set of attributes attr provided by the thread creating the event. The attributes may include for example a priority level and a callback function to be associated with the event. In one example a normal thread such as the thread of must be associated with a registered callback function by the time the event is created so that the abstraction layer may call that function upon the occurrence of the event.

Further regarding the owner thread of the event may set the event by way of passing the correct event handle event to an event set function call. Similarly the owner thread may clear such an event by way of initiating an event clear function. Correspondingly a controller thread as shown in may set an event created by an associated controlled thread by supplying the handle thread for the controlled thread and the event handle event to an event set thread event function. Also the controller thread may clear the same event using an event clear thread event function call.

The Events API of further presents a set of functions for checking event status. For example a thread associated with a particular event event may check if that event is set by way of an event check function call which returns a Boolean value is set. The status of multiple events on the current thread may be obtained simultaneously by a call to an event check events function. Any one of the multiple events may then be checked by passing the obtained events from event check events as a parameter to an event is set function.

An event owner may wait for a particular event to occur under various circumstances. For example a thread may block waiting for a particular event to occur by way of passing the event handle event to an event wait event function. In one example only a worker thread may block while waiting for an event. To wait for a particular event for a maximum length of time the thread awaiting the event may call the event timedwait event ms function with a length of time timeout ms as an input. To await any event without a timeout a thread may pass the events obtained via the event check events function to the event wait events function. Again in one implementation only a worker thread may block while awaiting events. To await any event while imposing a timeout the thread awaiting the events may utilize the event timedwait events ms function.

Once the owner thread of an event considers further use of the event as unnecessary the owner thread may delete the event by calling an event delete function.

Another useful tool of the abstraction layer may be an API for the use of timers employable in conjunction with either messages or events or both. As a result timers associated with the sending of messages may be referred to as message timers while those not associated with a message may be termed event timers . For example a timer may be used to initiate the transferring of a message to the message service of a thread wherein the transferring occurs in response to expiration of a message timer. In one implementation only normal threads and not worker threads may create timers.

To start a timer the thread that created the timer may pass the timer handle timer to a timer start function the timer may be stopped similarly by calling a timer stop function. The thread may also check if a timer is running by passing the timer handle timer to a timer is running function which returns a Boolean value is running indicating the status of the timer. Finally the owner thread may delete the timer by passing the timer handle timer to a timer delete function.

At least some embodiments as described herein provide a firmware or software architecture for an electronic device wherein the architecture presents a standardized interface to application code for the generation transmission and reception of messages passed between execution threads regardless of the relationship between or relative location of the threads. An abstraction layer selects between multiple data transfer mechanisms for transmitting the messages depending on the inter thread relationship. Further the abstraction layer may provide a unified event model to the application code so that any type of event to which the electronic device is to respond such as an indicator flag system signal network socket action file access action user input or the like may be indicated to a thread of interest by way of a single standardized interface. The abstraction layer may also provide one or more timers for delayed transmission of messages setting of events and the like.

While several embodiments of the invention have been discussed herein other implementations encompassed by the scope of the invention are possible. For example while some embodiments disclosed herein have been described within the context of a television set top box other message and event driven embedded or general purpose computing systems including but not limited to televisions audio receivers gaming consoles DVRs and CD and DVD players may benefit from application of the concepts explicated above. In addition aspects of one embodiment disclosed herein may be combined with those of alternative embodiments to create further implementations of the present invention. Thus while the present invention has been described in the context of specific embodiments such descriptions are provided for illustration and not limitation. Accordingly the proper scope of the present invention is delimited only by the following claims and their equivalents.

