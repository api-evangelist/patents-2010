---

title: Systems and methods for testing a component by using encapsulation
abstract: Systems and methods for testing a component by using encapsulation are described. The systems and methods facilitate communication between two components that use two different languages in a test environment. Such communication is allowed by encapsulating an identifier of a function to create a call message, encapsulating an identifier of an event to create an event message, or encapsulating an identifier of the function to create a return message.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08397188&OS=08397188&RS=08397188
owner: Altera Corporation
number: 08397188
owner_city: San Jose
owner_country: US
publication_date: 20100921
---
The present disclosure relates to systems and methods for testing a component by using encapsulation.

In electronic design automation EDA functional verification is the task of verifying that a logic design conforms to its specification. Logic simulation is the process of simulating a logic design before the logic design manufactured as integrated circuits ICs . In software simulation a description of the logic design is simulated on computers or workstations. Logic designs may be described using various languages such as hardware description languages HDLs or other more abstract languages e.g. synthesizable SystemC . In software simulation engineers write a test bench program to functionally verify the logic design by providing meaningful scenarios to check that given certain input stimuli the design performs to specification. A test bench may be written using various languages including lower level languages such as very high speed integrated circuit HDL VHDL Verilog and the like as well as more abstract languages such as C C SystemC SystemVerilog and the like. Higher level languages such as SystemC allow engineers to write more abstract test bench models for simulation such as transaction level models TLMs as opposed to lower level register transfer level RTL models.

The test bench includes various components that may be tested. However in certain cases it may be difficult for the components to communicate with each other.

Systems and methods for testing a component by using encapsulation are described. In various embodiments the methods include connecting a test module component and a functional module component via a plurality of pins. The test module component is created by using a first programming language and the functional module component is created by using a second programming language that is different than the first programming language. In executing the methods the test module component sends a function identifier of a function to be performed by the functional module component. The function identifier is encapsulated within a call wrapper. In an alternative embodiment the first and second programming languages are the same.

The systems and methods allow communication between two components such as the test and functional module components that use two different languages in a test environment. Such communication is allowed by encapsulating the function identifier to create the call message.

In other embodiments such communication is also allowed by encapsulating an identifier of an event to create an event message or by encapsulating an identifier of the function to create a return message. The encapsulation facilitates communication between the two components that use different or same languages.

Each LAB includes a plurality of logic elements LEs which can be implemented as memory or logic. Each LE can be flexibly configured to include one or more lookup tables LUTs . LEs are connected via a plurality of local lines .

Processing unit may be a central processing unit CPU the processor a microprocessor a hardware controller a microcontroller a programmable logic device programmed for use as a controller a network controller or other processing unit. Memory device may be a random access memory RAM a read only memory ROM or a combination of RAM and ROM. For example memory device includes a computer readable medium such as a floppy disk a ZIP disk a magnetic disk a hard disk a compact disc ROM CD ROM a recordable CD a digital video disc DVD or a flash memory. Memory device stores a System on Programmable Chip SOPC Builder which may be a Quartus Systems QSYS Editor for designing PLD .

Network interface may be a modem or a network interface card NIC that allows processing unit to communicate with a network such as a wide area network WAN or a local area network LAN . Processing unit may be connected via a wireless connection or a wired connection to network . Examples of the wireless connection include a connection using Wi Fi protocol or a WiMax protocol. The Wi Fi protocol may be an IEEE 802.11 IEEE 802.11a IEEE 802.11b IEEE 802.11g or IEEE 802.11i protocol. Examples of input device include a mouse a keyboard a stylus or a keypad.

Output device may be a liquid crystal display LCD device a plasma display device a light emitting diode LED display device or a cathode ray tube CRT display device. Examples of output interface include a video controller that drives output device to display one or more images based on instructions received from processing unit a light source or an audio signal generator with speakers that outputs audible sound based on instructions received from processing unit . The light source may be a set of light emitting diodes LEDs or a cold cathode fluorescent lamp CCFL . Processing unit may access the techniques described herein for testing a component from memory device or from a remote memory device not shown similar to memory device via network and executes the techniques. Processing unit memory device network interface input device output interface and output device communicate with each other via a bus . In an alternative embodiment system may not include network interface .

In one example input stage often allows selection and parameterization of components to be used on PLD . Input stage also allows configuration of variable or fixed latency support. In some examples components provided to an input stage include intellectual property functions megafunctions and intellectual property cores. Input stage may be a graphical user interface GUI using wizards for allowing efficient or convenient entry of information. Input stage may also be a text interface or a program reading a data file such as a spreadsheet database table or schematic to acquire selection information. Input stage produces an output containing information about the various modules selected.

A generator program creates a logic description from information received via input stage and provides the logic description along with other customized logic to any of a synthesis tool place and route programs and logic configuration tools to allow a logic description to be implemented on PLD .

In typical implementations generator program can identify the selections and generate a logic description with information for implementing the various modules. Generator program can be a Perl script creating Hardware Description Language HDL files such as Verilog Abel Very High Speed Integrated Circuit HDL VHDL and Altera HDL AHDL files from the module information entered by the user.

Generator program also provides information to synthesis tool to allow HDL files to be automatically synthesized. In some examples a logic description is provided directly by the user. Hookups between various components selected by the user are also interconnected by generator program . Some of the available synthesis tools are Leonardo Spectrum available from Mentor Graphics Corporation of Wilsonville Oreg. and Synplify available from Synplicity Corporation of Sunnyvale Calif. The HDL files may contain technology specific code readable by synthesis tool .

Input stage generator program and synthesis tool can be separate programs. The interface between the separate programs can be a database file a log or simply messages transmitted between the programs. For example instead of writing a file to storage such as memory device input stage can send messages directly to generator program to allow the generator program to create a logic description. Similarly generator program can provide information directly to synthesis tool instead of writing HDL files. Similarly input stage generator program and synthesis tool can be integrated into a single program.

The user may select various modules and an integrated program can then take the user selections and output a logic description in the form of a synthesized netlist without intermediate files. According to other embodiments a logic description is a synthesized netlist such as an Electronic Design Interchange Format Input File EDF file . An EDF file is one example of a synthesized netlist file that can be output by synthesis tool .

Synthesis tool can take HDL files and output EDF files. Synthesis tool allows the implementation of the logic design on PLD .

A verification stage typically follows an application of synthesis tool . Verification stage checks the accuracy of the logic deign of PLD to ensure that an intermediate or final design realizes the expected requirements. Verification stage typically includes simulation tools functional verification tools and timing analysis tools for timing verification. A test module component described below may be a part of verification stage . For example the test module component is part of a simulation tool generated during verification stage . Tools for simulation allow the application of inputs and the observation of outputs without having to implement PLD . Simulation tools provide the user with cost effective and efficient mechanisms for both functional and timing verification of a design of PLD . Functional verification involves the circuit s logical operation independent of timing considerations. During functional verification gate delays are disregarded.

Timing verification involves the analysis of the design s operation with timing delays. Setup hold and other timing requirements for sequential devices such as flip flops within a design of PLD are confirmed. Some available simulation tools include Synopsys VCS VSS and Scirocco available from Synopsys Corporation of Sunnyvale Calif. and Cadence NC Verilog and NC VHDL available from Cadence Design Systems of San Jose Calif.

After verification stage the synthesized netlist file can be provided to a physical design stage including the place and route phase and configuration tools. The place and route phase typically locates logic cells on specific logic elements of PLD and connects wires between the inputs and outputs of various logic elements of the PLD in accordance with logic required to implement an electronic design. PLD can also be physically tested at .

For programmable logic devices a programmable logic configuration stage can take the output of the place and route phase to program PLD with the user selected and parameterized modules. According to various embodiments the place and route phase and the logic configuration stage are provided in a Quartus Development Tool available from Altera Corporation.

As noted above different stages and programs can be integrated in a variety of manners. According to one embodiment input stage generator program synthesis tool verification stage and physical design stage are integrated into a single program such as a System On a Programmable Chip SOPC Builder. The various stages are automatically run using system and transparent to the user. Technique can receive the user selected modules generate a logic description depicting logic for implementing the various selected modules and implement PLD . As will be appreciated by one of skill in the art HDL files and EDF files are mere examples of a logic description. Other file formats as well as internal program representations are other examples of a logic description.

Functional module component may be a master component that sends commands to a slave component or may be a slave component that receives commands from a master component. As an example functional module component is a memory mapped MM master bus functional module BFM an MM slave BFM a streaming ST source BFM or an ST sink BFM. A BFM may use any bus specification such as an advanced microcontroller bus architecture AMBA specification developed by ARM corporation an Avalon specification developed by Altera corporation or a MicroBlaze bus specification developed by Xilinx corporation to send and receive commands. Functional module component may be a memory controller a bus controller a processor a switch fabric or any other component. Memory component may be a RAM or a ROM.

Test module component is created as software by using a programming language different than a programming language used to create functional module component . For example test module component is created using VHDL SystemC or AHDL and functional module component is created by using Verilog SystemVerilog or Abel. As another example test module component is created by using a first mixture of any two of VHDL SystemC and AHDL and functional module component is created by using a second mixture of any two of Verilog SystemVerilog and Abel. As yet another example test module component is created by using Verilog SystemVerilog or Abel and functional module component is created by using VHDL SystemC or AHDL. As another example functional module component is created by using the first mixture and test module component is created by using the second mixture.

To use the SOPC Builder to create the test bench all components of system are described by hardware Tool Command language Tcl files which may be stored in memory device . Each component of system is represented by a hardware Tcl hw.Tcl file that describes the component to allow use of the component as an SOPC Builder component. For example each of test wrapper component test module component functional module component and functional wrapper component has an associated Tcl file. A Tcl file can be created manually by the user via input device or by using a Component Editor software.

System is implemented as hardware software or a combination of software and hardware. For example test module component and functional module component are integrated within the same integrated circuit such as PLD or an Application Specific Integrated Circuit ASIC . As another example test module component and functional module component are integrated within different integrated circuits. In this example test module component is integrated within a first PLD or ASIC and functional module component is integrated within a second PLD or ASIC. As yet another example each of test module component test wrapper component call connection return connection event connection functional wrapper component and functional module component is a software component or a hardware component. As another example each of test module component test wrapper component functional wrapper component and functional module component is implemented in hardware as LE and pins and are hardware pins and each channel and is a conductor such as a bus or a wire. As another example each of test module component and test wrapper component is implemented in hardware as LE each of functional wrapper component and functional module component is implemented as a software component that can be stored within memory device and can be executed by processing unit each pin and is a hardware pin and each channel and is a Joint Test Action Group JTAG connector. As yet another example each of functional wrapper component and functional module component is implemented in hardware as LE each of test module component and test wrapper component is implemented as a software component that can be stored within memory device and can be executed by processing unit each pin and is a hardware pin and each channel and is a Joint Test Action Group JTAG connector.

Each of test module component test wrapper component functional wrapper component and functional module component can be created by editing by the user HDL code generated by the SOPC Builder and adding the component to the code. If the user edits HDL code used to create the test bench the modified test bench is retained on subsequent modifications and regeneration of the modified test bench.

Regardless of how a component of system is created there is no direct signaling between test module component and functional module component . Rather communication between test module component and functional module component occurs via a call message a return message or an event message which are described below.

Functional module component includes an Application Programming Interface API that further includes a set of functions including function and function executed by functional module component . An example of function includes a write function and an example of function includes a read function. A function is a transaction such as a read or a write transaction. Test module component controls functional module component such as by issuing transactions or polling responses via functions and or events of API .

Test module component includes a set of function identifiers including a function identifier and a function identifier and the number of function identifiers in test module component are the same as the number of instances of functions in set . Function identifier identifies an instance of function and function identifier identifies an instance of function . An example of function identifier includes an identifier identifying an instance of a write function stored within functional module component and an example of function identifier includes an identifier identifying an instance of a read function stored within functional module component . API also includes a set of event identifiers such as an event identifier and an event identifier . Event identifier identifies an instance of an event and event identifier identifies an instance of an event . A set of events including events and are stored in functional module component .

API includes the set of events including events and . An event is similar to a function except that the event has only one phase equivalent to an API return unsolicited by test module component . A function has two phases including an API call which is a solicitation by test module component and an API return which is a response to the solicitation. Examples of an instance of an event include a notification of an instance of an error in functional module component . Another example of an instance of an event includes a notification that a return value described below is received by a response queue also described below of functional module component . The user labels an event with a particular prefix such as signal  or phenomenon  or a suffix such as  signal or  phenomenon by using input device at input stage to make the event publicly known especially to test module component . For example event is labeled as signal event and event is labeled as signal event . The label used for labeling an event is not used for labeling a function such as function or function . For example function may be labeled as foo function and function may be labeled as soo function . An event is used by test module component for synchronizing with functional module component by using a statement such as an statement or a wait statement which is created by the user at input state by using input device . The statement is executed by functional module component to monitor an occurrence of a condition and to execute an instance of the event upon occurrence of the condition. An event is unidirectional in that the event is transferred from functional module component to test module component and is not transferred from test module component to functional module component .

An identifier as used herein is a associated with a location such as a hierarchical instance path of an instance of an event or an instance of a function within a test bench hierarchy. For example as shown in a hierarchy of a test bench includes functional wrapper component functional module component another functional wrapper component and another functional module component . The other functional module component includes an API that further includes a function a function an event and an event . Location of instance of function within the hierarchy of test bench may be test bench .functional wrapper component .functional module component .API .function .instance . If function is within a first set of functions and function is within a second set of functions location of instance of function may be test bench . Functional wrapper component .functional module component .API .the first set of functions.function .instance and location of instance of function within the hierarchy of test bench may be test bench . functional wrapper component .functional module component .API .the second set of functions.function .instance . As another example location of instance of function is test bench . functional wrapper component . functional module component .API .function .instance . As yet another example location of instance of function is test bench . functional wrapper component .API .function .instance .

Test module component can reach across hierarchical boundaries and access any event of function of API or API if a hierarchical instance path of the event or functions is stored within test module component . For example if a function identifier identifying an instance of function is associated such as linked with a hierarchical instance path test bench .functional wrapper component .API .function .instance test module component module can access the instance of function by calling the function identifier that is equivalent to calling the hierarchical instance path.

A call is a hierarchical cross module reference between test module component and functional module component and such reference is specific to hierarchy of a component in test bench . For example test module component has a particular hierarchy within test bench . As another example test module component is executed first in order to test memory component . As yet another example test module component may be a macro named MSTR that points to functional module component that is controlled by an API call made by test module component . If there is a change in test bench such as renaming of an instance of component of test bench or a change in hierarchy of the component within the test bench the API call is also changed to reflect the change in the test bench or in the hierarchy.

In an alternative embodiment functional module component includes any number of functions and events. In yet another embodiment any or all of functions and are located in functional module component instead of functional module component and any or all of events and are located in functional module component instead of functional module component . In yet another alternative embodiment test module component is created as software by using the same programming language as that used to create functional module component . In still another alternative embodiment a BFM uses an Ethernet specification.

In another alternative embodiment test composite module is located on a chip having a single substrate that is separate from a chip having another single substrate on which functional composite module is located. Moreover in another alternative embodiment memory component is located on a chip having a single substrate separate from a chip having another single substrate on which test composite module or functional composite module is located. In various alternative embodiments test composite module is located on a different chip than a chip on which memory component is located and the memory component is located on the chip different than a chip on which functional composite module is located. A chip having a single substrate is different than another chip having a single substrate.

In yet another alternative embodiment. system is created using a custom programming software such as an HDL language or SystemC language.

It is also noted that each function and can have one or multiple instances. For example function is executed in instances and . In this example the same function is executed two times in multiple instances and . As another example each event and can have one or multiple instances. In this example the same event is executed three times in multiple instances and where instance is the first instance of event instance is the second instance of event and instance is the third instance of event .

Referring back to each of test module component test wrapper component functional wrapper component and functional module component operate synchronous to a particular clock signal. For example test module component operates synchronous to a clock signal test wrapper component operates synchronous to a clock signal functional wrapper component operates synchronous to a clock signal and functional module component operates synchronous to a clock signal . Each clock signal and is generated by a clock source not shown . For example clock signal is generated by a signal oscillator not shown clock signal is generated by another signal oscillator not shown clock signal is generated by yet another signal oscillator not shown and clock signal is generated by still another signal oscillator not shown . The clock signals and may be synchronous with each other or one or more of the clock signals is asynchronous with the remaining of the clock signals. In various embodiments in which one or more of the clock signals and is asynchronous with the remaining of the clock signals one or more clock domains of the one or more of the clock signals is synchronized with the remaining of clock domains of the remaining of the clock signals by a technique such as clock domain crossing.

Also test module component may be reset by a reset signal test wrapper component may be reset by another reset signal functional wrapper component is reset by yet another reset signal and functional module component is reset by still another reset signal . Reset signals and are asserted at time of initiation of simulation to test a component of a test bench such as test bench .

In various embodiments a first clock domain of clock signal with which a return message is synchronous is different than a second clock domain of clock signal with which a call message is synchronous. In an alternative embodiment a third clock domain of clock signal with which an event message is synchronous is different than the first and or second clock domains. Each clock domain has a unique frequency. For example a frequency of the first clock domain is different than a frequency of the second clock domain and a frequency of the third clock domain.

In another alternative embodiment clock signal is the same as one or more of clock signals and and reset signal is the same as one or more of reset signals and .

In an alternative embodiment event connection is the same as return connection . In various embodiments system does not include memory component . In various alternative embodiments test wrapper component is a part of test module component and functional wrapper component is a part of functional module component . In various embodiments API includes any number of instances of events and the same number of event identifiers are stored within test module component . In other embodiments API includes any number of instances of functions and the same number of function identifiers are stored within test module component .

In another alternative embodiment each of test module component test wrapper component functional wrapper component and functional module component can be created as a separate component within the SOPC Builder and all the components can be instantiated in parallel and can be reused in other test benches.

In yet another alternative embodiment memory component may be replaced with any other DUT that is connected via a plurality of pins and ports to functional module component .

It is further noted that in another embodiment any number of functional module components are connected to test wrapper component in a similar manner in which functional module component is connected to test wrapper component and each functional module component is connected to a DUT.

In various embodiments functional module component is not a server connected via a network such as the Internet or the Intranet to a client.

Upon determining to send argument with function identifier test module component sends both argument and function identifier to test wrapper component . On the other hand upon determining not to send argument with function identifier test module component sends function identifier to test wrapper component .

Upon receiving function identifier and not receiving argument test wrapper encapsulates function identifier in a call wrapper layer to create a call message . For example function identifier is attached as a prefix or suffix to call wrapper layer to create call message . The function identifier may be a numerical identifier an alphanumeric identifier or an identifier that only includes letters. An example of function identifier includes a name assigned to function by functional module component .

On the other hand upon receiving both the function identifier and argument test wrapper component encapsulates both argument and function identifier within call wrapper layer to create call message . For example test wrapper component attaches argument as a prefix or a suffix to function identifier to encapsulate both argument and function identifier within call wrapper layer to create call message .

Test wrapper component sends call message via call connection to functional wrapper component . Functional wrapper component receives call message from test wrapper component and determines whether the call message includes both function identifier and argument . Upon determining that call message includes function identifier and does not include argument functional wrapper component extracts function identifier from call message and sends functional identifier to functional module component . If call message includes both function identifier and argument functional wrapper component extracts both argument and function identifier from call message and sends the argument and function identifier to functional module component .

Upon receiving function identifier from functional wrapper component functional module component executes instance of function identified by function identifier . On the other hand upon receiving both argument and function identifier from functional wrapper component functional module component executes instance of function by using argument . For example if function identifier identifies instance of function of writing argument to a memory location of memory component functional module component executes instance of function of sending argument via a write connection including a functional module component write pin a write channel and a memory component write pin to write argument to a memory location of memory component . Write connection may be an on chip bus such as a bus that applies the AMBA specification the Avalon specification or the MicroBlaze bus specification.

Functional module component may receive another function identifier in a call message from test wrapper component in a similar manner in which call message is received and executes an instance of function upon receiving the function identifier that identifies instance of function . Instance of function is a first instance of function and instance of function is a second instance of function . Each instance of a function is an occurrence of the function and is identified by a unique function identifier.

In another embodiment test module component sends more than one argument such as a list of arguments via call message to test wrapper component that encapsulates the list within call wrapper .

Functional module component determines whether the return value is received from memory component or is generated within functional module component . If the return value is received from memory component or generated within functional module component functional module component sends the return value along with function identifier identifying instance of function executed to functional wrapper component . Instance of function is called by test module component by sending the call message to functional wrapper component . If the return value is not received from memory component and is not generated within functional module component functional module component sends the function identifier without sending the return value to functional wrapper component .

In case in which the function identifier is received and the return value is not received by functional wrapper component from functional module component functional wrapper component encapsulates in a return wrapper layer the function identifier identifying instance of function that was called by call message to generate a return message . In case in which the function identifier and the return value are received by functional wrapper component from functional module component functional wrapper component encapsulates in the return wrapper layer the function identifier and the return value to generate the return message . Functional wrapper component sends the return message to test wrapper component via return connection .

Test wrapper component receives return message from function wrapper component and determines whether the return message encapsulates both the return value and function identifier . Upon determining that the return message encapsulates the function identifier and does not encapsulate the return value test wrapper component extracts from return message the function identifier of function called via call message and provides the function identifier to test module component . On the other hand upon determining that the return message encapsulates both the function identifier and the return value test wrapper component extracts both function identifier and the return value from the return message and provides both function identifier and the return value to test module component .

Upon receiving function identifier and not receiving the return value from test wrapper component test module component determines that instance of function called by using call message was executed by functional module component . Upon receiving the return value and function identifier from test wrapper component test module component stores the return value in addition to making the determination that instance of function called by using call message was executed by functional module component .

Any of a call message a return message and an event message is transferred serially or in parallel over a corresponding connection. For example call message is transferred in parallel over call connection in a single clock cycle of clock signal or is transferred serially in a fixed width such as N bits over call connection where N is an integer greater than zero. As another example return message is transferred in parallel over return connection in a single clock cycle of clock signal or is transferred serially in a fixed width such as M bits over return connection where M is an integer greater than zero. As yet another example event message is transferred in parallel over event connection in a single clock cycle of clock signal or is transferred serially in a fixed width such as P bits over event connection where P is an integer greater than zero. M may be the same or different than N and or P. A fixed width is provided by the user via input device .

The number of clock cycles taken in communicating call return and or event messages depends on parameterization between test wrapper component and functional wrapper component and the parameterization is provided by the user via input device . A width of a connection depends on parameterization of the connection and the parameterization is provided by the user via input device .

It is noted that each of call connection return connection event connection read connection and write connection may communicate using an on chip communication such as the Avalon protocol the AMBA protocol or the MicroBlaze protocol. In an alternative embodiment each of call connection return connection event connection read connection and write connection may communicate using an off chip connection such as an Ethernet connection a Peripheral Component Interconnect Express PCI e connection a Universal Serial Bus USB connection a JTAG connection a Hypertransport connection developed by Advanced MicroDevices AMD corporation or a QuickPath Interconnect QPI developed by Intel corporation.

In an alternative embodiment read connection and write connection are the same. In another alternative embodiment argument and the return value are communicated between functional module component and memory component via the same connection. In another alternative embodiment the return value is not read from memory component but is rather stored in functional module component .

In various embodiments test module component compares the return value with argument to determine whether a match between the return value and argument has occurred. If there is a match test module component determines that functional module component is operational and may indicate so to output device that may display the determination or output the determination as an audio signal. On the other hand if there is no match between the return value and argument test module component determines that functional module component is nonoperational or malfunctioning and may indicate the determination to output device that may display the determination or output the determination as an audio signal.

In other embodiments test module component compares function identifier with another function identifier received within a return message to determine whether the two function identifiers match. The other function identifier identifies function of API after execution of instance of function . Function identifier identifies function of API before execution of instance of function . If there is a match test module component determines that instance of function was executed. On the other hand if the match does not occur test module component determines that instance of function was not executed.

It is noted that an instance of an event is not triggered based on information in a call message received from test wrapper component . Rather the condition that triggers execution of an instance of an event and the event are pre defined by the user by using input device . For example the user programs functional module component to define the condition and an event that is triggered based on the condition. In various embodiments an event performs the same task as that performed by a function of API except that the event is not instantiated upon receiving a function identifier from test module component but is rather triggered to perform the task upon occurrence of the condition.

Upon receiving the event identifier without receiving the event value from functional module component functional wrapper component encapsulates event identifier within an event wrapper layer to generate an event message . On the other hand if both event identifier and the event value are received by functional wrapper component from functional module component functional wrapper component encapsulates both the event identifier and event value within the event wrapper layer to generate the event message .

Functional wrapper component sends the event message to test wrapper component via event connection . Upon receiving event message test wrapper component determines whether event message encapsulates both the event value and event identifier .

Upon determining that event message encapsulates event identifier and not the event value test wrapper component extracts event identifier from event message and determines that instance of event has occurred in functional wrapper component and may send the determination to output device to display the determination.

Upon determining that event message encapsulates both event identifier and the event value test wrapper component extracts event identifier and the event value from event message determines that the instance of event has occurred and may store the event value .

In an alternative embodiment an event identifier is encapsulated by a functional wrapper component not shown separate from functional wrapper component .

Upon extracting function validity query function identifier and any argument received from functional wrapper component functional module component executes instance of function identified by function event identifier and also determines whether instance of function is validly executed. As an example if function is a read function for reading data from memory component functional module component determines whether data is read from memory component . Upon determining that data is read from memory component functional module component determines that instance of function is validly executed and upon determining that instance of function is validly executed functional module component creates a function validity read response which is an exemplary validity indicator. On the other hand upon determining that data is not read from memory component functional module component determines that instance of function is not validly executed and upon determining that instance of function is not validly executed functional module component does not create the function validity read response or creates a function invalidity read response which is an exemplary validity indicator. As another example if function is a write function for writing argument to memory component functional module component determines whether argument is written to memory component . Such a determination can be made based on whether a response is received from memory component upon sending a write command to the memory component . For example after sending a write command to memory component if functional module component receives a response from memory component functional module component determines that argument is written to memory component and if functional module component does not receive a response from memory component functional module component determines that argument is not written to memory component . Upon determining that argument is written to memory component functional module component determines that instance of function is validly executed and creates a function valid write response which is an exemplary validity indicator. On the other hand upon determining that argument is not written to memory component functional module component determines that instance of function is not validly executed. Upon determining that instance of function is not validly executed functional module component does not create a function valid write response or creates a function invalid write response which is an exemplary validity indicator.

Upon not creating the function valid read response or the function valid write response functional module component does not send a valid or invalid response to functional wrapper component . Moreover alternatively upon creating the function invalid read response or the function invalid write response functional module component sends the invalid response to functional wrapper component . On the other hand upon creating the function valid read response or the function valid write response functional module component sends the valid response to functional wrapper component .

If functional wrapper component receives the function invalid read response or the function invalid write response or does not receive a response functional module wrapper module encapsulates function identifier and the response in the return message to create the return message and sends the return message to test wrapper component via return connection .

On the other hand if functional wrapper component receives the function valid read response or the function valid write response from functional module component functional wrapper component encapsulates the response the function identifier and any return value that may be received from functional module component to create the return message and sends the return message to test wrapper module via return connection .

Upon receiving the return message from functional wrapper component test wrapper component determines whether return message excludes any response or includes the function invalid read response or the function invalid write response. For example upon receiving the return message from functional wrapper component test wrapper component determines whether return message includes the function valid read response or the function valid write response. Upon determining that return message includes the function valid read response or the function valid write response test wrapper component extracts the response function identifier identifying function that was performed and any return value that may be received and sends the function identifier the return value and the response to test module component . On the other hand upon determining that return message includes the function invalid read response or the function invalid write response or does not include any response test wrapper component extracts the invalid response function identifier identifying function that was performed and sends the function identifier and the invalid response to test module component .

Upon receiving the function valid read or write response test module component determines that instance of function is validly executed and that any return value received is valid. On the other hand upon receiving the function invalid read or invalid write response or not receiving a response test module component determines that instance of function is not validly executed. An instance of a function may not be validly executed for any of a variety of reasons such as malfunction or inoperation of memory component malfunction or inoperation of read connection malfunction or inoperation of write connection malfunction or inoperation of call connection malfunction or inoperation of return connection or malfunction or inoperation of event connection .

Any determination made by test module component may be output via output device such as a displayed on a display device or output as an audio signal by speakers or output in the form of various combinations of light colors of a light source.

Upon not creating the event valid read response or the event valid write response functional module component does not send a valid or invalid response to functional wrapper component . Moreover alternatively upon creating the event invalid read response or the event invalid write response functional module component sends the invalid response to functional wrapper component . On the other hand upon creating the event valid read response or the event valid write response functional module component sends the valid response to functional wrapper component .

If functional wrapper component receives the function invalid read response or the function invalid write response or does not receive a response functional module wrapper module encapsulates function identifier and the response in the event message to create the event message and sends the event message to test wrapper component via event connection .

On the other hand if functional wrapper component receives the event valid read response or the event valid write response from functional module component functional wrapper component encapsulates the response the event identifier and any event value that may be received from functional module component to create the event message and sends the event message to test wrapper module via event connection .

Upon receiving the event message from functional wrapper component test wrapper component determines whether event message excludes any response or includes the event invalid read response or the event invalid write response. For example upon receiving the event message from functional wrapper component test wrapper component determines whether event message includes the event valid read response or the event valid write response. Upon determining that event message includes the event valid read response or the event valid write response test wrapper component extracts the response event identifier identifying event that was performed and any event value that may be received and sends the event identifier the event value and the response to test module component . On the other hand upon determining that event message includes the event invalid read response or the event invalid write response or does not include any response test wrapper component extracts the invalid response event identifier identifying event that was performed and sends the event identifier and the invalid response to test module component .

Upon receiving the event valid read or write response test module component determines that instance of event is validly executed and that any event value received is valid. On the other hand upon receiving the event invalid read or invalid write response or not receiving a response test module component determines that instance of event is not validly executed. An instance of an event may not be validly executed for any of the reasons described above.

Functional module component creates command descriptor by populating the command descriptor with data such as argument and any other transaction information such as whether a transaction is a read transaction or a write transaction and pushes command descriptor onto pending command queue . Bus driver pops command descriptor from pending command queue and issues a transaction request such as a read request or a write request onto read or write connection to conduct a transaction such as a read or write transaction with respect to memory component by using data in the command descriptor . At the same time command descriptor is popped from pending command queue functional module component obtains a timestamp from counter and bundles the timestamp with command descriptor to create a bundled descriptor and pushes the bundled descriptor onto issued command queue .

Bus monitor obtains bundled descriptor from issued command queue to determine a type of response such as a response to a read request or a write request to expect from read connection or write connection . For example in case of a write transaction bus monitor may not expect any response from memory component or expects an error write signal from memory component . An error write signal is generated in case of an incomplete write transaction in which all data within command descriptor is not written to memory device or a broken write transaction in which write connection or memory component is malfunctional or inoperational. As another example in case of a read transaction bus monitor expects to receive the return value or an error read signal from memory component . An error read signal is generated by memory component in case of an incomplete read transaction in which all data from a particular memory location of memory component is not read from the location or a broken read transaction in which data is not read from memory component due to malfunction or inoperation of memory component or malfunction or inoperation of read connection .

When a response is received by bus monitor from memory component at end of a transaction functional module component creates response descriptor including the response that may include the return value and the response descriptor is pushed onto response queue . In addition functional module component calculates a latency of a transaction by subtracting the timestamp from a current value of counter at a time of reception of a response by bus monitor from memory component .

Test module component may query a state of response queue such as whether response queue is empty of full by sending the query within a call message. If all command descriptors in pending command queue have corresponding response descriptors in response queue functional module component sends in a return message data such as 1 to indicate to test module component that all command descriptors within issued command queue are executed. Otherwise functional module component sends a 0 .

In various embodiments functional module component fires an event indicating whether all commands in pending command queue are executed in the same manner as that described above except the event is not fired in response to a query from test module component but rather upon an occurrence of the condition such as whether response queue has response descriptors corresponding to all command descriptors in pending command queue . Examples of an event include a notification that a fatal error has occurred in functional module component a notification that a response is received by functional module component from memory component and pushed into response queue a notification that command descriptor is driven onto read connection or write connection a notification that all transactions corresponding to command descriptors within pending command queue are executed a notification that pending command queue is occupied by command descriptors below a minimum threshold a notification that pending command queue is occupied by command descriptors above the minimum threshold.

In an alternative embodiment functional module component is generated using any HDL language such as SystemVerilog VHDL or Verilog.

Although the systems and methods are described herein with respect to PLD the systems and methods are also applicable to an ASIC.

If both test module component and functional module component use the same programming language which is the programming language used to create the components test module component can directly access functions and of API without the use of test wrapper component and functional wrapper component .

In a case in which test module component and functional module component use different programming languages without the use of test wrapper component and functional module component test module component and functional module component can be interconnected directly via a set of pins not shown and the programming language used to create test module component restricts how functions and or are accessed by test module component . However in such an embodiment a language used by test module component which is the same language used to create test module component restricts how an instance of a function of API can be accessed. For example a language used by test module component in and of itself does not support an API call. This restriction prevents test module component from calling a function of functional module component . Hierarchical cross module access of functions and or are not supported in the programming language used to create test module component .

The systems and methods described herein make it possible to use functional module component having procedural API within the test bench. By packaging functions and or events of API as messages which may be packets the messages can be transferred to test module component over corresponding event and or function connections which may include Avalon ST interfaces. Hence test module component which may use VHDL and functional module component which may use Verilog can be interconnected via test wrapper component functional wrapper component and any or all of return connection call connection and event connection and thus exchange information regarding API .

The systems and methods described herein allow an interoperation of functional module component within a test bench. The systems and methods provide a mechanism for test module component which may be a test program to access API . Test module component and the functional module component can be implemented in distinct register transfer level RTL languages such as VHDL and Verilog. Communication between test module component and the functional module component is via a call message a return message and or an event message transported over corresponding call connection return connection and event connection .

A single implementation in two languages rather than two implementations one in each language offers a plurality of benefits including lower development and maintenance cost. Moreover no issues are created with model mismatches between two distinct languages. Systems and methods described herein allow functional module component that uses one language to run in a test bench environment that uses another language or any simulator that uses dual language simulation.

The systems and methods described herein maps an API call onto call connection and an API return onto return connection to facilitate communication between test module component and functional module component . API call and return features are not available if test module component and functional module component are created such as written in the same language.

It is further noted that the systems and methods described herein do not apply to a Transaction Level Modeling TLM 2.0 standard that is applied for interoperability between components created with SystemC and SystemVerilog protocols.

Although the foregoing systems and techniques have been described in detail by way of illustration and example for purposes of clarity and understanding it will be recognized that the above described systems and techniques may be embodied in numerous other specific variations and embodiments without departing from the spirit or essential characteristics of the systems and techniques. Certain changes and modifications may be practiced and it is understood that the systems and techniques are not to be limited by the foregoing details but rather is to be defined by the scope of the appended claims.

