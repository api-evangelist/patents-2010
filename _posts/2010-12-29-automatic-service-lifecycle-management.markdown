---

title: Automatic service lifecycle management
abstract: A method is described for assisting execution of an application that is implemented with individual blocks of program code that are executable with separate processes. The method includes receiving an indication that a first of the blocks desires availability of a service provided by a second of the blocks. The method further includes, in response to the receipt of the indication, instantiating an instance of code to handle the delivery of inter process requests from the first block to the second block. The method further includes, in response to the instance of code receiving a first request from the first block for the service, instantiating the second block for execution with a different process than the first block's process. The method further includes detecting that the second block has no pending requests and has not, over a period of time, received any new requests, and, terminating the second block in response.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09317324&OS=09317324&RS=09317324
owner: Apple Inc.
number: 09317324
owner_city: Cupertino
owner_country: US
publication_date: 20101229
---
Concurrent execution of multiple processes has become more and more of a mainstream runtime environment for present day desktop computing systems and mobile computing systems including laptop notebook netbook tablet and smartphone systems . A process is the execution of a sequence of code to accomplish a particular task. Concurrent execution of multiple processes is the concurrent execution of multiple sequences of code over a same time period to accomplish multiple respective tasks. In various environments multiple processes are understood to have independent address spaces. A possible benefit of separate address spaces is that one process cannot inadvertently disrupt the data of another process.

In the case of application software application developers may wish to try utilize multiple processes for their particular application. However writing application software for a multiple process environment may present some challenges. One issue pertains to inter process communication. Here for example the application software developer may granularize the overall application into smaller constituent regions or blocks with the idea that different blocks can be run concurrently on different processes. Even so however blocks will need to communicate with other blocks within the same application in order to effect cohesive overall flow of the application as a whole.

For instance if a first block of the program recognizes that a second block of the program can be used to perform a specific task concurrently with the operation of the first block the first block should be able to communicate with the second block in order to trigger the second block into operation. Unfortunately such communication between processes typically involves knowledge of low level system details that ideally application software developers should not have to concern themselves with.

Another issue concerns the memory footprint of the application. Specifically inefficient memory use results if certain blocks of the application are instantiated in memory and ready to operate but have either never been called upon to operate or are not expected to be called on to operate.

Inter process communication takes place through conduits . In a further embodiment a service is invoked by the main execution block by issuing a request message to the conduit that connects the main execution block to the service being invoked. For instance if the main execution block desires to use service main execution block issues a request message to conduit . Subsequently once service completes its task in response to the request the service sends a response message to the main execution block over conduit . Having successfully invoked the service the main execution block continues forward with execution of the overall application.

As alluded to above in the Background if services represent the set of all potential services for the application that main execution block might call upon during operation of the application it is apt to be an inefficient use of memory to load into memory each of the blocks of code for the respective services when the application is first launched. Here the invocation of a particular service is likely to be a function of a particular state of the main execution block e.g. the values of the main execution block s variables . It is possible that because of the main execution block s state some services of the application have little or no likelihood of being called upon by the main execution block. As such memory resources are better utilized if such services are not loaded in memory.

Instead as described in more detail further below a more efficient approach is to load a service into memory when it is needed or at least when the state of the application is such that there is an increased likelihood that a service might be needed. Moreover further memory efficiencies may be realized if a determination is made that a particular service that has been loaded into memory is apt not to be called upon again. In this case the region of memory where the service s corresponding block of code resides may be made available for other system uses. That is the unused service is terminated. In addition to the above described memory savings compartmentalization of an application into a number different services also improves the resilience of the application through fault isolation and recovery. That is a crash in one process does not necessarily terminate the entire application and the service process that crashed can be automatically relaunched in response to a crash as easily as it could be relaunched in response to an idle exit timeout as described in more detail further below .

For instance an embedded service provided by the platform which may be the same service that provides inter process communication as described below scans the application to identify the various services that the application has the potential to invoke. The embedded service clears any all such services through a security authentication and or authorization process and provides a formal name or other identifier for each such service to the main execution block.

It is pertinent to note that according to one approach the services that are advertised to the main execution block are a mixture of services written by the application developer and services provided by the underlying platform e.g. operating system OS . In this manner the provider of the underlying platform can integrate various application services as part of the platform which saves the developer the time and expense of having to write custom code for these same services. For example according to one embodiment the services that are provided by the underlying platform include to name a few 1 an image decoder service that decodes images according to a particular industry standard e.g. an H264 decoder 2 a network authentication service that performs authentication procedures according to a particular industry standard e.g. SAML 3 a parser that parses text documents written according to an industry standard e.g. an XML parser 4 a service that provides arbitrated access to a system resource such as a disk drive or network interface .

With these services being provided by the underlying platform and made available to an application written for the platform the application developer need not expend resources writing custom code services for functions that perform these same services. Here as the platform provider begins to make available more and more services for basic or fundamental routines such as any routine whose functions are specified by an industry standard the developer s development efforts may be more streamlined towards routines that are custom to the specific application being developed e.g. the unique logic of the application . In this case the application developer need only provide the application in the form of the main execution block and the application s application specific services.

As mentioned just above the advertisement of services to the main execution block may include both services that are provided as part of the platform and those that were written by the application developer. As will be more apparent further below architecturally speaking in an embodiment there is no substantial difference as to the manner in which the services provided by the platform are instantiated and the manner in which the services written by the application developer are instantiated. That is during the services advertisement phase of the application initialization process the main execution block becomes aware of custom made services provided by the application developer and basic services provided as part of the underlying platform. Over the course of program flow the main execution block invokes various ones of these services e.g. as needed without there being any substantial difference as to the manner in which they are invoked and instantiated.

In response to the main execution block s asking for the service a dedicated connection for issuing request messages to the service and receiving subsequent reply messages from the service is established. In an embodiment the establishment of the connection is effected by providing a handler with corresponding API to the main execution block . In an embodiment part of the service advertisement is a description of the service s input parameters and output product s . The handler is code that runs on the main execution block s process receives the input parameters from the main execution block and forwards them to the service which is running on a different process than the handler s and main execution block s process . When the service has produced the output product s responsive to the received input parameters the handler receives the output product s from the service and presents them to the main execution block . Here because the targeted service is running on a different process than the main execution block in an embodiment where the different processes have independent address spaces the request for the service is communicated explicitly by the main execution block s process.

In an embodiment when the handler for the service is instantiated the service itself or said another way the service s program code is not instantiated loaded into memory . Here as the main execution block may request a service merely because the state of the application has reached a point where an actual need for the service is more likely the service s actual use is not guaranteed. As such instantiation of the service s code on its respective process is triggered when the service s handler actually receives a request e.g. with input parameters for the service. In this approach memory usage is conserved because memory is not populated with the service s substantive operational code until it is actually needed.

The situation depicted in where an inter process communicative channel to a service has been instantiated but the service itself has not can therefore remain for an extended period of time. In a further embodiment once constructed the communication channel is never torn down unless the application itself is terminated.

In the case where the service is replaced with another service whose function is different than the previously called service for the application as observed in the main execution block asks for the newer service . In response in an embodiment a second inter process communication channel with corresponding handler is coupled between the main execution block and the process that was used to execute the first now terminated service. Here as the different services are apt to accept different inputs the main execution block is provided with different handlers for the different services which from the main execution block s perspective corresponds to different communication channels in fact the underlying transport mechanism within the platform may be the same as between the two channels. In an implementation the handlers are performed by a single entity that renegotiate the channels between the different services. The application may generally be unaware of this transition from the handler API perspective.

As discussed above in an embodiment upon the communication channel to the newly asked service being instantiated in response to the main execution block s request for the newer service the newer service is not actually instantiated until the main execution block actually requests the service s service. shows the system after the main execution block has actually issued a request for the new service to the new handler associated with communication channel . shows the exemplary situation where some time later the newer service has not been utilized for a time period and is terminated in response. Notably the handlers for each of the previously instantiated services of process remain.

Recalling from above that services may be terminated if they are deemed not to be in use nor are expected to be used at least in the near term in one embodiment a hidden daemon within the platform monitors the usage of the individual services and makes the determination that a specific instantiated service should be terminated. According to one approach for each instantiated service the platform daemon increments a counter each time the main execution block issues a request to the service and decrements the counter each time the service responds to a particular request. The counter may be incremented decremented by observing the behavior on a service s inter process communication channel e.g. by observing requests handled by the handler observing the actual passage of the request between processes observing the state of a service side queue etc. . In an embodiment the service process itself keeps track of the counter e.g. a default timeout value on the order of 30 seconds but that is not a strict requirement . This is done by system code resident inside the service process i.e. the library runtime support .

Notably in an embodiment requests to the individual services can be queued e.g. at the service side process . As such the counter is able to increment to values greater than one. For example if a particular service entails fairly extensive and therefore time lengthy operations the main execution block may have multiple requests for the service before the service is able to respond to an initial request. Here the main execution block simply issues the requests are queued. The counter increments for each new request and therefore increases to a value greater than one. Note that a single process may be multi threaded. In this case multiple requests to a same process service can be concurrently handled at least partially in parallel.

If no new requests are issued at least until the service is able to respond to all the currently issued requests the counter which again is decremented for each response to a request generated by the service will eventually decrement to zero signifying that all issued requests have been responded to. As such a counter value of zero corresponds to a service that is not currently being utilized. In an embodiment the platform background daemon tracks the counter values and in response to a detected counter value of zero starts a timer. In an embodiment the timer is set to expire after a time period has passed beyond which is an indication that an application s state has moved to a point in which the application s need for the service is unlikely e.g. according to one embodiment 20 ms .

If a new request for the service is observed or said another way the counter increments to a value of one or more before the timer expires the count is stopped and the timer is reset. If the counter is again observed to reach a value of zero the timer restarts set for expiration upon passing of the full time period and the process repeats. If the timer ever expires upon expiration of the full time period which corresponds to the counter remaining at zero over the time period expanse of the timer the service is terminated.

In a more distributed approach for example in which the counter values for the various services are respectively maintained by the services themselves e.g. as described above the inter process communication service is designed to have visibility into the current counter values of the service processes. Based on criteria established by the system inter process communication service can scan counter values and look for opportunities to terminate the various service processes. Here the arrows from inter process communication service represent this visibility into the counters.

Recall from the discussion of that a more centralized application architecture was discussed that included a main execution block and individual services . In a purely centralized model only the main execution block calls on the services based on application needs or anticipated application needs determined by the main execution block. show a more distributed approach in which a service is permitted to call upon another service. Referring to block corresponds to a first block of application code running on a first process. At some execution point observed in block asks for a first service. In response an inter process communication channel is established to a second process. In an embodiment the inter process communication channel is established at least in part with a handler and corresponding API that is instantiated on the first process.

Upon an actual message being constructed for the first service by the first block of application code as observed in the first service is instantiated on the second process. At some execution point observed in first service asks for a second service. In response an inter process communication channel is established to a third process. In an embodiment the inter process communication channel is established at least in part with a handler and corresponding API that is instantiated on the second process. Upon an actual message being constructed for the second service by the first service as observed in the second service is instantiated on the third process. Thus in contrast to where all inter process communication channels reside between a main execution block and the application s individual services in an inter process communication channel can reside between services or at least not all inter process communication channels need to reside between one block of code and all other blocks of code.

In an embodiment in order for the first service to ask for the second service the first service needs to be aware of the second service . Thus according to one approach as part of the start up instantiation of first service the other services of the application including service are advertised to the first service . Thus whereas in a purely centralized approach e.g. as observed in it is possible to only advertise available services to the main execution block by contrast in a more distributed approach individual services may be made aware of other individual services.

Furthermore as described at length above any one of services may be terminated if a determination is made that a service is not being utilized. For example as discussed above a counter may be maintained for each of services that increments with each new request message for the service and decrements with each response provided by the service. If the counter value for a service remains at zero over a specific time period the service is terminated.

The bus interconnects these various components together and also interconnects these components to a display controller and display device and to peripheral devices such as input output I O devices which may include a touchscreen network interfaces and other devices which are well known in the art. Typically the input output devices are coupled to the system through input output controllers. The volatile memory is typically implemented as dynamic RAM DRAM which requires power continually in order to refresh or maintain the data in the memory. The nonvolatile memory is typically a magnetic hard drive or a flash semiconductor memory or a magnetic optical drive or other type of memory systems which maintain data e.g. large amounts of data even after power is removed from the system. Typically the nonvolatile memory will also be a random access memory although this is not required.

While shows that the nonvolatile memory is a local device coupled directly to the rest of the components in the data processing system it will be appreciated that the present invention may utilize storage which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as is well known in the art. Alternatively the bus may be replaced with a mesh or other arrangement of point to point links.

It will be apparent from this description that aspects of the present invention may be embodied at least in part in software. That is the techniques may be carried out in a computing system in response to its processor s processing core s executing sequences of instructions contained in a machine readable storage medium such as a memory e.g. memory and or memory . In various embodiments hardwired circuitry may be used in combination with software instructions to implement the present invention. Thus the techniques are not limited to any specific combination of hardware circuitry and software nor to any particular source for the instructions executed by the data processing system. In addition throughout this description various functions and operations are described as being performed by or caused by software code to simplify description. However those skilled in the art will recognize what is meant by such expressions is that the functions result from execution of the code by a processor such as the processing system .

In the foregoing specification the invention has been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

