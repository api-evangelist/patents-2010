---

title: Systems and methods for service isolation
abstract: The present invention is directed towards systems and methods of streaming an application from a remote location to a local machine system, and using local machine system resources in executing that application. In various embodiments, services needed by a streamed application may be started with high local system privileges in their own isolation environment. These service may be started, stopped, and otherwise managed by a Service Control Manager. In order for an application to both access services that operate at high local system privileges and the network so that it can access remotely stored, streaming, information; a streaming application may rely on privileges of the user when accessing network information rather than the higher privileges of the services running in isolation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09055080&OS=09055080&RS=09055080
owner: Citrix Systems, Inc.
number: 09055080
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20101213
---
This application claims priority to U.S. Application Ser. No. 61 286 334 entitled Systems and Methods for Rade Service Isolation filed Dec. 14 2009 the entire disclosure of which is incorporated herein by reference in its entirety for any and all purposes.

The present disclosure relates to a method for executing application programs and in particular to a method for isolating services operating on a client machine.

Administrators of modern enterprise environments may face many challenges when providing access to application programs. One such challenge concerns the issue of delivering and maintaining i.e. updating applications to the environments in which they will eventually execute large numbers of machines having different execution environments with varying types of access to multiple corporate networks. Another challenge concerns providing an environment on a target machine enabling execution of an application program without interfering with other application programs which may have conflicting requirements and in environments in which the application program may not have been designed to run i.e. a single user application running in isolation within a multi user operating system .

The present disclosure relates to a method for selecting between a predetermined number of execution methods for an application program. In one aspect the invention relates to a method for selecting by a remote machine a method of execution for an application program. Credentials associated with a local machine are received. An enumeration of a plurality of applications available to the local machine is provided responsive to the received credentials. A request to execute an enumerated application is received. One of a predetermined number of methods for executing the enumerated application is selected responsive to a policy the predetermined number of methods including a method for application streaming of the enumerated application. In one embodiment the method includes selection of a method for streaming of the enumerated application to the local machine. In another embodiment the method includes selection of a method for streaming the enumerated application to a remote machine executing the enumerated application on the remote machine and providing to the local machine application output data generated by the execution of the enumerated application on the remote machine.

In another aspect the present application relates to systems and methods for providing isolation environments to services and service processes supporting applications operating in their own isolation environments that are independent from the isolation environments of the services.

The illustrative embodiment of the present disclosure is applicable to a distributed networking environment where a user of a local machine requests access to applications stored on a remote machine. Prior to discussing the specifics of the present disclosure it may be helpful to discuss some of the network environments in which the illustrative embodiment of the present disclosure may be employed.

The remote machines within each farm can be heterogeneous. That is one or more of the remote machines can operate according to one type of operating system platform e.g. WINDOWS NT manufactured by Microsoft Corp. of Redmond Wash. while one or more of the other remote machines can operate on according to another type of operating system platform e.g. Unix or Linux . The remote machines comprising each farm do not need to be physically proximate to each other remote machine in its farm . Thus the group of remote machines logically grouped as a farm may be interconnected using a wide area network WAN connection or medium area network MAN connection. For example a farm may include remote machines physically located in different regions of a state city campus or room. Data transmission speeds between remote machines in the farm can be increased if the remote machines are connected using a local area network LAN connection or some form of direct connection.

Remote machines may be referred to as servers file servers application servers or remote machines. In some embodiments remote machines may have the capacity to function as either application servers or as a master application server. In one embodiment a remote machine may include an Active Directory. The local machines may also be referred to as client nodes or endpoints. In some embodiments the local machines have the capacity to function as both client nodes seeking access to applications and as application servers providing access to hosted applications for other local machines .

In one embodiment the local machine communicates directly with one of the remote machines in a farm . In another embodiment the local machine executes a program neighborhood application to communicate with the remote machine in a farm . In still another embodiment the remote machine provides the functionality of a master node. In some embodiments the local machine communicates with the remote machine in the farm through a communications link . Over the communication link the local machine can for example request execution of various applications hosted by the remote machines and in the farm and receive output of the results of the application execution for display. The communications link may be synchronous or asynchronous and may be a LAN connection MAN Medium Area Network connection or a WAN connection. Additionally communications link may be a wireless link such as an infrared channel or satellite band. In some embodiments only the master node provides the functionality required to identify and provide address information associated with a remote machine hosting a requested application.

In some embodiments a local machine communicates with a remote machine . In one of these embodiment the remote machine provides functionality of a web server. In another of these embodiments the remote machine receives requests from the local machine forwards the requests to a remote machine and responds to the request by the local machine with a response to the request from the remote machine . In still another of these embodiments the remote machine acquires an enumeration of applications available to the local machine and address information associated with a remote machine hosting an application identified by the enumeration of applications. In yet another of these embodiments the remote machine presents the response to the request to the local machine using a web interface. In one embodiment the local machine communicates directly with the remote machine to access the identified application. In another embodiment the local machine receives application output data from the remote machine the application output data generated by an execution of the identified application on the remote machine .

In many embodiments the remote machines and the local machines and are provided as personal computer or computer servers of the sort manufactured by Apple Computer Inc. of Cupertino Calif. International Business Machines of White Plains N.Y. Hewlett Packard Corporation of Palo Alto Calif. or the Dell Corporation of Round Rock Tex. In some embodiments the remote machines may be virtual machines executing on a server such as a blade server. In these embodiments a single physical server may provide two or more application servers.

The central processing unit is any logic circuitry that responds to and processes instructions fetched from the main memory unit . In many embodiments the central processing unit is provided by a microprocessor unit such as those manufactured by Intel Corporation of Mountain View Calif. those manufactured by Motorola Corporation of Schaumburg Ill. those manufactured by International Business Machines of White Plains N.Y. or those manufactured by Advanced Micro Devices of Sunnyvale Calif.

Main memory unit may be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by the microprocessor such as Static random access memory SRAM Burst SRAM or SynchBurst SRAM BSRAM Dynamic random access memory DRAM Fast Page Mode DRAM FPM DRAM Enhanced DRAM EDRAM Extended Data Output RAM EDO RAM Extended Data Output DRAM EDO DRAM Burst Extended Data Output DRAM BEDO DRAM Enhanced DRAM EDRAM synchronous DRAM SDRAM JEDEC SRAM PC SDRAM Double Data Rate SDRAM DDR SDRAM Enhanced SDRAM ESDRAM SyncLink DRAM SLDRAM Direct Rambus DRAM DRDRAM or Ferroelectric RAM FRAM .

In the embodiment shown in the processor communicates with main memory via a system bus described in more detail below . depicts an embodiment of a computer system in which the processor communicates directly with main memory via a memory port. For example in the main memory may be DRDRAM.

In the embodiment shown in the processor communicates with various I O devices via a local system bus . Various busses may be used to connect the central processing unit to the I O devices including a VESA VL bus an ISA bus an EISA bus a MicroChannel Architecture MCA bus a PCI bus a PCI X bus a PCI Express bus or a NuBus. For embodiments in which the I O device is a video display the processor may use an Advanced Graphics Port AGP to communicate with the display. depicts an embodiment of a computer system in which the main processor communicates directly with I O device via HyperTransport Rapid I O or InfiniBand. also depicts an embodiment in which local busses and direct communication are mixed the processor communicates with I O device using a local interconnect bus while communicating with I O device directly.

A wide variety of I O devices may be present in the computer system . Input devices include keyboards mice trackpads trackballs microphones and drawing tablets. Output devices include video displays speakers inkjet printers laser printers and dye sublimation printers. An I O device may also provide mass storage for the computer system such as a hard disk drive a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive tape drives of various formats and USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry Inc. of Los Alamitos Calif. and the iPod Shuffle line of devices manufactured by Apple Computer Inc. of Cupertino Calif.

In further embodiments an I O device may be a bridge between the system bus and an external communication bus such as a USB bus an Apple Desktop Bus an RS 232 serial connection a SCSI bus a FireWire bus a FireWire 800 bus an Ethernet bus an AppleTalk bus a Gigabit Ethernet bus an Asynchronous Transfer Mode bus a HIPPI bus a Super HIPPI bus a SerialPlus bus a SCI LAMP bus a FibreChannel bus or a Serial Attached small computer system interface bus.

General purpose desktop computers of the sort depicted in and typically operate under the control of operating systems which control scheduling of tasks and access to system resources. Typical operating systems include MICROSOFT WINDOWS manufactured by Microsoft Corp. of Redmond Wash. MacOS manufactured by Apple Computer of Cupertino Calif. OS 2 manufactured by International Business Machines of Armonk N.Y. and Linux a freely available operating system distributed by Caldera Corp. of Salt Lake City Utah among others.

The local machines and may be any personal computer e.g. a Macintosh computer or a computer based on processors such as 286 386 486 Pentium Pentium II Pentium III Pentium IV Pentium M the Celeron or the Xeon processor all of which are manufactured by Intel Corporation of Mountain View Calif. Windows based terminal Network Computer wireless device information appliance RISC Power PC X device workstation mini computer main frame computer personal digital assistant or other computing device that has a windows based desktop and sufficient persistent storage for executing a small display presentation program. The display presentation program uses commands and data sent to the application across communication channels to render a graphical display. Windows oriented platforms supported by the local machines and can include without limitation WINDOWS 3.x WINDOWS 95 WINDOWS 98 WINDOWS NT 3.51 WINDOWS NT 4.0 WINDOWS 2000 Windows 2003 WINDOWS CE Windows XP Windows vista MAC OS Java Linux and UNIX. The local machines and can include a visual display device e.g. a computer monitor a data entry device e.g. a keyboard persistent or volatile storage e.g. computer memory for storing downloaded application programs a processor and a mouse. Execution of a small display presentation program allows the local machines and to participate in a distributed computer system model i.e. a server based computing model .

For embodiments in which a local machine or is a mobile device the device may be a JAVA enabled cellular telephone such as those manufactured by Motorola Corp. of Schaumburg Ill. those manufactured by Kyocera of Kyoto Japan or those manufactured by Samsung Electronics Co. Ltd. of Seoul Korea. In other embodiments in which the local machine or is mobile the device may be a personal digital assistant PDA operating under control of the PalmOS operating system such as the devices manufactured by palmOne Inc. of Milpitas Calif. In further embodiments the local machine or may be a personal digital assistant PDA operating under control of the PocketPC operating system such as the iPAQ devices manufactured by Hewlett Packard Corporation of Palo Alto Calif. the devices manufactured by ViewSonic of Walnut Calif. or the devices manufactured by Toshiba America Inc. of New York N.Y. In still other embodiments the client node is a combination PDA telephone device such as the Treo devices manufactured by palmOne Inc. of Milpitas Calif. In still further embodiments the local machine or is a cellular telephone that operates under control of the PocketPC operating system such as those manufactured by Motorola Corp.

In one embodiment the local machine communicates directly with one of the remote machines in a farm . In some embodiments the local machine communicates with the remote machine in the farm through a communications link . Over the communication link the local machine can for example request execution of various applications hosted by the remote machines and in the farm and receive output of the results of the application execution for display. The communications link may be synchronous or asynchronous and may be a LAN connection MAN Medium area Network connection or a WAN connection. Additionally communications link may be a wireless link such as an infrared channel or satellite band.

In some embodiments a local machine communicates with a remote machine . In one of these embodiment the remote machine provides the local machine with an enumeration of applications available for execution by the local machine . In another of these embodiments the remote machine provides the local machine with address information associated with a remote machine hosting an application identified by the enumeration of applications. In still another of these embodiments the local machine communicates with the remote machine to access the identified application. In one embodiment the local machine executes a program neighborhood application to communicate with the remote machines and . In some embodiments each of the remote machines provide the functionality required to identify and provide address information associated with a remote machine hosting a requested application.

In some embodiments a local machine communicates with a remote machine . In one of these embodiment the remote machine provides functionality of a web server or a file server. In another of these embodiments the remote machine receives requests from the local machine forwards the requests to a remote machine and responds to the request by the local machine with a response to the request from the remote machine . In still another of these embodiments the remote machine acquires an enumeration of applications available to the local machine and address information associated with a remote machine providing access to an application program identified by the enumeration of applications. In yet another of these embodiments the remote machine presents the response to the request to the local machine using a web interface. In one embodiment the local machine communicates directly with the remote machine to access the identified application. In another embodiment the local machine receives application output data from the remote machine the application output data generated by an execution of the identified application on the remote machine .

Referring now to the remote machines comprising a farm each include a network side interface and a farm side interface . The network side interfaces of the remote machine may be in communication with one or more local machines or a network . The network can be a WAN LAN or international network such as the Internet or the World Wide Web. Local machines may establish connections with the remote machines using the network .

The farm side interfaces of the remote machines are interconnected with each over communication links so that the remote machines may communicate with one another. On each remote machine the farm side interface communicates with the network side interface . The farm side interfaces also communicate designated by arrows with a persistent store and in some embodiments with a dynamic store . The combination of remote machines the persistent store and the dynamic store when provided are collectively referred to as a farm . In some embodiments a remote machine communicates with the persistent store and other remote machines communicate with the remote machine to access information stored in the persistent store.

Persistent store may be physically implemented on a disk disk farm a redundant array of independent disks RAID writeable compact disc or any other device that allows data to be read and written and that maintains written data if power is removed from the storage device. A single physical device may provide storage for a plurality of persistent stores i.e. a single physical device may be used to provide the persistent store for more than one farm . The persistent store maintains static data associated with each remote machine in farm and global data used by all remote machines within the farm . In one embodiment the persistent store may maintain the remote machine data in a Lightweight Directory Access Protocol LDAP data model. In other embodiments the persistent store stores remote machine data in an ODBC compliant database. For the purposes of this description the term static data refers to data that do not change frequently i.e. data that change only on an hourly daily or weekly basis or data that never change. Each remote machine uses a persistent storage subsystem to read data from and write data to the persistent store .

The data stored by the persistent store may be replicated for reliability purposes physically or logically. For example physical redundancy may be provided using a set of redundant mirrored disks each providing a copy of the data. In other embodiments the database itself may be replicated using standard database techniques to provide multiple copies of the database. In further embodiments both physical and logical replication may be used concurrently.

The dynamic store i.e. the collection of all record tables can be embodied in various ways. In one embodiment the dynamic store is centralized that is all runtime data are stored in the memory of one remote machine in the farm . That remote machine operates as a master network node with which all other remote machines in the farm communicate when seeking access to that runtime data. In another embodiment each remote machine in the farm keeps a full copy of the dynamic store . Here each remote machine communicates with every other remote machine to keep its copy of the dynamic store up to date.

In another embodiment each remote machine maintains its own runtime data and communicates with every other remote machine when seeking to obtain runtime data from them. Thus for example a remote machine attempting to find an application program requested by the local machine may communicate directly with every other remote machine in the farm to find one or more remote machines hosting the requested application.

For farms having a large number of remote machines the network traffic produced by these embodiments can become heavy. One embodiment alleviates heavy network traffic by designating a subset of the remote machines in a farm typically two or more as collector points. Generally a collector point is a remote machine that collects run time data. Each collector point stores runtime data collected from certain other remote machines in the farm . Each remote machine in the farm is capable of operating as and consequently is capable of being designated as a collector point. In one embodiment each collector point stores a copy of the entire dynamic store . In another embodiment each collector point stores a portion of the dynamic store i.e. it maintains runtime data of a particular data type. The type of data stored by a remote machine may be predetermined according to one or more criteria. For example remote machines may store different types of data based on their boot order. Alternatively the type of data stored by a remote machine may be configured by an administrator using administration tool . In these embodiments the dynamic store is distributed among two or more remote machines in the farm .

Remote machines not designated as collector points know the remote machines in a farm that are designated as collector points. A remote machine not designated as a collector point may communicate with a particular collector point when delivering and requesting runtime data. Consequently collector points lighten network traffic because each remote machine in the farm communicates with a single collector point remote machine rather than with every other remote machine when seeking to access the runtime data.

Each remote machine can operate as a collector point for more than one type of data. For example remote machine can operate as a collector point for licensing information and for loading information. In these embodiments each collector point may amass a different type of run time data. For example to illustrate this case the remote machine can collect licensing information while the remote machine collects loading information.

In some embodiments each collector point stores data that is shared between all remote machines in a farm . In these embodiments each collector point of a particular type of data exchanges the data collected by that collector point with every other collector point for that type of data in the farm . Thus upon completion of the exchange of such data each collector point and possesses the same data. Also in these embodiments each collector point and also keeps every other collector point abreast of any updates to the runtime data.

Browsing enables a local machine to view farms remote machines and applications in the farms and to access available information such as sessions throughout the farm . Each remote machine includes an ICA browsing subsystem to provide the local machine with browsing capability. After the local machine establishes a connection with the ICA browser subsystem of any of the remote machines that browser subsystem supports a variety of local machine requests. Such local machine requests include 1 enumerating names of remote machines in the farm 2 enumerating names of applications published in the farm 3 resolving a remote machine name and or application name to a remote machine address that is useful the local machine . The ICA browser subsystem also supports requests made by local machines running a program neighborhood application that provides the local machine upon request with a view of those applications within the farm for which the user is authorized. The ICA browser subsystem forwards all of the above mentioned local machine requests to the appropriate subsystem in the remote machine .

In one embodiment each remote machine in the farm that has a program neighborhood subsystem can provide the user of a local machine with a view of applications within the farm . The program neighborhood subsystem may limit the view to those applications for which the user of the local machine has authorization to access. Typically this program neighborhood service presents the applications to the user as a list or a group of icons.

The functionality provided by the program neighborhood subsystem is available to two types of local machines 1 program neighborhood enabled local machines that can access the functionality directly from a local machine desktop and 2 non program neighborhood enabled local machines e.g. legacy local machines that can access the functionality by running a program neighborhood enabled desktop on the remote machine.

Communication between a program neighborhood enabled local machine and the program neighborhood subsystem may occur over a dedicated virtual channel that is established on top of an ICA virtual channel. In other embodiments the communication occurs using an XML service. In one of these embodiments the program neighborhood enabled local machine communicates with an XML subsystem such as the XML service described in connection with below providing program neighborhood functionality on a remote machine .

In one embodiment the program neighborhood enabled local machine does not have a connection with the remote machine with a program neighborhood subsystem . For this embodiment the local machine sends a request to the ICA browser subsystem to establish an ICA connection to the remote machine in order to identify applications available to the local machine . The local machine then runs a client side dialog that acquires the credentials of a user. The credentials are received by the ICA browser subsystem and sent to the program neighborhood subsystem . In one embodiment the program neighborhood subsystem sends the credentials to a user management subsystem for authentication. The user management subsystem may return a set of distinguished names representing the list of accounts to which the user belongs. Upon authentication the program neighborhood subsystem establishes the program neighborhood virtual channel. This channel remains open until the application filtering is complete.

The program neighborhood subsystem then requests the program neighborhood information from the common application subsystem associated with those accounts. The common application subsystem obtains the program neighborhood information from the persistent store . On receiving the program neighborhood information the program neighborhood subsystem formats and returns the program neighborhood information to the local machine over the program neighborhood virtual channel. Then the partial ICA connection is closed.

For another example in which the program neighborhood enabled local machine establishes a partial ICA connection with a remote machine consider the user of the local machine who selects a farm . The selection of the farm sends a request from the local machine to the ICA browser subsystem to establish an ICA connection with one of the remote machines in the selected farm . The ICA browser subsystem sends the request to the program neighborhood subsystem which selects a remote machine in the farm . Address information associated with the remote machine is identified and returned to the local machine by way of the ICA browser subsystem . The local machine can then subsequently connect to the remote machine corresponding to the received address information.

In another embodiment the program neighborhood enabled local machine an ICA connection upon which the program neighborhood virtual channel is established and remains open for as long as the ICA connection persists. Over this program neighborhood virtual channel the program neighborhood subsystem pushes program neighborhood information updates to the local machine . To obtain updates the program neighborhood subsystem subscribes to events from the common application subsystem to allow the program neighborhood subsystem to detect changes to published applications.

Referring to a block diagram depicts another embodiment of a system architecture for providing a plurality of application programs available to the local machine via publishing of GUIs in a web service directory. The system includes the local machine and a plurality of remote machines . One remote machine functions as a content server. A remote machine provides web server functionality. A remote machine provides functionality for providing access to application files and acts as an application server or a file server. The local machine can download content from the content server the web server and the application server over the network . In one embodiment the local machine can download content e.g. an application from the application server over the client application server communication channel .

In one embodiment the web browser on the local machine uses Secure Socket Layer SSL support for communications to the content server and or the web server . SSL is a secure protocol developed by Netscape Communication Corporation of Mountain View Calif. and is now a standard promulgated by the Internet Engineering Task Force IETF . The web browser can alternatively connect to the content server and or the web server using other security protocols such as but not limited to Secure Hypertext Transfer Protocol SHTTP developed by Terisa Systems of Los Altos Calif. HTTP over SSL HTTPS Private Communication Technology PCT developed by Microsoft Corporation of Redmond Wash. and the Transport Level Security TLS standard promulgated by the IETF. In other embodiments the web browser communicates with the servers using a communications protocol without encryption such as the HyperText Transfer Protocol HTTP .

Additionally the local machine includes an application client for establishing and exchanging communications with the application server over the client application server communication channel . In one embodiment the application client is a GUI application. In some embodiments the application client is an Independent Computing Architecture ICA client developed by Citrix Systems Inc. of Fort Lauderdale Fla. and is also referred to below as ICA client . Other embodiments of the application client include a Remote Display Protocol RDP client developed by Microsoft Corporation of Redmond Wash. an X Windows client a client side player interpreter or simulator capable of executing multimedia applications email Java or .NET code. Moreover in one embodiment the output of an application executing on the application server can be displayed at the local machine via the ICA client . In some embodiments the application client is an application client such as the application streaming client described in greater detail in connection with .

The local machine searches the web service directory for a web service. In one embodiment the search is a manual search. Alternatively the search is an automatic search. The web service directory may also provide a service based view such as white and yellow pages to search for web services in the web service directory. In another embodiment the web service directory supports a hierarchical browsing based on a structured service name and service kind for GUI applications. In one embodiment the web service directory executes on a remote machine independent of the content server such as a directory server. In other embodiments the web service directory executes on multiple servers.

In some embodiments the content server enables the local machine to select web services based on additional analysis or information by providing this information or analysis in the web service directory . Examples of service information that the web service directory can list includes but is not limited to the name of the business offering the service the service type a textual description of the service one or more service access points SAPs the network type the path to use e.g. TCP or HTTPS and quality of service QoS information. Moreover service information can be client device type or user e.g. role specific. Thus service selection can be based on one or more of the above attributes.

In one embodiment the service type denotes a programming interface that the local machine may use to access the web service. For instance the service type can state that the service is encoded by an interface description language such as Web Services Description Language WSDL .

The service access point or SAP is a unique address for an application. The SAPs enable the computer system to support multiple applications at the local machine and each remote machine . For example the application server may support an electronic mail i.e. e mail application a file transfer application and or a GUI application. In one embodiment these applications would each have a SAP that is unique within the application server . In one embodiment the SAP is a web or Internet address e.g. Domain Name System DNS name IP port or Uniform Resource Locator URL . Thus in one embodiment the SAP identifies the address of the web server as part of the address for an application stored on the web server . In some embodiments the SAP identifies the address of a publishing server plug in as part of the address for an application stored on the web server as described below. In one embodiment the SAP is an accessPoint from the UDDI registry.

To prepare an item for publishing in the web service directory the content server includes a web publishing tool . In one embodiment the web publishing tool is a software module. Alternatively the web publishing tool is another server that may be externally located from or internally located in the content server .

In one embodiment the web server delivers web pages to the local machine . The web server can be any remote machine capable of providing web pages to the local machine . In another embodiment the web server is an Enterprise Information Portal e.g. corporate Intranet or secured business to business extranet . Enterprise portals are company web sites that aggregate personalize and serve applications data and content to users while offering management tools for organizing and using information more efficiently. In some companies portals have replaced traditional desktop software with browser based access to a virtual workplace.

The web server also includes a publishing server plug in to enable the publishing of graphical user interface GUI applications. More specifically the publishing server plug in translates a new web service entry URL into a GUI application service so that the GUI can be accessed via the web service directory . In one embodiment the publishing server plug in is a Common Gateway Interface CGI script which is a program designed to accept and return data that conforms to the CGI specification. The program can be written in any programming language such as C Perl Java or Visual Basic. In another embodiment the publishing server plug in is a Java Server Page JSP . Using the publishing server plug in to facilitate the publishing of remote GUI applications the local machine can thereby access the web service not through a programming interface or a web page but through a full GUI interface such as with Citrix s ICA or Microsoft s RDP.

The application server hosts one or more applications that are available for the local machine . Examples of such applications include word processing programs such as MICROSOFT WORD and spreadsheet programs such as MICROSOFT EXCEL both manufactured by Microsoft Corporation of Redmond Wash. financial reporting programs customer registration programs programs providing technical support information customer database applications or application set managers.

In some embodiments one or more communication links are established over different networks. For example the client content server communication channel can belong to a first network e.g. the World Wide Web and the client web server communication channel can belong to a second network e.g. a secured extranet or Virtual Private Network VPN .

In one embodiment the web publishing tool stores information about an application that the web publishing tool is publishing in the web service directory in a persistent mass storage . In one embodiment the information is a URL for the dynamic publishing server plug in . The persistent mass storage may be a magnetic disk or magneto optical drive. In one embodiment the persistent mass storage is a database server which stores data related to the published application in one or more local service databases. The persistent mass storage may be a component internally located in or externally located from any or all of the remote machines .

In other embodiments the content server or the web server communicate with a remote machine in the farm to retrieve the list of applications. In one of these embodiments the content server or the web server communicate with the farm instead of with the persistent mass storage .

Referring now to a flow diagram depicts one embodiment of the steps taken to select a method of execution of an application program. In brief overview credentials associated with the local machine or with a user of the local machine are received with a request for an enumeration of applications available for execution by the local machine step . An enumeration of a plurality of application programs available to the local machine is provided responsive to the received credentials step . A request is received to execute an enumerated application step . One of a predetermined number of methods for executing the enumerated application is selected responsive to a policy the predetermined number of methods including a method for application streaming of the enumerated application step .

Credentials associated with the local machine or with a user of the local machine are received with a request for an enumeration of applications available for execution by the local machine step . In one embodiment the remote machine receives a request for enumeration of available applications from the local machine with the credentials. In another embodiment an XML service on the remote machine receives the request and the credentials and transmits the request and credentials to a management service on the remote machine .

In some embodiments a remote machine functioning as a web server receives communications from the local machine and forwards the communications to a remote machine . In one of these embodiments the web server forwards the communications to an XML service on the remote machine . In another of these embodiments the web server resides on the local machine. In other embodiments where communications from the local machine are routed to a remote machine by the web server the remote machine may be selected responsive to an Internet Protocol IP address of the local machine .

In some embodiments a local machine requests access to an application residing on a remote machine . In one of these embodiments the local machine requests execution by the remote machine of the application residing on the remote machine . In another of these embodiments the local machine requests retrieval of a plurality of application files that comprise the application.

In some embodiments the user provides credentials to the remote machine via a graphical user interface presented to the local machine by the remote machine . In other embodiments a remote machine having the functionality of a web server provides the graphical user interface to the local machine . In still other embodiments a collection agent transmitted to the local machine by the remote machine gathers the credentials from the local machine . In one embodiment a credential refers to a username and password. In another embodiment a credential is not limited to a username and password but includes without limitation a machine ID of the local machine operating system type existence of a patch to an operating system MAC addresses of installed network cards a digital watermark on the client device membership in an Active Directory existence of a virus scanner existence of a personal firewall an HTTP header browser type device type network connection information such as internet protocol address or range of addresses machine ID of the remote machine date or time of access request including adjustments for varying time zones and authorization credentials.

In some embodiments a credential associated with a local machine is associated with a user of the local machine. In one of these embodiments the credential is information possessed by the user. In another of these embodiments the credential is user authentication information. In other embodiments a credential associated with a local machine is associated with a network. In one of these embodiments the credential is information associated with a network to which the local machine may connect. In another of these embodiments the credential is information associated with a network collecting information about the local machine. In still other embodiments a credential associated with a local machine is a characteristic of the local machine.

An enumeration of a plurality of application programs available to the local machine is provided responsive to the received credentials step . In one embodiment a user of a local machine may learn of the availability of application programs hosted by the remote machines in the network without knowing where to find such applications and without technical information necessary to link to such applications. These available application programs comprise the program neighborhood of the user. A system for determining a program neighborhood for a local machine includes an application program hereafter referred to as the Program Neighborhood application memory for storing components of the application program and a processor for executing the application program. The Program Neighborhood PN application can be installed in memory of the local machine and or on a remote machine as described below.

A remote machine operating according to the Program Neighborhood application collects application related information from each of the remote machines in a farm . The application related information for each hosted application can be a variety of information including for example an address of the remote machine hosting that application the application name the users or groups of users who are authorized to use that application and the minimum capabilities required of the local machine before establishing a connection to run the application. For example the application may stream video data and therefore a required minimum capability may be that the local machine supports video data. Other examples are requirements that the local machine support audio data or have the capacity to process encrypted data. The application related information can be stored in a database.

When a local machine connects to the network the user of the local machine provides user credentials. User credentials may include the username of a user of the local machine the password of the user and the domain name for which the user is authorized. Alternatively the user credentials may be obtained from smart cards time based tokens social security numbers user passwords personal identification PIN numbers digital certificates based on symmetric key or elliptic curve cryptography biometric characteristics of the user or any other means by which the identification of the user of the local machine can be obtained and submitted for authentication. The remote machine responding to the local machine can authenticate the user based on the user credentials. The user credentials can be stored wherever the Program Neighborhood application is executing. For embodiments in which the local machine executes the Program Neighborhood application the user credentials may be stored at the local machine . For embodiments in which a remote machine executes the Program Neighborhood the user credentials can be stored at that remote machine .

From the user credentials and the application related information the remote machine can also determine which application programs hosted by remote machines are available for use by the user of the local machine . The remote machine transmits information representing the available application programs to the local machine . This process eliminates the need for a user of the local machine to establish application connections. Additionally an administrator of the remote machine may control access to applications among multiple users of a local machine .

In some embodiments the user authentication performed by the remote machine may suffice to authorize the use of each hosted application program presented to the local machine although such applications may reside at another remote machine . Accordingly when the local machine launches i.e. initiates execution of one of the hosted applications additional input of user credentials by the local machine may be unnecessary to authenticate use of that application. Thus a single entry of the user credentials may serve to determine the available applications and to authorize the launching of such applications without an additional manual log on authentication process by the user.

Either a local machine or remote machine can launch the Program Neighborhood application. The results are displayed on the display screen of the local machine . In a graphical windows based implementation the results can be displayed in a Program Neighborhood graphical window and each authorized application program can be represented by a graphical icon in that window.

In one embodiment the Program Neighborhood application filters out application programs that the local machine is unauthorized to execute and displays only authorized i.e. available programs. In other embodiments the Program Neighborhood application can display authorized and unauthorized applications. When unauthorized applications are not filtered from the display a notice can be provided indicating that such applications are unavailable. Alternatively the Program Neighborhood application can report all applications hosted by the remote machines to the user of a local machine without identifying which applications the local machine is authorized or unauthorized to execute. Authorization can be subsequently determined when the local machine attempts to run one of those applications.

The local machine may request application enumeration from a remote machine . Application enumeration enables a user of the local machine to view the names of every published application. In one embodiment the user of the local machine can view the application names regardless of whether the user has authorization to execute the application. In another embodiment the user views only those application names that the user is authorized to execute.

Requests for application enumeration pass to the ICA browser subsystem to the program neighborhood subsystem or to a common application subsystem depending upon the particular process being run by the local machine . For example when the local machine is running program neighborhood application the requests for application enumeration are sent to the program neighborhood subsystem on a remote machine . When the local machine submits the enumeration request through a web page the requests pass to the common access point subsystem . For these embodiments the common application subsystem serves as an initial access point for the program neighborhood subsystem ICA browser subsystem and common application subsystems when the local machine wants to enumerate applications. In some embodiments when the local machine submits the enumeration request through a web page an intermediate remote machine hosting a web server receives the request and forwards the request to a remote machine .

Upon receiving the enumeration requests a common application subsystem queries the persistent store for a list of all applications. For requests received from the program neighborhood subsystem and common access point subsystems this list of applications is filtered according to the credentials of the user of the local machine i.e. the user views only those applications for which the user is authorized .

The local machine can also request remote machine enumeration. Remote machine enumeration enables a user of the local machine to view a list of remote machines in the farm . In one embodiment the list of remote machines can be filtered according to the type of remote machine as determined by the specialized remote machine subsystem on that remote machine.

Requests for remote machine enumeration pass to the ICA browser subsystem or to the common access point subsystem depending upon the particular process being run by the local machine . For example when the local machine submits the remote machine enumeration request through a web page the requests pass to the common access point subsystem . For these embodiments the common remote machine subsystem serves as an initial access point for the ICA browser subsystem and common access point subsystems. Upon receiving the remote machine enumeration requests the common remote machine subsystem queries the persistent store for a list of all remote machines. Optionally the list of remote machines is filtered according to the remote machine type.

The local machine via the web browser transmits a request to access a Uniform Resource Locator URL address corresponding to an HTML page residing on remote machine . In some embodiments the first HTML page returned to the local machine by the remote machine is an authentication page that seeks to identify the local machine .

Still referring to once the local machine is authenticated by the remote machine the remote machine prepares and transmits to the local machine an HTML page that includes a Program Neighborhood window in which appears graphical icons representing application programs to which the local machine has access. A user of local machine invokes execution of an application represented by icon by clicking that icon .

In some embodiments the remote machine executes the Program Neighborhood application on behalf of a user of the local machine . In one of these embodiments the remote machine is an intermediate remote machine residing between the local machine and a remote machine .

Referring to a flow diagram depicts one embodiment of the steps taken to provide a plurality of application programs available to the local machine via publishing of GUIs in a web service directory. The web publishing tool receives a web service description and access information for an application e.g. GUI application for publishing step . In one embodiment the web service description includes the service information described above e.g. the name of the business offering the web service the service type a textual description of the service and a SAP . The access information may include for example a published application name a Transmission Control Protocol TCP browsing server farm address and a MetaFrame server IP address. In some embodiments the access information specifies the address to use and a ticket to use to traverse network or security gateways or bridge devices.

The web publishing tool then constructs a service publishing request to request the publication of the web service i.e. GUI application step . In one embodiment the service publishing request includes a SAP. In some embodiments the SAP is a URL including the web address of the web server and the publishing server plug in . Further the web address can be a Uniform Resource Identifier URI which is the generic term for the types of names and addresses that refer to objects on the web. A URL is one kind of URI. An example of the URI is the name of the web server e.g. web server and the CGI script name e.g. dynamic component for the publishing server plug in .

The web publishing tool stores a SAP entry associated with the SAP in the persistent mass storage step . In some embodiments the web publishing tool also associates published application information e.g. ICA published app info with the GUI application. In further embodiments the web publishing tool also includes a key in the service publishing request to identify the SAP entry that the content server stores in the persistent mass storage . For instance the key can have the value of 123456677. An example of a SAP identifying the web server the CGI script name of the publishing server plug in and the key described above is http web server dynamic component app 123456677. 

An example of the SAP entry associated with the SAP described above is key 123456677 value ICA published app info. The key can be any length e.g. 56 bit key 128 bit key . In one embodiment the key is a cryptographic random number. The key may also provides an access right to the key holder. Although illustrated with a key any means can be used to provide a form of security to the SAP entry stored in the persistent mass storage .

The web publishing tool provides the service publishing request to the content server for publishing in the web service directory step . Moreover in one embodiment the content server transmits the key of the SAP to the local machine requesting the particular web service for subsequent use in locating the SAP entry. In one embodiment the publishing of the service publishing request enables users of the local machine to access the service. In one embodiment GUI applications are published on the web service directory using NFUSE developed by Citrix Systems Inc. of Fort Lauderdale Fla. In some embodiments a publisher of a GUI application customizes the publication of the GUI application on the web service directory using Application Launching And Embedding ALE also developed by Citrix Systems Inc. ALE enables the launching of a GUI application from or the embedding of the application into an HTML page.

The local machine then queries a service name from the web service directory step . The content server receives the query from the local machine step and finds the requested service name in the web service directory . In another embodiment the user of the local machine navigates the web service directory until locating a particular service name that the user of the local machine was attempting to find. Although illustrated with the local machine any web service directory client e.g. UDDI client or LDAP browser can query or navigate the web service directory to discover published web services.

Upon location of the SAP associated with the received query the content server transmits the SAP to the local machine step . The local machine receives the SAP step and determines the address of the publishing server plug in from the SAP. The local machine subsequently transmits a request for the GUI application to the web server step . In some embodiments the request from the local machine is an HTTP request transmitted from the web browser to the web server . In other embodiments an application e.g. general directory browser or HTML UI executing on the local machine receives the SAP from the content server and provides the SAP as an argument to the web browser . The web browser may then automatically transmit an HTTP request for the GUI application to the web server . Following along the lines of the previous examples a particular example of the application request to the web server is http web server dynamic component app 123456677 .

The web server and more particularly the publishing server plug in receives the application request associated the SAP step and determines the SAP entry associated with the request step . In one embodiment the publishing server plug in receives the request from the local machine and retrieves the published application information associated with the request that had been stored as part of the SAP entry in the persistent mass storage . In some embodiments the publishing server plug in uses the SAP or part of the SAP that the local machine received from the content server as the key to access the proper service entry e.g. the published application information stored in the persistent mass storage .

The publishing server plug in then constructs a file or document having the published application information e.g. HTTP address of the application server step and transmits this document to the local machine step . The publishing server plug in constructs the file so that the file has a format compatible with the application client . In one embodiment the document is a Multipurpose Internet Mail Extensions MIME or a secure MIME S MIME document. In another embodiment the document is an HTML document containing an ICA web client embedded object HTML tag. In still another embodiment the document is an HTML document containing an application streaming client embedded object HTML tag.

The web browser subsequently receives the document and attempts to open the document. In one embodiment if the application client is not installed on the local machine the local machine communicates with the application server to download and install the application client . Upon installation of the application client or alternatively if the application client has already been installed on the local machine the local machine launches the application client to view the document received from the web server step .

Once the application client is installed and executing on the local machine the application server then executes the application and displays the application on the application client step . In an alternative embodiment the application server transmits a plurality of application files comprising the application to the application client for execution on the local machine as described in further detail below in connection with . In another embodiment the local machine views the document even before launching the application client and uses the information in the document to obtain the GUI application from the application server . In this embodiment the display of the GUI application includes the installation and execution of the application client . Moreover the viewing of the document may be transparent to the user of the local machine . For example the local machine may receive the document from the web server and interpret the document before automatically requesting the GUI application from the application server .

Thus the application client provides service based access to published applications desktops desktop documents and any other application that is supported by the application client . Examples of applications that the application client can provide access to include but are not limited to the WINDOWS desktops WINDOWS documents such as MICROSOFT EXCEL WORD and POWERPOINT all of which were developed by Microsoft Corporation of Redmond Wash. Unix desktops such as SUN SOLARIS developed by Sun Microsystems of Palo Alto Calif. and GNU Linux distributed by Red Hat Inc. of Durham N.C. among others.

In some embodiments an enumeration of a plurality of application programs available to the local machine is provided step responsive to a determination by a policy engine regarding whether and how a local machine may access an application. The policy engine may collect information about the local machine prior to making the determination. Referring now to one embodiment of a computer network constructed in accordance with the invention is depicted which includes a local machine a collection agent a policy engine a policy database a farm and an application server . In one embodiment the policy engine is a remote machine . In another embodiment the application server is a remote machine . Although only one local machine collection agent policy engine farm and application server are depicted in the embodiment shown in it should be understood that the system may provide multiple ones of any or each of those components.

In brief overview when the local machine transmits a request to the policy engine for access to an application the collection agent communicates with local machine retrieving information about the local machine and transmits the local machine information to the policy engine . The policy engine makes an access control decision by applying a policy from the policy database to the received information .

In more detail the local machine transmits a request for a resource to the policy engine . In one embodiment the policy engine resides on an application server . In another embodiment the policy engine is a remote machine . In still another embodiment an application server receives the request from the local machine and transmits the request to the policy engine . In yet another embodiment the local machine transmits a request for a resource to a remote machine which transmits the request to the policy engine .

In some embodiments the local machine transmits the request over a network connection. The network can be a local area network LAN a metropolitan area network MAN or a wide area network WAN such as the Internet. The local machine and the policy engine may connect to a network through a variety of connections including standard telephone lines LAN or WAN links e.g. T1 T3 56 kb X.25 broadband connections ISDN Frame Relay ATM and wireless connections. Connections between the local machine and the policy engine may use a variety of data link layer communication protocols e.g. TCP IP IPX SPX NetBIOS NetBEUI SMB Ethernet ARCNET Fiber Distributed Data Interface FDDI RS232 IEEE 802.11 IEEE 802.11a IEE 802.11b IEEE 802.11 g and direct asynchronous connections . The connection may also be a communications link as described above.

Upon receiving the request the policy engine initiates information gathering by the collection agent . The collection agent gathers information regarding the local machine and transmits the information to the policy engine .

In some embodiments the collection agent gathers and transmits the information over a network connection. In some embodiments the collection agent comprises bytecode such as an application written in the bytecode programming language JAVA. In some embodiments the collection agent comprises at least one script. In those embodiments the collection agent gathers information by running at least one script on the local machine . In some embodiments the collection agent comprises an Active X control on the local machine . An Active X control is a specialized Component Object Model COM object that implements a set of interfaces that enable it to look and act like a control.

In one embodiment the policy engine transmits the collection agent to the local machine . In one embodiment the policy engine requires a second execution of the collection agent after the collection agent has transmitted information to the policy engine . In this embodiment the policy engine may have insufficient information to determine whether the local machine satisfies a particular condition. In other embodiments the policy engine requires a plurality of executions of the collection agent in response to received information .

In some embodiments the policy engine transmits instructions to the collection agent determining the type of information the collection agent gathers. In those embodiments a system administrator may configure the instructions transmitted to the collection agent from the policy engine . This provides greater control over the type of information collected. This also expands the types of access control decisions that the policy engine can make due to the greater control over the type of information collected. The collection agent gathers information including without limitation machine ID of the local machine operating system type existence of a patch to an operating system MAC addresses of installed network cards a digital watermark on the client device membership in an Active Directory existence of a virus scanner existence of a personal firewall an HTTP header browser type device type network connection information such as internet protocol address or range of addresses machine ID of the remote machine date or time of access request including adjustments for varying time zones and authorization credentials.

In some embodiments the device type is a personal digital assistant. In other embodiments the device type is a cellular telephone. In other embodiments the device type is a laptop computer. In other embodiments the device type is a desktop computer. In other embodiments the device type is an Internet kiosk.

In some embodiments the digital watermark includes data embedding. In some embodiments the watermark comprises a pattern of data inserted into a file to provide source information about the file. In other embodiments the watermark comprises data hashing files to provide tamper detection. In other embodiments the watermark provides copyright information about the file.

In some embodiments the network connection information pertains to bandwidth capabilities. In other embodiments the network connection information pertains to Internet Protocol address. In still other embodiments the network connection information consists of an Internet Protocol address. In one embodiment the network connection information comprises a network zone identifying the logon agent to which the local machine provided authentication credentials.

In some embodiments the authorization credentials include a number of types of authentication information including without limitation user names client names client addresses passwords PINs voice samples one time passcodes biometric data digital certificates tickets etc. and combinations thereof. After receiving the gathered information the policy engine makes an access control decision based on the received information .

Referring now to a block diagram depicts one embodiment of a policy engine including a first component comprising a condition database and a logon agent and including a second component comprising a policy database . The first component applies a condition from the condition database to information received about local machine and determines whether the received information satisfies the condition.

In some embodiments a condition may require that the local machine execute a particular operating system to satisfy the condition. In some embodiments a condition may require that the local machine execute a particular operating system patch to satisfy the condition. In still other embodiments a condition may require that the local machine provide a MAC address for each installed network card to satisfy the condition. In some embodiments a condition may require that the local machine indicate membership in a particular Active Directory to satisfy the condition. In another embodiment a condition may require that the local machine execute a virus scanner to satisfy the condition. In other embodiments a condition may require that the local machine execute a personal firewall to satisfy the condition. In some embodiments a condition may require that the local machine comprise a particular device type to satisfy the condition. In other embodiments a condition may require that the local machine establish a particular type of network connection to satisfy the condition.

If the received information satisfies a condition the first component stores an identifier for that condition in a data set . In one embodiment the received information satisfies a condition if the information makes the condition true. For example a condition may require that a particular operating system be installed. If the local machine has that operating system the condition is true and satisfied. In another embodiment the received information satisfies a condition if the information makes the condition false. For example a condition may address whether spyware exists on the local machine . If the local machine does not contain spyware the condition is false and satisfied.

In some embodiments the logon agent resides outside of the policy engine . In other embodiments the logon agent resides on the policy engine . In one embodiment the first component includes a logon agent which initiates the information gathering about local machine . In some embodiments the logon agent further comprises a data store. In these embodiments the data store includes the conditions for which the collection agent may gather information. This data store is distinct from the condition database .

In some embodiments the logon agent initiates information gathering by executing the collection agent . In other embodiments the logon agent initiates information gathering by transmitting the collection agent to the local machine for execution on the local machine . In still other embodiments the logon agent initiates additional information gathering after receiving information . In one embodiment the logon agent also receives the information . In this embodiment the logon agent generates the data set based upon the received information . In some embodiments the logon agent generates the data set by applying a condition from the database to the information received from the collection agent .

In another embodiment the first component includes a plurality of logon agents . In this embodiment at least one of the plurality of logon agents resides on each network domain from which a local machine may transmit a resource request. In this embodiment the local machine transmits the resource request to a particular logon agent . In some embodiments the logon agent transmits to the policy engine the network domain from which the local machine accessed the logon agent . In one embodiment the network domain from which the local machine accesses a logon agent is referred to as the network zone of the local machine .

The condition database stores the conditions that the first component applies to received information. The policy database stores the policies that the second component applies to the received data set . In some embodiments the condition database and the policy database store data in an ODBC compliant database. For example the condition database and the policy database may be provided as an ORACLE database manufactured by Oracle Corporation of Redwood Shores Calif. In other embodiments the condition database and the policy database can be a Microsoft ACCESS database or a Microsoft SQL server database manufactured by Microsoft Corporation of Redmond Wash.

After the first component applies the received information to each condition in the condition database the first component transmits the data set to second component . In one embodiment the first component transmits only the data set to the second component . Therefore in this embodiment the second component does not receive information only identifiers for satisfied conditions. The second component receives the data set and makes an access control decision by applying a policy from the policy database based upon the conditions identified within data set .

In one embodiment policy database stores the policies applied to the received information . In one embodiment the policies stored in the policy database are specified at least in part by the system administrator. In another embodiment a user specifies at least some of the policies stored in the policy database . The user specified policy or policies are stored as preferences. The policy database can be stored in volatile or non volatile memory or for example distributed through multiple servers.

In one embodiment a policy allows access to a resource only if one or more conditions are satisfied. In another embodiment a policy allows access to a resource but prohibits transmission of the resource to the local machine . Another policy might make connection contingent on the local machine that requests access being within a secure network. In some embodiments the resource is an application program and the local machine has requested execution of the application program. In one of these embodiments a policy may allow execution of the application program on the local machine . In another of these embodiments a policy may enable the local machine to receive a stream of files comprising the application program. In this embodiment the stream of files may be stored and executed in an isolation environment. In still another of these embodiments a policy may allow only execution of the application program on a remote machine such as an application server and require the remote machine to transmit application output data to the local machine .

Referring now to a flow diagram depicts one embodiment of the steps taken by the policy engine to make an access control decision based upon information received about a local machine . Upon receiving gathered information about the local machine Step the policy engine generates a data set based upon the information Step . The data set contains identifiers for each condition satisfied by the received information . The policy engine applies a policy to each identified condition within the data set . That application yields an enumeration of resources which the local machine may access Step . The policy engine then presents that enumeration to the local machine . In some embodiments the policy engine creates a Hypertext Markup Language HTML document used to present the enumeration to the local machine.

Referring to one embodiment of a network constructed in accordance with the invention is depicted which includes a local machine a collection agent a policy engine a policy database a condition database a local machine a session server a stored application database a remote machine a first database a remote machine and a second database . In brief overview when the local machine transmits to the access control server a request for access to an application program the collection agent communicates with local machine retrieves information about local machine and transmits local machine information to the policy engine . The policy engine makes an access control decision as discussed above in and . The local machine receives an enumeration of available applications associated with the local machine .

In some embodiments the session server establishes a connection between the local machine and a plurality of application sessions associated with the local machine . In other embodiments the policy engine determines that the local machine has authorization to retrieve a plurality of application files comprising the application and to execute the application program locally. In one of these embodiments the remote machine stores application session data and a plurality of application files comprising the application program. In another of these embodiments the local machine establishes an application streaming session with a remote machine storing the application session data and the plurality of application files comprising the application program.

Referring now to a flow diagram depicts one embodiment of the steps taken by the session server to provide access for the local machine to its associated application sessions. The session server receives information about the local machine from the policy engine containing access control decision the policy engine made step . The session server generates an enumeration of associated applications step . The session server may connect the local machine to an associated application step . In one embodiment the information also includes the local machine information . In another embodiment the information includes authorization to execute the application program locally.

The session server generates an enumeration of associated applications step . In some embodiments the policy engine identifies a plurality of application sessions already associated with the local machine . In other embodiments the session server identifies stored application sessions associated with the local machine . In some of these embodiments the session server automatically identifies the stored application sessions upon receiving the information from the policy engine . In one embodiment the stored application database resides on the session server . In another embodiment the stored application database resides on the policy engine .

The stored application database contains data associated with a plurality of remote machines in the farm executing application sessions or providing access to application session data and application files comprising application programs. In some embodiments identifying the application sessions associated with the local machine requires consulting stored data associated with one or more remote machines. In some of these embodiments the session store consults the stored data associated with one or more remote machines. In others of these embodiments the policy engine consults the stored data associated with one or more remote machines. In some embodiments a first application session runs on a remote machine and a second application session runs on a remote machine . In other embodiments all application sessions run on a single remote machine within the farm .

The session server includes information related to application sessions initiated by users. The session server can be stored in volatile or non volatile memory or for example distributed through multiple servers. Table 1 shows the data included in a portion of an illustrative session server 

The illustrative session server in Table 1 includes data associating each application session with the user that initiated the application session an identification of the client computer or if any from which the user is currently connected to the remote machine and the IP address of that client computer or . The illustrative session server also includes the status of each application session. An application session status can be for example active meaning a user is connected to the application session or disconnected meaning a user is not connected to the application session . In an alternative embodiment an application session status can also be set to executing disconnected meaning the user has disconnected from the application session but the applications in the application session are still executing or stalled disconnected meaning the user is disconnected and the applications in the application session are not executing but their operational state immediately prior to the disconnection has been stored . The session server further stores information indicating the applications that are executing within each application session and data indicating each application s process on the server. In embodiments in which the remote machine is part of the farm the session server is at least a part of the dynamic store and also includes the data in the last two rows of Table 1 that indicate on which remote machine in the farm each application is was executing and the IP address of that remote machine . In alternative embodiments the session server includes a status indicator for each application in each application session.

For example in the example of Table 1 three application sessions exist App Session 1 App Session 2 and App Session 3. App Session 1 is associated with User 1 who is currently using terminal 1. Terminal one s IP address is 152.16.2.50. The status of App Session 1 is active and in App Session 1 a word processing program is being executed. The word processing program is executing on Server A as process number 1. Server A s IP address is 152.16.2.55. App Session 2 in Table 1 is an example of a disconnected application session . App Session 2 is associated with User 2 but App Session 2 is not connected to a local machine or . App Session 2 includes a database program that is executing on Server A at IP address 152.16.2.55 as process number 3. App Session 3 is an example of how a user can interact with application sessions operating on different remote machines . App Session 3 is associated with User 1 as is App Session 1. App Session 3 includes a spreadsheet program that is executing on Server B at IP address 152.16.2.56 as process number 2 whereas the application session included in App Session 1 is executing on Server A.

In another example a user may access a first application program through an application session executing on a remote machine such as Server A while communicating across an application streaming session with a second remote machine such as Server B to retrieve a second application program from the second remote machine for local execution. The user of the local machine may have acquired authorization to execute the second application program locally while failing to satisfy the execution pre requisites of the first application program.

In one embodiment the session server is configured to receive a disconnect request to disconnect the application sessions associated with the local machine and disconnects the application sessions in response to the request. The session server continues to execute an application session after disconnecting the local machine from the application session. In this embodiment the session server accesses the stored application database and updates a data record associated with each disconnected application session so that the record indicates that the application session associated with the local machine is disconnected.

After receiving authentication information associated with a local machine connecting to the network the session server consults the stored applications database to identify any active application sessions that are associated with a user of the local machine but that are connected to a different local machine such as the local machine if the authentication information is associated with local machine for example. In one embodiment if the session server identifies any such active application sessions the session server automatically disconnects the application session s from the local machine and connects the application session s to the current local machine . In some embodiments the received authentication information will restrict the application sessions to which the local machine may reconnect. In other embodiments the received authentication information authorizes execution of an application program on the local machine where the authorization may have been denied to local machine . In one of these embodiments the session server may provide the local machine access information for retrieving the application program for local execution.

A request is received to execute an enumerated application step . In one embodiment a user of the local machine selects an application for execution from a received enumeration of available applications. In another embodiment the user selects an application for execution independent of the received enumeration. In some embodiments the user selects an application for execution by selecting a graphical representation of the application presented on the local machine by a client agent. In other embodiments the user selects an application for execution by selecting a graphical representation of the application presented to the user on a web server or other remote machine .

In still other embodiments the user requests access a file. In one of these embodiments execution of an application is required to provide the user with access to the file. In another of these embodiments the application is automatically selected for execution upon selection of the file for access. In still another of these embodiments prior to the request for access to the file the application is associated with a type of file enabling automatic selection of the application upon identification of a type of file associated with the requested file.

In one embodiment the enumerated application comprises a plurality of application files. In some embodiments the plurality of application files reside on the remote machine . In other embodiments the plurality of application files reside on a separate file server or remote machine . In still other embodiments the plurality of application files may be transmitted to a local machine . In yet other embodiments a file in the plurality of application files may be executed prior to transmission of a second file in the plurality of application files to the local machine .

In some embodiments the remote machine retrieves information about the enumerated application from a remote machine . In one of these embodiments the remote machine receives an identification of a remote machine hosting a plurality of application files. In another of these embodiments the remote machine receives identification of a location of a plurality of application files the identification conforming to a Universal Naming Convention UNC . In still another of these embodiments the identification includes a network location and a socket for an application streaming protocol.

In one embodiment the remote machine retrieves a file containing information about the enumerated application. The file may include an identification of a location of a server hosting the enumerated application. The file may include an identification of a plurality of versions of the enumerated application. The file may include an enumeration of a plurality of application files comprising the enumerated application. The file may include an identification of a compressed file comprising a plurality of applications files comprising the enumerated application. The file may include an identification of pre requisites to be satisfied by a machine executing the enumerated application. The file may include an enumeration of data files associated with the enumerated application. The file may include an enumeration of scripts to be executed on a machine executing the enumerated application. The file may include an enumeration of registry data associated with the enumerated application. The file may include an enumeration of rules for use in an embodiment where the enumerated application executes within an isolation environment. In one embodiment the file may be referred to as a manifest file. The information that the file may contain is described in further detail in connection with below.

In some embodiments the remote machine applies a policy to an identified characteristic of the local machine . In one of these embodiments the remote machine identifies a version of the enumerated application for execution responsive to the identified characteristic. In another of these embodiments the remote machine makes a determination to execute a version of the enumerated application compatible with a characteristic of the local machine . In still another of these embodiments the remote machine makes a determination to execute a version of the enumerated application compatible with an operating system executing on the local machine . In yet another of these embodiments the remote machine makes a determination to execute a version of the enumerated application compatible with a revision level of an operating system on the local machine . In one of these embodiments the remote machine makes a determination to execute a version of the enumerated application compatible with a language specified by an operating system on the local machine .

One of a predetermined number of methods for executing the enumerated application is selected responsive to a policy the predetermined number of methods including a method for application streaming of the enumerated application step . In one embodiment the selection is made responsive to an application of a policy to the received credentials associated with the local machine . In some embodiments the selection is made by a policy engine such as the policy engine described above in and . In other embodiments the remote machine receiving the credentials and the request to execute the enumerated application further comprises such a policy engine .

In one embodiment the predetermined number of methods includes a method for executing the enumerated application on a remote machine . In another embodiment the predetermined number of methods includes a method for executing the enumerated application on the local machine . In still another embodiment the predetermined number of methods includes a method for executing the enumerated application on a second remote machine .

In some embodiments the predetermined number of methods includes a method for providing the enumerated application to the local machine across an application streaming session. In one of these embodiments the local machine comprises a streaming service agent capable of initiating a connection with a remote machine and receiving from the remote machine a stream of transmitted data packets.

The stream of data packets may include application files comprising the enumerated application. In some embodiments application files include data files associated with an application program. In other embodiments application files include executable files required for execution of the application program. In still other embodiments the application files include metadata including information about the files such as location compatibility requirements configuration data registry data identification of execution scripts rules for use in isolation environments or authorization requirements.

In some embodiments the streamed application executes prior to the transmission of each application file in a plurality of application files comprising the streamed application. In one of these embodiments execution of the streamed application begins upon receipt by a local machine of one application file in the plurality of applications. In another of these embodiments execution of the streamed application begins upon receipt by a local machine of an executable application file in the plurality of application files. In still another of these embodiments the local machine executes a first received application file in a plurality of application files and the first received application file requests access to a second application file in the plurality of application files.

In one embodiment the streamed application executes on the local machine without permanently residing on the local machine . In this embodiment the streamed application may execute on the local machine and be removed from the local machine upon termination of the streamed application. In another embodiment the streamed application executes on the local machine after a pre deployed copy of each application file is stored on the local machine . In still another embodiment the streamed application executes on the local machine after a copy of each application file is stored in an isolation environment on the local machine. In yet another embodiment the streamed application executes on the local machine after a copy of each application file is stored in a cache on the local machine .

In one embodiment the method for streaming the application to the local machine is selected from the predetermined number of methods responsive to a determination that the local machine may receive the streamed application files. In another embodiment the method for streaming the application to the local machine is selected from the predetermined number of methods responsive to a determination that the local machine has authority to execute the streamed application files locally.

In other embodiments the predetermined number of methods includes a method for providing application output data to the local machine the application output data generated from an execution of the enumerated application on a remote machine . In one of these embodiments the remote machine is the remote machine receiving the request for execution of the enumerated application. In another of these embodiments the remote machine is a second remote machine such as a file server or an application server. In some embodiments the enumerated application resides on the remote machine executing the enumerated application. In other embodiments the remote machine executing the enumerated application first receives the enumerated application from a second remote machine across an application streaming session. In one of these embodiments the remote machine comprises a streaming service agent capable of initiating a connection with a second remote machine and receiving from the second remote machine a stream of transmitted data. In another of these embodiments the second remote machine may be identified using a load balancing technique. In still another of these embodiments the second remote machine may be identified based upon proximity to the remote machine . These embodiments will be described in greater detail in connection with below.

In some embodiments the remote machine selects from the predetermined number of methods for executing the enumerated application a method for streaming the enumerated application to the remote machine executing the enumerated application on the remote machine and providing to the local machine application output data generated by the execution of the enumerated application. In one of these embodiments the remote machine selects the method responsive to an evaluation of the local machine . In another of these embodiments the determination is made responsive to an application of a policy to the evaluation of the local machine . In still another of these embodiments the determination is made responsive to an evaluation of the received credentials. In one embodiment the remote machine receives a plurality of application files comprising the enumerated application. In another embodiment the remote machine provides the application output data via a presentation level protocol such as an ICA presentation level protocol or a Remote Desktop Windows presentation level protocol or an X Windows presentation level protocol.

In some embodiments the remote machine also provides access information associated with the enumerated application the access information generated responsive to the selected method. In one of these embodiments the access information provides an indication to the local machine of the selected method for execution of the enumerated application program. In another of these embodiments the access information includes an identification of a location of the enumerated application the identification conforming to a Universal Naming Convention UNC . In still another of these embodiments the access information includes an identification of a session management server.

In some embodiments the access information includes a launch ticket comprising authentication information. In one of these embodiments the local machine may use the launch ticket to authenticate the access information received from the remote machine . In another of these embodiments the local machine may use the launch ticket to authenticate itself to a second remote machine hosting the enumerated application. In still another of these embodiments the remote machine includes the launch ticket in the access information responsive to a request from the local machine for the launch ticket.

Referring now to a block diagram depicts one embodiment of the present disclosure in which a local machine requests execution of an application program and a remote machine selects a method of executing the application program. In one embodiment the remote machine receives credentials from the local machine . In another embodiment the remote machine receives a request for an enumeration of available applications from the local machine .

In some embodiments multiple redundant remote machines and are provided. In one of these embodiments there may be for example multiple file servers multiple session management servers multiple staging machines multiple web interfaces or multiple access suite consoles. In another of these embodiments if a remote machine fails a redundant remote machine is selected to provide the functionality of the failed machine. In other embodiments although the remote machines and and the web interface and access suite console are described as separate remote machines having the separate functionalities of a management server a session management server a staging machine a file server a web server and an access suite console a single remote machine may be provided having the functionality of all of these machines. In still other embodiments a remote machine may provide the functionality and services of one or more of the other remote machines.

Referring now to in greater detail a block diagram depicts one embodiment of a remote machine providing access to an application program. In addition to the interfaces and subsystems described above in connection with the remote machine may further include a management communication service an XML service and a management service . The management service may comprise an application management subsystem a server management subsystem a session management subsystem and a license management subsystem . The remote machine may be in communication with an access suite console .

In one embodiment the management service further comprises a specialized remote procedure call subsystem the MetaFrame Remote Procedure Call MFRPC subsystem . In some embodiments the MFRPC subsystem routes communications between subsystems on the remote machine such as the XML service and the management service . In other embodiments the MFRPC subsystem provides a remote procedure call RPC interface for calling management functions delivers RPC calls to the management service and returns the results to the subsystem making the call.

In some embodiments the remote machine is in communication with a protocol engine such as the protocol engine described above in . In one of these embodiments the remote machine is in communication with a protocol engine residing on a remote machine . In other embodiments the remote machine further comprises a protocol engine .

The remote machine may be in communication with an access suite console . The access suite console may host management tools to an administrator of a remote machine or of a farm . In some embodiments the remote machine communicates with the access suite console using XML. In other embodiments the remote machine communicates with the access suite console using the Simple Object Access Protocol SOAP .

For embodiments such as those described in and in in which the remote machine comprises a subset of subsystems the management service may comprise a plurality of subsystems. In one embodiment each subsystem is either a single threaded or a multi threaded subsystem. A thread is an independent stream of execution running in a multi tasking environment. A single threaded subsystem is capable of executing only one thread at a time. A multi threaded subsystem can support multiple concurrently executing threads i.e. a multi threaded subsystem can perform multiple tasks simultaneously.

The application management subsystem manages information associated with a plurality of applications capable of being streamed. In one embodiment the application management subsystem handles requests from other components such as requests for storing deleting updating enumerating or resolving applications. In another embodiment the application management subsystem handles requests sent by components related to an application capable of being streamed. These events can be classified into three types of events application publishing application enumeration and application launching each of which will be described in further detail below. In other embodiments the application management subsystem further comprises support for application resolution application publication and application publishing. In other embodiments the application management subsystem uses a data store to store application properties and policies.

The server management subsystem handles configurations specific to application streaming in server farm configurations. In some embodiments the server management subsystem also handles events that require retrieval of information associated with a configuration of a farm . In other embodiments the server management subsystem handles events sent by other components related to remote machines providing access to applications across application streams and properties of those remote machines. In one embodiment the server management subsystem stores remote machine properties and farm properties.

In some embodiments the remote machine further comprises one or more common application subsystems providing services for one or more specialized application subsystems. These remote machines may also have one or more common remote machine subsystem providing services for one or more specialized remote machine subsystems. In other embodiments no common application subsystems are provided and each specialized application and remote machine subsystem implements all required functionality.

In one embodiment in which the remote machine comprises a common application subsystem the common application subsystem manages common properties for published applications. In some embodiments the common application subsystem handles events that require retrieval of information associated with published applications or with common properties. In other embodiments the common application subsystem handles all events sent by other components related to common applications and their properties.

A common application subsystem can publish applications to the farm which makes each application available for enumeration and launching by a local machine . Generally an application is installed on each remote machine on which availability of that application is desired. In one embodiment to publish an application an administrator runs an administration tool specifying information such as the remote machines hosting the application the name of the executable file on each remote machine the required capabilities of a local machine for executing the application e.g. audio video encryption etc. and a list of users that can use the application. This specified information is categorized into application specific information and common information. Examples of application specific information are the path name for accessing the application and the name of the executable file for running the application. Common information i.e. common application data includes for example the user friendly name of the application e.g. Microsoft WORD 2000 a unique identification of the application and the users of the application.

The application specific information and common information may be sent to a specialized application subsystem controlling the application on each remote machine hosting the application. The specialized application subsystem may write the application specific information and the common information into a persistent store .

When provided a common application subsystem also provides a facility for managing the published applications in the farm . Through a common application subsystem an administrator can manage the applications of the farm using an administration tool such as the access suite console to configure application groups and produce an application tree hierarchy of those application groups. Each application group may be represented as a folder in the application tree hierarchy. Each application folder in the application tree hierarchy can include one or more other application folders and specific instances of remote machines. The common application subsystem provides functions to create move rename delete and enumerate application folders.

In one embodiment the common application subsystem supports the application management subsystem in handling application enumeration and application resolution requests. In some embodiments the common application subsystem provides functionality for identifying an application for execution responsive to a mapping between a type of data file and an application for processing the type of data file. In other embodiments a second application subsystem provides the functionality for file type association.

In some embodiments the remote machine may further comprise a policy subsystem. A policy subsystem includes a policy rule for determining whether an application may be streamed to a local machine upon a request by the local machine for execution of the application. In some embodiments the policy subsystem identifies a server access option associated with a streamed application published in the access suite console . In one of these embodiments the policy subsystem uses the server access option as a policy in place of the policy rule.

The session monitoring subsystem maintains and updates session status of an application streaming session associated with a local machine and enforces license requirements for application streaming sessions. In one embodiment the session management subsystem monitors sessions and logs events such as the launching of an application or the termination of an application streaming session. In another embodiment the session monitoring subsystem receives communications such as heartbeat messages transmitted from the local machine to the remote machine . In still another embodiment the session management subsystem responds to queries about sessions from management tools such as tools within the access suite console . In some embodiments the management service further comprises a license management subsystem communicating with the session management subsystem to provide and maintain licenses to local machines for execution of applications.

In one embodiment the management service provides functionality for application enumeration and application resolution. In some embodiments the management service also provides functionality for application launching session monitoring and tracking application publishing and license enforcement.

Referring now to a block diagram depicts one embodiment of a remote machine comprising a management service providing an application enumeration. The management service may provide application enumeration through the use of a web interface interacting with an XML service . In one embodiment XML service enumerates applications for a user of a local machine . In another embodiment the XML service implements the functionality of the ICA browser subsystem and the program neighborhood subsystem described above. The XML service may interact with a management communications service . In one embodiment the XML service generates an application enumeration request using the management communications service . The application enumeration request may include a client type indicating a method of execution to be used when executing the enumerated application. The application enumeration request is sent to a common application subsystem . In one embodiment the common application subsystem returns an enumeration of applications associated with the client type of the application enumeration request. In another embodiment the common application subsystem returns an enumeration of applications available to the user of the local machine the enumeration selected responsive to an application of a policy to a credential associated with the local machine . In this embodiment a policy engine may apply the policy to credentials gathered by a collection agent as described in connection with above. In still another embodiment the enumeration of applications is returned and an application of a policy to the local machine is deferred until an execution of an enumerated application is requested.

The management service may provide application resolution service for identifying a second remote machine hosting an application. In one embodiment the second remote machine is a file server or an application server. In some embodiments the management service consults a file including identifiers for a plurality of remote machines hosting applications. In one embodiment the management service provides the application resolution service responsive to a request from a local machine for execution of an application. In another embodiment the management service identifies a second remote machine capable of implementing a different method of executing the application than a first remote machine . In some embodiments the management service identifies a first remote machine capable of streaming an application program to a local machine and a second remote machine capable of executing the application program and providing application output data generated responsive to the execution of the application program to the local machine .

In one embodiment a web interface transmits an application resolution request to the XML service . In another embodiment the XML service receives a application resolution request and transmits the request to the MFRPC subsystem .

In one embodiment the MFRPC subsystem identifies a client type included with a received application resolution request. In another embodiment the MFRPC subsystem applies a policy to the client type and determines to stream the application to the local machine . In this embodiment the MFRPC subsystem may forward the application resolution request to an application management subsystem . In one embodiment upon receiving the application resolution request from the MFRPC subsystem the application management subsystem may identify a remote machine functioning as a session management server for the local machine . In some embodiments the local machine transmits a heartbeat message to the session management server . In another embodiment the application management subsystem may identify a remote machine hosting a plurality of application files comprising the application to be streamed to the local machine .

In some embodiments the application management subsystem use a file enumerating a plurality of remote machines hosting the plurality of application files to identify the remote machine . In other embodiments the application management subsystem identifies a remote machine having an IP address similar to an IP address of the local machine . In still other embodiments the application management subsystem identifies a remote machine having an IP address in a range of IP addresses accessible to the local machine .

In still another embodiment the MFRPC subsystem applies a policy to the client type and determines that the application may be executed on a remote machine the remote machine transmitting application output data generated by an execution of the application to the local machine . In this embodiment the MFRPC subsystem may forward the application resolution request to a common application subsystem to retrieve an identifier of a host address for a remote machine . In one embodiment the identified remote machine may transmit the application output data to the local machine using a presentation level protocol such as ICA or RDP or X Windows. In some embodiments the remote machine receives the application from a second remote machine across an application streaming session.

In one embodiment upon completion of application enumeration and application resolution access information is transmitted to the local machine that includes an identification of a method of execution for an enumerated application and an identifier of a remote machine hosting the enumerated application. In one embodiment where the management service determines that the enumerated application will execute on the local machine a web interface creates and transmits to the local machine a file containing name resolved information about the enumerated application. In some embodiments the file may be identified using a .rad extension. The local machine may execute the enumerated application responsive to the contents of the received file. Table 2 depicts one embodiment of information contained in the file 

The file may also contain a launch ticket for use by the local machine in executing the application as shown in Table 2. In some embodiments the launch ticket expires after a predetermined period of time. In one embodiment the local machine provides the launch ticket to a remote machine hosting the enumerated application to be executed. Use of the launch ticket to authorize access to the enumerated application by a user of the local machine assists in preventing the user from reusing the file or generating an unauthorized version of the file to inappropriately access to applications. In one embodiment the launch ticket comprises a large randomly generated number.

As described above in connection with a method for selecting a method of execution of an application program begins when credentials associated with the local machine or with a user of the local machine are received step and an enumeration of a plurality of application programs available to the local machine is provided responsive to the received credentials step . A request is received to execute an enumerated application step and one of a predetermined number of methods for executing the enumerated application is selected responsive to a policy the predetermined number of methods including a method for application streaming of the enumerated application step .

Referring now to a flow diagram depicts one embodiment of the steps taken to access a plurality of files comprising an application program. A local machine performs a pre launch analysis of the local machine step . In one embodiment the local machine performs the pre launch analysis prior to retrieving and executing a plurality of application files comprising an application program. In another embodiment the local machine performs the pre launch analysis responsive to a received indication that the pre launch analysis is a requirement for authorization to access the plurality of application files comprising an application program.

In some embodiments the local machine receives from a remote machine access information associated with the plurality of application files. In one of these embodiments the access information includes an identification of a location of a remote machine hosting the plurality of application files. In another of these embodiments the local machine receives an identification of a plurality of applications comprising one or more versions of the application program. In still another of these embodiments the local machine receives an identification of a plurality of application files comprising one or more application programs. In other embodiments the local machine receives an enumeration of application programs available to the local machine for retrieval and execution. In one of these embodiments the enumeration results from an evaluation of the local machine . In still other embodiments the local machine retrieves the at least one characteristic responsive to the retrieved identification of the plurality of application files comprising an application program.

In some embodiments the access information includes a launch ticket capable of authorizing the local machine to access the plurality of application files. In one of these embodiments the launch ticket is provided to the local machine responsive to an evaluation of the local machine . In another of these embodiments the launch ticket is provided to the local machine subsequent to a pre launch analysis of the local machine by the local machine .

In other embodiments the local machine retrieves at least one characteristic required for execution of the plurality of application files. In one of these embodiments the access information includes the at least one characteristic. In another of these embodiments the access information indicates a location of a file for retrieval by the local machine the file enumerating the at least one characteristic. In still another of these embodiments the file enumerating the at least one characteristic further comprises an enumeration of the plurality of application files and an identification of a remote machine hosting the plurality of application files.

The local machine determines the existence of the at least one characteristic on the local machine. In one embodiment the local machine makes this determination as part of the pre launch analysis. In another embodiment the local machine determines whether the local machine has the at least one characteristic.

In one embodiment determining the existence of the at least one characteristic on the local machine includes determining whether a device driver is installed on the local machine. In another embodiment determining the existence of the at least one characteristic on the local machine includes determining whether an operating system is installed on the local machine . In still another embodiment determining the existence of the at least one characteristic on the local machine includes determining whether a particular operating system is installed on the local machine . In yet another embodiment determining the existence of the at least one characteristic on the local machine includes determining whether a particular revision level of an operating system is installed on the local machine .

In some embodiments determining the existence of the at least one characteristic on the local machine includes determining whether the local machine has acquired authorization to execute an enumerated application. In one of these embodiments a determination is made by the local machine as to whether the local machine has received a license to execute the enumerated application. In another of these embodiments a determination is made by the local machine as to whether the local machine has received a license to receive across an application streaming session a plurality of application files comprising the enumerated application. In other embodiments determining the existence of the at least one characteristic on the local machine includes determining whether the local machine has sufficient bandwidth available to retrieve and execute an enumerated application.

In some embodiments determining the existence of the at least one characteristic on the local machine includes execution of a script on the local machine . In other embodiments determining the existence of the at least one characteristic on the local machine includes installation of software on the local machine . In still other embodiments determining the existence of the at least one characteristic on the local machine includes modification of a registry on the local machine . In yet other embodiments determining the existence of the at least one characteristic on the local machine includes transmission of a collection agent to the local machine for execution on the local machine to gather credentials associated with the local machine .

The local machine requests from a remote machine authorization for execution of the plurality of application files the request including a launch ticket step . In some embodiments the local machine makes the request responsive to a determination that at least one characteristic exists on the local machine . In one of these embodiments the local machine determines that a plurality of characteristics exist on the local machine the plurality of characteristics associated with an enumerated application and received responsive to a request to execute the enumerated application. In another of these embodiments whether the local machine receives an indication that authorization for execution of the enumerated application files depends upon existence of the at least one characteristic on the local machine . In one embodiment the local machine received an enumeration of application programs requested execution of an enumerated application and received access information including the at least one characteristic and a launch ticket authorizing the execution of the enumerated application upon the determination of the existence of the at least one characteristic on the local machine .

In one embodiment the local machine receives from the remote machine a license authorizing execution of the plurality of application files. In some embodiments the license authorizes execution for a specified time period. In one of these embodiments the license requires transmission of a heart beat message to maintain authorization for execution of the plurality of application files.

In another embodiment the local machine receives from the remote machine the license and an identifier associated with a remote machine monitoring execution of the plurality of application files. In some embodiments the remote machine is a session management server as depicted above in . In one of these embodiments the session management server includes a session management subsystem that monitors the session associated with the local machine . In other embodiments a separate remote machine is the session management server .

The local machine receives and executes the plurality of application files step . In one embodiment the local machine receives the plurality of application files across an application streaming session. In another embodiment the local machine stores the plurality of application files in an isolation environment on the local machine . In still another embodiment the local machine executes one of the plurality of application files prior to receiving a second of the plurality of application files. In some embodiments a remote machine transmits the plurality of application files to a plurality of local machines each local machine in the plurality having established a separate application streaming session with the remote machine.

In some embodiments the local machine stores the plurality of application files in a cache and delays execution of the application files. In one of these embodiments the local machine receives authorization to execute the application files during a pre defined period of time. In another of these embodiments the local machine receives authorization to execute the application files during the pre defined period of time when the local machine lacks access to a network. In other embodiments the local machine stores the plurality of application files in a cache. In one of these embodiments the application streaming client establishes an internal application streaming session to retrieve the plurality of application files from the cache. In another of these embodiments the local machine receives authorization to execute the application files during a pre defined period of time when the local machine lacks access to a network.

The local machine transmits at least one heartbeat message to a remote machine step . In some embodiments the local machine transmits the at least one heartbeat message to retain authorization to execute the plurality of application files comprising the enumerated application. In other embodiments the local machine transmits the at least one heartbeat message to retain authorization retrieve an application file in the plurality of application files. In still other embodiments the local machine receives a license authorizing execution of the plurality of application files during a pre determined period of time.

In some embodiments the local machine transmits the heartbeat message to a second remote machine . In one of these embodiments the second remote machine may comprise a session management server monitoring the retrieval and execution of the plurality of application files. In another of these embodiments the second remote machine may renew a license authorizing execution of the plurality of application files responsive to the transmitted heartbeat message. In still another of these embodiments the second remote machine may transmit to the local machine a command responsive to the transmitted heartbeat message.

Referring back to the local machine may include an application streaming client a streaming service and an isolation environment .

The application streaming client may be an executable program. In some embodiments the application streaming client may be able to launch another executable program. In other embodiments the application streaming client may initiate the streaming service . In one of these embodiments the application streaming client may provide the streaming service with a parameter associated with executing an application program. In another of these embodiments the application streaming client may initiate the streaming service using a remote procedure call.

In one embodiment the local machine requests execution of an application program and receives access information from a remote machine regarding execution. In another embodiment the application streaming client receives the access information. In still another embodiment the application streaming client provides the access information to the streaming service . In yet another embodiment the access information includes an identification of a location of a file associated with a plurality of application files comprising the application program.

In one embodiment the streaming service retrieves a file associated with a plurality of application files. In some embodiments the retrieved file includes an identification of a location of the plurality of application files. In one of these embodiments the streaming service retrieves the plurality of application files. In another of these embodiments the streaming service executes the retrieved plurality of application files on the local machine . In other embodiments the streaming service transmits heartbeat messages to a remote machine to maintain authorization to retrieve and execute a plurality of application files.

In some embodiments the retrieved file includes an identification of a location of more than one plurality of application files each plurality of application files comprising a different application program. In one of these embodiments the streaming service retrieves the plurality of application files comprising the application program compatible with the local machine . In another of these embodiments the streaming service receives authorization to retrieve a particular plurality of application files responsive to an evaluation of the local machine .

In some embodiments the plurality of application files are compressed and stored on a file server within an archive file such as a CAB ZIP SIT TAR JAR or other archive file. In one embodiment a plurality of application files stored in an archive file comprise an application program. In another embodiment multiple pluralities of application files stored in an archive file each comprise different versions of an application program. In still another embodiment multiple pluralities of application files stored in an archive file each comprise different application programs. In some embodiments an archive file includes metadata associated with each file in the plurality of application files. In one of these embodiments the streaming service generates a directory structure responsive to the included metadata. As will be described in greater detail in connection with below the metadata may be used to satisfy requests by application programs for directory enumeration.

In one embodiment the streaming service decompresses an archive file to acquire the plurality of application files. In another embodiment the streaming service determines whether a local copy of a file within the plurality of application files exists in a cache on the local machine prior to retrieving the file from the plurality of application files. In still another embodiment the file system filter driver determines whether the local copy exists in the cache. In some embodiments the streaming service modifies a registry entry prior to retrieving a file within the plurality of application files.

In some embodiments the streaming service stores a plurality of application files in a cache on the local machine . In one of these embodiments the streaming service may provide functionality for caching a plurality of application files upon receiving a request to cache the plurality of application files. In another of these embodiments the streaming service may provide functionality for securing a cache on the local machine . In another of these embodiments the streaming service may use an algorithm to adjust a size and a location of the cache.

In some embodiments the streaming service creates an isolation environment on the local machine . In one of these embodiments the streaming service uses an isolation environment application programming interface to create the isolation environment . In another of these embodiments the streaming service stores the plurality of application files in the isolation environment . In still another of these embodiments the streaming service executes a file in the plurality of application files within the isolation environment. In yet another of these embodiments the streaming service executes the application program in the isolation environment.

For embodiments in which authorization is received to execute an application on the local machine the execution of the application may occur within an isolation environment . In some embodiments a plurality of application files comprising the application are stored on the local machine prior to execution of the application. In other embodiments a subset of the plurality of application files are stored on the local machine prior to execution of the application. In still other embodiments the plurality of application files do not reside in the isolation environment . In yet other embodiments a subset of the plurality of applications files do not reside on the local machine . Regardless of whether a subset of the plurality of application files or each application file in the plurality of application files reside on the local machine or in isolation environment in some embodiments an application file in the plurality of application files may be executed within an isolation environment .

The isolation environment may consist of a core system able to provide File System Virtualization Registry System Virtualization and Named Object Virtualization to reduce application compatibility issues without requiring any change to the application source code. The isolation environment may redirect application resource requests using hooking both in the user mode for registry and named object virtualization and in the kernel using a file system filter driver for file system virtualization. The following is a description of some embodiments of an isolation environment .

Referring now to one embodiment of a computer running under control of an operating system that has reduced application compatibility and application sociability problems is shown. The operating system makes available various native resources to application programs via its system layer . The view of resources embodied by the system layer will be termed the system scope . In order to avoid conflicting access to native resources by the application programs an isolation environment is provided. As shown in the isolation environment includes an application isolation layer and a user isolation layer . Conceptually the isolation environment provides via the application isolation layer an application program with a unique view of native resources such as the file system the registry objects and window names . Each isolation layer modifies the view of native resources provided to an application. The modified view of native resources provided by a layer will be referred to as that layer s isolation scope . As shown in the application isolation layer includes two application isolation scopes . Scope represents the view of native resources provided to application and scope represents the view of native resources provided to application . Thus in the embodiment shown in APP is provided with a specific view of the file system while APP is provided with another view of the file system which is specific to it. In some embodiments the application isolation layer provides a specific view of native resources to each individual application program executing on top of the operating system . In other embodiments application programs may be grouped into sets and in these embodiments the application isolation layer provides a specific view of native resources for each set of application programs. Conflicting application programs may be put into separate groups to enhance the compatibility and sociability of applications. In still further embodiments the applications belonging to a set may be configured by an administrator. In some embodiments a passthrough isolation scope can be defined which corresponds exactly to the system scope. In other words applications executing within a passthrough isolation scope operate directly on the system scope.

In some embodiments the application isolation scope is further divided into layered sub scopes. The main sub scope contains the base application isolation scope and additional sub scopes contain various modifications to this scope that may be visible to multiple executing instances of the application. For example a sub scope may contain modifications to the scope that embody a change in the patch level of the application or the installation or removal of additional features. In some embodiments the set of additional sub scopes that are made visible to an instance of the executing application is configurable. In some embodiments that set of visible sub scopes is the same for all instances of the executing application regardless of the user on behalf of which the application is executing. In others the set of visible sub scopes may vary for different users executing the application. In still other embodiments various sets of sub scopes may be defined and the user may have a choice as to which set to use. In some embodiments sub scopes may be discarded when no longer needed. In some embodiments the modifications contained in a set of sub scopes may be merged together to form a single sub scope.

Referring now to a multi user computer having reduced application compatibility and application sociability problems is depicted. The multi user computer includes native resources in the system layer as well as the isolation environment discussed immediately above. The application isolation layer functions as discussed above providing an application or group of applications with a modified view of native resources. The user isolation layer conceptually provides an application program with a view of native resources that is further altered based on user identity of the user on whose behalf the application is executed. As shown in the user isolation layer may be considered to comprise a number of user isolation scopes generally . A user isolation scope provides a user specific view of application specific views of native resources. For example APP executing in user session on behalf of user a is provided with a file system view a that is altered or modified by both the user isolation scope and the application isolation scope .

Put another way the user isolation layer alters the view of native resources for each individual user by layering a user specific view modification provided by a user isolation scope on top of an application specific view modification provided by an application isolation scope which is in turn layered on top of the system wide view of native resources provided by the system layer. For example when the first instance of APP accesses an entry in the registry database the view of the registry database specific to the first user session and the application a is consulted. If the requested registry key is found in the user specific view of the registry a that registry key is returned to APP . If not the view of the registry database specific to the application is consulted. If the requested registry key is found in the application specific view of the registry that registry key is returned to APP . If not then the registry key stored in the registry database in the system layer i.e. the native registry key is returned to APP .

In some embodiments the user isolation layer provides an isolation scope for each individual user. In other embodiments the user isolation layer provides an isolation scope for a group of users which may be defined by roles within the organization or may be predetermined by an administrator. In still other embodiments no user isolation layer is provided. In these embodiments the view of native resources seen by an application program is that provided by the application isolation layer . The isolation environment although described in relation to multi user computers supporting concurrent execution of application programs by various users may also be used on single user computers to address application compatibility and sociability problems resulting from sequential execution of application programs on the same computer system by different users and those problems resulting from installation and execution of incompatible programs by the same user.

In some embodiments the user isolation scope is further divided into sub scopes. The modifications by the user isolation scope to the view presented to an application executing in that scope is the aggregate of the modifications contained within each sub scope in the scope. Sub scopes are layered on top of each other and in the aggregate view modifications to a resource in a higher sub scope override modifications to the same resource in lower layers.

In some of these embodiments one or more of these sub scopes may contain modifications to the view that are specific to the user. In some of these embodiments one or more sub scopes may contain modifications to the view that are specific to sets of users which may be defined by the system administrators or defined as a group of users in the operating system. In some of these embodiments one of these sub scopes may contain modifications to the view that are specific to the particular login session and hence that are discarded when the session ends. In some of these embodiments changes to native resources by application instances associated with the user isolation scope always affects one of these sub scopes and in other embodiments those changes may affect different sub scopes depending on the particular resource changed.

The conceptual architecture described above allows an application executing on behalf of a user to be presented with an aggregate or unified virtualized view of native resources specific to that combination of application and user. This aggregated view may be referred to as the virtual scope . The application instance executing on behalf of a user is presented with a single view of native resources reflecting all operative virtualized instances of the native resources. Conceptually this aggregated view consists firstly of the set of native resources provided by the operating system in the system scope overlaid with the modifications embodied in the application isolation scope applicable to the executing application further overlaid with the modifications embodied in the user isolation scope applicable to the application executing on behalf of the user. The native resources in the system scope are characterized by being common to all users and applications on the system except where operating system permissions deny access to specific users or applications. The modifications to the resource view embodied in an application isolation scope are characterized as being common to all instances of applications associated with that application isolation scope. The modifications to the resource view embodied in the user isolation scope are characterized as being common to all applications associated with the applicable application isolation scope that are executing on behalf of the user associated with the user isolation scope.

This concept can be extended to sub scopes the modifications to the resource view embodied in a user sub scope are common to all applications associated with the applicable isolation sub scope executing on behalf of a user or group of users associated with a user isolation sub scope. Throughout this description it should be understood that whenever general reference is made to scope it is intended to also refer to sub scopes where those exist.

When an application requests enumeration of a native resource such as a portion of the file system or registry database a virtualized enumeration is constructed by first enumerating the system scoped instance of the native resource that is the instance found in the system layer if any. Next the application scoped instance of the requested resource that is the instance found in the appropriate application isolation scope if any is enumerated. Any enumerated resources encountered in the application isolation scope are added to the view. If the enumerated resource already exists in the view because it was present in the system scope as well it is replaced with the instance of the resource encountered in the application isolation scope. Similarly the user scoped instance of the requested resource that is the instance found in the appropriate user isolation scope if any is enumerated. Again any enumerated resources encountered in the user isolation scope are added to the view. If the native resource already exists in the view because it was present in the system scope or in the appropriate application isolation scope it is replaced with the instance of the resource encountered in the user isolation scope. In this manner any enumeration of native resources will properly reflect virtualization of the enumerated native resources. Conceptually the same approach applies to enumerating an isolation scope that comprises multiple sub scopes. The individual sub scopes are enumerated with resources from higher sub scopes replacing matching instances from lower sub scopes in the aggregate view.

In other embodiments enumeration may be performed from the user isolation scope layer down to the system layer rather than the reverse. In these embodiments the user isolation scope is enumerated. Then the application isolation scope is enumerated and any resource instances appearing in the application isolation scope that were not enumerated in the user isolation scope are added to the aggregate view that is under construction. A similar process can be repeated for resources appearing only in the system scope.

In still other embodiments all isolation scopes may be simultaneously enumerated and the respective enumerations combined.

If an application attempts to open an existing instance of a native resource with no intent to modify that resource the specific instance that is returned to the application is the one that is found in the virtual scope or equivalently the instance that would appear in the virtualized enumeration of the parent of the requested resource. From the point of view of the isolation environment the application is said to be requesting to open a virtual resource and the particular instance of native resource used to satisfy that request is said to be the literal resource corresponding to the requested resource.

If an application executing on behalf of a user attempts to open a resource and indicates that it is doing so with the intent to modify that resource that application instance is normally given a private copy of that resource to modify as resources in the application isolation scope and system scope are common to applications executing on behalf of other users. Typically a user scoped copy of the resource is made unless the user scoped instance already exists. The definition of the aggregate view provided by a virtual scope means that the act of copying an application scoped or system scoped resource to a user isolation scope does not change the aggregate view provided by the virtual scope for the user and application in question nor for any other user nor for any other application instance. Subsequent modifications to the copied resource by the application instance executing on behalf of the user do not affect the aggregate view of any other application instance that does not share the same user isolation scope. In other words those modifications do not change the aggregate view of native resources for other users or for application instances not associated with the same application isolation scope.

Applications may be installed into a particular isolation scope described below in more detail . Applications that are installed into an isolation scope are always associated with that scope. Alternatively applications may be launched into a particular isolation scope or into a number of isolation scopes. In effect an application is launched and associated with one or more isolation scopes. The associated isolation scope or scopes provide the process with a particular view of native resources. Applications may also be launched into the system scope that is they may be associated with no isolation scope. This allows for the selective execution of operating system applications such as Internet Explorer as well as third party applications within an isolation environment.

This ability to launch applications within an isolation scope regardless of where the application is installed mitigates application compatibility and sociability issues without requiring a separate installation of the application within the isolation scope. The ability to selectively launch installed applications in different isolation scopes provides the ability to have applications which need helper applications such as Word Notepad etc. to have those helper applications launched with the same rule sets.

Further the ability to launch an application within multiple isolated environments allows for better integration between isolated applications and common applications.

Referring now to and in brief overview a method for associating a process with an isolation scope includes the steps of launching the process in a suspended state step . The rules associated with the desired isolation scope are retrieved step and an identifier for the process and the retrieved rules are stored in a memory element step and the suspended process is resumed step . Subsequent calls to access native resources made by the process are intercepted or hooked step and the rules associated with the process identifier if any are used to virtualize access to the requested resource step .

Still referring to and in more detail a process is launched in a suspended state step . In some embodiments a custom launcher program is used to accomplish this task. In some of these embodiments the launcher is specifically designed to launch a process into a selected isolation scope. In other embodiments the launcher accepts as input a specification of the desired isolation scope for example by a command line option.

The rules associated with the desired isolation scope are retrieved step . In some embodiments the rules are retrieved from a persistent storage element such as a hard disk drive or other solid state memory element. The rules may be stored as a relational database flat file database tree structured database binary tree structure or other persistent data structure. In other embodiments the rules may be stored in a data structure specifically configured to store them.

An identifier for the process such as a process id PID and the retrieved rules are stored in a memory element step . In some embodiments a kernel mode driver is provided that receives operating system messages concerning new process creation. In these embodiments the PID and the retrieved rules may be stored in the context of the driver. In other embodiments a file system filter driver or mini filter is provided that intercepts native resource requests. In these embodiments the PID and the retrieved rules may be stored in the filter. In other embodiments still all interception is performed by user mode hooking and no PID is stored at all. The rules are loaded by the user mode hooking apparatus during the process initialization and no other component needs to know the rules that apply to the PID because rule association is performed entirely in process.

The suspended process is resumed step and subsequent calls to access native resources made by the process are intercepted or hooked step and the rules associated with the process identifier if any are used to virtualize access to the requested resource step . In some embodiments a file system filter driver or mini filter or file system driver intercepts requests to access native resources and determines if the process identifier associated with the intercepted request has been associated with a set of rules. If so the rules associated with the stored process identifier are used to virtualize the request to access native resources. If not the request to access native resources is passed through unmodified. In other embodiments a dynamically linked library is loaded into the newly created process and the library loads the isolation rules. In still other embodiments both kernel mode techniques hooking filter driver mini filter and user mode techniques are used to intercept calls to access native resources. For embodiments in which a file system filter driver stores the rules the library may load the rules from the file system filter driver.

Processes that are children of processes associated with isolation scopes are associated with the isolation scopes of their parent process. In some embodiments this is accomplished by a kernel mode driver notifying the file system filter driver when a child process is created. In these embodiments the file system filter driver determines if the process identifier of the parent process is associated with an isolation scope. If so file system filter driver stores an association between the process identifier for the newly created child process and the isolation scope of the parent process. In other embodiments the file system filter driver can be called directly from the system without use of a kernel mode driver. In other embodiments in processes that are associated with isolation scopes operating system functions that create new processes are hooked or intercepted. When request to create a new process are received from such a process the association between the new child process and the isolation scope of the parent is stored.

In some embodiments a scope or sub scope may be associated with an individual thread instead of an entire process allowing isolation to be performed on a per thread basis. In some embodiments per thread isolation may be used for Services and COM servers.

In some embodiments isolation environments are used to provide additional functionality to the application streaming client . In one of these embodiments an application program is executed within an isolation environment. In another of these embodiments a retrieved plurality of application files resides within the isolation environment. In still another of these embodiments changes to a registry on the local machine are made within the isolation environment.

In one embodiment the application streaming client includes an isolation environment . In some embodiments the application streaming client includes a file system filter driver intercepting application requests for files. In one of these embodiments the file system filter driver intercepts an application request to open an existing file and determines that the file does not reside in the isolation environment . In another of these embodiments the file system filter driver redirects the request to the streaming service responsive to a determination that the file does not reside in the isolation environment . The streaming service may extract the file from the plurality of application files and store the file in the isolation environment . The file system filter driver may then respond to the request for the file with the stored copy of the file. In some embodiments the file system filter driver may redirect the request for the file to a file server responsive to an indication that the streaming service has not retrieved the file or the plurality of application files and a determination the file does not reside in the isolation environment .

In some embodiments the file system filter driver uses a strict isolation rule to prevent conflicting or inconsistent data from appearing in the isolation environment . In one of these embodiments the file system filter driver intercepting a request for a resource in a user isolation environment may redirect the request to an application isolation environment. In another of these embodiments the file system filter driver does not redirect the request to a system scope.

In one embodiment the streaming service uses IOCTL commands to communicate with the filter driver. In another embodiment communications to the file server are received with the Microsoft SMB streaming protocol.

In some embodiments the packaging mechanism stores in a manifest file a list of file types published as available applications and makes this information available to application publishing software. In one of these embodiments the packaging mechanism receives this information from monitoring an installation of an application program into the isolation environment on the staging machine. In another of these embodiments a user of the packaging mechanism provides this information to the packaging mechanism . In other embodiments application publishing software within the access suite console consults the manifest file to present to a user of the access suite console the possible file types that can be associated with the requested application being published. The user selects a file type to associate with a particular published application. The file type is presented to the local machine at the time of application enumeration.

The local machine may include a client agent . The client agent provides functionality for associating a file type with an application program and selecting a method of execution of the application program responsive to the association. In one embodiment the client agent is a program neighborhood application.

When an application program is selected for execution the local machine makes a determination as to a method of execution associated with a file type of the application program. In one embodiment the local machine determines that the file type is associated with a method of execution requiring an application streaming session for retrieval of the application files and execution within an isolation environment. In this embodiment the local machine may redirect the request to the application streaming client instead of launching a local version of the application program. In another embodiment the client agent makes the determination. In still another embodiment the client agent redirects the request to the application streaming client .

In one embodiment the application streaming client requests access information associated with the application program from the remote machine . In some embodiments the application streaming client receives an executable program containing the access information. In one of these embodiments the application streaming client receives an executable program capable of displaying on the local machine application output data generated from an execution of the application program on a remote machine. In another of these embodiments the application streaming client receives an executable program capable of retrieving the application program across an application streaming session and executing the application program in an isolation environment on the local machine . In this embodiment the application streaming client may execute the received executable program. In still another of these embodiments the remote machine selects an executable program to provide to the local machine responsive to performing an application resolution as described above.

Referring now to a flow diagram depicts one embodiment of steps taken in a method for executing an application. As described above in regarding step a local machine receives and executes the plurality of application files. In brief overview the local machine receives a file including access information for accessing a plurality of application files and for executing a first client capable of receiving an application stream step . The local machine retrieves an identification of the plurality of application files responsive to the file step . The local machine retrieves at least one characteristic required for execution of the plurality of application files responsive to the file step . The local machine determines whether the local machine includes the at least one characteristic step . The local machine executes a second client the second client requesting execution of the plurality of application files on a remote machine responsive to a determination that the local machine lacks the at least one characteristic step .

Referring to and in greater detail the local machine receives a file including access information for accessing a plurality of application files and for executing a first client capable of receiving an application stream step . In one embodiment the local machine receives access information including an identification of a location of a plurality of application files comprising an application program. In another embodiment the local machine receives the file responsive to requesting execution of the application program. In still another embodiment the access information includes an indication that the plurality of application files reside on a remote machine such as an application server or a file server. In yet another embodiment the access information indicates that the local machine may retrieve the plurality of application files from the remote machine over an application streaming session.

The local machine retrieves an identification of the plurality of application files responsive to the file step . In one embodiment the local machine identifies a remote machine on which the plurality of application files reside responsive to the file including access information. In another embodiment the local machine retrieves from the remote machine a file identifying the plurality of application files. In some embodiments the plurality of application files comprise an application program. In other embodiments the plurality of application files comprise multiple application programs. In still other embodiments the plurality of application files comprise multiple versions of a single application program.

Referring ahead to a flow diagram depicts one embodiment of a plurality of application files residing on a remote machine such as file server . In a plurality of application files referred to as a package includes application files comprising three different versions of one or more application programs.

In one embodiment each subset of application files comprising a version of one or more application programs and stored within the package is referred to as a target. Target for example includes a version of a word processing application program and of a spreadsheet program the version compatible with the English language version of the Microsoft Windows 2000 operating system. Target includes a version of a word processing application program and of a spreadsheet program the version compatible with the English language version of the Microsoft XP operating system. Target a version of a word processing application program and of a spreadsheet program the version compatible with the Japanese language version of the Microsoft Windows 2000 operating system with service pack .

Returning now to in some embodiments the file retrieved from the remote machine hosting the plurality of application files includes a description of the package and the targets included in the plurality of application files. In other embodiments the file retrieved from the remote machine identifies the plurality of application files comprising an application program requested for execution by the local machine .

The local machine retrieves at least one characteristic required for execution of the plurality of application files responsive to the file step . In some embodiments the local machine may not execute an application program unless the local machine includes certain characteristics. In one of these embodiments different application programs require local machines to include different characteristics from the characteristics required by other application programs. In another of these embodiments the local machine receives an identification of the at least one characteristic required for execution of the plurality of application files comprising the application program requested by the local machine .

The local machine determines whether the local machine includes the at least one characteristic step . In one embodiment the local machine evaluates an operating system on the local machine to determine whether the local machine includes the at least one characteristic. In another embodiment the local machine identifies a language used by an operating system on the local machine to determine whether the local machine includes the at least one characteristic. In still another embodiment the local machine identifies a revision level of an operating system on the local machine to determine whether the local machine includes the at least one characteristic. In yet another embodiment the local machine identifies an application version of an application program residing on the local machine to determine whether the local machine includes the at least one characteristic. In some embodiments the local machine determines whether the local machine includes a device driver to determine whether the local machine includes the at least one characteristic. In other embodiments the local machine determines whether the local machine includes an operating system to determine whether the local machine includes the at least one characteristic. In still other embodiments the local machine determines whether the local machine includes a license to execute the plurality of application files to determine whether the local machine includes the at least one characteristic.

The local machine executes a second client the second client requesting execution of the plurality of application files on a remote machine responsive to a determination that the local machine lacks the at least one characteristic step . In one embodiment when the local machine determines that the local machine lacks the at least one characteristic the local machine does not execute the first client capable of receiving an application stream. In another embodiment a policy prohibits the local machine from receiving the plurality of application files over an application stream when the local machine lacks the at least one characteristic. In some embodiments the local machine determines that the local machine does include the at least one characteristic. In one of these embodiments the local machine executes the first client the first client receiving an application stream comprising the plurality of application files from a remote machine for execution on the local machine.

In some embodiments the local machine executes the second client requesting execution of the plurality of application files on a remote machine upon determining that the local machine lacks the at least one characteristic. In one of these embodiments the second client transmits the request to a remote machine hosting the plurality of application files. In another of these embodiments the remote machine executes the plurality of application files comprising the application program and generates application output data. In still another of these embodiments the second client receives application output data generated by execution of the plurality of application files on the remote machine. In some embodiments the second client receives the application output data via an Independent Computing Architecture presentation level protocol or a Remote Desktop Windows presentation level protocol or an X Windows presentation level protocol. In yet another of these embodiments the second client displays the application output on the local machine .

In some embodiments the second client transmits the request to a remote machine that does not host the plurality of application files. In one of these embodiments the remote machine may request the plurality of application files from a second remote machine hosting the plurality of application files. In another of these embodiments the remote machine may receive the plurality of application files from the second remote machine across an application streaming session. In still another of these embodiments the remote machine stores the received plurality of application files in an isolation environment and executes the application program within the isolation environment. In yet another of these embodiments the remote machine transmits the generated application output data to the second client on the local machine.

Referring back to in one embodiment the first client capable of receiving the application stream is an application streaming client . The application streaming client receiving the file retrieving an identification of a plurality of application files and at least one characteristic required for execution of the plurality of application files responsive to the file and determining whether the local machine includes the at least one characteristic. In another embodiment the second client is a client agent . In some embodiments the client agent receives the file from the application streaming client responsive to a determination by the application streaming client that the local machine lacks the at least one characteristic.

In some embodiments an application executing on the local machine enumerates files associated with the application using the Win32 FindFirstFile and FindNextFile API calls. In one of these embodiments a plurality of application files comprise the application . In another of these embodiments not all files in the plurality of application files reside on the local machine . In still another of these embodiments the streaming service retrieved the plurality of application file in an archived files but extracted only a subset of the plurality of application files. In yet another of these embodiments the streaming service and the file system filter driver provide functionality for satisfying the enumeration request even when the requested file does not reside on the local machine .

In one embodiment the functionality is provided by intercepting the enumeration requests and providing the data as if all files in the plurality of application files reside on the local machine . In another embodiment the functionality is provided by intercepting by the file system filter driver an enumeration request transmitted as an IOCTL command such as IRP MJ DIRECTORY CONTROL IOCTL. When the file system filter driver intercepts the call the file system filter driver redirects the request to the streaming service . In one embodiment the file system filter driver determines that the requested enumeration resides in an isolation environment on the local machine prior to redirecting the request to the streaming service . In another embodiment the streaming service fulfills the request using a file in the plurality of application files the file including an enumeration of a directory structure associated with the plurality of application files. In still another embodiment the streaming service provides the response to the request to the file system filter driver for satisfaction of the enumeration request.

Referring now to a flow diagram depicts one embodiment of the steps taken in a method for responding locally to requests for file metadata associated with files stored remotely. In brief overview i a directory structure representing an application program stored by the remote machine and ii metadata associated with each file comprising the stored application program are received from a remote machine step . The directory structure and the metadata are stored step . At least one request to access metadata associated with a specific file in the directory structure is received step . The at least one request is responded to using the stored metadata step .

Referring to in greater detail a directory structure representing an application program stored by the remote machine and metadata associated with each file comprising the stored application program are received from a remote machine step . In one embodiment the streaming service receives the directory structure and the metadata. In another embodiment the streaming service receives the directory structure and the metadata when the streaming service retrieves a plurality of application files comprising the stored application program. In still another embodiment the directory structure and the metadata are stored in a file in the plurality of application files.

In one embodiment the metadata associated with each file comprises an alternate name for the at least one file. In another embodiment the metadata associated with each file includes a short name for the at least one file the name having a length of eight characters a dot and a three character extension. In still another embodiment the metadata associated with each file includes a mapping between the alternate name for the at least one file and the short name for the at least one file. In some embodiments a file in the plurality of application files has an alternate filename. In one of these embodiments when the file is retrieved by a streaming service to a local machine the file is associated with a short name responsive to the mapping between the alternate name for the file and the short name for the at least one file.

The directory structure and the metadata are stored step . In one embodiment the directory structure and the metadata are stored in an isolation environment . In another embodiment the directory structure and the metadata are stored in a cache memory element. In still another embodiment the directory structure representing an application program stored by the remote machine is used to generate an enumeration of a directory structure representing an application program executing on the local machine.

At least one request to access metadata associated with a specific file in the directory structure is received step . In one embodiment the request is a request for enumeration of the file. In another embodiment the request is a request to determine whether a copy of the file comprising the stored application program resides locally.

In one embodiment the request is made by an application executing in an isolation environment on a local machine. In another embodiment the request is made by the application streaming client . In still another embodiment the request is made on behalf of the application .

In one embodiment the request is intercepted by a file system filter driver . In another embodiment the request is forwarded to the application streaming client by the file system filter driver . In still another embodiment the request is forwarded to the streaming service by the file system filter driver .

In some embodiments the request is hooked by a function that replaces the operating system function or functions for enumerating a directory. In another embodiment a hooking dynamically linked library is used to intercept the request. The hooking function may execute in user mode or in kernel mode. For embodiments in which the hooking function executes in user mode the hooking function may be loaded into the address space of a process when that process is created. For embodiments in which the hooking function executes in kernel mode the hooking function may be associated with an operating system resource that is used in dispatching requests for file operations. For embodiments in which a separate operating system function is provided for each type of file operation each function may be hooked separately. Alternatively a single hooking function may be provided which intercepts create or open calls for several types of file operations.

The at least one request is responded to using the stored metadata step . In one embodiment the file system filter driver responds to the request. In another embodiment the application streaming client responds to the request. In still another embodiment the streaming service responds to the request. In one embodiment the stored metadata is accessed to respond to the at least one request. In another embodiment the request is responded to with a false indication that a remote copy of the file resides locally.

In one embodiment a Windows Operating System FindFirst operation is satisfied responsive to the received metadata. In another embodiment a Windows Operating System FindNext operation is satisfied responsive to the received metadata. In still another embodiment an operation for identifying a root node in a directory structure is satisfied responsive to the received metadata. In some embodiments an application layer API such as WIN32 FIND DATA API is used to respond to the operation. In other embodiments a kernel layer API such as FILE BOTH DIR INFORMATION is used to respond to the operation.

In one embodiment the metadata satisfies an operation for identifying a time of access associated with a node in a directory structure. In another embodiment the metadata satisfies an operation for identifying a time of modification associated with a node in a directory structure. In still another embodiment the metadata satisfies an operation for identifying a modified node in a directory structure.

Referring now to a block diagram depicts one embodiment of a system for responding locally to requests for file metadata associated with files stored remotely including a streaming service a file system filter driver a directory structure a plurality of application files metadata and a cache memory element . In brief overview the directory structure identifies a plurality of files associated with at least one application program. The metadata is associated with at least one of the plurality of files at least one of the plurality of files residing on a remote machine. In one embodiment the directory structure includes the metadata . The cache memory element stores the directory structure . The file system filter driver intercepts a request to access metadata associated with the at least one remotely stored file accesses the cache memory element and responds to the at least one request using the stored directory structure.

In some embodiments the streaming service receives the directory structure and metadata . In one of these embodiments the directory structure represents a plurality of application files associated with an application program the plurality of application files residing on a remote machine such as the remote machine . In another of these embodiments the metadata comprises information for responding to a Windows Operating System FindFirst request. In still another of these embodiments the metadata comprises information for responding to a Windows Operating System FindNext request. In yet another of these embodiments the metadata comprises information for responding to a request for identification of a root node in a directory structure. In another of these embodiments the metadata comprises information for responding to a request for identification of a node in a directory structure. In some embodiments an application layer API such as WIN32 FIND DATA API is used to respond to the operation. In other embodiments a kernel layer API such as FILE BOTH DIR INFORMATION is used to respond to the operation.

In some embodiments small amounts of metadata about a file may be stored directly in the literal filename such as by suffixing the virtual name with a metadata indicator where a metadata indicator is a string uniquely associated with a particular metadata state. The metadata indicator may indicate or encode one or several bits of metadata. Requests to access the file by virtual filename check for possible variations of the literal filename due to the presence of a metadata indicator and requests to retrieve the name of the file itself are hooked or intercepted in order to respond with the literal name. In other embodiments one or more alternate names for the file may be formed from the virtual file name and a metadata indicator and may be created using hard link or soft link facilities provided by the file system. The existence of these links may be hidden from applications by the isolation environment by indicating that the file is not found if a request is given to access a file using the name of a link. A particular link s presence or absence may indicate one bit of metadata for each metadata indicator or there may be a link with a metadata indicator that can take on multiple states to indicate several bits of metadata. In still other embodiments where the file system supports alternate file streams an alternate file stream may be created to embody metadata with the size of the stream indicating several bits of metadata. In still other embodiments a file system may directly provide the ability to store some 3rd party metadata for each file in the file system. In yet other embodiment a separate sub scope may be used to record deleted files and existence of a file not marked as a placeholder in that sub scope is taken to mean that the file is deleted.

In one embodiment data in a user isolation environment an application isolation environment and a system scope is combined to form a local enumeration of a directory structure representing an application. In another embodiment the streaming service accesses metadata and the directory structure to populate the application isolation environment. In still another embodiment the file system filter driver generates the local enumeration of the directory structure. In yet another embodiment the local enumeration of the directory structure identifies at least one file in the plurality of application files the at least one file residing on a remote machine and not on the local machine. In some embodiments the local enumeration of the directory structure is stored on the cache memory element . In other embodiments the streaming service generates the application isolation environment and the local enumeration of the directory structure.

In one embodiment the file system filter driver intercepts a request transmitted to a system scope for access to the local enumeration of the directory structure. In another embodiment file system filter driver generates the local enumeration after intercepting the request. In still another embodiment the file system filter driver redirects the request for the local enumeration to the user isolation environment. In yet another embodiment the file system filter driver redirects the request for the local enumeration to the application isolation environment.

In some embodiments the file system filter driver intercepts a request for access to a file identifies in the local enumeration of the directory the file residing on a remote machine. In one of these embodiments the file system filter driver requests retrieval of the file by the streaming service as described in greater detail in connection with below.

As applications running in an isolation environment make requests for files a filter driver intercepts these requests. If the request is to open a file the filter driver will first redirect the request to an isolation environment to determine whether the request may be satisfied by the isolation environment. If the call is successful the filter driver will respond to the request with the instance of the file located in the isolation environment.

However if the requested file does not reside in the isolation environment the filter driver sends a request to streaming service to retrieve the file from the plurality of application files blocks until the request is complete and then retries the original open. In some embodiments the functionality of the streaming service for retrieving files from the plurality of application files upon receipt of a request from the filter driver is referred to as on demand caching. 

Referring now to a flow diagram depicts one embodiment of the steps taken in a method for accessing a remote file in a directory structure associated with an application program executing locally. In brief overview a request by an application for access to a file is intercepted step . The request is redirected to a first isolation environment step . A determination is made that the requested file does not exist in the first isolation environment step . The request is redirected to a second isolation environment responsive to a determination that the file is identified in an enumeration of a directory structure associated with a plurality of application files residing on a remote machine step . The requested file is retrieved from the remote machine responsive to a determination that the second isolation environment does not contain the file and that the file is identified in the enumeration step .

Referring to and in greater detail a request by an application for access to a file is intercepted step . In one embodiment the request is intercepted by a file system filter driver. In another embodiment the file system filter driver intercepts all requests for access to files. In still another embodiment an application streaming client intercepts the request. In some embodiments a request by an application for access to an executable file is intercepted. In other embodiments a request by an application for access to a file a portion of the application executing on a local machine is intercepted.

The request is redirected to a first isolation environment step . In one embodiment the application executes within the first isolation environment. In one embodiment the application is an application program such as a word processing program or spreadsheet program. In another embodiment the application is the application streaming client . In still another embodiment the application is a component within the application streaming client attempting to launch an application program on behalf of a user of the local machine . In another embodiment the file system filter driver redirects the request to the first isolation environment.

A determination is made that the requested file does not exist in the first isolation environment step . In one embodiment the file system filter driver receives an indication that the requested file does not exist in the first isolation environment.

The request is redirected to a second isolation environment responsive to a determination that the file is identified in an enumeration of a directory structure associated with a plurality of application files residing on a remote machine step . In one embodiment the enumeration of the directory structure is received with access information regarding execution of the first application. In another embodiment the enumeration identifies a plurality of application files comprising a second application. In this embodiment the first application is a local copy of the second application.

The requested file is retrieved from the remote machine responsive to a determination that the second isolation environment does not contain the file and that the file is identified in the enumeration step . In one embodiment the requested file is retrieved from a second remote machine. In another embodiment the requested file is retrieved from a file server. In some embodiments the enumeration of the directory structure identifies a plurality of application files residing on the local machine. In other embodiments the enumeration of the directory structure indicates that the plurality of application files resides on the local machine. In one of these embodiments when the application requests access to the file in the plurality of application files which the enumeration of the directory structure has indicated resides on the local machine the file is acquired from the file server upon interception of the access request. In another of these embodiments the file server streams the requested file to the local machine. In still another of these embodiments upon receiving the requested file the requested file is stored in the second isolation environment. In still other embodiments when the application requests access to the file in the plurality of application files which the enumeration of the directory structure has indicated resides on the local machine a copy of the file is provided to the application from a local cache.

In some embodiments the requested file is encrypted. In other embodiments the requested file is stored in an encrypted form. In still other embodiments the application requesting the file may be prevented from decrypting the requested file if the application lacks authorization to access the requested file.

In one embodiment a determination is made that the enumeration of the directory structure does not identify the file. In this embodiment the request to access the file may be redirected to an environment outside the first isolation environment and outside the second isolation environment.

In some embodiments a second request to access the file is intercepted. In one of these embodiments the request to access the file is made by a second application. In another of these embodiments the second application executes in a third isolation environment. In still another of these embodiments the request is redirected to the second isolation environment responsive to a determination that the file is enumerated in the enumeration and that the second isolation environment does contain the file. The determination may be made that the local machine stored the file in the second isolation environment upon receipt of the file from the file server. In yet another embodiment the file is stored in the third isolation environment.

Referring now to a block diagram depicts one embodiment of a system for accessing a file in a directory structure associated with an application. In brief overview a local machine includes an application streaming client a streaming service an isolation environment a file system filter driver and a first application . The local machine may interact with a file server a remote machine a web interface and a second application .

The local machine initializes the application streaming client to execute the first application . In one embodiment the application streaming client initializes a streaming service to retrieve and execute the first application . In some embodiments a plurality of application files comprise the first application . in one of these embodiments the streaming service retrieves the plurality of application files and stores them in the isolation environment . In another of these embodiments the streaming service identifies a location of a remote machine on which the plurality of application files resides but does not retrieve the plurality of application files. In still another of these embodiments the streaming service retrieves a subset of the files in the plurality of application files. In yet another of these embodiments the streaming service retrieves an archive file containing the plurality of application files.

In one embodiment the first application comprises a local copy of a second application residing on a remote machine . In another embodiment the plurality of application files reside on the remote machine and comprise the second application residing on a remote machine . In still another embodiment to execute the second application the local machine retrieves the plurality of application files creating the first application on the local machine and executes the first application . In some embodiments the applications and are user applications such as word processing applications or spreadsheet applications or presentation applications.

In some embodiments the plurality of application files include a file identifying a directory structure associated with the plurality of application files on the remote machine . In one of these embodiments the file includes metadata about each application file in the plurality of application files. In another of these embodiments the streaming service retrieves the metadata from the file to generate an enumeration of the directory structure associated with the plurality of application files as described in connection with above. In still another of these embodiments the streaming service stores the enumeration of the directory structure associated with the plurality of application files comprising the second application . In some embodiments the streaming service stores the enumeration in a second isolation environment.

In one embodiment the streaming service retrieves an initial executable file associated with the first application . In another embodiment the streaming service executes the first application on the local machine upon retrieval of the initial executable file. In still another embodiment the first application requests access to other files in the plurality of application files as the files are needed for continued execution of the first application . In some embodiments the first application executes in the isolation environment .

The file system filter driver intercepts requests by the first application executing within the isolation environment for access to a file in the plurality of application files. The file system filter driver redirects the request to the isolation environment . If the requested file resides in the isolation environment access to the requested file is provided to the first application .

If the requested file does not reside in the isolation environment the file system filter driver redirects the request to a second isolation environment. In one embodiment the second isolation environment includes the enumeration of the directory structure generated by the streaming service and associated with the plurality of application files comprising the second application . In another embodiment a determination is made that the requested file is identified in the enumeration of the directory structure.

In some embodiments the streaming service provides a semaphore to the isolation environment . In one of these embodiments the file system filter driver using the semaphore indicates to the streaming service that access to a file in the plurality of application files is required. In other embodiments the file system filter driver uses a thread to indicate to the streaming service that access to the file is required.

Upon receiving the notification from the file system filter driver the streaming service retrieves the requested file from the plurality of application files. In still another of these embodiments the streaming service stores the requested file in the second application isolation environment. In one embodiment the request for access to the file is satisfied with the instance of the file retrieved from the plurality of application files and stored in the second isolation environment. In another embodiment the requested file is also stored in the first isolation environment.

In some embodiments a determination is made that the second isolation environment does not contain the file and that the file is identified in the enumeration. In one of these embodiments the file is identified in the enumeration of the directory structure associated with the plurality of application files comprising the second application and the file is a file in the plurality of application files. In another of these embodiments the streaming service did not retrieve the file from the remote machine. In still another of these embodiments the streaming service did not retrieve a plurality of application files including the requested file. In yet another of these embodiments the streaming service retrieved the plurality of application files in an archived file but did not retrieve the requested file from the archive file.

In one embodiment the streaming service includes a transceiver in communication with the file system filter driver. In another embodiment the transceiver receives the redirected request from the file system filter driver. In still another embodiment the transceiver forwards the request for the file to a remote machine hosting the requested file. In one embodiment the remote machine is a file server . In another embodiment the request is forwarded to a remote machine which routes the request to a file server . In some embodiments the file server streams the requested file to the transceiver on the local machine . In other embodiments the remote machine streams the requested file to the transceiver on the local machine . In still other embodiments upon receiving the requested file from the file server the transceiver stores the received file in the second isolation environment.

In one embodiment the file system filter driver intercepts a second request for access to the file made by a third application executing on the local machine in a third isolation environment. In another embodiment the file system filter driver redirects the request for access to the file to the second isolation environment. In still another embodiment the file system filter driver determines that the streaming service stored the received file in the second isolation environment prior to the interception of the request for access by the third application .

In some embodiments upon initialization the streaming service may populate a cache in an isolation environment prior to execution of an application program. In one of these embodiments the streaming service installs a registry file into the isolation environment. In another of these embodiments the streaming service stores a mapping between a long name of a file and a short file name.

In one embodiment to save space on the local machine the size of the cache may be limited. In some embodiments when the cache nears its size limit the oldest files in the cache will automatically be purged to make room for new files. In one of these embodiments the age of a file is determined by a timestamp maintained by the operating system indicating a time of last access timestamp. In addition to the age of a file the file type may be taken into account binary executable files .EXE .DLL etc may be kept longer than similarly aged files of other types.

Upon initialization the streaming service may enumerate files currently in a cache and determine the total size of the cache. After a file is added to the cache either by an isolation environment or by the streaming service the streaming service calls a function to inform the cache system of the new file its location and its size. The size of each newly cached file is added to the running total of the current cache size. This new total is then compared against the cache size limit and if the limit has been exceeded the code fires off a thread to age the cache. There can only ever be one instance of this thread running at any given time.

The thread generates a list of all files currently in the cache sorts this list by last access timestamp and then starts walking down the list deleting files until we have freed enough disk space to satisfy the exit criteria for the thread. The exit criteria is based on dropping to cache size down to a level below the limit that is determined as a percentage of the limit the default value is 10 . Deleting more than is needed to prevent exceeding the limit prevents the cache from thrashing each time a new file is added.

In some embodiments the streaming service provides the ability to copy every file in a plurality of application files comprising an application program in a compressed file format to the local machine . This ability may be referred to as pre caching. In one of these embodiments when the application program is subsequently executed all the package requests go to the local copy rather than traversing the network. These embodiments may enable a user of the local machine to execute the application program at a time when the user has no access to the network.

A remote machine includes functionality for monitoring application usage by a local machine . The remote machine may monitor the status of each application used by the local machine for example when execution or termination of an application. In one embodiment the remote machine requires the local machine to transmit messages about the status of an application executed by the local machine . In another embodiment when a local machine connects to a network on which the remote machine resides the local machine transmits a message indicating that the local machine has connected to the network.

In one embodiment the local machine is said to have a session when the local machine interacts with the remote machine and executes one or more applications. In another embodiment the remote machine requires the local machine to maintain for the duration of a session a license authorizing execution of applications received from a remote machine. In still another embodiment sessions have unique session identifiers assigned by the remote machine.

In one embodiment the local machine transmits the messages to the remote machine with which is interacted to receive and execute the application program. In another embodiment the local machine receives from the remote machine an identifier of a second remote machine such as a session management server the second remote machine receiving and storing all transmitted messages associated with the session on the local machine .

In some embodiments the session management server is a remote machine providing license management and session monitoring services. In one of these embodiments the session management server includes a server management subsystem providing these services.

In one embodiment the local machine transmits messages directly to the session management server . In another embodiment the local machine transmits messages to a remote machine the remote machine forwarding the messages to the session management server with an identification of the local machine .

A local machine may transmit a heartbeat message to the remote machine . In one embodiment the heartbeat message includes a request for a license. In this embodiment the local machine may transmit the heartbeat message after receiving access information associated with an application program which the local machine requested authorization to execute. The local machine may transmit the heartbeat message prior to executing the application. In one embodiment the local machine includes with the heartbeat message a launch ticket received with the access information. In this embodiment the remote machine may grant the local machine a license upon successful verification of the launch ticket.

In another embodiment the heartbeat message includes an indication that the local machine has initiated execution of an application. In still another embodiment the heartbeat message includes an indication that the local machine has terminated execution of an application. In yet another embodiment the heartbeat message includes an indication of a failure to execute an application.

In one embodiment the heartbeat message includes a request for an identification of a second session management server such as a session management server . In another embodiment the heartbeat message includes an indication that the local machine has connected to a network on which the remote machine resides.

In some embodiments the heartbeat message includes a request to reset an application streaming session. In one of these embodiments the local machine transmits this heartbeat message when an error has occurred and a connection is terminated between a network on which the remote machine resides and the local machine . In another of these embodiments the local machine transmits with the heartbeat message information associated with the session. In still another of these embodiments the remote machine may transmit to the local machine session related data if the session has not expired.

In another of these embodiments if a remote machine disconnects from a network on which it replies the local machine may not receive a reply to a heartbeat message transmitted to the remote machine . In one embodiment the local machine may re establish a session by transmitting a message requesting a session reset to the remote machine . In another embodiment the local machine may re establish a session by transmitting a message requesting a session reset to a second remote machine . In some embodiments when the remote machine reconnects to the network it will create a new session for each session reset request received while the remote machine was disconnected. In one of these embodiments the new session will be associated with the reconnected and unlicensed state. In another of these embodiments no new license will be acquired for the new session. In still another of these embodiments when the local machine executes an application a new license will be acquired and all sessions associated with the local machine will be associated with an active and licensed state.

In some embodiments an application streaming client on the local machine generates the heartbeat message. In one of these embodiments the application streaming client forwards the heartbeat message to a web interface for transmission to the local machine for transmission to the remote machine . In other embodiments the management service on the remote machine receives the heartbeat message from the local machine via the web interface . In still other embodiments a remote machine comprising a collector point described above in connection with receives and stores the heartbeat messages.

In some embodiments the application streaming client requests a license from the remote machine . In one of these embodiments the license authorizes execution of an application program on the local machine . In another of these embodiments the remote machine may access a second remote machine to provide the license. In still another of these embodiments the remote machine may provide the license to the local machine. In yet another of these embodiments the remote machine may provide a license acceptable for authorization purposes to a second remote machine. In some embodiments the license is revoked upon termination of execution of an application program.

In some embodiments a remote machine in the farm includes a license management subsystem for configuring and maintaining licenses for those subsystems that require a license to operate and for controlling the number of connections to such subsystems. In other embodiments the remote machine incorporates functionality of a license management subsystem within other subsystems such as the application management subsystem and the session management subsystem. In one embodiment each remote machine includes a license management subsystem or the functionality associated with a license management subsystem. The license management subsystem manages two types of licenses 1 feature licenses and 2 connection licenses. In brief overview the license management subsystem uses feature licenses to control access to features of licensed software products such as load management and connection licenses to control the number of user connections allowed by those licensed software products. A feature can be some aspect or particular functionality of the software product or the feature can be the entire product that will not work without a feature license.

The license management subsystem communicates with the group subsystem over an event bus to form and maintain a logical grouping of licenses hereafter license groups to facilitate license pools assignments and groups. A license group includes a collection of license strings described below and or other license groups. License groups collect licenses of similar features and consequently enable pooling of licenses. A pooled license is a license that is available for use by any remote machine in the farm . Each license group holds the collective capabilities of the licenses in the license group and the other license subgroups i.e. other license groups within a license group . Information relating to license pools is in one embodiment maintained in the dynamic store . In this embodiment each license management subsystem stores locally the total number of licenses and the number of license assigned to a remote machine in the farm . Upon granting a pooled license the granting license management subsystem makes an entry in the dynamic store indicating that a pooled license is in use. Every other license management subsystem recognizes that such pooled license is unavailable for granting. In one particular embodiment the dynamic store store remote machine ID client ID pairs associated with each license group to identify pooled licenses that are in use.

The relationship subsystem maintains associations between licenses and remote machines and between license groups and remote machines . The associations define the number of licenses for each license and license group that only the associated remote machine may obtain i.e. local licenses . A local license is a license that is assigned to one remote machine in the farm and is not shared by other remote machines . The license management subsystem communicates with the relationship subsystem to create delete query and update such associations. The common access point subsystem provides remote procedure calls RPCs for use by software products residing on the remote machine . These RPC interfaces enable such software products to communicate through the common access subsystem to access licensing information.

Still referring to the specialized remote machine subsystem communicates with the license management subsystem to obtain a feature license for each capability of the specialized remote machine subsystem for which a license is required. This occurs at initialization of specialized remote machine subsystem and after any license event. If unable to obtain the feature license the specialized remote machine subsystem restricts the functionality that the subsystem would provide with a license. Also the specialized remote machine subsystem uses the license management subsystem to obtain client connection licenses whenever a client session is initiated with the remote machine .

The license management subsystem communicates with the persistent store system service module to store feature and connection licenses in a license repository as license strings formed in accordance with a naming convention. The license repository resides in the persistent store . Cyclical redundancy checks CRC prevent tampering of the licenses while such licenses are stored in the license repository . The license management subsystem also stores information related to the license strings in the license repository . For example the information may indicate which licenses are assigned to which remote machines of the farm and in some embodiments the activation status of each license. In one embodiment a connection license table stores identifiers of those local machines that have obtained a connection license.

In one embodiment the license management subsystem supports events from subsystems requesting use of a licensed capability such as a request for an available pooled license. The event includes the UID of the subsystem requesting the license and the UID of the remote machine upon which that subsystem resides. The event also contains the license type requested i.e. feature or connection license in the form of a license group ID. The actual license group ID stored in the persistent store is arbitrary but adherence to the naming convention provides flexibility for the future addition of new software products i.e. subsystems to the remote machine .

The event sent by a requesting subsystem seeking a license includes 1 an indication of the license group type the identity of the local machine and remote machine requesting the license and a force acquire flag. An indication of license group type may include identification of a feature license such as a load management or a connection type license such as a software application product. The field identifying the local machine and remote machine seeking the license may include the unique identifier associated with the remote machine and the local machine. The force acquire flag may be used for example to reacquire connection licenses after a license change event. A license change event indicates that licensing information in the persistent store has changed for example a license has been deleted added or assigned. Upon a license change event each remote machine attempts to reacquire all connection licenses that it possessed before the license change event because the particular cause of the license change event is unknown to that remote machine. This flag if set indicates that a connection license may be acquired even if doing so increases the number of connections to the remote machine in excess of the predetermined maximum number of allowable connections. No new connection licenses are subsequently granted until the number of connection licenses in use drops below this predetermined maximum number. In this manner a local machine connection will not be terminated in mid session due to a license change event.

Referring now to a block diagram depicts one embodiment of the components involved in licensing enforcement. A remote machine includes a server management subsystem and a license management subsystem . In some embodiments the server management subsystem and the license management subsystem provide the functionality of the license management subsystem described above. In other embodiments an application management subsystem and a session management subsystem provide the functionality of the license management subsystem described above. In still other embodiments other subsystems provide the functionality of the license management subsystem described above.

In one embodiment the server management subsystem may include a licensing component used to request issuance and revocation of licenses. In another embodiment the license management subsystem may apply a policy to a request for issuance or revocation of a license received from the server management subsystem . In still another embodiment the license management subsystem may transmit the request to a remote machine providing license enforcement functionality. In some embodiments the management service may maintain a connection with a second remote machine providing license enforcement functionality. In other embodiments the remote machine provides the license enforcement functionality.

In some embodiments a license expires and ceases to be valid upon a failure of the local machine to transmit a predetermined number of heartbeat messages to the remote machine. In one of these embodiments expiration of the license revokes authorization for execution of an application program by the local machine .

In other embodiments a session times out upon the expiration of a predetermined period of time. In one embodiment the management service maintains session related data after the expiration of a license until an expiration of a session. In some embodiments the session related data may include information such as session name session id client id client name session start time server name UNC Path of File Server application name Unique name generated by local machine based on browser name alias name session state active licensed active unlicensed reconnected unlicensed . In another embodiment the local machine ceases transmission of heartbeat messages and restarts transmission of heartbeat messages at a later point in time. In still another embodiment the management service may reissue a license and make the maintained session related data available to the local machine if the local machine restarts transmission of heartbeat messages prior to the expiration of the session.

Referring now to a flow diagram depicts one embodiment of the steps taken to request and maintain a license from a remote machine for the duration of a session on a local machine . In brief overview an application streaming client requests a license step . A remote machine receives the request for the license verifies a ticket associated with the request and generates a license step . The remote machine provides the license and information associated with the license to the local machine step . The local machine executes the application as described above in connection to step in . The local machine transmits a heartbeat message indicating that the local machine has executed an application step . The remote machine receives the heartbeat message and verifies identifying information transmitted with the heartbeat message step . The remote machine creates a session associated with the executed application and with the local machine step . A result of creating the session is transmitted to the local machine step . The local machine transmits heartbeat messages throughout the execution of the application as described above in connection with step of . The local machine receives a response to a transmitted heartbeat message step . The local machine transmits a heartbeat message indicating a termination of an execution of the application step . The remote machine receives the heartbeat message and determines whether to remove session related data and whether to release the license associated with the local machine and the terminated application step . A result of the determination made by the remote machine is transmitted to the local machine step .

Referring now to and in greater detail an application streaming client on a local machine requests a license step . In some embodiments the local machine requests the license upon receiving access information associated with an application program. In one of these embodiments the local machine requests a license from the remote machine granting authorization for execution of the application program by the local machine . In some embodiments the request for the license includes a launch ticket received from the remote machine with the access information. In other embodiments an application streaming client on the local machine transmits the request to a web interface and the web interface transmits the request to the remote machine . In still other embodiments a session management subsystem on the remote machine receives and processes the request for the license.

A remote machine receives the request for the license verifies a ticket associated with the request and generates a license step . In one embodiment the remote machine verifies that the local machine is authorized to execute the application. In another embodiment the remote machine determines whether the local machine is already associated with an existing license. In still another embodiment the remote machine determines that the local machine is associated with an existing license and provides the local machine with an identifier for a session management server managing the existing license. In yet another embodiment the remote machine generates and provides to the local machine a new license a session identifier and an identification of a session management server managing the new license.

In some embodiments the remote machine uses a license management subsystem to respond to a license request in an embodiment in which. The license management subsystem receives a license request. The request can be for a feature license or for a connection license. The license management subsystem determines if the license has already been granted i.e. the feature has already been started or a connection for a local machine already exists. If the license is already granted the license management subsystem sends a grant event to the license requestor. If the license has not been previously granted the license management subsystem determines if a local license i.e. a license that has been permanently assigned to the remote machine is available. In some embodiments the license management subsystem performs this determination by checking local memory. If a local license is available i.e. the remote machine has more licenses permanently assigned than currently granted the license management subsystem sends a grant event to the license requestor.

The remote machine provides the license and information associated with the license to the local machine step . In one embodiment upon receiving the license the session identifier and the identification of the session management server from the remote machine the local machine executes the application. The local machine may execute the application as described above in connection to step in . The local machine transmits a heartbeat message indicating that the local machine has executed an application step . In one embodiment the local machine transmits the heartbeat message to the remote machine for transmission of the heartbeat message to a session management server . In another embodiment the local machine transmits a heartbeat message directly to a session management server responsive to an identifier of the session management server received from the remote machine .

The remote machine receives the heartbeat message and verifies identifying information transmitted with the heartbeat message step . In one embodiment a remote machine is the session management server . In another embodiment the session management server verifies a server identifier provided with the heartbeat message by the local machine . In still another embodiment the server identifier is the identifier provided to the local machine by a remote machine .

The remote machine creates a session associated with the executed application and with the local machine step . In one embodiment the session management server creates a new session associated with the executing application upon receiving the heartbeat message. In another embodiment a third remote machine creates the new session. In some embodiments the session management server stores session related information upon the creation of the new session.

A result of creating the session is transmitted to the local machine step . In some embodiments the result confirms the creation of the session. In other embodiments the result identifies the application or applications associated with the session. The local machine transmits heartbeat messages throughout the execution of the application as described above in connection with step of . In one embodiment the local machine continues to transmit heartbeat messages at regular intervals to the session management server at periodic intervals throughout the execution of the application program. The local machine receives a response to a transmitted heartbeat message step . In one embodiment the local machine receives a confirmation of receipt of the heartbeat messages from the session management server . In another embodiment the local machine receives a command for execution from the session management server responsive to the receipt of a heartbeat message by the session management server .

The local machine transmits a heartbeat message indicating a termination of an execution of the application step . The remote machine receives the heartbeat message and determines whether to remove session related data and whether to release the license associated with the local machine and the terminated application step . A result of the determination made by the remote machine is transmitted to the local machine step .

Referring now to a block diagram depicts one embodiment of states that may be associated with a session monitored by a management service . In one embodiment a session maintenance subsystem on the management service monitors a session of a local machine and assigns a state to the session. In another embodiment the session maintenance subsystem maintains a list of license related data which may include an identifier associated with the local machine an identifier associated with the session a session state and a timestamp indicating the last time the remote machine received a message from the local machine . In some embodiments the session maintenance subsystem includes a session monitoring thread. In one of these embodiments the session monitoring thread awakens at a periodic license timeout interval to scan the list of license related data and update the session status of a session.

A first state that a session may be in is an active and licensed state. In one embodiment when in this state the local machine has maintained a valid license authorizing execution of an application. In another embodiment a session management server maintains session related data. In some embodiments the session management server stores the session related data on a second remote machine. In one embodiment when a local machine initially executes an application the session for the local machine is in the active and licensed state.

A second state that a session may be in is an active and unlicensed state. In one embodiment a session is in this state when the local machine fails to transmit heartbeat messages and a license to the local machine has expired. In another embodiment if a session is in this state then while the license has expired insufficient time has elapsed for the session to expire and the session is considered active. In some embodiments while a session is in this state a remote machine or a session management server may store session related data on behalf of the local machine . In other embodiments if a local machine transmits a heartbeat message prior to the expiration of the session session related data is transmitted to the local machine with a new license and the session returns to the active and licensed state. In one embodiment a remote machine uses session identifiers and identifiers associated with the local machine to verify that the session has not expired and to provide the local machine with the appropriate session related data.

A third state that a session may be in is a disconnected and non existent state. When a session expires session related data is deleted.

A fourth state that a session may be in is a reconnected and unlicensed state. In one embodiment when a session on a local machine expires session related data is deleted. In another embodiment when the local machine transmits a new heartbeat message a new session identifier and local machine identifier are generated for the local machine . In some embodiments the local machine re authenticates to the remote machine receives a new license and enters the active and licensed state.

In some embodiments a packaging mechanism enables creation of a plurality of application files associated with an application program. In one of these embodiments the packaging mechanism enables identification of a plurality of application files. In another of these embodiments the packaging mechanism enables grouping of individual application files into the plurality of application files. In still another of these embodiments the packaging mechanism enables hosting of the plurality of application files on a remote machine such as a file server or application server.

In one embodiment the packaging mechanism executes on a remote machine described as a staging machine. In another embodiment the packaging mechanism executes on a clean machine. A clean machine may be a remote machine having only an operating system installed on it without additional software drivers registry entries or other files. In still another embodiment the packaging machine executes on a remote machine the remote machine resembling a local machine on which an application program may execute. In some embodiments the remote machine on which the packaging mechanism executes includes an isolation environment providing a clean machine environment into which an application may be installed even where the remote machine is not itself a clean machine.

In one embodiment the plurality of application files is referred to as a package. In another embodiment the package may be an archive file storing the plurality of application files. In still another embodiment the package may be an archive file storing the plurality of application files and a file including metadata associated with at least one file in the plurality of application files. In some embodiments a package includes a plurality of application files comprising an application program. In other embodiments a package includes a plurality of application files comprising a suite of application programs. In yet other embodiments a package includes a plurality of application files comprising an application program and a prerequisite required for execution of the application program.

In one embodiment the packaging mechanism initiates execution of an installation program in an isolation environment. In another embodiment the packaging mechanism monitors a change to the isolation environment generated by the installation program. In still another embodiment the packaging mechanism monitors a creation by the installation program of a file in the isolation environment. In yet another embodiment the packaging mechanism monitors a modification by the installation program of a file in the isolation environment. In some embodiments the plurality of application files includes a file created or modified by the installation program. In other embodiments the packaging mechanism implements a file system filter driver to monitor the isolation environment.

In some embodiments a packaging mechanism may generate multiple pluralities of application files each comprising a different version of an application program configured for execution in a different target environment. In one of these embodiments a plurality of application files is configured to execute on a local machine having a particular operating system revision level language configurations and master drive e.g. one plurality of application files may be configured to execute on a local machine having the Windows XP Professional operating system with revision level SP2 and above using English and having a master Drive C . In another of these embodiments more than one plurality of application files may be combined in a single archive file. In still another of these embodiments each plurality of application files may be referred to as a target. In yet another of these embodiments an archive file containing one or more pluralities of application files may be referred to as a package. 

Referring now to a block diagram depicts a package including two targets each target comprising a plurality of application files comprising an application. In the application program Foo is packaged in two targets. The difference between the two targets is Target Language . Specifically target supports English and target supports German . In one embodiment an enumeration of available application programs may list the application program Foo. In another embodiment the appropriate plurality of files is transmitted to a local machine requesting access to the application program. In still another embodiment a determination is made to transmit a particular target to a local machine responsive to an evaluation of the local machine. In yet another embodiment a file associated with the package identifies at least one characteristic associated with a target in the package and required for execution on a local machine.

In some embodiments the packaging mechanism prepares an application program for streaming by executing an installation program associated with the application program. In one of these embodiments the packaging mechanism generates an isolation environment on the remote machine on which the packaging mechanism executes. In another of these embodiments the packaging mechanism executes the application program in the isolation environment. In still another of these embodiment the packaging mechanism identifies a plurality of application files generated or modified by the installation program. In yet another of these embodiment the packaging mechanism creates an archive file including the plurality of application files. In one of these embodiments the packaging mechanism creates a .CAB file including the plurality of application files. In another of these embodiments the packaging mechanism creates a directory and stores the plurality of application files in the directory. In some embodiments the packaging mechanism stores the plurality of application files on a file server or other remote machine . In other embodiments the packaging mechanism stores the plurality of application files on multiple remote machines.

Referring now to a flow diagram depicts one embodiment of the steps taken in a policy based method for effectively installing an application program without rebooting an operating system. In brief overview a packaging mechanism executes an installer program within an isolation environment the installer program installing at least one application file associated with a second application into the isolation environment step . A call by the installer program to at least one application programming interface API is intercepted the call requiring performance of an action after a reboot of an operating system step . The action of the at least one intercepted call is executed without reboot of the operating system step . An identification of a file type of the at least one application file is received step . At least one execution method is associated with the at least one installed application file responsive to the identified file type step . The at least one installed application file is stored on at least one server step . An enumeration is generated of the second application the at least one installed application file a location of the at least one server and the at least one execution method step .

Referring now to and in greater detail a packaging mechanism executes an installer program within an isolation environment the installer program installing at least one application file associated with a second application into the isolation environment step . In one embodiment executing the installer program within the isolation environment enables the packaging mechanism to isolate changes made by the installer program to a file or registry on the local machine. In another embodiment the packaging mechanism intercepts a change requested by the installer program and redirects the change to the isolation environment to prevent the change from occurring on the local machine. In still another embodiments the packaging mechanism executes a second installer program within the isolation environment the second application installing at least one application file associated with a third application into the isolation environment.

In some embodiments the packaging mechanism executes the installer program within the isolation environment the installer program executing at least one executable application associated with an application inside the isolation environment. In one embodiment in which the installer executes an application execution of the application enables installation of a second application.

In another of these embodiments installation of an application requires execution of the at least one executable application in addition to the execution of the installer program. In still another of these embodiments installation of an application requires execution of an Internet browser application in addition to the execution of the installer program. In some embodiments an installer program is executed to install a program and execution of the installer program includes execution of a second program required to install the program. In one of these embodiments the program is a plug in. In another of these embodiments the program is an Active X component. In still another of these embodiments the program is a Flash component. In yet another of these embodiments the program is a customized toolbar such as a Yahoo or Google toolbar. In other embodiments the program is a component installed into the second program and not executable independent of the second program.

A call by the installer program to at least one application programming interface API is intercepted the call requiring performance of an action after a reboot of an operating system step . The action of the at least one intercepted call is executed without reboot of the operating system step . In some embodiments execution of the action comprises executing an action of a registry entry modified during installation. Further details regarding the execution of the at least one intercepted call without reboot of the operating system are provided in connection with below.

An identification of a file type of the at least one application file is received step . At least one execution method is associated with the at least one installed application file responsive to the identified file type step . In one embodiment the at least one execution method enables streaming of the at least one application file to a client. In another embodiment the at least one execution method enables execution of the at least one installed application file on a client. In still another embodiment the at least one execution method enables execution of the at least one installed application file on a server. In yet another embodiment the at least one execution method enables streaming of the at least one application file to a server.

The at least one installed application file is stored on at least one server step . In some embodiments the installed application program is executed within the isolation environment prior to storing the at least one installed application file on at least one server. In one of these embodiments an additional application file is generated responsive to the execution of the installed application program. In another of these embodiments a data file is generated. In still another of these embodiments the installed application program requires information to complete installation the information being required after an initial installation process. In yet another of these embodiments information such as software product identifiers license identifiers or other credentials is required.

In some embodiments an identifier is provided identifying a location of the at least one installed application file on the at least one server. In one of these embodiments the identifier conforms to a Universal Naming Convention UNC . In other embodiments the at least one installed application file is placed in an archive file such as a .CAB file. In one of these embodiments a plurality of application files are stored in an archive file and the archive file is stored on the at least one server. In still another of these embodiments the at least one installed application file is stored on multiple servers. In still other embodiments the at least one application file is placed in a directory storing application files.

An enumeration is generated of the second application the at least one installed application file a location of the at least one server and the at least one execution method step . In some embodiments the enumeration is stored in a file. In other embodiments the enumeration is stored in a manifest file. In still other embodiments the enumeration is stored in an XML file.

In one embodiment an enumeration is generated of multiple applications a plurality of installed application files associated with each of the multiple application and a location of at least one server storing the plurality of installed application files. In another embodiment a enumeration is generated including an association between the second application and a plurality of installed application files. In still another embodiment an enumeration is generated including an association between the second application and a compressed file containing the at least one installed application file

Referring now to a flow diagram depicts one embodiment of the steps taken in a policy based method for installing an application program without rebooting an operating system. In brief overview a packaging mechanism executes an installer program within an isolation environment the installer program installing at least one application file associated with a second application into the isolation environment step . A call by the installer program to at least one application programming interface API is intercepted the call requiring performance of an action after a reboot of an operating system step . The action of the at least one intercepted call is executed without reboot of the operating system step . An identification of a characteristic of the at least one application file is received step . At least one execution pre requisite is associated with the at least one installed application file responsive to the identified characteristic step . The at least one installed application file is stored on at least one server step . An enumeration is generated of the second application the at least one installed application file a location of the at least one server and the at least one execution pre requisite step .

Referring now to and in greater detail a packaging mechanism executes an installer program within an isolation environment the installer program installing at least one application file associated with a second application into the isolation environment step . In one embodiment executing the installer program within the isolation environment enables the packaging mechanism to isolate changes made by the installer program to a file or registry on the local machine. In another embodiment the packaging mechanism intercepts a change requested by the installer program and redirects the change to the isolation environment to prevent the change from occurring on the local machine. In still another embodiments the packaging mechanism executes a second installer program within the isolation environment the second application installing at least one application file associated with a third application into the isolation environment.

In some embodiments the packaging mechanism executes the installer program within the isolation environment the installer program executing at least one executable application associated with an application inside the isolation environment. In one embodiment in which the installer executes an application execution of the application enables installation of a second application. In another of these embodiments installation of an application requires execution of the at least one executable application in addition to the execution of the installer program. In still another of these embodiments installation of an application requires execution of an Internet browser application in addition to the execution of the installer program.

Referring ahead to a block diagram depicts one embodiment of a system including a packaging mechanism executing an installer program into an isolation environment and a file system filter driver in communication with the packaging mechanism and the isolation environment .

In one embodiment the packaging mechanism generates a package as described above in connection with by installing an application program into an isolation environment . In another embodiment the packaging mechanism installs the application program into the isolation environment by executing the installer program . In some embodiments the packaging mechanism includes a graphical user interface. In one of these embodiments the graphical user interface enables a user of the packaging mechanism to customize the generation of a package by the packaging mechanism . In another of these embodiments the packaging mechanism is in communication with a graphical user interface on the access control suite enabling a user of the access control suite to customize the generation of a package by the packaging mechanism .

In some embodiments the file system filter driver enables the installation of the application program in an isolation environment . In one of these embodiments the file system filter driver intercepts a request by the installer program . In another of these embodiments the file system filter driver redirects the request by the installer program to the isolation environment . In still another of these embodiments the file system filter driver stores a record of the request made by the installer program . In yet another of these embodiments the file system filter driver stores a copy of a file created or modified by the installer program . In some embodiments the stored records generated by the file system filter driver are stored together as a plurality of application files comprising an application program. In other embodiments the plurality of application files is stored on a file server .

Referring back to a call by the installer program to at least one application programming interface API is intercepted the call requiring performance of an action after a reboot of an operating system step . The action of the at least one intercepted call is executed without reboot of the operating system step . In some embodiments execution of the action comprises installation of a driver configured to be started upon the boot of the computer system. In other embodiments execution of the action comprises executing an action of a registry entry modified during installation.

An identification of a characteristic of the at least one application file is received step . In some embodiments an identification of an operating system type is received. In other embodiments an identification of a language used by operating system is received. In still other embodiments an identification of a version of the second application is received.

At least one execution pre requisite is associated with the at least one installed application file responsive to the identified characteristic step . In one embodiment the at least one execution pre requisite is associated with the at least one installed application file responsive to an application of a policy to the characteristic. In another embodiment a script is associated with the at least one installed application file the script comprising an executable program determining the existence of the at least one execution pre requisite on a client. Referring ahead to a screen shot depicts one embodiment of an enumeration of scripts to be executed on the local machine. A type of script indicates when the script should be executed for example either before the execution of the application or after termination of execution of the application. An isolation indicator indicates whether the script should be executed in an isolation environment on the local machine . As shown in in some embodiments the script was associated with the application program at the time the plurality of application files were packaged together and stored on the remote machine hosting the plurality of application files.

In some embodiments the at least one execution pre requisite requires installation of a version of an operating system on a system executing the at least one installed application file. In other embodiments the at least one execution pre requisite requires installation of a version of the second application on a system executing the at least one installed application file. In still other embodiments an instruction is associated with the at least one installed application file the instruction indicating a second installed application file for use by a client failing to satisfy the at least one execution pre requisite. In yet other embodiments an instruction is associated with the at least one installed application file the instruction indicating a second execution method for execution of the at least one installed application file on a client failing to satisfy the at least one execution pre requisite. In one of these embodiments an execution method is associated with the at least one installed application file the execution method authorizing streaming of a plurality of application files comprising the second application to a local machine for execution on the local machine. In another of these embodiments an evaluation of a local machine identifies at least one characteristic associated with the at least one installed application file not included on the local machine. In still another of these embodiments authorization for execution of the plurality of application files is revoked. In yet another of these embodiments a second execution method is provided for executing the plurality of application files the second execution method enabling execution of the plurality of application files on a remote machine and transmission of application output data from the remote machine to the local machine.

The at least one installed application file is stored on at least one server step . In some embodiments the installed application program is executed within the isolation environment prior to storing the at least one installed application file on at least one server. In one of these embodiments an additional application file is generated responsive to the execution of the installed application program. In another of these embodiments a data file is generated. In still another of these embodiments the installed application program requires information to complete installation the information being required after an initial installation process. In yet another of these embodiments information such as software product identifiers license identifiers or other credentials is required.

In some embodiments an identifier is provided identifying a location of the at least one installed application file on the at least one server. In one of these embodiments the identifier conforms to a Universal Naming Convention UNC . In other embodiments the at least one installed application file is placed in an archive file such as a .CAB file. In one of these embodiments a plurality of application files are stored in an archive file and the archive file is stored on the at least one server. In still another of these embodiments the at least one installed application file is stored on multiple servers. In still other embodiments the at least one installed application file is placed in a directory storing application files.

An enumeration is generated of the second application the at least one installed application file a location of the at least one server and the at least one execution pre requisite step . In some embodiments the enumeration is stored in a file. In other embodiments the enumeration is stored in a manifest file. In still other embodiments the enumeration is stored in an XML file.

In one embodiment an enumeration is generated of multiple applications a plurality of installed application files associated with each of the multiple application and a location of at least one server storing the plurality of installed application files. In another embodiment a enumeration is generated including an association between the second application and a plurality of installed application files. In still another embodiment an enumeration is generated including an association between the second application and a compressed file containing the at least one installed application file

Referring back to step where an action of the at least one intercepted call is executed without reboot of the operating system in some embodiments a virtualized installation and execution environment is provided that removes the requirement of rebooting the system before executing an installed application.

Referring now to a flow chart depicts an embodiment in which execution of an installer program requires rebooting of an operating system on a local machine on which the installer program executes. A conventional application installer copies files onto a remote machine where the application is being installed step . In some embodiments copying the files may cause a reboot of the remote machine. The application installer attempts to copy at least one of the files to locked files step . In one embodiment a locked file may only be written to when an operating system is executed or rebooted . The MOVE FILE DELAY UNTIL REBOOT option is set in the MoveFileEx Win32 API step and the application installer calls system shutdown reboot function step . Following a reboot the originally locked files are then installed upon reboot step .

Referring now to a block diagram depicts one embodiment of a remote machine onto which a packaging mechanism installs an application program. The remote machine includes system resources system APIs and an application installer used to install an application. The remote machine also includes a function hooking mechanism a post install processor module and an application isolation environment . In some embodiments installing an application program into an isolation environment enables installation without reboot of the remote machine . In one of these embodiments a change made to a system resource virtualized in an isolation environment does not change a corresponding system resource on the remote machine . Since the system resource on the remote machine is not changed rebooting the machine to protect the system resource from inappropriate changes is not required.

Referring now to and in greater detail the system resources may include registry entries system DLLs and other locked files that the operating system prevents from being written to while the remote machine is executing. The system APIs include APIs used to reboot the system that are called by the application installer and hooked by the function hooking mechanism to prevent the rebooting of the remote machine .

The application isolation environment provides an environment with a view of operating system resources to an application installer . In one embodiment the application isolation environment is an isolation environment . In some embodiments the application isolation environment provides virtualization of operating system resources such as the file system registry and named objects. In one embodiment the application installer executes within the application isolation environment . In another embodiment the application installer installs the application program into the application isolation environment . In still another embodiment the application installer executes outside the application isolation environment and installs the application program inside the application isolation environment .

In some embodiments the application isolation environment circumvents the requirement for rebooting the remote machine when the application installer installs an application into the application isolation environment . In one embodiment the application isolation environment intercepts a request to copy an application file to a locked file. In another embodiment the application isolation environment redirects the request to copy the application file to an unlocked file. In still another embodiment the application isolation environment redirects the request to copy the application file to a virtualized file. In yet another embodiment redirecting the request to copy the application file enables installation of application files without requiring a reboot of the remote machine . As an example if an application installer attempts to write to a locked file such as c windows system32 mfc40.dll the application isolation environment intercepts the request and redirect the file to another unlocked location. This ability to avoid locked files means the file can be installed without having to make use of the MoveFileEx API and MOVE FILE DELAY UNTIL REBOOT flag. This ability in removes the need for a reboot of the remote machine .

In one embodiment the function hooking mechanism is a file system filter driver . In another embodiment a file system filter driver includes the function hooking mechanism . In still another embodiment the function hooking mechanism intercepts requests from the application installer to restart the remote machine . In some embodiments the application isolation environment provides for copying of application files to unlocked files. However the application isolation environment does not address a request by the application installer for reboot of the remote machine . The function hooking mechanism intercepts the request for reboot and responds to the application installer .

The application isolation environment enables copying of application files to unlocked files. However in some embodiments other actions are required for installation of an application and these actions may occur upon the reboot. Preventing the reboot does not prevent the need to complete these actions in the installation process. The function hooking mechanism may provide functionality for carrying out an action associated with an installation of an application

For example during the installation of an application registry entries such as HKLM SYSTEM CurrentControlSet Control Session Manager Pending FileRenameOperations may be written. Other applications may install services or drivers which need to be started upon boot of a machine. The Post Install Processor Module identifies application files that have been modified during installation and carries out the actions associated with the application files.

Referring now to a flow diagram depicts one embodiment of the steps followed to install an application in an application isolation environment . The application isolation environment provides a virtualized view of the server operating system to the application installer step . The APIs on the server relating to system reboots and shutdowns are hooked step to prevent the application installer from causing a reboot. The application installer requests file copying operations to locked files the request being intercepted and redirected to non conflicting locations step . When the application installer attempts to reboot by calling a system API the request is intercepted and the reboot is prevented step . The post install processor module performs actions that ordinarily occur after reboot step and the application may then be executed in the application isolation environment without reboot of a remote machine step .

In some embodiments following installation of the application program into the application isolation environment a packaging mechanism identifies a plurality of application files created or modified during installation of an application program. In one of these embodiments the plurality of application files are stored on a remote machine. In another of these embodiments a local machine retrieving the plurality of application files may execute the application program.

In some embodiments the packaging mechanism executes on a remote machine including an isolation environment and a file system filter driver and installs an application program into the isolation environment . In one of these embodiments the remote machine is referred to as a clean machine or a staging machine. In another of these embodiments the isolation environment includes an application isolation scope providing a modifiable virtualized instance of a native resource provided by an operating system on the clean machine. In still another of these embodiments the isolation environment includes a system isolation scope providing a read only view of the native resource. In yet another of these embodiments the read only view of the native resource comprises a snapshot of a file system and registry residing on the clean machine.

In one embodiment a redirector intercepts a request for a change to the native resource. In some embodiments the redirector is a file system filter driver . In another embodiment an installer program executed by the packaging mechanism makes the request for the change. In still another embodiment the change to the native resource is required to install an application program on to the clean machine. In yet another embodiment the redirector redirects the request to the isolation environment .

In some embodiments redirecting requests to change native resources to the isolation environment results in isolation of changes associated with installation of an application program. In other embodiments the requests to change native resources are recorded and stored in a storage element. In one of these embodiments all changes associated with installation of an application program reside in the storage element. In another of these embodiments a local machine retrieving the contents of the storage element and implementing the changes to native resources residing in an isolation environment on the local machine result in installation of the application program on the local machine .

In some embodiments a pre launch analysis of the local machine may be required. In one of these embodiments the local machine verifies that at least one characteristic is included in the local machine . In another of these embodiments the at least one characteristic is added to the local machine after the pre launch analysis determines that the local machine lacks the at least one characteristic. In still another of these embodiments the at least one characteristic is included in a remote machine hosting an application program and failure of the local machine to include the at least one characteristic will prevent execution of the application program. In yet another embodiment the application program requires existence of the at least one characteristic on the local machine for execution.

In some embodiments the packaging mechanism enables identification of at least one characteristic for use in a pre launch analysis on the local machine. In other embodiments the packaging mechanism enables association of at least one characteristic with an application program available for execution on the local machine. In still other embodiments the packaging mechanism enables association of an executable script with an application program the local machine executing the executable script to complete the pre launch analysis. In yet other embodiments the at least one characteristic is required to exist on the local machine after the execution of the application program.

The packaging mechanism may provided functionality for signing a plurality of application files. In one embodiment signing the plurality of application files enables a local machine to verify integrity of the plurality of application files. In another embodiment signing the plurality of application files prevents a local machine from executing a corrupted application program. In some embodiments a cryptographic checksum such as an MD4 hash an MD5 hash or a SHA 1 hash of a file in the plurality of application files is computed.

In other embodiments a cryptographic checksum of every file in the plurality of application files is computed. In one of these embodiments the cryptographic checksum is stored in a second file. In another of these embodiments the second file is associated with the plurality of application files. In some embodiments the second file is added to the plurality of application files. In other embodiments the second file is signed using a certificate such as an X.509 certificate. In still other embodiments a local machine retrieving the plurality of application files verifies the signature using a public portion of the certificate. In yet other embodiments the local machine receives the public portion of the certificate and an identification of a certificate trust list for verification of the signature. In one of these embodiments local machine receives a registry key containing the identification of a certificate trust list.

In one embodiment the packaging mechanism provides functionality for customizing an isolation environment. In another embodiment the packaging mechanism provides functionality for generating a file storing a definition of an isolation environment. In still another embodiment the packaging mechanism includes the file with the plurality of application files comprising an application program. In yet another embodiment a local machine receives the file with access information from a remote machine.

In some embodiments a plurality of application files are stored in an archive file. In one of these embodiments the archive file is in a CAB file format. In another of these embodiments the archive file format does not provide support for specification by an application program of a short file names of a file. In still another of these embodiments an operating system such as WINDOWS 2000 may not provide support for specification by an application program of a short file names of a file. In other embodiments an operating system such as WINDOWS XP provides support for specification by an application program of a short file name of a file. In one of these embodiments a request to execute the file may include the correct short file name of the file.

In one embodiment a mapping may be generated to associate a long file name of a file in the plurality of application files with a short name of the file. In another embodiment the mapping is stored in a file in the plurality of application files. In still another embodiment a file has a short file name only if the long file name of the file is longer than twelve characters. In some embodiments the short file name is a virtual file name associated with the file. In one of these embodiments the file is transmitted to a local machine for execution where it is stored with a long file name. In another of these embodiments an application file on the local machine requests execution of the file using the short file name. In still another of these embodiments the mapping enables execution of the file although the request for execution of the file did not use the name of the file on the local machine the long file name .

In some embodiments the packager mechanism generates the mapping. In one of these embodiments the packager mechanism selects a short file name for a file having a long file name. In another of these embodiments an operating system on the remote machine on which the packager mechanism is executing selects a short file name for a file having a long file name. In still another of these embodiments a unique short file name is selected that does not conflict with a second short file name on the remote machine . In yet another of these embodiments the installer program executed by the packager mechanism generates a file including a mapping between a long file name with a short file name. In other embodiments the mapping is transmitted to a local machine retrieving the file. In one of these embodiments the local machine refers to the file when executing the file.

The following illustrative examples show how the methods and systems discussed above can be used for selecting streaming to a local machine and executing on the local machine a plurality of files comprising an application program. These examples are meant to illustrate and not to limit the invention.

In one embodiment a user of a local machine requests access to an application program such as a word processing program a web browsing application or a spreadsheet program identified in an enumeration of application programs. In one example of this embodiment the local machine executes a program neighborhood application that receives from a remote machine an enumeration of applications available to the local machine . In another example of this embodiment the local machine communicates with a web server such as remote machine to receive the enumeration of applications. The user of the local machine may request access to an enumerated application program by selecting a graphical depiction representing the enumerated application program. The user of the local machine may request access to an application program not previously installed on the local machine .

The local machine transmits the request to access the application program to a remote machine . The local machine receives an identification of a remote machine providing access to a plurality of application files comprising the application program. The local machine identifies at least one characteristic required for execution of the application program. In one example of this embodiment the local machine receives the at least one characteristic with the identification of the remote machine transmitted to the local machine by the remote machine . In another example of this embodiment the local machine retrieves the at least one characteristic from the remote machine after receiving the identification of the remote machine . The local machine may be required to comprise the at least one characteristic prior to receiving authorization to retrieve the plurality of application files. Alternatively the local machine may be required to comprise the at least one characteristic prior to executing the plurality of application files. In one example of this embodiment the local machine may be required to comprise the at least one characteristic throughout the execution of the plurality of application files.

Upon verification by the local machine that the local machine includes the at least one characteristic the local machine retrieves a least one application file in the plurality of application files and executes the retrieved application file to execute the application program.

A remote machine receives a request to access an application program from a local machine . The remote machine authenticates the local machine . In one example of this embodiment the remote machine requests credentials such as a user name and password from the local machine . In another example of this embodiment the remote machine transmits a collection agent to the local machine . The collection agent gathers information about the local machine and transmits the information to the remote machine for use in authenticating the local machine . In still another example of this embodiment the remote machine provides information about the local machine to a policy engine for authentication of the local machine . The remote machine may comprise the policy engine . Alternatively the remote machine may be in communication with a remote machine comprising the policy engine .

The remote machine selects a method of execution of the application program. The remote machine may make the selection responsive to the authentication of the local machine . In one example of this embodiment the remote machine applies a policy to information gathered about the local machine . In another example of this embodiment the remote machine makes the selection responsive to a policy applied to the application program. In still another example of this embodiment the remote machine makes the selection responsive to a policy applied to a file type associated with the application program. The remote machine may consult a file to make the selection of the method of execution of the application program.

The remote machine may select a method of execution of the application program enabling the local machine to receive application output data generated by execution of the application program on a remote machine . The remote machine may select a method of execution of the application program enabling the local machine to execute the application program locally after retrieving a plurality of application files comprising the application program.

In one embodiment the remote machine selects a method of execution of the application program enabling the local machine to execute the application program locally while retrieving a plurality of application files comprising the application program across an application streaming session. In one example of this embodiment the local machine establishes an application streaming session with a remote machine hosting a plurality of application files the local machine initiates retrieval of the plurality of application files across the application streaming session and the local machine executes a retrieved first application file in the plurality of application files while retrieving a second application file in the plurality of application files. In another example of this embodiment the local machine executes a first application file in the plurality of application files and retrieves a second application file in the plurality of applications upon receiving a request from the first application file for access to the second application file.

For embodiments in which the selected method of execution enables the local machine to retrieve at least one application file in a plurality of application files comprising an application program the remote machine identifies a remote machine hosting the application program available for access by the local machine . The remote machine hosts a plurality of application files comprising the application program. The remote machine may host multiple pluralities of application files comprising various application programs. In one example of this embodiment the remote machine hosts a plurality of application files for each of several different versions of an application program.

The remote machine hosts a file associating a plurality of application files comprising a particular application program with a description of the application program. The file may also identify one or more execution pre requisites to be identified on a machine prior to the transmission of the plurality of application files to the machine. The file may further include an identification of a location on a network of the remote machine . In one example of this embodiment the remote machine consults the file to identify the location on the network of the remote machine .

The remote machine selects a remote machine . The remote machine may select a remote machine having a location on a network accessible to the local machine . The remote machine may select a remote machine hosting a version of the application program compatible with the local machine . The remote machine transmits an identification of the selected method of execution of the application program and an identification of the remote machine to the local machine in response to receiving the request for access to the application program. The remote machine may also transmit the file to the local machine .

In one embodiment the local machine receives an identification of a selected method of execution of an application program and an identification of a remote machine providing access to a plurality of application files comprising the application program. The local machine verifies authorization of access to the application program. In one example of this embodiment the local machine performs a pre launch analysis of itself. The local machine identifies at least one characteristic and verifies the existence of the at least one characteristic on the local machine . The at least one characteristic may be a pre requisite to maintaining authorization to access and execute the application program. Verifying the existence of the at least one characteristic on the local machine may ensure compatibility between characteristics of the local machine and the system requirements of the application program and may additionally ensure compliance with security policies or licensing agreements.

Upon successful completion of a pre launch analysis the local machine establishes an application streaming session with the remote machine providing access to the plurality of application files. The application streaming session may be any connection over which the local machine may request and receive a file in the plurality of application files. Establishment of the application streaming session may enable the local machine to execute a first application file in the plurality of application files prior to retrieval of all files in the plurality of application files. The local machine may initiate execution of the application program while continuing retrieval of additional application files in the plurality of application files. Alternatively the local machine may retrieve the plurality of application files in an archive file and execute a first extracted application file while extracting a second application file from the archive file.

In one embodiment an application streaming client on a local machine retrieves a plurality of application files from a remote machine . The application streaming client includes a streaming service an isolation environment and a file system filter driver . The streaming service establishes an application streaming session with the remote machine for requesting and retrieving the plurality of application files. The streaming service executes the application files within the isolation environment . The file system filter driver enables execution of application files within the isolation environment by intercepting requests from the execution application files and redirecting the requests to the isolation environment .

In one example of this embodiment the streaming service retrieves an archive file including the plurality of application files comprising an application program. The streaming service extracts from the archive file a first application file from the plurality of application files. The first application file may be an executable file. The streaming service may execute the first application file within the isolation environment . Execution of the first application file may initiate execution of the application program.

In another embodiment a first application file executing within the isolation environment requests from the local machine an enumeration of the plurality of application files. The file system filter driver intercepts the request for the enumeration and redirects the request to the streaming service . In embodiments where the streaming service retrieved the plurality of application files the streaming service may generate an enumeration of the plurality of application files. In embodiments where the streaming service retrieved an archive file including the plurality of application files the streaming service may generate the enumeration of the plurality of application files responsive to an enumeration included in the retrieved archive file. In other embodiments the streaming service retrieves only the enumeration of the plurality of application files while at least one application file in the plurality of application files resides on a remote machine and has not yet been retrieved to the local machine by the streaming service . In these embodiments the streaming service may generate an enumeration of the plurality of application files responsive to the retrieved enumeration. In one example of these embodiments the streaming service indicates to the first application file that the plurality of application files resides on the local machine although only the enumeration resides on the local machine .

In one embodiment a first application file executing within the isolation environment requests from the local machine access to a file identified by the enumeration of the plurality of application files. If the requested file resides in a user scope within the isolation environment accessible to the first application file the first application file accesses the requested file.

If the requested file does not reside in the user scope or in the isolation environment the file system filter driver intercepts the request and redirects the request to the streaming service . If the requested file is a file within the archive file containing the plurality of application files the streaming service extracts the requested file and stores the requested file on the local machine . The streaming service may store the file within the isolation environment . The request for the file is satisfied when the file is stored in the isolation environment .

If the requested file does not reside in the isolation environment or in the archive file including the plurality of application files the streaming service requests the file from the remote machine . The streaming service may receive the file from the remote machine across an application streaming session. The streaming service stores the received file in the isolation environment . The request for the file is satisfied when the file is stored in the isolation environment .

In one example of this embodiment a second application file executes in a second user scope in the isolation environment . The second application file requests access to the file originally requested by the first application file. If a copy of the requested file does not reside in the second user scope the copy of the requested file stored in the isolation environment is used to satisfy the request for the application file.

In one embodiment a local machine receives from a remote machine an identification of a selected method of execution of an application program and an identification of a remote machine providing access to a plurality of application files comprising the application program. The local machine successfully completes a pre launch analysis of the local machine . The local machine receives a license from the remote machine authorizing execution of the application program. In one example of this embodiment the license requires the local machine to transmit heartbeat messages to a session management server to maintain authorization to execute the application program. Heartbeat messages may include messages indicating initiation of execution of an application program termination of execution of an application program and messages sent on a periodic basis throughout the execution of the application program. Heartbeat messages may also include messages about the status of the local machine such as when the local machine connects to a network or when the local machine terminates a connection to a network. In another example of this embodiment the license specifies a pre determined period of time during which the local machine has authorization to execute the application program.

The local machine establishes an application streaming session with the remote machine and retrieves at least one of the application files in the plurality of application files. During execution of the at least one application file in embodiments where the received license requires transmission of heartbeat messages the local machine sends heartbeat messages to the session management server to maintain authorization to execute the at least one application file.

In one embodiment the local machine receives an identification of a selected method of execution of an application program and an identification of a remote machine providing access to a plurality of application files comprising the application program. The local machine successfully completes a pre launch analysis of the local machine . The local machine receives a license specifying a pre determined period of time during which the local machine has authorization to execute the application program.

The local machine establishes an application streaming session with the remote machine and retrieves at least one of the application files in the plurality of application files. In one example of this embodiment the local machine retrieves a subset of the plurality of application files the subset comprising each file necessary to execute the application program when the local machine is not connected to a network. The local machine stores the subset in a cache on the local machine .

At a point in time within the pre determined period of time the local machine is disconnected from a network and receives from a user of the local machine a request for access to the application program. In one example of this embodiment the local machine is a device such as a laptop and the user of the local machine is in an environment prohibiting connections to networks such as an airplane. Upon receiving the request from the user the local machine may retrieve from the cache an application file from the plurality of application files and execute the application program.

In another embodiment the local machine receives an identification of a selected method of execution of an application program and an identification of a remote machine providing access to a plurality of application files comprising the application program. The local machine may receive an identification of a first client agent residing on the local machine to execute to retrieve the plurality of application files such as an application streaming client.

In one example of this embodiment the local machine fails to successfully complete a pre launch analysis of itself. The local machine may lack a characteristic required for compatibility with a requirement of the application program such as a particular device driver or operating system. The local machine may lack a characteristic required for compliance with a security policy for example membership in a particular Active Directory or authorization for access to a private network. The local machine may be a type of machine incompatible with a requirement of the application program such as a personal digital assistant attempting to access a computationally intensive application program or a public machine at a kiosk attempting to execute a secure application hosted by a remote machine on a private network.

The local machine makes a determination not to retrieve the plurality of application files across the application streaming session responsive to the determination that the local machine lacks the at least one characteristic required for access to the application program. The local machine executes a second client agent residing on the local machine instead of executing the identified first client agent. In one example of this embodiment the local machine receives an identification of the second client agent to execute in the event of failure to successfully complete the pre launch analysis. The local machine requests execution of the application program on a remote machine . The second client agent receives application output data generated by the execution of the application program on the remote machine . The second client agent displays the application output data on the local machine .

In one embodiment an administrator of a network provides access to an application program for users of local machines . The administrator executes an application on a remote machine to generate a plurality of application files comprising the application program. The application may include a graphical user interface. The administrator may use the graphical user interface to identify the application program and an installer program associated with the application program define policies to be applied in authorizing access to the application program and specify characteristics about the type of access provided including requirements to be satisfied by a local machine attempting to access or execute the application program. The administrator may identify an installer program installing an entire application program or a portion of an application program such as an upgrade or patch.

In one example of this embodiment a remote machine includes a packaging mechanism . The packaging mechanism executes the installer program within an isolation environment on the remote machine . Execution of the installer program results in installation into the isolation environment of at least one application file associated with the application program. The remote machine may include a file system filter driver which ensures the installation of the application file into the isolation environment by intercepting a request by the installer program to install the application file on the local machine and redirecting the request to the isolation environment . The packaging mechanism may use the file system filter driver to maintain a record of each application file installed into the isolation environment .

The installer program may install a plurality of application files into the isolation environment . The packaging mechanism generates a file including an enumeration of application files in the plurality of application files. The file may include information associated with the plurality of application files such as the type of application program the plurality of application files comprise the version of the application program execution pre requisites associated with the application program and policy requirements such as a method of execution required for a particular application program. The packaging mechanism stores on a remote machine the plurality of application files and the file.

In one embodiment the administrator of the network identifies an application program comprising an updated version of an existing application program or application file in a plurality of application files comprising an application program.

The application may be provided as one or more computer readable programs embodied on or in one or more articles of manufacture. The article of manufacture may be a floppy disk a hard disk a compact disc a digital versatile disc a flash memory card a PROM a RAM a ROM or a magnetic tape. In general the computer readable programs may be implemented in any programming language. Some examples of languages that can be used include C C C or JAVA. The software programs may be stored on or in one or more articles of manufacture as object code.

While the invention has been shown and described with reference to specific preferred embodiments it should be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention as defined by the following claims.

In some aspects the present disclosure further relates to systems and methods for enhanced application streaming that supports profiling and execution of applications which may use local client machine system services as a part of their execution environment. The systems and methods presented may also enable an application executed in an isolated environment of the client machine to use the services of the local client machine which may be outside of the application s isolated environment. For example in embodiments in which a client machine includes an isolated environment within which an application operates services which may support this application may be provided from outside of the application s isolated environment. Therefore these systems and methods may enable the service supported applications to work seamlessly in the isolation environment even if such applications use the services of the local client machine which may be operating outside of the application s isolation environment and separate from user space.

By creating an isolation environment for services or processes which need to run on the client machine and separately from the isolation environment of the application being supported by the processes the systems and methods of the present disclosure allow for preservation of high privileges for the services while allowing the services to run on the client machine. Similarly by using a separate isolation environment within which to run services may communicate with the remote server as would the application. The isolation environment for the services may be created using user credentials which may be already cleared by the system for authentication and access. The services may be in communication with the application they service as well as in communication with the remote server. The isolation environment for the services may include a number of components described herein for creating and maintaining the isolation environment as well as for controlling and managing the services within the environment. Furthermore the isolation environments for services enable running or executing of the services in a separate context from the application which they support because the application operates within an isolation environment independent from the isolation environment in which the services operate. In addition the isolation environments for the services enables the services to have privileges which are higher or greater than the privileges which may be granted by the client to applications such as the Rapid Application Delivery Rade applications.

A service used by an application operating on the client machine may be a privileged executable. In some embodiments a service may be run or executed outside the context of a user session. In further embodiments the service is run outside of an isolation environment of the application. In certain embodiments a service is run when the system is booted or restarted. In specific embodiments the service is run or executed when the application requests that the service be loaded. In some embodiments services run or executed to aid the application may need to be executed under isolation. In further embodiments the isolation of the service aiding the application may be separated from the isolation environment of the application. By separating the isolation environment of the service from the isolation environment of the application the service may be enabled to have privileges that do not infringe on the client s or the remote server s security.

A service may provide an application with a service of conducting an operation of high privilege. This may be additionally useful for applications which may be categorized as low privilege applications. In some embodiments some services may require higher privileges for some applications than the same applications may be granted. In certain embodiments the higher privileges of the services supporting the applications are provided by executing the services in their own isolation environments which are independent from the isolation environments of the application or the session of the user. Ignoring isolation services may be implemented such that there is a single service of a particular kind or type per client machine. In some embodiments services may provide a central place for instances of an application that may be run in multiple logon sessions to communicate with a central single instance. In some embodiments services include one or more command line applications. In further embodiments services include no GUI. In still further embodiments services include a command line input output which may generally not be viewable. In further embodiments services implemented in isolation environments may include command line input outputs that may be accessible and viewable.

In some embodiments Services may be run with a number of predefined privileges. For example on Microsoft systems privileges for services may include LOCAL SERVICE with low privileges NETWORK SERVICE with higher privileges than LOCAL SERVICE and access to the network or LOCAL SYSTEM with higher privileges than NETWORK SERVICE but can not access the network .

From some operational standpoints services may be similar to applications. Accordingly in some embodiments just like with applications the services may be also isolated. Services may also be privileged. Isolating a service may include executing or running the service inside a profile sandbox or an isolation environment. The service operating in the sandbox may perform operations on a disk and registry. These operations may be intercepted and redirected to other locations as is common for other applications under isolation. While some services may be run or executed only once for the global machine there may be an instance of the service created for the profile such as a user profile. From such instance of the service created all sandboxes that may started from the profile may share this single instance of service. When the service is from different profiles then multiple instances may be created.

Services may be controlled by a Service Control Manager SCM . An SCM may create a service. The SCM may initiate manage start stop pause and delete a service. The SCM may manage services based on a request. In some embodiments a CreateProcessInternalW function in SCM may monitor the starting of service processes. The SCM may further use an HKLM Software Citrix IsolatedSevices Key to see if the initiated or launched service is to be isolated. Whenever a request to start a service is sent to the SCM the SCM may check a list to ascertain whether the service being started or initiated also needs to be isolated. If the SCM determines based on the list that the service is to be isolated the SCM may create a sandbox or the isolated environment and put the service in the sandbox. Once the service is started the SCM may manage the isolated service just like any other service. In some embodiments the SCM manages or treats the isolated service the way an application operating in it s own isolated environment is managed. Each isolated service may therefore run or execute in its own sandbox just like an independent application. In some embodiments the service uses a user token in order satisfy any authentication issues and in order to receive any necessary permissions from the client machine to run and operate in an independent sandbox. In some embodiments the userroot of the user is used by the service in order to execute. The sandbox of the service may be treated by the client machine as a sandbox that is created by the user from session zero. In some embodiments the client machine does not differentiate between a sandbox created by the SCM comprising a service to support an operation of a user and a sandbox created from session zero by the user for the application. The service may run in the context in which the service control manager launches it.

Services may be isolated using the Service Control Manager SCM. The services may register with SCM and SCM may facilitate the start stop pause operations on the services. The service process may be run as part of a sandbox that is created from the service user session zero and GUID of the profile. All service from the same user and profile GUID may be configured to run in accordance with the user provided privilege. When a process is launched and if there is a service in one of the profiles in case of IIC then a sandbox may be created for the service. The service sandbox may run until all of the service processes die or the system is rebooted. In some embodiments the service sandbox runs even when all the service processes are inactive or dead.

The service isolation architecture may encompass one or more components. In some embodiments the service isolation architecture includes the SCM. The SCM may include services.exe which may be installed along with the operating system. Isolation service architecture may further include one or more service processes. Service processes may be installed by the application during profiling. The service isolation architecture may also include the Isolated Streamed Application which may include the application running inside a sandbox. In some embodiments Client Service Hooks which may include or be added to CtxsbxHook.dll CreateProcessInternal hooks which may include or be added to CtxsbxHook.dll and Rade service may be included in the service isolation architecture.

In some embodiments the term hooking such as hooking of a hooked function for example may cover a range of techniques used to alter or augment the behavior of an application software an operating system component or a function. Hooking may be implemented by modifying function calls or messages events or any other communications passed between the software components or functions. Code that handles such intercepted function calls events or messages may be referred to as a hook and the function which may be affected may be referred to as a hooked function. Hooking may be used for extending functionality. In some embodiments functions of the present disclosure are hooked such that the functionality for creating managing or modifying isolation environments and operation of services within isolation environments is enabled or provided.

The Service Control Manager SCM may be a Windows service control manager process services.exe. SCM may be responsible for controlling as well as managing all the aspects of services running on the system. Service Isolation design may use SCM for handling all the services and service specific aspects. The service process may include a process which may be run inside an isolation environment such as the isolation environment of the application or an isolation environment different from the isolation environment of the application. The application may be a streamed application. The application such as a streamed application may include the process running inside the isolation environment. This application may be either fully or partially depended upon one or more services. In some embodiments the application uses the isolated services to run properly. Client Service Hooks may include components active in the streamed application to monitor the service creation and starting. CreateProcessInternal hook may comprise a module created in the SCM. This component may be responsible for identifying the isolated service start and may take the appropriate action of isolating the service process. Rade Service may include services for reading services from the profile populating the profile s service database requesting for creation deletion and starting of isolated services to Rade helper Service. In some embodiments Rade service may not include the privileges of creating and starting the services. Rade service may also be responsible for sandboxing service on client side. Radehlprsvc may be referred to as the Rade help service. Rade help service may run as a system. Rade help service may include privileges to Create Delete and Start the services. This service may minimize the attack surface. Since Rade Service may include a lot of end points which may be exposed to attacks. For this reason Rade help service may provide a new service with higher privileges which can be contacted only by Rade service.

The hooked CreateService function may change certain parameters before invoking the original CreateService function. To differentiate between the isolated services and normal services the service name may be mangled and binary path may be set to actual physical path of service EXE path inside radecache location . Once the relevant parameters are modified the parameters may be passed onto the original CreateService function which may inform the SCM to install the specified service. Once the service is installed the service may create the new registry entry under following registry key which may be reserved for storing all the installed services HKEY LOCAL MACHINE System CurrentControlSet IsolatedServices

If the CreateService function call is successful then this call may be recorded along with all the parameters into the installed services database within the profile. This recorded information may be used later to install these services on the client machine wherever this application is streamed. During profiling all the installed services may be deleted at the end of profiling operation to ensure that base system registry remains clean. Also since the profiler runs with administrative privilege the profiler may have enough rights to install or delete the services.

A single user environment may refer to a streaming client installed in the client version of the platform. In such instances one or more users may be logged in at one time. In such environment a sandbox may be created when a streamed application is launched. If a created sandbox includes services that are isolated all the isolated services with automatic start may be started. There may be an instance of the service that would be running or that would be created and then shared by other sandbox created from same profile. In some embodiments two profiles may have the same service service with same name . In some embodiments such occurrences happen when the both profiles have two different versions of the same application installed. For example one profile may run Microsoft Office 2003 version while another profile may run Microsoft office version. In such cases services from both profiles may conflict due to conflict in RPC endpoints.

A multiuser environment may refer to sandboxes created in stream to server or STS scenarios. In some embodiments treatment of the sandbox and the services is substantially similar as a treatment of a single user environment. When multiple sandboxes from the same profile are created the service may be started in only one sandbox and may be shared by all other sandboxes. In some embodiments such a configuration preserves the singleton behavior of the service and avoids any endpoint collision for service using sockets RPC etc. In further embodiments issues may be faced when two profiles having same service names run simultaneously. For example the Microsoft Office 2007 and the Microsoft Office 2007 operated by two users may encounter issues if two different users are using these two profiles. In some embodiments a conflict may occur if services are ran at the same time. In some embodiments no conflicts occur.

An isolated service may be started based on the start type. An automatic start may include services which may be started when the sandbox is created from the profile. Such services may continue to run until the system is rebooted or shut down. A manual start may include services which may be started when there is a start service from within isolated process. These services may continue to run till the service is stopped or system is rebooted. In some embodiments when shutting down the system there might arise problems due to arbitrary order of shutting services down. When a service is created and started from the version one of the profile and the subsequent application launch finds an upgraded version two of the profile the running version of the service may be stopped or deleted. The service from the newer profile may then be started. This may fail the current application calls to the service. The application may not communicate with the service for some time. In some embodiments the application does not stop communicating with the service. If the application has stopped communicating with the service the communication may be resumed after a period of time. When the profiled application deletes the service the service may be deleted and the service entries may be removed from internal store. During profiling there may be a sandbox which may be using the service. In some embodiments the service may be safely deleted during profiling

The isolated service may be visible to processes running outside of isolation. In some embodiments the isolated services are not visible to the processes running outside of isolation. In further embodiments no communication is exchanged between the isolated and non isolated processes.

A custom user may be provided and given a varying privilege level. An admin may choose which one suits best for the service requirements. In some embodiments the services running as a local service network service or a local system are all supported. In some embodiments global named objects the objects created with Global prefix may be used. In some embodiments local named objects with user identifier and a session identifier which may be prefixed as local prefix may be used. In some embodiments if an application wants to share a named object with a service running in separate session the application may share the named object via Global objects. In some embodiments Global prefixes and or global named objects are mangled or obfuscated. In other embodiments global prefixes and or global named objects are not mangled or obfuscated. Similarly local prefixes and local named objects may or may not be mangled or obfuscated depending on the preference or the application.

In some embodiments services may run in the sandbox created for them as user of the service. So the user root of the service may include the user context on which the service is launched. In some embodiments the service operates irrespective of the context on which the service is launched. The user root may be flushed using the radecache utility. The isolated service may be isolated by using a user token to satisfy the authentication and or permissions necessary to create an isolation environment for the service. Services started during profiling may be supported. In some embodiments services that are created or started and then deleted during the profile time may be supported. For example an Office update may use OSE service to upgrade the application.

The table below presents embodiments of API calls that may be used with the system and methods of the present application 

The service may be seen by the end user in the service control manager. The service may not be masked from the service control manager. In some embodiments the service may include a name mangled with a constant string. Within an isolated application the service may be identified with the actual name. The user may not be able to start the isolated services inside isolation from the service control manager. In some embodiments only isolated applications can start the services. The service control manager may run inside isolation in order to start isolated services.

When a profile is updated all services installed in the profile may be created and those which are automatic start configured may be started. Also when the profiled application is streamed to the client all the recorded services need to be installed before the application is started. This may be accomplished by installing all the recorded services via the RadeHelperService which runs as system within the profile before actually starting the application.

An isolated application may open a service. Applications may use the OpenService API function to open the handle to an installed service. This handle may be used to perform various operations such as starting stopping controlling querying the service. Like the CreateService function the OpenService function may also be hooked to provide a virtual view of a service to the streamed application. Whenever the streamed application tries to open any service the application may land up in the hooked function. Inside this hooked OpenService function the service name parameter may be changed to its mapped name and then passed onto the original OpenService function. If the service does not exist inside isolation we can pass the original unmangled name to the OpenService API.

Applications may use the OpenService and then the StartService function to start the installed service. The StartService function may invoke an RStartService function within the SCM. This function may retrieve the binary path of the service from the registry database and then use the CreateProcess or CreateProcessAsUser function to create the service process in suspended mode. Both these functions may internally call the CreateProcessInternal function to create the process. A hook in the CreateProcessInternal function may take care of isolating the service. Once the service process is created a unique name may be created to communicate with the service.

In order to support service isolation the CreateProcessInternal function within the SCM process services.exe may be hooked to alter its behavior with respect to streamed services. When the application invokes the StartService function to start the service the application may first land up on a hooked Start Service call where the application may mark the service to be isolated by writing in the HKLM Software Citrix IsolatedServices registry Key. The application may then place a call with the SCM from where the application may end up in the hooked CreateProcessInternal function in the SCM where the application may check the HKLM Software Citrix IsolatedServices key to see if the service needs to be isolated. If the service needs to be isolated the service process may be created in suspended mode and then sandboxed. In some embodiments only users having access to the HKLM Software Citrix IsolatedServices key can start an isolated service. After reading this Key the SCM may delete the registry subkey with the name of the service to ensure that the locally installed services inside the isolation environment may be started. The sandbox may be created for the user for which the service runs or for session zero. This configuration may ensure that the service uses the user root of the service user and not that of the process that imitated the launch of the service.

Next in the RStartService function after the response returns from the CreateProcess function a named pipe may be created to communicate with the service process. Then the application uses the actual service the process may handle responses returned from the CreateProcess function to resume the service process. The real service process may run under the same isolation environment as the streamed application. Also all the service related communication between the SCM and the isolated service process happens seamlessly over the named pipe.

Referring now to embodiments of systems and methods which may include the flow of actions or events for starting or using the services is depicted.

Referring to steps of embodiments of a method are depicted. At step An application is launched via either PNagent or Dazzle and RadeRun is spawned. At step RadeRun launches RadeLauncher in suspended mode. At step RadeRun makes an RPC call to RadeService and requests that the application sandbox RadeLauncher. At step RadeService goes to the remote share to read the profile if trusted in order to create sandbox rules. At step RadeService checks if the profile has services if so the application requests that the RadeHelperService create the service with a mangled name outside isolation. At step RadeHelperService creates the service with a mangled name outside isolation and if the service happens to be configured to auto start RadeHelperService starts the service. At step StartService ultimately ends up in the SCM CreateProcessInternal hook where the application launches the service in suspended mode. At step The SCM then makes a call to RadeService to create a sandbox with this suspended process and resumes the service. Now the service is up and running in the sandbox. At step The call now returns to RadeService which then returns the call to RadeRun notifying that RadeLauncher has been successfully sandboxed. RadeRun then resumes RadeLauncher. At step RadeLauncher then does a ShellExecute on the application to be launched and the isolated application comes up. At step The isolated application comes up and communicates with the isolated service.

Once the isolated service is started the streamed application may use the ControlService or StopService function to stop pause or continue the service. These functions may finally invoke an RControlService or RStopService function within the SCM which then may send the appropriate control commands to the isolated service over the named pipe. All these control events may be handled independently by the SCM without any need to intercept these functions. Service names may have mapped names which may be created in the profiling system during profiling. All the services may be deleted at the end of the profiling operation. This may be done to make sure that the profiler system is clean otherwise installed services may remain in the base system s registry.

Isolated services may be created in the client system with mapped names. Such a service may run as a part of a sandbox created on behalf of the service user or in session zero. These services may continue to run until the system is rebooted or RadeCache FlushAll is called. Isolated services may be deleted when the RadeCache is flushed. However deletion of a service from within an isolation environment may not be allowed on the client side.

Applications may use the GetServiceKeyName API to retrieve the name of a specified service. Like the CreateService function the GetServiceKeyName function may be hooked to provide a virtual view of a service to the streamed application. Whenever a streamed application tries get the name of a service from the display name the application may use a hooked function. Using a hooked function such as the GetServiceKeyName function the application may check whether or not the passed display name is for an isolated service. Then a query may be made to an internal data base. In some embodiments an original API call may be made. Applications may use the QueryServiceConfig API configuration parameters of a specified service. Like the CreateService function the QueryServiceConfig function may also be hooked to provide a virtual view of a service to the streamed application. Whenever a streamed application calls QueryServiceConfig the application may end up in the hooked function. Inside this hooked QueryServiceConfig function an internal data base may be checked to see if the application requires an isolated service. If so the original API call may be sent to retrieve the information and then de mangle the required entries and pass the application back to the caller.

Applications may use the ChangeServiceConfig and ChangServiceConfig2 APIs to configure parameters of a specified service. Like other service related APIs the ChangeServiceConfig and ChangServiceConfig2 functions may also be hooked to provide a virtual view of a service to the streamed application. Whenever a streamed application calls QueryServiceConfig the application may end up in the hooked function. Using this hooked ChangeServiceConfig function the application may check the internal data base to see if the application requires an isolated service. If yes a call to the original API is made to retrieve the information and then the internal database is updated. Services may use the RegisterServiceCtrlHandler to register a function for handling service control requests. Like other service related APIs RegisterServiceCtrlHandler may be hooked to provide a virtual view of a service to the streamed application. Whenever an isolated service calls RegisterServiceCtrlHandler the application may end up in the hooked function. Using this hooked RegisterServiceCtrlHandler function the application may check the internal data base to see if it requires an isolated service if yes a call to the original API with a mangled service name is made. Services may use StartServiceCtrlDispatcher to connect the main thread of a service process to the service control manager which may cause the thread to be the service control dispatcher thread for the calling process. Like other service related APIs StartServiceCtrlDispatcher may also be hooked to provide a virtual view of a service to the streamed application.

