---

title: Systems, methods and apparatus for distributed decision processing
abstract: Methods, apparatus, and computer software product for making a decision based on the semantics of formal logic are provided. In an exemplary embodiment, two custom computing apparatuses are used to resolve the satisfiability of a logical formula and provide an example. In this embodiment, the two custom computing apparatuses operate in concert to explore the space of possible satisfying examples. This Abstract is provided for the sole purpose of complying with the Abstract requirement rules. This Abstract is submitted with the explicit understanding that it will not be used to interpret or to limit the scope or the meaning of the claims.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08688619&OS=08688619&RS=08688619
owner: Reservoir Labs
number: 08688619
owner_city: New York
owner_country: US
publication_date: 20100308
---
This application is related to and claims the benefit of priority to U.S. Provisional Application Ser. No. 61 158 665 entitled ALEF A SAT SOLVER FOR MPI CONNECTED CLUSTERS filed Mar. 9 2009 the entirety of which is hereby incorporated by reference.

Portions of this invention were made with U.S. Government support under DARPA ACIP program contract number W31P4Q 05 C R171. The U.S. Government has certain rights.

The present invention generally concerns data processing. More particularly the invention concerns a system methods and apparatus for distributed decision processing.

Distributed decision models are useful in a variety of problems. One important area where distributed decision processing has seen some benefit is within an area known in the art as Boolean Satisfiability SAT problems. SAT problems arise in a number of arenas but one of importance is in the field of integrated circuit design and verification. As the demand for more functional consumer electronics has increased so has the complexity of the integrated circuits powering the consumer electronics. With the increase in the complexity of the circuit there have been significant increases in the challenges within the design and verification of these more complex circuits.

In the verification process there are a number of computerized techniques employed. For example a common technique for verification of digital designs is known as model checking. Model checking is typically implemented with a Binary Decision Diagram BDD . With recent advances in SAT solvers they are proving to be a reasonable alternative to BDD s in digital circuit verification. A given Boolean formula is considered satisfiable if all the variables in the formula can take on such values to make the formula evaluate to true. Alternatively and potentially more important if no combination of values can be found that forces the function to evaluate to true then the formula is unsatisfiable.

SAT solvers typically require the function to be expressed in Conjunctive Normal Form CNF which is a conjunction of clauses where a clause is a disjunction of literals. A literal is either a variable name or its negation. A satisfying assignment returned by the SAT solver corresponds to a counterexample of length k. If the problem is unsatisfiable at length k the SAT returns a proof that there are no counterexamples of length less than or equal to k.

The DPLL Davis Putnam Logemann Loveland algorithm is a complete backtracking based algorithm for deciding the satisfiability of propositional logic formulae in conjunctive normal form i.e. for solving the CNF SAT problem. The basic backtracking algorithm runs by choosing a branching literal assigning a truth value to it simplifying the formula and then recursively checking if the simplified formula is satisfiable. If this is the case the original formula is satisfiable otherwise the same recursive check is done assuming the opposite truth value. This is known as the splitting rule as it splits the problem into two simpler sub problems. The simplification step essentially removes all clauses which become true under the assignment from the formula and all literals that become false from the remaining clauses.

Multiple contributions well known by engineers knowledgeable in the field have been proposed in the literature mainly in three directions 1. defining different policies for choosing the branching literals 2. defining new data structures to make the algorithm faster especially the part on unit propagation and 3. defining variants of the basic backtracking algorithm. The latter direction includes non chronological backtracking and clause learning. These refinements describe a method of backtracking after reaching a conflict clause which learns the root causes assignments to variables of the conflict in order to avoid reaching the same conflict again. Intuitively backtracking can be viewed as jumping back to the root problem in a sequence of decisions and making the opposite decision.

The following strategies are well known by engineers knowledgeable in the field Restarts have been previously introduced in the literature as a way to break a sequence of bad decision by starting over at certain points in the resolution and resetting the heuristic that chooses the branching literals. Number of learned clauses per conflict each conflict can be summarized by multiple learned clauses that avoid reaching this conflict again. Traditional algorithms have been using one of such clause per conflict. Conflict clause minimization has been introduced in the literature and is a technique to make the learned conflict clauses as small as possible. Decision replay has been introduced in the literature to replay decisions that were not proven bad. The intuition is to avoid discarding useful choices when a backtracking goes too far to undo the root decision problem. Database compaction the number of clauses can grow to unmanageable sizes database compaction discards learned clauses.

With complex digital designs verification approaches can be significantly complex and the memory limits of a computer can be quickly reached. Therefore there exists a need for more efficient SAT solvers.

The present invention provides a system apparatus and methods for distributed decision processing. Various embodiments of the present invention provide a method apparatus and computer software product for generating solutions to logical decision problems through the use of multi processing element computing apparatus. In one embodiment a method is provided that receives a formula in a memory the method then generates multiple replications of the formula. In some embodiments the number of replications of the formula is related to the number of processing elements available on the computing apparatus. The provided method then assigns one replication to a first processing element and another to a second processing element. Each of the processing elements is then configured to solve the formula using in some embodiments different solution tactics. The method further allows each of these processing elements to communicate with each other over a message passing interface. In some embodiments information passed across the message passing interface is used by the receiving processing element in its solution of the formula.

In another embodiment of a provided method the parametric space of options available to each of a plurality of processing elements is defined. In some embodiments this space is related to decision procedures available to the processing elements. In this method a choice of instantiation of one or more of the procedures is additionally distributed to the processing elements. Each of the processing elements may then separately instantiate a subset of options in the space based on its choice of instantiation.

Another embodiment provides a custom computing apparatus. This custom computing apparatus contains a number of processing elements and a memory. Contained within the memory are a set of processor executable instructions that when executed by at least one of the processors configures the custom computing apparatus to generate a solution to a logical decision problem. In one embodiment of this configuration a formula is received in a memory the configuration then generates multiple replications of the formula. In some embodiments the number of replications of the formula is related to the number of processing elements available on the computing apparatus. The configuration then assigns one replication to a first processing element and another to a second processing element. Each of the processing elements is then configured to solve the formula using in some embodiments different solution tactics. The configuration further allows each of these processing elements to communicate with each other over a message passing interface. In some embodiments information passed across the message passing interface is used by the receiving processing element in its solution of the formula.

A further embodiment of a custom computing apparatus is additionally provided. In this embodiment the computing apparatus also contains multiple processing elements and at least one memory that is in communication with these elements. Contained within the memory is a set of processor executable instructions that when executed by at least one of the processing elements configure the computing apparatus to define the parametric space of options available to each of a plurality of processing elements. In some embodiments this space is related to decision procedures available to the processing elements. In this configuration a choice of instantiation of one or more of the procedures is additionally distributed to the processing elements. Each of the processing elements may then separately instantiate a subset of options in the space based on its choice of instantiation.

In another embodiment a computer software product is provided. The computer software product includes a non transitory medium with a set of processor executable instructions. These instructions are such that when executed by a processing element contained with a multiple processing element computing apparatus they configure the apparatus to generate a solution to a logical decision problem. In one embodiment of this configuration a formula is received in a memory the configuration then generates multiple replications of the formula. In some embodiments the number of replications of the formula is related to the number of processing elements available on the computing apparatus. The configuration then assigns one replication to a first processing element and another to a second processing element. Each of the processing elements is then configured to solve the formula using in some embodiments different solution tactics. The configuration further allows each of these processing elements to communicate with each other over a message passing interface. In some embodiments information passed across the message passing interface is used by the receiving processing element in its solution of the formula.

A further provided embodiment of a computer software product additionally includes a non transitory medium with a set of processor executable instructions on it. In this embodiment the instructions are sufficient that when executed by at least one processing element of a multiple processing element computing apparatus they configure the apparatus to define the parametric space of options available to each of a plurality of processing elements. In some embodiments this space is related to decision procedures available to the processing elements. In this configuration a choice of instantiation of one or more of the procedures is additionally distributed to the processing elements. Each of the processing elements may then separately instantiate a subset of options in the space based on its choice of instantiation.

These and other features and advantages of the present invention will be appreciated from review of the following detailed description of the invention along with the accompanying figures in which like reference numerals refer to like parts throughout.

It will be recognized that some or all of the Figures are schematic representations for purposes of illustration and do not necessarily depict the actual relative sizes or locations of the elements shown. The Figures are provided for the purpose of illustrating one or more embodiments with the explicit understanding that they will not be used to limit the scope or the meaning of the claims.

In the following paragraphs the present invention will be described in detail by way of example with reference to the attached drawings. While this invention is capable of embodiment in many different forms there is shown in the drawings and will herein be described in detail specific embodiments with the understanding that the present disclosure is to be considered as an example of the principles of the invention and not intended to limit the invention to the specific embodiments shown and described. That is throughout this description the embodiments and examples shown should be considered as exemplars rather than as limitations on the present invention. Descriptions of well known components methods and or processing techniques are omitted so as to not unnecessarily obscure the invention. As used herein the present invention refers to any one of the embodiments of the invention described herein and any equivalents. Furthermore reference to various feature s of the present invention throughout this document does not mean that all claimed embodiments or methods must include the referenced feature s .

As used in this application the terms component module system and the like are intended to refer to a computer related entity either hardware firmware a combination of hardware and software software or software in execution. For example a component can be but is not limited to being a process running on a processor an integrated circuit an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computing device and the computing device can be a component. One or more components can reside within a process and or thread of execution and a component can be localized on one computer and or distributed between two or more computers. In addition these components can execute from various computer readable media having various data structures stored thereon. The components can communicate by way of local and or remote processes such as in accordance with a signal having one or more data packets e.g. data from one component interacting with another component in a local system distributed system and or across a network such as the Internet with other systems by way of the signal .

Moreover various functions described herein can be implemented in hardware software firmware or any combination thereof. If implemented in software the functions can be stored on or transmitted over as one or more instructions or code on a computer readable medium. Computer readable media is non transitory in nature and includes both computer storage media and communication media including any medium that facilitates transfer of a computer program from one place to another. A storage media can be any available media that can be accessed by a computer. By way of example and not limitation such computer readable media can comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer. Also any physical connection is properly termed a computer readable medium. For example if the software is transmitted from a website server or other remote source using a coaxial cable fiber optic cable twisted pair digital subscriber line DSL or wireless technologies such as infrared radio and microwave then the coaxial cable fiber optic cable twisted pair DSL or wireless technologies such as infrared radio and microwave are included in the definition of medium. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and blu ray disc BD where disks usually reproduce data magnetically and discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

Additionally in the subject description the word exemplary is used to mean serving as an example instance or illustration. Any embodiment or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other embodiments or designs. Rather use of the word exemplary is intended to present concepts in a concrete manner.

Embodiments of the present invention provide a custom computing apparatus illustrated in that is configured to optimize computer source code for operation on a second computing apparatus. As illustrated first custom computing apparatus is configured to communicate with second computing apparatus across network . A further illustration of computing apparatus is provided in . In this illustration custom computing apparatus contains at least one processor a communication port communicating with the at least one processor . Custom computing apparatus additionally includes memory which in some embodiments includes dependence analysis module . Custom computing apparatus in some embodiments additionally includes drive configured to accept external storage medium . In some embodiments external storage medium is a CD in others a DVD. In these embodiments drive is configured to accept the appropriate external storage medium . While CD and DVD are specifically enumerated in these embodiments there are many external storage media that can be used to practice various aspects of the invention therefore some embodiments are not limited to the particular drive configuration or external media . Custom computing apparatus additionally includes storage medium . Storage medium in some embodiments is a hard disk drive and in others is a solid state drive. In some embodiments storage medium contains a set of processor executable instructions that when executed by the at least one processor they configure custom computing apparatus to optimize computer code for execution on computing apparatus . While custom computing apparatus and computing apparatus are illustrated in communicating over network various embodiments of the invention do not require this inter computer communication. As used herein the term processing element can be a processor or an execution unit on a processor. Additionally each processor may contain multiple execution units.

Various embodiments of the present invention are directed to processors containing multi stage execution units and in some embodiments multiple execution units. By way of example and not limitation to the particular multi stage execution unit illustrates exemplary multi stage execution units . In one embodiment a 6 stage execution unit is utilized. In this embodiment the stages may include instruction fetch instruction decode operand address generation operand fetch instruction execute and result store. In another depicted multi stage architecture the stages include instruction fetch instruction fetch register decode execute memory access and register write back. During routine operation of a multi stage execution unit instructions are processed sequentially moving from stage to stage. In scheduling operations on multi stage execution unit processors there are inherent difficulties that arise. For example one instruction in one stage of the pipeline may attempt to read from a memory location while another instruction is writing to that location. This problem is confounded in the instance of multiple processing cores. Additionally in multiple processor and or multiple core architectures the locality of data to the execution unit attempting access can create significant delays in processing. Additionally some provided embodiments include the use of multiple processing elements. In some embodiments these processing elements are threads in a multi threaded processor in others they are individual processors. In still further embodiments they are processing cores or execution units.

As is known in the art the Boolean satisfiability problem SAT is a problem that seeks to determine if the variables of a given Boolean formula can be assigned in a way as to make the formula evaluate to 1 or true . If the set of inputs can be so assigned the formula is satisfiable . On the other hand if no such assignment exists this implies that the formula is identically equal to 0 or false for all possible inputs. In this case the formula is considered unsatisfiable. Most SAT solvers require the formula under verification to be expressed in conjunctive normal form CNF as a conjunction of clauses which is a disjunction of variables or their negations. For example the CNF formula a OR b AND NOT b OR c is satisfiable if a 0 b 1 and c 1.

Various embodiments of the present invention are directed to improvements on the DPLL Davis Putnam Logemann Loveland algorithm. As is known in the art the DPLL algorithm is a backtracking based algorithm for deciding the satisfiability of propositional logic formulae in conjunctive normal form i.e. for solving the CNF SAT problem. The basic backtracking algorithm runs by choosing a branching literal assigning a truth value to it simplifying the formula and then recursively checking if the simplified formula is satisfiable if this is the case the original formula is satisfiable. Otherwise the same recursive check is done assuming the opposite truth value. This is known as the splitting rule as it splits the problem into two simpler sub problems. The simplification step essentially removes all clauses which become true under the assignment from the formula and all literals that become false from the remaining clauses.

Various improvements on the DPLL algorithm that are known in the art are typically classified in three areas. First is in defining different policies for choosing the branching literals. The second area is in defining new data structures to make the algorithm faster. The third is in the area of defining variants of the basic backtracking algorithm. This last direction includes non chronological backtracking and clause learning. These refinements describe a method of backtracking after reaching a conflict clause which learns the root causes assignments to variables of the conflict in order to avoid reaching the same conflict again. Intuitively backtracking can be viewed as jumping back to the root problem in a sequence of decisions and making the opposite decision.

One method known in the art for determining if a formula is satisfiable is Conflict Directed Clause Learning. In this method conflict clauses are derived from logical implications of the original formula clauses that encapsulate learned information about mutually unsatisfiable assignments. The discovery of a conflict clause initiates a backtrack within the current candidate set of assignments to a point that resolves the conflict. For an instance running on a single processor the conflict clause generation and backtrack routines are tightly coupled. The problem being solved is to abstract these operations in such a way that conflict clauses can be received from external processes while initiating the proper backtrack. The requirement is that the conflict clause received is a properly formatted conflict derived from the initial replicated clause set independent of the specific tactics employed in deriving it.

Embodiments of the present invention include systems methods and apparatus to manage previously known solution tactics in a novel manner and additionally introduce new tactics. For example the following pseudo code illustrates a binary back propagation solution tactic. In this example the input parameters are as follows stack the assignment stack reasons a structure that maps the assigned literals to the clauses that forced the assignment and conflict a list of literals forming conflict . The pseudo code function returns the parameter result which is the list of literals forming the resulting conflict.

An exemplary embodiment of a provided method is illustrated in . In this embodiment a formula for a logical decision problem is received in memory in block . In block a first solution tactic is configured for a first processing element and in block a second solution tactic is configured for a second processing element. In blocks and a replication of the formula is generated and assigned to each of the processing element. Flow continues to blocks and where the processing elements begin to solve the formula by the assigned solution tactic. In some embodiments the solution tactics employed by the processing elements include selection and assignment of literals in the formula. In some instances these assignments result in conflicts. In these embodiments flow continues to blocks and where the process identifies the existence of new conflict clauses. If new conflicts exist flow continues to blocks and where the process backtracks to the previous state assignments and the new information related to conflict is learned. The process then continues to and where this new learned information is aggregated and the periodicity of communicating the learned information is controlled. At the appropriate time flow continues to block where the learned information is communicated to other processing elements across the message passing interface. Additionally when the process backtracks to a previous state flow continues back to blocks and .

In some embodiments the formula that is replicated and solved contains a propositional logic component. In other embodiments the solution tactics comprises a search and decisions made in the course of the search can be saved in the event of a backtrack. In additional embodiments the solution tactics include a function for replaying decisions made from the backtrack. In still further embodiments the backtracking function is induced by learned information received on the message passing interface. In various embodiments the learned information is shared with other processing elements across the message passing interface. This learned information can include a subset of conflict clauses derived by the execution of the assigned solution tactic. In other embodiments this learned information can include a subset of must implications derived by the execution of the assigned solution tactic. In some embodiments the solution tactics used may include a restarts enabled tactic a number of learned clauses per conflict tactic a conflict clause minimization enabled tactic a decision replay enabled tactic a binary back propagation enabled tactic a database compaction enabled tactic and a binary centric Boolean Constraint Propagation enabled tactic.

Boolean Constraint Propagation BCP is a function known in the art for propagating the implications of a logical assignment. After a variable is selected and assigned with a candidate assignment those clauses that depend on the assignment are examined. In the case where a clause exists such that all but exactly one of the variables present in the clause have been assigned and the clause has not been satisfied by any of those assignments the assignment to the final variable is forced and the assignment is made. The BCP function maintains of a worklist of assignments to process each assignment potentially leading to new assignments that are added back to the worklist. The process continues until either the worklist is empty no more implications or a case is discovered in which a variable must simultaneously be set true and false a logical conflict . A logical conflict initiates a backtrack.

A backtrack is a function known in the art for recovering from a conflict derived from BCP. In a backtrack operation assignments are undone beginning with the most recent and proceeding in order until a point is reached at which the remaining assignments and their logical implications no longer violate the conflict clause derived from the conflict. The backtracking processes along the discrete level known in the art as decision levels. Each decision level begins with a free choice of assignment and includes all of the assignments derived from that choice through the BCP process. Decision levels are numbered upward from 0 with assignments at level 0 being must implications. A conflict inducing a backtrack past level 0 indicates the formula is unsatisfiable.

An additional provided embodiment of a method is illustrated in . In some embodiments method is a subset of the functions and operations of blocks and . In this provided method two copies of the replicated formula are assigned to the processing element in blocks and . Flow continues to blocks and where the processing element attempts to solve the replications of the formula by the assigned solution tactic. Flow then continues to decision blocks and where it is determined if any additional variables exist in the formula. If additional variables exist flow continues to blocks and where a variable is asserted TRUE then to and where the same variable is asserted FALSE. In blocks and the implications of these assignments are additionally derived through Boolean Constraint Propagation. Flow then continues to decision blocks and where it is determined if a must implication exists. If so this must implication is communicated in block across the message passing interface. If not flow continues back to decision blocks and and the process iterates.

As is known in the art a must implication is a logical implication that exists when a particular clause takes on a logical state regardless of the assertion of TRUE or FALSE. In some embodiments the solution tactics include deriving logical implications from the message passing interface and using these implications in the process of deriving a solution. In some embodiments the logical implication is a conflict clause in others it is a must implication. In some embodiments the process illustrated in method is a partitioned process operating on different portions of the same formula. In these embodiments the selection of a particular partition may be made based on a score assigned to a variable in another process. In other embodiments the partitioning is accomplished based on the number of times a function has been called. In other embodiments one of the solution tactics includes Boolean Constraint Propagation with backtracking and the deriving logical implications is performed when the number of backtracks exceeds a threshold.

Another provided embodiment of a method is illustrated in and . In this embodiment flow begins at block where a processing element configuration is read from a file. Flow then continues to block where variables are instantiated. In this embodiment block receives parameters such as processor index the number of processors present and various communication related parameters. In no particular order a number of decision blocks and are performed. As illustrated the decisions include whether restarts are enabled whether multiple conflict clauses are enabled whether conflict clause minimization is enabled whether binary propagation is enabled whether binary centric BCP is enabled whether database compaction is enabled and whether replays are enabled . In each instance if the configuration read from the file in block does not include the tested feature flow continues to disable blocks and where the particular feature is disabled. If the feature is to be enabled flow continues to enable blocks and where the particular feature is enabled. Flow then continues to block for replication of the formula on the particular processing element.

Some embodiments of the present invention provide methods that allow processes using different solution tactics to communicate learned information with each other and to benefit from this information. The following pseudo code illustrates the communications between processes and the activation and inactivation of the solution tactics.

In some embodiments these options are related to a decision procedure such as a solution tactic for a Satisfiability problem. In other embodiments the process of evaluating if a particular option is to be enabled includes assigning that option a key and associating that key to an expression of zero or more variables that can be evaluated by a processing element. In some embodiments this expression is an arithmetic expression that supports the modulus operation. In others it supports if then and if then else conditionals. In other embodiments these expressions are evaluated separately by each processing element involved in solving the formula. In other embodiments this expression is in postfix notation. In still further embodiments these variables are specific to the process being instantiated. Additional embodiments include where these variables include a unique index of the process being instantiated a value related to the number of processes being instantiated and a value related to the capabilities of the platform on which the process is being instantiated. In other embodiments these variables are stored to a file accessible to other processing elements.

The enabling of multiple conflict clauses is known in the art as the technique by which BCP is allowed to continue past the discovery of a first conflict to determine if additional conflicts are also implied. A conflict clause is then generated for each. Conflict clause minimization is a known in the art as an optimization technique for reducing the number of literals contained in a conflict clause. Binary back propagation is a technique for optimizing a conflict clause using implications derived from binary clauses original or conflict . Binary centric BCP is a method for separating in the BCP process the handling of binary and non binary clauses. Database compaction is known in the art as a technique by which the set of clauses being considered is reduced by removing clauses satisfied by must implications or conflict clauses that are no longer active. The enabling of replays is a technique wherein decisions that have been backtracked over as a result of finding a conflict but that may be unrelated to the conflict are retested after the backtrack.

In still further embodiments the parametric space contains a parameter such as a seed to a random number generator a parameter related to a choice of tactics used by the decision procedure a parameter related to options affecting the behavior of the decision procedure within a tactic and a parameter related to options affecting the frequency of functions called within a tactic. In still further embodiments the choice of instantiation includes distributing all possible combinations of choices of instantiation to the plurality of processing elements. In still further embodiments the parametric space of options can be explored dynamically by at least one processing element during execution.

Another provided embodiment of a method is illustrated in . In this method the formula is replicated and assigned to a particular processing element in block . Flow continues to decision block where it is determined if additional unassigned literals exist in the formula. If so one is chosen and an assignment made. Flow continues to block where all variables are propagated using binary clauses only. In decision block it is determined if a conflict exists if no conflict exists flow continues to block where one variable is propagated using non binary clauses only. Flow then continues to decision block where it is again determined if a conflict exists. If no conflict exists flow continues back to decision block and the process iterates. Returning back to decision block if a conflict is found flow continues to decision block . Additionally if a conflict is found in decision block flow continues to decision block . At block it is determined if the conflict is a binary clause. If the conflict is a binary clause flow continues to block where it is added to the binary clause database and in block put on the head of the binary watch list. Flow then continues back to decision block . If in decision block it is determined that the clause is not binary flow continues to block where it is added to the non binary database and put on the head of the non binary watch list in block . Flow then continues back to decision block and the process iterates until decision block determines that there are no unassigned literals. Flow then continues to block where all searches are terminated.

In some embodiments a data structure is used that maintains separation between the binary and non binary clauses in the formula. In other embodiments the data structure includes different insertion points for binary and non binary clauses. In many embodiments new assignments are deduced from the watch lists. The concept of watch lists is of common knowledge to the engineer knowledgeable in the art of SAT solving. The intuition is to constantly monitor unassigned literals from every clause. When a clause that is not yet satisfied has only 1 unassigned literal left this literal must be satisfied. Watch lists are a structure to efficiently track for each literal the list of clauses that can influence the literals assignment. In other embodiments Binary Constraint Propagation is performed on all binary clauses before the non binary clauses. In other embodiments a test for a must implication is additionally performed and a determination made about the binary nature of a clause based on the must implication. In other embodiments a data structure includes a field that is used to indicate whether a clause is binary or non binary.

The pseudo code below shows how an implementation of binary centric BCP gives preference to binary clauses by first performing resolution on the binary watchlists only.

Another embodiment of a provided method is illustrated in . In this embodiment the formula is replicated and assigned to a particular processing element in block . Flow then continues to block where the particular solution tactic for this processing element is accomplished. Flow continues to block decision where it is determined if a conflict exists. If no conflicts exist flow continues to block where all searches are terminated. As with other embodiments the termination and other information can be communicated over a network or other message passing interface to other processing elements. If a conflict is found in decision block flow proceeds to decision block where it is determined an unexamined literal exists in the conflict clause. If not flow continues to block where backtracking is performed and the new clause added to learned clauses. Flow then continues to block . If at decision block it is determined that there is a non examined literal in the conflict clause flow proceeds to decision block where it is determined if the literal was derived from a binary clause. If not flow returns to block . If it is determined that the literal is derived from a binary clause flow continues to block where it is determined if another literal has a previous assignment. If so flow continues to block where the second literal is substituted into the conflict clause and flow continues back to . If the second literal was not previously assigned flow continues back to .

In some embodiments the first clause is a binary clause in others it is not. Additional embodiments include embodiments where the second clause is binary and included the negated literal under consideration in the first clause. Additional embodiments include embodiments where one to one substitution is performed on all literals identified within a particular conflict clause. Since this provided method is independent from routine conflict clause minimization it can be performed in conjunction with this minimization occurring either before or after the minimization.

Conflict clause minimization is known in the art and is a technique used to make the learned conflict as small as possible. Various aspects of the present invention additionally perform substitutions of literals in the generated learned clauses. An example of these substitutions is seen in the below pseudo code.

It is to be understood that the aspects described herein can be implemented by hardware software firmware middleware microcode or any combination thereof. When the systems and or methods are implemented in software firmware middleware or microcode program code or code segments they can be stored in a machine readable medium such as a storage component. A code segment can represent a procedure a function a subprogram a program a routine a subroutine a module a software package a class or any combination of instructions data structures or program statements. A code segment can be coupled to another code segment or a hardware circuit by passing and or receiving information data arguments parameters or memory contents. Information arguments parameters data etc. can be passed forwarded or transmitted using any suitable means including memory sharing message passing token passing network transmission etc.

For a software implementation the techniques described herein can be implemented with modules e.g. procedures functions and so on that perform the functions described herein. The software codes can be stored in memory units and executed by processors. The memory unit can be implemented within the processor or external to the processor in which case it can be communicatively coupled to the processor via various means as is known in the art.

Thus it is seen that methods and an apparatus for distributed decision processing are provided. One skilled in the art will appreciate that the present invention can be practiced by other than the above described embodiments which are presented in this description for purposes of illustration and not of limitation. The specification and drawings are not intended to limit the exclusionary scope of this patent document. It is noted that various equivalents for the particular embodiments discussed in this description may practice the invention as well. That is while the present invention has been described in conjunction with specific embodiments it is evident that many alternatives modifications permutations and variations will become apparent to those of ordinary skill in the art in light of the foregoing description. Accordingly it is intended that the present invention embrace all such alternatives modifications and variations as fall within the scope of the appended claims. The fact that a product process or method exhibits differences from one or more of the above described exemplary embodiments does not mean that the product or process is outside the scope literal scope and or other legally recognized scope of the following claims.

