---

title: Code-clone detection and analysis
abstract: Techniques for detecting, analyzing, and/or reporting code clone are described herein. In one or more implementations, clone-code detection is performed on one or more source code bases to find true and near clones of a subject code snippet that a user (e.g., a software developer) expressly or implicitly selected. In one or more other implementations, code clone is analyzed to estimate the code-improvement-potential (such as bug-potential and code-refactoring-potential) properties of clones. One or more other implementations present the results of code clone analysis with indications (e.g., rankings) of the estimated properties of the respective the clones.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09110769&OS=09110769&RS=09110769
owner: Microsoft Technology Licensing, LLC
number: 09110769
owner_city: Redmond
owner_country: US
publication_date: 20100401
---
For efficiency in programming software developers often duplicate sections of source code in numerous locations within programming projects. Reusing a portion of source code via copy and paste with or without some degree of modifications or adaptations is called code cloning and the resulting copied portion is called code clone or more simply a clone. Code cloning is a common behavior of software developers for quick code reuse. In general the amount of code clones is likely to increase as the scale of code bases increases. A source code base of a programming project e.g. an application or an operating system is the collection of the source code of the bulk of the computer programs that make up the project.

In many cases unbridled code cloning negatively impacts the overall code quality by introducing potentially undetected cloning errors and potentially unnecessary redundancy. Consequently unbridled code cloning increases testing and code maintenance costs. For example it is a common problem that developers fix a bug in one piece of code but forget to apply the fix to its clones. This problem is more severe if the bug reveals a security issue. Also for example a high degree of clone coding may cause code bloating. Code bloating occurs when code clone is unnecessarily repeated in the code base.

It still remains a great challenge today to efficiently detect analyze and report code clones in large scale code bases to enable developers to take effective action.

Described herein are techniques for code clone detection analysis and or reporting. With one or more implementations of the techniques described herein code clone detection is performed on one or more source code bases to find true and near clones of a subject code snippet that a user e.g. a software developer expressly or implicitly selected. In one or more other implementations code clone is analyzed to estimate the code improvement potential such as bug potential and code refactoring potential properties of clones. These techniques may also present the results of code clone analysis with indications e.g. rankings of the estimated properties in association with the clones.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. The term techniques for instance may refer to device s system s method s and or computer readable instructions as permitted by the context above and throughout the document.

The disclosure describes techniques for code clone detection analysis and or reporting. These scalable and actionable techniques may efficiently detect and analyze code clones in large scale code bases so that software developers can easily take concrete actions against analyzed clones. These techniques may be used to determine the code improvement properties of found clones. Such properties include bug potential and code refactoring potential of detected clones. These techniques may also be used to provide rich reporting and visualization to intuitively help software developers to recognize code clones and recognize which actions to take regarding this code.

The following is a description of an operational use of an implementation employing the techniques described herein. A software developer for example may be examining reviewing fixing or otherwise directly observing a section of source code of a source code base or simply a code base . She may be doing this to for example fix a bug found in that code section. However after fixing the bug in this section of code she may need to fix that same bug in the same or similar code sections that are scattered throughout the code base. In some instances those same or similar code sections were copied and pasted and possibly slightly altered thereafter into the code base when the code base was initially programmed. However now when debugging the programmer has her work multiplied because the bug was part of the copied code clone.

With conventional solutions she would be limited to brute force approaches for some or all of the searching finding analyzing and fixing of buggy cloned code. The conventional solutions are limited by the size or characteristics of the code base to be searched the ability to find buggy code and the ability to present results of detection and analyses in a usable and useful manner to the software developer. Moreover none of the conventional solutions offered anything that allowed the software developer to have an online or on the fly detection of code clone.

Conventionally all code clone detection is performed offline. Offline code clone detection is where the entire source code is searched exhaustively to find all code clone pairs in the source code. A code clone pair is two sections of code where one is a clone of the other. Depending upon the size of the source code base this offline code clone detection may take hours upon hours. One of the inspirations which led to the implementations described herein is an appreciation that a software developer may not want to know about all clone pairs and experience the wait for the offline results . Rather she may simply be interested in the clones of a particular section of code that she is working on at the moment. Using the techniques described herein she may do online or on the fly code clone detection which focuses on quickly finding clones of a particular section of code of interest to the developer.

Also described herein are other implementations of code clone analysis and reporting techniques that further help the software developer in her quest for better quality code.

This brief introduction including section titles and corresponding summaries is provided for the reader s convenience and is not intended to limit the scope of the claims nor the proceeding sections.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims should generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

The computing device may include one or more processors as well as memory . Residing in the memory are backend and frontend components of a code clone detection analysis and reporting system which are shown in as components stored in the memory . These components may be modules of computer executable instructions which are instructions executable on a computer computing device or the processors of a computer. While shown here as modules the component may be embodied as hardware software or any combination thereof. Also while shown here residing on the computing device they may be distributed across many computing devices in the distributed system.

The frontend components include a clone explorer a clone finder and a clone visualizer . Alone or together the clone explorer and the clone visualizer display or report the results of the code clone detection and analysis. More precisely they present the results for display on a presentation device such as a computer monitor of the computing device . Working with the clone visualizer the clone explorer and clone finder are graphics based user interfaces GUI that present the clone analysis and search results of the backend components. Portions of examples of those GUIs are shown in and discussed below. More generally the frontend components may not directly present or display but instead may cause or help with a visual presentation or display of the code clone reporting information described herein.

The backend components include code improvement potential properties analyzer online clone search engine clone detection core preprocessor code base storage and storage . The code improvement potential properties analyzer includes a bug potential estimator a refactoring potential estimator and a clone scanner . The clone scanner scans through clones that have already been located or locates new clones. The code base storage stores the source code bases. A source code base of a programming project e.g. an application or an operating system is the collection of the source code of the bulk of the computer programs which make up that project.

The techniques described herein are highly scalable so that they may operate on code bases of any scale including large scale code bases. Here a large scale code base is one having tens of millions or even hundreds of millions lines of code. Furthermore the techniques described herein may operate on multiple code bases. This means that clones may be detected analyzed and reported across multiple code bases e.g. programs like applications .

The code improvement potential properties analyzer exhaustively finds and estimates code improvement potential properties of detected clones. The bug potential estimator estimates the potential or likelihood that a clone is buggy. The refactoring potential estimator estimates the potential or likelihood that a code clone can be re factored which involves replacing a code clone with a call to a single or shared function. Therefore after refactoring the source code is reduced in overall size but retains its functionality. Bug potential and code refactoring potential are two of many examples of how the described techniques may improve a code base by detecting code clone therein.

Another backend component is the online clone search engine that finds some or all of the cloned copies of an input code snippet in the specified code base in the code base storage . The clone search engine is the search engine which drives the clone detection core .

A code snippet is a section or portion of contiguous source code of a code function or just function . A function is a natural code boundary and is known to those of ordinary skill in the art of software development. For instance a function may comprise a named section of a program that performs a specific task. Stated otherwise a function may be deemed a type of procedure or routine.

To be pragmatic a code snippet is defined to have a minimum number e.g. 3 or 5 perhaps of statements. A statement i.e. statement block or logic block is known to those of ordinary skill in the art of software development. For instance a statement may be an instruction written in a high level programming language. Typically a statement directs the computer to perform a specified action. Therefore the non instructional elements e.g. comments are not part of a statement.

The clone detection core finds a group of clone code snippets in the source code base. The group of found clone code snippets includes not only identical clones but also clones which are similar but not identical. The preprocessor does preprocessing of the source code for the clone detection core . In short the preprocessor removes irrelevant e.g. non functional material in the source code and re formats the source code.

In one or more implementations the clone detection core performs the fundamental code clone functionality. Given an index of a code base or code bases and an input code snippet the clone detection core may return a list of code clones of the input code snippet. The clone detection core may be used in either offline on online fashion. In the online fashion the online clone search engine accepts a code snippet from a user and then calls the clone detection core on the fly. The input snippet from user is not predictable and may well not be the same as any code snippet in the specified code base. This means that the code clone results of a query is not computable ahead of time. Of course this might not be so in other alternative implementations that does not utilize on the fly based queries. In the Offline fashion the clone scanner feeds all functions in code bases one by one to the clone detection core as the input code snippet and the clone detection core returns all code clones for each function.

The described backend components may be parallelized in a distributed computer cluster. The preprocessor may partition the code bases and build indices for each partition. There may be multiple instances of the online clone search engine and each may be run against the same number of source code partitions to compute the clones of the input code snippet.

One or more implementations like those described herein may provide two integration points for other applications or systems to utilize its functionalities. Web service APIs application programming interfaces may be designed to expose the clone search service such as that provided by online clone search engine . The clone detection and analysis results generated by the code improvement potential properties analyzer may be accessed via another set of web service APIs. Applications that consume clone results may utilize these APIs to integrate with one or more implementations.

During preprocessing the source code in the specified code base is parsed tokenized and indexed. Given a subject code snippet rough matching is performed to find a list of candidate functions that contain possible cloned snippets that might match the subject code snippet. Then the fine matching of the subject code snippet and each clone candidate function of the list of candidate functions produces a more accurate listing of clones.

The source code parser of the preprocessor parses the source code which is pulled from the specified code base of the code base storage . The source code parser skips comments in the source code and retrieves function boundaries along with statements in function definitions. In addition the source code parser normalizes e.g. re formats the statements. This may include removing extra white spaces and merging break lines of a statement into one line in order to remove formatting differences. In one or more implementations of the source code parser its parsing is much lighter compared to the comprehensive parsing functionalities of compilers. Compared with conventional parse tree based clone detection approaches one or more implementations described herein have a practical advantage of compiler independence. Because of that one or more implementations may be easily applied to languages whose parse tree information is difficult to obtain e.g. scripting languages like JavaScript object oriented scripting language . In addition the compiler independency property also makes the system working on multiple code bases easily. The reason is in practical different code bases may require different build environment to compile. Dependency on compiler will make the whole system very complicated.

After parsing the statements of the source code by the source code parser the tokenizer generates a token map for the normalized parsed statements. Each keyword and operator of a statement is mapped to a unique token. Also the identifiers and constants are mapped to the same token respectively to tolerate identifier renaming.

After tokenizing by the tokenizer the indexer indexes each tokenized statement. If no statement hash dictionary exists the indexer creates one. Otherwise the indexer uses an existing statement hash dictionary associated with source code and or the specified code bases. The indexer assigns each tokenized statement a value e.g. a hash value and the same tokenized statements are assigned the same value. The location information of each statement inside its function definition is associated with the statement s index value. If multiple tokenized statements are the same then the location information of each of the identical statements will be recorded at the corresponding index value in the statement hash dictionary .

The statement hash dictionary produced by the preprocessor and a subject code snippet are the input into the clone detection core . As its name implies the clone detection core detects code clone in specified source code of all or part of a code base or of multiple code bases. The clone detection core finds and identifies at minimum code snippets in functions that are identical to the subject code snippet in every way after preprocessing of course . These clone code snippets are all clones of the subject code snippet in a very true and literal sense of the word. However the clone detection core of one or more implementations described herein does more than find exact duplicates of code snippets. It finds near clones as well. Indeed unless the context indicates otherwise references herein to code clone and the like includes near clones as well as true clones.

The nearness of the code clone is described as meeting and or exceeding an adjustable threshold of similarity. Said another way a pair of code snippets are considered to be a clone pair when their similarity metric which is a measure of their similarity to each other is greater than and or equal to a defined similarity threshold. Said again a different way a clone pair is defined as code snippets spand sphaving a similarity metric S sp sp greater than or equal to a defined similarity threshold 1 

The following helps explain this code clone definition further. Assume spis a code snippet such as subject code snippet in function F spis a code snippet in function F T is a tokenization function and m represents a number of statements that match between spand sp. Said another way there are m statements in spand sp respectively and these statements have one to one correspondence that satisfies the constraint T s T s sand sare the ith and jth statement in spand sp respectively. The similarity metric of spand spis

This definition is based upon an insight that the more commonly shared tokenized statements in spand spmeans that it is more likely for spand spto be clones. With this code clone similarity control offered by equations 1 and 2 software developers may precisely definite how similar a pair of code snippets must be in order to be considered a clone pair. Thus by adjusting the similarity threshold a developer controls the scope and size of the clones found by the clone detection core . In general more near clones will be obtained if a smaller is used which means fewer tokenized statements are commonly shared.

In one or more implementations the clone pair definition focuses on code snippets with comparable sizes based on the assumption that copy and paste types of clones usually involve a non significant amount of changes after code is cloned. In addition this clone definition enables the detection of near clones with disordered statements which is a potential source of bugs caused by unintentional changes after copy and paste actions.

As illustrated shows the clone detection core receiving the subject code snippet and the statement hash dictionary as input. Also shown is a software developer working at a software development workstation e.g. a computing device which is called herein a software development station .

A typical scenario involves a software developer using the software development station working on the code snippets found in the source code of the specified code base stored in the code base storage . Indeed she may be actively working on a particular code snippet of interest. That interest may be in the form of debugging reprogramming or just active interest for any reason that she might have.

Another typical scenario involves a software developer using the software development station working on a code base or code bases trying to find all code clones inside it. The interest may be to identify all potential issues regarding code clones for example potential bugs caused by code cloning potential code refactoring e.g. removing opportunities cased by code cloning.

Clone explorer may help her to explore all code clones and clone analysis result generated by clone scanner and code improvement potential properties analyzer . Clone explorer also leverages clone visualizer to show the difference between code clones. Clone finder is GUI to facilitate the on the fly query of code clones. A user may input a code snippet to clone finder . Clone finder sends the code snippet to online clone search engine and clone search engine returns a list of clones to clone finder . Subsequently the clone finder presents a list of clones returned by the online clone search engine to the user and leverages clone visualizer to show the clone difference.

In general using one or more of the frontend components e.g. the clone explorer the clone finder and the clone visualizer she indicates her interest in the particular code snippet. That indication may of course be purposeful and expressed by selection of code click of a button selection of a particular interface etc. But in alternative implementations that indication may be inferred or implied by for example the software developer spending time viewing editing etc. a particular code snippet. With an implicit selection implementation a timer or particular event may trigger the implicit selection of a code snippet.

Once interest in a particular code snippet is indicated it becomes the subject code snippet and clone detection functionality of the clone detection core is initiated. The initial operation of the clone detection core is performed by the rough matcher . When given as input the code snippet and the statement hash dictionary the rough matcher returns a list of candidate functions that contains possible clones of the code snippet .

The rough matcher reduces the search space from the entire code base or even multiple code bases to the list of clone candidates which is of a much smaller scale. From there the fine matcher winnows down the list of clone candidates to those that are actually clones of the subject code snippet . More details about the rough and fine matching are found in a section below titled Additional Details of Example Techniques. 

The clone code snippets found in the clones are clones of subject code snippet in accordance with clone pair definition and similarity metric equations which are equations 1 and 2 respectively.

In other words it can via the online clone scanner receive the subject code snippet and the found clones resulting from an on the fly i.e. online code clone detection as described herein for the clone detection core . Alternatively the analyzer can via the offline clone scanner receive the subject code snippet which may be any code snippet and not one provided via a user selection and unprocessed source code from the code base in the code base storage . In doing this the offline clone scanner exhaustively searches the un preprocessed source code from the code base to find all clones of the subject code snippet . Alternatively still the offline clone scanner might not receive the subject code snippet and instead search the un preprocessed source code for all clones that there are to be found.

Regardless of which approach is used the code improvement potential properties analyzer operates in a similar manner. That manner is to analyze the clones to determine if they have inherent properties that lend themselves to allow for improvement to the source code by additional attention and programming by the software developer.

While other examples of the code improvement properties exist two of particular interest here are bug potential and refactoring potential. In short the bug potential of a code clone is the chance that an inconsistent or inattentive change in a code clone introduced a bug. The refactoring potential is the chance that a code clone can be easily replaced by a call to a reusable duplicate.

The bug potential estimator calculates a quantitative estimate on how likely code clone is to be buggy. The estimate may be an output of the estimator. Also the clone code snippets may be ranked based upon that estimate and those bug potential rankings may be output. These estimates ranking or both may be stored with the code clone in a data structure that tracks that code. Also it may be displayed and made available for manipulation via one or more of the frontend components e.g. the clone explorer the clone finder and the clone visualizer .

The refactoring potential estimator calculates a quantitative estimate on how likely code clone may be re factored. The estimate may be output. Also the clone code snippets may be ranked based upon that estimate and those refactoring potential rankings may be output. These estimates ranking or both may be stored with the code clone in a data structure that tracks that code. Also it may be displayed and made available for manipulation via one or more of the frontend components.

In order to help developers with bug fixing and code refactoring the code improvement potential properties analyzer analyzes the clone detection results and generates with quantitative estimates on how likely code clone is buggy or is re factorable. This way the detected clones can be prioritized based on the analysis results which helps developers focus on the high potential clones with their limited time and resources.

These estimates are based at least in part upon an analysis of the differences between the code clone pairs. So given two clone functions Fand F the code improvement potential properties analyzer determines the differences between Fand Fin order to estimate the code improvement potential. Based on the fine matching result of Fand F four types of matching statement blocks between Fand Fare generated.

Suppose Band Bare two matching statement blocks i.e. statements in function clones Fand Fwith sand sas matching statements in Band B respectively. T is a tokenization function and SC is a string comparison function. The four types of statement blocks are defined below.

In addition to the above four types of matching statement blocks the code improvement potential properties analyzer also identifies the sequential differences of matching blocks using a disordered block concept Disordered block. Suppose there are m matching blocks in Fand F and the blocks in Fare ranked in ascending order B 1 i m . For an ordered block pair Bi Bj in F B B is used to represent its correspondence in F. B is called a disordered block if i j .

The code listing of clone pair includes statement blocks . The code listing of clone pair includes statement blocks . Blocks and are exactly matched blocks between the clone pairs and . Similarly blocks and are exactly matched blocks. And the same is true of blocks and .

Blocks and are similar logic blocks. Likewise blocks and are similar logic blocks. Between the clone pairs and the similar logic blocks differ merely in labeling. Blocks and have a d where blocks have d instead.

Block and block are a different logic blocks. The logic differs between the two blocks. Block has k i while block has k i i .

Block has no equivalent in the clone . So it is an extra logic block. Blocks and appear in a different ordering between the clone pairs and . Therefore blocks and are disordered blocks.

The inconsistency between clone pairs and Fand F includes the block types defined herein as well as disordered blocks of any type. These different types of inconsistencies play a role in estimating bug potential and code refactoring potential.

The bug potential estimator estimates clone related bug potential based on the categorization of differences in function clones. Different logic blocks disordered blocks and extra logic blocks indicate semantic level differences between function clones. A small amount of such differences may be indicators of bugs while a large amount of such differences are likely to be caused by intentional changes. In other words the bug potential estimator presumes that small inconsistencies between clone pairs correlates with the likelihood that the clone is buggy. That is because it is presumed that large differences were the results of a purposeful act by the software developer.

Based on this observation a bug potential metric of a clone function pair Fand Fas follows is calculated by 

The refactoring potential estimator also estimates code refactoring potential based on the categorization of differences in function clones. It is presumed here that it is relatively easier to re factor large sized exactly same blocks and similar logic blocks using techniques such as extraction and pull up the code refactoring potential metric is calculated by 

The value of R F F is in the range of 0 0 Similar to the bug potential value the value of R F F is also mapped to ranks of High Moderate Low and Zero. This value and or the ranking is the results shown at of .

The frontend components e.g. the clone explorer the clone finder and the clone visualizer provide a graphical user interface GUI for a software developer at for example her station . The clone visualization and reporting mechanism provides a rich and interactive user experience for developers to efficiently review the clone analysis results and take corresponding actions.

Display field shows an example of how the clone explorer displays and organizes clone statistics based on source tree hierarchy in order to enable a quick and easy developer s review at different source levels. Display field is a drop down list that allows pivoting the clone analysis results around bug potential shown at display field code refactoring potential any other code improvement potential properties and or clone scope. Clone scope indicates whether cloned code is detected inside a file cross file or cross folder. For a selected folder in the left pane of the GUI the list of clone functions along with sorting enabled bug potential and refactoring potential display field is displayed in the right pane . The GUI provides filters on clone scope bug potential and refactoring potential to enable easy selection of interested clones.

As illustrated in matching blocks in the code snippets and are shown in display areas and and a legend that shows the highlight e.g. color coding for indicating different block types is shown at . The left and right source panes where the code snippets and are shown are synchronized. Furthermore navigation buttons are provided to navigate through source code by matching blocks instead of statements in order to improve review efficiency. Via options users can take the immediate action of opening a bug once a clone is confirmed to be a bug or needs to be re factored. Via options users can copy the code out for more investigation.

As shown in an option at and at activates a tagging mechanism. With this tagging mechanism a user may tag a detected clone code snippet. Some tags may be merely for commentary or documentation purposes unique to the user. Some tags may indicate immunity for a clone code snippet. Some of the detected clones are by design and thus are desired by the software developer. Therefore it is unnecessary and undesirable to have such clones included in a detection and analysis. When a clone is tagged as immune by the user the clone is ignored by the code clone detection analysis and or reporting systems or techniques.

Still another purpose for the tagging is for feedback to product development. User feedback and evaluation results of a product implementing one or more of the code clone detection analysis or reporting systems or techniques are collected and reported back to product development. This aids in further improvement of the product.

One example of the feedback may include using a tagging mechanism that allows users to label a clone as confirmed bug or confirmed code refactoring opportunity. These tags can be further used to improve the bug potential and code refactoring potential estimator and .

For one or more implementations of the preprocessing the source code of the source code bases is parsed in order to identify and normalize statements in the source code of the source code bases. Then those identified and normalized statements are tokenized so that keywords and operators of each statement are mapped to a unique token. The tokenized statements are then indexed to create an index value for each tokenized statement and each index value e.g. hash value is stored in the statement hash dictionary with an association between the index value of each tokenized statement and one or more locations in the source code of the source code bases where each unique tokenized statement is found.

Of course other conventional and new clone detection preprocessing approaches other than tokenization may additionally or alternatively be used. Examples of those approaches include text based e.g. parameterized matching abstract syntax tree based e.g. tree edit distance and semantics based e.g. using a dependency graph approach.

At operation and after preprocessing the computing device receives a selection of an input code snippet e.g. subject code snippet of based upon user input. The user input may include a purposeful selection by a software developer or the selection may be inferred by the user s activity e.g. editing a particular code snippet .

Next operation is in response to the receiving of the selection of the subject code snippet based upon user input e.g. from a user interface . At operation the computing device obtains the subject code snippet . For example the subject code snippet may be obtained via a communications medium or pulled from working memory such as RAM or storage such as a hard disk flash memory an optical disc etc. .

The process then proceeds to operation at which point the computing device finds a group of clone code snippets in the source code bases such as those stored in . This is one example of code clone detection. Here both true clone pairs where pairs are completely identical and near clones are detected. For each of the near clones a similarity metric relative to the subject code snippet is calculated see equation 2 . A near clone is considered a clone found here when it has a similarity metric that meets and or exceeds a defined similarity threshold see equation 1 . That threshold may be preset or user adjustable.

The finding operation includes rough matching the subject code snippet to a list of candidate functions e.g. the clone candidates of in the source code bases. To qualify as a candidate function it must be determined to include a possible cloned code snippet that has a likelihood of being a clone or near clone of the subject code snippet based upon a rough matching calculation of functions in the source code bases. That rough matching calculation is elaborated further section below titled Additional Details of Example Techniques. 

Since this is a rough matching not all of the candidate functions will include cloned code snippets which are clones or near clones. Therefore at least some of the possible cloned code snippets have the similarity metric that is below the defined similarity threshold.

Next the candidate functions are fine tuned by fine matching the subject code snippet with the list of candidate functions. The fine matching includes identifying the clone code snippets of the group in the list of candidate functions that have the similarity metric that meets and or exceeds the defined similarity threshold. The fine matching calculation is elaborated further section below titled Additional Details of Example Techniques. 

The end product of process is a set of code clone e.g. clones that is clones or near clones of the subject code snippet in accordance with clone pair definition and similarity metric equations which are equations 1 and 2 respectively.

Next at operation the computer device estimates code improvement potential properties of the of the clone code snippets of the group of found clone code snippets. As part of this estimation the computer device compares and contrasts the statements of the subject code snippet and the statements of each of the clone code snippets. When comparing and contrasting it identifies statements between the subject code snippet and the cloned code snippets that are exactly matched similarly matched unmatched different disordered matched but in the wrong order and or extra or missing found in one but not the other .

In one or more implementations the estimating of operation includes a calculation of bug potential estimation metrics of the clone code snippets of the group. The bug potential estimation metrics is one of the code improvement potential properties. The bug potential estimation metric of a specific code clone is a measure of a likelihood that the specific code clone is buggy. Here it is presumed that small inconsistencies between clone pairs correlates with the likelihood that the clone is buggy. That is because it is presumed that large differences were the results of a purposeful act by the software developer.

In one or more implementations the estimating of operation includes a calculation of code refactoring potential estimation metrics of the clone code snippets of the group. The code refactoring potential estimation metrics being one of the code improvement potential properties. The code refactoring potential estimation metric of a specific code clone being a measure of a likelihood that the specific code clone is a viable candidate for refactoring and code refactoring potential estimation metrics being one of the code improvement potential properties.

Next at operation the computing device ranks at least some of the clone code snippets of the group based upon the of the estimated code improvement potential properties e.g. bug potential and refactoring potential .

At operation the computing device which is further configured to present visual information to users presents the ranked clone code snippets of the group. It may for example present or cause to be presented the ranked clone code snippets on a computer monitor or display using a GUI like that of and of .

Next at operation the computing device indicates differences similarities or both in the statements of the subject code snippet and the at least one of the clone code snippets. In doing this it may show statements that are exactly matched similarly matched unmatched different disordered matched but in the wrong order and or extra or missing found in one but not the other .

At operation the computing device displays the presented ranked clone code snippets in an order relative to rankings. At operation the computing device indicates the relative ranking of the presented ranked clone code snippets. And at operation the computing device provides the estimated code improvement potential properties of each of the presented ranked clone code snippets.

In process of and at operation the computing devices performs code clone detection in accordance with new techniques described herein e.g. see or in accordance with other new or potentially conventional approaches.

Next at operation the computing device immunizes specific code snippets of the clones detected in operation . Alternatively whole functions procedures sub procedures and or code bases may be immunized. That may be done for example by a user selecting or identifying specific code snippets for immunity for future code clone detections.

In response to the immunization the computer device at operation tags the immune snippets as immune. 

At during a subsequent clone detection the immune snippets are excluded from detection analysis and or reporting. That includes for example the finding estimating ranking or presenting operations discussed herein.

This sub section describes portions of non limiting embodiments of these techniques in greater detail.

As illustrated shows the clone detection core receiving the subject code snippet and the statement hash dictionary as input. Also shown is a software developer working at a software development workstation e.g. a computing device which is called herein a software development station .

One scenario involves a software developer using the software development station working on the code snippets found in the source code of the specified code base stored in the code base storage . Indeed she is actively working on a particular code snippet of interest. That interest may be in the form of debugging reprogramming or just active interest for any reason that she might have.

Using one or more of the frontend components e.g. the clone explorer the clone finder and the clone visualizer she indicates her interest in the particular code snippet. That indication may of course be purposeful by selection of code click of a button selection of a particular interface etc. . But in alternative implementations that indication may be inferred by the software developer spending time viewing editing etc. at particular code snippet.

Once interest in a particular code snippet is indicated it becomes the subject code snippet and clone detection functionality of the clone detection core is initiated. The initial operation of the clone detection core is performed by the rough matcher . When given as input the code snippet sp and the statement hash dictionary D the rough matcher returns a list of candidate functions L sp that contains possible clones of sp. The rough matcher reduces the search space from the entire code base or even multiple code bases to L sp which is of a much smaller scale.

From there the fine matcher winnows down the list of clone candidates to those that are actually clones of the subject code snippet in accordance with clone pair definition and similarity metric equation which are equations 1 and 2 respectively.

The rough matcher utilizes hit functions and generates clone candidate functions. A hit function F is a function and it consists of n statements F s s s . . . s. T and H are tokenization and hash functions respectively. The tokenized statements of Fare mapped to a dictionary D v v v . . . y where v H T s . A code snippet sp consists of k statements sp s s s . . . s. Fis called a hit function of swhen there exist p and q such that H T s H T s .

A function Fis called a clone candidate function of a code snippet sp when there exists at least nstatements in sp with Fas one of its hit functions and

As its name implies the rough matcher performs a rough match. Therefore some or even many of the list of functions of the clone candidates F resulting from the rough matching might not be clones of the code snippet sp in accordance with clone pair definition and similarity metric equations which are equations 1 and 2 respectfully. There may be many reasons why this occurs. Some of those reasons include 1 the matched tokenized statements may be so scattered in Fthat the snippet consisting of these statements do not match sp 2 multiple tokenized statements in Fmay be mapped to the same tokenized statement in sp 3 there might be mis matched statements between sp and Fdue to hash collisions even though the probability of hash collision is quite low. Therefore the fine matcher prunes the list of functions of the clone candidates so as to finely match the code snippet and each clone candidate function in order to remove the noise and identify the real clones in accordance with clone pair definition and similarity metric equations which are equations 1 and 2 respectively.

Suppose F for brevity Fis denoted by F with regard to the description of fine matching is its clone candidate function. T is a tokenization function. The goal of fine matching is to find a snippet spof F that optimizes the following objective 

In order to optimize the fine matching first the similarity between the code snippet sp and spis determined. Then the size of spis constrained based on the clone pair definition of equations 1 and 2 . Based upon the determined similarity and the constrained size an iterative approach is used to perform the actual fine matching.

A bipartite graph G V V V E represents the matching relationship between sp and sp. In general a bipartite graph i.e. a bigraph is understood by a skilled artisan to be a set of graph vertices decomposed into two disjoint sets such as no two graph vertices with the same set are adjacent. Each statement in sp is a vertex in vertex set V and each statement in spis a vertex in V. The edge set E consists of statement pairs s s that satisfies T s T s . Gconsists of a number of disjoint sub graphs G G l 1 . . . n G V V V E s s V S S V T s T s T c T s where nis the number of unique tokenized statements in the code snippet sp with at least one matching statement in sp. Each Gis a fully connected bipartite graph because all of its vertices are identical tokenized statements. The maximal count of one to one matching statement in Gis min V V where V is the number of vertices in V. Based on this understanding the number of one to one matching statements between sp and spis determined as follows min 6 Consequently the similarity between sp and spcan be calculated based on equations 6 and 2 .

The rough matching results indicate that there are at most nmatching statements between sp and F. Based on the clone definition in equation 1 the number of statements in spis constrained by LOC 7 where

The following is an example of an outline of a fine matching algorithm that may be performed by one or more implementations of the fine matcher 

The input spof FineMatching is set to F at the beginning to find all clones of sp in F. A sliding window line with variable length from kto k line is used to scan all snippets of sp. Based on the last two constraints in equation 3 only those snippets with first and last statements having matches in sp are processed line . s line represents the ith statements of sp. The function Graph line builds the bipartite graph between the two code snippets sp and sp a snippet of spwith k statements starting from the ith statement . Matchings line calculates the number of one to one matching statements between sp and sp and Similarity line calculates their similarity. sp is recorded if it is identified as a clone line and the two remainder code fragments before and after sp in spwill be further analyzed by calling FineMatching recursively line and . Alternatively the above example algorithm may be adjusted in various ways. For example Graph does not need to build the bipartite graph directly every time. The graph can be built iteratively by updating the graph of the last snippet in the loop because most often the current snippet largely overlaps with the previous snippet.

In the case of detecting whether two functions F and F are clones sp and spin equation 5 become F and F respectively. Therefore the approach may be adjusted to build the bipartite graph between F and F and calculate the similarity based on equations 2 and 6 with spequal to F.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as exemplary forms of implementing the claims.

