---

title: Automated service version upgrading
abstract: A method consists of upgrading, at a server, a service from a first version to a second version, receiving a request from a client associated with the first version of the service, sending a response to the client indicating that the server supports the second version of the service, communicating with the client using the second version of the service as a result of receiving a communication from the client utilizing the second version of the service after sending the response, and communicating with the client using the first version of the service as a result of receiving a communication from the client utilizing the first version of the service after sending the response.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09529578&OS=09529578&RS=09529578
owner: Hewlett Packard Enterprise Development LP
number: 09529578
owner_city: Houston
owner_country: US
publication_date: 20101020
---
Distributed architectures comprise clients and servers. Clients initiate requests to servers servers process requests and return appropriate responses. One example of a distributed architecture is the Representational State Transfer REST architecture. In REST style architectures requests and responses are built around the transfer of representations of resources. A resource can be essentially any coherent and meaningful object that may be addressed such as a database. A representation of a resource may be a document that captures the current or intended state of a resource such as a HyperText Markup Language HTML or Extensible Markup Language XML file that represents some or all of the database records.

The resource oriented nature of certain distributed architectures for example REST style architectures allows the client and server to be much more loosely coupled than is possible using an operation oriented approach. For example if an application installed on a server has a set of services that all use the same uniform interface and a client application installed on a client understands the data model for the resources provided by one service then that client application can connect to another service providing some of the same types of resources without modification. However at some point services need to modify their data models which can result in changes that are not backwards compatible with client applications in communication with the services.

While loosely coupled integrations allow for the client application and service to evolve independently a change in the data model or functionality that is not backwards compatible causes an integration configuration problem during upgrades. With multiple versions of the client application and multiple versions of the service available in the field it is necessary to configure which version of the service to which a client application connects. This is a manual process that is performed by administrators or IT personnel and is error prone. Additionally applications participating in solution integrations rarely follow the same upgrade timeline which leads to uncertainty as to when and how an administrator should configure a new version of an integration and as to what happens if there are multiple application versions that exist in a customer s environment.

Certain terms are used throughout the following description and claims to refer to particular system components. As one skilled in the art will appreciate computer companies may refer to a component by different names. This document does not intend to distinguish between components that differ in name but not function. In the following discussion and in the claims the terms including and comprising are used in an open ended fashion and thus should be interpreted to mean including but not limited to . . . . Also the term couple or couples is intended to mean either an indirect direct optical or wireless electrical connection. Thus if a first device couples to a second device that connection may be through a direct electrical connection through an indirect electrical connection via other devices and connections through an optical electrical connection or through a wireless electrical connection.

A solution is a set of standalone products that are able to interact with each other when installed together in order to provide a more complete product. For example an end to end IT management solution comprises an operations management product product A that detects events and metric anomalies a root cause and business impact analysis product product B a helpdesk product product C and remediation automation product product D . Standalone products provide functionality without the need to interact with another product. Each of products A B C and D can be used as a standalone product in a customer environment but together they may enable a more comprehensive synergistic solution. Standalone products may communicate with each other e.g. by way of requests and responses however they do not exert any other control over other products in the solution.

An integration is a point of communication between two standalone products for the purpose of sharing resources. In general there are two parties to every integration for example a client and a server. The difference between the two parties is that a client initiates communication by making a request whereas a server listens for connections and responds to requests in order to supply access to its services. Thus a single component may comprise both a client and a server depending on its connections to and interactions with other components.

A client application refers to a standalone application that operates on a client and makes requests of a service for some information or action and a service refers to a standalone application that operates on a server and responds to client application requests. A standalone application is capable of providing functionality to a user independent of its interaction with other applications. Furthermore a standalone application may communicate and interact with a multitude of different services in the case of a client application or a multitude of different client applications in the case of a service . A standalone application may comprise both a client application and a service. However in the following discussion and in the claims a standalone application may be described as either a service or a client application for simplicity.

An endpoint is the implementation of an interface between a client application and a service application. In a distributed architecture such as a REST style web service an endpoint may be defined for example by a set of related Uniform Resource Locators URLs and the Hypertext Transfer Protocol HTTP methods that are valid for those URLs. For example to access a particular version of a service a client application accesses a known endpoint such as a URL and provides requests to the service and receives responses from the service through the endpoint. The endpoint implementation acts as the server in an integration. In some embodiments multiple integrations may be supported between a client and a server.

The following discussion is directed to various embodiments of the invention. Although one or more of these embodiments may be preferred the embodiments disclosed should not be interpreted or otherwise used as limiting the scope of the disclosure including the claims. In addition one skilled in the art will understand that the following description has broad application and the discussion of any embodiment is meant only to be exemplary of that embodiment and not intended to intimate that the scope of the disclosure including the claims is limited to that embodiment.

In accordance with various embodiments automated upgrades to client applications and services are provided in a system to configure or re configure one or more integrations in the system. For example a client application that communicates with a service automatically discovers when the service is upgraded and the client application reconfigures itself to use the newer version of the service without requiring manual intervention by an administrator or IT personnel. Standards used in REST style architectures such as HTTP Atom Syndication Format ASF and Atom Publication Protocol APP are leveraged to allow the client application to reconfigure itself. Incorporating version information in the messages exchanged between the client application and the service allows the products participating in an integration to maintain their relationship automatically and use the latest version of the integration that the client application supports and that the service provides. One skilled in the art would appreciate that various embodiments may leverage different distributed architectures such as Simple Object Access Protocol SOAP .

The functionality added to the existing communication between client applications and services comprises a discovery process and a notification process. The discovery process allows a client application to request from a service what available versions the service supports. Additionally the discovery process allows a service to advertise what available versions the service supports and inform a client application so that the client application may access one or more versions. The notification process facilitates installing a newer version of a service without requiring a manual reconfiguration of an application that is a client application of that service. The new version of the service may be installed in parallel with an existing version of the service. Additionally the notification process facilitates notifying a client application that a newer version of a service is available when the service is upgraded to a newer version.

In accordance with various embodiments a service maintains a service document. The service document is provided regardless of the format used to exchange messages. The service document may be for example an APP service document that is provided regardless of whether messages are exchanged using ASF or any other representation such as HTML or SOAP. The service document specifies all available versions of a service offered and specifies which service endpoint is to be used for each such version. Thus a client application reads the service document when the client application begins using the service which allows the client application to select the appropriate version of the service that the client application supports. When the client application selects the appropriate version of the service the client application also knows the location of the endpoint to use to access the appropriate version of the service. In an exemplary embodiment the client application is initially configured such that the client application is aware of the location of the service document.

In accordance with various embodiments a service is aware of the latest version that it provides. Thus when the service receives a request from a client application that is not associated with the latest version of the service the service sends a response to the client application that includes a notification that a newer version of the service is available. The response also includes the location of the endpoint associated with the newer version of the service or the location of the service document. When the client application receives a notification indicating that a newer version of the service is available the client application accesses the service document to discover the versions provided by the service. Alternatively the client application directly accesses the newer version of the service by using the location of the newer version of the requested service indicated in the notification without first accessing the service document. If the client application does not yet support a newer version e.g. the client application s request is made using its most recent version the client application ignores the new version notification from the server.

A customer for example an IT provider might upgrade Product A on the client to version shown in as a second solution . However Product A on the client is not upgraded and remains as version . For example Product A version may add the ability to request and to receive and use additional diagnostic information in a record produced by Product B. The client does not know whether Product B has been upgraded and thus sends a request to the server using the endpoint . The request does not take advantage of the added functionality of version of Product A e.g. the request does not ask for the additional diagnostic information or a new format of a record produced by Product B because the client does not know whether Product B has been upgraded. The server receives the request and because Product B has not been upgraded sends a response that contains the functionality present in version of Product B as above e.g. the response does not include additional diagnostic information in a record having a new format which is enabled by version of Product A and may be enabled by version of Product B . Thus the client continues to access Product B by way of the endpoint and does not yet take advantage of the additional features of version of Product A.

After Product A on the client has been upgraded the customer might upgrade Product B to version on the server which adds an enhancement to Product B s functionality e.g. the ability to receive a request for a record containing additional diagnostic information sending a response that includes a record containing the additional diagnostic information . This is shown in as a third solution . The server includes two instances of Product B one instance is version and the other instance is version and each instance has its own endpoint respectively. In an alternate embodiment a single instance of Product B provides both version and version of a service. Continuing the above version functionality example Product B version now has the functionality to add additional diagnostic information to a record produced by Product B. Product B s service document is also amended to specify the endpoint of Product B version in addition to the endpoint of the previous version.

Version of Product A on the client is not aware that Product B has been upgraded and thus the next time Product A sends a request to Product B Product A sends the request using the endpoint indicated by the dashed arrow . As a result of receiving a request from either client at the endpoint which does not reflect the latest version of Product B provided by the server the server notifies the client that a newer version of Product B is available and provides a link to the Product B s updated service document or to the new endpoint of the new version of Product B.

The client has not upgraded beyond version of Product A. In some embodiments Product A version is aware that it is already communicating with the highest version endpoint of Product B that Product A version supports and thus Product A version ignores the message from the server that a new version is available. In other embodiments Product A version accesses Product B s updated service document to verify that the client is communicating with the highest version endpoint that Product A version supports.

Unlike the client the client has version of Product A installed and thus is aware that it is not using the additional functionality of version i.e. is still communicating with Product B by way of endpoint which corresponds to functionality present in Product A version and thus does not ignore the message from Product B that a newer version of Product B is available. Upon receiving the message from the server the client determines the location of the endpoint of the newer version of Product B. In an exemplary embodiment the client accesses the service document provided by Product B to discover the latest version of Product B that the client supports and the location of the endpoint associated with that version. In an alternate embodiment the client receives the location of the endpoint associated with the latest version of Product B directly from the server either as a part of the message notifying the client that a newer version of Product B exists or in a separate message from the server .

If the client determines that it supports the newer version of Product B then the client sends future requests to the endpoint of the newer version of Product B using integration . When the server receives a request at the endpoint the server knows that the requesting client possesses the capability to receive enhanced functionality made available by version of Product B. However the client continues to send requests to the endpoint of the older version of Product B because the client cannot yet support the newer version of Product B. In accordance with various embodiments there is no need to configure the individual clients with a new endpoint location each time a service offered by the server is upgraded.

In accordance with various embodiments the above described discovery and notification processes enable the server to inform one or more clients at runtime that a newer version of a service offered by the server is available. Additionally the server informs the one or more clients at runtime which versions of the service are available. Still further the server informs the one or more clients of how to access each version e.g. by associating each version with an endpoint in for example the service document or in a separate notification message . Thus client applications operating on the clients do not need to be reconfigured to identify or access a new version of a service with which the client applications interact.

In accordance with various embodiments the service document of a service represents that more than one version of the service is supported. shows an example of a service document that illustrates using the workspace grouping to advertise two versions of a service. In this example the endpoint of the newer version of the HelpDesk Service contains v2 in its URL to differentiate it from the older version of the HelpDesk Service. However it is not necessary for the URL of version to be different from the URL of version .

In accordance with various embodiments the clients access the service document periodically to determine whether the client is using the latest endpoint for a particular service. In alternate embodiments the server notifies the client in the server s response that a newer version of a service is available through the use of a version element. In some embodiments the version element comprises a link relation 

The method continues with receiving a request from a client associated with the first version of the service block . In an exemplary embodiment the server determines that the request is associated with the first version of the service based on receiving the request at an endpoint that is associated with the first version of the service. The server can provide a newer version of the service than that requested by the client and thus the method continues with sending a response to the client indicating that the server supports the second version of the service block . As discussed above the indication that the server supports the second version takes the form of a notification embedded in the response from the server to the client s request.

If the server receives a communication from the client utilizing the second version of the service decision block then the method continues with the server communicating with the client using the second version of the service block and ends. The server determines that the client supports and thus is utilizing the second version of the service based receiving the communication at the endpoint associated with the second version. If the client does not support and thus does not utilize the second version of the service decision block i.e. continues to communicate using the endpoint then the method continues with the server communicating with the client using the first version of the service block and ends.

The method continues with receiving a response from the server indicating that the server supports a second version of the service block . As discussed above the indication that the server supports the second version takes the form of a notification embedded in the response from the server to the client s request.

If the client supports the second version the service decision block then the method continues with the client communicating with the server using the second version of the service block and ends. The client communicates with the server using functionality of the second version of the service by using the endpoint to access the second version of the service. If the client does not support the second version of the service decision block then the method continues with the client communicating with the server using the first version of the service block through the endpoint and ends.

The above discussion is meant to be illustrative of the principles and various embodiments of the present invention. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

