---

title: Augmented advisory lock mechanism for tightly-coupled clusters
abstract: An inter-machine locking mechanism coordinates the access of shared resources in a tightly-coupled cluster that includes a number of processing systems. When a requesting processing system acquires a lock to access a resource, a comparison is made between values of a global counter and a local counter. The global counter indicates the number of times the lock is acquired exclusively by any of the processing systems. Based on the comparison result, the requesting processing system determines whether the resource has been modified since the last time it held the lock.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08645650&OS=08645650&RS=08645650
owner: Red Hat, Inc.
number: 08645650
owner_city: Raleigh
owner_country: US
publication_date: 20100129
---
Embodiments of the present invention relate to a computer system and more specifically to the management of shared resources in a tightly coupled cluster.

A tightly coupled cluster is a system of multiple machines that share common resources and are typically co located. When machines are sharing resources they need to be careful not to perform simultaneous conflicting operations. For example when one machine is altering a resource the other machines should not be accessing it. Coordination of their operations on the resource can be done by the use of inter machine locks.

Conflicting operations which these inter machine locks prevent generally involve shared resources which are accessible by all of the machines in a cluster. Access to the shared resources e.g. SAN attached disks is typically slower than access to local memory e.g. caches . A machine may save a copy of a shared resource in its local memory. However the local copy may become invalid if the resource in the shared location is modified by other machines. The local copy can be accessed freely while the resource is protected by an inter machine lock but if the lock is released the resource must be validated upon the next lock acquisition. This validation usually comes from re reading the shared resource which is a performance negative operation.

Described herein is a method and system for augmenting an inter machine locking mechanism to include knowledge about whether a shared resource has changed. One purpose of the augmentation is to facilitate the elimination of unnecessary cache validation work. Definitive knowledge of whether or not another system has altered the shared resource allows a caller machine to skip the process of cache validation. This knowledge can be derived from the past history of the lock associated with the shared resource in particular whether the lock has been acquired by another machine for the purpose of modifying the shared resource.

Embodiments of the present invention can be built upon any of a number of known inter machine locking mechanisms that can be either distributed or centralized. The method of augmentation will necessarily vary based on the chosen inter machine locking. In one embodiment the act of tracking whether machines have modified a resource is to monitor whether the lock has been acquired exclusively signaling the intent of an acquirer to modify the resource . The exclusive acquisition of the lock can be monitored by way of counters. A distributed locking manager DLM can be utilized in one embodiment as the inter machine locking mechanism. The DLM provides a range of shared and exclusive locking modes as well as a way to utilize a small amount of inter machine shared memory. The small amount of inter machine shared memory can be used to store a global counter. The global counter is incremented before an exclusive lock is released. This global counter is used to compare against a local non shared counter that is not updated when another machine acquires an exclusive lock but is updated when the local machine acquires either an exclusive or shared lock signaling the intent of the local machine to either modify or read the resource . The comparison result of the two counters indicates whether the resource has been modified since the last time the local machine held the lock.

With the knowledge of the state of the resource a machine upon acquiring a lock can determine whether it can read from a local e.g. cached copy of the resource without accessing a shared location e.g. SAN attached disks for the resource. This is an improvement over the otherwise necessary steps of reading the shared location in order to validate the local copy reprocessing the results to account for any potential changes making modifications locally and then writing the resource to the shared location. As a result the performance of data access can be accelerated.

In the following description numerous details are set forth. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details. In some instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the present invention.

Each processing system may include one or more central processing units CPUs and a local non shared memory such as a cache . Each processing system also includes a lock manager which is responsible for maintaining the inter machine locks. Although not shown in the processing systems may be connected to external networked resources via a network which may be a public network e.g. the Internet or a private network e.g. an Ethernet or a local area Network LAN .

To ensure data coherency each processing system obtains a lock when reading from or writing to a shared resource. The lock is released when the read write operation is completed. Each lock is associated with a shared resource. In one embodiment the locks may be distributed across the processing systems . When a processing system referred to as a requesting machine requests a lock for a shared resource its lock manager identifies or calculates the location of the lock. For example with a distributed inter machine locking mechanism the lock manager may use a lock identifier to calculate a value which can be mapped to a processing system referred to as a lock managing machine that manages and stores the lock. The lock managing machine may store the lock in a data structure in its local memory. With a centralized inter machine locking mechanism a designated machine in the cluster may serve as the lock managing machine for all of the machines in the cluster.

In one embodiment after the lock location is determined the requesting machine sends a lock request to the lock managing machine to acquire the lock. In response the lock managing machine returns an indication of success lock acquired or failure lock acquisition failed to the requesting machine. If the lock is acquired successfully the lock managing machine also returns a small portion of shared memory associated with the lock.

According to embodiments of the present invention a shared global counter is stored in the shared memory associated with the locks provided by the inter machine locking mechanism for example the DLM . Embodiments of the invention use this global counter to keep track of the number of times its associated lock is acquired exclusively by any machine in the cluster. Embodiments of the invention also maintain a non shared local copy of the counter value associated with the lock. Through an augmented Application Programming Interface API a requesting machine which attempts to access shared resources calls functions to compare the local counter value with the global counter value and the returned value of the function indicates to the requesting machine whether another machine has acquired the lock exclusively since it last held the lock. The actions of incrementing and comparing the counters are encapsulated in the functions. If the lock has not been acquired exclusively that is the local counter value is the same as the current value of the global counter it means the shared resource associated with the lock has not been modified by another machine. Therefore the machine can safely use its cached copy of the shared resource. If the lock has been acquired exclusively that is the local counter value is different from the current value of the global counter it means the shared resource associated with the lock has been modified by another machine. Therefore the machine cannot safely use its cached copy of the shared resource.

The global lock structure is used by all of the machines in a cluster through a nominal API or an augmented API. A machine that manages locks through the nominal API does not receive the benefit of advisory information regarding the current state of a shared resource. Alternatively a machine may manage locks through the augmented API according to embodiments of the present invention. The augmented API utilizes the information stored in the internal meta lock structure as well as the information stored in the global lock structure to provide advisory information regarding the current state of a shared resource i.e. whether the shared resource has been modified since the machine last held the lock . In the embodiment of the global lock structure stores the information of a number of locks. Each lock is identified by a lock ID and is associated with a lock mode . A portion of shared memory is used by embodiments of the invention as a global counter .

Embodiments of the present invention provide a number of lock modes to derive advisory information regarding whether a shared resource has been modified. A machine at a given time can hold a lock in the EXCLUSIVE when intending to alter the resource SHARED when intending to read the resource UNLOCK when access to the resource is finished or MONITOR when access to the resource is finished but subsequent access to the resource is expected mode. The lock mode in the global lock structure indicates whether its associated lock is being held in the EXCLUSIVE SHARED or UNLOCK mode. The MONITOR mode is tracked by the internal meta lock structure instead of the global lock structure . In one embodiment the lock mode may include machine specific information. For example the lock mode may indicate that the lock is concurrently held by a first machine and a second machine in the SHARED mode. The global counter indicates the number of times the lock has been acquired exclusively by any of the processing systems .

The internal meta lock structure which is used by the augmented API stores a lock mode a local counter and other lock information . The internal meta lock structure is non shared and is used by the local machine on which the structure resides. The lock mode indicates the mode of the lock EXCLUSIVE SHARED MONITOR or UNLOCK held by the local machine.

The local counter and the global counter operate in cooperation of the lock modes to derive advisory information regarding whether a shared resource has been modified. In one embodiment a lock user e.g. a machine in a cluster can acquire an EXCLUSIVE lock i.e. a lock in the EXCLUSIVE mode when intending to alter the resource or a SHARED lock i.e. a lock in the SHARED mode when intending to read the resource. The lock user can release the lock by placing the lock in the UNLOCK mode when it finishes with the resource. The lock user can change either an EXCLUSIVE lock or a SHARED lock to MONITOR. A lock held in the MONITOR mode by one machine does not conflict with other machines that wish to acquire the same lock. However when the lock is held in the MONITOR mode by a machine and the same machine subsequently acquires the lock in the EXCLUSIVE or SHARED modes the returned value for the lock acquisition can be 1 an error code e.g. when a connection problem occurs 2 success indicating some other machine or machines have grabbed the lock exclusively while the lock is held in the MONITOR mode or 3 success indicating no one else has acquired the lock exclusively while the lock was held in the MONITOR mode. In one embodiment the lock structures and can be hidden from the lock user. Thus the lock users do not see the structures and and do not know about the counters and . The only thing that the lock users receive from the functions of the augmented API are a return value indicating error success resource modified and success resource unmodified . Abstracting the details away from the lock users greatly simplifies the use of the augmented API.

Referring to in one embodiment the method begins when a requesting machine e.g. one of the processing systems intends to access a shared resource. The lock manager of the requesting machine acquires a SHARED or EXCLUSIVE lock associated with the resource through the augmented API of block . For the purpose of this example it is assumed that another machine referred to as a lock managing machine is responsible for maintaining the global lock structure for this lock. If the lock does not exist i.e. a new lock block a new global lock structure and a new internal meta lock structure are created and the corresponding global counter and the local counter are initialized block . The requesting machine then proceeds to acquire an inter machine lock according to the underlying inter machine locking mechanism which can be the DLM or other distributed or centralized locking mechanisms block . If the lock is not new block which means the corresponding structures and already exist the requesting machine proceeds directly to acquire the inter machine lock according to the underlying inter machine locking mechanism block .

At block the requesting machine receives an indication of whether the lock is successfully acquired block . If the lock cannot be successfully acquired an error is returned to the requesting machine block . If the lock is successfully acquired the requesting machine receives an indication of whether or not the shared resource has been modified. In one embodiment the indication is a result of comparing the values of the global counter and the local counter block . After the comparison is performed the value of the global counter is copied to the local counter regardless of the outcome of the comparison blocks and . A global counter value that is equal to the local counter value indicates that the shared resource has not been modified block . Otherwise the shared resource has been modified block .

In an alternative embodiment the information about whether a resource has changed can be derived with a callback mechanism implemented by a lock manager. In this alternative embodiment a lock released into the MONITOR mode by a first machine would have its lock mode recorded as SHARED in the global lock structure . When a second machine requests the lock in the EXCLUSIVE mode the second machine issues a callback to all the other machines to release their locks. Upon receiving the callback the first machine unlocks the SHARED inter machine lock and sets a flag indicating that the resource has been modified because the second machine is acquiring the lock exclusively . Subsequently when the first machine wishes to acquire the lock again it does so with an indication of the flag that the resource has been changed. If between the time the first machine releases the lock and re acquires the lock no other machine had come along requesting an EXCLUSIVE lock the callback would have never occurred and the resource is known to be unaltered.

Embodiments of the present invention provide a simple to use cluster wide locking mechanism that can generally be applicable to a wide range of products. Engineers and programmers can make their products cluster aware without the amount of effort normally required. The augmented locking mechanism has broad usage and promotes robustness in a tightly coupled cluster.

A use case for the augmented locking mechanism is provided below. In one scenario the information about whether a shared resource has been modified can be used to improve the performance of snapshot processing. In this context a snapshot is a point in time copy of a storage device i.e. the Origin . It functions by storing old portions of data from the Origin in a separate area the Copy On Write COW device before overwriting them with new data. Subsequent alterations to the same location on the Origin do not require the COW device to be updated since a copy of the old data from the point in time of the snapshot is already recorded on the COW device. Old versions of the data accumulate in the COW device as new locations in the Origin are changed. When multiple processing systems are sharing a snapshotted storage device they are all responsible for updating the COW device when the Origin changes. Their efforts must be coordinated or conflicting changes will be made to the COW device causing corruption of the information.

When a machine wishes to read from a snapshot the point in time copy of a storage device Origin it first checks the COW device to see if the requested data has been altered and must be retrieved from the COW device. If the data has been changed the old copy is retrieved from the COW device otherwise it is simply read from the Origin. It would be an expensive process if the COW needed to be read every time to check whether or not a particular area of the Origin had changed so this information is cached for quick look ups. A single machine operating a snapshot can be confident that its cache is always correct but in a cluster where the storage is shared another machine may add new entries to the COW device and invalidate the cache. If this situation is not handled a machine requesting snapshot data may incorrectly retrieve the data from the Origin believing the data to be unaltered even though another machine has altered the data and made the appropriate adjustments to the COW device. The situation is handled by acquiring a SHARED lock on the COW device preventing changes to the COW device while reading it and re reading the COW device for any changes that may have occurred. Again the re reading of the COW device is an expensive operation. Embodiments of the invention provide a way of avoiding this expensive operation. When acquiring a lock through the augmented API the machine will know whether or not the lock protecting the resource was acquired exclusively i.e. in the EXCLUSIVE mode . If it has been acquired exclusively the expensive operation of re reading the COW is necessary but if it has not the operation can be avoided and the cache is known to be valid. This benefit becomes more pronounced as the COW device ages fills with old copies of data from the Origin since fewer and fewer alterations will be required and therefore a reduced frequency of machines requiring an EXCLUSIVE lock.

The exemplary computer system includes a processing device a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or Rambus DRAM RDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a secondary memory e.g. a data storage device which communicate with each other via a bus .

The processing device represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processing device may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor processor implementing other instruction sets or processors implementing a combination of instruction sets. The processing device may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. The processing device is configured to execute the locking mechanism for performing the operations and steps discussed herein.

The computer system may further include a network interface device . The computer system also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. a speaker .

The secondary memory may include a machine readable storage medium or more specifically a computer readable storage medium on which is stored one or more sets of instructions e.g. a locking mechanism embodying any one or more of the methodologies or functions described herein e.g. the lock managers of . The locking mechanism may also reside completely or at least partially within the main memory and or within the processing device during execution thereof by the computer system the main memory and the processing device also constituting machine readable storage media. The locking mechanism may further be transmitted or received over a network via the network interface device .

The machine readable storage medium may also be used to store the locking mechanism persistently. While the machine readable storage medium is shown in an exemplary embodiment to be a single medium the term machine readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable storage medium shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine that cause the machine to perform any one or more of the methodologies of the present invention. The term machine readable storage medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media.

The computer system may additionally include locking mechanism modules for implementing the functionalities of the lock managers of . The modules components and other features described herein for example in relation to can be implemented as discrete hardware components or integrated in the functionality of hardware components such as ASICS FPGAs DSPs or similar devices. In addition the modules can be implemented as firmware or functional circuitry within hardware devices. Further the modules can be implemented in any combination of hardware devices and software components.

Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as acquiring incrementing comparing determining or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments of the present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer system selectively programmed by a computer program stored in the computer system. Such a computer program may be stored in a computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic disk storage media optical storage media flash memory devices other type of machine accessible storage media or any type of media suitable for storing electronic instructions each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear as set forth in the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. Although the present invention has been described with reference to specific exemplary embodiments it will be recognized that the invention is not limited to the embodiments described but can be practiced with modification and alteration within the spirit and scope of the appended claims. Accordingly the specification and drawings are to be regarded in an illustrative sense rather than a restrictive sense. The scope of the invention should therefore be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

