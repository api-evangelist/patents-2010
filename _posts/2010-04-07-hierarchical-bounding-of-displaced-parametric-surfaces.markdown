---

title: Hierarchical bounding of displaced parametric surfaces
abstract: Hierarchical bounding of displaced parametric surfaces may be a very common use case for tessellation in interactive and real-time rendering. An efficient normal bounding technique may be used, together with min-max mipmap hierarchies and oriented bounding boxes. This provides substantially faster convergence for the bounding volumes of the displaced surface, without tessellating and displacing the surface in some embodiments. This bounding technique can be used for different types of culling, ray tracing, and to sort higher order primitives in tiling architectures.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08144147&OS=08144147&RS=08144147
owner: Intel Corporation
number: 08144147
owner_city: Santa Clara
owner_country: US
publication_date: 20100407
---
This relates generally to graphics processing and particularly to tessellation in rendering systems such as interactive real time and off line film rendering.

Modern graphics processors contain dedicated hardware for tessellating surfaces into many small triangles. The DirectX 11 application programming interface DX11 API adds three new stages to the graphics pipeline to support tessellation the hull shader the fixed function tessellator and the domain shader. The hull shader is executed once per patch and once per control point typically to compute tessellation factors and change control point bases. The fixed function tessellator takes tessellation factors as inputs and generates a large set of vertex positions in the domain of the input primitive and connectivity information between vertices. The connectivity information forms many small triangles. The domain shader is executed once per generated vertex position from the tessellator. A typical domain shader usage is evaluating the position and normal of a parametric surface using for example a set of control points barycentric coordinates and a detailed texture as inputs. The output is a displaced vertex defined by a set of attributes. One attribute is the position but the shader also can compute the normal tangent bi tangent texture coordinate color transparency or other attribute of the displaced vertex.

Reducing the number of domain shader evaluations reduces the computational resources needed for that stage of a graphics pipeline. This can be done by culling patches which do not contribute to the final image. To make this culling efficient an algorithm for computing hierarchical bounds of displaced surfaces may be used.

Furthermore in tile based rendering architectures bounds for input primitives are needed to efficiently sort the input primitives into tiles. A bounding volume is a volumetric object such as a box or sphere that encloses another object. Since the domain shader is programmable it is hard to give conservative and tight bounds of the output positions which may give rise to a need to sort the generated small triangles individually into tiles. This increases the memory requirements on the tile queues increases bandwidth usage and reduces the efficiency of occlusion culling on a patch primitive level.

These bounds may instead be computed on the fly block based on the domain shader only without any need for a user specified parameter as indicated in . The bounds may then be adaptively refined as the primitive is split into smaller sub patches to create a hierarchy. In one embodiment an algorithm enables conservative and tight bounding of dynamic displaced parametric surfaces such as B zier patches using efficient normal bounding oriented bounding boxes and min max mipmap hierarchies of the displacement texture. The patch may be culled block . If not then the primitive may be subjected to tessellation and domain shading block .

Since the patch does not have to be sent to the tessellator both domain shader and tessellator tasks may be reduced for the patch in some embodiments. If the input patch is culled then no tessellation and domain shading may be done in some embodiments. Similarly if a sub patch is culled no further processing of that sub patch may be done in some embodiments. Otherwise the sub patch is tessellated and domain shaded.

Collections of bi cubic B zier patches are popular rendering primitives for smooth surfaces. Known algorithms may be used for translating Catmull Clark subdivision surfaces to collections of such parametric patches while faithfully approximating the limit surface of the recursive subdivision process. It is common to add displacements from high resolution textures in the direction of the normal vector of the patch in order to increase the detail of the final surface.

The B zier patch with displacement may be used in a domain shader in the rendering API. The B zier patch is compactly represented by its control points and this parametric surface representation can be efficiently evaluated in parallel unlike recursive subdivision surfaces .

A B zier patch p u v is a parametric surface that is a surface defined over two parametric coordinates u and v. The term base patch denotes the B zier patch which has not yet been displaced to distinguish it from the final displaced surface. A domain shader that evaluates a displaced B zier patch at a parametric coordinate u v computes the base patch position p u v the base patch s normalized normal circumflex over n u v and a displacement value usually taken from a texture t u v . If the displacement acts in the base patch s normal direction the domain shader before multiplication with the model view projection matrix is then circumflex over 1 

Multiplying d u v by the model view projection matrix M the clip space position q in homogeneous coordinates is obtained circumflex over 2 

Next we describe how we bound p u v . B zier patches have the convex hull property and they can be easily bounded by their control points. Finding an axis aligned bounding box AABB for a B zier patch accounts for 3 min and 3 max operations per control point.

By repeatedly applying B zier subdivision the control point cages of the subdivided patches converge quickly towards the underlying base patch. Furthermore if the original patch is recursively split in two pieces pand p in each step the de Casteljau steps needed to generate pwill generate the control points for pas a side product. This allows for an efficient implementation.

We can derive axes for an oriented bounding box OBB from the control points of the base patch defined axes. This box encloses the base patch more tightly than an AABB. For each of the two subdivided patches in the same iteration both the base patch the normal patch and the displacement texture and lookup is refined. Referring to which shows steps which are used to compute the bounds of the displaced surface indicated in block in the base patch is subdivided along one axis using B zier subdivision. The base patch bounding indicated in block involves finding the OBB axes from control points and projecting all control points on these axes. Then the minimum and maximum along each axis is located to derive an OBB that contains all of the control points and the convex hull property of B zier patches means that the surface is contained in this OBB.

Next as indicated in block the displacement minimum and maximums are looked up in a min max texture hierarchy. Thereafter in diamond a check determines whether the displacement is zero. If so the model view projection is applied to the eight corners of the patch s bounding box block and the bounds are returned block . If the displacement is not zero normal bounding is done in block using one of the techniques to be described hereinafter called TPATCH and NPATCH before doing the model view projection transform block and returning the bounds block . Finally in block the model view projection transform is applied.

For B zier patches the vectors between the corner control points are summed to get two axes block . Given a patch with m 1 x n 1 control points we denote the four corner control points C c cand c and form the two vectors 3 4 t and b can be seen as approximate average gradients in the u and v parametric directions respectively. They do not have to be orthogonal. Their cross product block gives a third axis n t cross product of b. To form an orthonormal coordinate system we set x t y n cross product of t and z n and normalize each vector block . The final coordinate system is circumflex over x circumflex over z . This significantly reduces the size of the bounding boxes compared to using AABBs in most cases. More elaborate OBB fitting schemes based on the control point cage could be derived but in practice the simple approach above produces axes for OBBs that bound the surface tightly. The difference in quality between bounding with AABBs and OBBs is highlighted in for curves and in for a B zier patch. For degenerate cases we simply use an AABB. As we will show below the OBB axes are also very useful in the normal bounding algorithms.

Bounding the patch normal circumflex over n u v over a domain is considerably more difficult than bounding the base position p u v . The normal direction is computed as the cross product of two parametric derivatives of the base patch p u v .

Following standard notation for tensor product B zier surfaces a B zier patch P u v R Ris defined by 

To apply displacement we need the normalized normal. The normalization operation Equation 11 needs bi degree 2 m n 1 m n 1 for an exact representation of the subexpressions n n and n. For a bi cubic B zier patch these terms can be represented exactly as a bi degree 10 10 B zier patch. In many cases this is prohibitively expensive 11 11 121 control points . Finally the reciprocal square root cannot be represented exactly with Bernstein polynomials. In addition the operand to the reciprocal square root should always be larger than or equal to zero since the operand is the squared length of the normal. If this is not true inf or NaN may result. Therefore the bounded representation of n n nshould be strictly greater than zero. This seems trivial at a first glance as the square root of a sum of three squared real terms should be greater than or equal to zero. However this can be difficult in practice as we use the bounding box of the control point cage for bounding and there is no guarantee that all control points will be positive.

Here we describe a normal bounding algorithm which avoids most of the problems discussed above. In summary normal vector B zier patch is derived from the parametric derivatives block then its control points are projected on the unit sphere block and their solid angle on the unit sphere is bounded in an OBB coordinate frame block which gives a conservative bound of the normalized normal. We denote this normal bounding approach NPATCH.

To conservatively bound the base patch s normal over the patch we exploit the fact that the normal after normalization is of unit length. Therefore we normalize the control vectors v so that they are represented by points on the unit sphere.

A fast way to derive these bounds is to use the i axis from the OBE coordinate frame which is an approximation of the patch s normal and simply compute the minimal scalar product between any normalized control point and the axis. This gives the cosine of the half angle of a cone enclosing the normalized directions. This is illustrated in .

For a bi cubic B zier patch the computation of vincludes 144 cross products. The binomial coefficients can be pre computed in a small lookup table.

Note however that all correlation of which direction corresponds to which parametric coordinate is lost. The tightness of the approach depends on whether the unnormalized normal can be bound reasonably well which can be hard over large domains but becomes easier as the subdomain shrinks.

Coarser bounds can be obtained more quickly by forming two tangent cones from the control points of the first order parametric derivative patches p u and p v see Equations 6 and 7 . The control points of the derivative patches are normalized and bounded on the unit sphere as shown in forming two cones T circumflex over t and B circumflex over b . A cone T is defined by a normalized axis circumflex over t and a half angle .

If the cones T and B do not overlap a cone N circumflex over n that bounds all possible cross products of two vectors one from each of T and B can be constructed. Its axis circumflex over n is in the direction t b and its half angle is given by 

We use the circumflex over t and circumflex over b axes derived above as axes for the cones T and B and the cone angles are found for cones T and B from the parametric derivative patches control points block . The cosine of the cone angle is simply the minimum dot product of any normalized control point from the tangent patch with the circumflex over t circumflex over b axis. A normal cone is derived by computing the cross product of cones T and B block . The bounds for the normalized normal expressed in the OBB coordinate frame are sin sin sin sin cos 1 17 where is the cone half angle of the normal cone N. Using the equality sin cos 1 we can derive the bounds of the normalized normal using the normal cone angle without using any trigonometric functions block . We denote this approach TPATCH.

Care must be taken to check that the two tangent cones do not overlap. The cones overlap if which given 

Techniques for bounding texture lookups involve keeping two extra mipmap hierarchies. The first stores the maximum displacement value over each texture footprint and level and the second stores the minimum displacement value of the footprint. In general when the parametric interval decreases so do the texture bounds.

The final bounds of the displacement vector o circumflex over n t is the product on interval arithmetic form of the interval from the texture lookup t t times the intervals of the normalized normal vector along each axis. Using the notation to define an interval where is the lower limit and is the upper limit multiplication of two intervals is defined by min max 19 Hence the interval version of the x component of o is 20 and similarly for the other components. If the texture displacement is strictly positive then equation 20 can be further optimized.

The last step in most domain shaders is the matrix transformation to clip space so the remaining part in obtaining bounds for q is the model view projection matrix which does not depend on the parametric domain and can be seen as a constant. This constant matrix is easily multiplied with the eight corners of the OBB obtained from the displaced patch d resulting in bounds for the clip space position q. The last step may not be needed when using hierarchical bounds for pre tessellation sorting and ray tracing .

Given an initial coarse subdivision of the patch a priority queue of the bounding boxes of the subdomains may be maintained in some embodiments. For example each sub patch could alternatively be divided into a number of smaller sub patches until each sub patch is small enough in terms of volume surface area or projected area as examples . In each following subdivision step we take the top element of the queue subdivide it further and insert the subdivided boxes back into the queue.

The exact sorting criterion is application dependent and may contain the screen space extents of the bounding box the depth values or prioritize boxes intersecting a frustum plane for view frustum culling. illustrates a view dependent subdivision criterion.

For view frustum culling the OBB corners in clip space are tested against the frustum planes. The subdivision criterion may be designed so that sub patches straddling the camera frustum are prioritized which efficiently culls geometry outside the clip planes. The clip test results of the patch can also be used to guarantee that the entire patch is completely inside the view frustum so the clip tests for generated triangles from the patch can possibly be bypassed.

Given a coarse depth buffer subpatches can be culled if their bounding box is entirely occluded by already drawn primitives. The subdivision criterion may be adopted so that sub patches closer to the camera are processed first and sent to the rasterization stage of the pipeline therefore increasing the likelihood of z culling.

Backface culling is the hardest type of culling due to the difficulty in efficiently bounding the geometric normal after displacement. However given the tessellation rate the normal bounds and a tight interval of the displacement bounds for the displaced surface normal can be derived. Further the subdivision criterion can be adapted to target patches with high normal variation increasing the likelihood of backface culling of subpatches.

After computing a bounded representation of the displaced B zier patch we can use the bounds for pre tessellation sorting into tiles. Tile overlap can be reduced by hierarchical subdivision of the largest screen space bounding box.

In a ray tracing environment the subdivision criterion is tuned to reduce the total surface area of each OBB similar to how a surface area heuristic builds acceleration data structures. In collision detection the subdivision criterion for reduced OBB volumes is tuned.

Hierarchical bounding volumes can be used for culling as well as for sorting into tiles and ray tracing. Using the techniques described herein electronic data may be transformed to a visual form for display on a display.

To efficiently support the DX 11 tessellation pipeline stages in a tiling architecture the bounds of the displaced surfaces are needed before tessellation and domain shading occurs. These bounds can be used to bin i.e. sort primitives into tile specific queues the displaced B zier patches without doing any tessellation. The tessellation and domain shading would then occur when and if needed. The use of hierarchical bounds may be useful for binning view frustum culling occlusion culling and backface culling.

The graphics processing techniques described herein may be implemented in various hardware architectures. For example graphics functionality may be integrated within a chipset. Alternatively a discrete graphics processor may be used. As still another embodiment the graphics functions may be implemented by a general purpose processor including a multicore processor.

The computer system shown in may include a hard drive and a removable medium coupled by a bus to a chipset core logic . A keyboard and mouse or other conventional components may be coupled to the chipset core logic via bus . The core logic may couple to the graphics processor via a bus and the main or host processor in one embodiment. The graphics processor may also be coupled by a bus to a frame buffer . The frame buffer may be coupled by a bus to a display screen . In one embodiment a graphics processor may be a multi threaded multi core parallel processor using single instruction multiple data SIMD architecture.

In the case of a software implementation the pertinent code may be stored in any suitable semiconductor magnetic or optical memory including the main memory or any available memory within the graphics processor. Thus in one embodiment the code to perform the sequences of may be stored in a machine or computer readable medium such as the memory or the graphics processor and may be executed by the processor or the graphics processor in one embodiment.

References throughout this specification to one embodiment or an embodiment mean that a particular feature structure or characteristic described in connection with the embodiment is included in at least one implementation encompassed within the present invention. Thus appearances of the phrase one embodiment or in an embodiment are not necessarily referring to the same embodiment. Furthermore the particular features structures or characteristics may be instituted in other suitable forms other than the particular embodiment illustrated and all such forms may be encompassed within the claims of the present application.

While the present invention has been described with respect to a limited number of embodiments those skilled in the art will appreciate numerous modifications and variations therefrom. It is intended that the appended claims cover all such modifications and variations as fall within the true spirit and scope of this present invention.

