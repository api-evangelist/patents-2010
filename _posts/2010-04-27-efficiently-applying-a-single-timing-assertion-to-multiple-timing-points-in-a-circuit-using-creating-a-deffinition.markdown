---

title: Efficiently applying a single timing assertion to multiple timing points in a circuit using creating a deffinition
abstract: A computer implemented method, system and/or computer program product efficiently manage timing parameters in a circuit. Multiple instances of a definition are implemented onto a circuit. A set of related pins from the multiple instances are defined, and a common assertion value is asserted against all pins in the set of related pins.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08448113&OS=08448113&RS=08448113
owner: International Business Machines Corporation
number: 08448113
owner_city: Armonk
owner_country: US
publication_date: 20100427
---
The present disclosure relates to the field of electronics and specifically to electronic circuits. Still more particularly the present disclosure relates to the timing of electronic circuits.

A computer implemented method system and or computer program product efficiently manage timing parameters in a circuit. Multiple instances of a definition are implemented onto a circuit. A set of related pins from the multiple instances are defined and a common assertion value is asserted against all pins in the set of related pins.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

With reference now to the figures and in particular to there is depicted a block diagram of an exemplary computer which may utilize the present invention. Note that some or all of the exemplary architecture including both depicted hardware and software shown for and within computer may be utilized by software deploying server .

Computer includes a processor that is coupled to a system bus . Processor may utilize one or more processors each of which has one or more processor cores. A video adapter which drives supports a display is also coupled to system bus . In one embodiment a switch couples the video adapter to the system bus . Alternatively the switch may couple the video adapter to the display . In either embodiment the switch is a switch preferably mechanical that allows the display to be coupled to the system bus and thus to be functional only upon execution of instructions e.g. circuitry development and assertion program CDAP described below that support the processes described herein.

System bus is coupled via a bus bridge to an input output I O bus . An I O interface is coupled to I O bus . I O interface affords communication with various I O devices including a keyboard a mouse a media tray which may include storage devices such as CD ROM drives multi media interfaces etc. and a device under test DUT . While the format of the ports connected to I O interface may be any known to those skilled in the art of computer architecture in a preferred embodiment some or all of these ports are universal serial bus USB ports particularly when USB ports are provided for additional I O functionality. Also coupled to system bus is a read only memory ROM which is a static and optionally programmable PROM and or erasable EPROM memory used to store boot programs and other static information.

As depicted computer is able to communicate with a software deploying server via network using a network interface . Network may be an external network such as the Internet or an internal network such as an Ethernet or a virtual private network VPN .

A hard drive interface is also coupled to system bus . Hard drive interface interfaces with a hard drive . In a preferred embodiment hard drive populates a system memory which is also coupled to system bus . System memory is defined as a lowest level of volatile memory in computer . This volatile memory includes additional higher levels of volatile memory not shown including but not limited to cache memory registers and buffers. Data that populates system memory includes computer s operating system OS and application programs .

OS includes a shell for providing transparent user access to resources such as application programs . Generally shell is a program that provides an interpreter and an interface between the user and the operating system. More specifically shell executes commands that are entered into a command line user interface or from a file. Thus shell also called a command processor is generally the highest level of the operating system software hierarchy and serves as a command interpreter. The shell provides a system prompt interprets commands entered by keyboard mouse or other user input media and sends the interpreted command s to the appropriate lower levels of the operating system e.g. a kernel for processing. Note that while shell is a text based line oriented user interface the present invention will equally well support other user interface modes such as graphical voice gestural etc.

As depicted OS also includes kernel which includes lower levels of functionality for OS including providing essential services required by other parts of OS and application programs including memory management process and task management disk management and mouse and keyboard management.

Application programs include a renderer shown in exemplary manner as a browser . Browser includes program modules and instructions enabling a world wide web WWW client i.e. computer to send and receive network messages to the Internet using hypertext transfer protocol HTTP messaging thus enabling communication with software deploying server and other computer systems.

Application programs in computer s system memory as well as software deploying server s system memory also include a circuitry development and assertion program CDAP . CDAP includes code for implementing the processes described below including those described in . In one embodiment computer is able to download CDAP from software deploying server including in an on demand basis wherein the code in CDAP is not downloaded until needed for execution to define and or implement the improved enterprise architecture described herein. Note further that in one embodiment of the present invention software deploying server performs all of the functions associated with the present invention including execution of CDAP thus freeing computer from having to use its own internal computing resources to execute CDAP .

The hardware elements depicted in computer are not intended to be exhaustive but rather are representative to highlight essential components required by the present invention. For instance computer may include alternate memory storage devices such as magnetic cassettes digital versatile disks DVDs Bernoulli cartridges and the like. These and other variations are intended to be within the spirit and scope of the present invention.

Referring now to a circuit which may be the device under test DUT shown in is depicted with multiple instances where c is an integer . For the sake of a simplified description only three instances are depicted. However it is understood that in most embodiments of circuit there will be hundreds thousands or millions of instances as well as hundreds thousands or millions of instances of other definitions DEFs not shown .

The depicted instances are derived from a same DEF. That is a single DEF also known as a sub circuit core abstract macro cell type is used as a template to create multiple identical circuitry units known as instances. Each DEF is of a particular function type such as that of a memory adder comparator buffer etc. While instances may be physical hardware units in one embodiment of the present disclosure instances as well as circuit are software generated simulations of physical hardware. As shown in instance comprises pins as well as other pins not shown . Pins are connection points to other circuitry within circuit including to other pins such as pins and pins for respective instances and . As noted above instances are all derived from a same parent DEF. In one embodiment therefore pins and pins and pins have the same operating parameters including timing rules which define their timing behavior.

Similarly as shown in a circuit may have instances which are derived from a same DEF. The pins of interest with regards to one embodiment of the present disclosure are internal pins where e is an integer which also have timing constraints applied against them.

In order to evaluate the timing of instances with circuit or circuit a static timing analysis STA may be performed. The STA uses software to compute expecting timing within a circuit such as the expected number of time units required for an event from one location to reach another location within the circuit. For example in if pin is connected to pin and pin outputs a signal at time zero then the STA may compute that pin will receive that signal after 25 time units. Signals generated may be from a single pin as just described or they may be from a defined group of pins. The simplest signal would be a logical state transition from high to low or from low to high while more complex signals are a series of logical state transitions.

STA utilizes a set of default rules to predict timing and signal patterns. These default rules which are generally benign to the operation of the circuit are generally known to be inaccurate in some special circumstances. Nonetheless they provide a starting point for predicting timing patterns. Fine tuning of these predicted timing and signal patterns is achieved by applying assertions. An assertion is a user defined constraint that adjusts the default timing pattern. Therefore such assertions define a performance target for the circuit as well as each instance . In some cases a pin may require a one off assertion which is uniquely applied to that pin. However there are other cases in which multiple pins have the same assertion applied to all of the multiple pins. In order to avoid the heavy overhead of looking up each pin by name the present disclosure presents a process efficiently applying a timing assertion to a set of pins whose relationship to each one another is identified by their relationship to structures like DEFs definitions that are defined for the design. This application of assertions is accomplished in a very efficient manner so as to minimize STA runtime. To accomplish this an additional application programming interface API is added to the STA.

Referring now to assume that an STA deploys an STA assertion against a set of pins. For example using the example shown in circuit has the instances which can be identified as MEMORY each of which has five pins. Without the presently disclosed API retrieving the assertions would be performed using pseudocode such as 

As depicted in rather than looking up every name for each of the pins in a sequential and time expensive manner a novel pin to set PTS application program interface API receives the STA assertion . By using logic such as a lookup table offsets to entries in an STA memory etc. the PTS API is able to determine that the STA assertion needs to be applied to all related pins located in the STA memory . Therefore the PTS API returns instructions to the STA instructing the STA to apply the same assertion to all pins in the set of common pins. Thus the following pseudocode can accomplish such assertion retrieval deployment by defining a pin group set pg before the STA memory is completely allocated 

The pin groups are created before the STA memory is complete allocated. This allows efficient memory structures to be built during STA initialization. This may include but is not limited to lookup tables offsets etc. This method does not require any real time name lookups since the STA memory is allocated in a novel fashion. In some implementations name lookups may still be necessary but since this is performed during the STA initialization the lookup is processed in the most efficient manner. Therefore overall runtime improves beyond known state of the art methods.

Alternatively rather than making the groups during an efficient pre initialization phase of timing the STA engine can systematically create memory structures as it loads multiple copies of related structures that include rapid access connections between equivalent points in each copy of the related structures. Thus even after STA initialization is complete an assertion that references one or several pins on all or a subset of copies of the related structures need perform name lookup and other argument computations only once for the first assertion and can then have the repeated assertions applied using the fast internal location method.

In one embodiment if the pin group contains all pins in the instances in the set the run time is improved further since no name lookup is required. That is if all pins are asserted in the same manner then there is no need to look up any pin definitions since the following pseudocode will accomplish this universal assertion 

With reference now to a high level flow chart of exemplary steps taken to manage timing parameters within a circuit by applying a same assertion against related pins is presented. After initiator block a definition is created block . This definition describes a hardware design of a component of a circuit such as an integrated circuit which may be implemented either in hardware or a software simulation. As described in block multiple instances of the definition are implemented onto the circuit. A set of related pins from the multiple instances are then defined as described in block . As described above the related pins share a common performance parameter such as a timing requirement for sending receiving a signal transmitting or responding to an event signal etc. and or share a same parent DEF. These related pins may be internal pins from a single definition which is exploited to generate multiple instances a same pin from multiple instances or a group of pins from multiple instances of a definition. As depicted in block the STA system is initialized by using any pre defined groupings defined in the process depicted in block . As described in block a common assertion value is asserted against all pins in the set of related pins. This common assertion value defines a single constraint used to adjust a default constraint on the related pins. The process ends at terminator block .

The flowchart and block diagrams in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present disclosure. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of various embodiments of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

Note further that any methods described in the present disclosure may be implemented through the use of a Hardware Description Language HDL such as VHDL VHSIC Hardware Description Language or Verilog. HDL s are an exemplary design entry language for Field Programmable Gate Arrays FPGAs Application Specific Integrated Circuits ASICs and other similar electronic devices. Thus any software implemented method described herein may be emulated by a hardware based VHDL program which is then applied to a VHDL chip such as a FPGA.

Having thus described embodiments of the invention of the present application in detail and by reference to illustrative embodiments thereof it will be apparent that modifications and variations are possible without departing from the scope of the invention defined in the appended claims.

